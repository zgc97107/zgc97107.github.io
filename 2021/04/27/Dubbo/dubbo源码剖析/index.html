

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/blog/img/fluid.png">
  <link rel="icon" href="/blog/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="">
  <meta name="keywords" content="">
  
    <meta name="description" content="架构体系框架介绍概述 Dubbo是阿里巴巴公司开源的一个高性能优秀的服务框架，使得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和 Spring框架无缝集成。 Dubbo是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。 相关概念 dubbo运行架构如下图示  节点角色说明  Provider：暴露">
<meta property="og:type" content="article">
<meta property="og:title" content="Dubbo源码剖析">
<meta property="og:url" content="http://zhaoguocheng.gitee.io/2021/04/27/Dubbo/dubbo%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/index.html">
<meta property="og:site_name" content="萤火的博客">
<meta property="og:description" content="架构体系框架介绍概述 Dubbo是阿里巴巴公司开源的一个高性能优秀的服务框架，使得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和 Spring框架无缝集成。 Dubbo是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。 相关概念 dubbo运行架构如下图示  节点角色说明  Provider：暴露">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://zhaoguocheng.gitee.io/blog/2021/04/27/Dubbo/dubbo%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/dubbo-architecture.png">
<meta property="og:image" content="http://zhaoguocheng.gitee.io/blog/2021/04/27/Dubbo/dubbo%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/pic2.png">
<meta property="og:image" content="http://zhaoguocheng.gitee.io/blog/2021/04/27/Dubbo/dubbo%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/pic3.png">
<meta property="og:image" content="http://zhaoguocheng.gitee.io/blog/2021/04/27/Dubbo/dubbo%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/pic4.png">
<meta property="og:image" content="http://zhaoguocheng.gitee.io/blog/2021/04/27/Dubbo/dubbo%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/pic5.png">
<meta property="og:image" content="http://zhaoguocheng.gitee.io/blog/2021/04/27/Dubbo/dubbo%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/pic6.png">
<meta property="og:image" content="http://zhaoguocheng.gitee.io/blog/2021/04/27/Dubbo/dubbo%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/pic7.png">
<meta property="og:image" content="http://zhaoguocheng.gitee.io/blog/2021/04/27/Dubbo/dubbo%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/pic8.png">
<meta property="og:image" content="http://zhaoguocheng.gitee.io/blog/2021/04/27/Dubbo/dubbo%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/pic9.png">
<meta property="og:image" content="http://zhaoguocheng.gitee.io/blog/2021/04/27/Dubbo/dubbo%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/pic10.png">
<meta property="og:image" content="http://zhaoguocheng.gitee.io/blog/2021/04/27/Dubbo/dubbo%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/pic11.png">
<meta property="og:image" content="http://zhaoguocheng.gitee.io/blog/2021/04/27/Dubbo/dubbo%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/pic12.png">
<meta property="og:image" content="http://zhaoguocheng.gitee.io/blog/2021/04/27/Dubbo/dubbo%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/pic13.png">
<meta property="og:image" content="http://zhaoguocheng.gitee.io/blog/2021/04/27/Dubbo/dubbo%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/pic14.png">
<meta property="og:image" content="http://zhaoguocheng.gitee.io/blog/2021/04/27/Dubbo/dubbo%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/pic15.png">
<meta property="og:image" content="http://zhaoguocheng.gitee.io/blog/2021/04/27/Dubbo/dubbo%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/pic16.png">
<meta property="og:image" content="http://zhaoguocheng.gitee.io/blog/2021/04/27/Dubbo/dubbo%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/pic17.png">
<meta property="og:image" content="http://zhaoguocheng.gitee.io/blog/2021/04/27/Dubbo/dubbo%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/pic18.png">
<meta property="og:image" content="http://zhaoguocheng.gitee.io/blog/2021/04/27/Dubbo/dubbo%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/pic19.png">
<meta property="og:image" content="http://zhaoguocheng.gitee.io/blog/2021/04/27/Dubbo/dubbo%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/pic20.png">
<meta property="article:published_time" content="2021-04-27T10:40:44.000Z">
<meta property="article:modified_time" content="2021-04-27T10:40:44.000Z">
<meta property="article:tag" content="dubbo">
<meta property="article:tag" content="源码">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://zhaoguocheng.gitee.io/blog/2021/04/27/Dubbo/dubbo%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/dubbo-architecture.png">
  
  
  
  <title>Dubbo源码剖析 - 萤火的博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/blog/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/blog/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/blog/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"zhaoguocheng.gitee.io","root":"/blog/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/blog/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/blog/js/utils.js" ></script>
  <script  src="/blog/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 5.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/blog/">
      <strong>萤火的博客</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/">
                <i class="iconfont icon-home-fill"></i>
                主页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/blog/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Dubbo源码剖析"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2021-04-27 18:40" pubdate>
          2021年4月27日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          151k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          1260 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Dubbo源码剖析</h1>
            
            
              <div class="markdown-body">
                
                <h3 id="架构体系"><a href="#架构体系" class="headerlink" title="架构体系"></a>架构体系</h3><h4 id="框架介绍"><a href="#框架介绍" class="headerlink" title="框架介绍"></a>框架介绍</h4><p>概述</p>
<p>Dubbo是阿里巴巴公司开源的一个高性能优秀的服务框架，使得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和 Spring框架无缝集成。</p>
<p>Dubbo是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。</p>
<p>相关概念</p>
<p>dubbo运行架构如下图示</p>
<p><img src="/blog/2021/04/27/Dubbo/dubbo%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/dubbo-architecture.png" srcset="/blog/img/loading.gif" lazyload></p>
<p>节点角色说明</p>
<ul>
<li>Provider：暴露服务的服务提供方</li>
<li>Consumer：调用远程服务的服务消费方</li>
<li>Registry：服务注册与发现的注册中心</li>
<li>Monitor：统计服务的调用次数和调用时间的监控中心</li>
<li>Container：服务运行容器</li>
</ul>
<h4 id="调用关系说明"><a href="#调用关系说明" class="headerlink" title="调用关系说明"></a>调用关系说明</h4><ol>
<li><p>服务容器负责启动，加载，运行服务提供者。</p>
</li>
<li><p>服务提供者在启动时，向注册中心注册自己提供的服务。</p>
</li>
<li><p>服务消费者在启动时，向注册中心订阅自己所需的服务。</p>
</li>
<li><p>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</p>
</li>
<li><p>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</p>
</li>
<li><p>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</p>
</li>
</ol>
<p>关于dubbo 的特点分别有连通性、健壮性、伸缩性、以及向未来架构的升级性。特点的详细介绍也可以参考官方文档。</p>
<h4 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h4><p>目前dubbo框架已经交由Apache基金会进行孵化，被在github开源。</p>
<p>Dubbo 社区目前主力维护的有 2.6.x 和 2.7.x 两大版本，其中，</p>
<ul>
<li><p>2.6.x 主要以 bugfifix 和少量 enhancements 为主，因此能完全保证稳定性</p>
</li>
<li><p>2.7.x 作为社区的主要开发版本，得到持续更新并增加了大量新 feature 和优化，同时也带来了一些稳定性挑战</p>
</li>
</ul>
<h4 id="源码拉取"><a href="#源码拉取" class="headerlink" title="源码拉取"></a>源码拉取</h4><p>通过以下的这个命令签出最新的dubbo项目源码,并导入到IDEA中</p>
<p><code>git clone https://github.com/apache/dubbo.git dubbo</code></p>
<h4 id="源码结构"><a href="#源码结构" class="headerlink" title="源码结构"></a><strong>源码结构</strong></h4><p>通过如下图形可以大致的了解到，dubbo源码各个模块的相关作用：</p>
<p><img src="/blog/2021/04/27/Dubbo/dubbo%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/pic2.png" srcset="/blog/img/loading.gif" lazyload></p>
<p>模块说明：</p>
<ul>
<li><p><strong>dubbo-common</strong> <strong>公共逻辑模块</strong>：包括 Util 类和通用模型。</p>
</li>
<li><p><strong>dubbo-remoting</strong> <strong>远程通讯模块</strong>：相当于 Dubbo 协议的实现，如果 RPC 用 RMI协议则不需要使用此包。</p>
</li>
<li><p><strong>dubbo-rpc</strong> <strong>远程调用模块</strong>：抽象各种协议，以及动态代理，只包含一对一的调用，不关心集群的管理。</p>
</li>
<li><p><strong>dubbo-cluster</strong> <strong>集群模块</strong>：将多个服务提供方伪装为一个提供方，包括：负载均衡、容错、路由等，集群的地址列表可以是静态配置的，也可以是由注册中心下发。</p>
</li>
<li><p><strong>dubbo-registry</strong> <strong>注册中心模块</strong>：基于注册中心下发地址的集群方式，以及对各种注册中心的抽象。</p>
</li>
<li><p><strong>dubbo-monitor</strong> <strong>监控模块</strong>：统计服务调用次数，调用时间的，调用链跟踪的服务。</p>
</li>
<li><p><strong>dubbo-config</strong> <strong>配置模块</strong>：是 Dubbo 对外的 API，用户通过 Confifig 使用Dubbo，隐藏 Dubbo 所有细节。</p>
</li>
<li><p><strong>dubbo-container</strong> <strong>容器模块</strong>：是一个 Standlone 的容器，以简单的 Main 加载 Spring 启动，因为服务通常不需要 Tomcat/JBoss 等 Web 容器的特性，没必要用 Web 容器去加载服务。</p>
</li>
</ul>
<h4 id="整体设计"><a href="#整体设计" class="headerlink" title="整体设计"></a>整体设计</h4><p><img src="/blog/2021/04/27/Dubbo/dubbo%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/pic3.png" srcset="/blog/img/loading.gif" lazyload></p>
<p><strong>图例说明：</strong></p>
<ul>
<li><p>图中左边淡蓝背景的为服务消费方使用的接口，右边淡绿色背景的为服务提供方使用的接口，位于中轴线上的为双方都用到的接口。</p>
</li>
<li><p>图中从下至上分为十层，各层均为单向依赖，右边的黑色箭头代表层之间的依赖关系，每一层都可以剥离上层被复用，其中，Service 和 Config 层为 API，其它各层均为 SPI。</p>
</li>
<li><p>图中绿色小块的为扩展接口，蓝色小块为实现类，图中只显示用于关联各层的实现类。</p>
</li>
<li><p>图中蓝色虚线为初始化过程，即启动时组装链，红色实线为方法调用过程，即运行时调时链，紫色三角箭头为继承，可以把子类看作父类的同一个节点，线上的文字为调用的方法。</p>
</li>
</ul>
<p><strong>各层说明：</strong></p>
<ul>
<li><strong>config</strong> <strong>配置层</strong>：对外配置接口，以 ServiceConfig , ReferenceConfig 为中心，可以直接初始化配置类，也可以通过 spring 解析配置生成配置类</li>
<li><strong>proxy</strong> <strong>服务代理层</strong>：服务接口透明代理，生成服务的客户端 Stub 和服务器端 Skeleton, 以 ServiceProxy 为中心，扩展接口为 ProxyFactory </li>
<li><strong>registry</strong> <strong>注册中心层</strong>：封装服务地址的注册与发现，以服务 URL 为中心，扩展接口为RegistryFactory , Registry , RegistryService</li>
<li><strong>cluster</strong> <strong>路由层</strong>：封装多个提供者的路由及负载均衡，并桥接注册中心，以 Invoker 为中心，扩展接口为 Cluster , Directory , Router , LoadBalance</li>
<li><strong>monitor</strong> <strong>监控层</strong>：RPC 调用次数和调用时间监控，以 Statistics 为中心，扩展接口为MonitorFactory , Monitor , MonitorService</li>
<li><strong>protocol</strong> <strong>远程调用层</strong>：封装 RPC 调用，以 Invocation , Result 为中心，扩展接口为Protocol , Invoker , Exporter </li>
<li><strong>exchange</strong> <strong>信息交换层</strong>：封装请求响应模式，同步转异步，以 Request , Response 为中心，扩展接口为 Exchanger , ExchangeChannel , ExchangeClient , ExchangeServer</li>
<li><strong>transport</strong> <strong>网络传输层</strong>：抽象 mina 和 netty 为统一接口，以 Message 为中心，扩展接口为Channel , Transporter , Client , Server , Codec</li>
<li><strong>serialize 数据序列化层</strong>：可复用的一些工具，扩展接口为 Serialization , ObjectInput , ObjectOutput , ThreadPool</li>
</ul>
<h3 id="SPI机制"><a href="#SPI机制" class="headerlink" title="SPI机制"></a>SPI机制</h3><h4 id="SPI的概述"><a href="#SPI的概述" class="headerlink" title="SPI的概述"></a>SPI的概述</h4><h5 id="SPI的主要作用"><a href="#SPI的主要作用" class="headerlink" title="SPI的主要作用"></a>SPI的主要作用</h5><p>SPI 全称为 Service Provider Interface，是一种服务发现机制。SPI 的本质是将接口实现类的全限定名配置在文件中，并由服务加载器读取配置文件，加载实现类。这样可以在运行时，动态为接口替换实现类。正因此特性，我们可以很容易的通过 SPI 机制为我们的程序提供拓展功能。</p>
<p><img src="/blog/2021/04/27/Dubbo/dubbo%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/pic4.png" srcset="/blog/img/loading.gif" lazyload></p>
<p>Java SPI 实际上是“<strong>基于接口的编程＋策略模式＋配置文件</strong>”组合实现的动态加载机制。</p>
<h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><p>首先定义一个接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Robot</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义两个实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OptimusPrime</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Robot</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello，I am OptimusPrime&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bumblebee</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Robot</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello，I am Bumblebee&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>接下来 META-INF/services 文件夹下创建一个文件，名称为 Robot 的全限定名com.itheima.java.spi.Robot。文件内容为实现类的全限定的类名，如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.itheima</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-class">.spi</span><span class="hljs-selector-class">.impl</span><span class="hljs-selector-class">.Bumblebee</span><br><span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.itheima</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-class">.spi</span><span class="hljs-selector-class">.impl</span><span class="hljs-selector-class">.OptimusPrime</span><br></code></pre></td></tr></table></figure>

<p>接下来编写代码进行测试。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SPITest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ServiceLoader&lt;Robot&gt; robots = ServiceLoader.load(Robot.class);<br>        robots.forEach(Robot::sayHello);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>控制台输出如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Hello，I am Bumblebee<br>Hello，I am OptimusPrime<br></code></pre></td></tr></table></figure>

<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>调用过程</p>
<ul>
<li><p>应用程序调用ServiceLoader.load方法，创建一个新的ServiceLoader，并实例化该类中的成员变量</p>
</li>
<li><p>应用程序通过迭代器接口获取对象实例，ServiceLoader先判断成员变量providers对象中(LinkedHashMap&lt;String,S&gt;类型)是否有缓存实例对象，如果有缓存，直接返回。如果没有缓存，执行类的装载</p>
</li>
</ul>
<p>优点</p>
<p>使用 Java SPI 机制的优势是实现解耦，使得接口的定义与具体业务实现分离，而不是耦合在一起。应用进程可以根据实际业务情况启用或替换具体组件。</p>
<p>缺点</p>
<ul>
<li><p>不能按需加载。虽然 ServiceLoader 做了延迟载入，但是基本只能通过遍历全部获取，也就是接口的实现类得全部载入并实例化一遍。如果你并不想用某些实现类，或者某些类实例化很耗时，它也被载入并实例化了，这就造成了浪费。</p>
</li>
<li><p>获取某个实现类的方式不够灵活，只能通过 Iterator 形式获取，不能根据某个参数来获取对应的实现类。</p>
</li>
<li><p>多个并发多线程使用 ServiceLoader 类的实例是不安全的。</p>
</li>
<li><p>加载不到实现类时抛出并不是真正原因的异常，错误很难定位。</p>
</li>
</ul>
<h4 id="Dubbo中的SPI"><a href="#Dubbo中的SPI" class="headerlink" title="Dubbo中的SPI"></a>Dubbo中的SPI</h4><p><strong>概述</strong></p>
<p>Dubbo 并未使用 Java SPI，而是重新实现了一套功能更强的 SPI 机制。Dubbo SPI 的相关逻辑被封装在了 ExtensionLoader 类中，通过 ExtensionLoader，我们可以加载指定的实现类。</p>
<p><strong>案例</strong></p>
<p>与 Java SPI 实现类配置不同，Dubbo SPI 是通过键值对的方式进行配置，这样我们可以按需加载指定的实现类。下面来演示 Dubbo SPI 的用法：</p>
<p>Dubbo SPI 所需的配置文件需放置在 META-INF/dubbo 路径下，与 Java SPI 实现类配置不同，Dubbo SPI 是通过键值对的方式进行配置，配置内容如下。</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">optimusPrime</span> = <span class="hljs-string">org.apache.spi.OptimusPrime</span><br><span class="hljs-attr">bumblebee</span> = <span class="hljs-string">org.apache.spi.Bumblebee</span><br></code></pre></td></tr></table></figure>

<p>在使用Dubbo SPI 时，需要在接口上标注 @SPI 注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SPI</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Robot</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过 ExtensionLoader，我们可以加载指定的实现类，下面来演示 Dubbo SPI ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DubboSPITest</span> </span>&#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        ExtensionLoader&lt;Robot&gt; extensionLoader = ExtensionLoader.getExtensionLoader(Robot.class);<br>        Robot optimusPrime = extensionLoader.getExtension(<span class="hljs-string">&quot;optimusPrime&quot;</span>);<br>        optimusPrime.sayHello();<br>        Robot bumblebee = extensionLoader.getExtension(<span class="hljs-string">&quot;bumblebee&quot;</span>);<br>        bumblebee.sayHello();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>控制台输出如下：</p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">Hello</span>，<span class="hljs-built_in">I</span> <span class="hljs-variable">am</span> <span class="hljs-variable">Bumblebee</span><br><span class="hljs-variable">Hello</span>，<span class="hljs-built_in">I</span> <span class="hljs-variable">am</span> <span class="hljs-variable">OptimusPrime</span><br></code></pre></td></tr></table></figure>

<p>Dubbo SPI 除了支持按需加载接口实现类，还增加了 IOC 和 AOP 等特性，这些特性将会在接下来的源码分析章节中一一进行介绍。</p>
<p>源码分析</p>
<p>Dubbo SPI 的使用过程为：通过 ExtensionLoader 的 getExtensionLoader 方法获取一个 ExtensionLoader 实例，然后再通过 ExtensionLoader 的 getExtension 方法获取拓展类对象。</p>
<p>ExtensionLoader 的 getExtension() 方法的源码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getExtension</span><span class="hljs-params">(String name, <span class="hljs-keyword">boolean</span> wrap)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (StringUtils.isEmpty(name)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Extension name == null&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;true&quot;</span>.equals(name)) &#123;<br>        <span class="hljs-comment">// 获取默认的拓展实现类</span><br>        <span class="hljs-keyword">return</span> getDefaultExtension();<br>    &#125;<br>    <span class="hljs-comment">// holder用于持有目标对象</span><br>    <span class="hljs-keyword">final</span> Holder&lt;Object&gt; holder = getOrCreateHolder(name);<br>    Object instance = holder.get();<br>    <span class="hljs-comment">// 双重检查</span><br>    <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">synchronized</span> (holder) &#123;<br>            instance = holder.get();<br>            <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// 创建拓展实例</span><br>                instance = createExtension(name, wrap);<br>                <span class="hljs-comment">// 设置实例到holder中</span><br>                holder.set(instance);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> (T) instance;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面代码的逻辑比较简单，首先检查缓存，缓存未命中则创建拓展对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> T <span class="hljs-title">createExtension</span><span class="hljs-params">(String name, <span class="hljs-keyword">boolean</span> wrap)</span> </span>&#123;<br>    <span class="hljs-comment">// 从配置文件中加载所有的拓展类，可得到配置项名称和配置类的映射关系表</span><br>    Class&lt;?&gt; clazz = getExtensionClasses().get(name);<br>    <span class="hljs-keyword">if</span> (clazz == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> findException(name);<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        T instance = (T) EXTENSION_INSTANCES.get(clazz);<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 通过反射创建实例</span><br>            EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.getDeclaredConstructor().newInstance());<br>            instance = (T) EXTENSION_INSTANCES.get(clazz);<br>        &#125;<br>        <span class="hljs-comment">// 向实例中注入依赖</span><br>        injectExtension(instance);<br><br><br>        <span class="hljs-keyword">if</span> (wrap) &#123;<br><br>            List&lt;Class&lt;?&gt;&gt; wrapperClassesList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>            <span class="hljs-keyword">if</span> (cachedWrapperClasses != <span class="hljs-keyword">null</span>) &#123;<br>                wrapperClassesList.addAll(cachedWrapperClasses);<br>                wrapperClassesList.sort(WrapperComparator.COMPARATOR);<br>                Collections.reverse(wrapperClassesList);<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (CollectionUtils.isNotEmpty(wrapperClassesList)) &#123;<br>                <span class="hljs-comment">// 循环创建 wrapper 实例</span><br>                <span class="hljs-keyword">for</span> (Class&lt;?&gt; wrapperClass : wrapperClassesList) &#123;<br>                    Wrapper wrapper = wrapperClass.getAnnotation(Wrapper.class);<br>                    <span class="hljs-keyword">if</span> (wrapper == <span class="hljs-keyword">null</span><br>                            || (ArrayUtils.contains(wrapper.matches(), name) &amp;&amp; !ArrayUtils.contains(wrapper.mismatches(), name))) &#123;<br>                        <span class="hljs-comment">// 将当前instance作为参数川味wrapper的构造方法，并通过反射创建wrapper实例</span><br>                        <span class="hljs-comment">// 然后向wrapper实例中注入依赖，最后将wrapper实例再次赋值给instance变量</span><br>                        instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        initExtension(instance);<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;Extension instance (name: &quot;</span> + name + <span class="hljs-string">&quot;, class: &quot;</span> +<br>                type + <span class="hljs-string">&quot;) couldn&#x27;t be instantiated: &quot;</span> + t.getMessage(), t);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>createExtension 方法的逻辑稍复杂一下，包含了如下的步骤：</p>
<ol>
<li><p>通过 getExtensionClasses 获取所有的拓展类</p>
</li>
<li><p>通过反射创建拓展对象</p>
</li>
<li><p>向拓展对象中注入依赖</p>
</li>
<li><p>将拓展对象包裹在相应的 Wrapper 对象中</p>
</li>
</ol>
<p>以上步骤中，第一个步骤是加载拓展类的关键，第三和第四个步骤是 Dubbo IOC 与 AOP 的具体实现。由于此类涉及源码较多，这里简单的总结下ExtensionLoader整个执行逻辑：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livescript">getExtension(<span class="hljs-built_in">String</span> name) <span class="hljs-comment">#根据key获取拓展对象</span><br><span class="hljs-function">	--&gt;</span>createExtension(<span class="hljs-built_in">String</span> name) <span class="hljs-comment">#创建拓展实例</span><br><span class="hljs-function">		--&gt;</span>getExtensionClasses <span class="hljs-comment">#根据路径获取所有的拓展类</span><br><span class="hljs-function">			--&gt;</span>loadExtensionClasses <span class="hljs-comment">#加载拓展类</span><br><span class="hljs-function">				--&gt;</span>cacheDefaultExtensionName <span class="hljs-comment">#解析@SPI注解</span><br><span class="hljs-function">			--&gt;</span>loadDirectory <span class="hljs-comment">#方法加载指定文件夹配置文件</span><br><span class="hljs-function">				--&gt;</span>loadResource <span class="hljs-comment">#加载资源</span><br><span class="hljs-function">					--&gt;</span>loadClass <span class="hljs-comment">#加载类，并通过 loadClass 方法对类进行缓存</span><br></code></pre></td></tr></table></figure>

<h4 id="SPI中的IOC和AOP"><a href="#SPI中的IOC和AOP" class="headerlink" title="SPI中的IOC和AOP"></a>SPI中的IOC和AOP</h4><h5 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> T <span class="hljs-title">injectExtension</span><span class="hljs-params">(T instance)</span> </span>&#123;<br><br>    <span class="hljs-keyword">if</span> (objectFactory == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 遍历目标类的所有方法</span><br>        <span class="hljs-keyword">for</span> (Method method : instance.getClass().getMethods()) &#123;<br>            <span class="hljs-comment">// 判断是否为public修饰的set方法，且仅有一个参数</span><br>            <span class="hljs-keyword">if</span> (!isSetter(method)) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * Check &#123;<span class="hljs-doctag">@link</span> DisableInject&#125; to see if we need auto injection for this property</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-keyword">if</span> (method.getAnnotation(DisableInject.class) != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">// 获取setter方法参数类型</span><br>            Class&lt;?&gt; pt = method.getParameterTypes()[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">if</span> (ReflectUtils.isPrimitives(pt)) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 获取属性名，如setName方法属性名为name</span><br>                String property = getSetterProperty(method);<br>                <span class="hljs-comment">// 从objectFactory中获取依赖对象</span><br>                Object object = objectFactory.getExtension(pt, property);<br>                <span class="hljs-keyword">if</span> (object != <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-comment">// 通过反射调用setter方法设置依赖</span><br>                    method.invoke(instance, object);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                logger.error(<span class="hljs-string">&quot;Failed to inject via method &quot;</span> + method.getName()<br>                        + <span class="hljs-string">&quot; of interface &quot;</span> + type.getName() + <span class="hljs-string">&quot;: &quot;</span> + e.getMessage(), e);<br>            &#125;<br><br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        logger.error(e.getMessage(), e);<br>    &#125;<br>    <span class="hljs-keyword">return</span> instance;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上面代码中，objectFactory 变量的类型为 AdaptiveExtensionFactory，AdaptiveExtensionFactory内部维护了一个 ExtensionFactory 列表，用于存储其他类型的 ExtensionFactory。Dubbo 目前提供了两种 ExtensionFactory，分别是 SpiExtensionFactory 和 SpringExtensionFactory。前者用于创建自适应的拓展，后者是用于从 Spring 的 IOC 容器中获取所需的拓展。这两个类的类的代码不是很复杂，这里就不一一分析了。</p>
<p>Dubbo IOC 目前仅支持 setter 方式注入，总的来说，逻辑比较简单易懂。</p>
<h5 id="动态增强"><a href="#动态增强" class="headerlink" title="动态增强"></a>动态增强</h5><p>在Dubbo中，有一种特殊的类，被称为Wrapper类。通过装饰者模式，使用包装类包装原始的扩展点实例。在原始扩展点实现前后插入其他逻辑，实现AOP功能。</p>
<p><strong>装饰者模式</strong></p>
<p>装饰者模式：在不改变原类文件以及不使用继承的情况下，动态地将责任附加到对象上，从而实现动态拓展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。</p>
<p><img src="/blog/2021/04/27/Dubbo/dubbo%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/pic5.png" srcset="/blog/img/loading.gif" lazyload></p>
<p>一般来说装饰者模式有下面几个参与者：</p>
<ul>
<li><p>Component：装饰者和被装饰者共同的父类，是一个接口或者抽象类，用来定义基本行为</p>
</li>
<li><p>ConcreteComponent：定义具体对象，即被装饰者</p>
</li>
<li><p>Decorator：抽象装饰者，继承自Component，从外类来扩展ConcreteComponent。对于ConcreteComponent来说，不需要知道Decorator的存在，Decorator是一个接口或抽象类</p>
</li>
<li><p>ConcreteDecorator：具体装饰者，用于扩展ConcreteComponent</p>
</li>
</ul>
<p>注：装饰者和被装饰者对象有相同的超类型，因为装饰者和被装饰者必须是一样的类型，这里利用继承是为了达到类型匹配，而不是利用继承获得行为。</p>
<p><strong>dubbo中的AOP</strong></p>
<p>Dubbo AOP 是通过装饰者模式完成的，接下来通过一个简单的案例来学习dubbo中AOP的实现方式。</p>
<p>首先定义一个接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.dubbo;<br><span class="hljs-keyword">import</span> org.apache.dubbo.common.extension.SPI; <br><span class="hljs-meta">@SPI</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Phone</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义接口的实现类，也就是被装饰者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.dubbo;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IphoneX</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Phone</span> </span>&#123;<br>  <span class="hljs-meta">@Override</span> <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">()</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;iphone正在拨打电话&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>为了简单，这里省略了装饰者接口。仅仅定义一个装饰者，实现phone接口，内部配置增强逻辑方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.dubbo;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MusicPhone</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Phone</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> Phone phone;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MusicPhone</span><span class="hljs-params">(Phone phone)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.phone = phone;<br>  &#125;<br>  <br>  <span class="hljs-meta">@Override</span> <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">()</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;播放彩铃&quot;</span>); <span class="hljs-keyword">this</span>.phone.call();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>添加拓展点配置文件META-INF/dubbo/com.itheima.dubbo.Phone，内容如下</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">iphone</span> = com.itheima.dubbo.IphoneX<br><span class="hljs-attr">filter</span> = com.itheima.dubbo.MusicPhone<br></code></pre></td></tr></table></figure>

<p>配置测试方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>  ExtensionLoader&lt;Phone&gt; extensionLoader = ExtensionLoader.getExtensionLoader(Phone.class); <br>  Phone phone = extensionLoader.getExtension(<span class="hljs-string">&quot;iphone&quot;</span>);<br>  phone.call();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Dubbo源码中相关逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (CollectionUtils.isNotEmpty(wrapperClassesList)) &#123;<br>    <span class="hljs-comment">// 循环创建 wrapper 实例</span><br>    <span class="hljs-keyword">for</span> (Class&lt;?&gt; wrapperClass : wrapperClassesList) &#123;<br>        Wrapper wrapper = wrapperClass.getAnnotation(Wrapper.class);<br>        <span class="hljs-keyword">if</span> (wrapper == <span class="hljs-keyword">null</span><br>                || (ArrayUtils.contains(wrapper.matches(), name) &amp;&amp; !ArrayUtils.contains(wrapper.mismatches(), name))) &#123;<br>            <span class="hljs-comment">// 将当前instance作为参数传入wrapper的构造方法，并通过反射创建wrapper实例</span><br>            <span class="hljs-comment">// 然后向wrapper实例中注入依赖，最后将wrapper实例再次赋值给instance变量</span><br>            instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="动态编译"><a href="#动态编译" class="headerlink" title="动态编译"></a>动态编译</h4><p>在 Dubbo 中，很多拓展都是通过 SPI 机制 进行加载的，比如 Protocol、Cluster、LoadBalance、ProxyFactory 等。有时，有些拓展并不想在框架启动阶段被加载，而是希望在拓展方法被调用时，根据运行时参数进行加载，即根据参数动态加载实现类。</p>
<p>这种在运行时，根据方法参数才动态决定使用具体的拓展，在dubbo中就叫做扩展点自适应实例。其实是一个扩展点的代理，将扩展的选择从Dubbo启动时，延迟到RPC调用时。Dubbo中每一个扩展点都有一个自适应类，如果没有显式提供，Dubbo会自动为我们创建一个，默认使用Javaassist创建。</p>
<p><strong>自适应拓展机制的实现逻辑是这样的</strong></p>
<ol>
<li><p>首先 Dubbo 会为拓展接口生成具有代理功能的代码；</p>
</li>
<li><p>通过 javassist 或 jdk 编译这段代码，得到 Class 类；</p>
</li>
<li><p>通过反射创建代理类；</p>
</li>
<li><p>在代理类中，通过URL对象的参数来确定到底调用哪个实现类；</p>
</li>
</ol>
<h5 id="javassist入门"><a href="#javassist入门" class="headerlink" title="javassist入门"></a>javassist入门</h5><p>Javassist是一个开源的分析、编辑和创建Java字节码的类库。是由东京工业大学的数学和计算机科学系的 Shigeru Chiba （千叶滋）所创建的。它已加入了开放源代码JBoss 应用服务器项目,通过使用Javassist对字节码操作为JBoss实现动态AOP框架。javassist是jboss的一个子项目，其主要的优点，在于简单，而且快速。直接使用java编码的形式，而不需要了解虚拟机指令，就能动态改变类的结构，或者动态生成类。为了方便更好的理解dubbo中的自适应，这里通过案例的形式来熟悉下Javassist的基本使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.javassist.compiler;<br><br><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.io.FileOutputStream;<br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.lang.reflect.Modifier;<br><br><span class="hljs-keyword">import</span> javassist.ClassPool;<br><span class="hljs-keyword">import</span> javassist.CtClass;<br><span class="hljs-keyword">import</span> javassist.CtConstructor;<br><span class="hljs-keyword">import</span> javassist.CtField;<br><span class="hljs-keyword">import</span> javassist.CtMethod;<br><span class="hljs-keyword">import</span> javassist.CtNewMethod;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  Javassist是一个开源的分析、编辑和创建Java字节码的类库</span><br><span class="hljs-comment"> *  能动态改变类的结构，或者动态生成类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CompilerByJavassist</span> </span>&#123;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>      <span class="hljs-comment">// ClassPool：class对象容器</span><br>      ClassPool pool = ClassPool.getDefault();<br><br>      <span class="hljs-comment">// 通过ClassPool生成一个User类</span><br>      CtClass ctClass = pool.makeClass(<span class="hljs-string">&quot;com.itheima.javassist.domain.User&quot;</span>);<br><br>      <span class="hljs-comment">// 添加属性     -- private String username</span><br>      CtField enameField = <span class="hljs-keyword">new</span> CtField(pool.getCtClass(<span class="hljs-string">&quot;java.lang.String&quot;</span>),<br>            <span class="hljs-string">&quot;username&quot;</span>, ctClass);<br><br>      enameField.setModifiers(Modifier.PRIVATE);<br><br>      ctClass.addField(enameField);<br><br>      <span class="hljs-comment">// 添加属性    -- private int age</span><br>      CtField enoField = <span class="hljs-keyword">new</span> CtField(pool.getCtClass(<span class="hljs-string">&quot;int&quot;</span>), <span class="hljs-string">&quot;age&quot;</span>, ctClass);<br><br>      enoField.setModifiers(Modifier.PRIVATE);<br><br>      ctClass.addField(enoField);<br><br>      <span class="hljs-comment">//添加方法</span><br>      ctClass.addMethod(CtNewMethod.getter(<span class="hljs-string">&quot;getUsername&quot;</span>, enameField));<br>      ctClass.addMethod(CtNewMethod.setter(<span class="hljs-string">&quot;setUsername&quot;</span>, enameField));<br>      ctClass.addMethod(CtNewMethod.getter(<span class="hljs-string">&quot;getAge&quot;</span>, enoField));<br>      ctClass.addMethod(CtNewMethod.setter(<span class="hljs-string">&quot;setAge&quot;</span>, enoField));<br><br><br>      <span class="hljs-comment">// 无参构造器</span><br>      CtConstructor constructor = <span class="hljs-keyword">new</span> CtConstructor(<span class="hljs-keyword">null</span>, ctClass);<br>      constructor.setBody(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>);<br>      ctClass.addConstructor(constructor);<br><br>      <span class="hljs-comment">// 添加构造函数</span><br>      <span class="hljs-comment">//ctClass.addConstructor(new CtConstructor(new CtClass[] &#123;&#125;, ctClass));</span><br><br>      CtConstructor ctConstructor = <span class="hljs-keyword">new</span> CtConstructor(<span class="hljs-keyword">new</span> CtClass[] &#123;pool.get(String.class.getName()),CtClass.intType&#125;, ctClass);<br>      ctConstructor.setBody(<span class="hljs-string">&quot;&#123;\n this.username=$1; \n this.age=$2;\n&#125;&quot;</span>);<br>      ctClass.addConstructor(ctConstructor);<br><br>      <span class="hljs-comment">// 添加自定义方法</span><br>      CtMethod ctMethod = <span class="hljs-keyword">new</span> CtMethod(CtClass.voidType, <span class="hljs-string">&quot;printUser&quot;</span>,<span class="hljs-keyword">new</span> CtClass[] &#123;&#125;, ctClass);<br>      <span class="hljs-comment">// 为自定义方法设置修饰符</span><br>      ctMethod.setModifiers(Modifier.PUBLIC);<br>      <span class="hljs-comment">// 为自定义方法设置函数体</span><br>      StringBuffer buffer2 = <span class="hljs-keyword">new</span> StringBuffer();<br>      buffer2.append(<span class="hljs-string">&quot;&#123;\nSystem.out.println(\&quot;用户信息如下\&quot;);\n&quot;</span>)<br>            .append(<span class="hljs-string">&quot;System.out.println(\&quot;用户名=\&quot;+username);\n&quot;</span>)<br>            .append(<span class="hljs-string">&quot;System.out.println(\&quot;年龄=\&quot;+age);\n&quot;</span>).append(<span class="hljs-string">&quot;&#125;&quot;</span>);<br>      ctMethod.setBody(buffer2.toString());<br>      ctClass.addMethod(ctMethod);<br><br>      <span class="hljs-comment">//生成一个class</span><br>      Class&lt;?&gt; clazz = ctClass.toClass();<br><br>      Constructor cons2 = clazz.getDeclaredConstructor(String.class,Integer.TYPE);<br><br>      Object obj = cons2.newInstance(<span class="hljs-string">&quot;itheima&quot;</span>,<span class="hljs-number">20</span>);<br><br>      <span class="hljs-comment">//反射 执行方法</span><br>      obj.getClass().getMethod(<span class="hljs-string">&quot;printUser&quot;</span>, <span class="hljs-keyword">new</span> Class[] &#123;&#125;)<br>            .invoke(obj, <span class="hljs-keyword">new</span> Object[] &#123;&#125;);<br><br>      <span class="hljs-comment">// 把生成的class文件写入文件</span><br>      <span class="hljs-keyword">byte</span>[] byteArr = ctClass.toBytecode();<br>      FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;D://User.class&quot;</span>));<br>      fos.write(byteArr);<br>      fos.close();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过以上代码，我们可以知道javassist可以在运行时，按需进行java对象的动态创建，并执行内部方法，这也是dubbo中动态编译的核心。</p>
<h5 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h5><p>Adaptive注解</p>
<p>在开始之前，我们有必要先看一下与自适应拓展息息相关的一个注解，即 Adaptive 注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Adaptive &#123;<br>  String[] value() <span class="hljs-keyword">default</span> &#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从上面的代码中可知，Adaptive 可注解在类或方法上。</p>
<ul>
<li><p>标注在类上：Dubbo 不会为该类生成代理类。</p>
</li>
<li><p>标注在方法上：Dubbo 则会为该方法生成代理逻辑，表示当前方法需要根据参数URL调用对应的扩展点实现。</p>
</li>
</ul>
<p>获取自适应拓展类</p>
<p>dubbo中每一个扩展点都有一个自适应类，如果没有显式提供，Dubbo会自动为我们创建一个，默认使用Javaassist创建。 先来看下创建自适应扩展类的代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getAdaptiveExtension</span><span class="hljs-params">()</span> </span>&#123;<br>    Object instance = cachedAdaptiveInstance.get();<br>    <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (createAdaptiveInstanceError != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;Failed to create adaptive instance: &quot;</span> +<br>                    createAdaptiveInstanceError.toString(),<br>                    createAdaptiveInstanceError);<br>        &#125;<br><br>        <span class="hljs-keyword">synchronized</span> (cachedAdaptiveInstance) &#123;<br>            instance = cachedAdaptiveInstance.get();<br>            <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    instance = createAdaptiveExtension();<br>                    cachedAdaptiveInstance.set(instance);<br>                &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>                    createAdaptiveInstanceError = t;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;Failed to create adaptive instance: &quot;</span> + t.toString(), t);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> (T) instance;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>继续看createAdaptiveExtension方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> T <span class="hljs-title">createAdaptiveExtension</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> injectExtension((T) getAdaptiveExtensionClass().newInstance());<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;Can&#x27;t create adaptive extension &quot;</span> + type + <span class="hljs-string">&quot;, cause: &quot;</span> + e.getMessage(), e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>继续看getAdaptiveExtensionClass方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Class&lt;?&gt; getAdaptiveExtensionClass() &#123;<br>    getExtensionClasses();<br>    <span class="hljs-keyword">if</span> (cachedAdaptiveClass != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> cachedAdaptiveClass;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cachedAdaptiveClass = createAdaptiveExtensionClass();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>继续看createAdaptiveExtensionClass方法，绕了一大圈，终于来到了具体的实现了。看这个createAdaptiveExtensionClass方法，它首先会生成自适应类的Java源码，然后再将源码编译成Java的字节码，加载到JVM中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Class&lt;?&gt; createAdaptiveExtensionClass() &#123;<br>    String code = <span class="hljs-keyword">new</span> AdaptiveClassCodeGenerator(type, cachedDefaultName).generate();<br>    ClassLoader classLoader = findClassLoader();<br>    org.apache.dubbo.common.compiler.Compiler compiler = ExtensionLoader.getExtensionLoader(org.apache.dubbo.common.compiler.Compiler.class).getAdaptiveExtension();<br>    <span class="hljs-keyword">return</span> compiler.compile(code, classLoader);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Compiler的代码，默认实现是javassist。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SPI(&quot;javassist&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Compiler</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Compile java source code.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> code        Java source code</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> classLoader classloader</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> Compiled class</span><br><span class="hljs-comment">     */</span><br>    Class&lt;?&gt; compile(String code, ClassLoader classLoader);<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>createAdaptiveExtensionClassCode()方法中使用一个StringBuilder来构建自适应类的Java源码。方法实现比较长，这里就不贴代码了。这种生成字节码的方式也挺有意思的，先生成Java源代码，然后编译，加载到jvm中。通过这种方式，可以更好的控制生成的Java类。而且这样也不用care各个字节码生成框架的api等。因为xxx.java文件是Java通用的，也是我们最熟悉的。只是代码的可读性不强，需要一点一点构建xx.java的内容。</p>
<h3 id="服务暴露与发现"><a href="#服务暴露与发现" class="headerlink" title="服务暴露与发现"></a>服务暴露与发现</h3><h4 id="dubbo与spring的整合"><a href="#dubbo与spring的整合" class="headerlink" title="dubbo与spring的整合"></a>dubbo与spring的整合</h4><h5 id="Spring自定义Schema"><a href="#Spring自定义Schema" class="headerlink" title="Spring自定义Schema"></a>Spring自定义Schema</h5><p>Dubbo 现在的设计是完全无侵入，也就是使用者只依赖于配置契约。在 Dubbo 中，可以使用 XML 配置相关信息，也可以用来引入服务或者导出服务。配置完成，启动工程，Spring 会读取配置文件，生成注入相关Bean。那 Dubbo 如何实现自定义 XML 被 Spring 加载读取呢？</p>
<p>从 Spring 2.0 开始，Spring 开始提供了一种基于 XML Schema 格式扩展机制，用于定义和配置bean。</p>
<p>入门案例</p>
<p>学习和使用Spring XML Schema 扩展机制并不难，需要下面几个步骤：</p>
<ol>
<li>创建配置属性的JavaBean对象</li>
<li>创建一个 XML Schema 文件，描述自定义的合法构建模块，也就是xsd文件。</li>
<li>自定义处理器类，并实现 NamespaceHandler 接口。</li>
<li>自定义解析器，实现 BeanDefinitionParser 接口(最关键的部分)。 </li>
<li>编写Spring.handlers和Spring.schemas文件配置所有部件。</li>
</ol>
<p>定义JavaBean对象，在spring中此对象会根据配置自动创建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> String id;<br>  <span class="hljs-keyword">private</span> String name;<br>  <span class="hljs-keyword">private</span> Integer age;<br>  <span class="hljs-comment">//省略getter setter方法</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在META-INF下定义 user.xsd 文件，使用xsd用于描述标签的规则</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">xsd:schema</span>   </span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.itheima.com/schema/user&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:xsd</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span>   </span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:beans</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span>  </span><br><span class="hljs-tag">    <span class="hljs-attr">targetNamespace</span>=<span class="hljs-string">&quot;http://www.itheima.com/schema/user&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">elementFormDefault</span>=<span class="hljs-string">&quot;qualified&quot;</span>   </span><br><span class="hljs-tag">    <span class="hljs-attr">attributeFormDefault</span>=<span class="hljs-string">&quot;unqualified&quot;</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">xsd:import</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span> /&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">xsd:element</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">xsd:complexType</span>&gt;</span>  <br>            <span class="hljs-tag">&lt;<span class="hljs-name">xsd:complexContent</span>&gt;</span>  <br>                <span class="hljs-tag">&lt;<span class="hljs-name">xsd:extension</span> <span class="hljs-attr">base</span>=<span class="hljs-string">&quot;beans:identifiedType&quot;</span>&gt;</span>  <br>                    <span class="hljs-tag">&lt;<span class="hljs-name">xsd:attribute</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;xsd:string&quot;</span> /&gt;</span>  <br>                    <span class="hljs-tag">&lt;<span class="hljs-name">xsd:attribute</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;xsd:int&quot;</span> /&gt;</span>  <br>                <span class="hljs-tag">&lt;/<span class="hljs-name">xsd:extension</span>&gt;</span>  <br>            <span class="hljs-tag">&lt;/<span class="hljs-name">xsd:complexContent</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;/<span class="hljs-name">xsd:complexType</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">xsd:element</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">xsd:schema</span>&gt;</span> <br></code></pre></td></tr></table></figure>

<p>Spring读取xml文件时，会根据标签的命名空间找到其对应的NamespaceHandler，我们在NamespaceHandler内会注册标签对应的解析器BeanDefinitionParser。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.schema;<br><br><span class="hljs-keyword">import</span> org.springframework.beans.factory.xml.NamespaceHandlerSupport;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserNamespaceHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">NamespaceHandlerSupport</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>        registerBeanDefinitionParser(<span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-keyword">new</span> UserBeanDefinitionParser());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>BeanDefinitionParser是标签对应的解析器，Spring读取到对应标签时会使用该类进行解析；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserBeanDefinitionParser</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractSingleBeanDefinitionParser</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> Class <span class="hljs-title">getBeanClass</span><span class="hljs-params">(Element element)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> User.class;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doParse</span><span class="hljs-params">(Element element, BeanDefinitionBuilder bean)</span> </span>&#123;<br>        String name = element.getAttribute(<span class="hljs-string">&quot;name&quot;</span>);<br>        String age = element.getAttribute(<span class="hljs-string">&quot;age&quot;</span>);<br>        String id = element.getAttribute(<span class="hljs-string">&quot;id&quot;</span>);<br>        <span class="hljs-keyword">if</span> (StringUtils.hasText(id)) &#123;<br>            bean.addPropertyValue(<span class="hljs-string">&quot;id&quot;</span>, id);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (StringUtils.hasText(name)) &#123;<br>            bean.addPropertyValue(<span class="hljs-string">&quot;name&quot;</span>, name);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (StringUtils.hasText(age)) &#123;<br>            bean.addPropertyValue(<span class="hljs-string">&quot;age&quot;</span>, Integer.valueOf(age));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义spring.handlers文件，内部保存命名空间与NamespaceHandler类的对应关系；必须放在classpath下的META-INF文件夹中。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">http\:<span class="hljs-regexp">//</span>www.itheima.com<span class="hljs-regexp">/schema/u</span>ser=com.itheima.schema.UserNamespaceHandler<br></code></pre></td></tr></table></figure>

<p>定义spring.schemas文件，内部保存命名空间对应的xsd文件位置；必须放在classpath下的META-INF文件夹中。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">http\:<span class="hljs-regexp">//</span>www.itheima.com<span class="hljs-regexp">/schema/u</span>ser.xsd=META-INF/user.xsd<br></code></pre></td></tr></table></figure>

<p>代码准备好了之后，就可以在spring工程中进行使用和测试，定义spring配置文件，导入对应约束</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;<br>&lt;beans xmlns=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span> <br>xmlns:xsi=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <br>xmlns:context=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span> <br>xmlns:util=<span class="hljs-string">&quot;http://www.springframework.org/schema/util&quot;</span> <br>xmlns:task=<span class="hljs-string">&quot;http://www.springframework.org/schema/task&quot;</span> <br>xmlns:aop=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span> <br>xmlns:tx=<span class="hljs-string">&quot;http://www.springframework.org/schema/tx&quot;</span><br>xmlns:itheima=<span class="hljs-string">&quot;http://www.itheima.com/schema/user&quot;</span><br> xsi:schemaLocation=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="hljs-string">      http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</span><br><span class="hljs-string">      http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd</span><br><span class="hljs-string">      http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task.xsd</span><br><span class="hljs-string">      http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd</span><br><span class="hljs-string">      http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd</span><br><span class="hljs-string">http://www.itheima.com/schema/user http://www.itheima.com/schema/user.xsd&quot;</span>&gt;<br><br>    &lt;itheima:user id=&quot;user&quot; name=&quot;zhangsan&quot; age=&quot;12&quot;&gt;&lt;/itheima:user&gt;<br><br>&lt;/beans&gt;<br></code></pre></td></tr></table></figure>

<p>编写测试类，通过spring容器获取对象user</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SchemaDemo</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      ApplicationContext ctx = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;/spring/applicationContext.xml&quot;</span>);<br>      User user = (User)ctx.getBean(<span class="hljs-string">&quot;user&quot;</span>);<br>      System.out.println(user);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="dubbo中的相关对象"><a href="#dubbo中的相关对象" class="headerlink" title="dubbo中的相关对象"></a>dubbo中的相关对象</h5><p> Dubbo是运行在spring容器中，dubbo的配置文件也是通过spring的配置文件applicationContext.xml来加载，所以dubbo的自定义配置标签实现，其实同样依赖spring的xml schema机制，DubboNamespaceHandler中源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    registerBeanDefinitionParser(<span class="hljs-string">&quot;application&quot;</span>, <span class="hljs-keyword">new</span> DubboBeanDefinitionParser(ApplicationConfig.class, <span class="hljs-keyword">true</span>));<br>    registerBeanDefinitionParser(<span class="hljs-string">&quot;module&quot;</span>, <span class="hljs-keyword">new</span> DubboBeanDefinitionParser(ModuleConfig.class, <span class="hljs-keyword">true</span>));<br>    registerBeanDefinitionParser(<span class="hljs-string">&quot;registry&quot;</span>, <span class="hljs-keyword">new</span> DubboBeanDefinitionParser(RegistryConfig.class, <span class="hljs-keyword">true</span>));<br>    registerBeanDefinitionParser(<span class="hljs-string">&quot;config-center&quot;</span>, <span class="hljs-keyword">new</span> DubboBeanDefinitionParser(ConfigCenterBean.class, <span class="hljs-keyword">true</span>));<br>    registerBeanDefinitionParser(<span class="hljs-string">&quot;metadata-report&quot;</span>, <span class="hljs-keyword">new</span> DubboBeanDefinitionParser(MetadataReportConfig.class, <span class="hljs-keyword">true</span>));<br>    registerBeanDefinitionParser(<span class="hljs-string">&quot;monitor&quot;</span>, <span class="hljs-keyword">new</span> DubboBeanDefinitionParser(MonitorConfig.class, <span class="hljs-keyword">true</span>));<br>    registerBeanDefinitionParser(<span class="hljs-string">&quot;metrics&quot;</span>, <span class="hljs-keyword">new</span> DubboBeanDefinitionParser(MetricsConfig.class, <span class="hljs-keyword">true</span>));<br>    registerBeanDefinitionParser(<span class="hljs-string">&quot;ssl&quot;</span>, <span class="hljs-keyword">new</span> DubboBeanDefinitionParser(SslConfig.class, <span class="hljs-keyword">true</span>));<br>    registerBeanDefinitionParser(<span class="hljs-string">&quot;provider&quot;</span>, <span class="hljs-keyword">new</span> DubboBeanDefinitionParser(ProviderConfig.class, <span class="hljs-keyword">true</span>));<br>    registerBeanDefinitionParser(<span class="hljs-string">&quot;consumer&quot;</span>, <span class="hljs-keyword">new</span> DubboBeanDefinitionParser(ConsumerConfig.class, <span class="hljs-keyword">true</span>));<br>    registerBeanDefinitionParser(<span class="hljs-string">&quot;protocol&quot;</span>, <span class="hljs-keyword">new</span> DubboBeanDefinitionParser(ProtocolConfig.class, <span class="hljs-keyword">true</span>));<br>    registerBeanDefinitionParser(<span class="hljs-string">&quot;service&quot;</span>, <span class="hljs-keyword">new</span> DubboBeanDefinitionParser(ServiceBean.class, <span class="hljs-keyword">true</span>));<br>    registerBeanDefinitionParser(<span class="hljs-string">&quot;reference&quot;</span>, <span class="hljs-keyword">new</span> DubboBeanDefinitionParser(ReferenceBean.class, <span class="hljs-keyword">false</span>));<br>    registerBeanDefinitionParser(<span class="hljs-string">&quot;annotation&quot;</span>, <span class="hljs-keyword">new</span> AnnotationBeanDefinitionParser());<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看出Dubbo所有的组件都是由 DubboBeanDefinitionParser 解析，并通过registerBeanDefinitionParser方法来注册到spring中最后解析对应的对象。这些对象中我们重点关注的有以下几个：</p>
<ul>
<li><p>ServiceBean：服务提供者暴露服务的核心对象</p>
</li>
<li><p>ReferenceBean：服务消费者发现服务的核心对象</p>
</li>
<li><p>RegistryConfig：定义注册中心的核心配置对象</p>
</li>
</ul>
<h4 id="服务暴露"><a href="#服务暴露" class="headerlink" title="服务暴露"></a>服务暴露</h4><p>前面主要探讨了 Dubbo 中 schema 、 XML 的相关原理，这些内容对理解框架整体至关重要，在此基础上我们继续探讨服务是如何依靠前面的配置进行服务暴露</p>
<h5 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h5><p>在 Dubbo 的核心领域模型中：</p>
<ul>
<li><p>Invoker 是实体域，它是 Dubbo 的核心模型，其它模型都向它靠扰，或转换成它，它代表一个可执行体，可向它发起 invoke 调用，它有可能是一个本地的实现，也可能是一个远程的实现，也可能一个集群实现。在服务提供方，Invoker用于调用服务提供类。在服务消费方，Invoker用于执行远程调用。</p>
</li>
<li><p>Protocol 是服务域，它是 Invoker 暴露和引用的主功能入口，它负责 Invoker 的生命周期管理。</p>
<ul>
<li>export：暴露远程服务</li>
<li>refer：引用远程服务</li>
</ul>
</li>
<li><p>proxyFactory：获取一个接口的代理类</p>
<ul>
<li>getInvoker：针对server端，将服务对象，如DemoServiceImpl包装成一个Invoker对象</li>
<li>getProxy：针对client端，创建接口的代理对象，例如DemoService的接口。Invocation 是会话域，它持有调用过程中的变量，比如方法名，参数等</li>
</ul>
</li>
<li><p>Invocation 是会话域，它持有调用过程中的变量，比如方法名，参数等</p>
</li>
</ul>
<h5 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h5><p>在详细探讨服务暴露细节之前 ， 我们先看一下整体duubo的服务暴露原理</p>
<p><img src="/blog/2021/04/27/Dubbo/dubbo%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/pic6.png" srcset="/blog/img/loading.gif" lazyload></p>
<p>在整体上看，Dubbo 框架做服务暴露分为两大部分 ， 第一步将持有的服务实例通过代理转换成Invoker, 第二步会把 Invoker 通过具体的协议 （ 比如 Dubbo ） 转换成 Exporter, 框架做了这层抽象也大大方便了功能扩展 。</p>
<p>服务提供方暴露服务的蓝色初始化链，时序图如下：</p>
<p><img src="/blog/2021/04/27/Dubbo/dubbo%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/pic7.png" srcset="/blog/img/loading.gif" lazyload></p>
<h5 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h5><p>服务导出的入口方法是 ServiceBean 的 onApplicationEvent。onApplicationEvent 是一个事件响应方法，该方法会在收到 Spring 上下文刷新事件后执行服务导出操作。方法代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onApplicationEvent</span><span class="hljs-params">(ContextRefreshedEvent event)</span> </span>&#123;<br>    <span class="hljs-comment">// 是否有延迟到出 &amp;&amp; 是否已导出 &amp;&amp; 是不是已被取消到处</span><br>    <span class="hljs-keyword">if</span> (!isExported() &amp;&amp; !isUnexported()) &#123;<br>        <span class="hljs-keyword">if</span> (logger.isInfoEnabled()) &#123;<br>            logger.info(<span class="hljs-string">&quot;The service ready on spring started. service: &quot;</span> + getInterface());<br>        &#125;<br>        <span class="hljs-comment">// 导出服务</span><br>        export();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>onApplicationEvent 方法在经过一些判断后，会决定是否调用 export 方法导出服务。在export 根据配置执行相应的动作。export 方法会通过调用 super.export 调用到父类 ServiceConfig 的 export() 方法，最终进入到doExportUrls导出服务方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doExportUrls</span><span class="hljs-params">()</span> </span>&#123; <br>  <span class="hljs-comment">// 加载注册中心链接 </span><br>  List&lt;URL&gt; registryURLs = loadRegistries(<span class="hljs-keyword">true</span>); <br>  <span class="hljs-comment">// 遍历 protocols，并在每个协议下导出服务</span><br>  <span class="hljs-keyword">for</span> (ProtocolConfig protocolConfig : protocols) &#123;<br>    doExportUrlsFor1Protocol(protocolConfig, registryURLs);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>关于多协议多注册中心导出服务首先是根据配置，以及其他一些信息组装 URL。前面说过，URL 是Dubbo 配置的载体，通过 URL 可让 Dubbo 的各种配置在各个模块之间传递。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doExportUrlsFor1Protocol</span><span class="hljs-params">(ProtocolConfig protocolConfig, List&lt;URL&gt; registryURLs)</span> </span>&#123;<br>    String name = protocolConfig.getName();<br>    <span class="hljs-comment">// 如果协议名为空，则将协议名变量设置为 dubbo</span><br>    <span class="hljs-keyword">if</span> (StringUtils.isEmpty(name)) &#123;<br>        name = DUBBO;<br>    &#125;<br><br>    Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;String, String&gt;();<br>    map.put(SIDE_KEY, PROVIDER_SIDE);<br><br>    appendRuntimeParameters(map);<br>    appendParameters(map, metrics);<br>    appendParameters(map, application);<br>    appendParameters(map, <span class="hljs-keyword">module</span>);<br>    <span class="hljs-comment">// remove &#x27;default.&#x27; prefix for configs from ProviderConfig</span><br>    <span class="hljs-comment">// appendParameters(map, provider, Constants.DEFAULT_KEY);</span><br>    appendParameters(map, provider);<br>    appendParameters(map, protocolConfig);<br>    appendParameters(map, <span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">if</span> (CollectionUtils.isNotEmpty(methods)) &#123;<br>        <span class="hljs-keyword">for</span> (MethodConfig method : methods) &#123;<br>            appendParameters(map, method, method.getName());<br>            String retryKey = method.getName() + <span class="hljs-string">&quot;.retry&quot;</span>;<br>            <span class="hljs-keyword">if</span> (map.containsKey(retryKey)) &#123;<br>                String retryValue = map.remove(retryKey);<br>                <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;false&quot;</span>.equals(retryValue)) &#123;<br>                    map.put(method.getName() + <span class="hljs-string">&quot;.retries&quot;</span>, <span class="hljs-string">&quot;0&quot;</span>);<br>                &#125;<br>            &#125;<br>            List&lt;ArgumentConfig&gt; arguments = method.getArguments();<br>            <span class="hljs-keyword">if</span> (CollectionUtils.isNotEmpty(arguments)) &#123;<br>                <span class="hljs-keyword">for</span> (ArgumentConfig argument : arguments) &#123;<br>                    <span class="hljs-comment">// convert argument type</span><br>                    <span class="hljs-keyword">if</span> (argument.getType() != <span class="hljs-keyword">null</span> &amp;&amp; argument.getType().length() &gt; <span class="hljs-number">0</span>) &#123;<br>                        Method[] methods = interfaceClass.getMethods();<br>                        <span class="hljs-comment">// visit all methods</span><br>                        <span class="hljs-keyword">if</span> (methods != <span class="hljs-keyword">null</span> &amp;&amp; methods.length &gt; <span class="hljs-number">0</span>) &#123;<br>                            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; methods.length; i++) &#123;<br>                                String methodName = methods[i].getName();<br>                                <span class="hljs-comment">// target the method, and get its signature</span><br>                                <span class="hljs-keyword">if</span> (methodName.equals(method.getName())) &#123;<br>                                    Class&lt;?&gt;[] argtypes = methods[i].getParameterTypes();<br>                                    <span class="hljs-comment">// one callback in the method</span><br>                                    <span class="hljs-keyword">if</span> (argument.getIndex() != -<span class="hljs-number">1</span>) &#123;<br>                                        <span class="hljs-keyword">if</span> (argtypes[argument.getIndex()].getName().equals(argument.getType())) &#123;<br>                                            appendParameters(map, argument, method.getName() + <span class="hljs-string">&quot;.&quot;</span> + argument.getIndex());<br>                                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                                            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Argument config error : the index attribute and type attribute not match :index :&quot;</span> + argument.getIndex() + <span class="hljs-string">&quot;, type:&quot;</span> + argument.getType());<br>                                        &#125;<br>                                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                                        <span class="hljs-comment">// multiple callbacks in the method</span><br>                                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; argtypes.length; j++) &#123;<br>                                            Class&lt;?&gt; argclazz = argtypes[j];<br>                                            <span class="hljs-keyword">if</span> (argclazz.getName().equals(argument.getType())) &#123;<br>                                                appendParameters(map, argument, method.getName() + <span class="hljs-string">&quot;.&quot;</span> + j);<br>                                                <span class="hljs-keyword">if</span> (argument.getIndex() != -<span class="hljs-number">1</span> &amp;&amp; argument.getIndex() != j) &#123;<br>                                                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Argument config error : the index attribute and type attribute not match :index :&quot;</span> + argument.getIndex() + <span class="hljs-string">&quot;, type:&quot;</span> + argument.getType());<br>                                                &#125;<br>                                            &#125;<br>                                        &#125;<br>                                    &#125;<br>                                &#125;<br>                            &#125;<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (argument.getIndex() != -<span class="hljs-number">1</span>) &#123;<br>                        appendParameters(map, argument, method.getName() + <span class="hljs-string">&quot;.&quot;</span> + argument.getIndex());<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Argument config must set index or type attribute.eg: &lt;dubbo:argument index=&#x27;0&#x27; .../&gt; or &lt;dubbo:argument type=xxx .../&gt;&quot;</span>);<br>                    &#125;<br><br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-comment">// end of methods for</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (ProtocolUtils.isGeneric(generic)) &#123;<br>        map.put(GENERIC_KEY, generic);<br>        map.put(METHODS_KEY, ANY_VALUE);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        String revision = Version.getVersion(interfaceClass, version);<br>        <span class="hljs-keyword">if</span> (revision != <span class="hljs-keyword">null</span> &amp;&amp; revision.length() &gt; <span class="hljs-number">0</span>) &#123;<br>            map.put(REVISION_KEY, revision);<br>        &#125;<br><br>        String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames();<br>        <span class="hljs-keyword">if</span> (methods.length == <span class="hljs-number">0</span>) &#123;<br>            logger.warn(<span class="hljs-string">&quot;No method found in service interface &quot;</span> + interfaceClass.getName());<br>            map.put(METHODS_KEY, ANY_VALUE);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            map.put(METHODS_KEY, StringUtils.join(<span class="hljs-keyword">new</span> HashSet&lt;String&gt;(Arrays.asList(methods)), <span class="hljs-string">&quot;,&quot;</span>));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!ConfigUtils.isEmpty(token)) &#123;<br>        <span class="hljs-keyword">if</span> (ConfigUtils.isDefault(token)) &#123;<br>            map.put(TOKEN_KEY, UUID.randomUUID().toString());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            map.put(TOKEN_KEY, token);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// export service</span><br>    <span class="hljs-comment">// 获取 host 和 post</span><br>    String host = <span class="hljs-keyword">this</span>.findConfigedHosts(protocolConfig, registryURLs, map);<br>    Integer port = <span class="hljs-keyword">this</span>.findConfigedPorts(protocolConfig, name, map);<br>    <span class="hljs-comment">// 组装 URL</span><br>    URL url = <span class="hljs-keyword">new</span> URL(name, host, port, getContextPath(protocolConfig).map(p -&gt; p + <span class="hljs-string">&quot;/&quot;</span> + path).orElse(path), map);<br><br>    <span class="hljs-keyword">if</span> (ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)<br>            .hasExtension(url.getProtocol())) &#123;<br>        url = ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)<br>                .getExtension(url.getProtocol()).getConfigurator(url).configure(url);<br>    &#125;<br><br>    String scope = url.getParameter(SCOPE_KEY);<br>    <span class="hljs-comment">// scope != none 时才执行操作</span><br>    <span class="hljs-comment">// don&#x27;t export when none is configured</span><br>    <span class="hljs-keyword">if</span> (!SCOPE_NONE.equalsIgnoreCase(scope)) &#123;<br><br>        <span class="hljs-comment">// scope != remote 导出到本地</span><br>        <span class="hljs-comment">// export to local if the config is not remote (export to remote only when config is remote)</span><br>        <span class="hljs-keyword">if</span> (!SCOPE_REMOTE.equalsIgnoreCase(scope)) &#123;<br>            exportLocal(url);<br>        &#125;<br>        <span class="hljs-comment">// scope != local 导出到远程</span><br>        <span class="hljs-comment">// export to remote if the config is not local (export to local only when config is local)</span><br>        <span class="hljs-keyword">if</span> (!SCOPE_LOCAL.equalsIgnoreCase(scope)) &#123;<br>            <span class="hljs-keyword">if</span> (!isOnlyInJvm() &amp;&amp; logger.isInfoEnabled()) &#123;<br>                logger.info(<span class="hljs-string">&quot;Export dubbo service &quot;</span> + interfaceClass.getName() + <span class="hljs-string">&quot; to url &quot;</span> + url);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (CollectionUtils.isNotEmpty(registryURLs)) &#123;<br>                <span class="hljs-keyword">for</span> (URL registryURL : registryURLs) &#123;<br>                    <span class="hljs-comment">//if protocol is only injvm ,not register</span><br>                    <span class="hljs-keyword">if</span> (LOCAL_PROTOCOL.equalsIgnoreCase(url.getProtocol())) &#123;<br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125;<br>                    url = url.addParameterIfAbsent(DYNAMIC_KEY, registryURL.getParameter(DYNAMIC_KEY));<br>                    URL monitorUrl = loadMonitor(registryURL);<br>                    <span class="hljs-keyword">if</span> (monitorUrl != <span class="hljs-keyword">null</span>) &#123;<br>                        url = url.addParameterAndEncoded(MONITOR_KEY, monitorUrl.toFullString());<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (logger.isInfoEnabled()) &#123;<br>                        logger.info(<span class="hljs-string">&quot;Register dubbo service &quot;</span> + interfaceClass.getName() + <span class="hljs-string">&quot; url &quot;</span> + url + <span class="hljs-string">&quot; to registry &quot;</span> + registryURL);<br>                    &#125;<br><br>                    <span class="hljs-comment">// For providers, this is used to enable custom proxy to generate invoker</span><br>                    String proxy = url.getParameter(PROXY_KEY);<br>                    <span class="hljs-keyword">if</span> (StringUtils.isNotEmpty(proxy)) &#123;<br>                        registryURL = registryURL.addParameter(PROXY_KEY, proxy);<br>                    &#125;<br>                    <span class="hljs-comment">// 为服务提供类(ref)生成 Invoker</span><br>                    Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(EXPORT_KEY, url.toFullString()));<br>                    <span class="hljs-comment">// DelegateProviderMetaDataInvoker 生成持有 Invoker 和 ServiceConfig</span><br>                    DelegateProviderMetaDataInvoker wrapperInvoker = <span class="hljs-keyword">new</span> DelegateProviderMetaDataInvoker(invoker, <span class="hljs-keyword">this</span>);<br>                    <span class="hljs-comment">// 导出服务，并生成 Exporter</span><br>                    Exporter&lt;?&gt; exporter = protocol.export(wrapperInvoker);<br>                    exporters.add(exporter);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 不存在注册中心，仅导出服务</span><br>                Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, url);<br>                DelegateProviderMetaDataInvoker wrapperInvoker = <span class="hljs-keyword">new</span> DelegateProviderMetaDataInvoker(invoker, <span class="hljs-keyword">this</span>);<br><br>                Exporter&lt;?&gt; exporter = protocol.export(wrapperInvoker);<br>                exporters.add(exporter);<br>            &#125;<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * <span class="hljs-doctag">@since</span> 2.7.0</span><br><span class="hljs-comment">             * ServiceData Store</span><br><span class="hljs-comment">             */</span><br>            MetadataReportService metadataReportService = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">if</span> ((metadataReportService = getMetadataReportService()) != <span class="hljs-keyword">null</span>) &#123;<br>                metadataReportService.publishProvider(url);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">this</span>.urls.add(url);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面的代码首先是将一些信息，比如版本、时间戳、方法名以及各种配置对象的字段信息放入到 map中，最后将 map 和主机名等数据传给 URL 构造方法创建 URL 对象。前置工作做完，接下来就可以进行服务导出了。根据 url 中的 scope 参数决定服务导出方式，分别如下：</p>
<ul>
<li><p>scope = none，不导出服务</p>
</li>
<li><p>scope != remote，导出到本地</p>
</li>
<li><p>scope != local，导出到远程</p>
</li>
</ul>
<p>不管是导出到本地，还是远程。进行服务导出之前，均需要先创建 Invoker，这是一个很重要的步骤。因此下面先来分析 Invoker 的创建过程。Invoker 是由 ProxyFactory 创建而来，Dubbo 默认的ProxyFactory 实现类是 JavassistProxyFactory。下面我们到 JavassistProxyFactory 代码中，探索Invoker 的创建过程。如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">Invoker&lt;T&gt; <span class="hljs-title">getInvoker</span><span class="hljs-params">(T proxy, Class&lt;T&gt; type, URL url)</span> </span>&#123;<br>    <span class="hljs-comment">// TODO Wrapper cannot handle this scenario correctly: the classname contains &#x27;$&#x27;</span><br>    <span class="hljs-comment">// 为目标类创建 wrapper</span><br>    <span class="hljs-keyword">final</span> Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf(<span class="hljs-string">&#x27;$&#x27;</span>) &lt; <span class="hljs-number">0</span> ? proxy.getClass() : type);<br>    <span class="hljs-comment">// 创建匿名 Invoker 类对象，并实现 doInvoker 方法</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AbstractProxyInvoker&lt;T&gt;(proxy, type, url) &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">doInvoke</span><span class="hljs-params">(T proxy, String methodName,</span></span><br><span class="hljs-function"><span class="hljs-params">                                  Class&lt;?&gt;[] parameterTypes,</span></span><br><span class="hljs-function"><span class="hljs-params">                                  Object[] arguments)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>            <span class="hljs-comment">// 调用 Wrapper 的 invokeMethod 方法，invokeMethod 最终会调用目标方法</span><br>            <span class="hljs-keyword">return</span> wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);<br>        &#125;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如上，JavassistProxyFactory 创建了一个继承自 AbstractProxyInvoker 类的匿名对象，并覆写了抽象方法 doInvoke。 </p>
<p><strong>导出服务到本地</strong></p>
<p>Invoke创建成功之后，接下来我们来看本地导出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exportLocal</span><span class="hljs-params">(URL url)</span> </span>&#123;<br>    <span class="hljs-comment">// 如果 URL 的协议头等于 injvm，说明已经导出到本地了，无需再次导出</span><br>    URL local = URLBuilder.from(url)<br>            .setProtocol(LOCAL_PROTOCOL)        <span class="hljs-comment">// 设置协议头为 injvm</span><br>            .setHost(LOCALHOST_VALUE)<br>            .setPort(<span class="hljs-number">0</span>)<br>            .build();<br>    <span class="hljs-comment">// 创建 Invoker ，并导出服务，这里的 protocol 会在运行时调用 InjvmProtocolProtocol 的 export 方法</span><br>    Exporter&lt;?&gt; exporter = protocol.export(<br>            proxyFactory.getInvoker(ref, (Class) interfaceClass, local));<br>    exporters.add(exporter);<br>    logger.info(<span class="hljs-string">&quot;Export dubbo service &quot;</span> + interfaceClass.getName() + <span class="hljs-string">&quot; to local registry url : &quot;</span> + local);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>exportLocal 方法比较简单，首先根据 URL 协议头决定是否导出服务。若需导出，则创建一个新的 URL并将协议头、主机名以及端口设置成新的值。然后创建 Invoker，并调用 InjvmProtocol 的 export 方法导出服务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">Exporter&lt;T&gt; <span class="hljs-title">export</span><span class="hljs-params">(Invoker&lt;T&gt; invoker)</span> <span class="hljs-keyword">throws</span> RpcException </span>&#123;<br>    <span class="hljs-comment">// 创建 InjvmExporter</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> InjvmExporter&lt;T&gt;(invoker, invoker.getUrl().getServiceKey(), exporterMap);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如上，InjvmProtocol 的 export 方法仅创建了一个 InjvmExporter，无其他逻辑。到此导出服务到本地就分析完了。</p>
<p><strong>导出服务到远程</strong></p>
<p>接下来，继续分析导出服务到远程的过程。导出服务到远程包含了服务导出与服务注册两个过程。先来分析导出服务，并生成 Exporter的逻辑，该逻辑位于RegistryProtocol.export()中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">Exporter&lt;T&gt; <span class="hljs-title">export</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Invoker&lt;T&gt; originInvoker)</span> <span class="hljs-keyword">throws</span> RpcException </span>&#123;<br>    <span class="hljs-comment">// 获取注册中心 URL</span><br>    URL registryUrl = getRegistryUrl(originInvoker);<br>    <span class="hljs-comment">// url to export locally</span><br>    URL providerUrl = getProviderUrl(originInvoker);<br><br>    <span class="hljs-comment">// Subscribe the override data</span><br>    <span class="hljs-comment">// FIXME When the provider subscribes, it will affect the scene : a certain JVM exposes the service and call</span><br>    <span class="hljs-comment">//  the same service. Because the subscribed is cached key with the name of the service, it causes the</span><br>    <span class="hljs-comment">//  subscription information to cover.</span><br>    <span class="hljs-comment">// 创建监听器</span><br>    <span class="hljs-keyword">final</span> URL overrideSubscribeUrl = getSubscribedOverrideUrl(providerUrl);<br>    <span class="hljs-keyword">final</span> OverrideListener overrideSubscribeListener = <span class="hljs-keyword">new</span> OverrideListener(overrideSubscribeUrl, originInvoker);<br>    overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);<br><br>    providerUrl = overrideUrlWithConfig(providerUrl, overrideSubscribeListener);<br>    <span class="hljs-comment">//export invoker</span><br>    <span class="hljs-keyword">final</span> ExporterChangeableWrapper&lt;T&gt; exporter = doLocalExport(originInvoker, providerUrl);<br><br>    <span class="hljs-comment">// 根据 URL 加载 Registry 实现类 </span><br>    <span class="hljs-comment">// url to registry</span><br>    <span class="hljs-keyword">final</span> Registry registry = getRegistry(originInvoker);<br>    <span class="hljs-comment">// 获取已注册的服务提供者 URL</span><br>    <span class="hljs-keyword">final</span> URL registeredProviderUrl = getRegisteredProviderUrl(providerUrl, registryUrl);<br>    ProviderInvokerWrapper&lt;T&gt; providerInvokerWrapper = ProviderConsumerRegTable.registerProvider(originInvoker,<br>            registryUrl, registeredProviderUrl);<br>    <span class="hljs-comment">// 获取 register 参数</span><br>    <span class="hljs-comment">//to judge if we need to delay publish</span><br>    <span class="hljs-keyword">boolean</span> register = registeredProviderUrl.getParameter(<span class="hljs-string">&quot;register&quot;</span>, <span class="hljs-keyword">true</span>);<br>    <span class="hljs-comment">// 根据 register 决定是否注册服务</span><br>    <span class="hljs-keyword">if</span> (register) &#123;<br>        <span class="hljs-comment">// 向注册中心注册服务</span><br>        register(registryUrl, registeredProviderUrl);<br>        providerInvokerWrapper.setReg(<span class="hljs-keyword">true</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 向注册中心进行订阅 override 数据</span><br>    <span class="hljs-comment">// Deprecated! Subscribe to override rules in 2.6.x or before.</span><br>    registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);<br><br>    exporter.setRegisterUrl(registeredProviderUrl);<br>    exporter.setSubscribeUrl(overrideSubscribeUrl);<br>    <span class="hljs-comment">//Ensure that a new exporter instance is returned every time export</span><br>    <span class="hljs-comment">// 创建并返回 DestroyableExporter</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DestroyableExporter&lt;&gt;(exporter);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面代码看起来比较复杂，主要做如下一些操作：</p>
<ol>
<li><p>调用 doLocalExport 导出服务</p>
</li>
<li><p>向注册中心注册服务</p>
</li>
<li><p>向注册中心进行订阅 override 数据</p>
</li>
<li><p>创建并返回 DestroyableExporter</p>
</li>
</ol>
<p>下面先来分析 doLocalExport 方法的逻辑，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> &lt;T&gt; <span class="hljs-function">ExporterChangeableWrapper&lt;T&gt; <span class="hljs-title">doLocalExport</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Invoker&lt;T&gt; originInvoker, URL providerUrl)</span> </span>&#123;<br>    String key = getCacheKey(originInvoker);<br>    <span class="hljs-comment">// 写入访问缓存</span><br>    <span class="hljs-keyword">return</span> (ExporterChangeableWrapper&lt;T&gt;) bounds.computeIfAbsent(key, s -&gt; &#123;<br>        <span class="hljs-comment">// 创建 Invoker 为委托类对象</span><br>        Invoker&lt;?&gt; invokerDelegate = <span class="hljs-keyword">new</span> InvokerDelegate&lt;&gt;(originInvoker, providerUrl);<br>        <span class="hljs-comment">// 调用 protocol 的 export 方法导出服务</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ExporterChangeableWrapper&lt;&gt;((Exporter&lt;T&gt;) protocol.export(invokerDelegate), originInvoker);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>接下来，我们把重点放在 Protocol 的 export 方法上。假设运行时协议为 dubbo，此处的 protocol 变量会在运行时加载 DubboProtocol，并调用 DubboProtocol 的 export 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">Exporter&lt;T&gt; <span class="hljs-title">export</span><span class="hljs-params">(Invoker&lt;T&gt; invoker)</span> <span class="hljs-keyword">throws</span> RpcException </span>&#123;<br>    URL url = invoker.getUrl();<br><br>    <span class="hljs-comment">// 获取服务标识（服务坐标）。由服务组名，服务名，服务版本号以及端口组成</span><br>    <span class="hljs-comment">// 示例 demoGroup/com.alibaba.dubbo.demo.DemoService:1.0.1:20800</span><br>    <span class="hljs-comment">// export service.</span><br>    String key = serviceKey(url);<br>    <span class="hljs-comment">// 创建 DubboExporter</span><br>    DubboExporter&lt;T&gt; exporter = <span class="hljs-keyword">new</span> DubboExporter&lt;T&gt;(invoker, key, exporterMap);<br>    <span class="hljs-comment">// 将 &lt;key, exporter&gt; 键值对放入缓存中</span><br>    exporterMap.put(key, exporter);<br><br>    <span class="hljs-comment">//export an stub service for dispatching event</span><br>    Boolean isStubSupportEvent = url.getParameter(STUB_EVENT_KEY, DEFAULT_STUB_EVENT);<br>    Boolean isCallbackservice = url.getParameter(IS_CALLBACK_SERVICE, <span class="hljs-keyword">false</span>);<br>    <span class="hljs-keyword">if</span> (isStubSupportEvent &amp;&amp; !isCallbackservice) &#123;<br>        String stubServiceMethods = url.getParameter(STUB_EVENT_METHODS_KEY);<br>        <span class="hljs-keyword">if</span> (stubServiceMethods == <span class="hljs-keyword">null</span> || stubServiceMethods.length() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (logger.isWarnEnabled()) &#123;<br>                logger.warn(<span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;consumer [&quot;</span> + url.getParameter(INTERFACE_KEY) +<br>                        <span class="hljs-string">&quot;], has set stubproxy support event ,but no stub methods founded.&quot;</span>));<br>            &#125;<br><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            stubServiceMethodsMap.put(url.getServiceKey(), stubServiceMethods);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 启动服务器</span><br>    openServer(url);<br>    <span class="hljs-comment">// 优化序列化</span><br>    optimizeSerialization(url);<br><br>    <span class="hljs-keyword">return</span> exporter;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>开启Netty服务</strong></p>
<p>如上，我们重点关注 DubboExporter 的创建以及 openServer 方法，其他逻辑看不懂也没关系，不影响理解服务导出过程。下面分析 openServer 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">openServer</span><span class="hljs-params">(URL url)</span> </span>&#123;<br>    <span class="hljs-comment">// find server.</span><br>    <span class="hljs-comment">// 获取 host:port ，并将其作为服务器实例的 key，用于标识当前的服务器实例</span><br>    String key = url.getAddress();<br>    <span class="hljs-comment">//client can export a service which&#x27;s only for server to invoke</span><br>    <span class="hljs-keyword">boolean</span> isServer = url.getParameter(IS_SERVER_KEY, <span class="hljs-keyword">true</span>);<br>    <span class="hljs-keyword">if</span> (isServer) &#123;<br>        <span class="hljs-comment">// 访问缓存</span><br>        ExchangeServer server = serverMap.get(key);<br>        <span class="hljs-keyword">if</span> (server == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 创建服务器实例</span><br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>                server = serverMap.get(key);<br>                <span class="hljs-keyword">if</span> (server == <span class="hljs-keyword">null</span>) &#123;<br>                    serverMap.put(key, createServer(url));<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 服务器已创建，则根据 url 中的配置重置服务器</span><br>            <span class="hljs-comment">// server supports reset, use together with override</span><br>            server.reset(url);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>接下来分析服务器实例的创建过程。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> ExchangeServer <span class="hljs-title">createServer</span><span class="hljs-params">(URL url)</span> </span>&#123;<br>    url = URLBuilder.from(url)<br>            <span class="hljs-comment">// send readonly event when server closes, it&#x27;s enabled by default</span><br>            .addParameterIfAbsent(CHANNEL_READONLYEVENT_SENT_KEY, Boolean.TRUE.toString())<br>            <span class="hljs-comment">// enable heartbeat by default</span><br>            <span class="hljs-comment">// 添加心跳检测配置到 url 中</span><br>            .addParameterIfAbsent(HEARTBEAT_KEY, String.valueOf(DEFAULT_HEARTBEAT))<br>            .addParameter(CODEC_KEY, DubboCodec.NAME)<br>            .build();<br>    <span class="hljs-comment">// 获取 server 参数，默认为 netty</span><br>    String str = url.getParameter(SERVER_KEY, DEFAULT_REMOTING_SERVER);<br><br>    <span class="hljs-comment">// 通过 SPI 检测是否存在 server 参数所代表的 Transporter 拓展，不存在则抛出异常</span><br>    <span class="hljs-keyword">if</span> (str != <span class="hljs-keyword">null</span> &amp;&amp; str.length() &gt; <span class="hljs-number">0</span> &amp;&amp; !ExtensionLoader.getExtensionLoader(Transporter.class).hasExtension(str)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RpcException(<span class="hljs-string">&quot;Unsupported server type: &quot;</span> + str + <span class="hljs-string">&quot;, url: &quot;</span> + url);<br>    &#125;<br><br>    ExchangeServer server;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 创建 ExchangeServer</span><br>        server = Exchangers.bind(url, requestHandler);<br>    &#125; <span class="hljs-keyword">catch</span> (RemotingException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RpcException(<span class="hljs-string">&quot;Fail to start server(url: &quot;</span> + url + <span class="hljs-string">&quot;) &quot;</span> + e.getMessage(), e);<br>    &#125;<br><br>    <span class="hljs-comment">// 提取 client 参数，可指定 netty，mina</span><br>    str = url.getParameter(CLIENT_KEY);<br>    <span class="hljs-keyword">if</span> (str != <span class="hljs-keyword">null</span> &amp;&amp; str.length() &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 获取所有的 Transporter 实现类名称集合，比如 supportedTypes = [netty, mina]</span><br>        Set&lt;String&gt; supportedTypes = ExtensionLoader.getExtensionLoader(Transporter.class).getSupportedExtensions();<br>        <span class="hljs-comment">// 检测当前 Dubbo 所支持的 Transporter 实现类名称列表中是否包含 client 所表示的 Transporter，若不包含，则抛出异常</span><br>        <span class="hljs-keyword">if</span> (!supportedTypes.contains(str)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RpcException(<span class="hljs-string">&quot;Unsupported client type: &quot;</span> + str);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> server;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如上，createServer 包含三个核心的逻辑。第一是检测是否存在 server 参数所代表的 Transporter 拓展，不存在则抛出异常。第二是创建服务器实例。第三是检测是否支持 client 参数所表示的Transporter 拓展，不存在也是抛出异常。两次检测操作所对应的代码比较直白了，无需多说。但创建服务器的操作目前还不是很清晰，我们继续往下看。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExchangeServer <span class="hljs-title">bind</span><span class="hljs-params">(URL url, ExchangeHandler handler)</span> <span class="hljs-keyword">throws</span> RemotingException </span>&#123;<br>    <span class="hljs-keyword">if</span> (url == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;url == null&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (handler == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;handler == null&quot;</span>);<br>    &#125;<br>    url = url.addParameterIfAbsent(Constants.CODEC_KEY, <span class="hljs-string">&quot;exchange&quot;</span>);<br>    <span class="hljs-comment">// 获取 Exchanger，默认为 HeaderExchanger。</span><br>    <span class="hljs-comment">// 调用 HeaderExchanger 的 bind 方法创建 ExchangerServe 实例</span><br>    <span class="hljs-keyword">return</span> getExchanger(url).bind(url, handler);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面代码比较简单，就不多说了。下面看一下 HeaderExchanger 的 bind 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ExchangeServer <span class="hljs-title">bind</span><span class="hljs-params">(URL url, ExchangeHandler handler)</span> <span class="hljs-keyword">throws</span> RemotingException </span>&#123;<br>    <span class="hljs-comment">// 创建 HeaderExchangeServer 实例，该方法包含了多个逻辑，如下：</span><br>    <span class="hljs-comment">// 1. new HeaderExchangeHandler(handler)</span><br>    <span class="hljs-comment">// 2. new DecodeHandler(new HandlerExchangeHandler(handler))</span><br>    <span class="hljs-comment">// 3. Transporters.bind(url, new DecodeHandler(new HeaderExchangeHandler(handler)))</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HeaderExchangeServer(Transporters.bind(url, <span class="hljs-keyword">new</span> DecodeHandler(<span class="hljs-keyword">new</span> HeaderExchangeHandler(handler))));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>HeaderExchanger 的 bind 方法包含的逻辑比较多，但目前我们仅需关心 Transporters 的 bind 方法逻辑即可。该方法的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Server <span class="hljs-title">bind</span><span class="hljs-params">(URL url, ChannelHandler... handlers)</span> <span class="hljs-keyword">throws</span> RemotingException </span>&#123;<br>    <span class="hljs-keyword">if</span> (url == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;url == null&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (handlers == <span class="hljs-keyword">null</span> || handlers.length == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;handlers == null&quot;</span>);<br>    &#125;<br>    ChannelHandler handler;<br>    <span class="hljs-keyword">if</span> (handlers.length == <span class="hljs-number">1</span>) &#123;<br>        handler = handlers[<span class="hljs-number">0</span>];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果 handlers 元素数量大于1，则创建 ChannelHandler 分发器</span><br>        handler = <span class="hljs-keyword">new</span> ChannelHandlerDispatcher(handlers);<br>    &#125;<br>    <span class="hljs-comment">// 获取自适应 Transporter 实例，并调用实例方法</span><br>    <span class="hljs-keyword">return</span> getTransporter().bind(url, handler);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如上，getTransporter() 方法获取的 Transporter 是在运行时动态创建的，类名为TransporterAdaptive，也就是自适应拓展类。TransporterAdaptive 会在运行时根据传入的 URL 参数决定加载什么类型的 Transporter，默认为 NettyTransporter。调用 NettyTransporter.bind(URL, ChannelHandler) 方法。创建一个 NettyServer 实例。调用 NettyServer.doOPen() 方法，服务器被开启，服务也被暴露出来了。</p>
<p><strong>服务注册</strong></p>
<p>RegistryProtocol 的 export 方法包含了服务导出，注册，以及数据订阅等逻辑。其中服务导出逻辑上一节已经分析过了，本节将分析服务注册逻辑，相关代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(URL registryUrl, URL registeredProviderUrl)</span> </span>&#123;<br>    <span class="hljs-comment">// 获取 Registry</span><br>    Registry registry = registryFactory.getRegistry(registryUrl);<br>    <span class="hljs-comment">// 注册服务</span><br>    registry.register(registeredProviderUrl);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>register 方法包含两步操作，第一步是获取注册中心实例，第二步是向注册中心注册服务。接下来分两节内容对这两步操作进行分析。</p>
<p>这里以 Zookeeper 注册中心为例进行分析。下面先来看一下 getRegistry 方法的源码，这个方法由AbstractRegistryFactory 实现。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Registry <span class="hljs-title">getRegistry</span><span class="hljs-params">(URL url)</span> </span>&#123;<br>    url = URLBuilder.from(url)<br>            .setPath(RegistryService.class.getName())<br>            .addParameter(INTERFACE_KEY, RegistryService.class.getName())<br>            .removeParameters(EXPORT_KEY, REFER_KEY)<br>            .build();<br>    String key = url.toServiceStringWithoutResolving();<br>    <span class="hljs-comment">// Lock the registry access process to ensure a single instance of the registry</span><br>    LOCK.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 访问缓存</span><br>        Registry registry = REGISTRIES.get(key);<br>        <span class="hljs-keyword">if</span> (registry != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> registry;<br>        &#125;<br>        <span class="hljs-comment">// 未命中，创建 Registry 实例</span><br>        <span class="hljs-comment">//create registry by spi/ioc</span><br>        registry = createRegistry(url);<br>        <span class="hljs-keyword">if</span> (registry == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;Can not create registry &quot;</span> + url);<br>        &#125;<br>        <span class="hljs-comment">// 写入缓存</span><br>        REGISTRIES.put(key, registry);<br>        <span class="hljs-keyword">return</span> registry;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// Release the lock</span><br>        LOCK.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如上，getRegistry 方法先访问缓存，缓存未命中则调用 createRegistry 创建 Registry。在此方法中就是通过 new ZookeeperRegistry(url, zookeeperTransporter) 实例化一个注册中心</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ZookeeperRegistry</span><span class="hljs-params">(URL url, ZookeeperTransporter zookeeperTransporter)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>(url);<br>    <span class="hljs-keyword">if</span> (url.isAnyHost()) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;registry address == null&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 获取组名，默认为 dubbo</span><br>    String group = url.getParameter(GROUP_KEY, DEFAULT_ROOT);<br>    <span class="hljs-keyword">if</span> (!group.startsWith(PATH_SEPARATOR)) &#123;<br>        <span class="hljs-comment">// group = &quot;/&quot; +group</span><br>        group = PATH_SEPARATOR + group;<br>    &#125;<br>    <span class="hljs-keyword">this</span>.root = group;<br>    <span class="hljs-comment">// 创建 Zookeeper 客户端，默认为 CuratorZookeeperTransporter</span><br>    zkClient = zookeeperTransporter.connect(url);<br>    <span class="hljs-comment">// 添加状态监听器</span><br>    zkClient.addStateListener(state -&gt; &#123;<br>        <span class="hljs-keyword">if</span> (state == StateListener.RECONNECTED) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                recover();<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                logger.error(e.getMessage(), e);<br>            &#125;<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上面的代码代码中，我们重点关注 ZookeeperTransporter 的 connect 方法调用，这个方法用于创建Zookeeper 客户端。创建好 Zookeeper 客户端，意味着注册中心的创建过程就结束了。接下来，再来分析一下 Zookeeper 客户端的创建过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ZookeeperClient <span class="hljs-title">connect</span><span class="hljs-params">(URL url)</span> </span>&#123;<br>    ZookeeperClient zookeeperClient;<br>    List&lt;String&gt; addressList = getURLBackupAddress(url);<br>    <span class="hljs-comment">// The field define the zookeeper server , including protocol, host, port, username, password</span><br>    <span class="hljs-keyword">if</span> ((zookeeperClient = fetchAndUpdateZookeeperClientCache(addressList)) != <span class="hljs-keyword">null</span> &amp;&amp; zookeeperClient.isConnected()) &#123;<br>        logger.info(<span class="hljs-string">&quot;find valid zookeeper client from the cache for address: &quot;</span> + url);<br>        <span class="hljs-keyword">return</span> zookeeperClient;<br>    &#125;<br>    <span class="hljs-comment">// avoid creating too many connections， so add lock</span><br>    <span class="hljs-keyword">synchronized</span> (zookeeperClientMap) &#123;<br>        <span class="hljs-keyword">if</span> ((zookeeperClient = fetchAndUpdateZookeeperClientCache(addressList)) != <span class="hljs-keyword">null</span> &amp;&amp; zookeeperClient.isConnected()) &#123;<br>            logger.info(<span class="hljs-string">&quot;find valid zookeeper client from the cache for address: &quot;</span> + url);<br>            <span class="hljs-keyword">return</span> zookeeperClient;<br>        &#125;<br><br>        zookeeperClient = createZookeeperClient(toClientURL(url));<br>        logger.info(<span class="hljs-string">&quot;No valid zookeeper client found from cache, therefore create a new client for url. &quot;</span> + url);<br>        writeToClientMap(addressList, zookeeperClient);<br>    &#125;<br>    <span class="hljs-keyword">return</span> zookeeperClient;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ZookeeperClient <span class="hljs-title">createZookeeperClient</span><span class="hljs-params">(URL url)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CuratorZookeeperClient(url);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CuratorZookeeperClient</span><span class="hljs-params">(URL url)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>(url);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">int</span> timeout = url.getParameter(TIMEOUT_KEY, <span class="hljs-number">5000</span>);<br>        <span class="hljs-comment">// 创建 CuratorFramework 构造器</span><br>        CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder()<br>                .connectString(url.getBackupAddress())<br>                .retryPolicy(<span class="hljs-keyword">new</span> RetryNTimes(<span class="hljs-number">1</span>, <span class="hljs-number">1000</span>))<br>                .connectionTimeoutMs(timeout);<br>        String authority = url.getAuthority();<br>        <span class="hljs-keyword">if</span> (authority != <span class="hljs-keyword">null</span> &amp;&amp; authority.length() &gt; <span class="hljs-number">0</span>) &#123;<br>            builder = builder.authorization(<span class="hljs-string">&quot;digest&quot;</span>, authority.getBytes());<br>        &#125;<br>        <span class="hljs-comment">// 构建 CuratorFramework 实例</span><br>        client = builder.build();<br>        client.getConnectionStateListenable().addListener(<span class="hljs-keyword">new</span> ConnectionStateListener() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stateChanged</span><span class="hljs-params">(CuratorFramework client, ConnectionState state)</span> </span>&#123;<br>                <span class="hljs-keyword">if</span> (state == ConnectionState.LOST) &#123;<br>                    CuratorZookeeperClient.<span class="hljs-keyword">this</span>.stateChanged(StateListener.DISCONNECTED);<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == ConnectionState.CONNECTED) &#123;<br>                    CuratorZookeeperClient.<span class="hljs-keyword">this</span>.stateChanged(StateListener.CONNECTED);<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == ConnectionState.RECONNECTED) &#123;<br>                    CuratorZookeeperClient.<span class="hljs-keyword">this</span>.stateChanged(StateListener.RECONNECTED);<br>                &#125;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-comment">// 启动客户端</span><br>        client.start();<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(e.getMessage(), e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>CuratorZookeeperClient 构造方法主要用于创建和启动 CuratorFramework 实例。至此Zookeeper客户端就已经启动了。启动完成后会进行register操作，调用链为：FailbackRegistry.register()-&gt;ZookeeperRegistry.doRegister()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doRegister</span><span class="hljs-params">(URL url)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 通过 Zookeeper 客户端创建节点，节点路径由 toUrlPath 方法生成，路径格式如下：</span><br>        <span class="hljs-comment">// /$&#123;group&#125;/$&#123;serviceInterface&#125;/providers/$&#123;url&#125;</span><br>        <span class="hljs-comment">// 如/dubbo/org.apache.dubbo.DemoService/providers/dubbo%3A%2F%2F127.0.0.1....</span><br>        zkClient.create(toUrlPath(url), url.getParameter(DYNAMIC_KEY, <span class="hljs-keyword">true</span>));<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RpcException(<span class="hljs-string">&quot;Failed to register &quot;</span> + url + <span class="hljs-string">&quot; to zookeeper &quot;</span> + getUrl() + <span class="hljs-string">&quot;, cause: &quot;</span> + e.getMessage(), e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>ZookeeperRegistry 在 doRegister 中调用了 Zookeeper 客户端创建服务节点。节点路径由toUrlPath 方法生成，该方法逻辑不难理解，就不分析了。接下来分析 create 方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">create</span><span class="hljs-params">(String path, <span class="hljs-keyword">boolean</span> ephemeral)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!ephemeral) &#123;<br>        <span class="hljs-comment">// 如果要创建的节点类型非临时节点，需要在这里检测节点是否存在</span><br>        <span class="hljs-keyword">if</span> (checkExists(path)) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">int</span> i = path.lastIndexOf(<span class="hljs-string">&#x27;/&#x27;</span>);<br>    <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 递归创建上一级路径</span><br>        create(path.substring(<span class="hljs-number">0</span>, i), <span class="hljs-keyword">false</span>);<br>    &#125;<br>    <span class="hljs-comment">// 根据 ephemeral 的值创建临时或持久节点</span><br>    <span class="hljs-keyword">if</span> (ephemeral) &#123;<br>        createEphemeral(path);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        createPersistent(path);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>到此关于服务注册的过程就分析完了。整个过程可简单总结为：先创建注册中心实例，之后再通过注册中心实例注册服务。</p>
<p><strong>总结</strong></p>
<ol>
<li><p>在有注册中心，需要注册提供者地址的情况下，ServiceConfig 解析出的 URL 格式为：registry:// registry-host/org.apache.dubbo.registry.RegistryService? export=URL.encode(“dubbo://service-host/{服务名}/{版本号}”) </p>
</li>
<li><p>基于 Dubbo SPI 的自适应机制，通过 URL registry:// 协议头识别，就调用RegistryProtocol#export() 方法</p>
<ol>
<li>将具体的服务类名，比如 DubboServiceRegistryImpl ，通过 ProxyFactory 包装成Invoker 实例</li>
<li>调用 doLocalExport 方法，使用 DubboProtocol 将 Invoker 转化为 Exporter 实例，并打开Netty 服务端监听客户请求</li>
<li>创建 Registry 实例，连接 Zookeeper，并在服务节点下写入提供者的 URL 地址，注册服务</li>
<li>向注册中心订阅 override 数据，并返回一个 Exporter 实例</li>
</ol>
</li>
<li><p>根据 URL 格式中的 “dubbo://service-host/{服务名}/{版本号}” 中协议头 dubbo:// 识别，调用 DubboProtocol#export() 方法，开发服务端口</p>
</li>
<li><p>RegistryProtocol#export() 返回的 Exporter 实例存放到 ServiceConfifig 的 List&lt;Exporter&gt; exporters 中</p>
</li>
</ol>
<h4 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h4><h5 id="服务发现流程"><a href="#服务发现流程" class="headerlink" title="服务发现流程"></a>服务发现流程</h5><p>整体dubbo的服务消费原理</p>
<p><img src="/blog/2021/04/27/Dubbo/dubbo%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/pic8.png" srcset="/blog/img/loading.gif" lazyload></p>
<p>在整体上看 ， Dubbo 框架做服务消费也分为两大部分，第一步通过持有远程服务实例生成Invoker，这个 Invoker 在客户端是核心的远程代理对象。 第二步会把 Invoker 通过动态代理转换成实现用户接口的动态代理引用。</p>
<p>服务消费方引用服务的蓝色初始化链，时序图如下：</p>
<p><img src="/blog/2021/04/27/Dubbo/dubbo%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/pic9.png" srcset="/blog/img/loading.gif" lazyload></p>
<h5 id="源码分析-2"><a href="#源码分析-2" class="headerlink" title="源码分析"></a>源码分析</h5><p>引用入口</p>
<p>服务引用的入口方法为 ReferenceBean 的 getObject 方法，该方法定义在 Spring 的 FactoryBean 接口中，ReferenceBean 实现了这个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getObject</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> get();<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>    checkAndUpdateSubConfigs();<br><br>    <span class="hljs-keyword">if</span> (destroyed) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;The invoker of ReferenceConfig(&quot;</span> + url + <span class="hljs-string">&quot;) has already destroyed!&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 检测 ref 是否为空，为空则通过 init 方法创建</span><br>    <span class="hljs-keyword">if</span> (ref == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// init 方法主要用于处理配置，以及调用 createProxy 生成代理类</span><br>        init();<br>    &#125;<br>    <span class="hljs-keyword">return</span> ref;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Dubbo 提供了丰富的配置，用于调整和优化框架行为，性能等。Dubbo 在引用或导出服务时，首先会对这些配置进行检查和处理，以保证配置的正确性。</p>
<p>在 init 会通过 createProxy 方法创建代理类，init 方法代码很长，主要完成的配置加载、检查、以及创建引用的代理对象。createProxy 除了创建代理对象外，还会调用其他方法构建以及合并 Invoker 实例，具体细节如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> T <span class="hljs-title">createProxy</span><span class="hljs-params">(Map&lt;String, String&gt; map)</span> </span>&#123;<br>    <span class="hljs-comment">// 本地引用</span><br>    <span class="hljs-keyword">if</span> (shouldJvmRefer(map)) &#123;<br>        URL url = <span class="hljs-keyword">new</span> URL(LOCAL_PROTOCOL, LOCALHOST_VALUE, <span class="hljs-number">0</span>, interfaceClass.getName()).addParameters(map);<br>        invoker = REF_PROTOCOL.refer(interfaceClass, url);<br>        <span class="hljs-keyword">if</span> (logger.isInfoEnabled()) &#123;<br>            logger.info(<span class="hljs-string">&quot;Using injvm service &quot;</span> + interfaceClass.getName());<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        urls.clear(); <span class="hljs-comment">// reference retry init will add url to urls, lead to OOM</span><br>        <span class="hljs-comment">// 点对点调用</span><br>        <span class="hljs-keyword">if</span> (url != <span class="hljs-keyword">null</span> &amp;&amp; url.length() &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// user specified URL, could be peer-to-peer address, or register center&#x27;s address.</span><br>            String[] us = SEMICOLON_SPLIT_PATTERN.split(url);<br>            <span class="hljs-keyword">if</span> (us != <span class="hljs-keyword">null</span> &amp;&amp; us.length &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">for</span> (String u : us) &#123;<br>                    URL url = URL.valueOf(u);<br>                    <span class="hljs-keyword">if</span> (StringUtils.isEmpty(url.getPath())) &#123;<br>                        url = url.setPath(interfaceName);<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (REGISTRY_PROTOCOL.equals(url.getProtocol())) &#123;<br>                        urls.add(url.addParameterAndEncoded(REFER_KEY, StringUtils.toQueryString(map)));<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        urls.add(ClusterUtils.mergeUrl(url, map));<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// assemble URL from register center&#x27;s configuration</span><br>            <span class="hljs-comment">// if protocols not injvm checkRegistry</span><br>            <span class="hljs-keyword">if</span> (!LOCAL_PROTOCOL.equalsIgnoreCase(getProtocol()))&#123;<br>                checkRegistry();<br>                <span class="hljs-comment">// 加载注册中心url</span><br>                List&lt;URL&gt; us = loadRegistries(<span class="hljs-keyword">false</span>);<br>                <span class="hljs-keyword">if</span> (CollectionUtils.isNotEmpty(us)) &#123;<br>                    <span class="hljs-keyword">for</span> (URL u : us) &#123;<br>                        URL monitorUrl = loadMonitor(u);<br>                        <span class="hljs-keyword">if</span> (monitorUrl != <span class="hljs-keyword">null</span>) &#123;<br>                            map.put(MONITOR_KEY, URL.encode(monitorUrl.toFullString()));<br>                        &#125;<br>                        <span class="hljs-comment">// 添加 refer 参数到 url 中，并将 url 添加到 urls 中</span><br>                        urls.add(u.addParameterAndEncoded(REFER_KEY, StringUtils.toQueryString(map)));<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (urls.isEmpty()) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;No such any registry to reference &quot;</span> + interfaceName + <span class="hljs-string">&quot; on the consumer &quot;</span> + NetUtils.getLocalHost() + <span class="hljs-string">&quot; use dubbo version &quot;</span> + Version.getVersion() + <span class="hljs-string">&quot;, please config &lt;dubbo:registry address=\&quot;...\&quot; /&gt; to your spring config.&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 服务直连（单个注册中心或服务提供者）</span><br>        <span class="hljs-keyword">if</span> (urls.size() == <span class="hljs-number">1</span>) &#123;<br>            invoker = REF_PROTOCOL.refer(interfaceClass, urls.get(<span class="hljs-number">0</span>));<br>        <span class="hljs-comment">// 多个注册中心或多个服务提供者，或两者混合</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            List&lt;Invoker&lt;?&gt;&gt; invokers = <span class="hljs-keyword">new</span> ArrayList&lt;Invoker&lt;?&gt;&gt;();<br>            URL registryURL = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-comment">// 获取所有的 Invoker</span><br>            <span class="hljs-keyword">for</span> (URL url : urls) &#123;<br>                <span class="hljs-comment">// 通过 refprotocol 调用 refer 构建 Invoker，refprotocol 会在运行时根据 url 协议头加载指定的 protocol 实例，并调用实例的 refer 方法</span><br>                invokers.add(REF_PROTOCOL.refer(interfaceClass, url));<br>                <span class="hljs-keyword">if</span> (REGISTRY_PROTOCOL.equals(url.getProtocol())) &#123;<br>                    registryURL = url; <span class="hljs-comment">// use last registry url</span><br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (registryURL != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// registry url is available</span><br>                <span class="hljs-comment">// 如果注册中心链接不为空，则将使用 AvailableCluster</span><br>                <span class="hljs-comment">// use RegistryAwareCluster only when register&#x27;s CLUSTER is available</span><br>                URL u = registryURL.addParameter(CLUSTER_KEY, RegistryAwareCluster.NAME);<br>                <span class="hljs-comment">// 创建 StaticDirectory 实例，并由 Cluster 对多个 Invoker 进行合并</span><br>                <span class="hljs-comment">// The invoker wrap relation would be: RegistryAwareClusterInvoker(StaticDirectory) -&gt; FailoverClusterInvoker(RegistryDirectory, will execute route) -&gt; Invoker</span><br>                invoker = CLUSTER.join(<span class="hljs-keyword">new</span> StaticDirectory(u, invokers));<br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// not a registry url, must be direct invoke.</span><br>                invoker = CLUSTER.join(<span class="hljs-keyword">new</span> StaticDirectory(invokers));<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (shouldCheck() &amp;&amp; !invoker.isAvailable()) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;Failed to check the status of the service &quot;</span> + interfaceName + <span class="hljs-string">&quot;. No provider available for the service &quot;</span> + (group == <span class="hljs-keyword">null</span> ? <span class="hljs-string">&quot;&quot;</span> : group + <span class="hljs-string">&quot;/&quot;</span>) + interfaceName + (version == <span class="hljs-keyword">null</span> ? <span class="hljs-string">&quot;&quot;</span> : <span class="hljs-string">&quot;:&quot;</span> + version) + <span class="hljs-string">&quot; from the url &quot;</span> + invoker.getUrl() + <span class="hljs-string">&quot; to the consumer &quot;</span> + NetUtils.getLocalHost() + <span class="hljs-string">&quot; use dubbo version &quot;</span> + Version.getVersion());<br>    &#125;<br>    <span class="hljs-keyword">if</span> (logger.isInfoEnabled()) &#123;<br>        logger.info(<span class="hljs-string">&quot;Refer dubbo service &quot;</span> + interfaceClass.getName() + <span class="hljs-string">&quot; from url &quot;</span> + invoker.getUrl());<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span> 2.7.0</span><br><span class="hljs-comment">     * ServiceData Store</span><br><span class="hljs-comment">     */</span><br>    MetadataReportService metadataReportService = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">if</span> ((metadataReportService = getMetadataReportService()) != <span class="hljs-keyword">null</span>) &#123;<br>        URL consumerURL = <span class="hljs-keyword">new</span> URL(CONSUMER_PROTOCOL, map.remove(REGISTER_IP_KEY), <span class="hljs-number">0</span>, map.get(INTERFACE_KEY), map);<br>        metadataReportService.publishConsumer(consumerURL);<br>    &#125;<br>    <span class="hljs-comment">// 生成代理类</span><br>    <span class="hljs-comment">// create service proxy</span><br>    <span class="hljs-keyword">return</span> (T) PROXY_FACTORY.getProxy(invoker);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面代码很多，不过逻辑比较清晰。</p>
<ol>
<li><p>如果是本地调用，直接jvm 协议从内存中获取实例</p>
</li>
<li><p>如果只有一个注册中心，直接通过 Protocol 自适应拓展类构建 Invoker 实例接口</p>
</li>
<li><p>如果有多个注册中心，此时先根据 url 构建 Invoker。然后再通过 Cluster 合并多个 Invoker，最后调用 ProxyFactory 生成代理类</p>
</li>
</ol>
<p>创建客户端</p>
<p>在服务消费方，Invoker 用于执行远程调用。Invoker 是由 Protocol 实现类构建而来。Protocol 实现类有很多，这里分析DubboProtocol</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">Invoker&lt;T&gt; <span class="hljs-title">protocolBindingRefer</span><span class="hljs-params">(Class&lt;T&gt; serviceType, URL url)</span> <span class="hljs-keyword">throws</span> RpcException </span>&#123;<br>    optimizeSerialization(url);<br><br>    <span class="hljs-comment">// 创建 DubboInvoker</span><br>    <span class="hljs-comment">// create rpc invoker.</span><br>    DubboInvoker&lt;T&gt; invoker = <span class="hljs-keyword">new</span> DubboInvoker&lt;T&gt;(serviceType, url, getClients(url), invokers);<br>    invokers.add(invoker);<br><br>    <span class="hljs-keyword">return</span> invoker;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面方法看起来比较简单，创建一个DubboInvoker。通过构造方法传入远程调用的client对象。默认情况下，Dubbo 使用 NettyClient 进行通信。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> ExchangeClient[] getClients(URL url) &#123;<br>    <span class="hljs-comment">// whether to share connection</span><br>    <span class="hljs-comment">// 是否共享连接</span><br>    <span class="hljs-keyword">boolean</span> useShareConnect = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-comment">// 获取连接数，默认为0，表示未配置</span><br>    <span class="hljs-keyword">int</span> connections = url.getParameter(CONNECTIONS_KEY, <span class="hljs-number">0</span>);<br>    List&lt;ReferenceCountExchangeClient&gt; shareClients = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">// if not configured, connection is shared, otherwise, one connection for one service</span><br>    <span class="hljs-comment">// 如果未配置 connections，则共享连接</span><br>    <span class="hljs-keyword">if</span> (connections == <span class="hljs-number">0</span>) &#123;<br>        useShareConnect = <span class="hljs-keyword">true</span>;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * The xml configuration should have a higher priority than properties.</span><br><span class="hljs-comment">         */</span><br>        String shareConnectionsStr = url.getParameter(SHARE_CONNECTIONS_KEY, (String) <span class="hljs-keyword">null</span>);<br>        connections = Integer.parseInt(StringUtils.isBlank(shareConnectionsStr) ? ConfigUtils.getProperty(SHARE_CONNECTIONS_KEY,<br>                DEFAULT_SHARE_CONNECTIONS) : shareConnectionsStr);<br>        shareClients = getSharedClient(url, connections);<br>    &#125;<br><br>    ExchangeClient[] clients = <span class="hljs-keyword">new</span> ExchangeClient[connections];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; clients.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (useShareConnect) &#123;<br>            <span class="hljs-comment">// 获取共享客户端</span><br>            clients[i] = shareClients.get(i);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 初始化新的客户端</span><br>            clients[i] = initClient(url);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> clients;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里根据 connections 数量决定是获取共享客户端还是创建新的客户端实例，getSharedClient 方法中也会调用 initClient 方法，因此下面我们一起看一下这个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> ExchangeClient <span class="hljs-title">initClient</span><span class="hljs-params">(URL url)</span> </span>&#123;<br><br>    <span class="hljs-comment">// 获取客户端类型，默认为 netty</span><br>    <span class="hljs-comment">// client type setting.</span><br>    String str = url.getParameter(CLIENT_KEY, url.getParameter(SERVER_KEY, DEFAULT_REMOTING_CLIENT));<br><br>    url = url.addParameter(CODEC_KEY, DubboCodec.NAME);<br>    <span class="hljs-comment">// enable heartbeat by default</span><br>    url = url.addParameterIfAbsent(HEARTBEAT_KEY, String.valueOf(DEFAULT_HEARTBEAT));<br><br>    <span class="hljs-comment">// BIO is not allowed since it has severe performance issue.</span><br>    <span class="hljs-keyword">if</span> (str != <span class="hljs-keyword">null</span> &amp;&amp; str.length() &gt; <span class="hljs-number">0</span> &amp;&amp; !ExtensionLoader.getExtensionLoader(Transporter.class).hasExtension(str)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RpcException(<span class="hljs-string">&quot;Unsupported client type: &quot;</span> + str + <span class="hljs-string">&quot;,&quot;</span> +<br>                <span class="hljs-string">&quot; supported client type is &quot;</span> + StringUtils.join(ExtensionLoader.getExtensionLoader(Transporter.class).getSupportedExtensions(), <span class="hljs-string">&quot; &quot;</span>));<br>    &#125;<br><br>    ExchangeClient client;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 获取lazy配置，并根据配置值决定创建的客户端类型</span><br>        <span class="hljs-comment">// connection should be lazy</span><br>        <span class="hljs-keyword">if</span> (url.getParameter(LAZY_CONNECT_KEY, <span class="hljs-keyword">false</span>)) &#123;<br>            <span class="hljs-comment">// 创建懒加载 ExchangeClient 实例</span><br>            client = <span class="hljs-keyword">new</span> LazyConnectExchangeClient(url, requestHandler);<br><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 创建普通 ExchangeClient 实例</span><br>            client = Exchangers.connect(url, requestHandler);<br>        &#125;<br><br>    &#125; <span class="hljs-keyword">catch</span> (RemotingException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RpcException(<span class="hljs-string">&quot;Fail to create remoting client for service(&quot;</span> + url + <span class="hljs-string">&quot;): &quot;</span> + e.getMessage(), e);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> client;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>initClient 方法首先获取用户配置的客户端类型，默认为 netty。下面我们分析一下 Exchangers 的 connect 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExchangeClient <span class="hljs-title">connect</span><span class="hljs-params">(URL url, ExchangeHandler handler)</span> <span class="hljs-keyword">throws</span> RemotingException </span>&#123;<br>    <span class="hljs-keyword">if</span> (url == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;url == null&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (handler == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;handler == null&quot;</span>);<br>    &#125;<br>    url = url.addParameterIfAbsent(Constants.CODEC_KEY, <span class="hljs-string">&quot;exchange&quot;</span>);<br>    <span class="hljs-comment">// 获取 Exchanger 实例，默认为 HeaderExchangeClient</span><br>    <span class="hljs-keyword">return</span> getExchanger(url).connect(url, handler);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>getExchanger 方法会通过 SPI 加载 HeaderExchangeClient 实例，这里主要看connect 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ExchangeClient <span class="hljs-title">connect</span><span class="hljs-params">(URL url, ExchangeHandler handler)</span> <span class="hljs-keyword">throws</span> RemotingException </span>&#123;<br>    <span class="hljs-comment">// 这里包含多个调用，分别如下：</span><br>    <span class="hljs-comment">// 1. 创建 HeaderExchangeHandler 对象</span><br>    <span class="hljs-comment">// 2. 创建 DecodeHandler 对象</span><br>    <span class="hljs-comment">// 3. 通过 Transporters 构建 Client 实例</span><br>    <span class="hljs-comment">// 4. 创建 HeaderExchangeClient 对象</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HeaderExchangeClient(Transporters.connect(url, <span class="hljs-keyword">new</span> DecodeHandler(<span class="hljs-keyword">new</span> HeaderExchangeHandler(handler))), <span class="hljs-keyword">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>调用比较多，重点看一下 Transporters 的 connect 方法。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Client <span class="hljs-title">connect</span><span class="hljs-params">(URL url, ChannelHandler... handlers)</span> <span class="hljs-keyword">throws</span> RemotingException </span>&#123;<br>    <span class="hljs-keyword">if</span> (url == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;url == null&quot;</span>);<br>    &#125;<br>    ChannelHandler handler;<br>    <span class="hljs-keyword">if</span> (handlers == <span class="hljs-keyword">null</span> || handlers.length == <span class="hljs-number">0</span>) &#123;<br>        handler = <span class="hljs-keyword">new</span> ChannelHandlerAdapter();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (handlers.length == <span class="hljs-number">1</span>) &#123;<br>        handler = handlers[<span class="hljs-number">0</span>];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果 handler 数量大于1，则创建一个 channelHandler 分发器</span><br>        handler = <span class="hljs-keyword">new</span> ChannelHandlerDispatcher(handlers);<br>    &#125;<br>    <span class="hljs-comment">// 获取 Transporter 自适应拓展类，并调用 connect 方法生成 client 实例</span><br>    <span class="hljs-keyword">return</span> getTransporter().connect(url, handler);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如上，getTransporter 方法返回的是自适应拓展类，该类会在运行时根据客户端类型加载指定的Transporter 实现类。若用户未配置客户端类型，则默认加载 NettyTransporter，并调用该类的connect 方法。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Client <span class="hljs-title">connect</span><span class="hljs-params">(URL url, ChannelHandler listener)</span> <span class="hljs-keyword">throws</span> RemotingException </span>&#123;<br>    <span class="hljs-comment">// 创建 NettyClient 对象</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> NettyClient(url, listener);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>注册</strong></p>
<p>这里就已经创建好了NettyClient对象。关于 DubboProtocol 的 refer 方法就分析完了。接下来，继续分析 RegistryProtocol 的 refer 方法逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">Invoker&lt;T&gt; <span class="hljs-title">refer</span><span class="hljs-params">(Class&lt;T&gt; type, URL url)</span> <span class="hljs-keyword">throws</span> RpcException </span>&#123;<br>    <span class="hljs-comment">// 取 registry 参数值，并将其设置为协议头</span><br>    url = URLBuilder.from(url)<br>            .setProtocol(url.getParameter(REGISTRY_KEY, DEFAULT_REGISTRY))<br>            .removeParameter(REGISTRY_KEY)<br>            .build();<br>    <span class="hljs-comment">// 获取注册中心实例</span><br>    Registry registry = registryFactory.getRegistry(url);<br>    <span class="hljs-keyword">if</span> (RegistryService.class.equals(type)) &#123;<br>        <span class="hljs-keyword">return</span> proxyFactory.getInvoker((T) registry, type, url);<br>    &#125;<br><br>    <span class="hljs-comment">// 将 url 查询字符串转为 Map</span><br>    <span class="hljs-comment">// group=&quot;a,b&quot; or group=&quot;*&quot;</span><br>    Map&lt;String, String&gt; qs = StringUtils.parseQueryString(url.getParameterAndDecoded(REFER_KEY));<br>    <span class="hljs-comment">// 获取 group 配置</span><br>    String group = qs.get(GROUP_KEY);<br>    <span class="hljs-keyword">if</span> (group != <span class="hljs-keyword">null</span> &amp;&amp; group.length() &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> ((COMMA_SPLIT_PATTERN.split(group)).length &gt; <span class="hljs-number">1</span> || <span class="hljs-string">&quot;*&quot;</span>.equals(group)) &#123;<br>            <span class="hljs-comment">// 通过 SPI 加载 MergeableCluster 实例，并调用 doRefer 继续执行</span><br>            <span class="hljs-keyword">return</span> doRefer(getMergeableCluster(), registry, type, url);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 调用 doRefer 继续执行服务引用逻辑</span><br>    <span class="hljs-keyword">return</span> doRefer(cluster, registry, type, url);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面代码首先为 url 设置协议头，然后根据 url 参数加载注册中心实例。然后获取 group 配置，根据group 配置决定 doRefer 第一个参数的类型。这里的重点是 doRefer 方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> &lt;T&gt; <span class="hljs-function">Invoker&lt;T&gt; <span class="hljs-title">doRefer</span><span class="hljs-params">(Cluster cluster, Registry registry, Class&lt;T&gt; type, URL url)</span> </span>&#123;<br>    <span class="hljs-comment">// 创建 RegistryDirectory 实例</span><br>    RegistryDirectory&lt;T&gt; directory = <span class="hljs-keyword">new</span> RegistryDirectory&lt;T&gt;(type, url);<br>    <span class="hljs-comment">// 设置注册中心和协议</span><br>    directory.setRegistry(registry);<br>    directory.setProtocol(protocol);<br>    <span class="hljs-comment">// all attributes of REFER_KEY</span><br>    Map&lt;String, String&gt; parameters = <span class="hljs-keyword">new</span> HashMap&lt;String, String&gt;(directory.getUrl().getParameters());<br>    <span class="hljs-comment">// 生成服务消费者连接</span><br>    URL subscribeUrl = <span class="hljs-keyword">new</span> URL(CONSUMER_PROTOCOL, parameters.remove(REGISTER_IP_KEY), <span class="hljs-number">0</span>, type.getName(), parameters);<br>    <span class="hljs-comment">// 注册服务消费者，在 consumers 目录下新节点</span><br>    <span class="hljs-keyword">if</span> (!ANY_VALUE.equals(url.getServiceInterface()) &amp;&amp; url.getParameter(REGISTER_KEY, <span class="hljs-keyword">true</span>)) &#123;<br>        directory.setRegisteredConsumerUrl(getRegisteredConsumerUrl(subscribeUrl, url));<br>        registry.register(directory.getRegisteredConsumerUrl());<br>    &#125;<br>    <span class="hljs-comment">// 订阅 providers、configurators、routers 等节点数据</span><br>    directory.buildRouterChain(subscribeUrl);<br>    directory.subscribe(subscribeUrl.addParameter(CATEGORY_KEY,<br>            PROVIDERS_CATEGORY + <span class="hljs-string">&quot;,&quot;</span> + CONFIGURATORS_CATEGORY + <span class="hljs-string">&quot;,&quot;</span> + ROUTERS_CATEGORY));<br>    <span class="hljs-comment">// 一个注册中心可能有多个服务提供者，因此这里需要将多个服务提供者合并为一个</span><br>    Invoker invoker = cluster.join(directory);<br>    ProviderConsumerRegTable.registerConsumer(invoker, url, subscribeUrl, directory);<br>    <span class="hljs-keyword">return</span> invoker;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如上，doRefer 方法创建一个 RegistryDirectory 实例，然后生成服务消费者链接，并向注册中心进行注册。注册完毕后，紧接着订阅 providers、confifigurators、routers 等节点下的数据。完成订阅后，RegistryDirectory 会收到这几个节点下的子节点信息。由于一个服务可能部署在多台服务器上，这样就会在 providers 产生多个节点，这个时候就需要 Cluster 将多个服务节点合并为一个，并生成一个Invoker。 </p>
<p><strong>创建代理对象</strong></p>
<p>Invoker 创建完毕后，接下来要做的事情是为服务接口生成代理对象。有了代理对象，即可进行远程调用。代理对象生成的入口方法为 ProxyFactory 的 getProxy，接下来进行分析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getProxy</span><span class="hljs-params">(Invoker&lt;T&gt; invoker)</span> <span class="hljs-keyword">throws</span> RpcException </span>&#123;<br>    <span class="hljs-comment">// 调用重载方法</span><br>    <span class="hljs-keyword">return</span> getProxy(invoker, <span class="hljs-keyword">false</span>);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getProxy</span><span class="hljs-params">(Invoker&lt;T&gt; invoker, <span class="hljs-keyword">boolean</span> generic)</span> <span class="hljs-keyword">throws</span> RpcException </span>&#123;<br>    Class&lt;?&gt;[] interfaces = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">// 获取接口列表</span><br>    String config = invoker.getUrl().getParameter(INTERFACES);<br>    <span class="hljs-keyword">if</span> (config != <span class="hljs-keyword">null</span> &amp;&amp; config.length() &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 切分接口列表</span><br>        String[] types = COMMA_SPLIT_PATTERN.split(config);<br>        <span class="hljs-keyword">if</span> (types != <span class="hljs-keyword">null</span> &amp;&amp; types.length &gt; <span class="hljs-number">0</span>) &#123;<br>            interfaces = <span class="hljs-keyword">new</span> Class&lt;?&gt;[types.length + <span class="hljs-number">2</span>];<br>            <span class="hljs-comment">// 设置服务接口类和 EchoService.class 到 interfaces 中</span><br>            interfaces[<span class="hljs-number">0</span>] = invoker.getInterface();<br>            interfaces[<span class="hljs-number">1</span>] = EchoService.class;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; types.length; i++) &#123;<br>                <span class="hljs-comment">// 加载接口类</span><br>                <span class="hljs-comment">// TODO can we load successfully for a different classloader?.</span><br>                interfaces[i + <span class="hljs-number">2</span>] = ReflectUtils.forName(types[i]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (interfaces == <span class="hljs-keyword">null</span>) &#123;<br>        interfaces = <span class="hljs-keyword">new</span> Class&lt;?&gt;[]&#123;invoker.getInterface(), EchoService.class&#125;;<br>    &#125;<br><br>    <span class="hljs-comment">// 为 http 和 hessian 协议提供泛化调用支持，参考 pull request #1827</span><br>    <span class="hljs-keyword">if</span> (!GenericService.class.isAssignableFrom(invoker.getInterface()) &amp;&amp; generic) &#123;<br>        <span class="hljs-keyword">int</span> len = interfaces.length;<br>        Class&lt;?&gt;[] temp = interfaces;<br>        <span class="hljs-comment">// 创建新的 interfaces 数组</span><br>        interfaces = <span class="hljs-keyword">new</span> Class&lt;?&gt;[len + <span class="hljs-number">1</span>];<br>        System.arraycopy(temp, <span class="hljs-number">0</span>, interfaces, <span class="hljs-number">0</span>, len);<br>        <span class="hljs-comment">// 设置 GenericService.class 到数组中</span><br>        interfaces[len] = com.alibaba.dubbo.rpc.service.GenericService.class;<br>    &#125;<br><br>    <span class="hljs-comment">// 调用重载方法</span><br>    <span class="hljs-keyword">return</span> getProxy(invoker, interfaces);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如上，上面大段代码都是用来获取 interfaces 数组的，我们继续往下看。getProxy(Invoker, Class&lt;?&gt;[]) 这个方法是一个抽象方法，下面我们到 JavassistProxyFactory 类中看一下该方法的实现代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getProxy</span><span class="hljs-params">(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces)</span> </span>&#123;<br>    <span class="hljs-comment">// 生成 Proxy 子类（Proxy 是抽象类）。并调用 Proxy 子类的 newInstance 方法创建 Proxy 实例</span><br>    <span class="hljs-keyword">return</span> (T) Proxy.getProxy(interfaces).newInstance(<span class="hljs-keyword">new</span> InvokerInvocationHandler(invoker));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面代码并不多，首先是通过 JavassistProxyFactory 的 getProxy 方法获取 Proxy 子类，然后创建InvokerInvocationHandler 对象，并将该对象传给 newInstance 生成 Proxy 实例。InvokerInvocationHandler 实现 JDK 的 InvocationHandler 接口，具体的用途是拦截接口类调用。</p>
<p><strong>总结</strong></p>
<ol>
<li><p>从注册中心发现引用服务：在有注册中心，通过注册中心发现提供者地址的情况下，ReferenceConfig 解析出的 URL 格式为： registry://registry-host:/org.apache.registry.RegistryService?refer=URL.encode(“conumer-host/com.foo.FooService?version=1.0.0”) 。 </p>
</li>
<li><p>通过 URL 的registry://协议头识别，就会调用RegistryProtocol#refer()方法</p>
<ol>
<li>查询提供者 URL，如 dubbo://service-host/com.foo.FooService?version=1.0.0 ，来获取注册中心</li>
<li>创建一个 RegistryDirectory 实例并设置注册中心和协议</li>
<li>生成 conusmer 连接，在 consumer 目录下创建节点，向注册中心注册</li>
<li>注册完毕后，订阅 providers，confifigurators，routers 等节点的数据</li>
<li>通过 URL 的 dubbo:// 协议头识别，调用 DubboProtocol#refer() 方法，创建一个ExchangeClient 客户端并返回 DubboInvoker 实例</li>
</ol>
</li>
<li><p>由于一个服务可能会部署在多台服务器上，这样就会在 providers 产生多个节点，这样也就会得到多个 DubboInvoker 实例，就需要 RegistryProtocol 调用 Cluster 将多个服务提供者节点伪装成一个节点，并返回一个 Invoker</p>
</li>
<li><p>Invoker 创建完毕后，调用 ProxyFactory 为服务接口生成代理对象，返回提供者引用</p>
</li>
</ol>
<h3 id="高可用集群"><a href="#高可用集群" class="headerlink" title="高可用集群"></a>高可用集群</h3><h4 id="服务集群的概述"><a href="#服务集群的概述" class="headerlink" title="服务集群的概述"></a>服务集群的概述</h4><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p>为了避免单点故障，现在的应用通常至少会部署在两台服务器上，这样就组成了集群。集群就是单机的多实例，在多个服务器上部署多个服务，每个服务就是一个节点，部署N个节点，处理业务的能力就提升 N倍（大约），这些节点的集合就叫做集群。</p>
<p><img src="/blog/2021/04/27/Dubbo/dubbo%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/pic10.png" srcset="/blog/img/loading.gif" lazyload></p>
<h5 id="管理控制台"><a href="#管理控制台" class="headerlink" title="管理控制台"></a>管理控制台</h5><p>目前的管理控制台已经发布0.1版本，结构上采取了前后端分离的方式，前端使用Vue和Vuetify分别作为Javascript框架和UI框架，后端采用Spring Boot框架。既可以按照标准的Maven方式进行打包，部署，也可以采用前后端分离的部署方式，方便开发，功能上，目前具备了服务查询，服务治理(包括Dubbo2.7中新增的治理规则)以及服务测试三部分内容。</p>
<p>Maven方式部署</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">git <span class="hljs-built_in">clone</span> https://github.com/apache/dubbo-admin.git<br><span class="hljs-built_in">cd</span> dubbo-admin mvn clean package<br><span class="hljs-built_in">cd</span> dubbo-admin-distribution/target<br>java -jar dubbo-admin-0.1.jar<br></code></pre></td></tr></table></figure>

<p>访问：<a target="_blank" rel="noopener" href="http://localhost:8080/">http://localhost:8080</a></p>
<p>前后端分离部署</p>
<p>前端</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> dubbo-admin-ui<br>npm install<br>npm run dev<br></code></pre></td></tr></table></figure>

<p>后端</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> dubbo-admin-server<br>mvn clean package<br><span class="hljs-built_in">cd</span> target<br>java -jar dubbo-admin-server-0.1.jar<br></code></pre></td></tr></table></figure>

<p>访问：<a target="_blank" rel="noopener" href="http://localhost:8081/">http://localhost:8081</a></p>
<p>前后端分离模式下，前端的修改可以实时生效</p>
<h4 id="集群的调用过程"><a href="#集群的调用过程" class="headerlink" title="集群的调用过程"></a>集群的调用过程</h4><h5 id="调用过程"><a href="#调用过程" class="headerlink" title="调用过程"></a>调用过程</h5><p>在对集群相关代码进行分析之前，这里有必要先来介绍一下集群容错的所有组件。包含 Cluster、Cluster Invoker、Directory、Router 和 LoadBalance 等。</p>
<p><img src="/blog/2021/04/27/Dubbo/dubbo%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/pic11.png" srcset="/blog/img/loading.gif" lazyload></p>
<p>集群工作过程可分为两个阶段，第一个阶段是在服务消费者初始化期间，集群 Cluster 实现类为服务消费者创建 Cluster Invoker 实例，即上图中的 merge 操作。第二个阶段是在服务消费者进行远程调用时。以 FailoverClusterInvoker 为例，该类型 Cluster Invoker 首先会调用 Directory 的 list 方法列举Invoker 列表（可将 Invoker 简单理解为服务提供者）。Directory 的用途是保存 Invoker，可简单类比为 List。其实现类 RegistryDirectory 是一个动态服务目录，可感知注册中心配置的变化，它所持有的Invoker 列表会随着注册中心内容的变化而变化。每次变化后，RegistryDirectory 会动态增删Invoker，并调用 Router 的 route 方法进行路由，过滤掉不符合路由规则的 Invoker。当FailoverClusterInvoker 拿到 Directory 返回的 Invoker 列表后，它会通过 LoadBalance 从 Invoker 列表中选择一个 Invoker。最后 FailoverClusterInvoker 会将参数传给 LoadBalance 选择出的 Invoker 实例的 invoke 方法，进行真正的远程调用。</p>
<h5 id="组件介绍"><a href="#组件介绍" class="headerlink" title="组件介绍"></a>组件介绍</h5><ul>
<li><p>Directory：它代表多个Invoker，从methodInvokerMap提取，但是他的值是动态，例如注册中心的变更。</p>
</li>
<li><p>Router：负责从多个Invoker中按路由规则选出子集，例如应用隔离或读写分离或灰度发布等等</p>
</li>
<li><p>Cluster：将Directory中的多个Invoker伪装成一个Invoker,来容错，调用失败重试。</p>
</li>
<li><p>LoadBalance：从多个Invoker选取一个做本次调用，具体包含很多种负载均衡算法。</p>
</li>
<li><p>Invoker：Provider中的一个可调用接口。例如DemoService</p>
</li>
</ul>
<h4 id="集群容错"><a href="#集群容错" class="headerlink" title="集群容错"></a>集群容错</h4><p>在分布式系统中，集群某个某些节点出现问题是大概率事件，因此在设计分布式RPC框架的过程中，必须要把失败作为设计的一等公民来对待。一次调用失败之后，应该如何选择对失败的选择策略，这是一个见仁见智的问题，每种策略可能都有自己独特的应用场景。因此，作为框架来说，应当针对不同场景提供多种策略，供用户进行选择。</p>
<p>在Dubbo设计中，通过Cluster这个接口的抽象，把一组可供调用的Provider信息组合成为一个统一的Invoker 供调用方进行调用。经过路由规则过滤，负载均衡选址后，选中一个具体地址进行调用，如果调用失败，则会按照集群配置的容错策略进行容错处理。</p>
<h5 id="内置集群容错方式"><a href="#内置集群容错方式" class="headerlink" title="内置集群容错方式"></a>内置集群容错方式</h5><p>Dubbo默认内置了若干容错策略，如果不能满足用户需求，则可以通过自定义容错策略进行配置</p>
<p>Dubbo主要内置了如下几种策略：</p>
<ul>
<li>Failover(失败自动切换)</li>
<li>Failsafe(失败安全)</li>
<li>Failfast(快速失败)</li>
<li>Failback(失败自动恢复)</li>
<li>Forking(并行调用)</li>
<li>Broadcast(广播调用)</li>
</ul>
<p>这些名称比较相似，概念也比较容易混淆，下面逐一进行解释。</p>
<h6 id="Failover-失败自动切换"><a href="#Failover-失败自动切换" class="headerlink" title="Failover(失败自动切换)"></a>Failover(失败自动切换)</h6><p>Failover 是高可用系统中的一个常用概念，服务器通常拥有主备两套机器配置，如果主服务器出现故障，则自动切换到备服务器中，从而保证了整体的高可用性。</p>
<p>Dubbo也借鉴了这个思想，并且把它作为Dubbo 默认的容错策略 。当调用出现失败的时候，根据配置的重试次数，会自动从其他可用地址中重新选择一个可用的地址进行调用，直到调用成功，或者是达到重试的上限位置。</p>
<p>Dubbo里默认配置的重试次数是2，也就是说，算上第一次调用，最多会调用3次。</p>
<p>其配置方法，容错策略既可以在服务提供方配置，也可以服务调用方进行配置。而重试次数的配置则更为灵活，既可以在服务级别进行配置，也可以在方法级别进行配置。具体优先顺序为：</p>
<p>服务调用方方法级配置 &gt; 服务调用方服务级配置 &gt; 服务提供方方法级配置 &gt; 服务提供方服务级配置 </p>
<p>以XML方式为例，具体配置方法如下：</p>
<p>服务提供方，服务级配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:service</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;org.apache.dubbo.demo.DemoService&quot;</span> </span><br><span class="hljs-tag">               <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;demoService&quot;</span> <span class="hljs-attr">cluster</span>=<span class="hljs-string">&quot;failover&quot;</span> <span class="hljs-attr">retries</span>=<span class="hljs-string">&quot;2&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure>

<p>服务提供方，方法级配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:service</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;org.apache.dubbo.demo.DemoService&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;demoService&quot;</span> <span class="hljs-attr">cluster</span>=<span class="hljs-string">&quot;failover&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sayHello&quot;</span> <span class="hljs-attr">retries</span>=<span class="hljs-string">&quot;2&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dubbo:reference</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>服务调用方，服务级配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:reference</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;demoService&quot;</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;org.apache.dubbo.demo.DemoService&quot;</span> </span><br><span class="hljs-tag">                 <span class="hljs-attr">cluster</span>=<span class="hljs-string">&quot;failover&quot;</span> <span class="hljs-attr">retries</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure>

<p>服务调用方，方法级配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:reference</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;demoService&quot;</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;org.apache.dubbo.demo.DemoService&quot;</span> <span class="hljs-attr">cluster</span>=<span class="hljs-string">&quot;failover&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sayHello&quot;</span> <span class="hljs-attr">retries</span>=<span class="hljs-string">&quot;3&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dubbo:reference</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>Failover可以自动对失败进行重试，对调用者屏蔽了失败的细节，但是Failover策略也会带来一些副作用：</p>
<ul>
<li><p>重试会额外增加一些开销，例如增加资源的使用，在高负载系统下，额外的重试可能让系统雪上加霜。</p>
</li>
<li><p>重试会增加调用的响应时间。</p>
</li>
<li><p>某些情况下，重试甚至会造成资源的浪费。考虑一个调用场景，A-&gt;B-&gt;C，如果A处设置了超时100ms，再B-&gt;C的第一次调用完成时已经超过了100ms，但很不幸B-&gt;C失败，这时候会进行重试，但其实这时候重试已经没有意义，因此在A看来这次调用已经超时，A可能已经开始执行其他逻辑。</p>
</li>
</ul>
<h6 id="Failsafe-失败安全"><a href="#Failsafe-失败安全" class="headerlink" title="Failsafe(失败安全)"></a>Failsafe(失败安全)</h6><p>失败安全策略的核心是即使失败了也不会影响整个调用流程。通常情况下用于旁路系统或流程中，它的失败不影响核心业务的正确性。在实现上，当出现调用失败时，会忽略此错误，并记录一条日志，同时返回一个空结果，在上游看来调用是成功的。</p>
<p>应用场景，可以用于写入审计日志等操作。</p>
<p>具体配置方法：</p>
<p>服务提供方，服务级配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:service</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;org.apache.dubbo.demo.DemoService&quot;</span> </span><br><span class="hljs-tag">               <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;demoService&quot;</span> <span class="hljs-attr">cluster</span>=<span class="hljs-string">&quot;failsafe&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>

<p>服务调用方，服务级配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:reference</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;demoService&quot;</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;org.apache.dubbo.demo.DemoService&quot;</span> </span><br><span class="hljs-tag">                 <span class="hljs-attr">cluster</span>=<span class="hljs-string">&quot;failsafe&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure>

<p>其中服务调用方配置优先于服务提供方配置。</p>
<h6 id="Failfast-快速失败"><a href="#Failfast-快速失败" class="headerlink" title="Failfast(快速失败)"></a>Failfast(快速失败)</h6><p>某些业务场景中，某些操作可能是非幂等的，如果重复发起调用，可能会导致出现脏数据等。例如调用某个服务，其中包含一个数据库的写操作，如果写操作完成，但是在发送结果给调用方的过程中出错了，那么在调用发看来这次调用失败了，但其实数据写入已经完成。这种情况下，重试可能并不是一个好策略，这时候就需要使用到 Failfast 策略，调用失败立即报错。让调用方来决定下一步的操作并保证业务的幂等性。</p>
<p>具体配置方法：</p>
<p>服务提供方，服务级配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:service</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;org.apache.dubbo.demo.DemoService&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;demoService&quot;</span> </span><br><span class="hljs-tag">               <span class="hljs-attr">cluster</span>=<span class="hljs-string">&quot;failfast&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>

<p>服务调用方，服务级配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:reference</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;demoService&quot;</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;org.apache.dubbo.demo.DemoService&quot;</span> </span><br><span class="hljs-tag">                 <span class="hljs-attr">cluster</span>=<span class="hljs-string">&quot;failfast&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure>

<p>其中服务调用方配置优先于服务提供方配置。</p>
<h6 id="Failback-失败自动恢复"><a href="#Failback-失败自动恢复" class="headerlink" title="Failback(失败自动恢复)"></a>Failback(失败自动恢复)</h6><p>Failback 通常和 Failover 两个概念联系在一起。在高可用系统中，当主机发生故障，通过Failover 进行主备切换后，待故障恢复后，系统应该具备自动恢复原始配置的能力。</p>
<p>Dubbo中的 Failback 策略中，如果调用失败，则此次失败相当于 Failsafe ，将返回一个空结果。而与 Failsafe 不同的是，Failback策略会将这次调用加入内存中的失败列表中，对于这个列表中的失败调用，会在另一个线程中进行异步重试，重试如果再发生失败，则会忽略，即使重试调用成功，原来的调用方也感知不到了。因此它通常适合于，对于实时性要求不高，且不需要返回值的一些异步操作。</p>
<p>具体配置方法：</p>
<p>服务提供方，服务级配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:service</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;org.apache.dubbo.demo.DemoService&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;demoService&quot;</span> </span><br><span class="hljs-tag">               <span class="hljs-attr">cluster</span>=<span class="hljs-string">&quot;failsafe&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>

<p>服务调用方，服务级配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:reference</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;demoService&quot;</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;org.apache.dubbo.demo.DemoService&quot;</span> </span><br><span class="hljs-tag">                 <span class="hljs-attr">cluster</span>=<span class="hljs-string">&quot;failsafe&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure>

<p>其中服务调用方配置优先于服务提供方配置。</p>
<p>按照目前的实现，Failback策略还有一些局限，例如内存中的失败调用列表没有上限，可能导致堆积，异步重试的执行间隔无法调整，默认是5秒。</p>
<h6 id="Forking-并行调用"><a href="#Forking-并行调用" class="headerlink" title="Forking(并行调用)"></a>Forking(并行调用)</h6><p>上述几种策略中，主要都是针对调用失败发生后如何进行弥补的角度去考虑的，而 Forking 策略则跟上述几种策略不同，是一种典型的用成本换时间的思路。即第一次调用的时候就同时发起多个调用，只要其中一个调用成功，就认为成功。在资源充足，且对于失败的容忍度较低的场景下，可以采用此策略。</p>
<p>具体配置方法：</p>
<p>服务提供方，服务级配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:service</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;org.apache.dubbo.demo.DemoService&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;demoService&quot;</span> </span><br><span class="hljs-tag">               <span class="hljs-attr">cluster</span>=<span class="hljs-string">&quot;forking&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>

<p>服务调用方，服务级配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:reference</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;demoService&quot;</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;org.apache.dubbo.demo.DemoService&quot;</span> </span><br><span class="hljs-tag">                 <span class="hljs-attr">cluster</span>=<span class="hljs-string">&quot;forking&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure>

<p>其中服务调用方配置优先于服务提供方配置。</p>
<h6 id="Broadcast-广播调用"><a href="#Broadcast-广播调用" class="headerlink" title="Broadcast(广播调用)"></a>Broadcast(广播调用)</h6><p>在某些场景下，可能需要对服务的所有提供者进行操作，此时可以使用广播调用策略。此策略会逐个调用所有提供者，只要任意有一个提供者出错，则认为此次调用出错。通常用于通知所有提供者更新缓存或日志等本地资源信息。</p>
<p>具体配置方法：</p>
<p>服务提供方，服务级配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:service</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;org.apache.dubbo.demo.DemoService&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;demoService&quot;</span> </span><br><span class="hljs-tag">               <span class="hljs-attr">cluster</span>=<span class="hljs-string">&quot;broadcast&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>

<p>服务调用方，服务级配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:reference</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;demoService&quot;</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;org.apache.dubbo.demo.DemoService&quot;</span> </span><br><span class="hljs-tag">                 <span class="hljs-attr">cluster</span>=<span class="hljs-string">&quot;broadcast&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure>

<p>其中服务调用方配置优先于服务提供方配置。</p>
<h5 id="集群容错调优"><a href="#集群容错调优" class="headerlink" title="集群容错调优"></a>集群容错调优</h5><p>下表对各种策略做一个简单对比：</p>
<table>
<thead>
<tr>
<th>策略名称</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>Failover</td>
<td>对调用者屏蔽调用失败的信息</td>
<td>增加RT，额外资源开销，资源浪费</td>
</tr>
<tr>
<td>Failfast</td>
<td>业务快速感知失败状态进行自主决策</td>
<td>产生较多报错的信息</td>
</tr>
<tr>
<td>Failsafe</td>
<td>即使失败了也不会影响核心流程</td>
<td>对于失败的信息不敏感，需要额外的监控</td>
</tr>
<tr>
<td>Failback</td>
<td>失败自动异步重试</td>
<td>重试任务可能堆积</td>
</tr>
<tr>
<td>Forking</td>
<td>并行发起多个调用，降低失败概率</td>
<td>消耗额外的机器资源，需要确保操作幂等性</td>
</tr>
<tr>
<td>Broadcast</td>
<td>支持对所有的服务提供者进行操作</td>
<td>资源消耗很大</td>
</tr>
</tbody></table>
<p>综上我们得知，不同的容错策略往往对应不同的业务处理，这里做一个总结如下：</p>
<ul>
<li><p><strong>Failover</strong> ：通常用于对调用rt不敏感的场景，如读操作；但重试会带来更长延迟</p>
</li>
<li><p><strong>Failfast</strong> ：通常用于非幂等性操作，需要快速感知失败的场景；比如新增记录</p>
</li>
<li><p><strong>Failsafe</strong> ：通常用于旁路系统，失败不影响核心流程正确性的场景；如日志记录</p>
</li>
<li><p><strong>Failback</strong> ：通常用于对于实时性要求不高，且不需要返回值的一些异步操作的场景</p>
</li>
<li><p><strong>Forking</strong> ：通常用于资源充足，且对于失败的容忍度较低，实时性要求高的读操作，但需要浪费更多服务资源</p>
</li>
<li><p><strong>Broadcast</strong>：如通知所有提供者更新缓存或日志等本地资源信息</p>
</li>
</ul>
<h5 id="源码分析-3"><a href="#源码分析-3" class="headerlink" title="源码分析"></a>源码分析</h5><p>集群接口 Cluster 和 Cluster Invoker这两者是不同的，Cluster 是接口，而 Cluster Invoker 是一种 Invoker。服务提供者的选择逻辑，以及远程调用失败后的的处理逻辑均是封装在 Cluster Invoker 中。 Cluster 接口和相关实现类用途比较简单，仅用于生成 Cluster Invoker。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FailoverCluster</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cluster</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String NAME = <span class="hljs-string">&quot;failover&quot;</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">Invoker&lt;T&gt; <span class="hljs-title">join</span><span class="hljs-params">(Directory&lt;T&gt; directory)</span> <span class="hljs-keyword">throws</span> RpcException </span>&#123;<br>        <span class="hljs-comment">// 创建并返回 FailoverClusterInvoker 对象</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FailoverClusterInvoker&lt;T&gt;(directory);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>如上，FailoverCluster 总共就包含这几行代码，用于创建 FailoverClusterInvoker 对象，很简单。下面再看一个。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FailbackCluster</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cluster</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String NAME = <span class="hljs-string">&quot;failback&quot;</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">Invoker&lt;T&gt; <span class="hljs-title">join</span><span class="hljs-params">(Directory&lt;T&gt; directory)</span> <span class="hljs-keyword">throws</span> RpcException </span>&#123;<br>        <span class="hljs-comment">// 创建并返回 FailbackClusterInvoker 对象</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FailbackClusterInvoker&lt;T&gt;(directory);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>FailbackCluster 的逻辑也是很简单</p>
<h6 id="Cluster-Invoker"><a href="#Cluster-Invoker" class="headerlink" title="Cluster Invoker"></a>Cluster Invoker</h6><p>我们首先从各种 Cluster Invoker 的父类 AbstractClusterInvoker 源码开始说起。前面说过，集群工作过程可分为两个阶段，第一个阶段是在服务消费者初始化期间，这个在服务引用那篇文章中分析过，就不赘述。第二个阶段是在服务消费者进行远程调用时，此时 AbstractClusterInvoker 的 invoke 方法会被调用。列举 Invoker，负载均衡等操作均会在此阶段被执行。因此下面先来看一下 AbstractClusterInvoker 中 invoke 方法的逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">invoke</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Invocation invocation)</span> <span class="hljs-keyword">throws</span> RpcException </span>&#123;<br>    checkWhetherDestroyed();<br><br>    <span class="hljs-comment">// 绑定 attachments 到 invocation 中</span><br>    <span class="hljs-comment">// binding attachments into invocation.</span><br>    Map&lt;String, String&gt; contextAttachments = RpcContext.getContext().getAttachments();<br>    <span class="hljs-keyword">if</span> (contextAttachments != <span class="hljs-keyword">null</span> &amp;&amp; contextAttachments.size() != <span class="hljs-number">0</span>) &#123;<br>        ((RpcInvocation) invocation).addAttachments(contextAttachments);<br>    &#125;<br><br>    <span class="hljs-comment">// 列举 Invoker</span><br>    List&lt;Invoker&lt;T&gt;&gt; invokers = list(invocation);<br>    <span class="hljs-comment">// 加载 loadBalance</span><br>    LoadBalance loadbalance = initLoadBalance(invokers, invocation);<br>    RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);<br>    <span class="hljs-comment">// 调用 doInvoke 进行后续操作</span><br>    <span class="hljs-keyword">return</span> doInvoke(invocation, invokers, loadbalance);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>AbstractClusterInvoker 的 invoke 方法主要用于列举 Invoker，以及加载 LoadBalance。最后再调用模板方法 doInvoke 进行后续操作。下面我们来看一下 Invoker 列举方法 list(Invocation) 的逻辑，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> List&lt;Invoker&lt;T&gt;&gt; list(Invocation invocation) <span class="hljs-keyword">throws</span> RpcException &#123;<br>    <span class="hljs-comment">// 调用 Directory 的 list 方法列举 Invoker</span><br>    <span class="hljs-keyword">return</span> directory.list(invocation);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如上，AbstractClusterInvoker 中的 list 方法做的事情很简单，只是简单的调用了 Directory 的 list 方法，没有其他更多的逻辑了。Directory 即相关实现类在前文已经分析过，这里就不多说了。接下来，我们把目光转移到 AbstractClusterInvoker 的各种实现类上，来看一下这些实现类是如何实现doInvoke 方法逻辑的。</p>
<h6 id="FailoverClusterInvoker"><a href="#FailoverClusterInvoker" class="headerlink" title="FailoverClusterInvoker"></a>FailoverClusterInvoker</h6><p>FailoverClusterInvoker 在调用失败时，会自动切换 Invoker 进行重试。默认配置下，Dubbo 会使用这个类作为缺省 Cluster Invoker。下面来看一下该类的逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">doInvoke</span><span class="hljs-params">(Invocation invocation, <span class="hljs-keyword">final</span> List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class="hljs-keyword">throws</span> RpcException </span>&#123;<br>    List&lt;Invoker&lt;T&gt;&gt; copyInvokers = invokers;<br>    checkInvokers(copyInvokers, invocation);<br>    String methodName = RpcUtils.getMethodName(invocation);<br>    <span class="hljs-comment">// 获取重试次数</span><br>    <span class="hljs-keyword">int</span> len = getUrl().getMethodParameter(methodName, RETRIES_KEY, DEFAULT_RETRIES) + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (len &lt;= <span class="hljs-number">0</span>) &#123;<br>        len = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// retry loop.</span><br>    RpcException le = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// last exception.</span><br>    List&lt;Invoker&lt;T&gt;&gt; invoked = <span class="hljs-keyword">new</span> ArrayList&lt;Invoker&lt;T&gt;&gt;(copyInvokers.size()); <span class="hljs-comment">// invoked invokers.</span><br>    Set&lt;String&gt; providers = <span class="hljs-keyword">new</span> HashSet&lt;String&gt;(len);<br>    <span class="hljs-comment">// 循环调用，失败重试</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>        <span class="hljs-comment">//Reselect before retry to avoid a change of candidate `invokers`.</span><br>        <span class="hljs-comment">//<span class="hljs-doctag">NOTE:</span> if `invokers` changed, then `invoked` also lose accuracy.</span><br>        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) &#123;<br>            checkWhetherDestroyed();<br>            <span class="hljs-comment">// 在进行重试前重新列举 Invoker，这样做的好处是，如果某个服务挂了，通过调用 list 可得到最新可用的 Invoker 列表</span><br>            copyInvokers = list(invocation);<br>            <span class="hljs-comment">// check again</span><br>            <span class="hljs-comment">// 对 copyinvokers 进行判空检查</span><br>            checkInvokers(copyInvokers, invocation);<br>        &#125;<br>        <span class="hljs-comment">// 通过负载均衡选择 Invoker</span><br>        Invoker&lt;T&gt; invoker = select(loadbalance, invocation, copyInvokers, invoked);<br>        <span class="hljs-comment">// 添加到 invoker 到 invoked 列表中</span><br>        invoked.add(invoker);<br>        <span class="hljs-comment">// 设置 invoked 到 RPC 上下文中</span><br>        RpcContext.getContext().setInvokers((List) invoked);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 调用目标 Invoker 的 invoke 方法</span><br>            Result result = invoker.invoke(invocation);<br>            <span class="hljs-keyword">if</span> (le != <span class="hljs-keyword">null</span> &amp;&amp; logger.isWarnEnabled()) &#123;<br>                logger.warn(<span class="hljs-string">&quot;Although retry the method &quot;</span> + methodName<br>                        + <span class="hljs-string">&quot; in the service &quot;</span> + getInterface().getName()<br>                        + <span class="hljs-string">&quot; was successful by the provider &quot;</span> + invoker.getUrl().getAddress()<br>                        + <span class="hljs-string">&quot;, but there have been failed providers &quot;</span> + providers<br>                        + <span class="hljs-string">&quot; (&quot;</span> + providers.size() + <span class="hljs-string">&quot;/&quot;</span> + copyInvokers.size()<br>                        + <span class="hljs-string">&quot;) from the registry &quot;</span> + directory.getUrl().getAddress()<br>                        + <span class="hljs-string">&quot; on the consumer &quot;</span> + NetUtils.getLocalHost()<br>                        + <span class="hljs-string">&quot; using the dubbo version &quot;</span> + Version.getVersion() + <span class="hljs-string">&quot;. Last error is: &quot;</span><br>                        + le.getMessage(), le);<br>            &#125;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125; <span class="hljs-keyword">catch</span> (RpcException e) &#123;<br>            <span class="hljs-keyword">if</span> (e.isBiz()) &#123; <span class="hljs-comment">// biz exception.</span><br>                <span class="hljs-keyword">throw</span> e;<br>            &#125;<br>            le = e;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>            le = <span class="hljs-keyword">new</span> RpcException(e.getMessage(), e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            providers.add(invoker.getUrl().getAddress());<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RpcException(le.getCode(), <span class="hljs-string">&quot;Failed to invoke the method &quot;</span><br>            + methodName + <span class="hljs-string">&quot; in the service &quot;</span> + getInterface().getName()<br>            + <span class="hljs-string">&quot;. Tried &quot;</span> + len + <span class="hljs-string">&quot; times of the providers &quot;</span> + providers<br>            + <span class="hljs-string">&quot; (&quot;</span> + providers.size() + <span class="hljs-string">&quot;/&quot;</span> + copyInvokers.size()<br>            + <span class="hljs-string">&quot;) from the registry &quot;</span> + directory.getUrl().getAddress()<br>            + <span class="hljs-string">&quot; on the consumer &quot;</span> + NetUtils.getLocalHost() + <span class="hljs-string">&quot; using the dubbo version &quot;</span><br>            + Version.getVersion() + <span class="hljs-string">&quot;. Last error is: &quot;</span><br>            + le.getMessage(), le.getCause() != <span class="hljs-keyword">null</span> ? le.getCause() : le);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如上，FailoverClusterInvoker 的 doInvoke 方法首先是获取重试次数，然后根据重试次数进行循环调用，失败后进行重试。在 for 循环内，首先是通过负载均衡组件选择一个 Invoker，然后再通过这个Invoker 的 invoke 方法进行远程调用。如果失败了，记录下异常，并进行重试。重试时会再次调用父类的 list 方法列举 Invoker。整个流程大致如此，不是很难理解。下面我们看一下 select 方法的逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Invoker&lt;T&gt; <span class="hljs-title">select</span><span class="hljs-params">(LoadBalance loadbalance, Invocation invocation,</span></span><br><span class="hljs-function"><span class="hljs-params">                            List&lt;Invoker&lt;T&gt;&gt; invokers, List&lt;Invoker&lt;T&gt;&gt; selected)</span> <span class="hljs-keyword">throws</span> RpcException </span>&#123;<br><br>    <span class="hljs-keyword">if</span> (CollectionUtils.isEmpty(invokers)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>    <span class="hljs-comment">// 获取调用方法名</span><br>    String methodName = invocation == <span class="hljs-keyword">null</span> ? StringUtils.EMPTY : invocation.getMethodName();<br>    <span class="hljs-comment">// 获取 sticky 配置，sticky 表示粘滞连接。所谓粘滞连接是指让服务消费者尽可能的调用同一个服务提供者，除非该提供者挂了再进行切换</span><br>    <span class="hljs-keyword">boolean</span> sticky = invokers.get(<span class="hljs-number">0</span>).getUrl()<br>            .getMethodParameter(methodName, CLUSTER_STICKY_KEY, DEFAULT_CLUSTER_STICKY);<br><br>    <span class="hljs-comment">// 检测 invokers 列表是否包含 stickyInvoker，如果不包含，说明 stickyInvoker 代表的服务提供者挂了，此时需要将其置空</span><br>    <span class="hljs-comment">//ignore overloaded method</span><br>    <span class="hljs-keyword">if</span> (stickyInvoker != <span class="hljs-keyword">null</span> &amp;&amp; !invokers.contains(stickyInvoker)) &#123;<br>        stickyInvoker = <span class="hljs-keyword">null</span>;<br>    &#125;<br>    <span class="hljs-comment">// 在 sticky 为 true，且 stickyInvoker != null 的情况下。如果 selected 包含 stickyInvoker，表明 stickyInvoker 对应的服务提供者可能因网络原因未能成功提供服务。但是该提供者并没挂，此时 invokers 列表中仍存在该服务提供者对应的 Invoker。</span><br>    <span class="hljs-comment">//ignore concurrency problem</span><br>    <span class="hljs-keyword">if</span> (sticky &amp;&amp; stickyInvoker != <span class="hljs-keyword">null</span> &amp;&amp; (selected == <span class="hljs-keyword">null</span> || !selected.contains(stickyInvoker))) &#123;<br>        <span class="hljs-comment">// availablecheck 表示是否开启了可用性检查，如果开启了，则调用 stickyInvoker 的 isAvailable 方法进行检查，如果检查通过，则直接返回 stickyInvoker。</span><br>        <span class="hljs-keyword">if</span> (availablecheck &amp;&amp; stickyInvoker.isAvailable()) &#123;<br>            <span class="hljs-keyword">return</span> stickyInvoker;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果线程走到当前代码处，说明前面的 stickyInvoker 为空，或者不可用。此时继续调用 doSelect 选择 Invoker</span><br>    Invoker&lt;T&gt; invoker = doSelect(loadbalance, invocation, invokers, selected);<br><br>    <span class="hljs-comment">// 如果 sticky 为 true，则将负载均衡组件选出的 Invoker 赋值给 stickyInvoker</span><br>    <span class="hljs-keyword">if</span> (sticky) &#123;<br>        stickyInvoker = invoker;<br>    &#125;<br>    <span class="hljs-keyword">return</span> invoker;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如上，select 方法的主要逻辑集中在了对粘滞连接特性的支持上。首先是获取 sticky 配置，然后再检测invokers 列表中是否包含 stickyInvoker，如果不包含，则认为该 stickyInvoker 不可用，此时将其置空。这里的 invokers 列表可以看做是<strong>存活着的服务提供者</strong>列表，如果这个列表不包含 stickyInvoker，那自然而然的认为 stickyInvoker 挂了，所以置空。如果 stickyInvoker 存在于 invokers 列表中，此时要进行下一项检测 — 检测 selected 中是否包含 stickyInvoker。如果包含的话，说明 stickyInvoker 在此之前没有成功提供服务（但其仍然处于存活状态）。此时我们认为这个服务不可靠，不应该在重试期间内再次被调用，因此这个时候不会返回该 stickyInvoker。如果 selected 不包含 stickyInvoker，此时还需要进行可用性检测，比如检测服务提供者网络连通性等。当可用性检测通过，才可返回stickyInvoker，否则调用 doSelect 方法选择 Invoker。如果 sticky 为 true，此时会将 doSelect 方法选出的 Invoker 赋值给 stickyInvoker。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Invoker&lt;T&gt; <span class="hljs-title">doSelect</span><span class="hljs-params">(LoadBalance loadbalance, Invocation invocation,</span></span><br><span class="hljs-function"><span class="hljs-params">                            List&lt;Invoker&lt;T&gt;&gt; invokers, List&lt;Invoker&lt;T&gt;&gt; selected)</span> <span class="hljs-keyword">throws</span> RpcException </span>&#123;<br><br>    <span class="hljs-keyword">if</span> (CollectionUtils.isEmpty(invokers)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (invokers.size() == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> invokers.get(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-comment">// 通过负载均衡组件选择 Invoker</span><br>    Invoker&lt;T&gt; invoker = loadbalance.select(invokers, getUrl(), invocation);<br><br>    <span class="hljs-comment">// 如果 selected 包含负载均衡选择出的 Invoker，或者该 Invoker 无法经过可用性检查，此时进行重选</span><br>    <span class="hljs-comment">//If the `invoker` is in the  `selected` or invoker is unavailable &amp;&amp; availablecheck is true, reselect.</span><br>    <span class="hljs-keyword">if</span> ((selected != <span class="hljs-keyword">null</span> &amp;&amp; selected.contains(invoker))<br>            || (!invoker.isAvailable() &amp;&amp; getUrl() != <span class="hljs-keyword">null</span> &amp;&amp; availablecheck)) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 进行重选</span><br>            Invoker&lt;T&gt; rInvoker = reselect(loadbalance, invocation, invokers, selected, availablecheck);<br>            <span class="hljs-keyword">if</span> (rInvoker != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// 如果 rinvoker 不为空，则将其赋值给 invoker</span><br>                invoker = rInvoker;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// rinvoker 为空，定位 invoker 在 invokers 中的位置</span><br>                <span class="hljs-comment">//Check the index of current selected invoker, if it&#x27;s not the last one, choose the one at index+1.</span><br>                <span class="hljs-keyword">int</span> index = invokers.indexOf(invoker);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 获取 index + 1 位置处的 Invoker</span><br>                    <span class="hljs-comment">//Avoid collision</span><br>                    invoker = invokers.get((index + <span class="hljs-number">1</span>) % invokers.size());<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    logger.warn(e.getMessage() + <span class="hljs-string">&quot; may because invokers list dynamic change, ignore.&quot;</span>, e);<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            logger.error(<span class="hljs-string">&quot;cluster reselect fail reason is :&quot;</span> + t.getMessage() + <span class="hljs-string">&quot; if can not solve, you can set cluster.availablecheck=false in url&quot;</span>, t);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> invoker;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>doSelect 主要做了两件事，第一是通过负载均衡组件选择 Invoker。第二是，如果选出来的 Invoker 不稳定，或不可用，此时需要调用 reselect 方法进行重选。若 reselect 选出来的 Invoker 为空，此时定位invoker 在 invokers 列表中的位置 index，然后获取 index + 1 处的 invoker，这也可以看做是重选逻辑的一部分。下面我们来看一下 reselect 方法的逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Invoker&lt;T&gt; <span class="hljs-title">reselect</span><span class="hljs-params">(LoadBalance loadbalance, Invocation invocation,</span></span><br><span class="hljs-function"><span class="hljs-params">                            List&lt;Invoker&lt;T&gt;&gt; invokers, List&lt;Invoker&lt;T&gt;&gt; selected, <span class="hljs-keyword">boolean</span> availablecheck)</span> <span class="hljs-keyword">throws</span> RpcException </span>&#123;<br><br>    <span class="hljs-comment">//Allocating one in advance, this list is certain to be used.</span><br>    List&lt;Invoker&lt;T&gt;&gt; reselectInvokers = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<br>            invokers.size() &gt; <span class="hljs-number">1</span> ? (invokers.size() - <span class="hljs-number">1</span>) : invokers.size());<br><br>    <span class="hljs-comment">// 遍历 invokers 列表</span><br>    <span class="hljs-comment">// First, try picking a invoker not in `selected`.</span><br>    <span class="hljs-keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) &#123;<br>        <span class="hljs-comment">// 检测可用性</span><br>        <span class="hljs-keyword">if</span> (availablecheck &amp;&amp; !invoker.isAvailable()) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">// 如果 selected 列表不包含当前 invoker，则将其添加到 reselectInvokers 中</span><br>        <span class="hljs-keyword">if</span> (selected == <span class="hljs-keyword">null</span> || !selected.contains(invoker)) &#123;<br>            reselectInvokers.add(invoker);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// reselectInvokers 不为空，此时通过负载均衡组件进行选择</span><br>    <span class="hljs-keyword">if</span> (!reselectInvokers.isEmpty()) &#123;<br>        <span class="hljs-keyword">return</span> loadbalance.select(reselectInvokers, getUrl(), invocation);<br>    &#125;<br>    <span class="hljs-comment">// 若线程走到此处，说明 reselectInvokers 集合为空，此时不会调用负载均衡组件进行筛选。</span><br>    <span class="hljs-comment">// 这里从 selected 列表中查找可用的 Invoker，并将其添加到 reselectInvokers 集合 中</span><br>    <span class="hljs-comment">// Just pick an available invoker using loadbalance policy</span><br>    <span class="hljs-keyword">if</span> (selected != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (Invoker&lt;T&gt; invoker : selected) &#123;<br>            <span class="hljs-keyword">if</span> ((invoker.isAvailable()) <span class="hljs-comment">// available first</span><br>                    &amp;&amp; !reselectInvokers.contains(invoker)) &#123;<br>                reselectInvokers.add(invoker);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 再次进行选择，并返回选择结果</span><br>    <span class="hljs-keyword">if</span> (!reselectInvokers.isEmpty()) &#123;<br>        <span class="hljs-keyword">return</span> loadbalance.select(reselectInvokers, getUrl(), invocation);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>reselect 方法总结下来其实只做了两件事情，第一是查找可用的 Invoker，并将其添加到reselectInvokers 集合中。第二，如果 reselectInvokers 不为空，则通过负载均衡组件再次进行选择。其中第一件事情又可进行细分，一开始，reselect 从 invokers 列表中查找有效可用的 Invoker，若未能找到，此时再到 selected 列表中继续查找。关于 reselect 方法就先分析到这，继续分析其他的 ClusterInvoker。</p>
<h6 id="FailbackClusterInvoker"><a href="#FailbackClusterInvoker" class="headerlink" title="FailbackClusterInvoker"></a>FailbackClusterInvoker</h6><p>FailbackClusterInvoker 会在调用失败后，返回一个空结果给服务消费者。并通过定时任务对失败的调用进行重传，适合执行消息通知等操作。下面来看一下它的实现逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Result <span class="hljs-title">doInvoke</span><span class="hljs-params">(Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class="hljs-keyword">throws</span> RpcException </span>&#123;<br>    Invoker&lt;T&gt; invoker = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        checkInvokers(invokers, invocation);<br>        <span class="hljs-comment">// 选择 Invoker</span><br>        invoker = select(loadbalance, invocation, invokers, <span class="hljs-keyword">null</span>);<br>        <span class="hljs-comment">// 进行调用</span><br>        <span class="hljs-keyword">return</span> invoker.invoke(invocation);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>        <span class="hljs-comment">// 如果调用过程中发生异常，此时仅打印错误日志，不抛出异常</span><br>        logger.error(<span class="hljs-string">&quot;Failback to invoke method &quot;</span> + invocation.getMethodName() + <span class="hljs-string">&quot;, wait for retry in background. Ignored exception: &quot;</span><br>                + e.getMessage() + <span class="hljs-string">&quot;, &quot;</span>, e);<br>        <span class="hljs-comment">// 记录调用信息</span><br>        addFailed(loadbalance, invocation, invokers, invoker);<br>        <span class="hljs-comment">// 返回一个空结果给服务消费者</span><br>        <span class="hljs-keyword">return</span> AsyncRpcResult.newDefaultAsyncResult(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, invocation); <span class="hljs-comment">// ignore</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>doInvoker方法负责初次的远程调用。若远程调用失败，则通过 addFailed 方法创建定时任务，进行重试。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addFailed</span><span class="hljs-params">(LoadBalance loadbalance, Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, Invoker&lt;T&gt; lastInvoker)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (failTimer == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-keyword">if</span> (failTimer == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// 创建定时器</span><br>                failTimer = <span class="hljs-keyword">new</span> HashedWheelTimer(<br>                        <span class="hljs-keyword">new</span> NamedThreadFactory(<span class="hljs-string">&quot;failback-cluster-timer&quot;</span>, <span class="hljs-keyword">true</span>),<br>                        <span class="hljs-number">1</span>,<br>                        TimeUnit.SECONDS, <span class="hljs-number">32</span>, failbackTasks);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 创建定时任务，每隔5秒执行一次</span><br>    RetryTimerTask retryTimerTask = <span class="hljs-keyword">new</span> RetryTimerTask(loadbalance, invocation, invokers, lastInvoker, retries, RETRY_FAILED_PERIOD);<br>    <span class="hljs-keyword">try</span> &#123;<br>        failTimer.newTimeout(retryTimerTask, RETRY_FAILED_PERIOD, TimeUnit.SECONDS);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>        logger.error(<span class="hljs-string">&quot;Failback background works error,invocation-&gt;&quot;</span> + invocation + <span class="hljs-string">&quot;, exception: &quot;</span> + e.getMessage());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>addFailed 首先会创建定时器，然后创建 RetryTimerTask 并交给定时器来执行失败重试的逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(Timeout timeout)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Invoker&lt;T&gt; retryInvoker = select(loadbalance, invocation, invokers, Collections.singletonList(lastInvoker));<br>        lastInvoker = retryInvoker;<br>        <span class="hljs-comment">// 再次进行调用</span><br>        retryInvoker.invoke(invocation);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>        logger.error(<span class="hljs-string">&quot;Failed retry to invoke method &quot;</span> + invocation.getMethodName() + <span class="hljs-string">&quot;, waiting again.&quot;</span>, e);<br>        <span class="hljs-comment">// 判断是否超过最大次数</span><br>        <span class="hljs-keyword">if</span> ((++retryTimes) &gt;= retries) &#123;<br>            logger.error(<span class="hljs-string">&quot;Failed retry times exceed threshold (&quot;</span> + retries + <span class="hljs-string">&quot;), We have to abandon, invocation-&gt;&quot;</span> + invocation);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 重新放入</span><br>            rePut(timeout);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h6 id="FailfastClusterInvoker"><a href="#FailfastClusterInvoker" class="headerlink" title="FailfastClusterInvoker"></a>FailfastClusterInvoker</h6><p>FailfastClusterInvoker 只会进行一次调用，失败后立即抛出异常。适用于幂等操作，比如新增记录。源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">doInvoke</span><span class="hljs-params">(Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class="hljs-keyword">throws</span> RpcException </span>&#123;<br>    checkInvokers(invokers, invocation);<br>    <span class="hljs-comment">// 选择 Invoker</span><br>    Invoker&lt;T&gt; invoker = select(loadbalance, invocation, invokers, <span class="hljs-keyword">null</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 调用 Invoker</span><br>        <span class="hljs-keyword">return</span> invoker.invoke(invocation);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>        <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> RpcException &amp;&amp; ((RpcException) e).isBiz()) &#123; <span class="hljs-comment">// biz exception.</span><br>            <span class="hljs-keyword">throw</span> (RpcException) e;<br>        &#125;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RpcException(e <span class="hljs-keyword">instanceof</span> RpcException ? ((RpcException) e).getCode() : <span class="hljs-number">0</span>,<br>                <span class="hljs-string">&quot;Failfast invoke providers &quot;</span> + invoker.getUrl() + <span class="hljs-string">&quot; &quot;</span> + loadbalance.getClass().getSimpleName()<br>                        + <span class="hljs-string">&quot; select from all providers &quot;</span> + invokers + <span class="hljs-string">&quot; for service &quot;</span> + getInterface().getName()<br>                        + <span class="hljs-string">&quot; method &quot;</span> + invocation.getMethodName() + <span class="hljs-string">&quot; on consumer &quot;</span> + NetUtils.getLocalHost()<br>                        + <span class="hljs-string">&quot; use dubbo version &quot;</span> + Version.getVersion()<br>                        + <span class="hljs-string">&quot;, but no luck to perform the invocation. Last error is: &quot;</span> + e.getMessage(),<br>                e.getCause() != <span class="hljs-keyword">null</span> ? e.getCause() : e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>首先是通过 select 方法选择 Invoker，然后进行远程调用。如果调用失败，则立即抛出异常。</p>
<h6 id="FailsafeClusterInvoker"><a href="#FailsafeClusterInvoker" class="headerlink" title="FailsafeClusterInvoker"></a>FailsafeClusterInvoker</h6><p>FailsafeClusterInvoker 是一种失败安全的 Cluster Invoker。所谓的失败安全是指，当调用过程中出现异常时，FailsafeClusterInvoker 仅会打印异常，而不会抛出异常。适用于写入审计日志等操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">doInvoke</span><span class="hljs-params">(Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class="hljs-keyword">throws</span> RpcException </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        checkInvokers(invokers, invocation);<br>        <span class="hljs-comment">// 选择 Invoker</span><br>        Invoker&lt;T&gt; invoker = select(loadbalance, invocation, invokers, <span class="hljs-keyword">null</span>);<br>        <span class="hljs-comment">// 进行远程调用</span><br>        <span class="hljs-keyword">return</span> invoker.invoke(invocation);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>        logger.error(<span class="hljs-string">&quot;Failsafe ignore exception: &quot;</span> + e.getMessage(), e);<br>        <span class="hljs-comment">// 返回空结果忽略错误</span><br>        <span class="hljs-keyword">return</span> AsyncRpcResult.newDefaultAsyncResult(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, invocation); <span class="hljs-comment">// ignore</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h6 id="ForkingClusterInvoker"><a href="#ForkingClusterInvoker" class="headerlink" title="ForkingClusterInvoker"></a>ForkingClusterInvoker</h6><p>ForkingClusterInvoker 会在运行时通过线程池创建多个线程，并发调用多个服务提供者。只要有一个服务提供者成功返回了结果，doInvoke 方法就会立即结束运行。ForkingClusterInvoker 的应用场景是在一些对实时性要求比较高<strong>读操作</strong>（注意是读操作，并行写操作可能不安全）下使用，但这将会耗费更多的资源。下面来看该类的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">doInvoke</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class="hljs-keyword">throws</span> RpcException </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        checkInvokers(invokers, invocation);<br>        <span class="hljs-keyword">final</span> List&lt;Invoker&lt;T&gt;&gt; selected;<br>        <span class="hljs-comment">// 获取 forks 配置</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> forks = getUrl().getParameter(FORKS_KEY, DEFAULT_FORKS);<br>        <span class="hljs-comment">// 获取超时配置</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> timeout = getUrl().getParameter(TIMEOUT_KEY, DEFAULT_TIMEOUT);<br>        <span class="hljs-comment">// 如果 forks 配置不合理，则直接将 invokers 赋值给 selected</span><br>        <span class="hljs-keyword">if</span> (forks &lt;= <span class="hljs-number">0</span> || forks &gt;= invokers.size()) &#123;<br>            selected = invokers;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            selected = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>            <span class="hljs-comment">// 循环选出 forks 个 Invoker，并添加到 selected 中</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; forks; i++) &#123;<br>                <span class="hljs-comment">// 选择 Invoker</span><br>                Invoker&lt;T&gt; invoker = select(loadbalance, invocation, invokers, selected);<br>                <span class="hljs-keyword">if</span> (!selected.contains(invoker)) &#123;<br>                    <span class="hljs-comment">//Avoid add the same invoker several times.</span><br>                    selected.add(invoker);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        RpcContext.getContext().setInvokers((List) selected);<br>        <span class="hljs-keyword">final</span> AtomicInteger count = <span class="hljs-keyword">new</span> AtomicInteger();<br>        <span class="hljs-keyword">final</span> BlockingQueue&lt;Object&gt; ref = <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;&gt;();<br>        <span class="hljs-comment">// 遍历 selected 列表</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> Invoker&lt;T&gt; invoker : selected) &#123;<br>            <span class="hljs-comment">// 为每个 Invoker 创建一个执行线程</span><br>            executor.execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-comment">// 进行远程调用</span><br>                        Result result = invoker.invoke(invocation);<br>                        <span class="hljs-comment">// 将结果存到阻塞队列中</span><br>                        ref.offer(result);<br>                    &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>                        <span class="hljs-keyword">int</span> value = count.incrementAndGet();<br>                        <span class="hljs-comment">// 仅在 value 大于等于 selected.size() 时，才将异常对象放入阻塞队列中</span><br>                        <span class="hljs-keyword">if</span> (value &gt;= selected.size()) &#123;<br>                            ref.offer(e);<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;);<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 从阻塞队列中取出远程调用结果</span><br>            Object ret = ref.poll(timeout, TimeUnit.MILLISECONDS);<br>            <span class="hljs-comment">// 如果结果类型为 Throwable，则抛出异常</span><br>            <span class="hljs-keyword">if</span> (ret <span class="hljs-keyword">instanceof</span> Throwable) &#123;<br>                Throwable e = (Throwable) ret;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RpcException(e <span class="hljs-keyword">instanceof</span> RpcException ? ((RpcException) e).getCode() : <span class="hljs-number">0</span>, <span class="hljs-string">&quot;Failed to forking invoke provider &quot;</span> + selected + <span class="hljs-string">&quot;, but no luck to perform the invocation. Last error is: &quot;</span> + e.getMessage(), e.getCause() != <span class="hljs-keyword">null</span> ? e.getCause() : e);<br>            &#125;<br>            <span class="hljs-comment">// 返回结果</span><br>            <span class="hljs-keyword">return</span> (Result) ret;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RpcException(<span class="hljs-string">&quot;Failed to forking invoke provider &quot;</span> + selected + <span class="hljs-string">&quot;, but no luck to perform the invocation. Last error is: &quot;</span> + e.getMessage(), e);<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// clear attachments which is binding to current thread.</span><br>        RpcContext.getContext().clearAttachments();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>ForkingClusterInvoker 的 doInvoker 方法比较长，这里将整个方法划分为三个逻辑块。首先选出 forks 个 Invoker，为接下来的并发调用提供输入。然后通过线程池并发调用多个 Invoker，并将结果存储在阻塞队列中。最后从阻塞队列中获取返回结果，并对返回结果类型进行判断。如果为异常类型，则直接抛出，否则返回。</p>
<p>对于  value &gt;= selected.size() 的情况下，才将异常对象添</p>
<p>在并行调用多个服务提供者的情况下，只要有一个服务提供者能够成功返回结果，不管其他是否全部失败，ForkingClusterInvoker 都应该返回成功的结果，而非抛出异常。在 value &gt;= selected.size() 时将异常对象放入阻塞队列中，可以保证异常对象不会出现在正常结果的前面，这样可从阻塞队列中优先取出正常的结果。</p>
<h6 id="BroadcastClusterInvoker"><a href="#BroadcastClusterInvoker" class="headerlink" title="BroadcastClusterInvoker"></a>BroadcastClusterInvoker</h6><p>BroadcastClusterInvoker 会逐个调用每个服务提供者，如果其中一台报错，在循环调用结束后，BroadcastClusterInvoker 会抛出异常。该类通常用于通知所有提供者更新缓存或日志等本地资源信息。源码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">doInvoke</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class="hljs-keyword">throws</span> RpcException </span>&#123;<br>    checkInvokers(invokers, invocation);<br>    RpcContext.getContext().setInvokers((List) invokers);<br>    RpcException exception = <span class="hljs-keyword">null</span>;<br>    Result result = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">// 遍历 Invoker 列表，逐个调用</span><br>    <span class="hljs-keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 进行远程调用</span><br>            result = invoker.invoke(invocation);<br>        &#125; <span class="hljs-keyword">catch</span> (RpcException e) &#123;<br>            exception = e;<br>            logger.warn(e.getMessage(), e);<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>            exception = <span class="hljs-keyword">new</span> RpcException(e.getMessage(), e);<br>            logger.warn(e.getMessage(), e);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// exception 不为空，则抛出异常</span><br>    <span class="hljs-keyword">if</span> (exception != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> exception;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><h5 id="负载均衡的主要作用"><a href="#负载均衡的主要作用" class="headerlink" title="负载均衡的主要作用"></a>负载均衡的主要作用</h5><p><img src="/blog/2021/04/27/Dubbo/dubbo%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/pic12.png" srcset="/blog/img/loading.gif" lazyload></p>
<p>负载均衡（LoadBalance），它的职责是将网络请求，或者其他形式的负载“均摊”到不同的机器上。避免集群中部分服务器压力过大，而另一些服务器比较空闲的情况。通过负载均衡，可以让每台服务器获取到适合自己处理能力的负载。在为高负载服务器分流的同时，还可以避免资源浪费，一举两得。</p>
<p>在 Dubbo 中，也有负载均衡的概念和相应的实现。Dubbo 需要对服务消费者的调用请求进行分配，避免少数服务提供者负载过大。服务提供者负载过大，会导致部分请求超时。因此将负载均衡到每个服务提供者上，是非常必要的。</p>
<h5 id="内置的负载均衡策略"><a href="#内置的负载均衡策略" class="headerlink" title="内置的负载均衡策略"></a>内置的负载均衡策略</h5><p>Dubbo 提供了4种负载均衡实现，分别是基于权重随机算法的 RandomLoadBalance、基于最少活跃调用数算法的 LeastActiveLoadBalance、基于 hash 一致性的 ConsistentHashLoadBalance，以及基于加权轮询算法的 RoundRobinLoadBalance。</p>
<h6 id="RandomLoadBalance"><a href="#RandomLoadBalance" class="headerlink" title="RandomLoadBalance"></a>RandomLoadBalance</h6><p>RandomLoadBalance 是加权随机算法的具体实现，它的算法思想很简单。假设我们有一组服务器servers = [A, B, C]，他们对应的权重为 weights = [5, 3, 2]，权重总和为10。现在把这些权重值平铺在一维坐标值上，[0, 5) 区间属于服务器 A，[5, 8) 区间属于服务器 B，[8, 10) 区间属于服务器 C。接下来通过随机数生成器生成一个范围在 [0, 10) 之间的随机数，然后计算这个随机数会落到哪个区间上。比如数字3会落到服务器 A 对应的区间上，此时返回服务器 A 即可。权重越大的机器，在坐标轴上对应的区间范围就越大，因此随机数生成器生成的数字就会有更大的概率落到此区间内。只要随机数生成器产生的随机数分布性很好，在经过多次选择后，每个服务器被选中的次数比例接近其权重比例。</p>
<p>源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> &lt;T&gt; <span class="hljs-function">Invoker&lt;T&gt; <span class="hljs-title">doSelect</span><span class="hljs-params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;<br>    <span class="hljs-comment">// Number of invokers</span><br>    <span class="hljs-keyword">int</span> length = invokers.size();<br>    <span class="hljs-comment">// Every invoker has the same weight?</span><br>    <span class="hljs-keyword">boolean</span> sameWeight = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-comment">// the weight of every invokers</span><br>    <span class="hljs-keyword">int</span>[] weights = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[length];<br>    <span class="hljs-comment">// the first invoker&#x27;s weight</span><br>    <span class="hljs-keyword">int</span> firstWeight = getWeight(invokers.get(<span class="hljs-number">0</span>), invocation);<br>    weights[<span class="hljs-number">0</span>] = firstWeight;<br>    <span class="hljs-comment">// The sum of weights</span><br>    <span class="hljs-keyword">int</span> totalWeight = firstWeight;<br>    <span class="hljs-comment">// 下面这个循环有两个作用，第一是计算总权重 totalWeight，</span><br>    <span class="hljs-comment">// 第二是检测每个服务提供者的权重是否相同</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; length; i++) &#123;<br>        <span class="hljs-keyword">int</span> weight = getWeight(invokers.get(i), invocation);<br>        <span class="hljs-comment">// save for later use</span><br>        weights[i] = weight;<br>        <span class="hljs-comment">// Sum</span><br>        <span class="hljs-comment">// 累加权重</span><br>        totalWeight += weight;<br>        <span class="hljs-comment">// 检测当前服务提供者的权重与上一个服务提供者的权重是否相同，</span><br>        <span class="hljs-comment">// 不相同的话，则将 sameWeight 置为 false</span><br>        <span class="hljs-keyword">if</span> (sameWeight &amp;&amp; weight != firstWeight) &#123;<br>            sameWeight = <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 下面的 if 分支主要用于获取随机数，并计算随机数落在哪个区间上</span><br>    <span class="hljs-keyword">if</span> (totalWeight &gt; <span class="hljs-number">0</span> &amp;&amp; !sameWeight) &#123;<br>        <span class="hljs-comment">// If (not every invoker has the same weight &amp; at least one invoker&#x27;s weight&gt;0), select randomly based on totalWeight.</span><br>        <span class="hljs-comment">// 随机获取一个 [0, totalWeight) 区间内的数字</span><br>        <span class="hljs-keyword">int</span> offset = ThreadLocalRandom.current().nextInt(totalWeight);<br><br>        <span class="hljs-comment">// Return a invoker based on the random value.</span><br>        <span class="hljs-comment">// 循环让 offset 数减去服务提供者权重值，当 offset 小于0时，返回相应的 Invoker。</span><br>        <span class="hljs-comment">// 举例说明一下，我们有 servers = [A, B, C]，weights = [5, 3, 2]，offset = 7。</span><br>        <span class="hljs-comment">// 第一次循环，offset - 5 = 2 &gt; 0，即 offset &gt; 5，</span><br>        <span class="hljs-comment">// 表明其不会落在服务器 A 对应的区间上。</span><br>        <span class="hljs-comment">// 第二次循环，offset - 3 = -1 &lt; 0，即 5 &lt; offset &lt; 8，</span><br>        <span class="hljs-comment">// 表明其会落在服务器 B 对应的区间上</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-comment">// 让随机值 offset 减去权重值</span><br>            offset -= weights[i];<br>            <span class="hljs-keyword">if</span> (offset &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 返回相应的 Invoker</span><br>                <span class="hljs-keyword">return</span> invokers.get(i);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 如果所有服务提供者权重值相同，此时直接随机返回一个即可</span><br>    <span class="hljs-comment">// If all invokers have the same weight value or totalWeight=0, return evenly.</span><br>    <span class="hljs-keyword">return</span> invokers.get(ThreadLocalRandom.current().nextInt(length));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>RandomLoadBalance 的算法思想比较简单，在经过多次请求后，能够将调用请求按照权重值进行“均 匀”分配。当然 RandomLoadBalance 也存在一定的缺点，当调用次数比较少时，Random 产生的随机数可能会比较集中，此时多数请求会落到同一台服务器上。这个缺点并不是很严重，多数情况下可以忽略。RandomLoadBalance 是一个简单，高效的负载均衡实现，因此 Dubbo 选择它作为缺省实现。</p>
<h6 id="LeastActiveLoadBalance"><a href="#LeastActiveLoadBalance" class="headerlink" title="LeastActiveLoadBalance"></a>LeastActiveLoadBalance</h6><p>LeastActiveLoadBalance 翻译过来是最小活跃数负载均衡。活跃调用数越小，表明该服务提供者效率越高，单位时间内可处理更多的请求。此时应优先将请求分配给该服务提供者。在具体实现中，每个服务提供者对应一个活跃数 active。初始情况下，所有服务提供者活跃数均为0。每收到一个请求，活跃数加1，完成请求后则将活跃数减1。在服务运行一段时间后，性能好的服务提供者处理请求的速度更快，因此活跃数下降的也越快，此时这样的服务提供者能够优先获取到新的服务请求、这就是最小活跃数负载均衡算法的基本思想。源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> &lt;T&gt; <span class="hljs-function">Invoker&lt;T&gt; <span class="hljs-title">doSelect</span><span class="hljs-params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;<br>    <span class="hljs-comment">// Number of invokers</span><br>    <span class="hljs-keyword">int</span> length = invokers.size();<br>    <span class="hljs-comment">// The least active value of all invokers</span><br>    <span class="hljs-comment">// 最小的活跃数</span><br>    <span class="hljs-keyword">int</span> leastActive = -<span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// The number of invokers having the same least active value (leastActive)</span><br>    <span class="hljs-comment">// 具有相同“最小活跃数”的服务者提供者（以下用 Invoker 代称）数量</span><br>    <span class="hljs-keyword">int</span> leastCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// The index of invokers having the same least active value (leastActive)</span><br>    <span class="hljs-comment">// leastIndexs 用于记录具有相同“最小活跃数”的 Invoker 在 invokers 列表中的下标信息</span><br>    <span class="hljs-keyword">int</span>[] leastIndexes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[length];<br>    <span class="hljs-comment">// the weight of every invokers</span><br>    <span class="hljs-comment">// 记录每个Invoker的权重</span><br>    <span class="hljs-keyword">int</span>[] weights = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[length];<br>    <span class="hljs-comment">// The sum of the warmup weights of all the least active invokes</span><br>    <span class="hljs-keyword">int</span> totalWeight = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// The weight of the first least active invoke</span><br>    <span class="hljs-comment">// 第一个最小活跃数的 Invoker 权重值，用于与其他具有相同最小活跃数的 Invoker 的权 重进行对比，以检测是否“所有具有相同最小活跃数的 Invoker 的权重”均相等</span><br>    <span class="hljs-keyword">int</span> firstWeight = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// Every least active invoker has the same weight value?</span><br>    <span class="hljs-keyword">boolean</span> sameWeight = <span class="hljs-keyword">true</span>;<br><br><br>    <span class="hljs-comment">// Filter out all the least active invokers</span><br>    <span class="hljs-comment">// 遍历 invokers 列表</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>        Invoker&lt;T&gt; invoker = invokers.get(i);<br>        <span class="hljs-comment">// Get the active number of the invoke</span><br>        <span class="hljs-comment">// 获取 Invoker 对应的活跃数</span><br>        <span class="hljs-keyword">int</span> active = RpcStatus.getStatus(invoker.getUrl(), invocation.getMethodName()).getActive();<br>        <span class="hljs-comment">// Get the weight of the invoke configuration. The default value is 100.</span><br>        <span class="hljs-keyword">int</span> afterWarmup = getWeight(invoker, invocation);<br>        <span class="hljs-comment">// save for later use</span><br>        <span class="hljs-comment">// 获取权重</span><br>        weights[i] = afterWarmup;<br>        <span class="hljs-comment">// If it is the first invoker or the active number of the invoker is less than the current least active number</span><br>        <span class="hljs-comment">// 发现更小的活跃数</span><br>        <span class="hljs-keyword">if</span> (leastActive == -<span class="hljs-number">1</span> || active &lt; leastActive) &#123;<br>            <span class="hljs-comment">// Reset the active number of the current invoker to the least active number</span><br>            <span class="hljs-comment">// 使用当前活跃数 active 更新最小活跃数 leastActive</span><br>            leastActive = active;<br>            <span class="hljs-comment">// Reset the number of least active invokers</span><br>            <span class="hljs-comment">// 更新 leastCount 为 1</span><br>            leastCount = <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// Put the first least active invoker first in leastIndexes</span><br>            <span class="hljs-comment">// 记录当前下标值到 leastIndexs 中</span><br>            leastIndexes[<span class="hljs-number">0</span>] = i;<br>            <span class="hljs-comment">// Reset totalWeight</span><br>            totalWeight = afterWarmup;<br>            <span class="hljs-comment">// Record the weight the first least active invoker</span><br>            firstWeight = afterWarmup;<br>            <span class="hljs-comment">// Each invoke has the same weight (only one invoker here)</span><br>            sameWeight = <span class="hljs-keyword">true</span>;<br>            <span class="hljs-comment">// If current invoker&#x27;s active value equals with leaseActive, then accumulating.</span><br>            <span class="hljs-comment">// 当前 Invoker 的活跃数 active 与最小活跃数 leastActive 相同</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (active == leastActive) &#123;<br>            <span class="hljs-comment">// Record the index of the least active invoker in leastIndexes order</span><br>            <span class="hljs-comment">// 在 leastIndexs 中记录下当前 Invoker 在 invokers 集合中的下标</span><br>            leastIndexes[leastCount++] = i;<br>            <span class="hljs-comment">// Accumulate the total weight of the least active invoker</span><br>            <span class="hljs-comment">// 累加权重</span><br>            totalWeight += afterWarmup;<br>            <span class="hljs-comment">// If every invoker has the same weight?</span><br>            <span class="hljs-comment">// 检测当前 Invoker 的权重与 firstWeight 是否相等，不相等则将 sameWeight 置为 false</span><br>            <span class="hljs-keyword">if</span> (sameWeight &amp;&amp; i &gt; <span class="hljs-number">0</span><br>                    &amp;&amp; afterWarmup != firstWeight) &#123;<br>                sameWeight = <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// Choose an invoker from all the least active invokers</span><br>    <span class="hljs-comment">// 当只有一个 Invoker 具有最小活跃数，此时直接返回该 Invoker 即可</span><br>    <span class="hljs-keyword">if</span> (leastCount == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// If we got exactly one invoker having the least active value, return this invoker directly.</span><br>        <span class="hljs-keyword">return</span> invokers.get(leastIndexes[<span class="hljs-number">0</span>]);<br>    &#125;<br>    <span class="hljs-comment">// 有多个 Invoker 具有相同的最小活跃数，但它们之间的权重不同</span><br>    <span class="hljs-keyword">if</span> (!sameWeight &amp;&amp; totalWeight &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// If (not every invoker has the same weight &amp; at least one invoker&#x27;s weight&gt;0), select randomly based on</span><br>        <span class="hljs-comment">// totalWeight.</span><br>        <span class="hljs-comment">// 随机生成一个 [0, totalWeight) 之间的数字</span><br>        <span class="hljs-keyword">int</span> offsetWeight = ThreadLocalRandom.current().nextInt(totalWeight);<br>        <span class="hljs-comment">// Return a invoker based on the random value.</span><br>        <span class="hljs-comment">// 循环让随机数减去具有最小活跃数的 Invoker 的权重值，当 offset 小于等于0时，返回相应的 Invoker</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; leastCount; i++) &#123;<br>            <span class="hljs-keyword">int</span> leastIndex = leastIndexes[i];<br>            <span class="hljs-comment">//获取权重值，并让随机数减去权重值</span><br>            offsetWeight -= weights[leastIndex];<br>            <span class="hljs-keyword">if</span> (offsetWeight &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> invokers.get(leastIndex);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// If all invokers have the same weight value or totalWeight=0, return evenly.</span><br>    <span class="hljs-comment">// 如果权重相同或权重为0时，随机返回一个 Invoker</span><br>    <span class="hljs-keyword">return</span> invokers.get(leastIndexes[ThreadLocalRandom.current().nextInt(leastCount)]);<br>&#125;<br></code></pre></td></tr></table></figure>

<h6 id="ConsistentHashLoadBalance"><a href="#ConsistentHashLoadBalance" class="headerlink" title="ConsistentHashLoadBalance"></a>ConsistentHashLoadBalance</h6><p>一致性 hash 算法由麻省理工学院的 Karger 及其合作者于1997年提出的，算法提出之初是用于大规模缓存系统的负载均衡。它的工作过程是这样的，首先根据 ip 或者其他的信息为缓存节点生成一个hash，并将这个 hash 投射到 [0, 2^32-1] 的圆环上。当有查询或写入请求时，则为缓存项的 key 生成一个 hash 值。然后查找第一个大于或等于该 hash 值的缓存节点，并到这个节点中查询或写入缓存项。如果当前节点挂了，则在下一次查询或写入缓存时，为缓存项查找另一个大于其 hash 值的缓存节点即可。大致效果如下图所示，每个缓存节点在圆环上占据一个位置。如果缓存项的 key 的 hash 值小于缓存节点 hash 值，则到该缓存节点中存储或读取缓存项。比如下面绿色点对应的缓存项将会被存储到 cache-2 节点中。由于 cache-3 挂了，原本应该存到该节点中的缓存项最终会存储到 cache-4 节点中。</p>
<p><img src="/blog/2021/04/27/Dubbo/dubbo%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/pic13.png" srcset="/blog/img/loading.gif" lazyload></p>
<p>下面来看看一致性 hash 在 Dubbo 中的应用。我们把上图的缓存节点替换成 Dubbo 的服务提供者，于是得到了下图：</p>
<p><img src="/blog/2021/04/27/Dubbo/dubbo%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/pic14.png" srcset="/blog/img/loading.gif" lazyload></p>
<p>这里相同颜色的节点均属于同一个服务提供者，比如 Invoker1-1，Invoker1-2，……, Invoker1-160。这样做的目的是通过引入虚拟节点，让 Invoker 在圆环上分散开来，避免数据倾斜问题。所谓数据倾斜是指，由于节点不够分散，导致大量请求落到了同一个节点上，而其他节点只会接收到了少量请求的情况。比如：</p>
<p><img src="/blog/2021/04/27/Dubbo/dubbo%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/pic15.png" srcset="/blog/img/loading.gif" lazyload></p>
<p>如上，由于 Invoker-1 和 Invoker-2 在圆环上分布不均，导致系统中75%的请求都会落到 Invoker-1上，只有 25% 的请求会落到 Invoker-2 上。解决这个问题办法是引入虚拟节点，通过虚拟节点均衡各个节点的请求量。</p>
<p>到这里背景知识就普及完了，接下来开始分析源码。我们先从 ConsistentHashLoadBalance 的 doSelect 方法开始看起，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> &lt;T&gt; <span class="hljs-function">Invoker&lt;T&gt; <span class="hljs-title">doSelect</span><span class="hljs-params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;<br>    String methodName = RpcUtils.getMethodName(invocation);<br>    String key = invokers.get(<span class="hljs-number">0</span>).getUrl().getServiceKey() + <span class="hljs-string">&quot;.&quot;</span> + methodName;<br><br>    <span class="hljs-comment">// 获取 invokers 原始的 hashcode</span><br>    <span class="hljs-keyword">int</span> identityHashCode = System.identityHashCode(invokers);<br>    ConsistentHashSelector&lt;T&gt; selector = (ConsistentHashSelector&lt;T&gt;) selectors.get(key);<br>    <span class="hljs-comment">// 如果 invokers 是一个新的 List 对象，意味着服务提供者数量发生了变化，可能新增也可能减少了。</span><br>    <span class="hljs-comment">// 此时 selector.identityHashCode != identityHashCode 条件成立</span><br>    <span class="hljs-keyword">if</span> (selector == <span class="hljs-keyword">null</span> || selector.identityHashCode != identityHashCode) &#123;<br>        <span class="hljs-comment">// 创建新的 ConsistentHashSelector</span><br>        selectors.put(key, <span class="hljs-keyword">new</span> ConsistentHashSelector&lt;T&gt;(invokers, methodName, identityHashCode));<br>        selector = (ConsistentHashSelector&lt;T&gt;) selectors.get(key);<br>    &#125;<br>    <span class="hljs-comment">// 调用 ConsistentHashSelector 的 select 方法选择 Invoker</span><br>    <span class="hljs-keyword">return</span> selector.select(invocation);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如上，doSelect 方法主要做了一些前置工作，比如检测 invokers 列表是不是变动过，以及创建ConsistentHashSelector。这些工作做完后，接下来开始调用 ConsistentHashSelector 的 select 方法执行负载均衡逻辑。在分析 select 方法之前，我们先来看一下一致性 hash 选择器ConsistentHashSelector 的初始化过程，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java">ConsistentHashSelector(List&lt;Invoker&lt;T&gt;&gt; invokers, String methodName, <span class="hljs-keyword">int</span> identityHashCode) &#123;<br>    <span class="hljs-keyword">this</span>.virtualInvokers = <span class="hljs-keyword">new</span> TreeMap&lt;Long, Invoker&lt;T&gt;&gt;();<br>    <span class="hljs-keyword">this</span>.identityHashCode = identityHashCode;<br>    URL url = invokers.get(<span class="hljs-number">0</span>).getUrl();<br>    <span class="hljs-comment">// 获取虚拟节点数，默认为160</span><br>    <span class="hljs-keyword">this</span>.replicaNumber = url.getMethodParameter(methodName, HASH_NODES, <span class="hljs-number">160</span>);<br>    <span class="hljs-comment">// 获取参与 hash 计算的参数下标值，默认对第一个参数进行 hash 运算</span><br>    String[] index = COMMA_SPLIT_PATTERN.split(url.getMethodParameter(methodName, HASH_ARGUMENTS, <span class="hljs-string">&quot;0&quot;</span>));<br>    argumentIndex = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[index.length];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; index.length; i++) &#123;<br>        argumentIndex[i] = Integer.parseInt(index[i]);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) &#123;<br>        String address = invoker.getUrl().getAddress();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; replicaNumber / <span class="hljs-number">4</span>; i++) &#123;<br>            <span class="hljs-comment">// 对 address + i 进行 md5 运算，得到一个长度为16的字节数组</span><br>            <span class="hljs-keyword">byte</span>[] digest = md5(address + i);<br>            <span class="hljs-comment">// 对 digest 部分字节进行4次 hash 运算，得到四个不同的 long 型正整数</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> h = <span class="hljs-number">0</span>; h &lt; <span class="hljs-number">4</span>; h++) &#123;<br>                <span class="hljs-comment">// h = 0 时，取 digest 中下标为 0 ~ 3 的4个字节进行位运算</span><br>                <span class="hljs-comment">// h = 1 时，取 digest 中下标为 4 ~ 7 的4个字节进行位运算</span><br>                <span class="hljs-comment">// h = 2, h = 3 时过程同上</span><br>                <span class="hljs-keyword">long</span> m = hash(digest, h);<br>                <span class="hljs-comment">// 将 hash 到 invoker 的映射关系存储到 virtualInvokers 中， </span><br>                <span class="hljs-comment">// virtualInvokers 需要提供高效的查询操作，因此选用 TreeMap 作为存 储结构</span><br>                virtualInvokers.put(m, invoker);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>ConsistentHashSelector 的构造方法执行了一系列的初始化逻辑，比如从配置中获取虚拟节点数以及参与 hash 计算的参数下标，默认情况下只使用第一个参数进行 hash。需要特别说明的是，ConsistentHashLoadBalance 的负载均衡逻辑只受参数值影响，具有相同参数值的请求将会被分配给同一个服务提供者。ConsistentHashLoadBalance 不关系权重，因此使用时需要注意一下。</p>
<p>在获取虚拟节点数和参数下标配置后，接下来要做的事情是计算虚拟节点 hash 值，并将虚拟节点存储到 TreeMap 中。到此，ConsistentHashSelector 初始化工作就完成了。 select 方法的逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Invoker&lt;T&gt; <span class="hljs-title">select</span><span class="hljs-params">(Invocation invocation)</span> </span>&#123;<br>    <span class="hljs-comment">// 将参数转为 key</span><br>    String key = toKey(invocation.getArguments());<br>    <span class="hljs-comment">// 对参数 key 进行 md5 运算</span><br>    <span class="hljs-keyword">byte</span>[] digest = md5(key);<br>    <span class="hljs-comment">// 取 digest 数组的前四个字节进行 hash 运算，再将 hash 值传给 selectForKey 方法，寻找合适的 Invoker</span><br>    <span class="hljs-keyword">return</span> selectForKey(hash(digest, <span class="hljs-number">0</span>));<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Invoker&lt;T&gt; <span class="hljs-title">selectForKey</span><span class="hljs-params">(<span class="hljs-keyword">long</span> hash)</span> </span>&#123;<br>    <span class="hljs-comment">// 到 TreeMap 中查找第一个节点值大于或等于当前 hash 的 Invoker</span><br>    Map.Entry&lt;Long, Invoker&lt;T&gt;&gt; entry = virtualInvokers.ceilingEntry(hash);<br>    <span class="hljs-comment">// 如果 hash 大于 Invoker 在圆环上最大的位置，此时 entry = null，需要将 TreeMap 的头节点赋值给 entry</span><br>    <span class="hljs-keyword">if</span> (entry == <span class="hljs-keyword">null</span>) &#123;<br>        entry = virtualInvokers.firstEntry();<br>    &#125;<br>    <span class="hljs-comment">// 返回 Invoker</span><br>    <span class="hljs-keyword">return</span> entry.getValue();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如上，选择的过程相对比较简单了。首先是对参数进行 md5 以及 hash 运算，得到一个 hash 值。然后再拿这个值到 TreeMap 中查找目标 Invoker 即可。</p>
<h6 id="RoundRobinLoadBalance"><a href="#RoundRobinLoadBalance" class="headerlink" title="RoundRobinLoadBalance"></a>RoundRobinLoadBalance</h6><p>LeastActiveLoadBalance 即加权轮询负载均衡，轮询是指将请求轮流分配给每台服务器，是一种无状态负载均衡算法，实现简单，适用于每台服务器性能相近的场景下。但现实情况下，并不能保证每台服务器性能均相近。如果将等量的请求分配给性能较差的服务器，这显然是不合理的。因此，这个时候需要对轮询过程进行加权，以调控每台服务器的负载。经过加权后，每台服务器能够得到的请求数比例，接近或等于他们的权重比。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> &lt;T&gt; <span class="hljs-function">Invoker&lt;T&gt; <span class="hljs-title">doSelect</span><span class="hljs-params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;<br>    String key = invokers.get(<span class="hljs-number">0</span>).getUrl().getServiceKey() + <span class="hljs-string">&quot;.&quot;</span> + invocation.getMethodName();<br>    <span class="hljs-comment">// 获取 url 到 WeightedRoundRobin 映射表，如果为空，则创建一个新的</span><br>    ConcurrentMap&lt;String, WeightedRoundRobin&gt; map = methodWeightMap.get(key);<br>    <span class="hljs-keyword">if</span> (map == <span class="hljs-keyword">null</span>) &#123;<br>        methodWeightMap.putIfAbsent(key, <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;String, WeightedRoundRobin&gt;());<br>        map = methodWeightMap.get(key);<br>    &#125;<br>    <span class="hljs-keyword">int</span> totalWeight = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">long</span> maxCurrent = Long.MIN_VALUE;<br><br>    <span class="hljs-comment">// 获取当前时间</span><br>    <span class="hljs-keyword">long</span> now = System.currentTimeMillis();<br>    Invoker&lt;T&gt; selectedInvoker = <span class="hljs-keyword">null</span>;<br>    WeightedRoundRobin selectedWRR = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-comment">// 下面这个循环主要做了这样几件事情：</span><br>    <span class="hljs-comment">// 1. 遍历 Invoker 列表，检测当前 Invoker 是否有相应的 WeightedRoundRobin，没有则创建</span><br>    <span class="hljs-comment">// 2. 检测 Invoker 权重是否发生了变化，若变化了，则更新 WeightedRoundRobin 的 weight 字段</span><br>    <span class="hljs-comment">// 3. 让 current 字段加上自身权重，等价于 current += weight</span><br>    <span class="hljs-comment">// 4. 设置 lastUpdate 字段，即 lastUpdate = now</span><br>    <span class="hljs-comment">// 5. 寻找具有最大 current 的 Invoker，以及 Invoker 对应的 WeightedRoundRobin，暂存起来，留作后用</span><br>    <span class="hljs-comment">// 6. 计算权重总和</span><br>    <span class="hljs-keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) &#123;<br>        String identifyString = invoker.getUrl().toIdentityString();<br>        WeightedRoundRobin weightedRoundRobin = map.get(identifyString);<br>        <span class="hljs-keyword">int</span> weight = getWeight(invoker, invocation);<br><br>        <span class="hljs-comment">// 检测当前 Invoker 是否有对应的 WeightedRoundRobin，没有则创建</span><br>        <span class="hljs-keyword">if</span> (weightedRoundRobin == <span class="hljs-keyword">null</span>) &#123;<br>            weightedRoundRobin = <span class="hljs-keyword">new</span> WeightedRoundRobin();<br>            <span class="hljs-comment">// 设置 Invoker 权重</span><br>            weightedRoundRobin.setWeight(weight);<br>            <span class="hljs-comment">// 存储 url 唯一标识 identifyString 到 weightedRoundRobin 的映射关系</span><br>            map.putIfAbsent(identifyString, weightedRoundRobin);<br>        &#125;<br><br>        <span class="hljs-comment">// Invoker 权重不等于 WeightedRoundRobin 中保存的权重，说明权重变化了，此时进行更新</span><br>        <span class="hljs-keyword">if</span> (weight != weightedRoundRobin.getWeight()) &#123;<br>            <span class="hljs-comment">//weight changed</span><br>            weightedRoundRobin.setWeight(weight);<br>        &#125;<br>        <span class="hljs-comment">// 让 current 加上自身权重，等价于 current += weight</span><br>        <span class="hljs-keyword">long</span> cur = weightedRoundRobin.increaseCurrent();<br>        <span class="hljs-comment">// 设置 lastUpdate，表示近期更新过</span><br>        weightedRoundRobin.setLastUpdate(now);<br>        <span class="hljs-comment">// 找出最大的 current</span><br>        <span class="hljs-keyword">if</span> (cur &gt; maxCurrent) &#123;<br>            maxCurrent = cur;<br>            <span class="hljs-comment">// 将具有最大 current 权重的 Invoker 赋值给 selectedInvoker</span><br>            selectedInvoker = invoker;<br>            <span class="hljs-comment">// 将 Invoker 对应的 weightedRoundRobin 赋值给 selectedWRR，留作后用</span><br>            selectedWRR = weightedRoundRobin;<br>        &#125;<br>        <span class="hljs-comment">// 计算权重总和</span><br>        totalWeight += weight;<br>    &#125;<br>    <span class="hljs-comment">// 对 &lt;identifyString, WeightedRoundRobin&gt; 进行检查，过滤掉长时间未被更新的节点。</span><br>    <span class="hljs-comment">// 该节点可能挂了，invokers 中不包含该节点，所以该节点的 lastUpdate 长时间无法被更新。</span><br>    <span class="hljs-comment">// 若未更新时长超过阈值后，就会被移除掉，默认阈值为60秒。</span><br>    <span class="hljs-keyword">if</span> (!updateLock.get() &amp;&amp; invokers.size() != map.size()) &#123;<br>        <span class="hljs-keyword">if</span> (updateLock.compareAndSet(<span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>)) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// copy -&gt; modify -&gt; update reference</span><br>                ConcurrentMap&lt;String, WeightedRoundRobin&gt; newMap = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;String, WeightedRoundRobin&gt;();<br>                <span class="hljs-comment">// 拷贝</span><br>                newMap.putAll(map);<br>                <span class="hljs-comment">// 遍历修改，即移除过期记录</span><br>                Iterator&lt;Entry&lt;String, WeightedRoundRobin&gt;&gt; it = newMap.entrySet().iterator();<br>                <span class="hljs-keyword">while</span> (it.hasNext()) &#123;<br>                    Entry&lt;String, WeightedRoundRobin&gt; item = it.next();<br>                    <span class="hljs-keyword">if</span> (now - item.getValue().getLastUpdate() &gt; RECYCLE_PERIOD) &#123;<br>                        it.remove();<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">// 更新引用</span><br>                methodWeightMap.put(key, newMap);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                updateLock.set(<span class="hljs-keyword">false</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (selectedInvoker != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 让 current 减去权重总和，等价于 current -= totalWeight</span><br>        selectedWRR.sel(totalWeight);<br>        <span class="hljs-comment">// 返回具有最大 current 的 Invoker</span><br>        <span class="hljs-keyword">return</span> selectedInvoker;<br>    &#125;<br>    <span class="hljs-comment">// should not happen here</span><br>    <span class="hljs-keyword">return</span> invokers.get(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>轮询调用并不是简单的一个接着一个依次调用，它是根据权重的值进行循环的。</p>
<h5 id="负载均衡总结"><a href="#负载均衡总结" class="headerlink" title="负载均衡总结"></a>负载均衡总结</h5><p>Dubbo 负载均衡策略提供下列四种方式：</p>
<ul>
<li><p><strong>Random LoadBalance 随机</strong>，按权重设置随机概率。 <strong>Dubbo的默认负载均衡策略</strong>，在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。</p>
</li>
<li><p><strong>RoundRobin LoadBalance</strong> <strong>轮循</strong>，按公约后的权重设置轮循比率。存在慢的提供者累积请求问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</p>
</li>
<li><p><strong>LeastActive LoadBalance</strong> <strong>最少活跃调用数</strong>，相同活跃数的随机，活跃数指调用前后计数差。使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。</p>
</li>
<li><p><strong>ConsistentHash LoadBalance 一致性Hash</strong>，相同参数的请求总是发到同一提供者。当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。</p>
</li>
</ul>
<h4 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a>服务治理</h4><h5 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h5><p>服务治理主要作用是改变运行时服务的行为和选址逻辑，达到限流，权重配置等目的，主要有：标签路由，条件路由，黑白名单，动态配置，权重调节，负载均衡等功能。</p>
<p><img src="/blog/2021/04/27/Dubbo/dubbo%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/pic16.png" srcset="/blog/img/loading.gif" lazyload></p>
<h5 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h5><p><img src="/blog/2021/04/27/Dubbo/dubbo%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/pic17.png" srcset="/blog/img/loading.gif" lazyload></p>
<ol>
<li><p>消费者，提供者启动成功，订阅zookeeper节点</p>
</li>
<li><p>管理平台对服务进行治理处理，向zookeeper写入节点数据</p>
</li>
<li><p>写入成功，通知消费者，提供者</p>
</li>
<li><p>根据不同的业务处理，在invoker调用时做出响应的处理</p>
</li>
</ol>
<h5 id="相关案例"><a href="#相关案例" class="headerlink" title="相关案例"></a>相关案例</h5><h6 id="服务禁用"><a href="#服务禁用" class="headerlink" title="服务禁用"></a>服务禁用</h6><p>通常用于临时踢除某台提供者机器</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">configVersion:</span> <span class="hljs-string">v2.7</span> <br><span class="hljs-attr">scope:</span> <span class="hljs-string">application</span> <br><span class="hljs-attr">key:</span> <span class="hljs-string">demo-provider</span> <br><span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <br><span class="hljs-attr">configs:</span> <br>	<span class="hljs-attr">addresses:</span> [<span class="hljs-string">&quot;192.168.191.2:20883&quot;</span>] <br>	<span class="hljs-attr">side:</span> <span class="hljs-string">provider</span> <br>	<span class="hljs-attr">parameters:</span> <br>		<span class="hljs-attr">disabled:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>

<h6 id="服务降级屏蔽"><a href="#服务降级屏蔽" class="headerlink" title="服务降级屏蔽"></a>服务降级屏蔽</h6><p>服务降级，当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级，以此释放服务器资源以保证核心任务的正常运行。</p>
<p>容错：当系统出现非业务异常(比如并发数太高导致超时，网络异常等)时，不对该接口进行处理。</p>
<p>屏蔽：在大促，促销活动的可预知情况下，例如双11活动。采用直接屏蔽接口访问</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">configVersion:</span> <span class="hljs-string">v2.7</span> <br><span class="hljs-attr">scope:</span> <span class="hljs-string">service</span> <br><span class="hljs-attr">key:</span> <span class="hljs-string">org.apache.dubbo.samples.governance.api.DemoService</span> <br><span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <br><span class="hljs-attr">configs:</span> <br>	<span class="hljs-attr">side:</span> <span class="hljs-string">consumer</span> <br>	<span class="hljs-attr">parameters:</span> <br>		<span class="hljs-attr">force:</span> <span class="hljs-string">return</span> <span class="hljs-number">12345</span><br></code></pre></td></tr></table></figure>

<h3 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h3><p>网络通信位于Remoting模块：</p>
<ul>
<li><p>Remoting 实现是 Dubbo 协议的实现，如果选择 RMI 协议，整个 Remoting 都不会用上；</p>
</li>
<li><p>Remoting 内部再划为 Transport 传输层 和 Exchange 信息交换层 ； </p>
</li>
<li><p>Transport 层只负责单向消息传输，是对 Mina, Netty, Grizzly 的抽象，它也可以扩展 UDP 传输；</p>
</li>
<li><p>Exchange 层是在传输层之上封装了 Request-Response 语义；</p>
</li>
</ul>
<p><img src="/blog/2021/04/27/Dubbo/dubbo%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/pic18.png" srcset="/blog/img/loading.gif" lazyload></p>
<p><strong>网络通信的问题：</strong></p>
<ul>
<li><p>客户端与服务端连通性问题</p>
</li>
<li><p>粘包拆包问题</p>
</li>
<li><p>异步多线程数据一致问题</p>
</li>
</ul>
<h4 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h4><p>dubbo内置，dubbo协议 ，rmi协议，hessian协议，http协议，webservice协议，thrift协议，rest协议，grpc协议，memcached协议，redis协议等10种通讯协议。各个协议特点如下</p>
<h5 id="dubbo协议"><a href="#dubbo协议" class="headerlink" title="dubbo协议"></a>dubbo协议</h5><p>Dubbo 缺省协议采用单一长连接和 NIO 异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。</p>
<p>缺省协议，使用基于 mina 1.1.7 和 hessian 3.2.1 的 tbremoting 交互。</p>
<ul>
<li><p>连接个数：单连接</p>
</li>
<li><p>连接方式：长连接</p>
</li>
<li><p>传输协议：TCP</p>
</li>
<li><p>传输方式：NIO 异步传输</p>
</li>
<li><p>序列化：Hessian 二进制序列化</p>
</li>
<li><p>适用范围：传入传出参数数据包较小（建议小于100K），消费者比提供者个数多，单一消费者无法压满提供者，尽量不要用 dubbo 协议传输大文件或超大字符串。</p>
</li>
<li><p>适用场景：常规远程服务方法调用</p>
</li>
</ul>
<h5 id="rmi协议"><a href="#rmi协议" class="headerlink" title="rmi协议"></a>rmi协议</h5><p>RMI 协议采用 JDK 标准的 java.rmi.* 实现，采用阻塞式短连接和 JDK 标准序列化方式。</p>
<ul>
<li><p>连接个数：多连接</p>
</li>
<li><p>连接方式：短连接</p>
</li>
<li><p>传输协议：TCP</p>
</li>
<li><p>传输方式：同步传输</p>
</li>
<li><p>序列化：Java 标准二进制序列化</p>
</li>
<li><p>适用范围：传入传出参数数据包大小混合，消费者与提供者个数差不多，可传文件。</p>
</li>
<li><p>适用场景：常规远程服务方法调用，与原生RMI服务互操作</p>
</li>
</ul>
<h5 id="hessian协议"><a href="#hessian协议" class="headerlink" title="hessian协议"></a>hessian协议</h5><p>Hessian 协议用于集成 Hessian 的服务，Hessian 底层采用 Http 通讯，采用 Servlet 暴露服务，Dubbo 缺省内嵌 Jetty 作为服务器实现。Dubbo 的 Hessian 协议可以和原生 Hessian 服务互操作，即：</p>
<ul>
<li><p>提供者用 Dubbo 的 Hessian 协议暴露服务，消费者直接用标准 Hessian 接口调用</p>
</li>
<li><p>或者提供方用标准 Hessian 暴露服务，消费方用 Dubbo 的 Hessian 协议调用。</p>
</li>
<li><p>连接个数：多连接</p>
</li>
<li><p>连接方式：短连接</p>
</li>
<li><p>传输协议：HTTP</p>
</li>
<li><p>传输方式：同步传输</p>
</li>
<li><p>序列化：Hessian二进制序列化</p>
</li>
<li><p>适用范围：传入传出参数数据包较大，提供者比消费者个数多，提供者压力较大，可传文件。</p>
</li>
<li><p>适用场景：页面传输，文件传输，或与原生hessian服务互操作</p>
</li>
</ul>
<h5 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h5><p>基于 HTTP 表单的远程调用协议，采用 Spring 的 HttpInvoker 实现</p>
<ul>
<li><p>连接个数：多连接</p>
</li>
<li><p>连接方式：短连接</p>
</li>
<li><p>传输协议：HTTP</p>
</li>
<li><p>传输方式：同步传输序列化：表单序列化</p>
</li>
<li><p>适用范围：传入传出参数数据包大小混合，提供者比消费者个数多，可用浏览器查看，可用表单或URL传入参数，暂不支持传文件。</p>
</li>
<li><p>适用场景：需同时给应用程序和浏览器 JS 使用的服务。</p>
</li>
</ul>
<h5 id="webservice协议"><a href="#webservice协议" class="headerlink" title="webservice协议"></a>webservice协议</h5><p>基于 WebService 的远程调用协议，基于 Apache CXF 实现](<a target="_blank" rel="noopener" href="http://dubbo.apache.org/zh-cn/docs/user/references/protocol/webservice.html#fn2)%E3%80%82">http://dubbo.apache.org/zh-cn/docs/user/references/protocol/webservice.html#fn2)。</a></p>
<p>可以和原生 WebService 服务互操作，即：</p>
<ul>
<li><p>提供者用 Dubbo 的 WebService 协议暴露服务，消费者直接用标准 WebService 接口调用，</p>
</li>
<li><p>或者提供方用标准 WebService 暴露服务，消费方用 Dubbo 的 WebService 协议调用。</p>
</li>
<li><p>连接个数：多连接</p>
</li>
<li><p>连接方式：短连接</p>
</li>
<li><p>传输协议：HTTP</p>
</li>
<li><p>传输方式：同步传输</p>
</li>
<li><p>序列化：SOAP 文本序列化（http + xml）</p>
</li>
<li><p>适用场景：系统集成，跨语言调用</p>
</li>
</ul>
<h5 id="thrift协议"><a href="#thrift协议" class="headerlink" title="thrift协议"></a>thrift协议</h5><p>当前 dubbo 支持 [1]的 thrift 协议是对 thrift 原生协议 [2] 的扩展，在原生协议的基础上添加了一些额外的头信息，比如 service name，magic number 等。</p>
<h5 id="rest协议"><a href="#rest协议" class="headerlink" title="rest协议"></a>rest协议</h5><p>基于标准的Java REST API——JAX-RS 2.0（Java API for RESTful Web Services的简写）实现的REST调用支持</p>
<h5 id="grpc协议"><a href="#grpc协议" class="headerlink" title="grpc协议"></a>grpc协议</h5><p>Dubbo 自 2.7.5 版本开始支持 gRPC 协议，对于计划使用 HTTP/2 通信，或者想利用 gRPC 带来的Stream、反压、Reactive 编程等能力的开发者来说， 都可以考虑启用 gRPC 协议。</p>
<p>为期望使用 gRPC 协议的用户带来服务治理能力，方便接入 Dubbo 体系用户可以使用 Dubbo 风格的，基于接口的编程风格来定义和使用远程服务</p>
<h5 id="memcached协议"><a href="#memcached协议" class="headerlink" title="memcached协议"></a>memcached协议</h5><p>基于 memcached实现的 RPC 协议</p>
<h5 id="redis协议"><a href="#redis协议" class="headerlink" title="redis协议"></a>redis协议</h5><p>基于 Redis 实现的 RPC 协议</p>
<h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><p>序列化就是将对象转成字节流，用于网络传输，以及将字节流转为对象，用于在收到字节流数据后还原成对象。序列化的优势有很多，例如安全性更好、可跨平台等。dubbo基于netty进行网络通讯，在 NettyClient.doOpen() 方法中可以看到Netty的相关类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doOpen</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>    NettyHelper.setNettyLoggerFactory();<br>    bootstrap = <span class="hljs-keyword">new</span> ClientBootstrap(CHANNEL_FACTORY);<br>    <span class="hljs-comment">// config</span><br>    <span class="hljs-comment">// @see org.jboss.netty.channel.socket.SocketChannelConfig</span><br>    bootstrap.setOption(<span class="hljs-string">&quot;keepAlive&quot;</span>, <span class="hljs-keyword">true</span>);<br>    bootstrap.setOption(<span class="hljs-string">&quot;tcpNoDelay&quot;</span>, <span class="hljs-keyword">true</span>);<br>    bootstrap.setOption(<span class="hljs-string">&quot;connectTimeoutMillis&quot;</span>, getConnectTimeout());<br>    <span class="hljs-keyword">final</span> NettyHandler nettyHandler = <span class="hljs-keyword">new</span> NettyHandler(getUrl(), <span class="hljs-keyword">this</span>);<br>    bootstrap.setPipelineFactory(<span class="hljs-keyword">new</span> ChannelPipelineFactory() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> ChannelPipeline <span class="hljs-title">getPipeline</span><span class="hljs-params">()</span> </span>&#123;<br>            NettyCodecAdapter adapter = <span class="hljs-keyword">new</span> NettyCodecAdapter(getCodec(), getUrl(), NettyClient.<span class="hljs-keyword">this</span>);<br>            ChannelPipeline pipeline = Channels.pipeline();<br>            pipeline.addLast(<span class="hljs-string">&quot;decoder&quot;</span>, adapter.getDecoder());<br>            pipeline.addLast(<span class="hljs-string">&quot;encoder&quot;</span>, adapter.getEncoder());<br>            pipeline.addLast(<span class="hljs-string">&quot;handler&quot;</span>, nettyHandler);<br>            <span class="hljs-keyword">return</span> pipeline;<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后去看NettyCodecAdapter 类最后进入ExchangeCodec类的encodeRequest方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encodeRequest</span><span class="hljs-params">(Channel channel, ChannelBuffer buffer, Request req)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>  	<span class="hljs-comment">// 默认是Hessian2Serialization序列化接口</span><br>    Serialization serialization = getSerialization(channel);<br>    <span class="hljs-comment">// ... 略</span><br></code></pre></td></tr></table></figure>

<p>这里获取的Serialization接口，默认是Hessian2Serialization序列化接口。</p>
<p>Dubbo序列化支持java、compactedjava、nativejava、fastjson、dubbo、fst、hessian2、kryo，protostuff其中默认hessian2。其中java、compactedjava、nativejava属于原生java的序列化。</p>
<ul>
<li>dubbo序列化：阿里尚未开发成熟的高效java序列化实现，阿里不建议在生产环境使用它。</li>
<li>hessian2序列化：hessian是一种跨语言的高效二进制序列化方式。但这里实际不是原生的hessian2序列化，而是阿里修改过的，它是dubbo RPC默认启用的序列化方式。</li>
<li>json序列化：目前有两种实现，一种是采用的阿里的fastjson库，另一种是采用dubbo中自己实现的简单json库，但其实现都不是特别成熟，而且json这种文本序列化性能一般不如上面两种二进制序列化。</li>
<li>java序列化：主要是采用JDK自带的Java序列化实现，性能很不理想。</li>
</ul>
<p>最近几年，各种新的高效序列化方式层出不穷，不断刷新序列化性能的上限，最典型的包括：</p>
<ul>
<li><p>专门针对Java语言的：Kryo，FST等等</p>
</li>
<li><p>跨语言的：Protostuff，ProtoBuf，Thrift，Avro，MsgPack等等</p>
</li>
</ul>
<p>这些序列化方式的性能多数都显著优于 hessian2 （甚至包括尚未成熟的dubbo序列化）。所以我们可以为 dubbo 引入 Kryo 和 FST 这两种高效 Java 来优化 dubbo 的序列化。</p>
<p>使用Kryo和FST非常简单，只需要在dubbo RPC的XML配置中添加一个属性即可：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dubbo&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">serialization</span>=<span class="hljs-string">&quot;kryo&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure>

<h4 id="网络通信-1"><a href="#网络通信-1" class="headerlink" title="网络通信"></a>网络通信</h4><h5 id="dubbo中数据格式"><a href="#dubbo中数据格式" class="headerlink" title="dubbo中数据格式"></a>dubbo中数据格式</h5><p>解决socket中数据粘包拆包问题，一般有三种方式</p>
<ul>
<li><p>定长协议（数据包长度一致）</p>
<p>定长的协议是指协议内容的长度是固定的，比如协议byte长度是50，当从网络上读取50个 byte后，就进行decode解码操作。定长协议在读取或者写入时，效率比较高，因为数据缓存的大小基本都确定了，就好比数组一样，缺陷就是适应性不足，以RPC场景为例，很难估计出定长的长度是多少。</p>
</li>
<li><p>特殊结束符（数据尾：通过特殊的字符标识#）</p>
<p>相比定长协议，如果能够定义一个特殊字符作为每个协议单元结束的标示，就能够以变长的方式进行通信，从而在数据传输和高效之间取得平衡，比如用特殊字符 \n 。特殊结束符方式的问题是过于简单的思考了协议传输的过程，对于一个协议单元必须要全部读入才能够进行处理，除此之外必须要防止用户传输的数据不能同结束符相同，否则就会出现紊乱。</p>
</li>
<li><p>变长协议（协议头+payload模式）</p>
<p>这种一般是自定义协议，会以定长加不定长的部分组成，其中定长的部分需要描述不定长的内容长度。dubbo就是使用这种形式的数据传输格式</p>
</li>
</ul>
<p>Dubbo 框架定义了私有的RPC协议，其中请求和响应协议的具体内容我们使用表格来展示。</p>
<p><img src="/blog/2021/04/27/Dubbo/dubbo%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/pic19.png" srcset="/blog/img/loading.gif" lazyload></p>
<p>Dubbo 数据包分为消息头和消息体，消息头用于存储一些元信息，比如魔数（Magic），数据包类型（Request/Response），消息体长度（Data Length）等。消息体中用于存储具体的调用消息，比如方法名称，参数列表等。下面简单列举一下消息头的内容。</p>
<table>
<thead>
<tr>
<th>偏移量（Bit）</th>
<th>字段</th>
<th>取值</th>
</tr>
</thead>
<tbody><tr>
<td>0-7</td>
<td>魔数高位</td>
<td>0xda00</td>
</tr>
<tr>
<td>8-15</td>
<td>魔数低位</td>
<td>0xbb</td>
</tr>
<tr>
<td>16</td>
<td>数据包类型</td>
<td>0 - Response<br>1 - Request</td>
</tr>
<tr>
<td>17</td>
<td>调用方式</td>
<td>仅在第16位被设为1的情况下有效，0 - 单向调用，1 - 双向调用</td>
</tr>
<tr>
<td>18</td>
<td>事件标识</td>
<td>0 - 当前数据包是请求或响应包，1 - 当前数据包是心跳包</td>
</tr>
<tr>
<td>19-23</td>
<td>序列化器编号</td>
<td>2 - Hessian2Serialization<br>3 - JavaSerialization<br>4 - CompactedJavaSerialization<br>6 - FastJsonSerialization<br>7 - NativeJavaSerialization<br>8 - KryoSerialization<br>9 - FstSerialization</td>
</tr>
<tr>
<td>24-31</td>
<td>状态</td>
<td>20 - OK <br>30 - CLIENT_TIMEOUT <br>31 - SERVER_TIMEOUT <br>40 -BAD_REQUEST <br>50 - BAD_RESPONSE ……</td>
</tr>
<tr>
<td>32-95</td>
<td>请求编号</td>
<td>共8字节，运行时生成</td>
</tr>
<tr>
<td>96-127</td>
<td>消息体长度</td>
<td>运行时计算</td>
</tr>
</tbody></table>
<h5 id="消费方发送请求"><a href="#消费方发送请求" class="headerlink" title="消费方发送请求"></a>消费方发送请求</h5><h6 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h6><p>这里以 DemoService 为例，将 sayHello 方法的整个调用路径贴出来。</p>
<figure class="highlight leaf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs leaf">proxy0<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">sayHello</span><span class="hljs-params">(<span class="hljs-variable">String</span>)</span></span> <br>—&gt; InvokerInvocationHandler<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">invoke</span><span class="hljs-params">(<span class="hljs-variable">Object</span>, <span class="hljs-variable">Method</span>, <span class="hljs-variable">Object</span>[])</span></span> <br>—&gt; MockClusterInvoker<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">invoke</span><span class="hljs-params">(<span class="hljs-variable">Invocation</span>)</span></span> <br>—&gt; AbstractClusterInvoker<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">invoke</span><span class="hljs-params">(<span class="hljs-variable">Invocation</span>)</span></span> <br>—&gt; FailoverClusterInvoker<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">doInvoke</span><span class="hljs-params">(<span class="hljs-variable">Invocation</span>, <span class="hljs-variable">List</span>&lt;<span class="hljs-variable">Invoker</span>&lt;<span class="hljs-variable">T</span>&gt;&gt;, <span class="hljs-variable">LoadBalance</span>)</span></span><br>—&gt; Filter<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">invoke</span><span class="hljs-params">(<span class="hljs-variable">Invoker</span>, <span class="hljs-variable">Invocation</span>)</span></span> // 包含多个 Filter 调用 <br>—&gt; ListenerInvokerWrapper<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">invoke</span><span class="hljs-params">(<span class="hljs-variable">Invocation</span>)</span></span> <br>—&gt; AbstractInvoker<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">invoke</span><span class="hljs-params">(<span class="hljs-variable">Invocation</span>)</span></span> <br>—&gt; DubboInvoker<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">doInvoke</span><span class="hljs-params">(<span class="hljs-variable">Invocation</span>)</span></span> <br>—&gt; ReferenceCountExchangeClient<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">request</span><span class="hljs-params">(<span class="hljs-variable">Object</span>, <span class="hljs-variable">int</span>)</span></span> <br>—&gt; HeaderExchangeClient<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">request</span><span class="hljs-params">(<span class="hljs-variable">Object</span>, <span class="hljs-variable">int</span>)</span></span> <br>—&gt; HeaderExchangeChannel<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">request</span><span class="hljs-params">(<span class="hljs-variable">Object</span>, <span class="hljs-variable">int</span>)</span></span> <br>—&gt; AbstractPeer<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">send</span><span class="hljs-params">(<span class="hljs-variable">Object</span>)</span></span><br>—&gt; AbstractClient<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">send</span><span class="hljs-params">(<span class="hljs-variable">Object</span>, <span class="hljs-variable">boolean</span>)</span></span><br></code></pre></td></tr></table></figure>

<p>dubbo消费方，自动生成代码对象如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">proxy0</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ClassGenerator</span>.<span class="hljs-title">DC</span>, <span class="hljs-title">EchoService</span>, <span class="hljs-title">DemoService</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> InvocationHandler handler; <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sayHello</span><span class="hljs-params">(String string)</span> </span>&#123;<br>    <span class="hljs-comment">// 将参数存储到 Object 数组中 </span><br>    Object[] arrobject = <span class="hljs-keyword">new</span> Object[]&#123;string&#125;; <br>    <span class="hljs-comment">// 调用 InvocationHandler 实现类的 invoke 方法得到调用结果 </span><br>    Object object = <span class="hljs-keyword">this</span>.handler.invoke(<span class="hljs-keyword">this</span>, methods[<span class="hljs-number">0</span>], arrobject); <br>    <span class="hljs-comment">// 返回调用结果 </span><br>    <span class="hljs-keyword">return</span> (String)object; <br>  &#125; <br>&#125;<br></code></pre></td></tr></table></figure>

<p>InvokerInvocationHandler 中的 invoker 成员变量类型为 MockClusterInvoker，MockClusterInvoker内部封装了服务降级逻辑。下面简单看一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">invoke</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> RpcException </span>&#123;<br>    Result result = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-comment">// 获取 mock 配置值</span><br>    String value = directory.getUrl().getMethodParameter(invocation.getMethodName(), MOCK_KEY, Boolean.FALSE.toString()).trim();<br>    <span class="hljs-keyword">if</span> (value.length() == <span class="hljs-number">0</span> || value.equalsIgnoreCase(<span class="hljs-string">&quot;false&quot;</span>)) &#123;<br>        <span class="hljs-comment">// no mock</span><br>        <span class="hljs-comment">// 无 mock 逻辑，直接调用其他 Invoker 对象的 invoke 方法，比如 FailoverClusterInvoker</span><br>        result = <span class="hljs-keyword">this</span>.invoker.invoke(invocation);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value.startsWith(<span class="hljs-string">&quot;force&quot;</span>)) &#123;<br>        <span class="hljs-keyword">if</span> (logger.isWarnEnabled()) &#123;<br>            logger.warn(<span class="hljs-string">&quot;force-mock: &quot;</span> + invocation.getMethodName() + <span class="hljs-string">&quot; force-mock enabled , url : &quot;</span> + directory.getUrl());<br>        &#125;<br>        <span class="hljs-comment">// force:direct mock</span><br>        <span class="hljs-comment">// force:xxx 直接执行 mock 逻辑，不发起远程调用</span><br>        result = doMockInvoke(invocation, <span class="hljs-keyword">null</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// fail-mock</span><br>        <span class="hljs-comment">// fail:xxx 表示消费方对调用服务失败后，再执行 mock 逻辑，不抛出异常</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            result = <span class="hljs-keyword">this</span>.invoker.invoke(invocation);<br>        &#125; <span class="hljs-keyword">catch</span> (RpcException e) &#123;<br>            <span class="hljs-keyword">if</span> (e.isBiz()) &#123;<br>                <span class="hljs-keyword">throw</span> e;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (logger.isWarnEnabled()) &#123;<br>                logger.warn(<span class="hljs-string">&quot;fail-mock: &quot;</span> + invocation.getMethodName() + <span class="hljs-string">&quot; fail-mock enabled , url : &quot;</span> + directory.getUrl(), e);<br>            &#125;<br>            <span class="hljs-comment">// 调用失败，执行 mock 逻辑</span><br>            result = doMockInvoke(invocation, e);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>考虑到前文已经详细分析过 FailoverClusterInvoker，因此本节略过 FailoverClusterInvoker，直接分析 DubboInvoker。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">invoke</span><span class="hljs-params">(Invocation inv)</span> <span class="hljs-keyword">throws</span> RpcException </span>&#123;<br>    <span class="hljs-comment">// if invoker is destroyed due to address refresh from registry, let&#x27;s allow the current invoke to proceed</span><br>    <span class="hljs-keyword">if</span> (destroyed.get()) &#123;<br>        logger.warn(<span class="hljs-string">&quot;Invoker for service &quot;</span> + <span class="hljs-keyword">this</span> + <span class="hljs-string">&quot; on consumer &quot;</span> + NetUtils.getLocalHost() + <span class="hljs-string">&quot; is destroyed, &quot;</span><br>                + <span class="hljs-string">&quot;, dubbo version is &quot;</span> + Version.getVersion() + <span class="hljs-string">&quot;, this invoker should not be used any longer&quot;</span>);<br>    &#125;<br>    RpcInvocation invocation = (RpcInvocation) inv;<br>    <span class="hljs-comment">// 设置 Invoker</span><br>    invocation.setInvoker(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">if</span> (CollectionUtils.isNotEmptyMap(attachment)) &#123;<br>        <span class="hljs-comment">// 设置 attachment</span><br>        invocation.addAttachmentsIfAbsent(attachment);<br>    &#125;<br>    Map&lt;String, String&gt; contextAttachments = RpcContext.getContext().getAttachments();<br>    <span class="hljs-keyword">if</span> (CollectionUtils.isNotEmptyMap(contextAttachments)) &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * invocation.addAttachmentsIfAbsent(context)&#123;<span class="hljs-doctag">@link</span> RpcInvocation#addAttachmentsIfAbsent(Map)&#125;should not be used here,</span><br><span class="hljs-comment">         * because the &#123;<span class="hljs-doctag">@link</span> RpcContext#setAttachment(String, String)&#125; is passed in the Filter when the call is triggered</span><br><span class="hljs-comment">         * by the built-in retry mechanism of the Dubbo. The attachment to update RpcContext will no longer work, which is</span><br><span class="hljs-comment">         * a mistake in most cases (for example, through Filter to RpcContext output traceId and spanId and other information).</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-comment">// 添加 contextAttachments 到 RpcInvocation#attachment 变量中</span><br>        invocation.addAttachments(contextAttachments);<br>    &#125;<br><br>    invocation.setInvokeMode(RpcUtils.getInvokeMode(url, invocation));<br>    <span class="hljs-comment">// 设置异步信息到 RpcInvocation#attachment 中</span><br>    RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 抽象方法，由子类实现</span><br>        <span class="hljs-keyword">return</span> doInvoke(invocation);<br>    &#125; <span class="hljs-keyword">catch</span> (InvocationTargetException e) &#123; <span class="hljs-comment">// biz exception</span><br>        Throwable te = e.getTargetException();<br>        <span class="hljs-keyword">if</span> (te == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> AsyncRpcResult.newDefaultAsyncResult(<span class="hljs-keyword">null</span>, e, invocation);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (te <span class="hljs-keyword">instanceof</span> RpcException) &#123;<br>                ((RpcException) te).setCode(RpcException.BIZ_EXCEPTION);<br>            &#125;<br>            <span class="hljs-keyword">return</span> AsyncRpcResult.newDefaultAsyncResult(<span class="hljs-keyword">null</span>, te, invocation);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (RpcException e) &#123;<br>        <span class="hljs-keyword">if</span> (e.isBiz()) &#123;<br>            <span class="hljs-keyword">return</span> AsyncRpcResult.newDefaultAsyncResult(<span class="hljs-keyword">null</span>, e, invocation);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> e;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>        <span class="hljs-keyword">return</span> AsyncRpcResult.newDefaultAsyncResult(<span class="hljs-keyword">null</span>, e, invocation);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面的代码来自 AbstractInvoker 类，其中大部分代码用于添加信息到 RpcInvocation#attachment 量中，添加完毕后，调用 doInvoke 执行后续的调用。doInvoke 是一个抽象方法，需要由子类实现，下面到 DubboInvoker 中看一下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Result <span class="hljs-title">doInvoke</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Invocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>    RpcInvocation inv = (RpcInvocation) invocation;<br>    <span class="hljs-keyword">final</span> String methodName = RpcUtils.getMethodName(invocation);<br>    <span class="hljs-comment">// 将目标方法以及版本号作为参数放入到Invocation中</span><br>    inv.setAttachment(PATH_KEY, getUrl().getPath());<br>    inv.setAttachment(VERSION_KEY, version);<br><br>    <span class="hljs-comment">// 获得客户端连接</span><br>    ExchangeClient currentClient;<br>    <span class="hljs-comment">// 初始化invoker的时候，构建的一个远程通信连接</span><br>    <span class="hljs-keyword">if</span> (clients.length == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 默认</span><br>        currentClient = clients[<span class="hljs-number">0</span>];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 通过取模获得其中一个连接</span><br>        currentClient = clients[index.getAndIncrement() % clients.length];<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 表示当前方法是否存在返回值</span><br>        <span class="hljs-keyword">boolean</span> isOneway = RpcUtils.isOneway(getUrl(), invocation);<br>        <span class="hljs-keyword">int</span> timeout = getUrl().getMethodParameter(methodName, TIMEOUT_KEY, DEFAULT_TIMEOUT);<br>        <span class="hljs-comment">// isOneway 为true，表示单向通信</span><br>        <span class="hljs-keyword">if</span> (isOneway) &#123;<span class="hljs-comment">//异步无返回值</span><br>            <span class="hljs-keyword">boolean</span> isSent = getUrl().getMethodParameter(methodName, Constants.SENT_KEY, <span class="hljs-keyword">false</span>);<br>            currentClient.send(inv, isSent);<br>            RpcContext.getContext().setFuture(<span class="hljs-keyword">null</span>);<br>            <span class="hljs-keyword">return</span> AsyncRpcResult.newDefaultAsyncResult(invocation);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//存在返回值</span><br>            <span class="hljs-comment">//是否采用异步</span><br>            AsyncRpcResult asyncRpcResult = <span class="hljs-keyword">new</span> AsyncRpcResult(inv);<br>            CompletableFuture&lt;Object&gt; responseFuture = currentClient.request(inv, timeout);<br>            responseFuture.whenComplete((obj, t) -&gt; &#123;<br>                <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span>) &#123;<br>                    asyncRpcResult.completeExceptionally(t);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    asyncRpcResult.complete((AppResponse) obj);<br>                &#125;<br>            &#125;);<br>            RpcContext.getContext().setFuture(<span class="hljs-keyword">new</span> FutureAdapter(asyncRpcResult));<br>            <span class="hljs-keyword">return</span> asyncRpcResult;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (TimeoutException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RpcException(RpcException.TIMEOUT_EXCEPTION, <span class="hljs-string">&quot;Invoke remote method timeout. method: &quot;</span> + invocation.getMethodName() + <span class="hljs-string">&quot;, provider: &quot;</span> + getUrl() + <span class="hljs-string">&quot;, cause: &quot;</span> + e.getMessage(), e);<br>    &#125; <span class="hljs-keyword">catch</span> (RemotingException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RpcException(RpcException.NETWORK_EXCEPTION, <span class="hljs-string">&quot;Failed to invoke remote method: &quot;</span> + invocation.getMethodName() + <span class="hljs-string">&quot;, provider: &quot;</span> + getUrl() + <span class="hljs-string">&quot;, cause: &quot;</span> + e.getMessage(), e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>最终进入到HeaderExchangeChannel#request方法，拼装Request并将请求发送出去</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> CompletableFuture&lt;Object&gt; <span class="hljs-title">request</span><span class="hljs-params">(Object request, <span class="hljs-keyword">int</span> timeout)</span> <span class="hljs-keyword">throws</span> RemotingException </span>&#123;<br>    <span class="hljs-keyword">if</span> (closed) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RemotingException(<span class="hljs-keyword">this</span>.getLocalAddress(), <span class="hljs-keyword">null</span>, <span class="hljs-string">&quot;Failed to send request &quot;</span> + request + <span class="hljs-string">&quot;, cause: The channel &quot;</span> + <span class="hljs-keyword">this</span> + <span class="hljs-string">&quot; is closed!&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 创建请求对象</span><br>    <span class="hljs-comment">// create request.</span><br>    Request req = <span class="hljs-keyword">new</span> Request();<br>    req.setVersion(Version.getProtocolVersion());<br>    req.setTwoWay(<span class="hljs-keyword">true</span>);<br>    req.setData(request);<br>    DefaultFuture future = DefaultFuture.newFuture(channel, req, timeout);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//NettyClient</span><br>        channel.send(req);<br>    &#125; <span class="hljs-keyword">catch</span> (RemotingException e) &#123;<br>        future.cancel();<br>        <span class="hljs-keyword">throw</span> e;<br>    &#125;<br>    <span class="hljs-keyword">return</span> future;<br>&#125;<br></code></pre></td></tr></table></figure>

<h6 id="请求编码"><a href="#请求编码" class="headerlink" title="请求编码"></a>请求编码</h6><p>在netty启动时，会设置编解码器，其中通过ExchangeCodec完成编解码工作如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExchangeCodec</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TelnetCodec</span> </span>&#123;<br><br>    <span class="hljs-comment">// header length.</span><br>    <span class="hljs-comment">// 消息头长度</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> HEADER_LENGTH = <span class="hljs-number">16</span>;<br>    <span class="hljs-comment">// magic header.</span><br>    <span class="hljs-comment">// 魔数内容</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">short</span> MAGIC = (<span class="hljs-keyword">short</span>) <span class="hljs-number">0xdabb</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span> MAGIC_HIGH = Bytes.short2bytes(MAGIC)[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span> MAGIC_LOW = Bytes.short2bytes(MAGIC)[<span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// message flag.</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span> FLAG_REQUEST = (<span class="hljs-keyword">byte</span>) <span class="hljs-number">0x80</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span> FLAG_TWOWAY = (<span class="hljs-keyword">byte</span>) <span class="hljs-number">0x40</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span> FLAG_EVENT = (<span class="hljs-keyword">byte</span>) <span class="hljs-number">0x20</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SERIALIZATION_MASK = <span class="hljs-number">0x1f</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger logger = LoggerFactory.getLogger(ExchangeCodec.class);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Short <span class="hljs-title">getMagicCode</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> MAGIC;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(Channel channel, ChannelBuffer buffer, Object msg)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">if</span> (msg <span class="hljs-keyword">instanceof</span> Request) &#123;<br>            <span class="hljs-comment">// 对 Request 对象进行编码</span><br>            encodeRequest(channel, buffer, (Request) msg);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (msg <span class="hljs-keyword">instanceof</span> Response) &#123;<br>            <span class="hljs-comment">// 对 Response 对象进行编码，后面分析</span><br>            encodeResponse(channel, buffer, (Response) msg);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">super</span>.encode(channel, buffer, msg);<br>        &#125;<br>    &#125;<br>  <br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encodeRequest</span><span class="hljs-params">(Channel channel, ChannelBuffer buffer, Request req)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        Serialization serialization = getSerialization(channel);<br>        <span class="hljs-comment">// header.</span><br>        <span class="hljs-comment">// 创建消息头字节数组，长度为 16</span><br>        <span class="hljs-keyword">byte</span>[] header = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[HEADER_LENGTH];<br>        <span class="hljs-comment">// set magic number.</span><br>        <span class="hljs-comment">// 设置魔数</span><br>        Bytes.short2bytes(MAGIC, header);<br><br>        <span class="hljs-comment">// set request and serialization flag.</span><br>        <span class="hljs-comment">// 设置数据包类型（Request/Response）和序列化器编号</span><br>        header[<span class="hljs-number">2</span>] = (<span class="hljs-keyword">byte</span>) (FLAG_REQUEST | serialization.getContentTypeId());<br><br>        <span class="hljs-comment">// 设置通信方式(单向/双向)</span><br>        <span class="hljs-keyword">if</span> (req.isTwoWay()) &#123;<br>            header[<span class="hljs-number">2</span>] |= FLAG_TWOWAY;<br>        &#125;<br><br>        <span class="hljs-comment">// 设置事件标识</span><br>        <span class="hljs-keyword">if</span> (req.isEvent()) &#123;<br>            header[<span class="hljs-number">2</span>] |= FLAG_EVENT;<br>        &#125;<br><br>        <span class="hljs-comment">// set request id.</span><br>        <span class="hljs-comment">// 设置请求编号，8个字节，从第4个字节开始设置</span><br>        Bytes.long2bytes(req.getId(), header, <span class="hljs-number">4</span>);<br><br>        <span class="hljs-comment">// encode request data.</span><br>        <span class="hljs-comment">// 获取 buffer 当前的写位置</span><br>        <span class="hljs-keyword">int</span> savedWriteIndex = buffer.writerIndex();<br>        <span class="hljs-comment">// 更新 writerIndex，为消息头预留 16 个字节的空间</span><br>        buffer.writerIndex(savedWriteIndex + HEADER_LENGTH);<br>        ChannelBufferOutputStream bos = <span class="hljs-keyword">new</span> ChannelBufferOutputStream(buffer);<br>        <span class="hljs-comment">// 创建序列化器，比如 Hessian2ObjectOutput</span><br>        ObjectOutput out = serialization.serialize(channel.getUrl(), bos);<br>        <span class="hljs-keyword">if</span> (req.isEvent()) &#123;<br>            <span class="hljs-comment">// 对事件数据进行序列化操作</span><br>            encodeEventData(channel, out, req.getData());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 对请求数据进行序列化操作</span><br>            encodeRequestData(channel, out, req.getData(), req.getVersion());<br>        &#125;<br>        out.flushBuffer();<br>        <span class="hljs-keyword">if</span> (out <span class="hljs-keyword">instanceof</span> Cleanable) &#123;<br>            ((Cleanable) out).cleanup();<br>        &#125;<br>        bos.flush();<br>        bos.close();<br>        <span class="hljs-comment">// 获取写入的字节数，也就是消息体长度</span><br>        <span class="hljs-keyword">int</span> len = bos.writtenBytes();<br>        checkPayload(channel, len);<br>        <span class="hljs-comment">// 将消息体长度写入到消息头中</span><br>        Bytes.int2bytes(len, header, <span class="hljs-number">12</span>);<br><br>        <span class="hljs-comment">// write</span><br>        <span class="hljs-comment">// 将 buffer 指针移动到 savedWriteIndex，为写消息头做准备</span><br>        buffer.writerIndex(savedWriteIndex);<br>        <span class="hljs-comment">// 从 savedWriteIndex 下标处写入消息头</span><br>        buffer.writeBytes(header); <span class="hljs-comment">// write header.</span><br>        <span class="hljs-comment">// 设置新的 writerIndex，writerIndex = 原写下标 + 消息头长度 + 消息体长度</span><br>        buffer.writerIndex(savedWriteIndex + HEADER_LENGTH + len);<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>以上就是请求对象的编码过程，该过程首先会通过位运算将消息头写入到 header 数组中。然后对Request 对象的 data 字段执行序列化操作，序列化后的数据最终会存储到 ChannelBuffer 中。序列化操作执行完后，可得到数据序列化后的长度 len，紧接着将 len 写入到 header 指定位置处。最后再将消息头字节数组 header 写入到 ChannelBuffer 中，整个编码过程就结束了。本节的最后，我们再来看一下 Request 对象的 data 字段序列化过程，也就是 encodeRequestData 方法的逻辑，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encodeRequestData</span><span class="hljs-params">(Channel channel, ObjectOutput out, Object data, String version)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    RpcInvocation inv = (RpcInvocation) data;<br><br>    <span class="hljs-comment">// 依次序列化 dubbo version、path、version</span><br>    out.writeUTF(version);<br>    out.writeUTF(inv.getAttachment(PATH_KEY));<br>    out.writeUTF(inv.getAttachment(VERSION_KEY));<br><br>    <span class="hljs-comment">// 序列化调用方法名</span><br>    out.writeUTF(inv.getMethodName());<br>    <span class="hljs-comment">// 将参数类型转换为字符串，并进行序列化</span><br>    out.writeUTF(ReflectUtils.getDesc(inv.getParameterTypes()));<br>    Object[] args = inv.getArguments();<br>    <span class="hljs-keyword">if</span> (args != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; args.length; i++) &#123;<br>            <span class="hljs-comment">// 对运行时参数进行序列化</span><br>            out.writeObject(encodeInvocationArgument(channel, inv, i));<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 序列化 attachments</span><br>    out.writeObject(inv.getAttachments());<br>&#125;<br></code></pre></td></tr></table></figure>

<p>至此，关于服务消费方发送请求的过程就分析完了</p>
<h5 id="提供方接收请求"><a href="#提供方接收请求" class="headerlink" title="提供方接收请求"></a>提供方接收请求</h5><h6 id="请求解码"><a href="#请求解码" class="headerlink" title="请求解码"></a>请求解码</h6><p>这里直接分析请求数据的解码逻辑，忽略中间过程，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExchangeCodec</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TelnetCodec</span> </span>&#123;<br>    <span class="hljs-comment">// ... 略</span><br>		<span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">decode</span><span class="hljs-params">(Channel channel, ChannelBuffer buffer)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">int</span> readable = buffer.readableBytes();<br>        <span class="hljs-comment">// 创建消息头字节数组</span><br>        <span class="hljs-keyword">byte</span>[] header = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[Math.min(readable, HEADER_LENGTH)];<br>        <span class="hljs-comment">// 读取消息头数据</span><br>        buffer.readBytes(header);<br>        <span class="hljs-comment">// 调用重载方法进行后续解码工作</span><br>        <span class="hljs-keyword">return</span> decode(channel, buffer, readable, header);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">decode</span><span class="hljs-params">(Channel channel, ChannelBuffer buffer, <span class="hljs-keyword">int</span> readable, <span class="hljs-keyword">byte</span>[] header)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">// check magic number.</span><br>        <span class="hljs-comment">// 检查魔数是否相等</span><br>        <span class="hljs-keyword">if</span> (readable &gt; <span class="hljs-number">0</span> &amp;&amp; header[<span class="hljs-number">0</span>] != MAGIC_HIGH<br>                || readable &gt; <span class="hljs-number">1</span> &amp;&amp; header[<span class="hljs-number">1</span>] != MAGIC_LOW) &#123;<br>            <span class="hljs-keyword">int</span> length = header.length;<br>            <span class="hljs-keyword">if</span> (header.length &lt; readable) &#123;<br>                header = Bytes.copyOf(header, readable);<br>                buffer.readBytes(header, length, readable - length);<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; header.length - <span class="hljs-number">1</span>; i++) &#123;<br>                <span class="hljs-keyword">if</span> (header[i] == MAGIC_HIGH &amp;&amp; header[i + <span class="hljs-number">1</span>] == MAGIC_LOW) &#123;<br>                    buffer.readerIndex(buffer.readerIndex() - header.length + i);<br>                    header = Bytes.copyOf(header, i);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 通过 telnet 命令行发送的数据包不包含消息头，所以这里调用 TelnetCodec 的 decode 方法对数据包进行解码</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.decode(channel, buffer, readable, header);<br>        &#125;<br>        <span class="hljs-comment">// check length.</span><br>        <span class="hljs-comment">// 检测可读数据量是否少于消息头长度，若小于则立即返回 DecodeResult.NEED_MORE_INPUT</span><br>        <span class="hljs-keyword">if</span> (readable &lt; HEADER_LENGTH) &#123;<br>            <span class="hljs-keyword">return</span> DecodeResult.NEED_MORE_INPUT;<br>        &#125;<br><br>        <span class="hljs-comment">// get data length.</span><br>        <span class="hljs-comment">// 从消息头中获取消息体长度</span><br>        <span class="hljs-keyword">int</span> len = Bytes.bytes2int(header, <span class="hljs-number">12</span>);<br>        <span class="hljs-comment">// 检测消息体长度是否超出限制，超出则抛出异常</span><br>        checkPayload(channel, len);<br><br>        <span class="hljs-keyword">int</span> tt = len + HEADER_LENGTH;<br>        <span class="hljs-comment">// 检测可读的字节数是否小于实际的字节数</span><br>        <span class="hljs-keyword">if</span> (readable &lt; tt) &#123;<br>            <span class="hljs-keyword">return</span> DecodeResult.NEED_MORE_INPUT;<br>        &#125;<br><br>        <span class="hljs-comment">// limit input stream.</span><br>        ChannelBufferInputStream is = <span class="hljs-keyword">new</span> ChannelBufferInputStream(buffer, len);<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 继续进行解码工作</span><br>            <span class="hljs-keyword">return</span> decodeBody(channel, is, header);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (is.available() &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">if</span> (logger.isWarnEnabled()) &#123;<br>                        logger.warn(<span class="hljs-string">&quot;Skip input stream &quot;</span> + is.available());<br>                    &#125;<br>                    StreamUtils.skipUnusedStream(is);<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    logger.warn(e.getMessage(), e);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>		<span class="hljs-comment">// ... 略</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面方法通过检测消息头中的魔数是否与规定的魔数相等，提前拦截掉非常规数据包，比如通过 telnet命令行发出的数据包。接着再对消息体长度，以及可读字节数进行检测。最后调用 decodeBody 方法进行后续的解码工作，ExchangeCodec 中实现了 decodeBody 方法，但因其子类 DubboCodec 覆写了该方法，所以在运行时 DubboCodec 中的 decodeBody 方法会被调用。下面我们来看一下该方法的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DubboCodec</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ExchangeCodec</span> </span>&#123;<br>  	<span class="hljs-comment">// ... 略</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">decodeBody</span><span class="hljs-params">(Channel channel, InputStream is, <span class="hljs-keyword">byte</span>[] header)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">// 获取消息头中的第三个字节，并通过逻辑与运算得到序列化器编号</span><br>        <span class="hljs-keyword">byte</span> flag = header[<span class="hljs-number">2</span>], proto = (<span class="hljs-keyword">byte</span>) (flag &amp; SERIALIZATION_MASK);<br>        <span class="hljs-comment">// get request id.</span><br>        <span class="hljs-comment">// 获取调用编号</span><br>        <span class="hljs-keyword">long</span> id = Bytes.bytes2long(header, <span class="hljs-number">4</span>);<br>        <span class="hljs-comment">// 通过逻辑与运算得到调用类型，0 - Response，1 - Request</span><br>        <span class="hljs-keyword">if</span> ((flag &amp; FLAG_REQUEST) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 对响应结果进行解码，得到 Response 对象。</span><br>            <span class="hljs-comment">// decode response.</span><br>            Response res = <span class="hljs-keyword">new</span> Response(id);<br>            <span class="hljs-keyword">if</span> ((flag &amp; FLAG_EVENT) != <span class="hljs-number">0</span>) &#123;<br>                res.setEvent(<span class="hljs-keyword">true</span>);<br>            &#125;<br>            <span class="hljs-comment">// get status.</span><br>            <span class="hljs-keyword">byte</span> status = header[<span class="hljs-number">3</span>];<br>            res.setStatus(status);<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (status == Response.OK) &#123;<br>                    Object data;<br>                    <span class="hljs-keyword">if</span> (res.isHeartbeat()) &#123;<br>                        ObjectInput in = CodecSupport.deserialize(channel.getUrl(), is, proto);<br>                        data = decodeHeartbeatData(channel, in);<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res.isEvent()) &#123;<br>                        ObjectInput in = CodecSupport.deserialize(channel.getUrl(), is, proto);<br>                        data = decodeEventData(channel, in);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        DecodeableRpcResult result;<br>                        <span class="hljs-keyword">if</span> (channel.getUrl().getParameter(DECODE_IN_IO_THREAD_KEY, DEFAULT_DECODE_IN_IO_THREAD)) &#123;<br>                            result = <span class="hljs-keyword">new</span> DecodeableRpcResult(channel, res, is,<br>                                    (Invocation) getRequestData(id), proto);<br>                            result.decode();<br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                            result = <span class="hljs-keyword">new</span> DecodeableRpcResult(channel, res,<br>                                    <span class="hljs-keyword">new</span> UnsafeByteArrayInputStream(readMessageData(is)),<br>                                    (Invocation) getRequestData(id), proto);<br>                        &#125;<br>                        data = result;<br>                    &#125;<br>                    res.setResult(data);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    ObjectInput in = CodecSupport.deserialize(channel.getUrl(), is, proto);<br>                    res.setErrorMessage(in.readUTF());<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>                <span class="hljs-keyword">if</span> (log.isWarnEnabled()) &#123;<br>                    log.warn(<span class="hljs-string">&quot;Decode response failed: &quot;</span> + t.getMessage(), t);<br>                &#125;<br>                res.setStatus(Response.CLIENT_ERROR);<br>                res.setErrorMessage(StringUtils.toString(t));<br>            &#125;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// decode request.</span><br>            <span class="hljs-comment">// 创建 Request 对象</span><br>            Request req = <span class="hljs-keyword">new</span> Request(id);<br>            req.setVersion(Version.getProtocolVersion());<br>            <span class="hljs-comment">// 通过逻辑与运算得到通信方式，并设置到 Request 对象中</span><br>            req.setTwoWay((flag &amp; FLAG_TWOWAY) != <span class="hljs-number">0</span>);<br>            <span class="hljs-comment">// 通过位运算检测数据包是否为事件类型</span><br>            <span class="hljs-keyword">if</span> ((flag &amp; FLAG_EVENT) != <span class="hljs-number">0</span>) &#123;<br>                req.setEvent(<span class="hljs-keyword">true</span>);<br>            &#125;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Object data;<br>                ObjectInput in = CodecSupport.deserialize(channel.getUrl(), is, proto);<br>                <span class="hljs-keyword">if</span> (req.isHeartbeat()) &#123;<br>                    <span class="hljs-comment">// 对心跳包进行解码，该方法已被标注为废弃</span><br>                    data = decodeHeartbeatData(channel, in);<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (req.isEvent()) &#123;<br>                    <span class="hljs-comment">// 对事件数据进行解码</span><br>                    data = decodeEventData(channel, in);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    DecodeableRpcInvocation inv;<br>                    <span class="hljs-comment">// 根据 url 参数判断是否在 IO 线程上对消息体进行解码</span><br>                    <span class="hljs-keyword">if</span> (channel.getUrl().getParameter(DECODE_IN_IO_THREAD_KEY, DEFAULT_DECODE_IN_IO_THREAD)) &#123;<br>                        inv = <span class="hljs-keyword">new</span> DecodeableRpcInvocation(channel, req, is, proto);<br>                        <span class="hljs-comment">// 在当前线程，也就是 IO 线程上进行后续的解码工作。此工作完成后， 可将调用方法名、attachment、以及调用参数解析出来</span><br>                        inv.decode();<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-comment">// 仅创建 DecodeableRpcInvocation 对象，但不在当前线程上执行解 码逻辑</span><br>                        inv = <span class="hljs-keyword">new</span> DecodeableRpcInvocation(channel, req,<br>                                <span class="hljs-keyword">new</span> UnsafeByteArrayInputStream(readMessageData(is)), proto);<br>                    &#125;<br>                    data = inv;<br>                &#125;<br>                <span class="hljs-comment">// 设置 data 到 Request 对象中</span><br>                req.setData(data);<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>                <span class="hljs-keyword">if</span> (log.isWarnEnabled()) &#123;<br>                    log.warn(<span class="hljs-string">&quot;Decode request failed: &quot;</span> + t.getMessage(), t);<br>                &#125;<br>                <span class="hljs-comment">// bad request</span><br>                <span class="hljs-comment">// 若解码过程中出现异常，则将 broken 字段设为 true，并将异常对象设置到 Request 对象中</span><br>                req.setBroken(<span class="hljs-keyword">true</span>);<br>                req.setData(t);<br>            &#125;<br><br>            <span class="hljs-keyword">return</span> req;<br>        &#125;<br>    &#125;<br>  	<span class="hljs-comment">// ... 略</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>如上，decodeBody 对部分字段进行了解码，并将解码得到的字段封装到 Request 中。随后会调用DecodeableRpcInvocation 的 decode 方法进行后续的解码工作。此工作完成后，可将调用方法名、attachment、以及调用参数解析出来。</p>
<h6 id="调用服务"><a href="#调用服务" class="headerlink" title="调用服务"></a>调用服务</h6><p>解码器将数据包解析成 Request 对象后，NettyHandler 的 messageReceived 方法紧接着会收到这个对象，并将这个对象继续向下传递。整个调用栈如下：</p>
<figure class="highlight leaf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs leaf">NettyServerHandler<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">channelRead</span><span class="hljs-params">(<span class="hljs-variable">ChannelHandlerContext</span>, <span class="hljs-variable">MessageEvent</span>)</span></span> <br>—&gt; AbstractPeer<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">received</span><span class="hljs-params">(<span class="hljs-variable">Channel</span>, <span class="hljs-variable">Object</span>)</span></span> <br>—&gt; MultiMessageHandler<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">received</span><span class="hljs-params">(<span class="hljs-variable">Channel</span>, <span class="hljs-variable">Object</span>)</span></span> <br>—&gt; HeartbeatHandler<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">received</span><span class="hljs-params">(<span class="hljs-variable">Channel</span>, <span class="hljs-variable">Object</span>)</span></span> <br>—&gt; AllChannelHandler<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">received</span><span class="hljs-params">(<span class="hljs-variable">Channel</span>, <span class="hljs-variable">Object</span>)</span></span> <br>—&gt; ExecutorService<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">execute</span><span class="hljs-params">(<span class="hljs-variable">Runnable</span>)</span></span> // 由线程池执行后续的调用逻辑<br></code></pre></td></tr></table></figure>

<p>这里直接分析调用栈最后一个调用方法逻辑。ChannelEventRunnable 的 run 方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 检测通道状态，对于请求或响应消息，此时 state = RECEIVED</span><br>    <span class="hljs-keyword">if</span> (state == ChannelState.RECEIVED) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 将 channel 和 message 传给 ChannelHandler 对象，进行后续的调用</span><br>            handler.received(channel, message);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            logger.warn(<span class="hljs-string">&quot;ChannelEventRunnable handle &quot;</span> + state + <span class="hljs-string">&quot; operation error, channel is &quot;</span> + channel<br>                    + <span class="hljs-string">&quot;, message is &quot;</span> + message, e);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 其他消息类型通过 switch 进行处理</span><br>        <span class="hljs-keyword">switch</span> (state) &#123;<br>        <span class="hljs-keyword">case</span> CONNECTED:<br>            <span class="hljs-keyword">try</span> &#123;<br>                handler.connected(channel);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                logger.warn(<span class="hljs-string">&quot;ChannelEventRunnable handle &quot;</span> + state + <span class="hljs-string">&quot; operation error, channel is &quot;</span> + channel, e);<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> DISCONNECTED:<br>            <span class="hljs-keyword">try</span> &#123;<br>                handler.disconnected(channel);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                logger.warn(<span class="hljs-string">&quot;ChannelEventRunnable handle &quot;</span> + state + <span class="hljs-string">&quot; operation error, channel is &quot;</span> + channel, e);<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> SENT:<br>            <span class="hljs-keyword">try</span> &#123;<br>                handler.sent(channel, message);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                logger.warn(<span class="hljs-string">&quot;ChannelEventRunnable handle &quot;</span> + state + <span class="hljs-string">&quot; operation error, channel is &quot;</span> + channel<br>                        + <span class="hljs-string">&quot;, message is &quot;</span> + message, e);<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> CAUGHT:<br>            <span class="hljs-keyword">try</span> &#123;<br>                handler.caught(channel, exception);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                logger.warn(<span class="hljs-string">&quot;ChannelEventRunnable handle &quot;</span> + state + <span class="hljs-string">&quot; operation error, channel is &quot;</span> + channel<br>                        + <span class="hljs-string">&quot;, message is: &quot;</span> + message + <span class="hljs-string">&quot;, exception is &quot;</span> + exception, e);<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            logger.warn(<span class="hljs-string">&quot;unknown state: &quot;</span> + state + <span class="hljs-string">&quot;, message is &quot;</span> + message);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>如上，请求和响应消息出现频率明显比其他类型消息高，所以这里对该类型的消息进行了针对性判断。ChannelEventRunnable 仅是一个中转站，它的 run 方法中并不包含具体的调用逻辑，仅用于将参数传给其他 ChannelHandler 对象进行处理，该对象类型为 DecodeHandler</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DecodeHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractChannelHandlerDelegate</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(DecodeHandler.class);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DecodeHandler</span><span class="hljs-params">(ChannelHandler handler)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(handler);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">received</span><span class="hljs-params">(Channel channel, Object message)</span> <span class="hljs-keyword">throws</span> RemotingException </span>&#123;<br>        <span class="hljs-keyword">if</span> (message <span class="hljs-keyword">instanceof</span> Decodeable) &#123;<br>            <span class="hljs-comment">// 对 Decodeable 接口实现类对象进行解码</span><br>            decode(message);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (message <span class="hljs-keyword">instanceof</span> Request) &#123;<br>            <span class="hljs-comment">// 对 Request 的 data 字段进行解码</span><br>            decode(((Request) message).getData());<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (message <span class="hljs-keyword">instanceof</span> Response) &#123;<br>            <span class="hljs-comment">// 对 Request 的 result 字段进行解码</span><br>            decode(((Response) message).getResult());<br>        &#125;<br><br>        <span class="hljs-comment">// 执行后续逻辑</span><br>        handler.received(channel, message);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(Object message)</span> </span>&#123;<br>        <span class="hljs-comment">// Decodeable 接口目前有两个实现类，分别为 DecodeableRpcInvocation 和 DecodeableRpcResult</span><br>        <span class="hljs-keyword">if</span> (message <span class="hljs-keyword">instanceof</span> Decodeable) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 执行解码逻辑</span><br>                ((Decodeable) message).decode();<br>                <span class="hljs-keyword">if</span> (log.isDebugEnabled()) &#123;<br>                    log.debug(<span class="hljs-string">&quot;Decode decodeable message &quot;</span> + message.getClass().getName());<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>                <span class="hljs-keyword">if</span> (log.isWarnEnabled()) &#123;<br>                    log.warn(<span class="hljs-string">&quot;Call Decodeable.decode failed: &quot;</span> + e.getMessage(), e);<br>                &#125;<br>            &#125; <span class="hljs-comment">// ~ end of catch</span><br>        &#125; <span class="hljs-comment">// ~ end of if</span><br>    &#125; <span class="hljs-comment">// ~ end of method decode</span><br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>DecodeHandler 主要是包含了一些解码逻辑，完全解码后的 Request 对象会继续向后传递到 DubboProtocol 中的 reply 方法，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> CompletableFuture&lt;Object&gt; <span class="hljs-title">reply</span><span class="hljs-params">(ExchangeChannel channel, Object message)</span> <span class="hljs-keyword">throws</span> RemotingException </span>&#123;<br><br>    <span class="hljs-keyword">if</span> (!(message <span class="hljs-keyword">instanceof</span> Invocation)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RemotingException(channel, <span class="hljs-string">&quot;Unsupported request: &quot;</span><br>                + (message == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : (message.getClass().getName() + <span class="hljs-string">&quot;: &quot;</span> + message))<br>                + <span class="hljs-string">&quot;, channel: consumer: &quot;</span> + channel.getRemoteAddress() + <span class="hljs-string">&quot; --&gt; provider: &quot;</span> + channel.getLocalAddress());<br>    &#125;<br><br>    Invocation inv = (Invocation) message;<br>    <span class="hljs-comment">// 获取 Invoker 实例</span><br>    Invoker&lt;?&gt; invoker = getInvoker(channel, inv);<br>    <span class="hljs-comment">// need to consider backward-compatibility if it&#x27;s a callback</span><br>    <span class="hljs-keyword">if</span> (Boolean.TRUE.toString().equals(inv.getAttachments().get(IS_CALLBACK_SERVICE_INVOKE))) &#123;<br>        String methodsStr = invoker.getUrl().getParameters().get(<span class="hljs-string">&quot;methods&quot;</span>);<br>        <span class="hljs-keyword">boolean</span> hasMethod = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">if</span> (methodsStr == <span class="hljs-keyword">null</span> || !methodsStr.contains(<span class="hljs-string">&quot;,&quot;</span>)) &#123;<br>            hasMethod = inv.getMethodName().equals(methodsStr);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            String[] methods = methodsStr.split(<span class="hljs-string">&quot;,&quot;</span>);<br>            <span class="hljs-keyword">for</span> (String method : methods) &#123;<br>                <span class="hljs-keyword">if</span> (inv.getMethodName().equals(method)) &#123;<br>                    hasMethod = <span class="hljs-keyword">true</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!hasMethod) &#123;<br>            logger.warn(<span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;The methodName &quot;</span> + inv.getMethodName()<br>                    + <span class="hljs-string">&quot; not found in callback service interface ,invoke will be ignored.&quot;</span><br>                    + <span class="hljs-string">&quot; please update the api interface. url is:&quot;</span><br>                    + invoker.getUrl()) + <span class="hljs-string">&quot; ,invocation is :&quot;</span> + inv);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125;<br>    RpcContext.getContext().setRemoteAddress(channel.getRemoteAddress());<br>    <span class="hljs-comment">// 通过 Invoker 调用具体的服务</span><br>    Result result = invoker.invoke(inv);<br>    <span class="hljs-keyword">return</span> result.completionFuture().thenApply(Function.identity());<br>&#125;<br></code></pre></td></tr></table></figure>

<p>DubboProtocol 中的 getInvoker 方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java">Invoker&lt;?&gt; getInvoker(Channel channel, Invocation inv) <span class="hljs-keyword">throws</span> RemotingException &#123;<br>    <span class="hljs-keyword">boolean</span> isCallBackServiceInvoke = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">boolean</span> isStubServiceInvoke = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">int</span> port = channel.getLocalAddress().getPort();<br>    String path = inv.getAttachments().get(PATH_KEY);<br><br>    <span class="hljs-comment">// if it&#x27;s callback service on client side</span><br>    isStubServiceInvoke = Boolean.TRUE.toString().equals(inv.getAttachments().get(STUB_EVENT_KEY));<br>    <span class="hljs-keyword">if</span> (isStubServiceInvoke) &#123;<br>        port = channel.getRemoteAddress().getPort();<br>    &#125;<br><br>    <span class="hljs-comment">//callback</span><br>    isCallBackServiceInvoke = isClientSide(channel) &amp;&amp; !isStubServiceInvoke;<br>    <span class="hljs-keyword">if</span> (isCallBackServiceInvoke) &#123;<br>        path += <span class="hljs-string">&quot;.&quot;</span> + inv.getAttachments().get(CALLBACK_SERVICE_KEY);<br>        inv.getAttachments().put(IS_CALLBACK_SERVICE_INVOKE, Boolean.TRUE.toString());<br>    &#125;<br><br>    <span class="hljs-comment">// 计算 service key，格式为 groupName/serviceName:serviceVersion:port。比如： dubbo/com.alibaba.dubbo.demo.DemoService:1.0.0:20880</span><br>    String serviceKey = serviceKey(port, path, inv.getAttachments().get(VERSION_KEY), inv.getAttachments().get(GROUP_KEY));<br>    <span class="hljs-comment">// 从 exporterMap 查找与 serviceKey 相对应的 DubboExporter 对象，服务导出过程中会将 &lt;serviceKey, DubboExporter&gt; 映射关系存储到 exporterMap 集合中</span><br>    DubboExporter&lt;?&gt; exporter = (DubboExporter&lt;?&gt;) exporterMap.get(serviceKey);<br><br>    <span class="hljs-keyword">if</span> (exporter == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RemotingException(channel, <span class="hljs-string">&quot;Not found exported service: &quot;</span> + serviceKey + <span class="hljs-string">&quot; in &quot;</span> + exporterMap.keySet() + <span class="hljs-string">&quot;, may be version or group mismatch &quot;</span> +<br>                <span class="hljs-string">&quot;, channel: consumer: &quot;</span> + channel.getRemoteAddress() + <span class="hljs-string">&quot; --&gt; provider: &quot;</span> + channel.getLocalAddress() + <span class="hljs-string">&quot;, message:&quot;</span> + inv);<br>    &#125;<br><br>    <span class="hljs-comment">// 获取 Invoker 对象，并返回</span><br>    <span class="hljs-keyword">return</span> exporter.getInvoker();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>服务全部暴露完成之后保存到exporterMap中。这里就是通过serviceKey获取exporter之后获取Invoker，并通过 Invoker 的 invoke 方法调用服务逻辑， AbstractProxyInvoker 中的 invoke 逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">invoke</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> RpcException </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 调用 doInvoke 执行后续的调用，并将调用结果封装到 RpcResult 中，并</span><br>        Object value = doInvoke(proxy, invocation.getMethodName(), invocation.getParameterTypes(), invocation.getArguments());<br>        CompletableFuture&lt;Object&gt; future = wrapWithFuture(value, invocation);<br>        AsyncRpcResult asyncRpcResult = <span class="hljs-keyword">new</span> AsyncRpcResult(invocation);<br>        future.whenComplete((obj, t) -&gt; &#123;<br>            AppResponse result = <span class="hljs-keyword">new</span> AppResponse();<br>            <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (t <span class="hljs-keyword">instanceof</span> CompletionException) &#123;<br>                    result.setException(t.getCause());<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    result.setException(t);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                result.setValue(obj);<br>            &#125;<br>            asyncRpcResult.complete(result);<br>        &#125;);<br>        <span class="hljs-keyword">return</span> asyncRpcResult;<br>    &#125; <span class="hljs-keyword">catch</span> (InvocationTargetException e) &#123;<br>        <span class="hljs-keyword">if</span> (RpcContext.getContext().isAsyncStarted() &amp;&amp; !RpcContext.getContext().stopAsync()) &#123;<br>            logger.error(<span class="hljs-string">&quot;Provider async started, but got an exception from the original method, cannot write the exception back to consumer because an async result may have returned the new thread.&quot;</span>, e);<br>        &#125;<br>        <span class="hljs-keyword">return</span> AsyncRpcResult.newDefaultAsyncResult(<span class="hljs-keyword">null</span>, e.getTargetException(), invocation);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RpcException(<span class="hljs-string">&quot;Failed to invoke remote proxy method &quot;</span> + invocation.getMethodName() + <span class="hljs-string">&quot; to &quot;</span> + getUrl() + <span class="hljs-string">&quot;, cause: &quot;</span> + e.getMessage(), e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如上，doInvoke 是一个抽象方法，这个需要由具体的 Invoker 实例实现。Invoker 实例是在运行时通过JavassistProxyFactory 创建的，创建逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">Invoker&lt;T&gt; <span class="hljs-title">getInvoker</span><span class="hljs-params">(T proxy, Class&lt;T&gt; type, URL url)</span> </span>&#123;<br>    <span class="hljs-comment">// TODO Wrapper cannot handle this scenario correctly: the classname contains &#x27;$&#x27;</span><br>    <span class="hljs-comment">// 为目标类创建 wrapper</span><br>    <span class="hljs-keyword">final</span> Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf(<span class="hljs-string">&#x27;$&#x27;</span>) &lt; <span class="hljs-number">0</span> ? proxy.getClass() : type);<br>    <span class="hljs-comment">// 创建匿名 Invoker 类对象，并实现 doInvoker 方法</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AbstractProxyInvoker&lt;T&gt;(proxy, type, url) &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">doInvoke</span><span class="hljs-params">(T proxy, String methodName,</span></span><br><span class="hljs-function"><span class="hljs-params">                                  Class&lt;?&gt;[] parameterTypes,</span></span><br><span class="hljs-function"><span class="hljs-params">                                  Object[] arguments)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>            <span class="hljs-comment">// 调用 Wrapper 的 invokeMethod 方法，invokeMethod 最终会调用目标方法</span><br>            <span class="hljs-keyword">return</span> wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);<br>        &#125;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Wrapper 是一个抽象类，其中 invokeMethod 是一个抽象方法。Dubbo 会在运行时通过 Javassist 框架为 Wrapper 生成实现类，并实现 invokeMethod 方法，该方法最终会根据调用信息调用具体的服务。以 DemoServiceImpl 为例，Javassist 为其生成的代理类如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.apache.dubbo.demo.provider;<br><br><span class="hljs-keyword">import</span> org.apache.dubbo.common.bytecode.ClassGenerator;<br><span class="hljs-keyword">import</span> org.apache.dubbo.common.bytecode.Wrapper;<br><span class="hljs-keyword">import</span> org.apache.dubbo.demo.DemoService;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Wrapper0 是在运行时生成的，大家可使用 Arthas 进行反编译</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Wrapper0</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Wrapper</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ClassGenerator</span>.<span class="hljs-title">DC</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String[] pns;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Map pts;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String[] mns;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String[] dmns;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Class[] mts0; <span class="hljs-comment">// 省略其他方法</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invokeMethod</span><span class="hljs-params">(Object object, String string, Class[] arrclass, Object[] arrobject)</span> <span class="hljs-keyword">throws</span> InvocationTargetException </span>&#123;<br>        DemoService demoService;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 类型转换</span><br>            demoService = (DemoService) object;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable throwable) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(throwable);<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 根据方法名调用指定的方法</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;sayHello&quot;</span>.equals(string) &amp;&amp; arrclass.length == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">return</span> demoService.sayHello((String) arrobject[<span class="hljs-number">0</span>]);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable throwable) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvocationTargetException(throwable);<br>        &#125;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchMethodException(<span class="hljs-keyword">new</span> StringBuffer().append(<span class="hljs-string">&quot;Not found method \&quot;&quot;</span>)<br>                .append(string)<br>                .append(<span class="hljs-string">&quot;\&quot; in class com.alibaba.dubbo.demo.DemoService.&quot;</span>)<br>                .toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>到这里，整个服务调用过程就分析完了。最后把调用过程贴出来，如下：</p>
<figure class="highlight leaf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs leaf">ChannelEventRunnable<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">run</span><span class="hljs-params">()</span></span> <br>—&gt; DecodeHandler<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">received</span><span class="hljs-params">(<span class="hljs-variable">Channel</span>, <span class="hljs-variable">Object</span>)</span></span> <br>—&gt; HeaderExchangeHandler<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">received</span><span class="hljs-params">(<span class="hljs-variable">Channel</span>, <span class="hljs-variable">Object</span>)</span></span> <br>—&gt; HeaderExchangeHandler<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">handleRequest</span><span class="hljs-params">(<span class="hljs-variable">ExchangeChannel</span>, <span class="hljs-variable">Request</span>)</span></span> <br>—&gt; DubboProtocol.requestHandler<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">reply</span><span class="hljs-params">(<span class="hljs-variable">ExchangeChannel</span>, <span class="hljs-variable">Object</span>)</span></span> <br>—&gt; Filter<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">invoke</span><span class="hljs-params">(<span class="hljs-variable">Invoker</span>, <span class="hljs-variable">Invocation</span>)</span></span> <br>—&gt; AbstractProxyInvoker<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">invoke</span><span class="hljs-params">(<span class="hljs-variable">Invocation</span>)</span></span> <br>—&gt; Wrapper0<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">invokeMethod</span><span class="hljs-params">(<span class="hljs-variable">Object</span>, <span class="hljs-variable">String</span>, <span class="hljs-variable">Class</span>[], <span class="hljs-variable">Object</span>[])</span></span> <br>—&gt; DemoServiceImpl<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">sayHello</span><span class="hljs-params">(<span class="hljs-variable">String</span>)</span></span><br></code></pre></td></tr></table></figure>

<h5 id="提供方返回调用结果"><a href="#提供方返回调用结果" class="headerlink" title="提供方返回调用结果"></a>提供方返回调用结果</h5><p>服务提供方调用指定服务后，会将调用结果封装到 Response 对象中，并将该对象返回给服务消费方。服务提供方也是通过 NettyChannel 的 send 方法将 Response 对象返回，这里就不在重复分析了。本节关注 Response 对象的编码过程即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExchangeCodec</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TelnetCodec</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(Channel channel, ChannelBuffer buffer, Object msg)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">if</span> (msg <span class="hljs-keyword">instanceof</span> Request) &#123;<br>            <span class="hljs-comment">// 对 Request 对象进行编码</span><br>            encodeRequest(channel, buffer, (Request) msg);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (msg <span class="hljs-keyword">instanceof</span> Response) &#123;<br>            <span class="hljs-comment">// 对 Response 对象进行编码，后面分析</span><br>            encodeResponse(channel, buffer, (Response) msg);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">super</span>.encode(channel, buffer, msg);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encodeResponse</span><span class="hljs-params">(Channel channel, ChannelBuffer buffer, Response res)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">int</span> savedWriteIndex = buffer.writerIndex();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Serialization serialization = getSerialization(channel);<br>            <span class="hljs-comment">// header.</span><br>            <span class="hljs-comment">// 创建消息头字节数组</span><br>            <span class="hljs-keyword">byte</span>[] header = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[HEADER_LENGTH];<br>            <span class="hljs-comment">// set magic number.</span><br>            <span class="hljs-comment">// 设置魔数</span><br>            Bytes.short2bytes(MAGIC, header);<br>            <span class="hljs-comment">// set request and serialization flag.</span><br>            <span class="hljs-comment">// 设置序列化器编号</span><br>            header[<span class="hljs-number">2</span>] = serialization.getContentTypeId();<br>            <span class="hljs-keyword">if</span> (res.isHeartbeat()) &#123;<br>                header[<span class="hljs-number">2</span>] |= FLAG_EVENT;<br>            &#125;<br>            <span class="hljs-comment">// set response status.</span><br>            <span class="hljs-comment">// 获取响应状态</span><br>            <span class="hljs-keyword">byte</span> status = res.getStatus();<br>            <span class="hljs-comment">// 设置响应状态</span><br>            header[<span class="hljs-number">3</span>] = status;<br>            <span class="hljs-comment">// set request id.</span><br>            <span class="hljs-comment">// 设置请求编号</span><br>            Bytes.long2bytes(res.getId(), header, <span class="hljs-number">4</span>);<br><br>            <span class="hljs-comment">// 更新 writerIndex，为消息头预留 16 个字节的空间</span><br>            buffer.writerIndex(savedWriteIndex + HEADER_LENGTH);<br>            ChannelBufferOutputStream bos = <span class="hljs-keyword">new</span> ChannelBufferOutputStream(buffer);<br>            ObjectOutput out = serialization.serialize(channel.getUrl(), bos);<br>            <span class="hljs-comment">// encode response data or error message.</span><br>            <span class="hljs-keyword">if</span> (status == Response.OK) &#123;<br>                <span class="hljs-keyword">if</span> (res.isHeartbeat()) &#123;<br>                    <span class="hljs-comment">// 对心跳响应结果进行序列化，已废弃</span><br>                    encodeHeartbeatData(channel, out, res.getResult());<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 对调用结果进行序列化</span><br>                    encodeResponseData(channel, out, res.getResult(), res.getVersion());<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 对错误信息进行序列化</span><br>                out.writeUTF(res.getErrorMessage());<br>            &#125;<br>            out.flushBuffer();<br>            <span class="hljs-keyword">if</span> (out <span class="hljs-keyword">instanceof</span> Cleanable) &#123;<br>                ((Cleanable) out).cleanup();<br>            &#125;<br>            bos.flush();<br>            bos.close();<br><br>            <span class="hljs-comment">// 获取写入的字节数，也就是消息体长度</span><br>            <span class="hljs-keyword">int</span> len = bos.writtenBytes();<br>            checkPayload(channel, len);<br>            <span class="hljs-comment">// 将消息体长度写入到消息头中</span><br>            Bytes.int2bytes(len, header, <span class="hljs-number">12</span>);<br>            <span class="hljs-comment">// write</span><br>            <span class="hljs-comment">// 将 buffer 指针移动到 savedWriteIndex，为写消息头做准备</span><br>            buffer.writerIndex(savedWriteIndex);<br>            <span class="hljs-comment">// 从 savedWriteIndex 下标处写入消息头</span><br>            buffer.writeBytes(header); <span class="hljs-comment">// write header.</span><br>            <span class="hljs-comment">// 设置新的 writerIndex，writerIndex = 原写下标 + 消息头长度 + 消息体长度</span><br>            buffer.writerIndex(savedWriteIndex + HEADER_LENGTH + len);<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            <span class="hljs-comment">// clear buffer</span><br>            buffer.writerIndex(savedWriteIndex);<br>            <span class="hljs-comment">// send error message to Consumer, otherwise, Consumer will wait till timeout.</span><br>            <span class="hljs-keyword">if</span> (!res.isEvent() &amp;&amp; res.getStatus() != Response.BAD_RESPONSE) &#123;<br>                Response r = <span class="hljs-keyword">new</span> Response(res.getId(), res.getVersion());<br>                r.setStatus(Response.BAD_RESPONSE);<br><br>                <span class="hljs-keyword">if</span> (t <span class="hljs-keyword">instanceof</span> ExceedPayloadLimitException) &#123;<br>                    logger.warn(t.getMessage(), t);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        r.setErrorMessage(t.getMessage());<br>                        channel.send(r);<br>                        <span class="hljs-keyword">return</span>;<br>                    &#125; <span class="hljs-keyword">catch</span> (RemotingException e) &#123;<br>                        logger.warn(<span class="hljs-string">&quot;Failed to send bad_response info back: &quot;</span> + t.getMessage() + <span class="hljs-string">&quot;, cause: &quot;</span> + e.getMessage(), e);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// FIXME log error message in Codec and handle in caught() of IoHanndler?</span><br>                    logger.warn(<span class="hljs-string">&quot;Fail to encode response: &quot;</span> + res + <span class="hljs-string">&quot;, send bad_response info instead, cause: &quot;</span> + t.getMessage(), t);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        r.setErrorMessage(<span class="hljs-string">&quot;Failed to send response: &quot;</span> + res + <span class="hljs-string">&quot;, cause: &quot;</span> + StringUtils.toString(t));<br>                        channel.send(r);<br>                        <span class="hljs-keyword">return</span>;<br>                    &#125; <span class="hljs-keyword">catch</span> (RemotingException e) &#123;<br>                        logger.warn(<span class="hljs-string">&quot;Failed to send bad_response info back: &quot;</span> + res + <span class="hljs-string">&quot;, cause: &quot;</span> + e.getMessage(), e);<br>                    &#125;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">// Rethrow exception</span><br>            <span class="hljs-keyword">if</span> (t <span class="hljs-keyword">instanceof</span> IOException) &#123;<br>                <span class="hljs-keyword">throw</span> (IOException) t;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t <span class="hljs-keyword">instanceof</span> RuntimeException) &#123;<br>                <span class="hljs-keyword">throw</span> (RuntimeException) t;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t <span class="hljs-keyword">instanceof</span> Error) &#123;<br>                <span class="hljs-keyword">throw</span> (Error) t;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(t.getMessage(), t);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DubboCodec</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ExchangeCodec</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encodeResponseData</span><span class="hljs-params">(Channel channel, ObjectOutput out, Object data, String version)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        Result result = (Result) data;<br>        <span class="hljs-comment">// currently, the version value in Response records the version of Request</span><br>        <span class="hljs-comment">// 检测当前协议版本是否支持带有 attachment 集合的 Response 对象</span><br>        <span class="hljs-keyword">boolean</span> attach = Version.isSupportResponseAttachment(version);<br>        Throwable th = result.getException();<br>        <span class="hljs-comment">// 异常信息为空</span><br>        <span class="hljs-keyword">if</span> (th == <span class="hljs-keyword">null</span>) &#123;<br>            Object ret = result.getValue();<br>            <span class="hljs-comment">// 调用结果为空</span><br>            <span class="hljs-keyword">if</span> (ret == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// 序列化响应类型</span><br>                out.writeByte(attach ? RESPONSE_NULL_VALUE_WITH_ATTACHMENTS : RESPONSE_NULL_VALUE);<br>            <span class="hljs-comment">// 调用结果非空</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 序列化响应类型</span><br>                out.writeByte(attach ? RESPONSE_VALUE_WITH_ATTACHMENTS : RESPONSE_VALUE);<br>                <span class="hljs-comment">// 序列化调用结果</span><br>                out.writeObject(ret);<br>            &#125;<br>        <span class="hljs-comment">// 异常信息非空</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 序列化响应类型</span><br>            out.writeByte(attach ? RESPONSE_WITH_EXCEPTION_WITH_ATTACHMENTS : RESPONSE_WITH_EXCEPTION);<br>            <span class="hljs-comment">// 序列化异常对象</span><br>            out.writeObject(th);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (attach) &#123;<br>            <span class="hljs-comment">// returns current version of Response to consumer side.</span><br>            <span class="hljs-comment">// 记录 Dubbo 协议版本</span><br>            result.getAttachments().put(DUBBO_VERSION_KEY, Version.getProtocolVersion());<br>            <span class="hljs-comment">// 序列化 attachments 集合</span><br>            out.writeObject(result.getAttachments());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>以上就是 Response 对象编码的过程，和前面分析的 Request 对象编码过程很相似。</p>
<h5 id="消费方接收调用结果"><a href="#消费方接收调用结果" class="headerlink" title="消费方接收调用结果"></a>消费方接收调用结果</h5><p>服务消费方在收到响应数据后，首先要做的事情是对响应数据进行解码，得到 Response 对象。然后再将该对象传递给下一个入站处理器，这个入站处理器就是 NettyHandler。接下来 NettyHandler 会将这个对象继续向下传递，最后 AllChannelHandler 的 received 方法会收到这个对象，并将这个对象派发到线程池中。这个过程和服务提供方接收请求的过程是一样的，因此这里就不重复分析了。</p>
<h6 id="响应数据解码"><a href="#响应数据解码" class="headerlink" title="响应数据解码"></a>响应数据解码</h6><p>响应数据解码逻辑主要的逻辑封装在 DubboCodec 中，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">decodeBody</span><span class="hljs-params">(Channel channel, InputStream is, <span class="hljs-keyword">byte</span>[] header)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">// 获取消息头中的第三个字节，并通过逻辑与运算得到序列化器编号</span><br>    <span class="hljs-keyword">byte</span> flag = header[<span class="hljs-number">2</span>], proto = (<span class="hljs-keyword">byte</span>) (flag &amp; SERIALIZATION_MASK);<br>    <span class="hljs-comment">// get request id.</span><br>    <span class="hljs-comment">// 获取调用编号</span><br>    <span class="hljs-keyword">long</span> id = Bytes.bytes2long(header, <span class="hljs-number">4</span>);<br>    <span class="hljs-comment">// 通过逻辑与运算得到调用类型，0 - Response，1 - Request</span><br>    <span class="hljs-keyword">if</span> ((flag &amp; FLAG_REQUEST) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 对响应结果进行解码，得到 Response 对象。</span><br>        <span class="hljs-comment">// decode response.</span><br>        Response res = <span class="hljs-keyword">new</span> Response(id);<br>        <span class="hljs-comment">// 检测事件标志位</span><br>        <span class="hljs-keyword">if</span> ((flag &amp; FLAG_EVENT) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 设置心跳事件</span><br>            res.setEvent(<span class="hljs-keyword">true</span>);<br>        &#125;<br>        <span class="hljs-comment">// get status.</span><br>        <span class="hljs-comment">// 获取响应状态</span><br>        <span class="hljs-keyword">byte</span> status = header[<span class="hljs-number">3</span>];<br>        <span class="hljs-comment">// 设置响应状态</span><br>        res.setStatus(status);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 如果响应状态为 OK，表明调用过程正常</span><br>            <span class="hljs-keyword">if</span> (status == Response.OK) &#123;<br>                Object data;<br>                <span class="hljs-keyword">if</span> (res.isHeartbeat()) &#123;<br>                    ObjectInput in = CodecSupport.deserialize(channel.getUrl(), is, proto);<br>                    <span class="hljs-comment">// 反序列化心跳数据，已废弃</span><br>                    data = decodeHeartbeatData(channel, in);<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res.isEvent()) &#123;<br>                    ObjectInput in = CodecSupport.deserialize(channel.getUrl(), is, proto);<br>                    <span class="hljs-comment">// 反序列化事件数据</span><br>                    data = decodeEventData(channel, in);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    DecodeableRpcResult result;<br>                    <span class="hljs-comment">// 根据 url 参数决定是否在 IO 线程上执行解码逻辑</span><br>                    <span class="hljs-keyword">if</span> (channel.getUrl().getParameter(DECODE_IN_IO_THREAD_KEY, DEFAULT_DECODE_IN_IO_THREAD)) &#123;<br>                        <span class="hljs-comment">// 创建 DecodeableRpcResult 对象</span><br>                        result = <span class="hljs-keyword">new</span> DecodeableRpcResult(channel, res, is,<br>                                (Invocation) getRequestData(id), proto);<br>                        <span class="hljs-comment">// 进行后续的解码工作</span><br>                        result.decode();<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-comment">// 创建 DecodeableRpcResult 对象</span><br>                        result = <span class="hljs-keyword">new</span> DecodeableRpcResult(channel, res,<br>                                <span class="hljs-keyword">new</span> UnsafeByteArrayInputStream(readMessageData(is)),<br>                                (Invocation) getRequestData(id), proto);<br>                    &#125;<br>                    data = result;<br>                &#125;<br>                <span class="hljs-comment">// 设置 DecodeableRpcResult 对象到 Response 对象中</span><br>                res.setResult(data);<br>            <span class="hljs-comment">// 响应状态非 OK，表明调用过程出现了异常</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 反序列化异常信息，并设置到 Response 对象中</span><br>                ObjectInput in = CodecSupport.deserialize(channel.getUrl(), is, proto);<br>                res.setErrorMessage(in.readUTF());<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            <span class="hljs-comment">// 解码过程中出现了错误，此时设置 CLIENT_ERROR 状态码到 Response 对象中</span><br>            <span class="hljs-keyword">if</span> (log.isWarnEnabled()) &#123;<br>                log.warn(<span class="hljs-string">&quot;Decode response failed: &quot;</span> + t.getMessage(), t);<br>            &#125;<br>            res.setStatus(Response.CLIENT_ERROR);<br>            res.setErrorMessage(StringUtils.toString(t));<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// decode request.</span><br>        <span class="hljs-comment">// 创建 Request 对象</span><br>        Request req = <span class="hljs-keyword">new</span> Request(id);<br>        req.setVersion(Version.getProtocolVersion());<br>        <span class="hljs-comment">// 通过逻辑与运算得到通信方式，并设置到 Request 对象中</span><br>        req.setTwoWay((flag &amp; FLAG_TWOWAY) != <span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 通过位运算检测数据包是否为事件类型</span><br>        <span class="hljs-keyword">if</span> ((flag &amp; FLAG_EVENT) != <span class="hljs-number">0</span>) &#123;<br>            req.setEvent(<span class="hljs-keyword">true</span>);<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Object data;<br>            ObjectInput in = CodecSupport.deserialize(channel.getUrl(), is, proto);<br>            <span class="hljs-keyword">if</span> (req.isHeartbeat()) &#123;<br>                <span class="hljs-comment">// 对心跳包进行解码，该方法已被标注为废弃</span><br>                data = decodeHeartbeatData(channel, in);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (req.isEvent()) &#123;<br>                <span class="hljs-comment">// 对事件数据进行解码</span><br>                data = decodeEventData(channel, in);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                DecodeableRpcInvocation inv;<br>                <span class="hljs-comment">// 根据 url 参数判断是否在 IO 线程上对消息体进行解码</span><br>                <span class="hljs-keyword">if</span> (channel.getUrl().getParameter(DECODE_IN_IO_THREAD_KEY, DEFAULT_DECODE_IN_IO_THREAD)) &#123;<br>                    inv = <span class="hljs-keyword">new</span> DecodeableRpcInvocation(channel, req, is, proto);<br>                    <span class="hljs-comment">// 在当前线程，也就是 IO 线程上进行后续的解码工作。此工作完成后， 可将调用方法名、attachment、以及调用参数解析出来</span><br>                    inv.decode();<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 仅创建 DecodeableRpcInvocation 对象，但不在当前线程上执行解 码逻辑</span><br>                    inv = <span class="hljs-keyword">new</span> DecodeableRpcInvocation(channel, req,<br>                            <span class="hljs-keyword">new</span> UnsafeByteArrayInputStream(readMessageData(is)), proto);<br>                &#125;<br>                data = inv;<br>            &#125;<br>            <span class="hljs-comment">// 设置 data 到 Request 对象中</span><br>            req.setData(data);<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            <span class="hljs-keyword">if</span> (log.isWarnEnabled()) &#123;<br>                log.warn(<span class="hljs-string">&quot;Decode request failed: &quot;</span> + t.getMessage(), t);<br>            &#125;<br>            <span class="hljs-comment">// bad request</span><br>            <span class="hljs-comment">// 若解码过程中出现异常，则将 broken 字段设为 true，并将异常对象设置到 Request 对象中</span><br>            req.setBroken(<span class="hljs-keyword">true</span>);<br>            req.setData(t);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> req;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>以上就是响应数据的解码过程，上面逻辑与前面章节分析过 DubboCodec 的 decodeBody 方法中关于请求数据的解码过程很相似。下面，继续分析调用结果的反序列化过程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">decode</span><span class="hljs-params">(Channel channel, InputStream input)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    ObjectInput in = CodecSupport.getSerialization(channel.getUrl(), serializationType)<br>            .deserialize(channel.getUrl(), input);<br><br>    <span class="hljs-comment">// 反序列化响应类型</span><br>    <span class="hljs-keyword">byte</span> flag = in.readByte();<br>    <span class="hljs-keyword">switch</span> (flag) &#123;<br>        <span class="hljs-keyword">case</span> DubboCodec.RESPONSE_NULL_VALUE:<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> DubboCodec.RESPONSE_VALUE:<br>            handleValue(in);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> DubboCodec.RESPONSE_WITH_EXCEPTION:<br>            handleException(in);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> DubboCodec.RESPONSE_NULL_VALUE_WITH_ATTACHMENTS:<br>            <span class="hljs-comment">// 返回值为空，且携带了 attachments 集合</span><br>            handleAttachment(in);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> DubboCodec.RESPONSE_VALUE_WITH_ATTACHMENTS:<br>            <span class="hljs-comment">// 返回值不为空，且携带了 attachments 集合</span><br>            handleValue(in);<br>            handleAttachment(in);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> DubboCodec.RESPONSE_WITH_EXCEPTION_WITH_ATTACHMENTS:<br>            <span class="hljs-comment">// 异常对象不为空，且携带了 attachments 集合</span><br>            handleException(in);<br>            handleAttachment(in);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">&quot;Unknown result flag, expect &#x27;0&#x27; &#x27;1&#x27; &#x27;2&#x27; &#x27;3&#x27; &#x27;4&#x27; &#x27;5&#x27;, but received: &quot;</span> + flag);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (in <span class="hljs-keyword">instanceof</span> Cleanable) &#123;<br>        ((Cleanable) in).cleanup();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>正常调用下，线程会进入 RESPONSE_VALUE_WITH_ATTACHMENTS 分支中。然后线程会从 invocation变量（大家探索一下 invocation 变量的由来）中获取返回值类型，接着对调用结果进行反序列化，并将序列化后的结果存储起来。最后对 attachments 集合进行反序列化，并存到指定字段中</p>
<h5 id="异步转同步"><a href="#异步转同步" class="headerlink" title="异步转同步"></a>异步转同步</h5><p>Dubbo发送数据至服务方后，在通信层面是异步的，通信线程并不会等待结果数据返回。而我们在使用Dubbo进行RPC调用缺省就是同步的，这其中就涉及到了异步转同步的操作。</p>
<p>而在2.7.x版本中，这种自实现的异步转同步操作进行了修改。新的 DefaultFuture 继承了CompletableFuture ，新的 doReceived(Response res) 方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doReceived</span><span class="hljs-params">(Response res)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (res == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;response cannot be null&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (res.getStatus() == Response.OK) &#123;<br>        <span class="hljs-keyword">this</span>.complete(res.getResult());<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res.getStatus() == Response.CLIENT_TIMEOUT || res.getStatus() == Response.SERVER_TIMEOUT) &#123;<br>        <span class="hljs-keyword">this</span>.completeExceptionally(<span class="hljs-keyword">new</span> TimeoutException(res.getStatus() == Response.SERVER_TIMEOUT, channel, res.getErrorMessage()));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">this</span>.completeExceptionally(<span class="hljs-keyword">new</span> RemotingException(channel, res.getErrorMessage()));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过 CompletableFuture#complete 方法来设置异步的返回结果，且删除旧的 get() 方法，使用CompletableFuture#get() 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span></span><br><span class="hljs-function">    <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;<br>    Object r;<br>    <span class="hljs-keyword">long</span> nanos = unit.toNanos(timeout);<br>    <span class="hljs-keyword">return</span> reportGet((r = result) == <span class="hljs-keyword">null</span> ? timedGet(nanos) : r);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>异步转同步操作在AsyncToSyncInvoker.invoker()方法中完成，该类会在ProtocolFilterWrapper中进行构建并由ClusterInvoker调用，主要逻辑为使用 CompletableFuture 的get方法完成异步转同步的操作。</p>
<h5 id="异步多线程数据一致"><a href="#异步多线程数据一致" class="headerlink" title="异步多线程数据一致"></a>异步多线程数据一致</h5><p>一般情况下，服务消费方会并发调用多个服务，每个用户线程发送请求后，会调用get 方法进行等待。 一段时间后，服务消费方的线程池会收到多个响应对象。这个时候要考虑一个问题，如何将每个响应对象传递给相应的 Future 对象，不出错。答案是通过调用<strong>编号</strong>。Future 被创建时，会要求传入一个 Request 对象。此时 DefaultFuture 可从 Request 对象中获取调用编号，并将 &lt;调用编号, DefaultFuture 对象&gt; 映射关系存入到静态 Map 中，即 FUTURES。线程池中的线程在收到Response 对象后，会根据 Response 对象中的调用编号到 FUTURES 集合中取出相应的 DefaultFuture对象，然后再将 Response 对象设置到 DefaultFuture 对象中。这样用户线程即可从 DefaultFuture 对象中获取调用结果了。整个过程大致如下图：</p>
<p><img src="/blog/2021/04/27/Dubbo/dubbo%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/pic20.png" srcset="/blog/img/loading.gif" lazyload></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">DefaultFuture</span><span class="hljs-params">(Channel channel, Request request, <span class="hljs-keyword">int</span> timeout)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.channel = channel;<br>    <span class="hljs-keyword">this</span>.request = request;<br>    <span class="hljs-keyword">this</span>.id = request.getId();<br>    <span class="hljs-keyword">this</span>.timeout = timeout &gt; <span class="hljs-number">0</span> ? timeout : channel.getUrl().getPositiveParameter(TIMEOUT_KEY, DEFAULT_TIMEOUT);<br>    <span class="hljs-comment">// put into waiting map.</span><br>    FUTURES.put(id, <span class="hljs-keyword">this</span>);<br>    CHANNELS.put(id, channel);<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="心跳检查"><a href="#心跳检查" class="headerlink" title="心跳检查"></a>心跳检查</h5><p>Dubbo采用双向心跳的方式检测Client端与Server端的连通性，客户端会给服务端发送心跳，反之，服务端也会向客户端发送心跳。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeaderExchangeClient</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ExchangeClient</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Client client;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ExchangeChannel channel;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> HashedWheelTimer IDLE_CHECK_TIMER = <span class="hljs-keyword">new</span> HashedWheelTimer(<br>            <span class="hljs-keyword">new</span> NamedThreadFactory(<span class="hljs-string">&quot;dubbo-client-idleCheck&quot;</span>, <span class="hljs-keyword">true</span>), <span class="hljs-number">1</span>, TimeUnit.SECONDS, TICKS_PER_WHEEL);<br>    <span class="hljs-keyword">private</span> HeartbeatTimerTask heartBeatTimerTask;<br>    <span class="hljs-keyword">private</span> ReconnectTimerTask reconnectTimerTask;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HeaderExchangeClient</span><span class="hljs-params">(Client client, <span class="hljs-keyword">boolean</span> startTimer)</span> </span>&#123;<br>        Assert.notNull(client, <span class="hljs-string">&quot;Client can&#x27;t be null&quot;</span>);<br>        <span class="hljs-keyword">this</span>.client = client;<br>        <span class="hljs-keyword">this</span>.channel = <span class="hljs-keyword">new</span> HeaderExchangeChannel(client);<br><br>        <span class="hljs-keyword">if</span> (startTimer) &#123;<br>            URL url = client.getUrl();<br>            <span class="hljs-comment">//开启心跳失败之后处理重连，断连的逻辑定时任务</span><br>            startReconnectTask(url);<br>            <span class="hljs-comment">//开启发送心跳请求定时任务</span><br>            startHeartBeatTask(url);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// ...略</span><br></code></pre></td></tr></table></figure>

<p>Dubbo 在 HeaderExchangeClient 初始化时开启了两个定时任务</p>
<ul>
<li><p>startReconnectTask 主要用于定时发送心跳请求</p>
</li>
<li><p>startHeartBeatTask 主要用于心跳失败之后处理重连，断连的逻辑</p>
</li>
</ul>
<h6 id="发送心跳请求"><a href="#发送心跳请求" class="headerlink" title="发送心跳请求"></a>发送心跳请求</h6><p>详细解析下心跳检测定时任务的逻辑 HeartbeatTimerTask#doTask ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doTask</span><span class="hljs-params">(Channel channel)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Long lastRead = lastRead(channel);<br>        Long lastWrite = lastWrite(channel);<br>        <span class="hljs-keyword">if</span> ((lastRead != <span class="hljs-keyword">null</span> &amp;&amp; now() - lastRead &gt; heartbeat)<br>                || (lastWrite != <span class="hljs-keyword">null</span> &amp;&amp; now() - lastWrite &gt; heartbeat)) &#123;<br>            Request req = <span class="hljs-keyword">new</span> Request();<br>            req.setVersion(Version.getProtocolVersion());<br>            req.setTwoWay(<span class="hljs-keyword">true</span>);<br>            req.setEvent(Request.HEARTBEAT_EVENT);<br>            channel.send(req);<br>            <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>                logger.debug(<span class="hljs-string">&quot;Send heartbeat to remote channel &quot;</span> + channel.getRemoteAddress()<br>                        + <span class="hljs-string">&quot;, cause: The channel has no data-transmission exceeds a heartbeat period: &quot;</span><br>                        + heartbeat + <span class="hljs-string">&quot;ms&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        logger.warn(<span class="hljs-string">&quot;Exception when heartbeat to remote channel &quot;</span> + channel.getRemoteAddress(), t);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>前面已经介绍过，<strong>Dubbo</strong> <strong>采取的是双向心跳设计</strong>，即服务端会向客户端发送心跳，客户端也会向服务端发送心跳，接收的一方更新 lastRead 字段，发送的一方更新 lastWrite 字段，超过心跳间隙的时间，便发送心跳请求给对端。这里的 lastRead/lastWrite 同样会被同一个通道上的普通调用更新，通过更新这两个字段，实现了只在连接空闲时才会真正发送空闲报文的机制，符合我们一开始科普的做法。</p>
<h6 id="处理重连和断连"><a href="#处理重连和断连" class="headerlink" title="处理重连和断连"></a>处理重连和断连</h6><p>继续研究下重连和断连定时器都实现了什么 ReconnectTimerTask#doTask 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doTask</span><span class="hljs-params">(Channel channel)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Long lastRead = lastRead(channel);<br>        Long now = now();<br><br>        <span class="hljs-comment">// Rely on reconnect timer to reconnect when AbstractClient.doConnect fails to init the connection</span><br>        <span class="hljs-keyword">if</span> (!channel.isConnected()) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                logger.info(<span class="hljs-string">&quot;Initial connection to &quot;</span> + channel);<br>                ((Client) channel).reconnect();<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                logger.error(<span class="hljs-string">&quot;Fail to connect to &quot;</span> + channel, e);<br>            &#125;<br>        <span class="hljs-comment">// check pong at client</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (lastRead != <span class="hljs-keyword">null</span> &amp;&amp; now - lastRead &gt; idleTimeout) &#123;<br>            logger.warn(<span class="hljs-string">&quot;Reconnect to channel &quot;</span> + channel + <span class="hljs-string">&quot;, because heartbeat read idle time out: &quot;</span><br>                    + idleTimeout + <span class="hljs-string">&quot;ms&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                ((Client) channel).reconnect();<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                logger.error(channel + <span class="hljs-string">&quot;reconnect failed during idle time.&quot;</span>, e);<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        logger.warn(<span class="hljs-string">&quot;Exception when reconnect to remote channel &quot;</span> + channel.getRemoteAddress(), t);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>第二个定时器则负责根据客户端、服务端类型来对连接做不同的处理，当超过设置的心跳总时间之后，客户端选择的是重新连接，服务端则是选择直接断开连接。这样的考虑是合理的，客户端调用是强依赖可用连接的，而服务端可以等待客户端重新建立连接。</p>
<p>Dubbo 对于建立的每一个连接，同时在客户端和服务端开启了 2 个定时器，一个用于定时发送心跳，一个用于定时重连、断连，执行的频率均为各自检测周期的 1/3。定时发送心跳的任务负责在连接空闲时，向对端发送心跳包。定时重连、断连的任务负责检测 lastRead 是否在超时周期内仍未被更新，如果判定为超时，客户端处理的逻辑是重连，服务端则采取断连的措施。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/blog/categories/Dubbo/" class="category-chain-item">Dubbo</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/blog/tags/dubbo/">#dubbo</a>
      
        <a href="/blog/tags/%E6%BA%90%E7%A0%81/">#源码</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Dubbo源码剖析</div>
      <div>http://zhaoguocheng.gitee.io/2021/04/27/Dubbo/dubbo源码剖析/</div>
    </div>
    <div class="license-meta">
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2021年4月27日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/blog/2021/05/21/Mybatis/mybatis%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" title="mybatis源码剖析">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">mybatis源码剖析</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/blog/2021/01/19/Zookeeper/Zookeeper%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8B/" title="Zookeeper源码分析下">
                        <span class="hidden-mobile">Zookeeper源码分析下</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/blog/js/events.js" ></script>
<script  src="/blog/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/blog/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/blog/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/blog/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
