

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/blog/img/favicon.png">
  <link rel="icon" href="/blog/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="">
  <meta name="keywords" content="">
  
  <title>Zookeeper源码分析下 - 萤火的博客</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/blog/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.1.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/blog/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"zhaoguocheng.gitee.io","root":"/blog/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":200}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/blog/js/utils.js" ></script>
  <script  src="/blog/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/blog/">&nbsp;<strong>萤火的博客</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/">
                <i class="iconfont icon-home-fill"></i>
                主页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/blog/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Zookeeper源码分析下">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-01-19 18:03" pubdate>
        2021年1月19日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      17.2k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      266
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Zookeeper源码分析下</h1>
            
            <div class="markdown-body">
              <h3 id="Session源码分析"><a href="#Session源码分析" class="headerlink" title="Session源码分析"></a>Session源码分析</h3><p>客户端创建 Socket 连接后，会尝试连接服务端，如果连接成功会调用到 primeConnection 方法用来发送 ConnectRequest 连接请求，开始设置 session 会话 。</p>
<h4 id="服务端Session属性分析"><a href="#服务端Session属性分析" class="headerlink" title="服务端Session属性分析"></a>服务端Session属性分析</h4><p>Zookeeper服务端会话操作如下图：</p>
<p><img src="/blog/2021/01/19/Zookeeper/Zookeeper%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8B/pic1.png" srcset="/blog/img/loading.gif" lazyload></p>
<p>在服务端通过 SessionTrackerImpl 和 ExpiryQueue 来保存Session会话信息。</p>
<p>SessionTrackerImpl 有以下属性：</p>
<ul>
<li>sessionsById：用来存储ConcurrentHashMap&lt;Long, SessionImpl&gt; {sessionId:SessionImpl} </li>
<li>sessionExpiryQueue：ExpiryQueue&lt;SessionImpl&gt;失效队列 </li>
<li>sessionsWithTimeout：ConcurrentMap&lt;Long, Integer&gt;存储的是{sessionId: sessionTimeout} </li>
<li>nextSessionId：下一个sessionId </li>
</ul>
<p>ExpiryQueue 失效队列有以下属性：</p>
<ul>
<li><p>elemMap：ConcurrentHashMap&lt;E, Long&gt; 存储的是{SessionImpl: newExpiryTime} Session 实例对象，失效时间。 </p>
</li>
<li><p>expiryMap：ConcurrentHashMap&lt;Long, Set&lt;E&gt;&gt;存储的是{time: set&lt;SessionImp&gt;} 失效时间，当前失效时间的Session对象集合。 </p>
</li>
<li><p>nextExpirationTime：下一次失效时间 {(System.nanoTime() / 1000000)/expirationInterval+1}*expirationInterval 当前系统时间毫秒值 ms=System.nanoTime() / 1000000。 nextExpirationTime=当前系统时间毫秒值 +expirationInterval(失效间隔)。 </p>
</li>
<li><p>expirationInterval：失效间隔，默认是10s，可以通过sessionlessCnxnTimeout修改。即是通过配置文件的tickTime修改。</p>
</li>
</ul>
<h4 id="Session创建"><a href="#Session创建" class="headerlink" title="Session创建"></a>Session创建</h4><p>在之前对 NIOServerCnxnFactory 源码的分析中，SelectorThread 从 Socket 读取数据后会将数据封装成 workRequest ，交给 workerPool 工作线程池处理，调用链为：SelectorThread.run() -&gt; SelectorThread.select() -&gt; SelectorThread.handleIO() -&gt; WorkerThread.schedule() -&gt; ScheduledWorkRequest.run() -&gt; IOWorkRequest.doWork() -&gt; NIOServerCnxn.doIO() -&gt; NIOServerCnxn.readPayload()</p>
<p>在 NIOServerCnxn.readPayload() 中会对第一次连接进行相应的处理， 源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readPayload</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException, ClientCnxnLimitException </span>&#123;<br>    <span class="hljs-keyword">if</span> (incomingBuffer.remaining() != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// have we read length bytes?</span><br>        <span class="hljs-keyword">int</span> rc = sock.read(incomingBuffer); <span class="hljs-comment">// sock is non-blocking, so ok</span><br>        <span class="hljs-keyword">if</span> (rc &lt; <span class="hljs-number">0</span>) &#123;<br>            handleFailedRead();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (incomingBuffer.remaining() == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// have we read length bytes?</span><br>        incomingBuffer.flip();<br>        packetReceived(<span class="hljs-number">4</span> + incomingBuffer.remaining());<br>        <span class="hljs-comment">// 此时如果initialized=false，表示第一次连接，需要创建Session(createSession)</span><br>        <span class="hljs-comment">// 调用readConnectRequest()后，在readConnectRequest()方法中会将initialized设置为true</span><br>        <span class="hljs-keyword">if</span> (!initialized) &#123;<br>            readConnectRequest();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            readRequest();<br>        &#125;<br>        lenBuffer.clear();<br>        incomingBuffer = lenBuffer;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>此时如果 initialized=false ，表示第一次连接 需要创建 Session(createSession) ，此处调用readConnectRequest()后，在readConnectRequest()方法中会将initialized设置为true，只有在处理完连接请求之后才会把initialized设置为true，才可以处理客户端其他命令。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readConnectRequest</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException, ClientCnxnLimitException </span>&#123;<br>    <span class="hljs-keyword">if</span> (!isZKServerRunning()) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">&quot;ZooKeeperServer not running&quot;</span>);<br>    &#125;<br>    zkServer.processConnectRequest(<span class="hljs-keyword">this</span>, incomingBuffer);<br>    initialized = <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面方法还调用了 processConnectRequest 处理连接请求，processConnectRequest 第一次从请求中获取的 sessionId=0，此时会把创建Session作为一个业务，会调用 createSession() 方法，processConnectRequest 方法部分关键代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processConnectRequest</span><span class="hljs-params">(ServerCnxn cnxn, ByteBuffer incomingBuffer)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> IOException, ClientCnxnLimitException </span>&#123;<br><br>    <span class="hljs-comment">// 省略部分代码...</span><br>    <span class="hljs-comment">// sessionId=0时，需要创建Session</span><br>    <span class="hljs-keyword">if</span> (sessionId == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 创建Session，第一次请求会作为一个业务提交</span><br>        <span class="hljs-keyword">long</span> id = createSession(cnxn, passwd, sessionTimeout);<br>        LOG.debug(<br>                <span class="hljs-string">&quot;Client attempting to establish new session: session = 0x&#123;&#125;, zxid = 0x&#123;&#125;, timeout = &#123;&#125;, address = &#123;&#125;&quot;</span>,<br>                Long.toHexString(id),<br>                Long.toHexString(connReq.getLastZxidSeen()),<br>                connReq.getTimeOut(),<br>                cnxn.getRemoteSocketAddress());<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        validateSession(cnxn, sessionId);<br>        LOG.debug(<br>                <span class="hljs-string">&quot;Client attempting to renew session: session = 0x&#123;&#125;, zxid = 0x&#123;&#125;, timeout = &#123;&#125;, address = &#123;&#125;&quot;</span>,<br>                Long.toHexString(sessionId),<br>                Long.toHexString(connReq.getLastZxidSeen()),<br>                connReq.getTimeOut(),<br>                cnxn.getRemoteSocketAddress());<br>        <span class="hljs-keyword">if</span> (serverCnxnFactory != <span class="hljs-keyword">null</span>) &#123;<br>            serverCnxnFactory.closeSession(sessionId, ServerCnxn.DisconnectReason.CLIENT_RECONNECT);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (secureServerCnxnFactory != <span class="hljs-keyword">null</span>) &#123;<br>            secureServerCnxnFactory.closeSession(sessionId, ServerCnxn.DisconnectReason.CLIENT_RECONNECT);<br>        &#125;<br>        cnxn.setSessionId(sessionId);<br>        reopenSession(cnxn, sessionId, passwd, sessionTimeout);<br>        ServerMetrics.getMetrics().CONNECTION_REVALIDATE_COUNT.add(<span class="hljs-number">1</span>);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>创建会话调用 createSession() ，该方法会首先创建一个sessionId，并把该sessionId作为会话ID创建一个创建session会话的请求，并将该请求交给业务链作为一个业务处理， createSession() 源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">createSession</span><span class="hljs-params">(ServerCnxn cnxn, <span class="hljs-keyword">byte</span>[] passwd, <span class="hljs-keyword">int</span> timeout)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (passwd == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// Possible since it&#x27;s just deserialized from a packet on the wire.</span><br>        passwd = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-comment">// 创建session</span><br>    <span class="hljs-keyword">long</span> sessionId = sessionTracker.createSession(timeout);<br>    Random r = <span class="hljs-keyword">new</span> Random(sessionId ^ superSecret);<br>    r.nextBytes(passwd);<br>    ByteBuffer to = ByteBuffer.allocate(<span class="hljs-number">4</span>);<br>    to.putInt(timeout);<br>    cnxn.setSessionId(sessionId);<br>    <span class="hljs-comment">// 根据创建的SessionID提交一个创建会话的业务</span><br>    Request si = <span class="hljs-keyword">new</span> Request(cnxn, sessionId, <span class="hljs-number">0</span>, OpCode.createSession, to, <span class="hljs-keyword">null</span>);<br>    <span class="hljs-comment">// 提交业务</span><br>    submitRequest(si);<br>    <span class="hljs-keyword">return</span> sessionId;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面方法用到的 sessionTracker.createSession(timeout) 做了2个操作分别是创建sessionId和配置sessionId的跟踪信息，方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 创建Session</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> sessionTimeout</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">createSession</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sessionTimeout)</span> </span>&#123;<br>    <span class="hljs-comment">// 获取下一个SessionID</span><br>    <span class="hljs-keyword">long</span> sessionId = nextSessionId.getAndIncrement();<br>    <span class="hljs-comment">// Session跟踪配置</span><br>    trackSession(sessionId, sessionTimeout);<br>    <span class="hljs-keyword">return</span> sessionId;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>会话信息的跟踪其实就是将会话信息添加到队列中，任何地方可以根据会话ID找到会话信息，trackSession 方法实现了Session创建、Session队列存储、 Session 过期队列存储， trackSession方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">trackSession</span><span class="hljs-params">(<span class="hljs-keyword">long</span> id, <span class="hljs-keyword">int</span> sessionTimeout)</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span> added = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-comment">// 获取一个Session，如果为空，则以SessionID创建一个Session</span><br>    SessionImpl session = sessionsById.get(id);<br>    <span class="hljs-keyword">if</span> (session == <span class="hljs-keyword">null</span>) &#123;<br>        session = <span class="hljs-keyword">new</span> SessionImpl(id, sessionTimeout);<br>    &#125;<br><br>    <span class="hljs-comment">// Session存入到sessionsById中，可以根据ID获取到Session</span><br>    <span class="hljs-comment">// findbugs2.0.3 complains about get after put.</span><br>    <span class="hljs-comment">// long term strategy would be use computeIfAbsent after JDK 1.8</span><br>    SessionImpl existedSession = sessionsById.putIfAbsent(id, session);<br><br>    <span class="hljs-keyword">if</span> (existedSession != <span class="hljs-keyword">null</span>) &#123;<br>        session = existedSession;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        added = <span class="hljs-keyword">true</span>;<br>        LOG.debug(<span class="hljs-string">&quot;Adding session 0x&#123;&#125;&quot;</span>, Long.toHexString(id));<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (LOG.isTraceEnabled()) &#123;<br>        String actionStr = added ? <span class="hljs-string">&quot;Adding&quot;</span> : <span class="hljs-string">&quot;Existing&quot;</span>;<br>        ZooTrace.logTraceMessage(<br>            LOG,<br>            ZooTrace.SESSION_TRACE_MASK,<br>            <span class="hljs-string">&quot;SessionTrackerImpl --- &quot;</span> + actionStr<br>            + <span class="hljs-string">&quot; session 0x&quot;</span> + Long.toHexString(id) + <span class="hljs-string">&quot; &quot;</span> + sessionTimeout);<br>    &#125;<br><br>    <span class="hljs-comment">// 将Session添加到失效队列中</span><br>    updateSessionExpiry(session, sessionTimeout);<br>    <span class="hljs-keyword">return</span> added;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在 PrepRequestProcessor 的 run 方法中调用 pRequest2Txn ，调用链：PrepRequestProcessor.run()-&gt;pRequest()-&gt;pRequestHelper()-&gt;pRequest2Txn()，pRequest2Txn()关键代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">case</span> OpCode.createSession:<br>    request.request.rewind();<br>    <span class="hljs-keyword">int</span> to = request.request.getInt();<br>    request.setTxn(<span class="hljs-keyword">new</span> CreateSessionTxn(to));<br>    request.request.rewind();<br>    <span class="hljs-comment">// only add the global session tracker but not to ZKDb</span><br>    zks.sessionTracker.trackSession(request.sessionId, to);<br>    zks.setOwner(request.sessionId, request.getOwner());<br>    <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure>

<p>在 SyncRequestProcessor 对txn（创建session的操作）进行持久化，在 FinalRequestProcessor 会对Session进行提交，其实就是把 Session 的ID和 Timeout 存到 sessionsWithTimeout 中去。</p>
<p>由于 FinalRequestProcessor 中的调用链路：</p>
<p>FinalRequestProcessor.processRequest()-&gt;applyRequest() -&gt;ZookeeperServer.processTxn(request)-&gt;ZookeeperServer.processTxnForSessionEvents()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processTxnForSessionEvents</span><span class="hljs-params">(Request request, TxnHeader hdr, Record txn)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> opCode = (request == <span class="hljs-keyword">null</span>) ? hdr.getType() : request.type;<br>    <span class="hljs-keyword">long</span> sessionId = (request == <span class="hljs-keyword">null</span>) ? hdr.getClientId() : request.sessionId;<br>    <span class="hljs-comment">//OpCode.createSession业务</span><br>    <span class="hljs-keyword">if</span> (opCode == OpCode.createSession) &#123;<br>        <span class="hljs-keyword">if</span> (hdr != <span class="hljs-keyword">null</span> &amp;&amp; txn <span class="hljs-keyword">instanceof</span> CreateSessionTxn) &#123;<br>            CreateSessionTxn cst = (CreateSessionTxn) txn;<br>            <span class="hljs-comment">// 将sessionId、TimeOut提交到sessionsWithTimeout中</span><br>            sessionTracker.commitSession(sessionId, cst.getTimeOut());<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (request == <span class="hljs-keyword">null</span> || !request.isLocalSession()) &#123;<br>            LOG.warn(<span class="hljs-string">&quot;*****&gt;&gt;&gt;&gt;&gt; Got &#123;&#125; &#123;&#125;&quot;</span>, txn.getClass(), txn.toString());<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (opCode == OpCode.closeSession) &#123;<br>        sessionTracker.removeSession(sessionId);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面方法主要处理了 OpCode.createSession 操作并且通过 sessionTracker.commitSession() 将 sessionId、TimeOut 提交到sessionsWithTimeout 中。</p>
<p>SessionTrackerImpl.commitSession() 代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">commitSession</span><span class="hljs-params">(<span class="hljs-keyword">long</span> id, <span class="hljs-keyword">int</span> sessionTimeout)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> sessionsWithTimeout.put(id, sessionTimeout) == <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="Session刷新"><a href="#Session刷新" class="headerlink" title="Session刷新"></a>Session刷新</h4><p>服务端无论接受什么请求命令(增删或ping等请求)都会更新Session的过期时间 。我们做增删或者ping命令的时候，都会经过 RequestThrottler ， RequestThrottler 的run方法中调用zks.submitRequestNow() ，而 zks.submitRequestNow(request) 中调用了 touch(si.cnxn); ，该方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">touch</span><span class="hljs-params">(ServerCnxn cnxn)</span> <span class="hljs-keyword">throws</span> MissingSessionException </span>&#123;<br>    <span class="hljs-keyword">if</span> (cnxn == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">long</span> id = cnxn.getSessionId();<br>    <span class="hljs-keyword">int</span> to = cnxn.getSessionTimeout();<br>    <span class="hljs-comment">// 更新会话过期时间</span><br>    <span class="hljs-keyword">if</span> (!sessionTracker.touchSession(id, to)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> MissingSessionException(<span class="hljs-string">&quot;No session with sessionid 0x&quot;</span><br>                + Long.toHexString(id)<br>                + <span class="hljs-string">&quot; exists, probably expired and removed&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>touchSession() 方法更新sessionExpiryQueue失效队列中的失效时间，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">touchSession</span><span class="hljs-params">(<span class="hljs-keyword">long</span> sessionId, <span class="hljs-keyword">int</span> timeout)</span> </span>&#123;<br>    <span class="hljs-comment">// 根据SessionId获取Session</span><br>    SessionImpl s = sessionsById.get(sessionId);<br><br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span>) &#123;<br>        logTraceTouchInvalidSession(sessionId, timeout);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (s.isClosing()) &#123;<br>        logTraceTouchClosingSession(sessionId, timeout);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// 更新session过期时间</span><br>    updateSessionExpiry(s, timeout);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>update() 方法会在当前时间的基础上增加timeout，并更新失效时间为newExpiryTime，关键源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateSessionExpiry</span><span class="hljs-params">(SessionImpl s, <span class="hljs-keyword">int</span> timeout)</span> </span>&#123;<br>    logTraceTouchSession(s.sessionId, timeout, <span class="hljs-string">&quot;&quot;</span>);<br>    sessionExpiryQueue.update(s, timeout);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">update</span><span class="hljs-params">(E elem, <span class="hljs-keyword">int</span> timeout)</span> </span>&#123;<br>    Long prevExpiryTime = elemMap.get(elem);<br>    <span class="hljs-keyword">long</span> now = Time.currentElapsedTime();<br>    <span class="hljs-comment">// 当前时间+timeout</span><br>    Long newExpiryTime = roundToNextInterval(now + timeout);<br><br>    <span class="hljs-keyword">if</span> (newExpiryTime.equals(prevExpiryTime)) &#123;<br>        <span class="hljs-comment">// No change, so nothing to update</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// First add the elem to the new expiry time bucket in expiryMap.</span><br>    Set&lt;E&gt; set = expiryMap.get(newExpiryTime);<br>    <span class="hljs-keyword">if</span> (set == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// Construct a ConcurrentHashSet using a ConcurrentHashMap</span><br>        set = Collections.newSetFromMap(<span class="hljs-keyword">new</span> ConcurrentHashMap&lt;E, Boolean&gt;());<br>        <span class="hljs-comment">// Put the new set in the map, but only if another thread</span><br>        <span class="hljs-comment">// hasn&#x27;t beaten us to it</span><br>        Set&lt;E&gt; existingSet = expiryMap.putIfAbsent(newExpiryTime, set);<br>        <span class="hljs-keyword">if</span> (existingSet != <span class="hljs-keyword">null</span>) &#123;<br>            set = existingSet;<br>        &#125;<br>    &#125;<br>    set.add(elem);<br><br>    <span class="hljs-comment">// Map the elem to the new expiry time. If a different previous</span><br>    <span class="hljs-comment">// mapping was present, clean up the previous expiry bucket.</span><br>    prevExpiryTime = elemMap.put(elem, newExpiryTime);<br>    <span class="hljs-keyword">if</span> (prevExpiryTime != <span class="hljs-keyword">null</span> &amp;&amp; !newExpiryTime.equals(prevExpiryTime)) &#123;<br>        Set&lt;E&gt; prevSet = expiryMap.get(prevExpiryTime);<br>        <span class="hljs-keyword">if</span> (prevSet != <span class="hljs-keyword">null</span>) &#123;<br>            prevSet.remove(elem);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> newExpiryTime;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="Session过期"><a href="#Session过期" class="headerlink" title="Session过期"></a>Session过期</h4><p>SessionTrackerImpl 是一个线程类，继承了 ZooKeeperCriticalThread ，我们可以看它的run方法，它首先获取了下一个会话过期时间，并休眠等待会话过期时间到期，然后获取过期的客户端会话集合并循环关闭，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">while</span> (running) &#123;<br>            <span class="hljs-comment">// 获取下一个失效时间 waitTime，并休眠等待时间到来</span><br>            <span class="hljs-keyword">long</span> waitTime = sessionExpiryQueue.getWaitTime();<br>            <span class="hljs-keyword">if</span> (waitTime &gt; <span class="hljs-number">0</span>) &#123;<br>                Thread.sleep(waitTime);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">// 获取失效的客户端会话集合</span><br>            <span class="hljs-keyword">for</span> (SessionImpl s : sessionExpiryQueue.poll()) &#123;<br>                ServerMetrics.getMetrics().STALE_SESSIONS_EXPIRED.add(<span class="hljs-number">1</span>);<br>                <span class="hljs-comment">// 关闭会话</span><br>                setSessionClosing(s.sessionId);<br>                <span class="hljs-comment">// 让客户端会话失效</span><br>                expirer.expire(s);<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        handleException(<span class="hljs-keyword">this</span>.getName(), e);<br>    &#125;<br>    LOG.info(<span class="hljs-string">&quot;SessionTrackerImpl exited loop!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面方法中调用了 sessionExpiryQueue.poll() ，该方法代码主要是获取过期时间对应的客户端会话集合，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Set&lt;E&gt; <span class="hljs-title">poll</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">long</span> now = Time.currentElapsedTime();<br>    <span class="hljs-keyword">long</span> expirationTime = nextExpirationTime.get();<br>    <span class="hljs-keyword">if</span> (now &lt; expirationTime) &#123;<br>        <span class="hljs-keyword">return</span> Collections.emptySet();<br>    &#125;<br><br>    Set&lt;E&gt; set = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">long</span> newExpirationTime = expirationTime + expirationInterval;<br>    <span class="hljs-keyword">if</span> (nextExpirationTime.compareAndSet(expirationTime, newExpirationTime)) &#123;<br>        <span class="hljs-comment">// 获取失效时间的客户端实现类的集合，这就是expiryMap集合类的意义</span><br>        set = expiryMap.remove(expirationTime);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (set == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> Collections.emptySet();<br>    &#125;<br>    <span class="hljs-keyword">return</span> set;<br>&#125;<br></code></pre></td></tr></table></figure>

<p> setSessionClosing() 方法其实是把Session会话的 isClosing 状态设置为了true,方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSessionClosing</span><span class="hljs-params">(<span class="hljs-keyword">long</span> sessionId)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (LOG.isTraceEnabled()) &#123;<br>        LOG.trace(<span class="hljs-string">&quot;Session closing: 0x&#123;&#125;&quot;</span>, Long.toHexString(sessionId));<br>    &#125;<br><br>    SessionImpl s = sessionsById.get(sessionId);<br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    s.isClosing = <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>让客户端失效的方法 expirer.expire(s); 其实也是一个业务操作，主要调用了ZooKeeperServer.expire() 方法，而该方法获取SessionId后，又创建了一个OpCode.closeSession 的请求，并交给业务链处理，ZooKeeperServer.expire() 方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">expire</span><span class="hljs-params">(Session session)</span> </span>&#123;<br>    <span class="hljs-keyword">long</span> sessionId = session.getSessionId();<br>    LOG.info(<br>            <span class="hljs-string">&quot;Expiring session 0x&#123;&#125;, timeout of &#123;&#125;ms exceeded&quot;</span>,<br>            Long.toHexString(sessionId),<br>            session.getTimeout());<br>    close(sessionId);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">(<span class="hljs-keyword">long</span> sessionId)</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个OpCode.closeSession业务请求</span><br>    Request si = <span class="hljs-keyword">new</span> Request(<span class="hljs-keyword">null</span>, sessionId, <span class="hljs-number">0</span>, OpCode.closeSession, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<br>    <span class="hljs-comment">// 交给业务链处理</span><br>    submitRequest(si);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在 PrepRequestProcessor.pRequest2Txn() 方法中 OpCode.closeSession 操作里最后部分代理明确将会话Session的isClosing设置为了true，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">case</span> OpCode.closeSession:<br>    <span class="hljs-comment">// We don&#x27;t want to do this check since the session expiration thread</span><br>    <span class="hljs-comment">// queues up this operation without being the session owner.</span><br>    <span class="hljs-comment">// this request is the last of the session so it should be ok</span><br>    <span class="hljs-comment">//zks.sessionTracker.checkSession(request.sessionId, request.getOwner());</span><br>    <span class="hljs-keyword">long</span> startTime = Time.currentElapsedTime();<br>    <span class="hljs-keyword">synchronized</span> (zks.outstandingChanges) &#123;<br>        <span class="hljs-comment">// need to move getEphemerals into zks.outstandingChanges</span><br>        <span class="hljs-comment">// synchronized block, otherwise there will be a race</span><br>        <span class="hljs-comment">// condition with the on flying deleteNode txn, and we&#x27;ll</span><br>        <span class="hljs-comment">// delete the node again here, which is not correct</span><br>        Set&lt;String&gt; es = zks.getZKDatabase().getEphemerals(request.sessionId);<br>        <span class="hljs-keyword">for</span> (ChangeRecord c : zks.outstandingChanges) &#123;<br>            <span class="hljs-keyword">if</span> (c.stat == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// Doing a delete</span><br>                es.remove(c.path);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c.stat.getEphemeralOwner() == request.sessionId) &#123;<br>                es.add(c.path);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (String path2Delete : es) &#123;<br>            <span class="hljs-keyword">if</span> (digestEnabled) &#123;<br>                parentPath = getParentPathAndValidate(path2Delete);<br>                parentRecord = getRecordForPath(parentPath);<br>                parentRecord = parentRecord.duplicate(request.getHdr().getZxid());<br>                parentRecord.stat.setPzxid(request.getHdr().getZxid());<br>                parentRecord.precalculatedDigest = precalculateDigest(<br>                        DigestOpCode.UPDATE, parentPath, parentRecord.data, parentRecord.stat);<br>                addChangeRecord(parentRecord);<br>            &#125;<br>            nodeRecord = <span class="hljs-keyword">new</span> ChangeRecord(<br>                    request.getHdr().getZxid(), path2Delete, <span class="hljs-keyword">null</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>);<br>            nodeRecord.precalculatedDigest = precalculateDigest(<br>                    DigestOpCode.REMOVE, path2Delete);<br>            addChangeRecord(nodeRecord);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (ZooKeeperServer.isCloseSessionTxnEnabled()) &#123;<br>            request.setTxn(<span class="hljs-keyword">new</span> CloseSessionTxn(<span class="hljs-keyword">new</span> ArrayList&lt;String&gt;(es)));<br>        &#125;<br>        zks.sessionTracker.setSessionClosing(request.sessionId);<br>    &#125;<br>    ServerMetrics.getMetrics().CLOSE_SESSION_PREP_TIME.add(Time.currentElapsedTime() - startTime);<br>    <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure>

<p>业务链处理对象 FinalRequestProcessor.processRequest() 方法调用了ZooKeeperServer.processTxn() ，并且在 processTxn() 方法中执行了processTxnForSessionEvents ，而 processTxnForSessionEvents() 方法正好移除了会话信息，方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processTxnForSessionEvents</span><span class="hljs-params">(Request request, TxnHeader hdr, Record txn)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> opCode = (request == <span class="hljs-keyword">null</span>) ? hdr.getType() : request.type;<br>    <span class="hljs-keyword">long</span> sessionId = (request == <span class="hljs-keyword">null</span>) ? hdr.getClientId() : request.sessionId;<br>    <span class="hljs-comment">// OpCode.createSession业务</span><br>    <span class="hljs-keyword">if</span> (opCode == OpCode.createSession) &#123;<br>        <span class="hljs-keyword">if</span> (hdr != <span class="hljs-keyword">null</span> &amp;&amp; txn <span class="hljs-keyword">instanceof</span> CreateSessionTxn) &#123;<br>            CreateSessionTxn cst = (CreateSessionTxn) txn;<br>            <span class="hljs-comment">// 将sessionId、TimeOut提交到sessionsWithTimeout中</span><br>            sessionTracker.commitSession(sessionId, cst.getTimeOut());<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (request == <span class="hljs-keyword">null</span> || !request.isLocalSession()) &#123;<br>            LOG.warn(<span class="hljs-string">&quot;*****&gt;&gt;&gt;&gt;&gt; Got &#123;&#125; &#123;&#125;&quot;</span>, txn.getClass(), txn.toString());<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (opCode == OpCode.closeSession) &#123;<br>        <span class="hljs-comment">// 移除对应会话</span><br>        sessionTracker.removeSession(sessionId);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>移除会话的方法 SessionTrackerImpl.removeSession() 会移除会话ID以及过期会话对象，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeSession</span><span class="hljs-params">(<span class="hljs-keyword">long</span> sessionId)</span> </span>&#123;<br>    LOG.debug(<span class="hljs-string">&quot;Removing session 0x&#123;&#125;&quot;</span>, Long.toHexString(sessionId));<br>    SessionImpl s = sessionsById.remove(sessionId);<br>    <span class="hljs-comment">// 会话ID移除</span><br>    sessionsWithTimeout.remove(sessionId);<br>    <span class="hljs-keyword">if</span> (LOG.isTraceEnabled()) &#123;<br>        ZooTrace.logTraceMessage(<br>            LOG,<br>            ZooTrace.SESSION_TRACE_MASK,<br>            <span class="hljs-string">&quot;SessionTrackerImpl --- Removing session 0x&quot;</span> + Long.toHexString(sessionId));<br>    &#125;<br>    <span class="hljs-keyword">if</span> (s != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 超时会话移除</span><br>        sessionExpiryQueue.remove(s);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Zookeeper集群启动流程"><a href="#Zookeeper集群启动流程" class="headerlink" title="Zookeeper集群启动流程"></a>Zookeeper集群启动流程</h3><h4 id="Zookeeper集群配置"><a href="#Zookeeper集群配置" class="headerlink" title="Zookeeper集群配置"></a>Zookeeper集群配置</h4><ol>
<li><p>复制zoo.cfg文件并修改其中dataDir、clientPort、admin.serverPort、server.n的配置</p>
<p>zoo1.cfg</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">tickTime</span>=<span class="hljs-string">2000</span><br><span class="hljs-attr">initLimit</span>=<span class="hljs-string">10</span><br><span class="hljs-attr">syncLimit</span>=<span class="hljs-string">5</span><br><span class="hljs-attr">dataDir</span>=<span class="hljs-string">/Users/zhaoguocheng/workspace/aosp/zookeeper-master/data/zookeeper1</span><br><span class="hljs-attr">clientPort</span>=<span class="hljs-string">2181</span><br><br><br><span class="hljs-meta">admin.serverPort</span>=<span class="hljs-string">8081</span><br><span class="hljs-meta">server.1</span>=<span class="hljs-string">127.0.0.1:12881:13881</span><br><span class="hljs-meta">server.2</span>=<span class="hljs-string">127.0.0.1:12882:13882</span><br><span class="hljs-meta">server.3</span>=<span class="hljs-string">127.0.0.1:12883:13883</span><br></code></pre></td></tr></table></figure>

<p>zoo2.cfg</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">tickTime</span>=<span class="hljs-string">2000</span><br><span class="hljs-attr">initLimit</span>=<span class="hljs-string">10</span><br><span class="hljs-attr">syncLimit</span>=<span class="hljs-string">5</span><br><span class="hljs-attr">dataDir</span>=<span class="hljs-string">/Users/zhaoguocheng/workspace/aosp/zookeeper-master/data/zookeeper2</span><br><span class="hljs-attr">clientPort</span>=<span class="hljs-string">2182</span><br><br><br><span class="hljs-meta">admin.serverPort</span>=<span class="hljs-string">8082</span><br><span class="hljs-meta">server.1</span>=<span class="hljs-string">127.0.0.1:12881:13881</span><br><span class="hljs-meta">server.2</span>=<span class="hljs-string">127.0.0.1:12882:13882</span><br><span class="hljs-meta">server.3</span>=<span class="hljs-string">127.0.0.1:12883:13883</span><br></code></pre></td></tr></table></figure>

<p>zoo3.cfg</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">tickTime</span>=<span class="hljs-string">2000</span><br><span class="hljs-attr">initLimit</span>=<span class="hljs-string">10</span><br><span class="hljs-attr">syncLimit</span>=<span class="hljs-string">5</span><br><span class="hljs-attr">dataDir</span>=<span class="hljs-string">/Users/zhaoguocheng/workspace/aosp/zookeeper-master/data/zookeeper3</span><br><span class="hljs-attr">clientPort</span>=<span class="hljs-string">2183</span><br><br><br><span class="hljs-meta">admin.serverPort</span>=<span class="hljs-string">8083</span><br><span class="hljs-meta">server.1</span>=<span class="hljs-string">127.0.0.1:12881:13881</span><br><span class="hljs-meta">server.2</span>=<span class="hljs-string">127.0.0.1:12882:13882</span><br><span class="hljs-meta">server.3</span>=<span class="hljs-string">127.0.0.1:12883:13883</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>在dataDir目录中创建myid文件，内容为server.n中n的值</p>
<p><img src="/blog/2021/01/19/Zookeeper/Zookeeper%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8B/pic2.png" srcset="/blog/img/loading.gif" lazyload></p>
</li>
<li><p>配置启动类，并指定配置文件</p>
<p><img src="/blog/2021/01/19/Zookeeper/Zookeeper%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8B/pic3.png" srcset="/blog/img/loading.gif" lazyload></p>
</li>
</ol>
<h4 id="集群启动流程分析"><a href="#集群启动流程分析" class="headerlink" title="集群启动流程分析"></a>集群启动流程分析</h4><p>Zookeeper单机/集群启动流程</p>
<p><img src="/blog/2021/01/19/Zookeeper/Zookeeper%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8B/pic4.png" srcset="/blog/img/loading.gif" lazyload></p>
<p>在QuorumPeerMain中的initializeAndRun()方法中，运行流程启动集群模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initializeAndRun</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ConfigException, IOException, AdminServerException </span>&#123;<br>    QuorumPeerConfig config = <span class="hljs-keyword">new</span> QuorumPeerConfig();<br>    <span class="hljs-keyword">if</span> (args.length == <span class="hljs-number">1</span>) &#123;<br>        config.parse(args[<span class="hljs-number">0</span>]);<br>    &#125;<br><br>    <span class="hljs-comment">// 启动数据清理计划</span><br>    DatadirCleanupManager purgeMgr = <span class="hljs-keyword">new</span> DatadirCleanupManager(<br>            config.getDataDir(),            <span class="hljs-comment">// 数据存储目录</span><br>            config.getDataLogDir(),         <span class="hljs-comment">// 事务日志记录，默认为dataDir</span><br>            config.getSnapRetainCount(),    <span class="hljs-comment">// 保留快照数据数量，默认为3个</span><br>            config.getPurgeInterval());     <span class="hljs-comment">// 多少小时清理一次数据，默认不清理，在zoo.cfg中的autopurge.purgeInterval=1设置时间</span><br>    purgeMgr.start();<br><br>    <span class="hljs-comment">// 集群模式运行</span><br>    <span class="hljs-keyword">if</span> (args.length == <span class="hljs-number">1</span> &amp;&amp; config.isDistributed()) &#123;<br>        runFromConfig(config);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        LOG.warn(<span class="hljs-string">&quot;Either no config or no quorum defined in config, running in standalone mode&quot;</span>);<br>        <span class="hljs-comment">// 单机模式运行</span><br>        ZooKeeperServerMain.main(args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其中的runFromConfig()方法会调用QuorumPeer中的start()方法，start()方法代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!getView().containsKey(myid)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;My id &quot;</span> + myid + <span class="hljs-string">&quot; not in the peer list&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 加载数据库数据</span><br>    loadDataBase();<br>    <span class="hljs-comment">// 启动网络通信</span><br>    startServerCnxnFactory();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 启动AdminServer</span><br>        adminServer.start();<br>    &#125; <span class="hljs-keyword">catch</span> (AdminServerException e) &#123;<br>        LOG.warn(<span class="hljs-string">&quot;Problem starting AdminServer&quot;</span>, e);<br>        System.out.println(e);<br>    &#125;<br>    <span class="hljs-comment">// 启动选举策略</span><br>    startLeaderElection();<br>    <span class="hljs-comment">// 启动JVM监听</span><br>    startJvmPauseMonitor();<br>    <span class="hljs-comment">// 启动线程</span><br>    <span class="hljs-keyword">super</span>.start();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>startLeaderElection() 开启Leader选举方法做了2件事，首先创建初始化选票选自己，接着创建选举投票方式，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startLeaderElection</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 创建当前选票，启动的时候先投票给自己</span><br>        <span class="hljs-keyword">if</span> (getPeerState() == ServerState.LOOKING) &#123;<br>            currentVote = <span class="hljs-keyword">new</span> Vote(myid, getLastLoggedZxid(), getCurrentEpoch());<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        RuntimeException re = <span class="hljs-keyword">new</span> RuntimeException(e.getMessage());<br>        re.setStackTrace(e.getStackTrace());<br>        <span class="hljs-keyword">throw</span> re;<br>    &#125;<br>    <span class="hljs-comment">// 创建选举算法</span><br>    <span class="hljs-keyword">this</span>.electionAlg = createElectionAlgorithm(electionType);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>createElectionAlgorithm() 创建选举算法只有第3种，其他2种均已废弃，方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Election <span class="hljs-title">createElectionAlgorithm</span><span class="hljs-params">(<span class="hljs-keyword">int</span> electionAlgorithm)</span> </span>&#123;<br>    Election le = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span> use a factory rather than a switch</span><br>    <span class="hljs-keyword">switch</span> (electionAlgorithm) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException(<span class="hljs-string">&quot;Election Algorithm 1 is not supported.&quot;</span>);<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException(<span class="hljs-string">&quot;Election Algorithm 2 is not supported.&quot;</span>);<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>        <span class="hljs-comment">// 只有electionAlgorithm=3,其他的已废弃</span><br>        QuorumCnxManager qcm = createCnxnManager();<br>        QuorumCnxManager oldQcm = qcmRef.getAndSet(qcm);<br>        <span class="hljs-keyword">if</span> (oldQcm != <span class="hljs-keyword">null</span>) &#123;<br>            LOG.warn(<span class="hljs-string">&quot;Clobbering already-set QuorumCnxManager (restarting leader election?)&quot;</span>);<br>            oldQcm.halt();<br>        &#125;<br>        QuorumCnxManager.Listener listener = qcm.listener;<br>        <span class="hljs-keyword">if</span> (listener != <span class="hljs-keyword">null</span>) &#123;<br>            listener.start();<br>            FastLeaderElection fle = <span class="hljs-keyword">new</span> FastLeaderElection(<span class="hljs-keyword">this</span>, qcm);<br>            fle.start();<br>            le = fle;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            LOG.error(<span class="hljs-string">&quot;Null listener when initializing cnx manager&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-keyword">assert</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> le;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个方法创建了以下三个对象：</p>
<ul>
<li><p>QuorumCnxManager</p>
</li>
<li><p>QuorumCnxManager.Listener</p>
</li>
<li><p>FastLeaderElection</p>
</li>
</ul>
<h3 id="Zookeeper集群Leader选举"><a href="#Zookeeper集群Leader选举" class="headerlink" title="Zookeeper集群Leader选举"></a>Zookeeper集群Leader选举</h3><h4 id="Paxos算法介绍"><a href="#Paxos算法介绍" class="headerlink" title="Paxos算法介绍"></a>Paxos算法介绍</h4><p>Zookeeper选举主要依赖于FastLeaderElection算法，其他算法均已淘汰，但FastLeaderElection算法又是典型的Paxos算法，所以我们要先学习下Paxos算法，这样更有助于掌握FastLeaderElection算法。</p>
<p>Paxos介绍</p>
<p>分布式事务中常见的事务模型有2PC和3PC，无论是2PC提交还是3PC提交都无法彻底解决分布式的一致性问题以及无法解决太过保守及容错性不好。Google Chubby的作者Mike Burrows说过，世上只有一种一致性算法，那就是Paxos，所有其他一致性算法都是Paxos算法的不完整版。Paxos算法是公认的晦涩，很难讲清楚，但是工程上也很难实现，所以有很多Paxos算法的工程实现，如Chubby， Raft，ZAB，微信的PhxPaxos等。这一篇会介绍这个公认为难于理解但是行之有效的Paxos算法。</p>
<p>Paxos算法是莱斯利·兰伯特(Leslie Lamport)1990年提出的一种基于消息传递的一致性算法，它曾就此发表了《The Part-Time Parliament》，《Paxos Made Simple》，由于采用故事的方式来解释此算法，感觉还是很难理解。</p>
<p>Paxos算法背景</p>
<p>Paxos算法是基于消息传递且具有高度容错特性的一致性算法，是目前公认的解决分布式一致性问题最有效的算法之一，其解决的问题就是在分布式系统中如何就某个值（决议）达成一致。 </p>
<p>不要把这个Paxos算法达到的目的和分布式事务联系起来，而是针对Zookeeper这样的master-slave集群对某个决议达成一致，也就是副本之间写或者leader选举达成一致。我觉得这个算法和狭义的分布式事务不是一样的。 在常见的分布式系统中，总会发生诸如机器宕机或网络异常（包括消息的延迟、丢失、重复、乱序，还有网络分区）(也就是会发生异常的分布式系统)等情况。Paxos算法需要解决的问题就是如何在一个可能发生上述异常的分布式系统中，快速且正确地在集群内部对某个数据的值达成一致。也可以理解成分布式系统中达成状态的一致性。</p>
<p>Paxos算法理解</p>
<p>Paxos 算法是分布式一致性算法用来解决一个分布式系统如何就某个值(决议)达成一致的问题。一个典型的场景是，在一个分布式数据库系统中，如果各节点的初始状态一致，每个节点都执行相同的操作序列，那么他们最后能得到一个一致的状态。为保证每个节点执行相同的命令序列，需要在每一条指令上执行一个”一致性算法”以保证每个节点看到的指令一致。 分布式系统中一般是通过多副本来保证可靠性，而多个副本之间会存在数据不一致的情况。所以必须有一个一致性算法来保证数据的一致。</p>
<p>假如在分布式系统中初始时各个节点的数据是一致的，每个节点都顺序执行系列操作，然后每个节点最终的数据还是一致的。Paxos算法就是解决这种分布式场景中的一致性问题。对于一般的开发人员来说，只需要知道paxos是一个分布式选举算法即可。多个节点之间存在两种通讯模型：共享内存（Shared memory）、消息传递（Messages passing），Paxos是基于消息传递的通讯模型的。</p>
<p>Paxos相关概念</p>
<p>在Paxos算法中，有三种角色：</p>
<ul>
<li><p>Proposer</p>
</li>
<li><p>Acceptor</p>
</li>
<li><p>Learners</p>
</li>
</ul>
<p>在具体的实现中，一个进程可能同时充当多种角色。比如一个进程可能既是Proposer又是Acceptor又是Learner。Proposer负责提出提案，Acceptor负责对提案作出裁决（accept与否），learner负责学习提案结果。 还有一个很重要的概念叫提案（Proposal）。最终要达成一致的value就在提案里。只要Proposer发的提案被Acceptor接受（半数以上的Acceptor同意才行），Proposer就认为该提案里的value被选定了。Acceptor告诉Learner哪个value被选定，Learner就认为那个value被选定。只要Acceptor接受了某个提案，Acceptor就认为该提案里的value被选定了。 为了避免单点故障，会有一个Acceptor集合，Proposer向Acceptor集合发送提案，Acceptor集合中的每个成员都有可能同意该提案且每个Acceptor只能批准一个提案，只有当一半以上的成员同意了一个提案，就认为该提案被选定了。</p>
<h4 id="QuorumPeer工作流程"><a href="#QuorumPeer工作流程" class="headerlink" title="QuorumPeer工作流程"></a>QuorumPeer工作流程</h4><p><img src="/blog/2021/01/19/Zookeeper/Zookeeper%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8B/pic5.png" srcset="/blog/img/loading.gif" lazyload></p>
<p><strong>QuorumCnxManager</strong>：每台服务器在启动的过程中，会启动一个 QuorumPeer ，负责Leader选举过程中的网络通信。 </p>
<p>Zookeeper 对于每个节点 QuorumPeer 的设计相当的灵活， QuorumPeer 主要包括四个组件：客户端请求接收器( ServerCnxnFactory )、数据引擎( ZKDatabase )、选举器( Election )、核心功能组件( Leader/Follower/Observer )。 其中：</p>
<ul>
<li><p>ServerCnxnFactory负责维护与客户端的连接(接收客户端的请求并发送相应的响应);</p>
</li>
<li><p>ZKDatabase负责存储/加载/查找数据(基于目录树结构的KV+操作日志+客户端Session);</p>
</li>
<li><p>Election负责选举集群的一个Leader节点;</p>
</li>
<li><p>Leader/Follower/Observer确认是QuorumPeer节点应该完成的核心职责;</p>
</li>
</ul>
<p>QuorumPeer 工作流程比较复杂，如下图：</p>
<p><img src="/blog/2021/01/19/Zookeeper/Zookeeper%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8B/pic6.png" srcset="/blog/img/loading.gif" lazyload></p>
<p>注意：开启选举协调者时会执行选举（这个过程是会持续，并不是一次操作就结束了）</p>
<h4 id="QuorumCnxManager源码分析"><a href="#QuorumCnxManager源码分析" class="headerlink" title="QuorumCnxManager源码分析"></a>QuorumCnxManager源码分析</h4><p>QuorumCnxManager 内部维护了一系列的队列，用来保存接收到的、待发送的消息以及消息的发送器，除接收队列以外，其他队列都按照SID分组形成队列集合，如一个集群中除了自身还有3台机器，那么就会为这3台机器分别创建一个发送队列，互不干扰。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">QuorumCnxManager</span><span class="hljs-params">(QuorumPeer self, <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> mySid, Map&lt;Long, QuorumPeer.QuorumServer&gt; view,</span></span><br><span class="hljs-function"><span class="hljs-params">    QuorumAuthServer authServer, QuorumAuthLearner authLearner, <span class="hljs-keyword">int</span> socketTimeout, <span class="hljs-keyword">boolean</span> listenOnAllIPs,</span></span><br><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">int</span> quorumCnxnThreadsSize, <span class="hljs-keyword">boolean</span> quorumSaslAuthEnabled)</span> </span>&#123;<br>    <span class="hljs-comment">// 消息接收队列，用于存放从其他服务器接受到的消息</span><br>    <span class="hljs-keyword">this</span>.recvQueue = <span class="hljs-keyword">new</span> CircularBlockingQueue&lt;&gt;(RECV_CAPACITY);<br>    <span class="hljs-comment">// 消息发送队列，用于保存待发送的消息，按照SID进行分组。</span><br>    <span class="hljs-keyword">this</span>.queueSendMap = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;();<br>    <span class="hljs-comment">// 发送起集合，每个SenderWorker消息发送器，都对应一台远程Zookeeper服务器，否则消息的发送也按照SID分组</span><br>    <span class="hljs-keyword">this</span>.senderWorkerMap = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;();<br>    <span class="hljs-comment">// 最近发送过的消息，为每个SID保留最近发送过的一个消息</span><br>    <span class="hljs-keyword">this</span>.lastMessageSent = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;();<br><br>    String cnxToValue = System.getProperty(<span class="hljs-string">&quot;zookeeper.cnxTimeout&quot;</span>);<br>    <span class="hljs-keyword">if</span> (cnxToValue != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">this</span>.cnxTO = Integer.parseInt(cnxToValue);<br>    &#125;<br><br>    <span class="hljs-keyword">this</span>.self = self;<br><br>    <span class="hljs-keyword">this</span>.mySid = mySid;<br>    <span class="hljs-keyword">this</span>.socketTimeout = socketTimeout;<br>    <span class="hljs-keyword">this</span>.view = view;<br>    <span class="hljs-keyword">this</span>.listenOnAllIPs = listenOnAllIPs;<br>    <span class="hljs-keyword">this</span>.authServer = authServer;<br>    <span class="hljs-keyword">this</span>.authLearner = authLearner;<br>    <span class="hljs-keyword">this</span>.quorumSaslAuthEnabled = quorumSaslAuthEnabled;<br><br>    initializeConnectionExecutor(mySid, quorumCnxnThreadsSize);<br><br>    <span class="hljs-comment">// Starts listener thread that waits for connection requests</span><br>    listener = <span class="hljs-keyword">new</span> Listener();<br>    listener.setName(<span class="hljs-string">&quot;QuorumPeerListener&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>QuorumCnxManager.Listener</p>
<p>为了能够相互投票，Zookeeper集群中的所有机器都需要建立起网络连接。QuorumCnxManager在启动时会创建一个ServerSocket来监听Leader选举的通信端口。开启监听后，Zookeeper能够不断地接收到来自其他服务器地创建连接请求，在接收到其他服务器地TCP连接请求时，会进行处理。为了避免两台机器之间重复地创建TCP连接，Zookeeper只允许SID大的服务器主动和其他机器建立连接，否则断开连接。在接收到创建连接请求后，服务器通过对比自己和远程服务器的SID值来判断是否接收连接请求，如果当前服务器发现自己的SID更大，那么会断开当前连接，然后自己主动和远程服务器将连接（自己作为“客户端”）。一旦连接建立，就会根据远程服务器的SID来创建相应的消息发送器SendWorker和消息发送器RecvWorker，并启动。</p>
<p>QuorumCnxManager.Listener 监听启动可以查看 QuorumCnxManager.Listener 的 run 方法，源代码如下，可以断点调试看到此时监听的正是我们所说的投票端口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!shutdown) &#123;<br>        LOG.debug(<span class="hljs-string">&quot;Listener thread started, myId: &#123;&#125;&quot;</span>, self.getId());<br>        Set&lt;InetSocketAddress&gt; addresses;<br><br>        <span class="hljs-keyword">if</span> (self.getQuorumListenOnAllIPs()) &#123;<br>            addresses = self.getElectionAddress().getWildcardAddresses();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            addresses = self.getElectionAddress().getAllAddresses();<br>        &#125;<br><br>        CountDownLatch latch = <span class="hljs-keyword">new</span> CountDownLatch(addresses.size());<br>        listenerHandlers = addresses.stream().map(address -&gt;<br>                        <span class="hljs-keyword">new</span> ListenerHandler(address, self.shouldUsePortUnification(), self.isSslQuorum(), latch))<br>                .collect(Collectors.toList());<br><br>        ExecutorService executor = Executors.newFixedThreadPool(addresses.size());<br>        listenerHandlers.forEach(executor::submit);<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            latch.await();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException ie) &#123;<br>            LOG.error(<span class="hljs-string">&quot;Interrupted while sleeping. Ignoring exception&quot;</span>, ie);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// Clean up for shutdown.</span><br>            <span class="hljs-keyword">for</span> (ListenerHandler handler : listenerHandlers) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    handler.close();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException ie) &#123;<br>                    <span class="hljs-comment">// Don&#x27;t log an error for shutdown.</span><br>                    LOG.debug(<span class="hljs-string">&quot;Error closing server socket&quot;</span>, ie);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    LOG.info(<span class="hljs-string">&quot;Leaving listener&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!shutdown) &#123;<br>        LOG.error(<br>          <span class="hljs-string">&quot;As I&#x27;m leaving the listener thread, I won&#x27;t be able to participate in leader election any longer: &#123;&#125;&quot;</span>,<br>          self.getElectionAddress().getAllAddresses().stream()<br>            .map(NetUtils::formatInetAddr)<br>            .collect(Collectors.joining(<span class="hljs-string">&quot;|&quot;</span>)));<br>        <span class="hljs-keyword">if</span> (socketException.get()) &#123;<br>            <span class="hljs-comment">// After leaving listener thread, the host cannot join the quorum anymore,</span><br>            <span class="hljs-comment">// this is a severe error that we cannot recover from, so we need to exit</span><br>            socketBindErrorHandler.run();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面是监听器，各个服务之间进行通信我们需要开启 ListenerHandler 线程，在QuorumCnxManager.Listener.ListenerHandler 的run方法中有一个方法 acceptConnections() 调用，该方法就是用于接受每次选举投票的信息，如果只有一个节点或者没有投票信息的时候，此时方法会阻塞，一旦执行选举，程序会往下执行，我们可以先启动1台服务，再启动第2台、第3台，此时会收到有客户端参与投票链接，程序会往下执行，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.currentThread().setName(<span class="hljs-string">&quot;ListenerHandler-&quot;</span> + address);<br>        acceptConnections();<br>        <span class="hljs-keyword">try</span> &#123;<br>            close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            LOG.warn(<span class="hljs-string">&quot;Exception when shutting down listener: &quot;</span>, e);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-comment">// Output of unexpected exception, should never happen</span><br>        LOG.error(<span class="hljs-string">&quot;Unexpected error &quot;</span>, e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        latch.countDown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acceptConnections</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> numRetries = <span class="hljs-number">0</span>;<br>    Socket client = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-keyword">while</span> ((!shutdown) &amp;&amp; (portBindMaxRetry == <span class="hljs-number">0</span> || numRetries &lt; portBindMaxRetry)) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 选举开启套接字</span><br>            serverSocket = createNewServerSocket();<br>            LOG.info(<span class="hljs-string">&quot;&#123;&#125; is accepting connections now, my election bind port: &#123;&#125;&quot;</span>, QuorumCnxManager.<span class="hljs-keyword">this</span>.mySid, address.toString());<br>            <span class="hljs-keyword">while</span> (!shutdown) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 阻塞等待客户端链接</span><br>                    client = serverSocket.accept();<br>                    setSockOpts(client);<br>                    LOG.info(<span class="hljs-string">&quot;Received connection request from &#123;&#125;&quot;</span>, client.getRemoteSocketAddress());<br>                    <span class="hljs-comment">// Receive and handle the connection request</span><br>                    <span class="hljs-comment">// asynchronously if the quorum sasl authentication is</span><br>                    <span class="hljs-comment">// enabled. This is required because sasl server</span><br>                    <span class="hljs-comment">// authentication process may take few seconds to finish,</span><br>                    <span class="hljs-comment">// this may delay next peer connection requests.</span><br>                    <span class="hljs-keyword">if</span> (quorumSaslAuthEnabled) &#123;<br>                        receiveConnectionAsync(client);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        receiveConnection(client);<br>                    &#125;<br>                    numRetries = <span class="hljs-number">0</span>;<br>                &#125; <span class="hljs-keyword">catch</span> (SocketTimeoutException e) &#123;<br>                    LOG.warn(<span class="hljs-string">&quot;The socket is listening for the election accepted &quot;</span><br>                            + <span class="hljs-string">&quot;and it timed out unexpectedly, but will retry.&quot;</span><br>                            + <span class="hljs-string">&quot;see ZOOKEEPER-2836&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">if</span> (shutdown) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            LOG.error(<span class="hljs-string">&quot;Exception while listening&quot;</span>, e);<br><br>            <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> SocketException) &#123;<br>                socketException.set(<span class="hljs-keyword">true</span>);<br>            &#125;<br><br>            numRetries++;<br>            <span class="hljs-keyword">try</span> &#123;<br>                close();<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (IOException ie) &#123;<br>                LOG.error(<span class="hljs-string">&quot;Error closing server socket&quot;</span>, ie);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException ie) &#123;<br>                LOG.error(<span class="hljs-string">&quot;Interrupted while sleeping. Ignoring exception&quot;</span>, ie);<br>            &#125;<br>            closeSocket(client);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!shutdown) &#123;<br>        LOG.error(<br>          <span class="hljs-string">&quot;Leaving listener thread for address &#123;&#125; after &#123;&#125; errors. Use &#123;&#125; property to increase retry count.&quot;</span>,<br>          formatInetAddr(address),<br>          numRetries,<br>          ELECTION_PORT_BIND_RETRY);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面虽然能证明投票访问了当前监听的端口，但怎么知道是哪台服务呢？我们可以沿着receiveConnection() 源码继续研究，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receiveConnection</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Socket sock)</span> </span>&#123;<br>    DataInputStream din = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        din = <span class="hljs-keyword">new</span> DataInputStream(<span class="hljs-keyword">new</span> BufferedInputStream(sock.getInputStream()));<br><br>        LOG.debug(<span class="hljs-string">&quot;Sync handling of connection request received from: &#123;&#125;&quot;</span>, sock.getRemoteSocketAddress());<br>        handleConnection(sock, din);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        LOG.error(<span class="hljs-string">&quot;Exception handling connection, addr: &#123;&#125;, closing server connection&quot;</span>, sock.getRemoteSocketAddress());<br>        LOG.debug(<span class="hljs-string">&quot;Exception details: &quot;</span>, e);<br>        closeSocket(sock);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>receiveConnection() 方法只是获取了数据流，并没做特殊处理，并且调用了 handleConnection()方法，该方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleConnection</span><span class="hljs-params">(Socket sock, DataInputStream din)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    Long sid = <span class="hljs-keyword">null</span>, protocolVersion = <span class="hljs-keyword">null</span>;<br>    MultipleAddresses electionAddr = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        protocolVersion = din.readLong();<br>        <span class="hljs-keyword">if</span> (protocolVersion &gt;= <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// this is a server id and not a protocol version</span><br>            sid = protocolVersion;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 获取sid，也就是myid的值</span><br>                InitialMessage init = InitialMessage.parse(protocolVersion, din);<br>                sid = init.sid;<br>                <span class="hljs-keyword">if</span> (!init.electionAddr.isEmpty()) &#123;<br>                    electionAddr = <span class="hljs-keyword">new</span> MultipleAddresses(init.electionAddr,<br>                            Duration.ofMillis(self.getMultiAddressReachabilityCheckTimeoutMs()));<br>                &#125;<br>                LOG.debug(<span class="hljs-string">&quot;Initial message parsed by &#123;&#125;: &#123;&#125;&quot;</span>, self.getId(), init.toString());<br>            &#125; <span class="hljs-keyword">catch</span> (InitialMessage.InitialMessageException ex) &#123;<br>                LOG.error(<span class="hljs-string">&quot;Initial message parsing error!&quot;</span>, ex);<br>                closeSocket(sock);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (sid == QuorumPeer.OBSERVER_ID) &#123;<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             * Choose identifier at random. We need a value to identify</span><br><span class="hljs-comment">             * the connection.</span><br><span class="hljs-comment">             */</span><br>            sid = observerCounter.getAndDecrement();<br>            LOG.info(<span class="hljs-string">&quot;Setting arbitrary identifier to observer: &#123;&#125;&quot;</span>, sid);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        LOG.warn(<span class="hljs-string">&quot;Exception reading or writing challenge&quot;</span>, e);<br>        closeSocket(sock);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// do authenticating learner</span><br>    authServer.authenticate(sock, din);<br>    <span class="hljs-comment">//If wins the challenge, then close the new connection.</span><br>    <span class="hljs-keyword">if</span> (sid &lt; self.getId()) &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * This replica might still believe that the connection to sid is</span><br><span class="hljs-comment">         * up, so we have to shut down the workers before trying to open a</span><br><span class="hljs-comment">         * new connection.</span><br><span class="hljs-comment">         */</span><br>        SendWorker sw = senderWorkerMap.get(sid);<br>        <span class="hljs-keyword">if</span> (sw != <span class="hljs-keyword">null</span>) &#123;<br>            sw.finish();<br>        &#125;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Now we start a new connection</span><br><span class="hljs-comment">         */</span><br>        LOG.debug(<span class="hljs-string">&quot;Create new connection to server: &#123;&#125;&quot;</span>, sid);<br>        closeSocket(sock);<br><br>        <span class="hljs-keyword">if</span> (electionAddr != <span class="hljs-keyword">null</span>) &#123;<br>            connectOne(sid, electionAddr);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            connectOne(sid);<br>        &#125;<br><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sid == self.getId()) &#123;<br>        <span class="hljs-comment">// we saw this case in ZOOKEEPER-2164</span><br>        LOG.warn(<span class="hljs-string">&quot;We got a connection request from a server with our own ID. &quot;</span><br>                 + <span class="hljs-string">&quot;This should be either a configuration error, or a bug.&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// Otherwise start worker threads to receive data.</span><br>        SendWorker sw = <span class="hljs-keyword">new</span> SendWorker(sock, sid);<br>        RecvWorker rw = <span class="hljs-keyword">new</span> RecvWorker(sock, din, sid, sw);<br>        sw.setRecv(rw);<br><br>        SendWorker vsw = senderWorkerMap.get(sid);<br><br>        <span class="hljs-keyword">if</span> (vsw != <span class="hljs-keyword">null</span>) &#123;<br>            vsw.finish();<br>        &#125;<br><br>        senderWorkerMap.put(sid, sw);<br><br>        queueSendMap.putIfAbsent(sid, <span class="hljs-keyword">new</span> CircularBlockingQueue&lt;&gt;(SEND_CAPACITY));<br><br>        sw.start();<br>        rw.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="FastLeaderElection算法源码分析"><a href="#FastLeaderElection算法源码分析" class="headerlink" title="FastLeaderElection算法源码分析"></a>FastLeaderElection算法源码分析</h4><p><img src="/blog/2021/01/19/Zookeeper/Zookeeper%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8B/pic7.png" srcset="/blog/img/loading.gif" lazyload></p>
<p>在 Zookeeper 集群中，主要分为三者角色，而每一个节点同时只能扮演一种角色，这三种角色分别是：</p>
<ul>
<li>Leader：接受所有Follower的提案请求并统一协调发起提案的投票，负责与所有的Follower进行内部的数据交换(同步)；</li>
<li>Follower：直接为客户端提供服务并参与提案的投票，同时与 Leader 进行数据交换(同步)；</li>
<li>Observer：直接为客户端服务但并不参与提案的投票，同时也与 Leader 进行数据交换(同步)；</li>
</ul>
<p>FastLeaderElection 选举算法是标准的 Fast Paxos 算法实现，可解决 LeaderElection 选举算法收敛速度慢的问题。</p>
<p>创建 FastLeaderElection 只需要 new FastLeaderElection() 即可，如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FastLeaderElection</span><span class="hljs-params">(QuorumPeer self, QuorumCnxManager manager)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.stop = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">this</span>.manager = manager;<br>    starter(self, manager);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>创建 FastLeaderElection 会调用 starter() 方法，该方法会创建 sendqueue 、 recvqueue 队列、Messenger 对象，其中 Messenger 对象的作用非常关键，方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">starter</span><span class="hljs-params">(QuorumPeer self, QuorumCnxManager manager)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.self = self;<br>    proposedLeader = -<span class="hljs-number">1</span>;<br>    proposedZxid = -<span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 创建sendqueue、recvqueue队列 Messenger对象</span><br>    sendqueue = <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;ToSend&gt;();<br>    recvqueue = <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Notification&gt;();<br>    <span class="hljs-keyword">this</span>.messenger = <span class="hljs-keyword">new</span> Messenger(manager);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>创建Messenger的时候，会创建 WorkerSender 并封装成 wsThread 线程，创建 WorkerReceiver 并封装成 wrThread 线程，看名字就很容易理解， wsThread 用于发送数据， wrThread 用于接收数据，Messenger 创建源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">Messenger(QuorumCnxManager manager) &#123;<br><br>    <span class="hljs-keyword">this</span>.ws = <span class="hljs-keyword">new</span> WorkerSender(manager);<br><br>    <span class="hljs-keyword">this</span>.wsThread = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">this</span>.ws, <span class="hljs-string">&quot;WorkerSender[myid=&quot;</span> + self.getId() + <span class="hljs-string">&quot;]&quot;</span>);<br>    <span class="hljs-keyword">this</span>.wsThread.setDaemon(<span class="hljs-keyword">true</span>);<br><br>    <span class="hljs-keyword">this</span>.wr = <span class="hljs-keyword">new</span> WorkerReceiver(manager);<br><br>    <span class="hljs-keyword">this</span>.wrThread = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">this</span>.wr, <span class="hljs-string">&quot;WorkerReceiver[myid=&quot;</span> + self.getId() + <span class="hljs-string">&quot;]&quot;</span>);<br>    <span class="hljs-keyword">this</span>.wrThread.setDaemon(<span class="hljs-keyword">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上main集群启动流程分析中 FastLeaderElection 创建后接着会调用它的 start() 方法启动选举算法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.messenger.start();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面会执行 messager.start() ，也就是如下方法，也就意味着 wsThread 和 wrThread 线程都将启动，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.wsThread.start();<br>    <span class="hljs-keyword">this</span>.wrThread.start();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>wsThread 由 WorkerSender 封装而来，此时会调用 WorkerSender 的 run 方法，run方法会调用process() 方法，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (!stop) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            ToSend m = sendqueue.poll(<span class="hljs-number">3000</span>, TimeUnit.MILLISECONDS);<br>            <span class="hljs-keyword">if</span> (m == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            process(m);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    LOG.info(<span class="hljs-string">&quot;WorkerSender is down&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>process 方法调用了 manager 的 toSend 方法，此时是把对应的sid作为了消息发送出去，这里其实是发送投票信息，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(ToSend m)</span> </span>&#123;<br>    ByteBuffer requestBuffer = buildMsg(m.state.ordinal(), m.leader, m.zxid, m.electionEpoch, m.peerEpoch, m.configData);<br><br>    manager.toSend(m.sid, requestBuffer);<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>投票可以投自己，也可以投别人，如果是选票选自己，只需要把投票信息添加到 recvQueue 中即可，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">toSend</span><span class="hljs-params">(Long sid, ByteBuffer b)</span> </span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * If sending message to myself, then simply enqueue it (loopback).</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.mySid == sid) &#123;<br>        b.position(<span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 自己发送给自己的选票</span><br>        addToRecvQueue(<span class="hljs-keyword">new</span> Message(b.duplicate(), sid));<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Otherwise send to the corresponding thread to send.</span><br><span class="hljs-comment">         */</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Start a new connection if doesn&#x27;t have one already.</span><br><span class="hljs-comment">         * 发送投票信息给其他节点</span><br><span class="hljs-comment">         */</span><br>        BlockingQueue&lt;ByteBuffer&gt; bq = queueSendMap.computeIfAbsent(sid, serverId -&gt; <span class="hljs-keyword">new</span> CircularBlockingQueue&lt;&gt;(SEND_CAPACITY));<br>        addToSendQueue(bq, b);<br>        connectOne(sid);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在 WorkerReceiver.run 方法中会从 recvQueue 中获取 Message ，并把发送给其他服务的投票封装到sendqueue 队列中，交给 WorkerSender 发送处理，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br><br>        Message response;<br>        <span class="hljs-keyword">while</span> (!stop) &#123;<br>            <span class="hljs-comment">// Sleeps on receive</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 从recvQueue中获取Message对象</span><br>                response = manager.pollRecvQueue(<span class="hljs-number">3000</span>, TimeUnit.MILLISECONDS);<br>                <span class="hljs-keyword">if</span> (response == <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br><br>                <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> capacity = response.buffer.capacity();<br><br>                <span class="hljs-comment">// The current protocol and two previous generations all send at least 28 bytes</span><br>                <span class="hljs-keyword">if</span> (capacity &lt; <span class="hljs-number">28</span>) &#123;<br>                    LOG.error(<span class="hljs-string">&quot;Got a short response from server &#123;&#125;: &#123;&#125;&quot;</span>, response.sid, capacity);<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br><br>                <span class="hljs-comment">// this is the backwardCompatibility mode in place before ZK-107</span><br>                <span class="hljs-comment">// It is for a version of the protocol in which we didn&#x27;t send peer epoch</span><br>                <span class="hljs-comment">// With peer epoch and version the message became 40 bytes</span><br>                <span class="hljs-keyword">boolean</span> backCompatibility28 = (capacity == <span class="hljs-number">28</span>);<br><br>                <span class="hljs-comment">// this is the backwardCompatibility mode for no version information</span><br>                <span class="hljs-keyword">boolean</span> backCompatibility40 = (capacity == <span class="hljs-number">40</span>);<br><br>                response.buffer.clear();<br><br>                <span class="hljs-comment">// Instantiate Notification and set its attributes</span><br>                Notification n = <span class="hljs-keyword">new</span> Notification();<br><br>                <span class="hljs-keyword">int</span> rstate = response.buffer.getInt();<br>                <span class="hljs-keyword">long</span> rleader = response.buffer.getLong();<br>                <span class="hljs-keyword">long</span> rzxid = response.buffer.getLong();<br>                <span class="hljs-keyword">long</span> relectionEpoch = response.buffer.getLong();<br>                <span class="hljs-keyword">long</span> rpeerepoch;<br><br>                <span class="hljs-keyword">int</span> version = <span class="hljs-number">0x0</span>;<br>                QuorumVerifier rqv = <span class="hljs-keyword">null</span>;<br><br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">if</span> (!backCompatibility28) &#123;<br>                        rpeerepoch = response.buffer.getLong();<br>                        <span class="hljs-keyword">if</span> (!backCompatibility40) &#123;<br>                            <span class="hljs-comment">/*</span><br><span class="hljs-comment">                             * Version added in 3.4.6</span><br><span class="hljs-comment">                             */</span><br><br>                            version = response.buffer.getInt();<br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                            LOG.info(<span class="hljs-string">&quot;Backward compatibility mode (36 bits), server id: &#123;&#125;&quot;</span>, response.sid);<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        LOG.info(<span class="hljs-string">&quot;Backward compatibility mode (28 bits), server id: &#123;&#125;&quot;</span>, response.sid);<br>                        rpeerepoch = ZxidUtils.getEpochFromZxid(rzxid);<br>                    &#125;<br><br>                    <span class="hljs-comment">// check if we have a version that includes config. If so extract config info from message.</span><br>                    <span class="hljs-keyword">if</span> (version &gt; <span class="hljs-number">0x1</span>) &#123;<br>                        <span class="hljs-keyword">int</span> configLength = response.buffer.getInt();<br><br>                        <span class="hljs-comment">// we want to avoid errors caused by the allocation of a byte array with negative length</span><br>                        <span class="hljs-comment">// (causing NegativeArraySizeException) or huge length (causing e.g. OutOfMemoryError)</span><br>                        <span class="hljs-keyword">if</span> (configLength &lt; <span class="hljs-number">0</span> || configLength &gt; capacity) &#123;<br>                            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException(String.format(<span class="hljs-string">&quot;Invalid configLength in notification message! sid=%d, capacity=%d, version=%d, configLength=%d&quot;</span>,<br>                                                                response.sid, capacity, version, configLength));<br>                        &#125;<br><br>                        <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[configLength];<br>                        response.buffer.get(b);<br><br>                        <span class="hljs-keyword">synchronized</span> (self) &#123;<br>                            <span class="hljs-keyword">try</span> &#123;<br>                                rqv = self.configFromString(<span class="hljs-keyword">new</span> String(b, UTF_8));<br>                                QuorumVerifier curQV = self.getQuorumVerifier();<br>                                <span class="hljs-keyword">if</span> (rqv.getVersion() &gt; curQV.getVersion()) &#123;<br>                                    LOG.info(<span class="hljs-string">&quot;&#123;&#125; Received version: &#123;&#125; my version: &#123;&#125;&quot;</span>,<br>                                             self.getId(),<br>                                             Long.toHexString(rqv.getVersion()),<br>                                             Long.toHexString(self.getQuorumVerifier().getVersion()));<br>                                    <span class="hljs-keyword">if</span> (self.getPeerState() == ServerState.LOOKING) &#123;<br>                                        LOG.debug(<span class="hljs-string">&quot;Invoking processReconfig(), state: &#123;&#125;&quot;</span>, self.getServerState());<br>                                        self.processReconfig(rqv, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);<br>                                        <span class="hljs-keyword">if</span> (!rqv.equals(curQV)) &#123;<br>                                            LOG.info(<span class="hljs-string">&quot;restarting leader election&quot;</span>);<br>                                            self.shuttingDownLE = <span class="hljs-keyword">true</span>;<br>                                            self.getElectionAlg().shutdown();<br><br>                                            <span class="hljs-keyword">break</span>;<br>                                        &#125;<br>                                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                                        LOG.debug(<span class="hljs-string">&quot;Skip processReconfig(), state: &#123;&#125;&quot;</span>, self.getServerState());<br>                                    &#125;<br>                                &#125;<br>                            &#125; <span class="hljs-keyword">catch</span> (IOException | ConfigException e) &#123;<br>                                LOG.error(<span class="hljs-string">&quot;Something went wrong while processing config received from &#123;&#125;&quot;</span>, response.sid);<br>                            &#125;<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        LOG.info(<span class="hljs-string">&quot;Backward compatibility mode (before reconfig), server id: &#123;&#125;&quot;</span>, response.sid);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (BufferUnderflowException | IOException e) &#123;<br>                    LOG.warn(<span class="hljs-string">&quot;Skipping the processing of a partial / malformed response message sent by sid=&#123;&#125; (message length: &#123;&#125;)&quot;</span>,<br>                             response.sid, capacity, e);<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-comment">/*</span><br><span class="hljs-comment">                 * If it is from a non-voting server (such as an observer or</span><br><span class="hljs-comment">                 * a non-voting follower), respond right away.</span><br><span class="hljs-comment">                 * 发送给其他服务的投票封装成ToSend，并存入到sendqueue中</span><br><span class="hljs-comment">                 */</span><br>                <span class="hljs-keyword">if</span> (!validVoter(response.sid)) &#123;<br>                    Vote current = self.getCurrentVote();<br>                    QuorumVerifier qv = self.getQuorumVerifier();<br>                    ToSend notmsg = <span class="hljs-keyword">new</span> ToSend(<br>                        ToSend.mType.notification,<br>                        current.getId(),<br>                        current.getZxid(),<br>                        logicalclock.get(),<br>                        self.getPeerState(),<br>                        response.sid,<br>                        current.getPeerEpoch(),<br>                        qv.toString().getBytes(UTF_8));<br><br>                    sendqueue.offer(notmsg);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// Receive new message</span><br>                    LOG.debug(<span class="hljs-string">&quot;Receive new notification message. My id = &#123;&#125;&quot;</span>, self.getId());<br><br>                    <span class="hljs-comment">// State of peer that sent this message</span><br>                    QuorumPeer.ServerState ackstate = QuorumPeer.ServerState.LOOKING;<br>                    <span class="hljs-keyword">switch</span> (rstate) &#123;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>                        ackstate = QuorumPeer.ServerState.LOOKING;<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                        ackstate = QuorumPeer.ServerState.FOLLOWING;<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>                        ackstate = QuorumPeer.ServerState.LEADING;<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>                        ackstate = QuorumPeer.ServerState.OBSERVING;<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">default</span>:<br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125;<br><br>                    n.leader = rleader;<br>                    n.zxid = rzxid;<br>                    n.electionEpoch = relectionEpoch;<br>                    n.state = ackstate;<br>                    n.sid = response.sid;<br>                    n.peerEpoch = rpeerepoch;<br>                    n.version = version;<br>                    n.qv = rqv;<br>                    <span class="hljs-comment">/*</span><br><span class="hljs-comment">                     * Print notification info</span><br><span class="hljs-comment">                     */</span><br>                    LOG.info(<br>                        <span class="hljs-string">&quot;Notification: my state:&#123;&#125;; n.sid:&#123;&#125;, n.state:&#123;&#125;, n.leader:&#123;&#125;, n.round:0x&#123;&#125;, &quot;</span><br>                            + <span class="hljs-string">&quot;n.peerEpoch:0x&#123;&#125;, n.zxid:0x&#123;&#125;, message format version:0x&#123;&#125;, n.config version:0x&#123;&#125;&quot;</span>,<br>                        self.getPeerState(),<br>                        n.sid,<br>                        n.state,<br>                        n.leader,<br>                        Long.toHexString(n.electionEpoch),<br>                        Long.toHexString(n.peerEpoch),<br>                        Long.toHexString(n.zxid),<br>                        Long.toHexString(n.version),<br>                        (n.qv != <span class="hljs-keyword">null</span> ? (Long.toHexString(n.qv.getVersion())) : <span class="hljs-string">&quot;0&quot;</span>));<br><br>                    <span class="hljs-comment">/*</span><br><span class="hljs-comment">                     * If this server is looking, then send proposed leader</span><br><span class="hljs-comment">                     */</span><br><br>                    <span class="hljs-keyword">if</span> (self.getPeerState() == QuorumPeer.ServerState.LOOKING) &#123;<br>                        recvqueue.offer(n);<br><br>                        <span class="hljs-comment">/*</span><br><span class="hljs-comment">                         * Send a notification back if the peer that sent this</span><br><span class="hljs-comment">                         * message is also looking and its logical clock is</span><br><span class="hljs-comment">                         * lagging behind.</span><br><span class="hljs-comment">                         */</span><br>                        <span class="hljs-keyword">if</span> ((ackstate == QuorumPeer.ServerState.LOOKING)<br>                            &amp;&amp; (n.electionEpoch &lt; logicalclock.get())) &#123;<br>                            Vote v = getVote();<br>                            QuorumVerifier qv = self.getQuorumVerifier();<br>                            ToSend notmsg = <span class="hljs-keyword">new</span> ToSend(<br>                                ToSend.mType.notification,<br>                                v.getId(),<br>                                v.getZxid(),<br>                                logicalclock.get(),<br>                                self.getPeerState(),<br>                                response.sid,<br>                                v.getPeerEpoch(),<br>                                qv.toString().getBytes());<br>                            sendqueue.offer(notmsg);<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-comment">/*</span><br><span class="hljs-comment">                         * If this server is not looking, but the one that sent the ack</span><br><span class="hljs-comment">                         * is looking, then send back what it believes to be the leader.</span><br><span class="hljs-comment">                         */</span><br>                        Vote current = self.getCurrentVote();<br>                        <span class="hljs-keyword">if</span> (ackstate == QuorumPeer.ServerState.LOOKING) &#123;<br>                            <span class="hljs-keyword">if</span> (self.leader != <span class="hljs-keyword">null</span>) &#123;<br>                                <span class="hljs-keyword">if</span> (leadingVoteSet != <span class="hljs-keyword">null</span>) &#123;<br>                                    self.leader.setLeadingVoteSet(leadingVoteSet);<br>                                    leadingVoteSet = <span class="hljs-keyword">null</span>;<br>                                &#125;<br>                                self.leader.reportLookingSid(response.sid);<br>                            &#125;<br><br><br>                            LOG.debug(<br>                                <span class="hljs-string">&quot;Sending new notification. My id =&#123;&#125; recipient=&#123;&#125; zxid=0x&#123;&#125; leader=&#123;&#125; config version = &#123;&#125;&quot;</span>,<br>                                self.getId(),<br>                                response.sid,<br>                                Long.toHexString(current.getZxid()),<br>                                current.getId(),<br>                                Long.toHexString(self.getQuorumVerifier().getVersion()));<br><br>                            QuorumVerifier qv = self.getQuorumVerifier();<br>                            ToSend notmsg = <span class="hljs-keyword">new</span> ToSend(<br>                                ToSend.mType.notification,<br>                                current.getId(),<br>                                current.getZxid(),<br>                                current.getElectionEpoch(),<br>                                self.getPeerState(),<br>                                response.sid,<br>                                current.getPeerEpoch(),<br>                                qv.toString().getBytes());<br>                            sendqueue.offer(notmsg);<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                LOG.warn(<span class="hljs-string">&quot;Interrupted Exception while waiting for new message&quot;</span>, e);<br>            &#125;<br>        &#125;<br>        LOG.info(<span class="hljs-string">&quot;WorkerReceiver is down&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="Zookeeper选举投票剖析"><a href="#Zookeeper选举投票剖析" class="headerlink" title="Zookeeper选举投票剖析"></a>Zookeeper选举投票剖析</h4><p>选举是个很复杂的过程，要考虑很多场景，而且选举过程中有很多概念需要理解。</p>
<h5 id="选举概念"><a href="#选举概念" class="headerlink" title="选举概念"></a>选举概念</h5><p>ZK服务状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">ServerState</span> </span>&#123;<br>    <span class="hljs-comment">// 代表没有，当前集群中没有Leader，此时是投票选举状态</span><br>    LOOKING,<br>    <span class="hljs-comment">// 代表已经是伴随者状态</span><br>    FOLLOWING,<br>    <span class="hljs-comment">// 代表已经是领导者状态</span><br>    LEADING,<br>    <span class="hljs-comment">// 代表已经是观察者状态（观察着不参与投票过程）</span><br>    OBSERVING<br>&#125;<br></code></pre></td></tr></table></figure>

<p>服务角色: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">LearnerType</span> </span>&#123;<br>    <span class="hljs-comment">// 随从者角色</span><br>    PARTICIPANT,<br>    <span class="hljs-comment">// 观察者角色</span><br>    OBSERVER<br>&#125;<br></code></pre></td></tr></table></figure>

<p>投票消息广播: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Notification</span> </span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Format version, introduced in 3.4.6</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CURRENTVERSION = <span class="hljs-number">0x2</span>;<br>    <span class="hljs-keyword">int</span> version;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Proposed leader</span><br><span class="hljs-comment">     * 被推荐leader的ID</span><br><span class="hljs-comment">     */</span> <span class="hljs-keyword">long</span> leader;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * zxid of the proposed leader</span><br><span class="hljs-comment">     * 被推荐leader的zxid</span><br><span class="hljs-comment">     */</span> <span class="hljs-keyword">long</span> zxid;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Epoch</span><br><span class="hljs-comment">     * 投票轮次</span><br><span class="hljs-comment">     */</span> <span class="hljs-keyword">long</span> electionEpoch;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * current state of sender</span><br><span class="hljs-comment">     * 当前投票者的服务状态（LOOKING）</span><br><span class="hljs-comment">     */</span> QuorumPeer.ServerState state;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Address of sender</span><br><span class="hljs-comment">     * 当前投票者的ID</span><br><span class="hljs-comment">     */</span> <span class="hljs-keyword">long</span> sid;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * QuorumVerifier作为集群验证器</span><br><span class="hljs-comment">     * 主要完成判断一组server在以给定配置的server列表中，是否能构成集群</span><br><span class="hljs-comment">     */</span><br>    QuorumVerifier qv;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * epoch of the proposed leader</span><br><span class="hljs-comment">     * 被推荐leader的投票轮次</span><br><span class="hljs-comment">     */</span> <span class="hljs-keyword">long</span> peerEpoch;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>选票模型:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vote</span> </span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 投票版本号，作为一个标识</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> version;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 当前服务的ID</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> id;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 当前服务事务ID</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> zxid;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 当前服务投票的轮次</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> electionEpoch;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 被推举服务器的投票轮次</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> peerEpoch;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 当前服务器所处的状态</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ServerState state;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>消息发送对象: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ToSend</span> </span>&#123;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 支持的消息类型 </span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">mType</span> </span>&#123;<br>        <span class="hljs-comment">// 请求</span><br>        crequest,<br>        <span class="hljs-comment">// 确认</span><br>        challenge,<br>        <span class="hljs-comment">// 通知</span><br>        notification,<br>        <span class="hljs-comment">// 确认回执</span><br>        ack<br>    &#125;<br><br>    ToSend(mType type, <span class="hljs-keyword">long</span> leader, <span class="hljs-keyword">long</span> zxid, <span class="hljs-keyword">long</span> electionEpoch, ServerState state, <span class="hljs-keyword">long</span> sid, <span class="hljs-keyword">long</span> peerEpoch, <span class="hljs-keyword">byte</span>[] configData) &#123;<br><br>        <span class="hljs-keyword">this</span>.leader = leader;<br>        <span class="hljs-keyword">this</span>.zxid = zxid;<br>        <span class="hljs-keyword">this</span>.electionEpoch = electionEpoch;<br>        <span class="hljs-keyword">this</span>.state = state;<br>        <span class="hljs-keyword">this</span>.sid = sid;<br>        <span class="hljs-keyword">this</span>.peerEpoch = peerEpoch;<br>        <span class="hljs-keyword">this</span>.configData = configData;<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Proposed leader in the case of notification</span><br><span class="hljs-comment">     * 被投票推举为leader的服务ID</span><br><span class="hljs-comment">     */</span> <span class="hljs-keyword">long</span> leader;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * id contains the tag for acks, and zxid for notifications</span><br><span class="hljs-comment">     */</span> <span class="hljs-keyword">long</span> zxid;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Epoch</span><br><span class="hljs-comment">     * 投票轮次</span><br><span class="hljs-comment">     */</span> <span class="hljs-keyword">long</span> electionEpoch;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Current state;</span><br><span class="hljs-comment">     * 服务状态</span><br><span class="hljs-comment">     */</span> QuorumPeer.ServerState state;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Address of recipient</span><br><span class="hljs-comment">     * 消息接收方服务ID</span><br><span class="hljs-comment">     */</span> <span class="hljs-keyword">long</span> sid;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Used to send a QuorumVerifier (configuration info)</span><br><span class="hljs-comment">     */</span> <span class="hljs-keyword">byte</span>[] configData = dummyData;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Leader epoch</span><br><span class="hljs-comment">     */</span> <span class="hljs-keyword">long</span> peerEpoch;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="选举过程"><a href="#选举过程" class="headerlink" title="选举过程"></a>选举过程</h5><p>QuorumPeer本身是个线程，在集群启动的时候会执行 quorumPeer.start(); ，此时会调用它重写的start() 方法，最后会调用父类的 start() 方法，所以该线程会启动执行，因此会执行它的run方法，而run方法正是选举流程的入口，我们看run方法关键源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">case</span> LOOKING:<br>    LOG.info(<span class="hljs-string">&quot;LOOKING&quot;</span>);<br>    ServerMetrics.getMetrics().LOOKING_COUNT.add(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">if</span> (Boolean.getBoolean(<span class="hljs-string">&quot;readonlymode.enabled&quot;</span>)) &#123;<br>        LOG.info(<span class="hljs-string">&quot;Attempting to start ReadOnlyZooKeeperServer&quot;</span>);<br><br>        <span class="hljs-comment">// Create read-only server but don&#x27;t start it immediately</span><br>        <span class="hljs-keyword">final</span> ReadOnlyZooKeeperServer roZk = <span class="hljs-keyword">new</span> ReadOnlyZooKeeperServer(logFactory, <span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>.zkDb);<br><br>        <span class="hljs-comment">// Instead of starting roZk immediately, wait some grace</span><br>        <span class="hljs-comment">// period before we decide we&#x27;re partitioned.</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">// Thread is used here because otherwise it would require</span><br>        <span class="hljs-comment">// changes in each of election strategy classes which is</span><br>        <span class="hljs-comment">// unnecessary code coupling.</span><br>        Thread roZkMgr = <span class="hljs-keyword">new</span> Thread() &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// lower-bound grace period to 2 secs</span><br>                    sleep(Math.max(<span class="hljs-number">2000</span>, tickTime));<br>                    <span class="hljs-keyword">if</span> (ServerState.LOOKING.equals(getPeerState())) &#123;<br>                        roZk.startup();<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    LOG.info(<span class="hljs-string">&quot;Interrupted while attempting to start ReadOnlyZooKeeperServer, not started&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    LOG.error(<span class="hljs-string">&quot;FAILED to start ReadOnlyZooKeeperServer&quot;</span>, e);<br>                &#125;<br>            &#125;<br>        &#125;;<br>        <span class="hljs-keyword">try</span> &#123;<br>            roZkMgr.start();<br>            reconfigFlagClear();<br>            <span class="hljs-keyword">if</span> (shuttingDownLE) &#123;<br>                shuttingDownLE = <span class="hljs-keyword">false</span>;<br>                startLeaderElection();<br>            &#125;<br>            <span class="hljs-comment">// 选举操作 makeLEStrategy();获取选举算法</span><br>            <span class="hljs-comment">// lookForLeader();选举过程</span><br>            setCurrentVote(makeLEStrategy().lookForLeader());<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            LOG.warn(<span class="hljs-string">&quot;Unexpected exception&quot;</span>, e);<br>            setPeerState(ServerState.LOOKING);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// If the thread is in the the grace period, interrupt</span><br>            <span class="hljs-comment">// to come out of waiting.</span><br>            roZkMgr.interrupt();<br>            roZk.shutdown();<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            reconfigFlagClear();<br>            <span class="hljs-keyword">if</span> (shuttingDownLE) &#123;<br>                shuttingDownLE = <span class="hljs-keyword">false</span>;<br>                startLeaderElection();<br>            &#125;<br>            setCurrentVote(makeLEStrategy().lookForLeader());<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            LOG.warn(<span class="hljs-string">&quot;Unexpected exception&quot;</span>, e);<br>            setPeerState(ServerState.LOOKING);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure>

<p>所有节点初始状态都为LOOKING，会进入到选举流程，选举流程首先要获取算法，获取算法的方法是makeLEStrategy() ，该方法返回的是 FastLeaderElection 实例，核心选举流程是FastLeaderElection 中的 lookForLeader() 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 获取选举算法</span><br><span class="hljs-comment"> * @return</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> Election <span class="hljs-title">makeLEStrategy</span><span class="hljs-params">()</span> </span>&#123;<br>    LOG.debug(<span class="hljs-string">&quot;Initializing leader election protocol...&quot;</span>);<br>    <span class="hljs-keyword">return</span> electionAlg;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>lookForLeader() 是选举过程的关键流程，源码分析如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Vote <span class="hljs-title">lookForLeader</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        self.jmxLeaderElectionBean = <span class="hljs-keyword">new</span> LeaderElectionBean();<br>        MBeanRegistry.getInstance().register(self.jmxLeaderElectionBean, self.jmxLocalPeerBean);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        LOG.warn(<span class="hljs-string">&quot;Failed to register with JMX&quot;</span>, e);<br>        self.jmxLeaderElectionBean = <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    self.start_fle = Time.currentElapsedTime();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * The votes from the current leader election are stored in recvset. In other words, a vote v is in recvset</span><br><span class="hljs-comment">         * if v.electionEpoch == logicalclock. The current participant uses recvset to deduce on whether a majority</span><br><span class="hljs-comment">         * of participants has voted for it.</span><br><span class="hljs-comment">         * 接受的投票票池</span><br><span class="hljs-comment">         */</span><br>        Map&lt;Long, Vote&gt; recvset = <span class="hljs-keyword">new</span> HashMap&lt;Long, Vote&gt;();<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * The votes from previous leader elections, as well as the votes from the current leader election are</span><br><span class="hljs-comment">         * stored in outofelection. Note that notifications in a LOOKING state are not stored in outofelection.</span><br><span class="hljs-comment">         * Only FOLLOWING or LEADING notifications are stored in outofelection. The current participant could use</span><br><span class="hljs-comment">         * outofelection to learn which participant is the leader if it arrives late (i.e., higher logicalclock than</span><br><span class="hljs-comment">         * the electionEpoch of the received notifications) in a leader election.</span><br><span class="hljs-comment">         * 对外的投票记录</span><br><span class="hljs-comment">         */</span><br>        Map&lt;Long, Vote&gt; outofelection = <span class="hljs-keyword">new</span> HashMap&lt;Long, Vote&gt;();<br><br>        <span class="hljs-keyword">int</span> notTimeout = minNotificationInterval;<br><br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-comment">// 投票轮次自增</span><br>            logicalclock.incrementAndGet();<br>            <span class="hljs-comment">// 首次推举自己为leader</span><br>            updateProposal(getInitId(), getInitLastLoggedZxid(), getPeerEpoch());<br>        &#125;<br><br>        LOG.info(<br>            <span class="hljs-string">&quot;New election. My id = &#123;&#125;, proposed zxid=0x&#123;&#125;&quot;</span>,<br>            self.getId(),<br>            Long.toHexString(proposedZxid));<br>        <span class="hljs-comment">// 广播发出投票</span><br>        sendNotifications();<br><br>        SyncedLearnerTracker voteSet;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Loop in which we exchange notifications until we find a leader</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-comment">// 如果当前server状态依然是LOOKING状态，且未选出leader则直到找到为止</span><br>        <span class="hljs-keyword">while</span> ((self.getPeerState() == ServerState.LOOKING) &amp;&amp; (!stop)) &#123;<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             * Remove next notification from queue, times out after 2 times</span><br><span class="hljs-comment">             * the termination time</span><br><span class="hljs-comment">             * 准备接受发来的投票，该过程属于阻塞过程，直到本次阻塞超市，一次取一个</span><br><span class="hljs-comment">             */</span><br>            Notification n = recvqueue.poll(notTimeout, TimeUnit.MILLISECONDS);<br><br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             * Sends more notifications if haven&#x27;t received enough.</span><br><span class="hljs-comment">             * Otherwise processes new notification.</span><br><span class="hljs-comment">             * 如果没有收到足够的投票，就继续发出广播进行投票，否则处理投票信息</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-keyword">if</span> (n == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// 如果集群中有其他节点信息，就开始广播</span><br>                <span class="hljs-keyword">if</span> (manager.haveDelivered()) &#123;<br>                    <span class="hljs-comment">// 开始广播自己的投票信息</span><br>                    sendNotifications();<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 如果服务器不存在，尝试与每个服务器建立连接。</span><br>                    manager.connectAll();<br>                &#125;<br><br>                <span class="hljs-comment">/*</span><br><span class="hljs-comment">                 * Exponential backoff</span><br><span class="hljs-comment">                 * 延长队列获取选票时长</span><br><span class="hljs-comment">                 */</span><br>                <span class="hljs-keyword">int</span> tmpTimeOut = notTimeout * <span class="hljs-number">2</span>;<br>                notTimeout = Math.min(tmpTimeOut, maxNotificationInterval);<br>                LOG.info(<span class="hljs-string">&quot;Notification time out: &#123;&#125; ms&quot;</span>, notTimeout);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (validVoter(n.sid) &amp;&amp; validVoter(n.leader)) &#123;<br>                <span class="hljs-comment">/*</span><br><span class="hljs-comment">                 * Only proceed if the vote comes from a replica in the current or next</span><br><span class="hljs-comment">                 * voting view for a replica in the current or next voting view.</span><br><span class="hljs-comment">                 */</span><br>                <span class="hljs-keyword">switch</span> (n.state) &#123;<br>                <span class="hljs-keyword">case</span> LOOKING:<br>                    <span class="hljs-comment">// 如果当前选举人是LOOKING状态</span><br>                    <span class="hljs-keyword">if</span> (getInitLastLoggedZxid() == -<span class="hljs-number">1</span>) &#123;<br>                        LOG.debug(<span class="hljs-string">&quot;Ignoring notification as our zxid is -1&quot;</span>);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (n.zxid == -<span class="hljs-number">1</span>) &#123;<br>                        LOG.debug(<span class="hljs-string">&quot;Ignoring notification from member with -1 zxid &#123;&#125;&quot;</span>, n.sid);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-comment">// 如果收到服务器轮次的大于自己的，则将自己的轮次设置成最新的，将自己的投票池清空</span><br>                    <span class="hljs-comment">// If notification &gt; current, replace and send messages out</span><br>                    <span class="hljs-keyword">if</span> (n.electionEpoch &gt; logicalclock.get()) &#123;<br>                        logicalclock.set(n.electionEpoch);<br>                        recvset.clear();<br>                        <span class="hljs-comment">// 进行选票PK，如果自己的票没有PK过其他投递的票，则将自己的票变更为其他</span><br>                        <span class="hljs-keyword">if</span> (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch, getInitId(), getInitLastLoggedZxid(), getPeerEpoch())) &#123;<br>                            updateProposal(n.leader, n.zxid, n.peerEpoch);<br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                            updateProposal(getInitId(), getInitLastLoggedZxid(), getPeerEpoch());<br>                        &#125;<br>                        <span class="hljs-comment">// 重新发出投票</span><br>                        sendNotifications();<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n.electionEpoch &lt; logicalclock.get()) &#123;<br>                        <span class="hljs-comment">// 如果收到的轮次小于自己的轮次，不做处理，n的投票无效</span><br>                            LOG.debug(<br>                                <span class="hljs-string">&quot;Notification election epoch is smaller than logicalclock. n.electionEpoch = 0x&#123;&#125;, logicalclock=0x&#123;&#125;&quot;</span>,<br>                                Long.toHexString(n.electionEpoch),<br>                                Long.toHexString(logicalclock.get()));<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch, proposedLeader, proposedZxid, proposedEpoch)) &#123;<br>                        <span class="hljs-comment">// 如果收到的轮次等于自己的轮次，则进行选票PK，如果自己的票没有PK过其他投递的票，则将自己的票边变成其他的</span><br>                        updateProposal(n.leader, n.zxid, n.peerEpoch);<br>                        <span class="hljs-comment">// 重新发出投递</span><br>                        sendNotifications();<br>                    &#125;<br><br>                    LOG.debug(<br>                        <span class="hljs-string">&quot;Adding vote: from=&#123;&#125;, proposed leader=&#123;&#125;, proposed zxid=0x&#123;&#125;, proposed election epoch=0x&#123;&#125;&quot;</span>,<br>                        n.sid,<br>                        n.leader,<br>                        Long.toHexString(n.zxid),<br>                        Long.toHexString(n.electionEpoch));<br><br>                    <span class="hljs-comment">// don&#x27;t care about the version if it&#x27;s in LOOKING state</span><br>                    <span class="hljs-comment">// 将获取到的投票数据放入自己的票池中</span><br>                    recvset.put(n.sid, <span class="hljs-keyword">new</span> Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch));<br><br>                    <span class="hljs-comment">// 统计选票</span><br>                    voteSet = getVoteTracker(recvset, <span class="hljs-keyword">new</span> Vote(proposedLeader, proposedZxid, logicalclock.get(), proposedEpoch));<br><br>                    <span class="hljs-comment">// 判断是否有超过半数的票数是指向同一个服务ID</span><br>                    <span class="hljs-keyword">if</span> (voteSet.hasAllQuorums()) &#123;<br><br>                        <span class="hljs-comment">// 如果此刻在票池汇总还有未取出的投票，则和选举出的投票PK，如果取出的票优于当前推举的投票，则重新投票</span><br>                        <span class="hljs-comment">// Verify if there is any change in the proposed leader</span><br>                        <span class="hljs-keyword">while</span> ((n = recvqueue.poll(finalizeWait, TimeUnit.MILLISECONDS)) != <span class="hljs-keyword">null</span>) &#123;<br>                            <span class="hljs-keyword">if</span> (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch, proposedLeader, proposedZxid, proposedEpoch)) &#123;<br>                                recvqueue.put(n);<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                        &#125;<br><br>                        <span class="hljs-comment">/*</span><br><span class="hljs-comment">                         * This predicate is true once we don&#x27;t read any new</span><br><span class="hljs-comment">                         * relevant message from the reception queue</span><br><span class="hljs-comment">                         */</span><br>                        <span class="hljs-comment">// 如果票池中没有课PK的投票，则就任务选举出来的服务为leader</span><br>                        <span class="hljs-keyword">if</span> (n == <span class="hljs-keyword">null</span>) &#123;<br>                            <span class="hljs-comment">// 修改各个服务的状态</span><br>                            setPeerState(proposedLeader, voteSet);<br>                            Vote endVote = <span class="hljs-keyword">new</span> Vote(proposedLeader, proposedZxid, logicalclock.get(), proposedEpoch);<br>                            <span class="hljs-comment">// 清除投票池</span><br>                            leaveInstance(endVote);<br>                            <span class="hljs-keyword">return</span> endVote;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> OBSERVING:<br>                    LOG.debug(<span class="hljs-string">&quot;Notification from observer: &#123;&#125;&quot;</span>, n.sid);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> FOLLOWING:<br>                <span class="hljs-keyword">case</span> LEADING:<br>                    <span class="hljs-comment">/*</span><br><span class="hljs-comment">                     * Consider all notifications from the same epoch</span><br><span class="hljs-comment">                     * together.</span><br><span class="hljs-comment">                     * 如果新收到的选票发送者角色是leader角色，且选票轮次和自己的选票轮次一样</span><br><span class="hljs-comment">                     */</span><br>                    <span class="hljs-keyword">if</span> (n.electionEpoch == logicalclock.get()) &#123;<br>                        <span class="hljs-comment">// 则将leader角色投递的这张选票放入自己的选票池中</span><br>                        recvset.put(n.sid, <span class="hljs-keyword">new</span> Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch, n.state));<br>                        <span class="hljs-comment">// 判断是否有超过半数的票是推荐了n推荐的leader，且n.leader也确实是LEADING状态</span><br>                        voteSet = getVoteTracker(recvset, <span class="hljs-keyword">new</span> Vote(n.version, n.leader, n.zxid, n.electionEpoch, n.peerEpoch, n.state));<br>                        <span class="hljs-keyword">if</span> (voteSet.hasAllQuorums() &amp;&amp; checkLeader(recvset, n.leader, n.electionEpoch)) &#123;<br>                            <span class="hljs-comment">// 则指定n推荐的为真正的leader同时修改其他服务对应的状态</span><br>                            setPeerState(n.leader, voteSet);<br>                            Vote endVote = <span class="hljs-keyword">new</span> Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch);<br>                            <span class="hljs-comment">// 清空票池</span><br>                            leaveInstance(endVote);<br>                            <span class="hljs-keyword">return</span> endVote;<br>                        &#125;<br>                    &#125;<br><br>                    <span class="hljs-comment">/*</span><br><span class="hljs-comment">                     * Before joining an established ensemble, verify that</span><br><span class="hljs-comment">                     * a majority are following the same leader.</span><br><span class="hljs-comment">                     *</span><br><span class="hljs-comment">                     * Note that the outofelection map also stores votes from the current leader election.</span><br><span class="hljs-comment">                     * See ZOOKEEPER-1732 for more information.</span><br><span class="hljs-comment">                     */</span><br>                    <span class="hljs-comment">// 如果轮次不一样，则将N的投票记录到outofelection中</span><br>                    outofelection.put(n.sid, <span class="hljs-keyword">new</span> Vote(n.version, n.leader, n.zxid, n.electionEpoch, n.peerEpoch, n.state));<br>                    voteSet = getVoteTracker(outofelection, <span class="hljs-keyword">new</span> Vote(n.version, n.leader, n.zxid, n.electionEpoch, n.peerEpoch, n.state));<br>                    <span class="hljs-comment">// 判断是否有超过半数的票数是推荐了n推荐的leader，却n.leader也确实是LEADING状态</span><br>                    <span class="hljs-keyword">if</span> (voteSet.hasAllQuorums() &amp;&amp; checkLeader(outofelection, n.leader, n.electionEpoch)) &#123;<br>                        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>                            <span class="hljs-comment">// 更新当前服务选举轮次</span><br>                            logicalclock.set(n.electionEpoch);<br>                            <span class="hljs-comment">// 则指定n推荐的为真正的leader同时修改其他服务对应的状态</span><br>                            setPeerState(n.leader, voteSet);<br>                        &#125;<br>                        Vote endVote = <span class="hljs-keyword">new</span> Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch);<br>                        <span class="hljs-comment">// 清空票池</span><br>                        leaveInstance(endVote);<br>                        <span class="hljs-keyword">return</span> endVote;<br>                    &#125;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">default</span>:<br>                    LOG.warn(<span class="hljs-string">&quot;Notification state unrecognized: &#123;&#125; (n.state), &#123;&#125;(n.sid)&quot;</span>, n.state, n.sid);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (!validVoter(n.leader)) &#123;<br>                    LOG.warn(<span class="hljs-string">&quot;Ignoring notification for non-cluster member sid &#123;&#125; from sid &#123;&#125;&quot;</span>, n.leader, n.sid);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (!validVoter(n.sid)) &#123;<br>                    LOG.warn(<span class="hljs-string">&quot;Ignoring notification for sid &#123;&#125; from non-quorum member sid &#123;&#125;&quot;</span>, n.leader, n.sid);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (self.jmxLeaderElectionBean != <span class="hljs-keyword">null</span>) &#123;<br>                MBeanRegistry.getInstance().unregister(self.jmxLeaderElectionBean);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            LOG.warn(<span class="hljs-string">&quot;Failed to unregister with JMX&quot;</span>, e);<br>        &#125;<br>        self.jmxLeaderElectionBean = <span class="hljs-keyword">null</span>;<br>        LOG.debug(<span class="hljs-string">&quot;Number of connection processing threads: &#123;&#125;&quot;</span>, manager.getConnectionThreadCount());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面多个地方都用到了过半数以上的方法 hasAllQuorums() 该方法用到了 QuorumMaj 类，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasAllQuorums</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (QuorumVerifierAcksetPair qvAckset : qvAcksetPairs) &#123;<br>        <span class="hljs-comment">// 过半数以上算法过程</span><br>        <span class="hljs-keyword">if</span> (!qvAckset.getQuorumVerifier().containsQuorum(qvAckset.getAckset())) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">containsQuorum</span><span class="hljs-params">(Set&lt;Long&gt; ackSet)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (ackSet.size() &gt; half);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>QuorumMaj 构造函数中体现了过半数以上的操作，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-keyword">this</span>.allMembers = allMembers;<br>    <span class="hljs-keyword">for</span> (QuorumServer qs : allMembers.values()) &#123;<br>        <span class="hljs-comment">// 获取所有角色为PARTICIPANT的成员，Observer不参与投票，所以在过半计算中不计入</span><br>        <span class="hljs-keyword">if</span> (qs.type == LearnerType.PARTICIPANT) &#123;<br>            votingMembers.put(Long.valueOf(qs.id), qs);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            observingMembers.put(Long.valueOf(qs.id), qs);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 半数计算</span><br>    half = votingMembers.size() / <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们来看一下选票PK的方法 totalOrderPredicate() ，该方法其实就是Leader选举规则，规则有如下三个：</p>
<ul>
<li><p>比较 epoche(zxid高32bit)，如果其他节点的epoche比自己的大，选举 epoch大的节点（理由： epoch 表示年代，epoch越大表示数据越新）代码：(newEpoch &gt; curEpoch)； </p>
</li>
<li><p>比较 zxid， 如果epoche相同，就比较两个节点的zxid的大小，选举 zxid大的节点（理由：zxid 表示节点所提交事务最大的id，zxid越大代表该节点的数据越完整）代码：(newEpoch == curEpoch) &amp;&amp; (newZxid &gt; curZxid)； </p>
</li>
<li><p>比较 serviceId，如果 epoch和zxid都相等，就比较服务的serverId，选举 serviceId大的节点（理由： serviceId 表示机器性能，他是在配置zookeeper集群时确定的，所以我们配置zookeeper集群的时候可以把服务性能更高的集群的serverId设置大些，让性能好的机器担任leader角色）代码：(newEpoch == curEpoch) &amp;&amp; ((newZxid == curZxid) &amp;&amp; (newId &gt; curId))。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">totalOrderPredicate</span><span class="hljs-params">(<span class="hljs-keyword">long</span> newId, <span class="hljs-keyword">long</span> newZxid, <span class="hljs-keyword">long</span> newEpoch, <span class="hljs-keyword">long</span> curId, <span class="hljs-keyword">long</span> curZxid, <span class="hljs-keyword">long</span> curEpoch)</span> </span>&#123;<br>    LOG.debug(<br>        <span class="hljs-string">&quot;id: &#123;&#125;, proposed id: &#123;&#125;, zxid: 0x&#123;&#125;, proposed zxid: 0x&#123;&#125;&quot;</span>,<br>        newId,<br>        curId,<br>        Long.toHexString(newZxid),<br>        Long.toHexString(curZxid));<br><br>    <span class="hljs-keyword">if</span> (self.getQuorumVerifier().getWeight(newId) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * We return true if one of the following three cases hold:</span><br><span class="hljs-comment">     * 1- New epoch is higher</span><br><span class="hljs-comment">     * 2- New epoch is the same as current epoch, but new zxid is higher</span><br><span class="hljs-comment">     * 3- New epoch is the same as current epoch, new zxid is the same</span><br><span class="hljs-comment">     *  as current zxid, but server id is higher.</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-keyword">return</span> ((newEpoch &gt; curEpoch)<br>            || ((newEpoch == curEpoch)<br>                &amp;&amp; ((newZxid &gt; curZxid)<br>                    || ((newZxid == curZxid)<br>                        &amp;&amp; (newId &gt; curId)))));<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Zookeeper集群数据同步"><a href="#Zookeeper集群数据同步" class="headerlink" title="Zookeeper集群数据同步"></a>Zookeeper集群数据同步</h3><p>所有事务操作都将由leader执行，并且会把数据同步到其他节点，比如follower、observer，我们可以分析leader和follower的操作行为即可分析出数据同步流程。</p>
<h4 id="Zookeeper同步流程说明"><a href="#Zookeeper同步流程说明" class="headerlink" title="Zookeeper同步流程说明"></a>Zookeeper同步流程说明</h4><p><img src="/blog/2021/01/19/Zookeeper/Zookeeper%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8B/pic8.png" srcset="/blog/img/loading.gif" lazyload></p>
<p>整体流程：</p>
<ol>
<li><p>当角色确立之后，leader调用leader.lead();方法运行，创建一个接收连接的LearnerCnxAcceptor线程，在LearnerCnxAcceptor线程内部又建立一个阻塞的 LearnerCnxAcceptorHandler线程等待Learner端的连接。Learner端以follower为例，follower 调用follower.followLeader();方法首先查找leader的Socket服务端，然后建立连接。当follower 建立连接后，leader端会建立一个LearnerHandler线程相对应，用来处理follower与leader的数据包 传输。 </p>
</li>
<li><p>follower端封装当前zk服务器的Zxid和Leader.FOLLOWERINFO的LearnerInfo数据包发送给 leader </p>
</li>
<li><p>leader端这时处于getEpochToPropose方法的阻塞时期，需要得到Learner端超过一半的服务器发送 Epoch </p>
</li>
<li><p>getEpochToPropose解阻塞之后，LearnerHandler线程会把超过一半的Epoch与leader比较得到最新的newLeaderZxid，并封装成Leader.LEADERINFO包发送给Learner端 </p>
</li>
<li><p>Learner端得到最新的Epoch，会更新当前服务器的Epoch。并把当前服务器所处的lastLoggedZxid 位置封装成Leader.ACKEPOCH发送给leader </p>
</li>
<li><p>此时leader端处于waitForEpochAck方法的阻塞时期，需要得到Learner端超过一半的服务器发送EpochACK </p>
</li>
<li><p>当waitForEpochAck阻塞之后便可以在LearnerHandler线程内决定用那种方式进行同步。如果 Learner端的lastLoggedZxid&gt;leader端的，Learner端将会被删除多余的部分。如果小于leader端的，将会以不同方式进行同步 </p>
</li>
<li><p>leader端发送Leader.NEWLEADER数据包给Learner端（6、7步骤都是另开一个线程来发送这些数据包）</p>
</li>
<li><p>Learner端同步之后，会在一个while循环内处理各种leader端发送数据包，包括两阶段提交的 Leader.PROPOSAL、Leader.COMMIT、Leader.INFORM等。在同步数据后会处理Leader.NEWLEADER数据包，然后发送Leader.ACK给leader端 </p>
</li>
<li><p>此时leader端处于waitForNewLeaderAck阻塞等待超过一半节点发送ACK。</p>
</li>
</ol>
<h4 id="Zookeeper-Follower同步流程"><a href="#Zookeeper-Follower同步流程" class="headerlink" title="Zookeeper Follower同步流程"></a>Zookeeper Follower同步流程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">case</span> FOLLOWING:<br>    <span class="hljs-keyword">try</span> &#123;<br>        LOG.info(<span class="hljs-string">&quot;FOLLOWING&quot;</span>);<br>        <span class="hljs-comment">// 创建Follower对象，并且设置Follower</span><br>        setFollower(makeFollower(logFactory));<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 这里会进行一个死循环，主要逻辑：</span><br><span class="hljs-comment">         * 1. 链接Leader</span><br><span class="hljs-comment">         * 2. 和Leader进行数据同步</span><br><span class="hljs-comment">         * 3. 同步完毕后，正常接收Leader的请求，并且执行对应的逻辑，包括Request、Propose、Commit等请求</span><br><span class="hljs-comment">         */</span><br>        follower.followLeader();<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        LOG.warn(<span class="hljs-string">&quot;Unexpected exception&quot;</span>, e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 如果集群超过半数服务宕机或者Leader宕机，先进行shutdown(),然后设置状态为LOOKING，会重新触发选举</span><br>        follower.shutdown();<br>        setFollower(<span class="hljs-keyword">null</span>);<br>        updateServerState();<br>    &#125;<br>    <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure>

<p>创建Follower的方法比较简单，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Follower <span class="hljs-title">makeFollower</span><span class="hljs-params">(FileTxnSnapLog logFactory)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Follower(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">new</span> FollowerZooKeeperServer(logFactory, <span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>.zkDb));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们看一下整个Follower在数据同步中做的所有操作 follower.followLeader(); ，源码如下；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">followLeader</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    self.end_fle = Time.currentElapsedTime();<br>    <span class="hljs-keyword">long</span> electionTimeTaken = self.end_fle - self.start_fle;<br>    self.setElectionTimeTaken(electionTimeTaken);<br>    ServerMetrics.getMetrics().ELECTION_TIME.add(electionTimeTaken);<br>    LOG.info(<span class="hljs-string">&quot;FOLLOWING - LEADER ELECTION TOOK - &#123;&#125; &#123;&#125;&quot;</span>, electionTimeTaken, QuorumPeer.FLE_TIME_UNIT);<br>    self.start_fle = <span class="hljs-number">0</span>;<br>    self.end_fle = <span class="hljs-number">0</span>;<br>    fzk.registerJMX(<span class="hljs-keyword">new</span> FollowerBean(<span class="hljs-keyword">this</span>, zk), self.jmxLocalPeerBean);<br><br>    <span class="hljs-keyword">long</span> connectionTime = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">boolean</span> completedSync = <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        self.setZabState(QuorumPeer.ZabState.DISCOVERY);<br>        <span class="hljs-comment">// 寻找Leader</span><br>        QuorumServer leaderServer = findLeader();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 创建链接</span><br>            connectToLeader(leaderServer.addr, leaderServer.hostname);<br>            <span class="hljs-comment">// 注册Follower，会将当前Follower节点信息发送给Leader节点</span><br>            connectionTime = System.currentTimeMillis();<br>            <span class="hljs-keyword">long</span> newEpochZxid = registerWithLeader(Leader.FOLLOWERINFO);<br>            <span class="hljs-keyword">if</span> (self.isReconfigStateChange()) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">&quot;learned about role change&quot;</span>);<br>            &#125;<br>            <span class="hljs-comment">//check to see if the leader zxid is lower than ours</span><br>            <span class="hljs-comment">//this should never happen but is just a safety check</span><br>            <span class="hljs-keyword">long</span> newEpoch = ZxidUtils.getEpochFromZxid(newEpochZxid);<br>            <span class="hljs-keyword">if</span> (newEpoch &lt; self.getAcceptedEpoch()) &#123;<br>                LOG.error(<span class="hljs-string">&quot;Proposed leader epoch &quot;</span><br>                          + ZxidUtils.zxidToString(newEpochZxid)<br>                          + <span class="hljs-string">&quot; is less than our accepted epoch &quot;</span><br>                          + ZxidUtils.zxidToString(self.getAcceptedEpoch()));<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">&quot;Error: Epoch of leader is lower&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">long</span> startTime = Time.currentElapsedTime();<br>            <span class="hljs-keyword">try</span> &#123;<br>                self.setLeaderAddressAndId(leaderServer.addr, leaderServer.getId());<br>                self.setZabState(QuorumPeer.ZabState.SYNCHRONIZATION);<br>                <span class="hljs-comment">// 和Leader同步历史数据</span><br>                syncWithLeader(newEpochZxid);<br>                self.setZabState(QuorumPeer.ZabState.BROADCAST);<br>                completedSync = <span class="hljs-keyword">true</span>;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-keyword">long</span> syncTime = Time.currentElapsedTime() - startTime;<br>                ServerMetrics.getMetrics().FOLLOWER_SYNC_TIME.add(syncTime);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (self.getObserverMasterPort() &gt; <span class="hljs-number">0</span>) &#123;<br>                LOG.info(<span class="hljs-string">&quot;Starting ObserverMaster&quot;</span>);<br><br>                om = <span class="hljs-keyword">new</span> ObserverMaster(self, fzk, self.getObserverMasterPort());<br>                om.start();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                om = <span class="hljs-keyword">null</span>;<br>            &#125;<br>            <span class="hljs-comment">// create a reusable packet to reduce gc impact</span><br>            <span class="hljs-comment">// 读取Leader发送的数据包</span><br>            QuorumPacket qp = <span class="hljs-keyword">new</span> QuorumPacket();<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.isRunning()) &#123;<br>                readPacket(qp);<br>                processPacket(qp);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            LOG.warn(<span class="hljs-string">&quot;Exception when following the leader&quot;</span>, e);<br>            closeSocket();<br><br>            <span class="hljs-comment">// clear pending revalidations</span><br>            pendingRevalidations.clear();<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (om != <span class="hljs-keyword">null</span>) &#123;<br>            om.stop();<br>        &#125;<br>        zk.unregisterJMX(<span class="hljs-keyword">this</span>);<br><br>        <span class="hljs-keyword">if</span> (connectionTime != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">long</span> connectionDuration = System.currentTimeMillis() - connectionTime;<br>            LOG.info(<br>                <span class="hljs-string">&quot;Disconnected from leader (with address: &#123;&#125;). Was connected for &#123;&#125;ms. Sync state: &#123;&#125;&quot;</span>,<br>                leaderAddr,<br>                connectionDuration,<br>                completedSync);<br>            messageTracker.dumpToLog(leaderAddr.toString());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面源码中的 follower.followLeader() 方法主要做了如下几件事：</p>
<ol>
<li>寻找Leader </li>
<li>和Leader创建链接 </li>
<li>向Leader注册Follower，会将当前Follower节点信息发送给Leader节点 </li>
<li>和Leader同步历史数据 </li>
<li>读取Leader发送的数据包 </li>
<li>同步Leader数据包</li>
</ol>
<p>对 follower.followLeader() 调用的其他方法进行剖析，其中 findLeader() 是寻找当前Leader节点的，源代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> QuorumServer <span class="hljs-title">findLeader</span><span class="hljs-params">()</span> </span>&#123;<br>    QuorumServer leaderServer = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">// Find the leader by id</span><br>    <span class="hljs-comment">// 获取当前投票选出的Leader</span><br>    Vote current = self.getCurrentVote();<br>    <span class="hljs-comment">// 循环查找Leader</span><br>    <span class="hljs-keyword">for</span> (QuorumServer s : self.getView().values()) &#123;<br>        <span class="hljs-keyword">if</span> (s.id == current.getId()) &#123;<br>            <span class="hljs-comment">// Ensure we have the leader&#x27;s correct IP address before</span><br>            <span class="hljs-comment">// attempting to connect.</span><br>            s.recreateSocketAddresses();<br>            leaderServer = s;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (leaderServer == <span class="hljs-keyword">null</span>) &#123;<br>        LOG.warn(<span class="hljs-string">&quot;Couldn&#x27;t find the leader with id = &#123;&#125;&quot;</span>, current.getId());<br>    &#125;<br>    <span class="hljs-keyword">return</span> leaderServer;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>followLeader() 中调用了 registerWithLeader(Leader.FOLLOWERINFO); 该方法是向Leader注册Follower，会将当前Follower节点信息发送给Leader节点，Follower节点信息发给Leader是必须的，是Leader同步数据个基础，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">long</span> <span class="hljs-title">registerWithLeader</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pktType)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Send follower info, including last zxid and sid</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">long</span> lastLoggedZxid = self.getLastLoggedZxid();<br>    QuorumPacket qp = <span class="hljs-keyword">new</span> QuorumPacket();<br>    qp.setType(pktType);<br>    qp.setZxid(ZxidUtils.makeZxid(self.getAcceptedEpoch(), <span class="hljs-number">0</span>));<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Add sid to payload</span><br><span class="hljs-comment">     */</span><br>    LearnerInfo li = <span class="hljs-keyword">new</span> LearnerInfo(self.getId(), <span class="hljs-number">0x10000</span>, self.getQuorumVerifier().getVersion());<br>    ByteArrayOutputStream bsid = <span class="hljs-keyword">new</span> ByteArrayOutputStream();<br>    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(bsid);<br>    boa.writeRecord(li, <span class="hljs-string">&quot;LearnerInfo&quot;</span>);<br>    qp.setData(bsid.toByteArray());<br>    <span class="hljs-comment">// 向Leader写数据包</span><br>    writePacket(qp, <span class="hljs-keyword">true</span>);<br>    readPacket(qp);<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> newEpoch = ZxidUtils.getEpochFromZxid(qp.getZxid());<br>    <span class="hljs-keyword">if</span> (qp.getType() == Leader.LEADERINFO) &#123;<br>        <span class="hljs-comment">// we are connected to a 1.0 server so accept the new epoch and read the next packet</span><br>        leaderProtocolVersion = ByteBuffer.wrap(qp.getData()).getInt();<br>        <span class="hljs-keyword">byte</span>[] epochBytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">4</span>];<br>        <span class="hljs-keyword">final</span> ByteBuffer wrappedEpochBytes = ByteBuffer.wrap(epochBytes);<br>        <span class="hljs-keyword">if</span> (newEpoch &gt; self.getAcceptedEpoch()) &#123;<br>            wrappedEpochBytes.putInt((<span class="hljs-keyword">int</span>) self.getCurrentEpoch());<br>            self.setAcceptedEpoch(newEpoch);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newEpoch == self.getAcceptedEpoch()) &#123;<br>            <span class="hljs-comment">// since we have already acked an epoch equal to the leaders, we cannot ack</span><br>            <span class="hljs-comment">// again, but we still need to send our lastZxid to the leader so that we can</span><br>            <span class="hljs-comment">// sync with it if it does assume leadership of the epoch.</span><br>            <span class="hljs-comment">// the -1 indicates that this reply should not count as an ack for the new epoch</span><br>            wrappedEpochBytes.putInt(-<span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">&quot;Leaders epoch, &quot;</span><br>                                  + newEpoch<br>                                  + <span class="hljs-string">&quot; is less than accepted epoch, &quot;</span><br>                                  + self.getAcceptedEpoch());<br>        &#125;<br>        <span class="hljs-comment">// 向Leader写ackNewEpoch</span><br>        QuorumPacket ackNewEpoch = <span class="hljs-keyword">new</span> QuorumPacket(Leader.ACKEPOCH, lastLoggedZxid, epochBytes, <span class="hljs-keyword">null</span>);<br>        writePacket(ackNewEpoch, <span class="hljs-keyword">true</span>);<br>        <span class="hljs-keyword">return</span> ZxidUtils.makeZxid(newEpoch, <span class="hljs-number">0</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (newEpoch &gt; self.getAcceptedEpoch()) &#123;<br>            self.setAcceptedEpoch(newEpoch);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (qp.getType() != Leader.NEWLEADER) &#123;<br>            LOG.error(<span class="hljs-string">&quot;First packet should have been NEWLEADER&quot;</span>);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">&quot;First packet should have been NEWLEADER&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> qp.getZxid();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>followLeader() 中最后读取数据包执行同步的方法中调用了 readPacket(qp); ，这个方法就是读取Leader的数据包的封装，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">readPacket</span><span class="hljs-params">(QuorumPacket pp)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-keyword">synchronized</span> (leaderIs) &#123;<br>        leaderIs.readRecord(pp, <span class="hljs-string">&quot;packet&quot;</span>);<br>        messageTracker.trackReceived(pp.getType());<br>    &#125;<br>    <span class="hljs-keyword">if</span> (LOG.isTraceEnabled()) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> traceMask =<br>            (pp.getType() == Leader.PING) ? ZooTrace.SERVER_PING_TRACE_MASK<br>                : ZooTrace.SERVER_PACKET_TRACE_MASK;<br><br>        ZooTrace.logQuorumPacket(LOG, traceMask, <span class="hljs-string">&#x27;i&#x27;</span>, pp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="Zookeeper-Leader同步流程"><a href="#Zookeeper-Leader同步流程" class="headerlink" title="Zookeeper Leader同步流程"></a>Zookeeper Leader同步流程</h4><p>我们查看 QuorumPeer.run() 方法的LEADING部分，可以看到先创建了Leader对象，并设置了Leader，然后调用了 leader.lead() ， leader.lead() 是执行的核心业务流程，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">case</span> LEADING:<br>    LOG.info(<span class="hljs-string">&quot;LEADING&quot;</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 创建Leader对象，并且设置Leader</span><br>        setLeader(makeLeader(logFactory));<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 进行死循环，主要逻辑为：</span><br><span class="hljs-comment">         * 1. 接受Follower的链接</span><br><span class="hljs-comment">         * 2. 进行Follower数据同步</span><br><span class="hljs-comment">         * 3. 同步完成后，正常接受请求（主要包括客户端发来的请求、集群Follower转发的事务请求等等）</span><br><span class="hljs-comment">         */</span><br>        leader.lead();<br>        <span class="hljs-comment">// 如果集群超过半数服务宕机，首先设置Leader对象为null</span><br>        setLeader(<span class="hljs-keyword">null</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        LOG.warn(<span class="hljs-string">&quot;Unexpected exception&quot;</span>, e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (leader != <span class="hljs-keyword">null</span>) &#123;<br>            leader.shutdown(<span class="hljs-string">&quot;Forcing shutdown&quot;</span>);<br>            setLeader(<span class="hljs-keyword">null</span>);<br>        &#125;<br>        <span class="hljs-comment">// 设置zk状态为LOOKING，重新触发选举</span><br>        updateServerState();<br>    &#125;<br>    <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>leader.lead() 方法是Leader执行的核心业务流程，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lead</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException </span>&#123;<br>    self.end_fle = Time.currentElapsedTime();<br>    <span class="hljs-keyword">long</span> electionTimeTaken = self.end_fle - self.start_fle;<br>    self.setElectionTimeTaken(electionTimeTaken);<br>    ServerMetrics.getMetrics().ELECTION_TIME.add(electionTimeTaken);<br>    LOG.info(<span class="hljs-string">&quot;LEADING - LEADER ELECTION TOOK - &#123;&#125; &#123;&#125;&quot;</span>, electionTimeTaken, QuorumPeer.FLE_TIME_UNIT);<br>    self.start_fle = <span class="hljs-number">0</span>;<br>    self.end_fle = <span class="hljs-number">0</span>;<br><br>    zk.registerJMX(<span class="hljs-keyword">new</span> LeaderBean(<span class="hljs-keyword">this</span>, zk), self.jmxLocalPeerBean);<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        self.setZabState(QuorumPeer.ZabState.DISCOVERY);<br>        self.tick.set(<span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 从快照和事务日志中加载数据</span><br>        zk.loadData();<br><br>        leaderStateSummary = <span class="hljs-keyword">new</span> StateSummary(self.getCurrentEpoch(), zk.getLastProcessedZxid());<br><br>        <span class="hljs-comment">// Start thread that waits for connection requests from</span><br>        <span class="hljs-comment">// new followers.</span><br>        <span class="hljs-comment">// 创建一个线程，接受Follower/Observer的链接</span><br>        cnxAcceptor = <span class="hljs-keyword">new</span> LearnerCnxAcceptor();<br>        <span class="hljs-comment">// 开启线程</span><br>        cnxAcceptor.start();<br><br>        <span class="hljs-comment">// 阻塞等待超过一半的（Follower和Observer）链接，才会往下执行，返回新的epoch</span><br>        <span class="hljs-keyword">long</span> epoch = getEpochToPropose(self.getId(), self.getAcceptedEpoch());<br>        <span class="hljs-comment">// 根据新的epoch，设置新的起始zxid</span><br>        zk.setZxid(ZxidUtils.makeZxid(epoch, <span class="hljs-number">0</span>));<br><br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            lastProposed = zk.getZxid();<br>        &#125;<br><br>        newLeaderProposal.packet = <span class="hljs-keyword">new</span> QuorumPacket(NEWLEADER, zk.getZxid(), <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<br><br>        <span class="hljs-keyword">if</span> ((newLeaderProposal.packet.getZxid() &amp; <span class="hljs-number">0xffffffffL</span>) != <span class="hljs-number">0</span>) &#123;<br>            LOG.info(<span class="hljs-string">&quot;NEWLEADER proposal has Zxid of &#123;&#125;&quot;</span>, Long.toHexString(newLeaderProposal.packet.getZxid()));<br>        &#125;<br><br>        QuorumVerifier lastSeenQV = self.getLastSeenQuorumVerifier();<br>        QuorumVerifier curQV = self.getQuorumVerifier();<br>        <span class="hljs-keyword">if</span> (curQV.getVersion() == <span class="hljs-number">0</span> &amp;&amp; curQV.getVersion() == lastSeenQV.getVersion()) &#123;<br>            <span class="hljs-comment">// This was added in ZOOKEEPER-1783. The initial config has version 0 (not explicitly</span><br>            <span class="hljs-comment">// specified by the user; the lack of version in a config file is interpreted as version=0).</span><br>            <span class="hljs-comment">// As soon as a config is established we would like to increase its version so that it</span><br>            <span class="hljs-comment">// takes presedence over other initial configs that were not established (such as a config</span><br>            <span class="hljs-comment">// of a server trying to join the ensemble, which may be a partial view of the system, not the full config).</span><br>            <span class="hljs-comment">// We chose to set the new version to the one of the NEWLEADER message. However, before we can do that</span><br>            <span class="hljs-comment">// there must be agreement on the new version, so we can only change the version when sending/receiving UPTODATE,</span><br>            <span class="hljs-comment">// not when sending/receiving NEWLEADER. In other words, we can&#x27;t change curQV here since its the committed quorum verifier,</span><br>            <span class="hljs-comment">// and there&#x27;s still no agreement on the new version that we&#x27;d like to use. Instead, we use</span><br>            <span class="hljs-comment">// lastSeenQuorumVerifier which is being sent with NEWLEADER message</span><br>            <span class="hljs-comment">// so its a good way to let followers know about the new version. (The original reason for sending</span><br>            <span class="hljs-comment">// lastSeenQuorumVerifier with NEWLEADER is so that the leader completes any potentially uncommitted reconfigs</span><br>            <span class="hljs-comment">// that it finds before starting to propose operations. Here we&#x27;re reusing the same code path for</span><br>            <span class="hljs-comment">// reaching consensus on the new version number.)</span><br><br>            <span class="hljs-comment">// It is important that this is done before the leader executes waitForEpochAck,</span><br>            <span class="hljs-comment">// so before LearnerHandlers return from their waitForEpochAck</span><br>            <span class="hljs-comment">// hence before they construct the NEWLEADER message containing</span><br>            <span class="hljs-comment">// the last-seen-quorumverifier of the leader, which we change below</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                LOG.debug(String.format(<span class="hljs-string">&quot;set lastSeenQuorumVerifier to currentQuorumVerifier (%s)&quot;</span>, curQV.toString()));<br>                QuorumVerifier newQV = self.configFromString(curQV.toString());<br>                newQV.setVersion(zk.getZxid());<br>                self.setLastSeenQuorumVerifier(newQV, <span class="hljs-keyword">true</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException(e);<br>            &#125;<br>        &#125;<br><br>        newLeaderProposal.addQuorumVerifier(self.getQuorumVerifier());<br>        <span class="hljs-keyword">if</span> (self.getLastSeenQuorumVerifier().getVersion() &gt; self.getQuorumVerifier().getVersion()) &#123;<br>            newLeaderProposal.addQuorumVerifier(self.getLastSeenQuorumVerifier());<br>        &#125;<br><br>        <span class="hljs-comment">// We have to get at least a majority of servers in sync with</span><br>        <span class="hljs-comment">// us. We do this by waiting for the NEWLEADER packet to get</span><br>        <span class="hljs-comment">// acknowledged</span><br>        <span class="hljs-comment">// 阻塞等待超过一半的（Follower和Observer）获取了新的epoch，并且返回了Leader.ACKEPOCH</span><br>        waitForEpochAck(self.getId(), leaderStateSummary);<br>        <span class="hljs-comment">// 设置当前新的epoch</span><br>        self.setCurrentEpoch(epoch);<br>        self.setLeaderAddressAndId(self.getQuorumAddress(), self.getId());<br>        self.setZabState(QuorumPeer.ZabState.SYNCHRONIZATION);<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 阻塞等待拆过一半的（Follower和Observer）进行数据同步成功，并且返回了Leader.ACK</span><br>            waitForNewLeaderAck(self.getId(), zk.getZxid());<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            shutdown(<span class="hljs-string">&quot;Waiting for a quorum of followers, only synced with sids: [ &quot;</span><br>                     + newLeaderProposal.ackSetsToString()<br>                     + <span class="hljs-string">&quot; ]&quot;</span>);<br>            HashSet&lt;Long&gt; followerSet = <span class="hljs-keyword">new</span> HashSet&lt;Long&gt;();<br><br>            <span class="hljs-keyword">for</span> (LearnerHandler f : getLearners()) &#123;<br>                <span class="hljs-keyword">if</span> (self.getQuorumVerifier().getVotingMembers().containsKey(f.getSid())) &#123;<br>                    followerSet.add(f.getSid());<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">boolean</span> initTicksShouldBeIncreased = <span class="hljs-keyword">true</span>;<br>            <span class="hljs-keyword">for</span> (Proposal.QuorumVerifierAcksetPair qvAckset : newLeaderProposal.qvAcksetPairs) &#123;<br>                <span class="hljs-keyword">if</span> (!qvAckset.getQuorumVerifier().containsQuorum(followerSet)) &#123;<br>                    initTicksShouldBeIncreased = <span class="hljs-keyword">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (initTicksShouldBeIncreased) &#123;<br>                LOG.warn(<span class="hljs-string">&quot;Enough followers present. Perhaps the initTicks need to be increased.&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 集群中数据同步已经完成，开启zkServer，并且同时开启请求调用链，接受并执行请求</span><br>        startZkServer();<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * WARNING: do not use this for anything other than QA testing</span><br><span class="hljs-comment">         * on a real cluster. Specifically to enable verification that quorum</span><br><span class="hljs-comment">         * can handle the lower 32bit roll-over issue identified in</span><br><span class="hljs-comment">         * ZOOKEEPER-1277. Without this option it would take a very long</span><br><span class="hljs-comment">         * time (on order of a month say) to see the 4 billion writes</span><br><span class="hljs-comment">         * necessary to cause the roll-over to occur.</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * This field allows you to override the zxid of the server. Typically</span><br><span class="hljs-comment">         * you&#x27;ll want to set it to something like 0xfffffff0 and then</span><br><span class="hljs-comment">         * start the quorum, run some operations and see the re-election.</span><br><span class="hljs-comment">         */</span><br>        String initialZxid = System.getProperty(<span class="hljs-string">&quot;zookeeper.testingonly.initialZxid&quot;</span>);<br>        <span class="hljs-keyword">if</span> (initialZxid != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">long</span> zxid = Long.parseLong(initialZxid);<br>            zk.setZxid((zk.getZxid() &amp; <span class="hljs-number">0xffffffff00000000L</span>) | zxid);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (!System.getProperty(<span class="hljs-string">&quot;zookeeper.leaderServes&quot;</span>, <span class="hljs-string">&quot;yes&quot;</span>).equals(<span class="hljs-string">&quot;no&quot;</span>)) &#123;<br>            self.setZooKeeperServer(zk);<br>        &#125;<br><br>        self.setZabState(QuorumPeer.ZabState.BROADCAST);<br>        self.adminServer.setZooKeeperServer(zk);<br><br>        <span class="hljs-comment">// We ping twice a tick, so we only update the tick every other</span><br>        <span class="hljs-comment">// iteration</span><br>        <span class="hljs-keyword">boolean</span> tickSkip = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-comment">// If not null then shutdown this leader</span><br>        String shutdownMessage = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-comment">// 进行死循环，每次休眠self.tickTime / 2，和所有的（Observer/Follower）发起心跳检测</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>                <span class="hljs-keyword">long</span> start = Time.currentElapsedTime();<br>                <span class="hljs-keyword">long</span> cur = start;<br>                <span class="hljs-keyword">long</span> end = start + self.tickTime / <span class="hljs-number">2</span>;<br>                <span class="hljs-keyword">while</span> (cur &lt; end) &#123;<br>                    wait(end - cur);<br>                    cur = Time.currentElapsedTime();<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (!tickSkip) &#123;<br>                    self.tick.incrementAndGet();<br>                &#125;<br><br>                <span class="hljs-comment">// We use an instance of SyncedLearnerTracker to</span><br>                <span class="hljs-comment">// track synced learners to make sure we still have a</span><br>                <span class="hljs-comment">// quorum of current (and potentially next pending) view.</span><br>                SyncedLearnerTracker syncedAckSet = <span class="hljs-keyword">new</span> SyncedLearnerTracker();<br>                syncedAckSet.addQuorumVerifier(self.getQuorumVerifier());<br>                <span class="hljs-keyword">if</span> (self.getLastSeenQuorumVerifier() != <span class="hljs-keyword">null</span><br>                    &amp;&amp; self.getLastSeenQuorumVerifier().getVersion() &gt; self.getQuorumVerifier().getVersion()) &#123;<br>                    syncedAckSet.addQuorumVerifier(self.getLastSeenQuorumVerifier());<br>                &#125;<br>                <br>                <span class="hljs-comment">// 将Follower加入该容器</span><br>                syncedAckSet.addAck(self.getId());<br><br>                <span class="hljs-keyword">for</span> (LearnerHandler f : getLearners()) &#123;<br>                    <span class="hljs-keyword">if</span> (f.synced()) &#123;<br>                        syncedAckSet.addAck(f.getSid());<br>                    &#125;<br>                &#125;<br><br>                <span class="hljs-comment">// check leader running status</span><br>                <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.isRunning()) &#123;<br>                    <span class="hljs-comment">// set shutdown flag</span><br>                    shutdownMessage = <span class="hljs-string">&quot;Unexpected internal error&quot;</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <br>                <span class="hljs-comment">// 判断是否有超过一般的Follower在集群中</span><br>                <span class="hljs-keyword">if</span> (!tickSkip &amp;&amp; !syncedAckSet.hasAllQuorums()) &#123;<br>                    <span class="hljs-comment">// Lost quorum of last committed and/or last proposed</span><br>                    <span class="hljs-comment">// config, set shutdown flag</span><br>                    <span class="hljs-comment">// 如果没有，就调用shutdown关闭一些对象，然后return，重新选举</span><br>                    shutdownMessage = <span class="hljs-string">&quot;Not sufficient followers synced, only synced with sids: [ &quot;</span><br>                                      + syncedAckSet.ackSetsToString()<br>                                      + <span class="hljs-string">&quot; ]&quot;</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                tickSkip = !tickSkip;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (LearnerHandler f : getLearners()) &#123;<br>                f.ping();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (shutdownMessage != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 没有过半Follower在集群中，调用shutdown关闭一些对象，重新选举</span><br>            shutdown(shutdownMessage);<br>            <span class="hljs-comment">// leader goes in looking state</span><br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        zk.unregisterJMX(<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>leader.lead() 方法会执行如下几个操作：</p>
<ol>
<li>从快照和事务日志中加载数据</li>
<li>创建一个线程，接收Follower/Observer的连接</li>
<li>等待超过一半的(Follower和Observer)连接，再继续往下执行程序</li>
<li>等待超过一半的(Follower和Observer)获取了新的epoch，并且返回了Leader.ACKEPOCH，再继续往下执行程序</li>
<li>等待超过一半的(Follower和Observer)进行数据同步成功，并且返回了Leader.ACK，再继续往下执行程序</li>
<li>数据同步完成，开启zkServer，并且同时开启请求调用链接收请求执行</li>
<li>进行一个死循环，每次休眠self.tickTime / 2，和对所有的(Observer/Follower)发起心跳检测</li>
<li>集群中没有过半Follower在集群中，调用shutdown关闭一些对象，重新选举</li>
</ol>
<p>lead() 方法中会创建 LearnerCnxAcceptor ，该对象是一个线程，主要用于接收followers的连接，这里加了CountDownLatch根据配置的同步的地址的数量（例如：server.2=127.0.0.1:12881:13881 配置同步的端口是12881只有一个）， LearnerCnxAcceptor 的run方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!stop.get() &amp;&amp; !serverSockets.isEmpty()) &#123;<br>        ExecutorService executor = Executors.newFixedThreadPool(serverSockets.size());<br>        CountDownLatch latch = <span class="hljs-keyword">new</span> CountDownLatch(serverSockets.size());<br><br>        <span class="hljs-comment">// 创建socket链接，并等待Follower节点链接</span><br>        serverSockets.forEach(serverSocket -&gt;<br>                executor.submit(<span class="hljs-keyword">new</span> LearnerCnxAcceptorHandler(serverSocket, latch)));<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 阻塞等待</span><br>            latch.await();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException ie) &#123;<br>            LOG.error(<span class="hljs-string">&quot;Interrupted while sleeping in LearnerCnxAcceptor.&quot;</span>, ie);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            closeSockets();<br>            executor.shutdown();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (!executor.awaitTermination(<span class="hljs-number">1</span>, TimeUnit.SECONDS)) &#123;<br>                    LOG.error(<span class="hljs-string">&quot;not all the LearnerCnxAcceptorHandler terminated properly&quot;</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException ie) &#123;<br>                LOG.error(<span class="hljs-string">&quot;Interrupted while terminating LearnerCnxAcceptor.&quot;</span>, ie);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>LearnerCnxAcceptor 的run方法中创建了 LearnerCnxAcceptorHandler 对象，在接收到链接后，就会调用 LearnerCnxAcceptorHandler ，而 LearnerCnxAcceptorHandler 是一个线程，它的run方法中调用了 acceptConnections() 方法，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.currentThread().setName(<span class="hljs-string">&quot;LearnerCnxAcceptorHandler-&quot;</span> + serverSocket.getLocalSocketAddress());<br><br>        <span class="hljs-comment">// 阻塞接受followers的链接，有链接过来生成socket对象</span><br>        <span class="hljs-comment">// 根据当前socket生成一个LearnerHandler线程</span><br>        <span class="hljs-keyword">while</span> (!stop.get()) &#123;<br>            acceptConnections();<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        LOG.warn(<span class="hljs-string">&quot;Exception while accepting follower&quot;</span>, e);<br>        <span class="hljs-keyword">if</span> (fail.compareAndSet(<span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>)) &#123;<br>            handleException(getName(), e);<br>            halt();<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 解除阻塞</span><br>        latch.countDown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>acceptConnections() 方法会在这里阻塞接收followers的连接，当有连接过来会生成一个socket对象。然后根据当前socket生成一个LearnerHandler线程 ，每个Learner都会开启一个LearnerHandler线程，方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acceptConnections</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    Socket socket = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">boolean</span> error = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 接受请求</span><br>        socket = serverSocket.accept();<br><br>        <span class="hljs-comment">// start with the initLimit, once the ack is processed</span><br>        <span class="hljs-comment">// in LearnerHandler switch to the syncLimit</span><br>        socket.setSoTimeout(self.tickTime * self.initLimit);<br>        socket.setTcpNoDelay(nodelay);<br>        <span class="hljs-comment">// 获取数据流</span><br>        BufferedInputStream is = <span class="hljs-keyword">new</span> BufferedInputStream(socket.getInputStream());<br>        <span class="hljs-comment">// 创建learnerHandler线程</span><br>        LearnerHandler fh = <span class="hljs-keyword">new</span> LearnerHandler(socket, is, Leader.<span class="hljs-keyword">this</span>);<br>        fh.start();<br>    &#125; <span class="hljs-keyword">catch</span> (SocketException e) &#123;<br>        error = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">if</span> (stop.get()) &#123;<br>            LOG.warn(<span class="hljs-string">&quot;Exception while shutting down acceptor.&quot;</span>, e);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> e;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (SaslException e) &#123;<br>        LOG.error(<span class="hljs-string">&quot;Exception while connecting to quorum learner&quot;</span>, e);<br>        error = <span class="hljs-keyword">true</span>;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        error = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">throw</span> e;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// Don&#x27;t leak sockets on errors</span><br>        <span class="hljs-keyword">if</span> (error &amp;&amp; socket != <span class="hljs-keyword">null</span> &amp;&amp; !socket.isClosed()) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                socket.close();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                LOG.warn(<span class="hljs-string">&quot;Error closing socket: &quot;</span> + socket, e);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>LearnerHandler.run 这里就是读取或写入数据包，并且与Learner交换数据包。如果没有数据包读取，则会阻塞当前方法 ia.readRecord(qp, “packet”); ，部分源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        learnerMaster.addLearnerHandler(<span class="hljs-keyword">this</span>);<br>        tickOfNextAckDeadline = learnerMaster.getTickOfInitialAckDeadline();<br><br>        ia = BinaryInputArchive.getArchive(bufferedInput);<br>        bufferedOutput = <span class="hljs-keyword">new</span> BufferedOutputStream(sock.getOutputStream());<br>        oa = BinaryOutputArchive.getArchive(bufferedOutput);<br>        <br>        <span class="hljs-comment">// 等待读取Follower/Observer发出的请求 请求包的类型Leader.FOLLOWERINFO或者Leader.OBSERVERINFO</span><br>        QuorumPacket qp = <span class="hljs-keyword">new</span> QuorumPacket();<br>        <span class="hljs-comment">// 阻塞读取数据</span><br>        ia.readRecord(qp, <span class="hljs-string">&quot;packet&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>我们再回到 leader.lead() 方法，其中调用了 getEpochToPropose() 方法，该方法是判断connectingFollowers发给leader端的Epoch是否过半，如果过半则会解阻塞，不过半会一直阻塞着，直到Follower把自己的Epoch数据包发送过来并符合过半机制，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getEpochToPropose</span><span class="hljs-params">(<span class="hljs-keyword">long</span> sid, <span class="hljs-keyword">long</span> lastAcceptedEpoch)</span> <span class="hljs-keyword">throws</span> InterruptedException, IOException </span>&#123;<br>    <span class="hljs-keyword">synchronized</span> (connectingFollowers) &#123;<br>        <span class="hljs-keyword">if</span> (!waitingForNewEpoch) &#123;<br>            <span class="hljs-keyword">return</span> epoch;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (lastAcceptedEpoch &gt;= epoch) &#123;<br>            epoch = lastAcceptedEpoch + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (isParticipant(sid)) &#123;<br>            connectingFollowers.add(sid);<br>        &#125;<br>        QuorumVerifier verifier = self.getQuorumVerifier();<br>        <span class="hljs-comment">// 过半算法</span><br>        <span class="hljs-keyword">if</span> (connectingFollowers.contains(self.getId()) &amp;&amp; verifier.containsQuorum(connectingFollowers)) &#123;<br>            waitingForNewEpoch = <span class="hljs-keyword">false</span>;<br>            self.setAcceptedEpoch(epoch);<br>            connectingFollowers.notifyAll();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">long</span> start = Time.currentElapsedTime();<br>            <span class="hljs-keyword">if</span> (sid == self.getId()) &#123;<br>                timeStartWaitForEpoch = start;<br>            &#125;<br>            <span class="hljs-keyword">long</span> cur = start;<br>            <span class="hljs-keyword">long</span> end = start + self.getInitLimit() * self.getTickTime();<br>            <span class="hljs-comment">// 如果不过半，会一直在这阻塞</span><br>            <span class="hljs-keyword">while</span> (waitingForNewEpoch &amp;&amp; cur &lt; end &amp;&amp; !quitWaitForEpoch) &#123;<br>                connectingFollowers.wait(end - cur);<br>                cur = Time.currentElapsedTime();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (waitingForNewEpoch) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException(<span class="hljs-string">&quot;Timeout while waiting for epoch from quorum&quot;</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> epoch;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在 lead() 方法中，当发送的Epoch过半之后，把当前zxid设置到zk，并等待EpochAck，关键源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 阻塞等待超过一半的（Follower和Observer）获取了新的epoch，并且返回了Leader.ACKEPOCH</span><br>waitForEpochAck(self.getId(), leaderStateSummary);<br><span class="hljs-comment">// 设置当前新的epoch</span><br>self.setCurrentEpoch(epoch);<br>self.setLeaderAddressAndId(self.getQuorumAddress(), self.getId());<br>self.setZabState(QuorumPeer.ZabState.SYNCHRONIZATION);<br></code></pre></td></tr></table></figure>

<p>waitForEpochAck() 方法也会等待超过一半的(Follower和Observer)获取了新的epoch，并且返回了Leader.ACKEPOCH，才会解除阻塞，否则会一直阻塞。等待EpochAck解阻塞后，把得到最新的epoch更新到当前服务，设置当前leader节点的zab状态是 SYNCHRONIZATION ，方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">waitForEpochAck</span><span class="hljs-params">(<span class="hljs-keyword">long</span> id, StateSummary ss)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException </span>&#123;<br>    <span class="hljs-keyword">synchronized</span> (electingFollowers) &#123;<br>        <span class="hljs-keyword">if</span> (electionFinished) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (ss.getCurrentEpoch() != -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span> (ss.isMoreRecentThan(leaderStateSummary)) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">&quot;Follower is ahead of the leader, leader summary: &quot;</span><br>                                      + leaderStateSummary.getCurrentEpoch()<br>                                      + <span class="hljs-string">&quot; (current epoch), &quot;</span><br>                                      + leaderStateSummary.getLastZxid()<br>                                      + <span class="hljs-string">&quot; (last zxid)&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (ss.getLastZxid() != -<span class="hljs-number">1</span> &amp;&amp; isParticipant(id)) &#123;<br>                electingFollowers.add(id);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 过半才能解除阻塞</span><br>        <span class="hljs-comment">// 等待超过一半的（Follower和Observer）获取了新的epoch，并且返回了Leader.ACKEPOCH</span><br>        QuorumVerifier verifier = self.getQuorumVerifier();<br>        <span class="hljs-keyword">if</span> (electingFollowers.contains(self.getId()) &amp;&amp; verifier.containsQuorum(electingFollowers)) &#123;<br>            electionFinished = <span class="hljs-keyword">true</span>;<br>            electingFollowers.notifyAll();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">long</span> start = Time.currentElapsedTime();<br>            <span class="hljs-keyword">long</span> cur = start;<br>            <span class="hljs-keyword">long</span> end = start + self.getInitLimit() * self.getTickTime();<br>            <span class="hljs-keyword">while</span> (!electionFinished &amp;&amp; cur &lt; end) &#123;<br>                <span class="hljs-comment">// 否则一直等待</span><br>                electingFollowers.wait(end - cur);<br>                cur = Time.currentElapsedTime();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!electionFinished) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException(<span class="hljs-string">&quot;Timeout while waiting for epoch to be acked by quorum&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>lead() 方法中还需要等待超过一半的(Follower和Observer)进行数据同步成功，并且返回了Leader.ACK，程序才会解除阻塞，如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 阻塞等待拆过一半的（Follower和Observer）进行数据同步成功，并且返回了Leader.ACK</span><br>    waitForNewLeaderAck(self.getId(), zk.getZxid());<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面所有流程都走完之后，就证明数据已经同步成功了，lead()中会执行startZkServer();</p>
<h4 id="LearnerHandler数据同步操作"><a href="#LearnerHandler数据同步操作" class="headerlink" title="LearnerHandler数据同步操作"></a>LearnerHandler数据同步操作</h4><p>LearnerHandler 线程是对应于 Learner 连接 Leader 端后，建立的一个与 Learner 端交换数据的线程。每一个 Learner 端都会创建一个 LearnerHandler 线程。</p>
<p>我们详细讲解 LearnerHandler.run() 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 等待读取Follower/Observer发出的请求 请求包的类型Leader.FOLLOWERINFO或者Leader.OBSERVERINFO</span><br>QuorumPacket qp = <span class="hljs-keyword">new</span> QuorumPacket();<br><span class="hljs-comment">// 阻塞读取数据</span><br>ia.readRecord(qp, <span class="hljs-string">&quot;packet&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>readRecord 读取数据包，不断从 learner 节点读数据，如果没读到将会阻塞 readRecord 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">messageTracker.trackReceived(qp.getType());<br><span class="hljs-keyword">if</span> (qp.getType() != Leader.FOLLOWERINFO &amp;&amp; qp.getType() != Leader.OBSERVERINFO) &#123;<br>    LOG.error(<span class="hljs-string">&quot;First packet &#123;&#125; is not FOLLOWERINFO or OBSERVERINFO!&quot;</span>, qp.toString());<br><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果数据包类型不是Leader.FOLLOWERINFO或Leader.OBSERVERINFO将会返回，因为咱们这里本身就是Leader节点，读数据肯定是读非Leader节点数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取learnerInfoData，用它来获取版本信息及sid</span><br><span class="hljs-keyword">byte</span>[] learnerInfoData = qp.getData();<br><span class="hljs-keyword">if</span> (learnerInfoData != <span class="hljs-keyword">null</span>) &#123;<br>    ByteBuffer bbsid = ByteBuffer.wrap(learnerInfoData);<br>    <span class="hljs-comment">// 根据字节数据的长度判断</span><br>    <span class="hljs-keyword">if</span> (learnerInfoData.length &gt;= <span class="hljs-number">8</span>) &#123;<br>        <span class="hljs-comment">// 获取myid</span><br>        <span class="hljs-keyword">this</span>.sid = bbsid.getLong();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (learnerInfoData.length &gt;= <span class="hljs-number">12</span>) &#123;<br>        <span class="hljs-comment">// 获取协议版本号，默认为 0x10000</span><br>        <span class="hljs-keyword">this</span>.version = bbsid.getInt(); <span class="hljs-comment">// protocolVersion</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (learnerInfoData.length &gt;= <span class="hljs-number">20</span>) &#123;<br>        <span class="hljs-keyword">long</span> configVersion = bbsid.getLong();<br>        <span class="hljs-keyword">if</span> (configVersion &gt; learnerMaster.getQuorumVerifierVersion()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">&quot;Follower is ahead of the leader (has a later activated configuration)&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 获取myid</span><br>    <span class="hljs-keyword">this</span>.sid = learnerMaster.getAndDecrementFollowerCounter();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>获取 learnerInfoData 来获取sid和版本信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取followerInfo</span><br>String followerInfo = learnerMaster.getPeerInfo(<span class="hljs-keyword">this</span>.sid);<br><span class="hljs-keyword">if</span> (followerInfo.isEmpty()) &#123;<br>    LOG.info(<br>        <span class="hljs-string">&quot;Follower sid: &#123;&#125; not in the current config &#123;&#125;&quot;</span>,<br>        <span class="hljs-keyword">this</span>.sid,<br>        Long.toHexString(learnerMaster.getQuorumVerifierVersion()));<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    LOG.info(<span class="hljs-string">&quot;Follower sid: &#123;&#125; : info : &#123;&#125;&quot;</span>, <span class="hljs-keyword">this</span>.sid, followerInfo);<br>&#125;<br><br><span class="hljs-keyword">if</span> (qp.getType() == Leader.OBSERVERINFO) &#123;<br>    learnerType = LearnerType.OBSERVER;<br>&#125;<br><br>learnerMaster.registerLearnerHandlerBean(<span class="hljs-keyword">this</span>, sock);<br><br><span class="hljs-comment">// 获取lastAcceptedEpoch</span><br><span class="hljs-keyword">long</span> lastAcceptedEpoch = ZxidUtils.getEpochFromZxid(qp.getZxid());<br></code></pre></td></tr></table></figure>

<p>把Leader.NEWLEADER数据包放入到queuedPackets，并向其他节点发送，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (getVersion() &lt; <span class="hljs-number">0x10000</span>) &#123;<br>    QuorumPacket newLeaderQP = <span class="hljs-keyword">new</span> QuorumPacket(Leader.NEWLEADER, newLeaderZxid, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<br>    oa.writeRecord(newLeaderQP, <span class="hljs-string">&quot;packet&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 把Leader.NEWLEADER数据包放入到queuedPackets</span><br>    QuorumPacket newLeaderQP = <span class="hljs-keyword">new</span> QuorumPacket(Leader.NEWLEADER, newLeaderZxid, learnerMaster.getQuorumVerifierBytes(), <span class="hljs-keyword">null</span>);<br>    queuedPackets.add(newLeaderQP);<br>&#125;<br>bufferedOutput.flush();<br><br><span class="hljs-comment">// Start thread that blast packets in the queue to learner</span><br><span class="hljs-comment">// 启动数据包发送</span><br>startSendingPackets();<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startSendingPackets</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!sendingThreadStarted) &#123;<br>        <span class="hljs-comment">// Start sending packets</span><br>        <span class="hljs-keyword">new</span> Thread() &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                Thread.currentThread().setName(<span class="hljs-string">&quot;Sender-&quot;</span> + sock.getRemoteSocketAddress());<br>                <span class="hljs-keyword">try</span> &#123;<br>                    sendPackets();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    LOG.warn(<span class="hljs-string">&quot;Unexpected interruption&quot;</span>, e);<br>                &#125;<br>            &#125;<br>        &#125;.start();<br>        sendingThreadStarted = <span class="hljs-keyword">true</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        LOG.error(<span class="hljs-string">&quot;Attempting to start sending thread after it already started&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/blog/categories/Zookeeper/">Zookeeper</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/blog/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">源码解析</a>
                    
                      <a class="hover-with-bg" href="/blog/tags/zookeeper/">zookeeper</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/blog/2021/04/27/%E6%9C%AA%E5%88%86%E7%B1%BB/dubbo%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Dubbo源码剖析</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/blog/2021/01/19/Zookeeper/Zookeeper%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8A/">
                        <span class="hidden-mobile">Zookeeper源码分析上</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":200})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.staticfile.org/jquery/3.5.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/js/bootstrap.min.js" ></script>
<script  src="/blog/js/events.js" ></script>
<script  src="/blog/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/blog/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.staticfile.org/tocbot/4.12.0/tocbot.min.js" ></script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>






  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/blog/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/blog/local-search.xml";
      jQuery('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      jQuery('#modalSearch').on('shown.bs.modal', function() {
        jQuery('#local-search-input').focus();
      });
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/blog/js/boot.js" ></script>


</body>
</html>
