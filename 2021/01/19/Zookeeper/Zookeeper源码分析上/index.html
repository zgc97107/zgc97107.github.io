

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/blog/img/fluid.png">
  <link rel="icon" href="/blog/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="">
  <meta name="keywords" content="">
  
    <meta name="description" content="Zookeeper源码导入Zookeeper各个版本源码下载地址：https:&#x2F;&#x2F;github.com&#x2F;apache&#x2F;zookeeper 我们可以在该仓库下选择不同的版本，我们选择最新版本，当前最新版本为3.7。 项目下载完成后，目录如下：  项目运行的时候，缺一个版本对象，创建 org.apache.zookeeper.version.Info ，代码如下： 1234567891011packa">
<meta property="og:type" content="article">
<meta property="og:title" content="Zookeeper源码分析上">
<meta property="og:url" content="http://zhaoguocheng.gitee.io/2021/01/19/Zookeeper/Zookeeper%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8A/index.html">
<meta property="og:site_name" content="萤火的博客">
<meta property="og:description" content="Zookeeper源码导入Zookeeper各个版本源码下载地址：https:&#x2F;&#x2F;github.com&#x2F;apache&#x2F;zookeeper 我们可以在该仓库下选择不同的版本，我们选择最新版本，当前最新版本为3.7。 项目下载完成后，目录如下：  项目运行的时候，缺一个版本对象，创建 org.apache.zookeeper.version.Info ，代码如下： 1234567891011packa">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://zhaoguocheng.gitee.io/blog/2021/01/19/Zookeeper/Zookeeper%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8A/image-20210726152932900.png">
<meta property="og:image" content="http://zhaoguocheng.gitee.io/blog/2021/01/19/Zookeeper/Zookeeper%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8A/pic4.png">
<meta property="og:image" content="http://zhaoguocheng.gitee.io/blog/2021/01/19/Zookeeper/Zookeeper%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8A/pic2.png">
<meta property="og:image" content="http://zhaoguocheng.gitee.io/blog/2021/01/19/Zookeeper/Zookeeper%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8A/pic3.png">
<meta property="og:image" content="http://zhaoguocheng.gitee.io/blog/2021/01/19/Zookeeper/Zookeeper%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8A/pic5.png">
<meta property="og:image" content="http://zhaoguocheng.gitee.io/blog/2021/01/19/Zookeeper/Zookeeper%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8A/pic6.png">
<meta property="og:image" content="http://zhaoguocheng.gitee.io/blog/2021/01/19/Zookeeper/Zookeeper%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8A/image-20210726165000300.png">
<meta property="og:image" content="http://zhaoguocheng.gitee.io/blog/2021/01/19/Zookeeper/Zookeeper%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8A/pic8.png">
<meta property="og:image" content="http://zhaoguocheng.gitee.io/blog/2021/01/19/Zookeeper/Zookeeper%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8A/pic9.png">
<meta property="article:published_time" content="2021-01-19T06:34:29.000Z">
<meta property="article:modified_time" content="2021-01-19T06:34:29.000Z">
<meta property="article:tag" content="源码解析">
<meta property="article:tag" content="zookeeper">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://zhaoguocheng.gitee.io/blog/2021/01/19/Zookeeper/Zookeeper%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8A/image-20210726152932900.png">
  
  
  
  <title>Zookeeper源码分析上 - 萤火的博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/blog/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/blog/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/blog/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"zhaoguocheng.gitee.io","root":"/blog/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/blog/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/blog/js/utils.js" ></script>
  <script  src="/blog/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 5.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/blog/">
      <strong>萤火的博客</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/">
                <i class="iconfont icon-home-fill"></i>
                主页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/blog/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Zookeeper源码分析上"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2021-01-19 14:34" pubdate>
          2021年1月19日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          45k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          372 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar category-bar" style="margin-right: -1rem">
    





<div class="category-list">
  
  
    
    
    
    <div class="category row nomargin-x">
      <a class="category-item 
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="Zookeeper"
        id="heading-fb4ac192a5f039c2e2c335ba5ced3583" role="tab" data-toggle="collapse" href="#collapse-fb4ac192a5f039c2e2c335ba5ced3583"
        aria-expanded="true"
      >
        Zookeeper
        <span class="list-group-count">(3)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse show" id="collapse-fb4ac192a5f039c2e2c335ba5ced3583"
           role="tabpanel" aria-labelledby="heading-fb4ac192a5f039c2e2c335ba5ced3583">
        
        
          
  <div class="category-post-list">
    
    
      
      
        <a href="/blog/2020/09/12/Zookeeper/zookeeper%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90/" title="Zookeeper深入剖析"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">Zookeeper深入剖析</span>
        </a>
      
    
      
      
        <a href="/blog/2021/01/19/Zookeeper/Zookeeper%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8A/" title="Zookeeper源码分析上"
           class="list-group-item list-group-item-action
           active">
          <span class="category-post">Zookeeper源码分析上</span>
        </a>
      
    
      
      
        <a href="/blog/2021/01/19/Zookeeper/Zookeeper%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8B/" title="Zookeeper源码分析下"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">Zookeeper源码分析下</span>
        </a>
      
    
  </div>

        
      </div>
    </div>
  
</div>


  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Zookeeper源码分析上</h1>
            
            
              <div class="markdown-body">
                
                <h3 id="Zookeeper源码导入"><a href="#Zookeeper源码导入" class="headerlink" title="Zookeeper源码导入"></a>Zookeeper源码导入</h3><p>Zookeeper各个版本源码下载地址：<a target="_blank" rel="noopener" href="https://github.com/apache/zookeeper">https://github.com/apache/zookeeper</a></p>
<p>我们可以在该仓库下选择不同的版本，我们选择最新版本，当前最新版本为3.7。</p>
<p>项目下载完成后，目录如下：</p>
<p><img src="/blog/2021/01/19/Zookeeper/Zookeeper%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8A/image-20210726152932900.png" srcset="/blog/img/loading.gif" lazyload alt="image-20210726152932900"></p>
<p>项目运行的时候，缺一个版本对象，创建 org.apache.zookeeper.version.Info ，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.apache.zookeeper.version;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Info</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAJOR = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MINOR = <span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MICRO = <span class="hljs-number">6</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String QUALIFIER = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> REVISION = -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String REVISION_HASH = <span class="hljs-string">&quot;1&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String BUILD_DATE = <span class="hljs-string">&quot;2020-12-03 09:29:06&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>pom中增加依赖（也可以将原本pom中对应dep的provided删除）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--引入依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.dropwizard.metrics<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>metrics-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.xerial.snappy<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>snappy-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.7.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.eclipse.jetty<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jetty-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.eclipse.jetty<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jetty-servlet<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-cli<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-cli<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>将conf中的log4j.properties添加到resources中，注意，如果此时resources并没有被Mark resources root，需要手动标记一下</p>
<p><img src="/blog/2021/01/19/Zookeeper/Zookeeper%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8A/pic4.png" srcset="/blog/img/loading.gif" lazyload></p>
<h3 id="ZK服务启动流程源码剖析"><a href="#ZK服务启动流程源码剖析" class="headerlink" title="ZK服务启动流程源码剖析"></a>ZK服务启动流程源码剖析</h3><p>ZooKeeper 可以以 standalone 、分布式的方式部署， standalone 模式下只有一台机器作为服务器，ZooKeeper 会丧失高可用特性，分布式是使用多个机器，每台机器上部署一个 ZooKeeper 服务器，即使有服务器宕机，只要少于半数，ZooKeeper 集群依然可以正常对外提供服务，集群状态下 Zookeeper 是具备高可用特性。</p>
<h4 id="ZK单机-集群启动流程"><a href="#ZK单机-集群启动流程" class="headerlink" title="ZK单机/集群启动流程"></a>ZK单机/集群启动流程</h4><p><img src="/blog/2021/01/19/Zookeeper/Zookeeper%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8A/pic2.png" srcset="/blog/img/loading.gif" lazyload></p>
<h4 id="ZK启动入口分析"><a href="#ZK启动入口分析" class="headerlink" title="ZK启动入口分析"></a>ZK启动入口分析</h4><p><strong>启动入口类：QuorumPeerMain</strong></p>
<p>该类是 zookeeper 单机/集群的启动入口类，是用来加载配置、启动 QuorumPeer（选举相关）线程、创建 ServerCnxnFactory 等，该类的 main 方法代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    QuorumPeerMain main = <span class="hljs-keyword">new</span> QuorumPeerMain();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 初始化配置，并启动服务</span><br>        main.initializeAndRun(args);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-comment">// 异常处理，省略。。。</span><br>    &#125;<br>    LOG.info(<span class="hljs-string">&quot;Exiting normally&quot;</span>);<br>    <span class="hljs-comment">// 退出</span><br>    ServiceUtils.requestSystemExit(ExitCode.EXECUTION_FINISHED.getValue());<br>&#125;<br></code></pre></td></tr></table></figure>

<p>initializeAndRun() 方法中会根据配置来决定启动单机Zookeeper还是集群Zookeeper，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initializeAndRun</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ConfigException, IOException, AdminServerException </span>&#123;<br>    QuorumPeerConfig config = <span class="hljs-keyword">new</span> QuorumPeerConfig();<br>    <span class="hljs-keyword">if</span> (args.length == <span class="hljs-number">1</span>) &#123;<br>        config.parse(args[<span class="hljs-number">0</span>]);<br>    &#125;<br><br>    <span class="hljs-comment">// 启动数据清理计划</span><br>    DatadirCleanupManager purgeMgr = <span class="hljs-keyword">new</span> DatadirCleanupManager(<br>            config.getDataDir(),            <span class="hljs-comment">// 数据存储目录</span><br>            config.getDataLogDir(),         <span class="hljs-comment">// 事务日志记录，默认为dataDir</span><br>            config.getSnapRetainCount(),    <span class="hljs-comment">// 保留快照数据数量，默认为3个</span><br>            config.getPurgeInterval());     <span class="hljs-comment">// 多少小时清理一次数据，默认不清理，在zoo.cfg中的autopurge.purgeInterval=1设置时间</span><br>    purgeMgr.start();<br>    <br>    <span class="hljs-comment">// 集群模式运行</span><br>    <span class="hljs-keyword">if</span> (args.length == <span class="hljs-number">1</span> &amp;&amp; config.isDistributed()) &#123;<br>        runFromConfig(config);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        LOG.warn(<span class="hljs-string">&quot;Either no config or no quorum defined in config, running in standalone mode&quot;</span>);<br>        <span class="hljs-comment">// 单机模式运行</span><br>        ZooKeeperServerMain.main(args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果启动单机版，会调用<code>ZooKeeperServerMain.main(args);</code>，如果启动集群版，会调用 <code>QuorumPeerMain.runFromConfig(config);</code> </p>
<h4 id="ZK单机启动源码剖析"><a href="#ZK单机启动源码剖析" class="headerlink" title="ZK单机启动源码剖析"></a>ZK单机启动源码剖析</h4><p>方法调用关系图：</p>
<p><img src="/blog/2021/01/19/Zookeeper/Zookeeper%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8A/pic3.png" srcset="/blog/img/loading.gif" lazyload></p>
<h5 id="单机启动入口"><a href="#单机启动入口" class="headerlink" title="单机启动入口"></a>单机启动入口</h5><p>ZooKeeperServerMain.main(args) 方法调用了ZooKeeperServerMain 的 initializeAndRun 方法，在 initializeAndRun 方法中执行初始化操作，并运行Zookeeper服务，main方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Start up the ZooKeeper server.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param args the configfile or the port datadir [ticktime]</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    ZooKeeperServerMain main = <span class="hljs-keyword">new</span> ZooKeeperServerMain();<br>    <span class="hljs-keyword">try</span> &#123;<br>        main.initializeAndRun(args);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-comment">// 异常处理，省略。。。</span><br>    &#125;<br>    LOG.info(<span class="hljs-string">&quot;Exiting normally&quot;</span>);<br>    <span class="hljs-comment">// 正常退出</span><br>    ServiceUtils.requestSystemExit(ExitCode.EXECUTION_FINISHED.getValue());<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="配置文件解析"><a href="#配置文件解析" class="headerlink" title="配置文件解析"></a>配置文件解析</h5><p>initializeAndRun() 方法会注册JMX，同时解析 zoo.cfg 配置文件，并调用 runFromConfig() 方法启动Zookeeper服务，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initializeAndRun</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ConfigException, IOException, AdminServerException </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 注册JMX</span><br>        <span class="hljs-comment">// JMX（Java Management Extensions，即Java管理扩展）是一个为应用程序、</span><br>        <span class="hljs-comment">// 设备、系统等植入管理功能的框架。JMX可以跨越一系列异构操作系统平台、</span><br>        <span class="hljs-comment">// 系统体系结构和网络传输协议，灵活的开发无缝集成的系统、网络和服务管理应用。</span><br>        ManagedUtil.registerLog4jMBeans();<br>    &#125; <span class="hljs-keyword">catch</span> (JMException e) &#123;<br>        LOG.warn(<span class="hljs-string">&quot;Unable to register log4j JMX control&quot;</span>, e);<br>    &#125;<br><br>    <span class="hljs-comment">// 解析配置文件</span><br>    ServerConfig config = <span class="hljs-keyword">new</span> ServerConfig();<br>    <span class="hljs-keyword">if</span> (args.length == <span class="hljs-number">1</span>) &#123;<br>        config.parse(args[<span class="hljs-number">0</span>]);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        config.parse(args);<br>    &#125;<br><br>    <span class="hljs-comment">// 根据解析的配置运行Zookeeper服务</span><br>    runFromConfig(config);<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="单机启动主流程"><a href="#单机启动主流程" class="headerlink" title="单机启动主流程"></a>单机启动主流程</h5><p>runFromConfig 方法是单机版启动的主要方法，该方法会做如下几件事：</p>
<ol>
<li>初始化各类运行指标，比如一次提交数据最大花费多长时间、批量同步数据大小等。 </li>
<li>初始化权限操作，例如IP权限、Digest权限。 </li>
<li>创建事务日志操作对象，Zookeeper中每次增加节点、修改数据、删除数据都是一次事务操作，都会记录日志。 </li>
<li>定义Jvm监控变量和常量，例如警告时间、告警阀值次数、提示阀值次数等。 </li>
<li>创建ZookeeperServer，这里只是创建，并不在ZooKeeperServerMain类中启动。 </li>
<li>启动Zookeeper的控制台管理对象AdminServer，该对象采用Jetty启动。 </li>
<li>创建ServerCnxnFactory，该对象其实是Zookeeper网络通信对象，默认使用了NIOServerCnxnFactory。</li>
<li>在ServerCnxnFactory中启动ZookeeperServer服务。 </li>
<li>创建并启动ContainerManager，该对象通过Timer定时执行，清理过期的容器节点和TTL节点，执行周期为分钟。 </li>
<li>防止主线程结束，阻塞主线程。</li>
</ol>
<p>方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">runFromConfig</span><span class="hljs-params">(ServerConfig config)</span> <span class="hljs-keyword">throws</span> IOException, AdminServerException </span>&#123;<br>    LOG.info(<span class="hljs-string">&quot;Starting server&quot;</span>);<br>    FileTxnSnapLog txnLog = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 创建MetricsProvider，用于收集指标并将当前值发布到外部设施的系统，与选举有关。</span><br>            metricsProvider = MetricsProviderBootstrap.startMetricsProvider(<br>                config.getMetricsProviderClassName(),<br>                config.getMetricsProviderConfiguration());<br>        &#125; <span class="hljs-keyword">catch</span> (MetricsProviderLifeCycleException error) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">&quot;Cannot boot MetricsProvider &quot;</span> + config.getMetricsProviderClassName(), error);<br>        &#125;<br>        <span class="hljs-comment">// 各类运行指标收集器</span><br>        ServerMetrics.metricsProviderInitialized(metricsProvider);<br>        <span class="hljs-comment">// 初始化权限</span><br>        ProviderRegistry.initialize();<br>        <span class="hljs-comment">// Note that this thread isn&#x27;t going to be doing anything else,</span><br>        <span class="hljs-comment">// so rather than spawning another thread, we will just call</span><br>        <span class="hljs-comment">// run() in this thread.</span><br>        <span class="hljs-comment">// create a file logger url from the command line args</span><br>        <span class="hljs-comment">// 根据参数创建事务操作日志对象（事务日志目录、快照日志目录）</span><br>        txnLog = <span class="hljs-keyword">new</span> FileTxnSnapLog(config.dataLogDir, config.dataDir);<br>        JvmPauseMonitor jvmPauseMonitor = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span> (config.jvmPauseMonitorToRun) &#123;<br>            jvmPauseMonitor = <span class="hljs-keyword">new</span> JvmPauseMonitor(config);<br>        &#125;<br>        <span class="hljs-comment">// 创建ZookeeperServer服务实例，并初始化参数，并未启动该服务</span><br>        <span class="hljs-keyword">final</span> ZooKeeperServer zkServer = <span class="hljs-keyword">new</span> ZooKeeperServer(jvmPauseMonitor, txnLog, config.tickTime, config.minSessionTimeout, config.maxSessionTimeout, config.listenBacklog, <span class="hljs-keyword">null</span>, config.initialConfig);<br>        txnLog.setServerStats(zkServer.serverStats());<br><br>        <span class="hljs-comment">// server error or shutdown state changes.</span><br>        <span class="hljs-comment">// 注册服务关闭程序</span><br>        <span class="hljs-keyword">final</span> CountDownLatch shutdownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);<br>        zkServer.registerServerShutdownHandler(<span class="hljs-keyword">new</span> ZooKeeperServerShutdownHandler(shutdownLatch));<br><br>        <span class="hljs-comment">// Start Admin server</span><br>        <span class="hljs-comment">// 启动服务管理器（JettyAdminServer）这里启动了Jetty组件</span><br>        adminServer = AdminServerFactory.createAdminServer();<br>        adminServer.setZooKeeperServer(zkServer);<br>        adminServer.start();<br><br>        <span class="hljs-keyword">boolean</span> needStartZKServer = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">if</span> (config.getClientPortAddress() != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 创建了ServerCnxnFactory，它是ZK通信组件，默认使用了NIO，也可以使用Netty</span><br>            cnxnFactory = ServerCnxnFactory.createFactory();<br>            <span class="hljs-comment">// 0.0.0.0/0.0.0.0:2181、单个客户端连接数限制、请求的传入连接队列的最大长度 -1不限制</span><br>            cnxnFactory.configure(config.getClientPortAddress(), config.getMaxClientCnxns(), config.getClientPortListenBacklog(), <span class="hljs-keyword">false</span>);<br>            <span class="hljs-comment">// 启动Zookeeper服务</span><br>            cnxnFactory.startup(zkServer);<br>            <span class="hljs-comment">// zkServer has been started. So we don&#x27;t need to start it again in secureCnxnFactory.</span><br>            <span class="hljs-comment">// 是否需要启动Zookeeper服务，zookeeper服务已经启动了，不需要再次启动，设置为false</span><br>            needStartZKServer = <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// SSL相关处理</span><br>        <span class="hljs-keyword">if</span> (config.getSecureClientPortAddress() != <span class="hljs-keyword">null</span>) &#123;<br>            secureCnxnFactory = ServerCnxnFactory.createFactory();<br>            secureCnxnFactory.configure(config.getSecureClientPortAddress(), config.getMaxClientCnxns(), config.getClientPortListenBacklog(), <span class="hljs-keyword">true</span>);<br>            secureCnxnFactory.startup(zkServer, needStartZKServer);<br>        &#125;<br><br>        <span class="hljs-comment">// 创建ContainerManager，它只由Leader调用，通过Timer定时执行，清理过期的容器节点和TTL节点，执行周期为分钟级别</span><br>        containerManager = <span class="hljs-keyword">new</span> ContainerManager(<br>            zkServer.getZKDatabase(),<br>            zkServer.firstProcessor,<br>            Integer.getInteger(<span class="hljs-string">&quot;znode.container.checkIntervalMs&quot;</span>, (<span class="hljs-keyword">int</span>) TimeUnit.MINUTES.toMillis(<span class="hljs-number">1</span>)),<br>            Integer.getInteger(<span class="hljs-string">&quot;znode.container.maxPerMinute&quot;</span>, <span class="hljs-number">10000</span>),<br>            Long.getLong(<span class="hljs-string">&quot;znode.container.maxNeverUsedIntervalMs&quot;</span>, <span class="hljs-number">0</span>)<br>        );<br>        containerManager.start();<br>        <span class="hljs-comment">// 为服务器启动和注册服务器停止日志添加审计日志</span><br>        ZKAuditProvider.addZKStartStopAuditLog();<br><br>        <span class="hljs-comment">// Watch status of ZooKeeper server. It will do a graceful shutdown</span><br>        <span class="hljs-comment">// if the server is not running or hits an internal error.</span><br>        <span class="hljs-comment">// 服务器正常启动时，运行到此处阻塞，只有server的state变为ERROR或SHUTDOWN时继续运行后边的代码</span><br>        shutdownLatch.await();<br><br>        shutdown();<br><br>        <span class="hljs-keyword">if</span> (cnxnFactory != <span class="hljs-keyword">null</span>) &#123;<br>            cnxnFactory.join();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (secureCnxnFactory != <span class="hljs-keyword">null</span>) &#123;<br>            secureCnxnFactory.join();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (zkServer.canShutdown()) &#123;<br>            zkServer.shutdown(<span class="hljs-keyword">true</span>);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        <span class="hljs-comment">// warn, but generally this is ok</span><br>        LOG.warn(<span class="hljs-string">&quot;Server interrupted&quot;</span>, e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (txnLog != <span class="hljs-keyword">null</span>) &#123;<br>            txnLog.close();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (metricsProvider != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                metricsProvider.stop();<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable error) &#123;<br>                LOG.warn(<span class="hljs-string">&quot;Error while stopping metrics&quot;</span>, error);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="网络通信对象的创建"><a href="#网络通信对象的创建" class="headerlink" title="网络通信对象的创建"></a>网络通信对象的创建</h5><p>在创建网络通信对象的时候调用了 ServerCnxnFactory.createFactory()，该方法其实是根据系统配置创建Zookeeper通信组件，可选的有 NIOServerCnxnFactory(默认) 和 NettyServerCnxnFactory ，该方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ServerCnxnFactory <span class="hljs-title">createFactory</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">// ZOOKEEPER_SERVER_CNXN_FACTORY为系统变量中配置该参数可改变通信对象，默认为NIO，可选Netty</span><br>    String serverCnxnFactoryName = System.getProperty(ZOOKEEPER_SERVER_CNXN_FACTORY);<br>    <span class="hljs-keyword">if</span> (serverCnxnFactoryName == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 默认为NIO</span><br>        serverCnxnFactoryName = NIOServerCnxnFactory.class.getName();<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 创建ServerCnxnFactory实例</span><br>        ServerCnxnFactory serverCnxnFactory = (ServerCnxnFactory) Class.forName(serverCnxnFactoryName)<br>                                                                       .getDeclaredConstructor()<br>                                                                       .newInstance();<br>        LOG.info(<span class="hljs-string">&quot;Using &#123;&#125; as server connection factory&quot;</span>, serverCnxnFactoryName);<br>        <span class="hljs-keyword">return</span> serverCnxnFactory;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        IOException ioe = <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">&quot;Couldn&#x27;t instantiate &quot;</span> + serverCnxnFactoryName, e);<br>        <span class="hljs-keyword">throw</span> ioe;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="单机启动"><a href="#单机启动" class="headerlink" title="单机启动"></a>单机启动</h5><p><code>cnxnFactory.startup(zkServer); </code>方法其实就是启动了 ZookeeperServer ，它调用NIOServerCnxnFactory 的 startup 方法，该方法中会调用 ZookeeperServer 的 startup 方法启动服务， ZooKeeperServerMain 运行到 <code>shutdownLatch.await();</code> 主线程会阻塞住，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startup</span><span class="hljs-params">(ZooKeeperServer zks, <span class="hljs-keyword">boolean</span> startServer)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException </span>&#123;<br>    <span class="hljs-comment">// NIO启动对应线程</span><br>    start();<br>    <span class="hljs-comment">// 设置Zookeeper的ServerCnxnFactory（客户端与服务端进行通信的对象，就是当前对象NIOServerCnxnFactory）</span><br>    setZooKeeperServer(zks);<br>    <span class="hljs-keyword">if</span> (startServer) &#123;<br>        <span class="hljs-comment">// 加载会话和数据</span><br>        zks.startdata();<br>        <span class="hljs-comment">// 启动Zookeeper服务</span><br>        zks.startup();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="ZK网络通信源码分析"><a href="#ZK网络通信源码分析" class="headerlink" title="ZK网络通信源码分析"></a>ZK网络通信源码分析</h3><p>ZooKeeper 中使用 ServerCnxnFactory 管理与客户端的连接，ServerCnxnFactory有两个实现，一个是 使用Java原生 NIO 的 NIOServerCnxnFactory；一个是使用 netty 的NettyServerCnxnFactory，NettyServerCnxnFactory 用 ServerCnxn 代表一个客户端与服务端的连接。</p>
<h4 id="NIOServerCnxnFactory工作流程"><a href="#NIOServerCnxnFactory工作流程" class="headerlink" title="NIOServerCnxnFactory工作流程"></a>NIOServerCnxnFactory工作流程</h4><p>一般使用Java NIO的思路为使用1个线程组监听 OP_ACCEPT 事件，负责处理客户端的连接；使用1个线程组监听客户端连接的 OP_READ 和 OP_WRITE 事件，处理IO事件(netty也是这种实现方式)。但ZooKeeper并不是如此划分线程功能的，NIOServerCnxnFactory 启动时会启动四类线程：</p>
<ol>
<li><p>AcceptThread：该线程接收来自客户端的连接，并将其分配给SelectorThread。</p>
</li>
<li><p>SelectorThread：该线程执行select()，由于在处理大量连接时，select()会成为性能瓶颈，因此启动多个SelectorThread，使用系统属性zookeeper.nio.numSelectorThreads配置该类线程数，默认个数为核心数/2。 </p>
</li>
<li><p>WorkerThread：该线程执行基本的套接字读写，使用系统属性zookeeper.nio.numWorkerThreads配置该类线程数，默认为核心数∗2。如果该类线程数为0，则另外启动一线程进行IO处理。</p>
</li>
<li><p>ConnectionExpirationThread：若连接上的session已过期，则关闭该连接。</p>
</li>
</ol>
<p>这四个线程在 NIOServerCnxnFactory 类上有说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * NIOServerCnxnFactory implements a multi-threaded ServerCnxnFactory using</span><br><span class="hljs-comment"> * NIO non-blocking socket calls. Communication between threads is handled via</span><br><span class="hljs-comment"> * queues.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *   - 1   accept thread, which accepts new connections and assigns to a</span><br><span class="hljs-comment"> *         selector thread</span><br><span class="hljs-comment"> *   - 1-N selector threads, each of which selects on 1/N of the connections.</span><br><span class="hljs-comment"> *         The reason the factory supports more than one selector thread is that</span><br><span class="hljs-comment"> *         with large numbers of connections, select() itself can become a</span><br><span class="hljs-comment"> *         performance bottleneck.</span><br><span class="hljs-comment"> *   - 0-M socket I/O worker threads, which perform basic socket reads and</span><br><span class="hljs-comment"> *         writes. If configured with 0 worker threads, the selector threads</span><br><span class="hljs-comment"> *         do the socket I/O directly.</span><br><span class="hljs-comment"> *   - 1   connection expiration thread, which closes idle connections; this is</span><br><span class="hljs-comment"> *         necessary to expire connections on which no session is established.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Typical (default) thread counts are: on a 32 core machine, 1 accept thread,</span><br><span class="hljs-comment"> * 1 connection expiration thread, 4 selector threads, and 64 worker threads.</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>

<p>ZooKeeper 中对线程需要处理的工作做了更细的拆分，比如将 selector.select() 拆分出来，交由 SelectorThread 处理，以解决有大量客户端连接的情况下selector.select() 会成为性能瓶颈的问题。</p>
<h5 id="NIOServerCnxnFactory源码"><a href="#NIOServerCnxnFactory源码" class="headerlink" title="NIOServerCnxnFactory源码"></a>NIOServerCnxnFactory源码</h5><p><strong>AcceptThread剖析</strong></p>
<p>在 NIOServerCnxnFactory 类中有一个 AccpetThread 线程，它的继承关系： AcceptThread &gt; AbstractSelectThread &gt; ZooKeeperThread &gt; Thread ，该线程接收来自客户端的连接，并将其分配给Selector Thread。</p>
<p><img src="/blog/2021/01/19/Zookeeper/Zookeeper%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8A/pic5.png" srcset="/blog/img/loading.gif" lazyload></p>
<p>该线程执行流程： run 执行<code>selector.select() </code>，并调用 doAccept() 接收客户端连接，因此我们可以着重关注 doAccept() 方法，当客户端链接 Zookeeper 的时候，首先会调用该方法，调用该方法执行过程如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">doAccept</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span> accepted = <span class="hljs-keyword">false</span>;<br>    SocketChannel sc = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 建立连接</span><br>        sc = acceptSocket.accept();<br>        accepted = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">if</span> (limitTotalNumberOfCnxns()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">&quot;Too many connections max allowed is &quot;</span> + maxCnxns);<br>        &#125;<br>        <span class="hljs-comment">// 获取远程计算机地址信息</span><br>        InetAddress ia = sc.socket().getInetAddress();<br>        LOG.info(<span class="hljs-string">&quot;AcceptThread连接服务的IP：&quot;</span> + ia.getHostName());<br>        <span class="hljs-keyword">int</span> cnxncount = getClientCnxnCount(ia);<br><br>        <span class="hljs-comment">// 判断是否超出最大客户端连接的限制</span><br>        <span class="hljs-keyword">if</span> (maxClientCnxns &gt; <span class="hljs-number">0</span> &amp;&amp; cnxncount &gt;= maxClientCnxns) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">&quot;Too many connections from &quot;</span> + ia + <span class="hljs-string">&quot; - max is &quot;</span> + maxClientCnxns);<br>        &#125;<br><br>        LOG.debug(<span class="hljs-string">&quot;Accepted socket connection from &#123;&#125;&quot;</span>, sc.socket().getRemoteSocketAddress());<br><br>        <span class="hljs-comment">// 调整此通道的阻塞模式</span><br>        sc.configureBlocking(<span class="hljs-keyword">false</span>);<br><br>        <span class="hljs-comment">// 轮询将此链接分配给一个SelectorThread</span><br>        <span class="hljs-comment">// Round-robin assign this connection to a selector thread</span><br>        <span class="hljs-keyword">if</span> (!selectorIterator.hasNext()) &#123;<br>            selectorIterator = selectorThreads.iterator();<br>        &#125;<br>        SelectorThread selectorThread = selectorIterator.next();<br>        <span class="hljs-comment">// 将新连接添加到AcceptedQueue中，并唤醒SelectorThread</span><br>        <span class="hljs-keyword">if</span> (!selectorThread.addAcceptedConnection(sc)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">&quot;Unable to add connection to selector queue&quot;</span><br>                    + (stopped ? <span class="hljs-string">&quot; (shutdown in progress)&quot;</span> : <span class="hljs-string">&quot;&quot;</span>));<br>        &#125;<br>        acceptErrorLogger.flush();<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        <span class="hljs-comment">// accept, maxClientCnxns, configureBlocking</span><br>        ServerMetrics.getMetrics().CONNECTION_REJECTED.add(<span class="hljs-number">1</span>);<br>        acceptErrorLogger.rateLimitLog(<span class="hljs-string">&quot;Error accepting new connection: &quot;</span> + e.getMessage());<br>        fastCloseSock(sc);<br>    &#125;<br>    <span class="hljs-keyword">return</span> accepted;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面代码中 addAcceptedConnection 方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addAcceptedConnection</span><span class="hljs-params">(SocketChannel accepted)</span> </span>&#123;<br>    <span class="hljs-comment">// 将accepted添加到acceptedQueue</span><br>    <span class="hljs-keyword">if</span> (stopped || !acceptedQueue.offer(accepted)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// 唤醒SelectorThread</span><br>    wakeupSelector();<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>重新启动连接后，控制台输出信息为：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2021</span>-<span class="hljs-number">02</span>-<span class="hljs-number">25</span> <span class="hljs-number">17</span>:<span class="hljs-number">00</span>:<span class="hljs-number">48</span>,<span class="hljs-number">970</span><span class="hljs-meta"> [myid:] - INFO  [NIOServerCxnFactory.AcceptThread:0.0.0.0/0.0.0.0:2181:NIOServerCnxnFactory$AcceptThread@270] - AcceptThread连接服务的IP：localhost</span><br></code></pre></td></tr></table></figure>

<p><strong>SelectorThread剖析</strong></p>
<p><img src="/blog/2021/01/19/Zookeeper/Zookeeper%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8A/pic6.png" srcset="/blog/img/loading.gif" lazyload></p>
<p>上图为 SelectorThread 的结构和方法调用关系</p>
<p>该线程的主要作用是从Socket读取数据，并封装成 workRequest ，并将 workRequest 交给 workerPool 工作线程池处理，同时将acceptedQueue中未处理的链接取出，并为每个链接绑定OP_READ 读事件，并封装对应的上下文对象 NIOServerCnxn 。SelectorThread 的run方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">while</span> (!stopped) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 调用select()读取就绪的IO事件，交由WorkerThread处理，在ZookeeperServer的processPacket()中处理数据</span><br>                select();<br>                <span class="hljs-comment">// 把acceptedQueue队列中接收的连接，取出来注册OP_READ读事件</span><br>                <span class="hljs-comment">// 并添加NIOServerCnxn对象与当前key绑定。</span><br>                <span class="hljs-comment">// 相当于给每个连接添加附加对象NIOServerCnxn(上下对象)</span><br>                processAcceptedConnections();<br>                <span class="hljs-comment">// 遍历所有updateQueue，更新updateQueue中连接的监听事件</span><br>                processInterestOpsUpdateRequests();<br>            &#125; <span class="hljs-keyword">catch</span> (RuntimeException e) &#123;<br>                LOG.warn(<span class="hljs-string">&quot;Ignoring unexpected runtime exception&quot;</span>, e);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                LOG.warn(<span class="hljs-string">&quot;Ignoring unexpected exception&quot;</span>, e);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// Close connections still pending on the selector. Any others</span><br>        <span class="hljs-comment">// with in-flight work, let drain out of the work queue.</span><br>        <span class="hljs-keyword">for</span> (SelectionKey key : selector.keys()) &#123;<br>            NIOServerCnxn cnxn = (NIOServerCnxn) key.attachment();<br>            <span class="hljs-keyword">if</span> (cnxn.isSelectable()) &#123;<br>                cnxn.close(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);<br>            &#125;<br>            cleanupSelectionKey(key);<br>        &#125;<br>        SocketChannel accepted;<br>        <span class="hljs-keyword">while</span> ((accepted = acceptedQueue.poll()) != <span class="hljs-keyword">null</span>) &#123;<br>            fastCloseSock(accepted);<br>        &#125;<br>        updateQueue.clear();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        closeSelector();<br>        <span class="hljs-comment">// This will wake up the accept thread and the other selector</span><br>        <span class="hljs-comment">// threads, and tell the worker thread pool to begin shutdown.</span><br>        NIOServerCnxnFactory.<span class="hljs-keyword">this</span>.stop();<br>        LOG.info(<span class="hljs-string">&quot;selector thread exitted run method&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>run() 方法中会调用 select()，而 select() 中的核心调用地方是 handleIO() 处理客户端请求的数据，但客户端请求数据并非在 SelectorThread 线程中处理，我们接着看 handleIO() 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">select</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        selector.select();<br><br>        Set&lt;SelectionKey&gt; selected = selector.selectedKeys();<br>        ArrayList&lt;SelectionKey&gt; selectedList = <span class="hljs-keyword">new</span> ArrayList&lt;SelectionKey&gt;(selected);<br>        Collections.shuffle(selectedList);<br>        Iterator&lt;SelectionKey&gt; selectedKeys = selectedList.iterator();<br>        <span class="hljs-keyword">while</span> (!stopped &amp;&amp; selectedKeys.hasNext()) &#123;<br>            SelectionKey key = selectedKeys.next();<br>            selected.remove(key);<br><br>            <span class="hljs-keyword">if</span> (!key.isValid()) &#123;<br>                cleanupSelectionKey(key);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (key.isReadable() || key.isWritable()) &#123;<br>                <span class="hljs-comment">// 读取客户端数据请求的开始</span><br>                handleIO(key);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                LOG.warn(<span class="hljs-string">&quot;Unexpected ops in select &#123;&#125;&quot;</span>, key.readyOps());<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        LOG.warn(<span class="hljs-string">&quot;Ignoring IOException while selecting&quot;</span>, e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>handleIO() 方法会封装当前 SelectorThread 为 IOWorkRequest ，并将 IOWorkRequest 交给 workerPool 来调度，而 workerPool 调度才是读数据的开始，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleIO</span><span class="hljs-params">(SelectionKey key)</span> </span>&#123;<br>    <span class="hljs-comment">// 将SelectorThread封装成WorkRequest</span><br>    IOWorkRequest workRequest = <span class="hljs-keyword">new</span> IOWorkRequest(<span class="hljs-keyword">this</span>, key);<br>    NIOServerCnxn cnxn = (NIOServerCnxn) key.attachment();<br><br>    <span class="hljs-comment">// Stop selecting this key while processing on its</span><br>    <span class="hljs-comment">// connection</span><br>    cnxn.disableSelectable();<br>    key.interestOps(<span class="hljs-number">0</span>);<br>    touchCnxn(cnxn);<br>    <span class="hljs-comment">// 将封装好的WorkRequest交给WorkerPool线程池处理，在这里会读取客户端数据</span><br>    workerPool.schedule(workRequest);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>WorkerThread剖析</strong></p>
<p>WorkerThread相比上面的线程而言，调用关系颇为复杂，设计到了多个对象方法调用，主要用于处理，但并未对数据做出处理，数据处理将由业务链对象RequestProcessor处理，调用关系图如下：</p>
<p><img src="/blog/2021/01/19/Zookeeper/Zookeeper%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8A/image-20210726165000300.png" srcset="/blog/img/loading.gif" lazyload></p>
<p><code>workerPool.schedule(workRequest);</code>调用了</p>
<p>WorkerService.schedule(workRequest) &gt; WorkerService.schedule(WorkRequest, long) ，该</p>
<p>方法创建了一个新的线程 ScheduledWorkRequest ,并执行该线程，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">schedule</span><span class="hljs-params">(WorkRequest workRequest, <span class="hljs-keyword">long</span> id)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (stopped) &#123;<br>        workRequest.cleanup();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 创建ScheduleWorkRequest线程</span><br>    ScheduledWorkRequest scheduledWorkRequest = <span class="hljs-keyword">new</span> ScheduledWorkRequest(workRequest);<br><br>    <span class="hljs-comment">// If we have a worker thread pool, use that; otherwise, do the work</span><br>    <span class="hljs-comment">// directly.</span><br>    <span class="hljs-keyword">int</span> size = workers.size();<br>    <span class="hljs-keyword">if</span> (size &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// make sure to map negative ids as well to [0, size-1]</span><br>            <span class="hljs-keyword">int</span> workerNum = ((<span class="hljs-keyword">int</span>) (id % size) + size) % size;<br>            ExecutorService worker = workers.get(workerNum);<br>            <span class="hljs-comment">// 执行对应线程</span><br>            worker.execute(scheduledWorkRequest);<br>        &#125; <span class="hljs-keyword">catch</span> (RejectedExecutionException e) &#123;<br>            LOG.warn(<span class="hljs-string">&quot;ExecutorService rejected execution&quot;</span>, e);<br>            workRequest.cleanup();<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// When there is no worker thread pool, do the work directly</span><br>        <span class="hljs-comment">// and wait for its completion</span><br>        scheduledWorkRequest.run();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>ScheduledWorkRequest 实现了 Runnable 接口，并在 run() 方法中调用了 IOWorkRequest 中的 doWork 方法，在该方法中会调用 doIO 执行IO数据处理，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// Check if stopped while request was on queue</span><br>        <span class="hljs-keyword">if</span> (stopped) &#123;<br>            workRequest.cleanup();<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 执行IOWorkRequest中的doWork方法</span><br>        workRequest.doWork();<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        LOG.warn(<span class="hljs-string">&quot;Unexpected exception&quot;</span>, e);<br>        workRequest.cleanup();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>IOWorkRequest 的 doWork 源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doWork</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <span class="hljs-keyword">if</span> (!key.isValid()) &#123;<br>        selectorThread.cleanupSelectionKey(key);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (key.isReadable() || key.isWritable()) &#123;<br>        <span class="hljs-comment">// 执行IO数据处理</span><br>        cnxn.doIO(key);<br><br>        <span class="hljs-comment">// Check if we shutdown or doIO() closed this connection</span><br>        <span class="hljs-keyword">if</span> (stopped) &#123;<br>            cnxn.close(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!key.isValid()) &#123;<br>            selectorThread.cleanupSelectionKey(key);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        touchCnxn(cnxn);<br>    &#125;<br><br>    <span class="hljs-comment">// Mark this connection as once again ready for selection</span><br>    cnxn.enableSelectable();<br>    <span class="hljs-comment">// Push an update request on the queue to resume selecting</span><br>    <span class="hljs-comment">// on the current set of interest ops, which may have changed</span><br>    <span class="hljs-comment">// as a result of the I/O operations we just performed.</span><br>    <span class="hljs-keyword">if</span> (!selectorThread.addInterestOpsUpdateRequest(key)) &#123;<br>        cnxn.close(ServerCnxn.DisconnectReason.CONNECTION_MODE_CHANGED);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>接下来的调用链路比较复杂，我们把核心步骤列出，在能直接看到数据读取的地方详细分析源码。上面方法调用链路： NIOServerCnxn.doIO()&gt;readPayload()&gt;readRequest() &gt;ZookeeperServer.processPacket() ，最后一步方法是获取核心数据的地方，我们可以修改下代码读取数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 数据包处理</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> cnxn</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> incomingBuffer</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IOException</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processPacket</span><span class="hljs-params">(ServerCnxn cnxn, ByteBuffer incomingBuffer)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">// We have the request, now process and setup for next</span><br>    InputStream bais = <span class="hljs-keyword">new</span> ByteBufferInputStream(incomingBuffer);<br>    <span class="hljs-comment">// 测试start</span><br>    ByteArrayOutputStream os = <span class="hljs-keyword">new</span> ByteArrayOutputStream();<br>    <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>    <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> ((len = bais.read(buffer)) != -<span class="hljs-number">1</span>) &#123;<br>        os.write(buffer, <span class="hljs-number">0</span>, len);<br>    &#125;<br>    String result = <span class="hljs-keyword">new</span> String(os.toByteArray());<br>    LOG.info(<span class="hljs-string">&quot;读取到的数据：&quot;</span> + result);<br>    <span class="hljs-comment">// 测试end</span><br>  <br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 数据包处理</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cnxn</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> incomingBuffer</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processPacket</span><span class="hljs-params">(ServerCnxn cnxn, ByteBuffer incomingBuffer)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">// We have the request, now process and setup for next</span><br>        InputStream bais = <span class="hljs-keyword">new</span> ByteBufferInputStream(incomingBuffer);<br><span class="hljs-comment">/*        // 测试start</span><br><span class="hljs-comment">        ByteArrayOutputStream os = new ByteArrayOutputStream();</span><br><span class="hljs-comment">        byte[] buffer = new byte[1024];</span><br><span class="hljs-comment">        int len = 0;</span><br><span class="hljs-comment">        while ((len = bais.read(buffer)) != -1) &#123;</span><br><span class="hljs-comment">            os.write(buffer, 0, len);</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">        String result = new String(os.toByteArray());</span><br><span class="hljs-comment">        LOG.info(&quot;读取到的数据：&quot; + result);</span><br><span class="hljs-comment">        // 测试end*/</span><br>        BinaryInputArchive bia = BinaryInputArchive.getArchive(bais);<br>        RequestHeader h = <span class="hljs-keyword">new</span> RequestHeader();<br>        h.deserialize(bia, <span class="hljs-string">&quot;header&quot;</span>);<br><br>        <span class="hljs-comment">// Need to increase the outstanding request count first, otherwise</span><br>        <span class="hljs-comment">// there might be a race condition that it enabled recv after</span><br>        <span class="hljs-comment">// processing request and then disabled when check throttling.</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">// Be aware that we&#x27;re actually checking the global outstanding</span><br>        <span class="hljs-comment">// request before this request.</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">// It&#x27;s fine if the IOException thrown before we decrease the count</span><br>        <span class="hljs-comment">// in cnxn, since it will close the cnxn anyway.</span><br>        cnxn.incrOutstandingAndCheckThrottle(h);<br><br>        <span class="hljs-comment">// Through the magic of byte buffers, txn will not be</span><br>        <span class="hljs-comment">// pointing</span><br>        <span class="hljs-comment">// to the start of the txn</span><br>        incomingBuffer = incomingBuffer.slice();<br>        <span class="hljs-keyword">if</span> (h.getType() == OpCode.auth) &#123;<br>            LOG.info(<span class="hljs-string">&quot;got auth packet &#123;&#125;&quot;</span>, cnxn.getRemoteSocketAddress());<br>            AuthPacket authPacket = <span class="hljs-keyword">new</span> AuthPacket();<br>            ByteBufferInputStream.byteBuffer2Record(incomingBuffer, authPacket);<br>            String scheme = authPacket.getScheme();<br>            ServerAuthenticationProvider ap = ProviderRegistry.getServerProvider(scheme);<br>            Code authReturn = KeeperException.Code.AUTHFAILED;<br>            <span class="hljs-keyword">if</span> (ap != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// handleAuthentication may close the connection, to allow the client to choose</span><br>                    <span class="hljs-comment">// a different server to connect to.</span><br>                    authReturn = ap.handleAuthentication(<br>                            <span class="hljs-keyword">new</span> ServerAuthenticationProvider.ServerObjs(<span class="hljs-keyword">this</span>, cnxn),<br>                            authPacket.getAuth());<br>                &#125; <span class="hljs-keyword">catch</span> (RuntimeException e) &#123;<br>                    LOG.warn(<span class="hljs-string">&quot;Caught runtime exception from AuthenticationProvider: &#123;&#125;&quot;</span>, scheme, e);<br>                    authReturn = KeeperException.Code.AUTHFAILED;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (authReturn == KeeperException.Code.OK) &#123;<br>                LOG.info(<span class="hljs-string">&quot;Session 0x&#123;&#125;: auth success for scheme &#123;&#125; and address &#123;&#125;&quot;</span>,<br>                        Long.toHexString(cnxn.getSessionId()), scheme,<br>                        cnxn.getRemoteSocketAddress());<br>                ReplyHeader rh = <span class="hljs-keyword">new</span> ReplyHeader(h.getXid(), <span class="hljs-number">0</span>, KeeperException.Code.OK.intValue());<br>                cnxn.sendResponse(rh, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (ap == <span class="hljs-keyword">null</span>) &#123;<br>                    LOG.warn(<br>                            <span class="hljs-string">&quot;No authentication provider for scheme: &#123;&#125; has &#123;&#125;&quot;</span>,<br>                            scheme,<br>                            ProviderRegistry.listProviders());<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    LOG.warn(<span class="hljs-string">&quot;Authentication failed for scheme: &#123;&#125;&quot;</span>, scheme);<br>                &#125;<br>                <span class="hljs-comment">// send a response...</span><br>                ReplyHeader rh = <span class="hljs-keyword">new</span> ReplyHeader(h.getXid(), <span class="hljs-number">0</span>, KeeperException.Code.AUTHFAILED.intValue());<br>                cnxn.sendResponse(rh, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<br>                <span class="hljs-comment">// ... and close connection</span><br>                cnxn.sendBuffer(ServerCnxnFactory.closeConn);<br>                cnxn.disableRecv();<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (h.getType() == OpCode.sasl) &#123;<br>            processSasl(incomingBuffer, cnxn, h);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (!authHelper.enforceAuthentication(cnxn, h.getXid())) &#123;<br>                <span class="hljs-comment">// Authentication enforcement is failed</span><br>                <span class="hljs-comment">// Already sent response to user about failure and closed the session, lets return</span><br>                <span class="hljs-keyword">return</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                Request si = <span class="hljs-keyword">new</span> Request(cnxn, cnxn.getSessionId(), h.getXid(), h.getType(), incomingBuffer, cnxn.getAuthInfo());<br>                <span class="hljs-keyword">int</span> length = incomingBuffer.limit();<br>                <span class="hljs-keyword">if</span> (isLargeRequest(length)) &#123;<br>                    <span class="hljs-comment">// checkRequestSize will throw IOException if request is rejected</span><br>                    checkRequestSizeWhenMessageReceived(length);<br>                    si.setLargeRequestSize(length);<br>                &#125;<br>                si.setOwner(ServerCnxn.me);<br>                <span class="hljs-comment">// 提交处理操作</span><br>                submitRequest(si);<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>启动客户端输入命令<code>create /test abcdef</code></p>
<p>控制台数据如下：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2021</span>-<span class="hljs-number">02</span>-<span class="hljs-number">25</span> <span class="hljs-number">17</span>:<span class="hljs-number">59</span>:<span class="hljs-number">39</span>,<span class="hljs-number">165</span><span class="hljs-meta"> [myid:] - INFO  [NIOWorkerThread-6:ZooKeeperServer@1598] - 读取到的数据：test abcdef world anyone </span><br></code></pre></td></tr></table></figure>

<h5 id="ConnectionExpirerThread剖析"><a href="#ConnectionExpirerThread剖析" class="headerlink" title="ConnectionExpirerThread剖析"></a>ConnectionExpirerThread剖析</h5><p>后台启动 ConnectionExpirerThread 清理线程清理过期的 session，线程中无限循环，执行工作如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">while</span> (!stopped) &#123;<br>            <span class="hljs-comment">// 获取需要等待的事件</span><br>            <span class="hljs-keyword">long</span> waitTime = cnxnExpiryQueue.getWaitTime();<br>            <span class="hljs-comment">// 执行休眠</span><br>            <span class="hljs-keyword">if</span> (waitTime &gt; <span class="hljs-number">0</span>) &#123;<br>                Thread.sleep(waitTime);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">// 清理过期会话</span><br>            <span class="hljs-keyword">for</span> (NIOServerCnxn conn : cnxnExpiryQueue.poll()) &#123;<br>                ServerMetrics.getMetrics().SESSIONLESS_CONNECTIONS_EXPIRED.add(<span class="hljs-number">1</span>);<br>                conn.close(ServerCnxn.DisconnectReason.CONNECTION_EXPIRED);<br>            &#125;<br>        &#125;<br><br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        LOG.info(<span class="hljs-string">&quot;ConnnectionExpirerThread interrupted&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="ZK通信优劣总结"><a href="#ZK通信优劣总结" class="headerlink" title="ZK通信优劣总结"></a>ZK通信优劣总结</h4><p>Zookeeper在通信方面默认使用了NIO，并支持扩展Netty实现网络数据传输。相比传统IO，NIO在网络数据传输方面有很多明显优势：</p>
<ul>
<li>传统IO在处理数据传输请求时，针对每个传输请求生成一个线程，如果IO异常，那么线程阻塞，在IO恢复后唤醒处理线程。在同时处理大量连接时，会实例化大量的线程对象。每个线程的实例化和回收都需要消耗资源，jvm需要为其分配TLAB，然后初始化TLAB，最后绑定线程，线程结束时又需要回收TLAB，这些都需要CPU资源。 </li>
<li>NIO使用selector来轮询IO流，内部使用poll或者epoll，以事件驱动形式来相应IO事件的处理。同一时间只需实例化很少的线程对象，通过对线程的复用来提高CPU资源的使用效率。 </li>
<li>CPU轮流为每个线程分配时间片的形式，间接的实现单物理核处理多线程。当线程越多时，每个线程分配到的时间片越短，或者循环分配的周期越长，CPU很多时间都耗费在了线程的切换上。线程切换包含线程上个线程数据的同步(TLAB同步)，同步变量同步至主存，下个线程数据的加载等等，他们都是很耗费CPU资源的。 </li>
<li>在同时处理大量连接，但活跃连接不多时，NIO的事件响应模式相比于传统IO有着极大的性能提升。NIO还提供了FileChannel，以zero-copy的形式传输数据，相较于传统的IO，数据不需要拷贝至用户空间，可直接由物理硬件(磁盘等)通过内核缓冲区后直接传递至网关，极大的提高了性能。 </li>
<li>NIO提供了MappedByteBuffer，其将文件直接映射到内存（这里的内存指的是虚拟内存，并不是物理内存），能极大的提高IO吞吐能力。</li>
</ul>
<p>ZK在使用NIO通信虽然大幅提升了数据传输能力，但也存在一些代码诟病问题：</p>
<ul>
<li>Zookeeper通信源码部分学习成本高，需要掌握NIO和多线程 </li>
<li>多线程使用频率高，消耗资源多，但性能得到提升 </li>
<li>Zookeeper数据处理调用链路复杂，多处存在内部类，代码结构不清晰，写法比较经典</li>
</ul>
<h3 id="RequestProcessor处理请求源码剖析"><a href="#RequestProcessor处理请求源码剖析" class="headerlink" title="RequestProcessor处理请求源码剖析"></a>RequestProcessor处理请求源码剖析</h3><p>zookeeper 的业务处理流程就像工作流一样，其实就是一个单链表；在 zookeeper 启动的时候，会确立各个节点的角色特性，即 leader、follower 和 observer ，每个角色确立后，就会初始化它的工作责任链；</p>
<h4 id="RequestProcessor结构"><a href="#RequestProcessor结构" class="headerlink" title="RequestProcessor结构"></a>RequestProcessor结构</h4><p>在上面IOWorkRequest的分析中，IOWorkRequest会调用ZookeeperServer.processPacket()进行数据包处理，之后的调用链为：</p>
<p>ZookeeperServer.processPacket()  &gt; ZookeeperServer.submitRequest() &gt; ZookeeperServer.enqueueRequest()</p>
<p>客户端请求过来，每次执行不同事务操作的时候，Zookeeper也提供了一套业务处理流程RequestProcessor ， RequestProcessor 的处理流程如下图：</p>
<p><img src="/blog/2021/01/19/Zookeeper/Zookeeper%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8A/pic8.png" srcset="/blog/img/loading.gif" lazyload></p>
<p>ZookeeperServer.enqueueRequest()会在IOWorkerThread调用的。</p>
<p>RequestProcessor 初始化流程，<code>ZooKeeperServer.setupRequestProcessors()</code>方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 初始化业务处理流程</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setupRequestProcessors</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建FinalRequestProcessors</span><br>    RequestProcessor finalProcessor = <span class="hljs-keyword">new</span> FinalRequestProcessor(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-comment">// 创建SyncRequestProcessor，并将FinalRequestProcessor最为他的下一个业务链</span><br>    RequestProcessor syncProcessor = <span class="hljs-keyword">new</span> SyncRequestProcessor(<span class="hljs-keyword">this</span>, finalProcessor);<br>    <span class="hljs-comment">// 启动SyncRequestProcessor</span><br>    ((SyncRequestProcessor) syncProcessor).start();<br>    <span class="hljs-comment">// 创建PrepRequestProcessor，并作为第一个处理业务的RequestProcessor，将SyncRequestProcessor作为它的下一个业务链</span><br>    firstProcessor = <span class="hljs-keyword">new</span> PrepRequestProcessor(<span class="hljs-keyword">this</span>, syncProcessor);<br>    <span class="hljs-comment">// 启动firstProcessor</span><br>    ((PrepRequestProcessor) firstProcessor).start();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>syncProcessor 创建时，将 finalProcessor 作为参数传递进来源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 创建SyncRequestProcessor</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> zks</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> nextProcessor</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SyncRequestProcessor</span><span class="hljs-params">(ZooKeeperServer zks, RequestProcessor nextProcessor)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>(<span class="hljs-string">&quot;SyncThread:&quot;</span> + zks.getServerId(), zks.getZooKeeperServerListener());<br>    <span class="hljs-keyword">this</span>.zks = zks;<br>    <span class="hljs-comment">// 下一个责任链</span><br>    <span class="hljs-keyword">this</span>.nextProcessor = nextProcessor;<br>    <span class="hljs-keyword">this</span>.toFlush = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;(zks.getMaxBatchSize());<br>&#125;<br></code></pre></td></tr></table></figure>

<p>firstProcessor 创建时，将 syncProcessor 作为参数传递进来源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 创建PrepRequestProcessor</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> zks</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> nextProcessor</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PrepRequestProcessor</span><span class="hljs-params">(ZooKeeperServer zks, RequestProcessor nextProcessor)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>(<br>        <span class="hljs-string">&quot;ProcessThread(sid:&quot;</span> + zks.getServerId()<br>        + <span class="hljs-string">&quot; cport:&quot;</span> + zks.getClientPort()<br>        + <span class="hljs-string">&quot;):&quot;</span>, zks.getZooKeeperServerListener());<br>    <span class="hljs-comment">// 下一个责任链</span><br>    <span class="hljs-keyword">this</span>.nextProcessor = nextProcessor;<br>    <span class="hljs-keyword">this</span>.zks = zks;<br>    <span class="hljs-keyword">this</span>.digestEnabled = ZooKeeperServer.isDigestEnabled();<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.digestEnabled) &#123;<br>        <span class="hljs-keyword">this</span>.digestCalculator = <span class="hljs-keyword">new</span> DigestCalculator();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>PrepRequestProcessor/SyncRequestProcessor 关系图：</p>
<p><img src="/blog/2021/01/19/Zookeeper/Zookeeper%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8A/pic9.png" srcset="/blog/img/loading.gif" lazyload></p>
<p>PrepRequestProcessor 和 SyncRequestProcessor 的结构一样，都是实现了 Thread 的一个线程，所以在这里初始化时便启动了这两个线程。</p>
<h4 id="PrepRequestProcessor剖析"><a href="#PrepRequestProcessor剖析" class="headerlink" title="PrepRequestProcessor剖析"></a>PrepRequestProcessor剖析</h4><p>PrepRequestProcessor 是请求处理器的第1个处理器，之前的请求业务链：</p>
<p>ZooKeeperServer.processPacket() &gt; submitRequest() &gt; enqueueRequest() &gt; RequestThrottler.submitRequest()，RequestThrottler.submitRequest()将当前请求添加到submittedRequests队列中，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">submitRequest</span><span class="hljs-params">(Request request)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (stopping) &#123;<br>        LOG.debug(<span class="hljs-string">&quot;Shutdown in progress. Request cannot be processed&quot;</span>);<br>        dropRequest(request);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        request.requestThrottleQueueTime = Time.currentElapsedTime();<br>        <span class="hljs-comment">// 将当前请求添加到submittedRequest队列中</span><br>        submittedRequests.add(request);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>RequestThrottler 继承了 ZooKeeperCriticalThread &gt; ZooKeeperThread &gt; Thread ，也就是说当前 RequestThrottler 是个线程，我们看看它的 run 方法做了什么事，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>          <br>          	<span class="hljs-comment">// 略... </span><br>              <br>            <span class="hljs-comment">// A dropped stale request will be null</span><br>            <span class="hljs-keyword">if</span> (request != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (request.isStale()) &#123;<br>                    ServerMetrics.getMetrics().STALE_REQUESTS.add(<span class="hljs-number">1</span>);<br>                &#125;<br>                <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> elapsedTime = Time.currentElapsedTime() - request.requestThrottleQueueTime;<br>                ServerMetrics.getMetrics().REQUEST_THROTTLE_QUEUE_TIME.add(elapsedTime);<br>                <span class="hljs-keyword">if</span> (shouldThrottleOp(request, elapsedTime)) &#123;<br>                  request.setIsThrottled(<span class="hljs-keyword">true</span>);<br>                  ServerMetrics.getMetrics().THROTTLED_OPS.add(<span class="hljs-number">1</span>);<br>                &#125;<br>                <span class="hljs-comment">// 调用ZookeeperServer.summitRequestNow(request)方法</span><br>                zks.submitRequestNow(request);<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        LOG.error(<span class="hljs-string">&quot;Unexpected interruption&quot;</span>, e);<br>    &#125;<br>    <span class="hljs-keyword">int</span> dropped = drainQueue();<br>    LOG.info(<span class="hljs-string">&quot;RequestThrottler shutdown. Dropped &#123;&#125; requests&quot;</span>, dropped);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>RequestThrottler 调用了 ZooKeeperServer.submitRequestNow() 方法，而该方法又调用了firstProcessor() 的方法，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">submitRequestNow</span><span class="hljs-params">(Request si)</span> </span>&#123;<br>    <span class="hljs-comment">// 略...</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        touch(si.cnxn);<br>        <span class="hljs-keyword">boolean</span> validpacket = Request.isValid(si.type);<br>        <span class="hljs-keyword">if</span> (validpacket) &#123;<br>            setLocalSessionFlag(si);<br>            <span class="hljs-comment">// firstProcessor = PrepRequestProcessor</span><br>            firstProcessor.processRequest(si);<br>            <span class="hljs-keyword">if</span> (si.cnxn != <span class="hljs-keyword">null</span>) &#123;<br>                incInProcess();<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            LOG.warn(<span class="hljs-string">&quot;Received packet at server of unknown type &#123;&#125;&quot;</span>, si.type);<br>            <span class="hljs-comment">// Update request accounting/throttling limits</span><br>            requestFinished(si);<br>            <span class="hljs-keyword">new</span> UnimplementedRequestProcessor().processRequest(si);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (MissingSessionException e) &#123;<br>        LOG.debug(<span class="hljs-string">&quot;Dropping request.&quot;</span>, e);<br>        <span class="hljs-comment">// Update request accounting/throttling limits</span><br>        requestFinished(si);<br>    &#125; <span class="hljs-keyword">catch</span> (RequestProcessorException e) &#123;<br>        LOG.error(<span class="hljs-string">&quot;Unable to process request&quot;</span>, e);<br>        <span class="hljs-comment">// Update request accounting/throttling limits</span><br>        requestFinished(si);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>ZooKeeperServer.submitRequestNow() 方法调用了 firstProcessor.processRequest() 方法，而这里的 firstProcessor 就是初始化业务处理链中的 PrepRequestProcessor ，也就是说三个RequestProecessor 中最先调用的是 PrepRequestProcessor 。</p>
<p>PrepRequestProcessor.processRequest() 方法将当前请求添加到了队列 submittedRequests 中，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processRequest</span><span class="hljs-params">(Request request)</span> </span>&#123;<br>    request.prepQueueStartTime = Time.currentElapsedTime();<br>    <span class="hljs-comment">// 添加到队列submittedRequests中</span><br>    submittedRequests.add(request);<br>    ServerMetrics.getMetrics().PREP_PROCESSOR_QUEUED.add(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>PrepRequestProcessor 同样是一个线程，对request的处理会在 run 中执行， run 中调用了 pRequest() 方法， pRequest() 方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pRequest</span><span class="hljs-params">(Request request)</span> <span class="hljs-keyword">throws</span> RequestProcessorException </span>&#123;<br>    <span class="hljs-comment">// LOG.info(&quot;Prep&gt;&gt;&gt; cxid = &quot; + request.cxid + &quot; type = &quot; +</span><br>    <span class="hljs-comment">// request.type + &quot; id = 0x&quot; + Long.toHexString(request.sessionId));</span><br>    request.setHdr(<span class="hljs-keyword">null</span>);<br>    request.setTxn(<span class="hljs-keyword">null</span>);<br><br>    <span class="hljs-keyword">if</span> (!request.isThrottled()) &#123;<br>      <span class="hljs-comment">// 处理业务流程  </span><br>      pRequestHelper(request);<br>    &#125;<br><br>    request.zxid = zks.getZxid();<br>    <span class="hljs-keyword">long</span> timeFinishedPrepare = Time.currentElapsedTime();<br>    ServerMetrics.getMetrics().PREP_PROCESS_TIME.add(timeFinishedPrepare - request.prepStartTime);<br>    <span class="hljs-comment">// 交给下一个业务链处理</span><br>    nextProcessor.processRequest(request);<br>    ServerMetrics.getMetrics().PROPOSAL_PROCESS_TIME.add(Time.currentElapsedTime() - timeFinishedPrepare);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>首先执行 pRequestHelper() 方法，该方法是 PrepRequestProcessor 处理核心业务流程，主要是一些过滤操作，操作完成后，会将请求交给下一个业务链，也就是SyncRequestProcessor.processRequest() 方法处理请求。</p>
<p>PrepRequestProcessor.pRequestHelper() 方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pRequestHelper</span><span class="hljs-params">(Request request)</span> <span class="hljs-keyword">throws</span> RequestProcessorException </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 操作类型，在ZooDefs中可以查看对应操作编码</span><br>        <span class="hljs-keyword">switch</span> (request.type) &#123;<br>        <span class="hljs-keyword">case</span> OpCode.createContainer:<br>        <span class="hljs-keyword">case</span> OpCode.create:<br>        <span class="hljs-keyword">case</span> OpCode.create2:<br>            CreateRequest create2Request = <span class="hljs-keyword">new</span> CreateRequest();<br>            pRequest2Txn(request.type, zks.getNextZxid(), request, create2Request, <span class="hljs-keyword">true</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> OpCode.createTTL:<br>            CreateTTLRequest createTtlRequest = <span class="hljs-keyword">new</span> CreateTTLRequest();<br>            pRequest2Txn(request.type, zks.getNextZxid(), request, createTtlRequest, <span class="hljs-keyword">true</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> OpCode.deleteContainer:<br>        <span class="hljs-keyword">case</span> OpCode.delete:<br>            DeleteRequest deleteRequest = <span class="hljs-keyword">new</span> DeleteRequest();<br>            pRequest2Txn(request.type, zks.getNextZxid(), request, deleteRequest, <span class="hljs-keyword">true</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> OpCode.setData:<br>            SetDataRequest setDataRequest = <span class="hljs-keyword">new</span> SetDataRequest();<br>            pRequest2Txn(request.type, zks.getNextZxid(), request, setDataRequest, <span class="hljs-keyword">true</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> OpCode.reconfig:<br>            ReconfigRequest reconfigRequest = <span class="hljs-keyword">new</span> ReconfigRequest();<br>            ByteBufferInputStream.byteBuffer2Record(request.request, reconfigRequest);<br>            pRequest2Txn(request.type, zks.getNextZxid(), request, reconfigRequest, <span class="hljs-keyword">true</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> OpCode.setACL:<br>            SetACLRequest setAclRequest = <span class="hljs-keyword">new</span> SetACLRequest();<br>            pRequest2Txn(request.type, zks.getNextZxid(), request, setAclRequest, <span class="hljs-keyword">true</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> OpCode.check:<br>            CheckVersionRequest checkRequest = <span class="hljs-keyword">new</span> CheckVersionRequest();<br>            pRequest2Txn(request.type, zks.getNextZxid(), request, checkRequest, <span class="hljs-keyword">true</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">// 略...    </span><br></code></pre></td></tr></table></figure>

<p>从上面源码可以看出 PrepRequestProcessor.pRequestHelper() 方法判断了客户端操作类型，但无论哪种操作类型几乎都调用了 pRequest2Txn() 方法，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pRequest2Txn</span><span class="hljs-params">(<span class="hljs-keyword">int</span> type, <span class="hljs-keyword">long</span> zxid, Request request, Record record, <span class="hljs-keyword">boolean</span> deserialize)</span> <span class="hljs-keyword">throws</span> KeeperException, IOException, RequestProcessorException </span>&#123;<br>    <span class="hljs-keyword">if</span> (request.getHdr() == <span class="hljs-keyword">null</span>) &#123;<br>        request.setHdr(<span class="hljs-keyword">new</span> TxnHeader(request.sessionId, request.cxid, zxid,<br>                Time.currentWallTime(), type));<br>    &#125;<br><br>    PrecalculatedDigest precalculatedDigest;<br>    <span class="hljs-keyword">switch</span> (type) &#123;<br>    <span class="hljs-keyword">case</span> OpCode.create:<br>    <span class="hljs-keyword">case</span> OpCode.create2:<br>    <span class="hljs-keyword">case</span> OpCode.createTTL:<br>    <span class="hljs-keyword">case</span> OpCode.createContainer: &#123;<br>        pRequest2TxnCreate(type, request, record, deserialize);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">case</span> OpCode.deleteContainer: &#123;<br>        String path = <span class="hljs-keyword">new</span> String(request.request.array(), UTF_8);<br>        String parentPath = getParentPathAndValidate(path);<br>        ChangeRecord nodeRecord = getRecordForPath(path);<br>        <span class="hljs-keyword">if</span> (nodeRecord.childCount &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> KeeperException.NotEmptyException(path);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (EphemeralType.get(nodeRecord.stat.getEphemeralOwner()) == EphemeralType.NORMAL) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> KeeperException.BadVersionException(path);<br>        &#125;<br>        <span class="hljs-comment">// 修改快照数据记录</span><br>        ChangeRecord parentRecord = getRecordForPath(parentPath);<br>        <span class="hljs-comment">// 事务信息记录</span><br>        request.setTxn(<span class="hljs-keyword">new</span> DeleteTxn(path));<br>        parentRecord = parentRecord.duplicate(request.getHdr().getZxid());<br>        parentRecord.childCount--;<br>        <span class="hljs-comment">// 状态数据记录</span><br>        parentRecord.stat.setPzxid(request.getHdr().getZxid());<br>        parentRecord.precalculatedDigest = precalculateDigest(<br>                DigestOpCode.UPDATE, parentPath, parentRecord.data, parentRecord.stat);<br>        addChangeRecord(parentRecord);<br><br>        nodeRecord = <span class="hljs-keyword">new</span> ChangeRecord(request.getHdr().getZxid(), path, <span class="hljs-keyword">null</span>, -<span class="hljs-number">1</span>, <span class="hljs-keyword">null</span>);<br>        nodeRecord.precalculatedDigest = precalculateDigest(DigestOpCode.REMOVE, path);<br>        setTxnDigest(request, nodeRecord.precalculatedDigest);<br>        addChangeRecord(nodeRecord);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">case</span> OpCode.delete:<br>        zks.sessionTracker.checkSession(request.sessionId, request.getOwner());<br>        DeleteRequest deleteRequest = (DeleteRequest) record;<br>        <span class="hljs-keyword">if</span> (deserialize) &#123;<br>            ByteBufferInputStream.byteBuffer2Record(request.request, deleteRequest);<br>        &#125;<br>        String path = deleteRequest.getPath();<br>        String parentPath = getParentPathAndValidate(path);<br>        ChangeRecord parentRecord = getRecordForPath(parentPath);<br>        <span class="hljs-comment">// 权限检查</span><br>        zks.checkACL(request.cnxn, parentRecord.acl, ZooDefs.Perms.DELETE, request.authInfo, path, <span class="hljs-keyword">null</span>);<br>        ChangeRecord nodeRecord = getRecordForPath(path);<br>        checkAndIncVersion(nodeRecord.stat.getVersion(), deleteRequest.getVersion(), path);<br>        <span class="hljs-keyword">if</span> (nodeRecord.childCount &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> KeeperException.NotEmptyException(path);<br>        &#125;<br>        request.setTxn(<span class="hljs-keyword">new</span> DeleteTxn(path));<br>        parentRecord = parentRecord.duplicate(request.getHdr().getZxid());<br>        parentRecord.childCount--;<br>        parentRecord.stat.setPzxid(request.getHdr().getZxid());<br>        parentRecord.precalculatedDigest = precalculateDigest(<br>                DigestOpCode.UPDATE, parentPath, parentRecord.data, parentRecord.stat);<br>        addChangeRecord(parentRecord);<br><br>        nodeRecord = <span class="hljs-keyword">new</span> ChangeRecord(request.getHdr().getZxid(), path, <span class="hljs-keyword">null</span>, -<span class="hljs-number">1</span>, <span class="hljs-keyword">null</span>);<br>        nodeRecord.precalculatedDigest = precalculateDigest(DigestOpCode.REMOVE, path);<br>        setTxnDigest(request, nodeRecord.precalculatedDigest);<br>        addChangeRecord(nodeRecord);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> OpCode.setData:<br>        zks.sessionTracker.checkSession(request.sessionId, request.getOwner());<br>        SetDataRequest setDataRequest = (SetDataRequest) record;<br>        <span class="hljs-keyword">if</span> (deserialize) &#123;<br>            ByteBufferInputStream.byteBuffer2Record(request.request, setDataRequest);<br>        &#125;<br>        path = setDataRequest.getPath();<br>        validatePath(path, request.sessionId);<br>        nodeRecord = getRecordForPath(path);<br>        <span class="hljs-comment">// 权限检查</span><br>        zks.checkACL(request.cnxn, nodeRecord.acl, ZooDefs.Perms.WRITE, request.authInfo, path, <span class="hljs-keyword">null</span>);<br>        zks.checkQuota(path, setDataRequest.getData(), OpCode.setData);<br>        <span class="hljs-keyword">int</span> newVersion = checkAndIncVersion(nodeRecord.stat.getVersion(), setDataRequest.getVersion(), path);<br>        request.setTxn(<span class="hljs-keyword">new</span> SetDataTxn(path, setDataRequest.getData(), newVersion));<br>        nodeRecord = nodeRecord.duplicate(request.getHdr().getZxid());<br>        nodeRecord.stat.setVersion(newVersion);<br>        nodeRecord.stat.setMtime(request.getHdr().getTime());<br>        nodeRecord.stat.setMzxid(zxid);<br>        nodeRecord.data = setDataRequest.getData();<br>        nodeRecord.precalculatedDigest = precalculateDigest(<br>                DigestOpCode.UPDATE, path, nodeRecord.data, nodeRecord.stat);<br>        setTxnDigest(request, nodeRecord.precalculatedDigest);<br>        addChangeRecord(nodeRecord);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> OpCode.reconfig:<br>        <span class="hljs-keyword">if</span> (!zks.isReconfigEnabled()) &#123;<br>            LOG.error(<span class="hljs-string">&quot;Reconfig operation requested but reconfig feature is disabled.&quot;</span>);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> KeeperException.ReconfigDisabledException();<br>        &#125;<br><br>        <span class="hljs-comment">// 权限检查</span><br>        <span class="hljs-keyword">if</span> (ZooKeeperServer.skipACL) &#123;<br>            LOG.warn(<span class="hljs-string">&quot;skipACL is set, reconfig operation will skip ACL checks!&quot;</span>);<br>        &#125;<br><br>        zks.sessionTracker.checkSession(request.sessionId, request.getOwner());<br>        LeaderZooKeeperServer lzks;<br>        <span class="hljs-keyword">try</span> &#123;<br>            lzks = (LeaderZooKeeperServer) zks;<br>        &#125; <span class="hljs-keyword">catch</span> (ClassCastException e) &#123;<br>            <span class="hljs-comment">// standalone mode - reconfiguration currently not supported</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> KeeperException.UnimplementedException();<br>        &#125;<br>        <span class="hljs-comment">// 略</span><br></code></pre></td></tr></table></figure>

<p>从上面代码可以看出 pRequest2Txn() 方法主要做了权限校验、快照记录、事务信息记录相关的事，还并未涉及数据处理，也就是说 PrepRequestProcessor 其实是做了操作前权限校验、快照记录、事务信息记录相关的事。</p>
<h4 id="SyncRequestProcessor剖析"><a href="#SyncRequestProcessor剖析" class="headerlink" title="SyncRequestProcessor剖析"></a>SyncRequestProcessor剖析</h4><p>分析了 PrepRequestProcessor 处理器后，接着来分析 SyncRequestProcessor ，该处理器主要是将请求数据高效率存入磁盘，并且请求在写入磁盘之前是不会被转发到下个处理器的。</p>
<p>我们先看请求被添加到队列的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processRequest</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Request request)</span> </span>&#123;<br>    Objects.requireNonNull(request, <span class="hljs-string">&quot;Request cannot be null&quot;</span>);<br><br>    request.syncQueueStartTime = Time.currentElapsedTime();<br>    <span class="hljs-comment">// 将请求添加到queuedRequests队列中</span><br>    queuedRequests.add(request);<br>    ServerMetrics.getMetrics().SYNC_PROCESSOR_QUEUED.add(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>同样 SyncRequestProcessor 是一个线程，执行队列中的请求也在线程中触发，我们看它的run方法，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// we do this in an attempt to ensure that not all of the servers</span><br>        <span class="hljs-comment">// in the ensemble take a snapshot at the same time</span><br>        <span class="hljs-comment">// 避免所有的server同时进行snapshot，重置snapshot判断条件</span><br>        resetSnapshotStats();<br>        lastFlushTime = Time.currentElapsedTime();<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            ServerMetrics.getMetrics().SYNC_PROCESSOR_QUEUE_SIZE.add(queuedRequests.size());<br><br>            <span class="hljs-keyword">long</span> pollTime = Math.min(zks.getMaxWriteQueuePollTime(), getRemainingDelay());<br>            <span class="hljs-comment">// 获取一个需要处理的请求</span><br>            Request si = queuedRequests.poll(pollTime, TimeUnit.MILLISECONDS);<br>            <span class="hljs-keyword">if</span> (si == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">/* We timed out looking for more writes to batch, go ahead and flush immediately */</span><br>                flush();<br>                <span class="hljs-comment">// 阻塞方法获取一个请求</span><br>                si = queuedRequests.take();<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (si == REQUEST_OF_DEATH) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">long</span> startProcessTime = Time.currentElapsedTime();<br>            ServerMetrics.getMetrics().SYNC_PROCESSOR_QUEUE_TIME.add(startProcessTime - si.syncQueueStartTime);<br><br>            <span class="hljs-comment">// 跟踪写入日志的记录数量</span><br>            <span class="hljs-comment">// track the number of records written to the log</span><br>            <span class="hljs-keyword">if</span> (!si.isThrottled() &amp;&amp; zks.getZKDatabase().append(si)) &#123;<br>                <span class="hljs-comment">// shouldSnapshot()：快照保存条件，根据 logCount 日志数量和 logSize 日志大小与snapCount快照的比较，具有随机性。</span><br>                <span class="hljs-keyword">if</span> (shouldSnapshot()) &#123;<br>                    <span class="hljs-comment">// 重置是否需要snapshot判断条件</span><br>                    resetSnapshotStats();<br>                    <span class="hljs-comment">// roll the log</span><br>                    <span class="hljs-comment">// 重置上次以来rollLog以来的事务的txn数量</span><br>                    zks.getZKDatabase().rollLog();<br>                    <span class="hljs-comment">// take a snapshot</span><br>                    <span class="hljs-keyword">if</span> (!snapThreadMutex.tryAcquire()) &#123;<br>                        LOG.warn(<span class="hljs-string">&quot;Too busy to snap, skipping&quot;</span>);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-keyword">new</span> ZooKeeperThread(<span class="hljs-string">&quot;Snapshot Thread&quot;</span>) &#123;<br>                            <span class="hljs-comment">// 创建线程保存快照数据</span><br>                            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                                <span class="hljs-keyword">try</span> &#123;<br>                                    <span class="hljs-comment">// 保存快照数据</span><br>                                    zks.takeSnapshot();<br>                                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                                    LOG.warn(<span class="hljs-string">&quot;Unexpected exception&quot;</span>, e);<br>                                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                                    snapThreadMutex.release();<br>                                &#125;<br>                            &#125;<br>                        &#125;.start();<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (toFlush.isEmpty()) &#123;<br>                <span class="hljs-comment">// optimization for read heavy workloads</span><br>                <span class="hljs-comment">// iff this is a read or a throttled request(which doesn&#x27;t need to be written to the disk),</span><br>                <span class="hljs-comment">// and there are no pending flushes (writes), then just pass this to the next processor</span><br>                <span class="hljs-keyword">if</span> (nextProcessor != <span class="hljs-keyword">null</span>) &#123;<br>                    nextProcessor.processRequest(si);<br>                    <span class="hljs-keyword">if</span> (nextProcessor <span class="hljs-keyword">instanceof</span> Flushable) &#123;<br>                        ((Flushable) nextProcessor).flush();<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">// 将当前请求添加到toFlush队列中，toFlush队列是已经写入并等待刷新到磁盘的事务</span><br>            toFlush.add(si);<br>            <span class="hljs-keyword">if</span> (shouldFlush()) &#123;<br>                <span class="hljs-comment">// 提交数据</span><br>                flush();<br>            &#125;<br>            ServerMetrics.getMetrics().SYNC_PROCESS_TIME.add(Time.currentElapsedTime() - startProcessTime);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        handleException(<span class="hljs-keyword">this</span>.getName(), t);<br>    &#125;<br>    LOG.info(<span class="hljs-string">&quot;SyncRequestProcessor exited!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>run 方法会从 queuedRequests 队列中获取一个请求，如果获取不到就会阻塞等待直到获取到一个请求对象，程序才会继续往下执行，接下来会调用 Snapshot Thread 线程实现将客户端发送的数据以快照的方式写入磁盘，最终调用 flush() 方法实现数据提交， flush() 方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">flush</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, RequestProcessorException </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.toFlush.isEmpty()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    ServerMetrics.getMetrics().BATCH_SIZE.add(toFlush.size());<br><br>    <span class="hljs-keyword">long</span> flushStartTime = Time.currentElapsedTime();<br>    <span class="hljs-comment">// 数据提交</span><br>    zks.getZKDatabase().commit();<br>    ServerMetrics.getMetrics().SYNC_PROCESSOR_FLUSH_TIME.add(Time.currentElapsedTime() - flushStartTime);<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.nextProcessor == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">this</span>.toFlush.clear();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">while</span> (!<span class="hljs-keyword">this</span>.toFlush.isEmpty()) &#123;<br>            <span class="hljs-keyword">final</span> Request i = <span class="hljs-keyword">this</span>.toFlush.remove();<br>            <span class="hljs-keyword">long</span> latency = Time.currentElapsedTime() - i.syncQueueStartTime;<br>            ServerMetrics.getMetrics().SYNC_PROCESSOR_QUEUE_AND_FLUSH_TIME.add(latency);<br>            <span class="hljs-comment">// 执行下一个业务链对象，下一个业务链对象是FinalRequestProcessor</span><br>            <span class="hljs-keyword">this</span>.nextProcessor.processRequest(i);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.nextProcessor <span class="hljs-keyword">instanceof</span> Flushable) &#123;<br>            ((Flushable) <span class="hljs-keyword">this</span>.nextProcessor).flush();<br>        &#125;<br>    &#125;<br>    lastFlushTime = Time.currentElapsedTime();<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="FinalRequestProcessor剖析"><a href="#FinalRequestProcessor剖析" class="headerlink" title="FinalRequestProcessor剖析"></a>FinalRequestProcessor剖析</h4><p>flush() 方法实现了数据提交，并且会将请求交给下一个业务链，下一个业务链为 FinalRequestProcessor 也就是请求处理链中最后的一个处理器，该业务处理对象主要用于返回Response。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processRequest</span><span class="hljs-params">(Request request)</span> </span>&#123;<br>    LOG.debug(<span class="hljs-string">&quot;Processing request:: &#123;&#125;&quot;</span>, request);<br><br>    <span class="hljs-keyword">if</span> (LOG.isTraceEnabled()) &#123;<br>        <span class="hljs-keyword">long</span> traceMask = ZooTrace.CLIENT_REQUEST_TRACE_MASK;<br>        <span class="hljs-keyword">if</span> (request.type == OpCode.ping) &#123;<br>            traceMask = ZooTrace.SERVER_PING_TRACE_MASK;<br>        &#125;<br>        ZooTrace.logRequest(LOG, traceMask, <span class="hljs-string">&#x27;E&#x27;</span>, request, <span class="hljs-string">&quot;&quot;</span>);<br>    &#125;<br>    ProcessTxnResult rc = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">if</span> (!request.isThrottled()) &#123;<br>      rc = applyRequest(request);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (request.cnxn == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    ServerCnxn cnxn = request.cnxn;<br><br>    <span class="hljs-keyword">long</span> lastZxid = zks.getZKDatabase().getDataTreeLastProcessedZxid();<br><br>    String lastOp = <span class="hljs-string">&quot;NA&quot;</span>;<br>    <span class="hljs-comment">// Notify ZooKeeperServer that the request has finished so that it can</span><br>    <span class="hljs-comment">// update any request accounting/throttling limits</span><br>    zks.decInProcess();<br>    zks.requestFinished(request);<br>    Code err = Code.OK;<br>    Record rsp = <span class="hljs-keyword">null</span>;<br>    String path = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">int</span> responseSize = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (request.getHdr() != <span class="hljs-keyword">null</span> &amp;&amp; request.getHdr().getType() == OpCode.error) &#123;<br>            AuditHelper.addAuditLog(request, rc, <span class="hljs-keyword">true</span>);<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             * When local session upgrading is disabled, leader will</span><br><span class="hljs-comment">             * reject the ephemeral node creation due to session expire.</span><br><span class="hljs-comment">             * However, if this is the follower that issue the request,</span><br><span class="hljs-comment">             * it will have the correct error code, so we should use that</span><br><span class="hljs-comment">             * and report to user</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-keyword">if</span> (request.getException() != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">throw</span> request.getException();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">throw</span> KeeperException.create(KeeperException.Code.get(((ErrorTxn) request.getTxn()).getErr()));<br>            &#125;<br>        &#125;<br><br>        KeeperException ke = request.getException();<br>        <span class="hljs-keyword">if</span> (ke <span class="hljs-keyword">instanceof</span> SessionMovedException) &#123;<br>            <span class="hljs-keyword">throw</span> ke;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (ke != <span class="hljs-keyword">null</span> &amp;&amp; request.type != OpCode.multi) &#123;<br>            <span class="hljs-keyword">throw</span> ke;<br>        &#125;<br><br>        LOG.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, request);<br><br>        <span class="hljs-keyword">if</span> (request.isStale()) &#123;<br>            ServerMetrics.getMetrics().STALE_REPLIES.add(<span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (request.isThrottled()) &#123;<br>          <span class="hljs-keyword">throw</span> KeeperException.create(Code.THROTTLEDOP);<br>        &#125;<br><br>        AuditHelper.addAuditLog(request, rc);<br><br>        <span class="hljs-keyword">switch</span> (request.type) &#123;<br>        <span class="hljs-keyword">case</span> OpCode.ping: &#123;<br>            lastOp = <span class="hljs-string">&quot;PING&quot;</span>;<br>            <span class="hljs-comment">// 设置响应状态</span><br>            updateStats(request, lastOp, lastZxid);<br>            <span class="hljs-comment">// 响应数据</span><br>            responseSize = cnxn.sendResponse(<span class="hljs-keyword">new</span> ReplyHeader(ClientCnxn.PING_XID, lastZxid, <span class="hljs-number">0</span>), <span class="hljs-keyword">null</span>, <span class="hljs-string">&quot;response&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> OpCode.createSession: &#123;<br>            lastOp = <span class="hljs-string">&quot;SESS&quot;</span>;<br>            <span class="hljs-comment">// 设置响应状态</span><br>            updateStats(request, lastOp, lastZxid);<br>            <span class="hljs-comment">// 响应数据并结束会话</span><br>            zks.finishSessionInit(request.cnxn, <span class="hljs-keyword">true</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> OpCode.multi: &#123;<br>            <span class="hljs-comment">// 多重操作</span><br>            lastOp = <span class="hljs-string">&quot;MULT&quot;</span>;<br>            rsp = <span class="hljs-keyword">new</span> MultiResponse();<br>            <span class="hljs-comment">// 遍历多重操作结果</span><br>            <span class="hljs-keyword">for</span> (ProcessTxnResult subTxnResult : rc.multiResult) &#123;<br><br>                OpResult subResult;<br><br>                <span class="hljs-keyword">switch</span> (subTxnResult.type) &#123;<br>                <span class="hljs-keyword">case</span> OpCode.check:<br>                    <span class="hljs-comment">// 检查</span><br>                    subResult = <span class="hljs-keyword">new</span> CheckResult();<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> OpCode.create:<br>                    <span class="hljs-comment">// 创建</span><br>                    subResult = <span class="hljs-keyword">new</span> CreateResult(subTxnResult.path);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> OpCode.create2:<br>                <span class="hljs-keyword">case</span> OpCode.createTTL:<br>                <span class="hljs-keyword">case</span> OpCode.createContainer:<br>                    subResult = <span class="hljs-keyword">new</span> CreateResult(subTxnResult.path, subTxnResult.stat);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> OpCode.delete:<br>                <span class="hljs-keyword">case</span> OpCode.deleteContainer:<br>                    <span class="hljs-comment">// 删除</span><br>                    subResult = <span class="hljs-keyword">new</span> DeleteResult();<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> OpCode.setData:<br>                    <span class="hljs-comment">// 设置数据</span><br>                    subResult = <span class="hljs-keyword">new</span> SetDataResult(subTxnResult.stat);<br>                    <br></code></pre></td></tr></table></figure>

<h4 id="ZK业务链处理优劣总结"><a href="#ZK业务链处理优劣总结" class="headerlink" title="ZK业务链处理优劣总结"></a>ZK业务链处理优劣总结</h4><p>Zookeeper业务链处理，思想遵循了AOP思想，但并未采用相关技术，为了提升效率，仍然大幅使用到了多线程。正因为有了业务链路处理先后顺序，使的Zookeeper业务处理流程更清晰更容易理解，但大量混入了多线程，也似的学习成本增加。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/blog/categories/Zookeeper/" class="category-chain-item">Zookeeper</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/blog/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">#源码解析</a>
      
        <a href="/blog/tags/zookeeper/">#zookeeper</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Zookeeper源码分析上</div>
      <div>http://zhaoguocheng.gitee.io/2021/01/19/Zookeeper/Zookeeper源码分析上/</div>
    </div>
    <div class="license-meta">
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2021年1月19日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/blog/2021/01/19/Zookeeper/Zookeeper%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8B/" title="Zookeeper源码分析下">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Zookeeper源码分析下</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/blog/2020/12/31/Docker%E5%AE%B9%E5%99%A8/docker%E5%BC%95%E6%93%8E%E4%B8%8E%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/" title="Docker引擎与核心组件">
                        <span class="hidden-mobile">Docker引擎与核心组件</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/blog/js/events.js" ></script>
<script  src="/blog/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/blog/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/blog/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/blog/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
