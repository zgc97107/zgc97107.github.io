<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Redis的高可用</title>
    <link href="/blog/2020/08/22/%E7%BC%93%E5%AD%98-Redis%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
    <url>/blog/2020/08/22/%E7%BC%93%E5%AD%98-Redis%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="Redis集群配置"><a href="#Redis集群配置" class="headerlink" title="Redis集群配置"></a>Redis集群配置</h3><p>现在安装对应的应用软件一般都推荐使用Docker容器，这里也不例外，直接使用Docker容器进行安装，安装大概要分这几个步骤： </p><ol><li><p>创建redis‐cluster.tmpl配置Redis信息【端口、是否开启集群等】 </p></li><li><p>创建redis.sh配置需要创建的redis信息 </p></li><li><p>添加网络，redis集群使用该网络 </p></li><li><p>执行redis.sh实现创建redis </p></li><li><p>执行redis‐cli创建集群</p></li></ol><h4 id="配置Redis信息"><a href="#配置Redis信息" class="headerlink" title="配置Redis信息"></a>配置Redis信息</h4><p>创建 redis-cluster.tmpl 配置Redis信息</p><pre><code class="hljs yaml"><span class="hljs-comment">#端口</span><span class="hljs-string">port</span> <span class="hljs-string">$&#123;PORT&#125;</span><span class="hljs-comment">#非保护模式</span><span class="hljs-string">protected-mode</span> <span class="hljs-literal">no</span><span class="hljs-comment">#启用集群模式</span><span class="hljs-string">cluster-enabled</span> <span class="hljs-literal">yes</span><span class="hljs-string">cluster-config-file</span> <span class="hljs-string">nodes.conf</span><span class="hljs-comment">#超时时间</span><span class="hljs-string">cluster-node-timeout</span> <span class="hljs-number">5000</span><span class="hljs-comment">#集群各节点IP地址</span><span class="hljs-string">cluster-announce-ip</span> <span class="hljs-string">$&#123;Native_IP&#125;</span><span class="hljs-comment">#集群节点映射端口</span><span class="hljs-string">cluster-announce-port</span> <span class="hljs-string">$&#123;PORT&#125;</span><span class="hljs-comment">#集群总线端口</span><span class="hljs-string">cluster-announce-bus-port</span> <span class="hljs-number">1</span><span class="hljs-string">$&#123;PORT&#125;</span><span class="hljs-comment">#开启aof持久化策略</span><span class="hljs-string">appendonly</span> <span class="hljs-literal">yes</span><span class="hljs-comment">#后台运行</span><span class="hljs-comment">#daemonize yes </span><span class="hljs-comment">#进程号存储</span><span class="hljs-string">pidfile</span>  <span class="hljs-string">/var/run/redis_$&#123;PORT&#125;.pid</span><span class="hljs-comment">#集群加密</span><span class="hljs-comment">#masterauth itheima </span><span class="hljs-comment">#requirepass itheima</span></code></pre><h4 id="Redis创建配置"><a href="#Redis创建配置" class="headerlink" title="Redis创建配置"></a>Redis创建配置</h4><p>创建redis.sh配置需要创建的Redis集群</p><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-comment">#在/usr/local/server/redis-cluster下生成conf和data目标，并生成配置信息</span><span class="hljs-comment">#输入信息</span><span class="hljs-built_in">read</span> -p <span class="hljs-string">"请输入本机IP地址："</span> Native_IP<span class="hljs-comment"># 创建文件夹</span>mkdir -p /usr/<span class="hljs-built_in">local</span>/server/redis-cluster<span class="hljs-comment"># 下载redis配置模板</span><span class="hljs-built_in">echo</span> <span class="hljs-string">"正在下载redis-cluster.tmpl配置模板"</span>;wget -P /usr/<span class="hljs-built_in">local</span>/server/redis-cluster https://srv-file22.gofile.io/download/RoGvVk/redis-cluster.tmpl<span class="hljs-built_in">echo</span> <span class="hljs-string">"正在创建redis-net网络"</span>;<span class="hljs-comment">#c创建网络</span>docker network create redis-net<span class="hljs-built_in">echo</span> <span class="hljs-string">"正在创建redis配置文件"</span>;<span class="hljs-keyword">for</span> port <span class="hljs-keyword">in</span> `seq 7001 7006`; <span class="hljs-keyword">do</span>   mkdir -p /usr/<span class="hljs-built_in">local</span>/server/redis-cluster/<span class="hljs-variable">$&#123;port&#125;</span>/conf &amp;&amp; PORT=<span class="hljs-variable">$&#123;port&#125;</span> Native_IP=<span class="hljs-variable">$&#123;Native_IP&#125;</span>  envsubst &lt; /usr/<span class="hljs-built_in">local</span>/server/redis-cluster/redis-cluster.tmpl &gt; /usr/<span class="hljs-built_in">local</span>/server/redis-cluster/<span class="hljs-variable">$&#123;port&#125;</span>/conf/redis.conf &amp;&amp; mkdir -p /usr/<span class="hljs-built_in">local</span>/server/redis-cluster/<span class="hljs-variable">$&#123;port&#125;</span>/data;<span class="hljs-keyword">done</span><span class="hljs-built_in">echo</span> <span class="hljs-string">"正在启动redis容器"</span>;<span class="hljs-comment">#创建6个redis容器</span><span class="hljs-keyword">for</span> port <span class="hljs-keyword">in</span> `seq 7001 7006`;<span class="hljs-keyword">do</span>docker run -d -it -p <span class="hljs-variable">$&#123;port&#125;</span>:<span class="hljs-variable">$&#123;port&#125;</span> -p 1<span class="hljs-variable">$&#123;port&#125;</span>:1<span class="hljs-variable">$&#123;port&#125;</span> -v /usr/<span class="hljs-built_in">local</span>/server/redis-cluster/<span class="hljs-variable">$&#123;port&#125;</span>/conf/redis.conf:/usr/<span class="hljs-built_in">local</span>/etc/redis/redis.conf -v /usr/<span class="hljs-built_in">local</span>/server/redis-cluster/<span class="hljs-variable">$&#123;port&#125;</span>/data:/data --privileged=<span class="hljs-literal">true</span> --restart always --name redis-<span class="hljs-variable">$&#123;port&#125;</span> --net redis-net --sysctl net.core.somaxconn=1024 redis redis-server /usr/<span class="hljs-built_in">local</span>/etc/redis/redis.conf;<span class="hljs-keyword">done</span><span class="hljs-comment">#查找ip</span><span class="hljs-keyword">for</span> port <span class="hljs-keyword">in</span> `seq 7001 7006`;<span class="hljs-keyword">do</span><span class="hljs-built_in">echo</span>  -n <span class="hljs-string">"<span class="hljs-variable">$(docker inspect --format '&#123;&#123; (index .NetworkSettings.Networks "redis-net")</span>.IPAddress &#125;&#125;' "</span>redis-<span class="hljs-variable">$&#123;port&#125;</span><span class="hljs-string">")"</span>:<span class="hljs-variable">$&#123;port&#125;</span><span class="hljs-string">" "</span>;<span class="hljs-keyword">done</span><span class="hljs-comment">#换行</span><span class="hljs-built_in">echo</span> -e <span class="hljs-string">"\n"</span><span class="hljs-comment">#输入信息</span><span class="hljs-built_in">read</span> -p <span class="hljs-string">"请把输入要启动的docker容器名称，默认redis-7001："</span> DOCKER_NAME<span class="hljs-comment">#判断是否为空</span><span class="hljs-keyword">if</span> [ ! <span class="hljs-variable">$DOCKER_NAME</span> ]; <span class="hljs-keyword">then</span> DOCKER_NAME=<span class="hljs-string">'redis-7001'</span>; <span class="hljs-keyword">fi</span><span class="hljs-comment">#进入容器</span>docker <span class="hljs-built_in">exec</span> -it redis-7001 /bin/bash<span class="hljs-comment"># 删除容器</span><span class="hljs-comment">#docker rm -f $(docker ps -a |  grep "redis-*"  | awk '&#123;print $1&#125;')</span></code></pre><p>移除脚本创建</p><p>创建stop.sh脚本，用于停止Redis容器，并且移除对应容器</p><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span>docker stop redis-7001 redis-7002 redis-7003 redis-7004 redis-7005 redis-7006docker rm redis-7001 redis-7002 redis-7003 redis-7004 redis-7005 redis-7006rm -rf 7001 7002 7003 7004 7005 7006</code></pre><p>脚本授权：给 redis.sh 和 stop.sh 添加可执行权限：</p><pre><code class="hljs sh">chmod +x redis.sh chmod +x stop.sh</code></pre><p>执行脚本开始安装Redis节点，并进入到 /usr/local/bin 目录下执行 redis-cli 创建集群关联：</p><pre><code class="hljs sh">./redis.sh redis-cli \--cluster create 172.18.0.2:7001 172.18.0.3:7002 172.18.0.4:7003 172.18.0.5:7004 172.18.0.6:7005 172.18.0.7:7006 \--cluster-replicas 1</code></pre><p><strong>–cluster-replicas</strong> 表示有一个主有几个slave。</p><img src="/blog/2020/08/22/%E7%BC%93%E5%AD%98-Redis%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8/pic21.png" srcset="/blog/img/loading.gif" class><p>安装好了后，链接Redis效果如下：</p><img src="/blog/2020/08/22/%E7%BC%93%E5%AD%98-Redis%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8/pic22.png" srcset="/blog/img/loading.gif" class><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><h4 id="主从拓扑"><a href="#主从拓扑" class="headerlink" title="主从拓扑"></a>主从拓扑</h4><h5 id="一主一从"><a href="#一主一从" class="headerlink" title="一主一从"></a>一主一从</h5><img src="/blog/2020/08/22/%E7%BC%93%E5%AD%98-Redis%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8/pic1.png" srcset="/blog/img/loading.gif" class><p>主节点的写入命令会同步到从节点，当需要持久化时，可以只在从节点开启AOF。</p><h5 id="一主多从"><a href="#一主多从" class="headerlink" title="一主多从"></a>一主多从</h5><img src="/blog/2020/08/22/%E7%BC%93%E5%AD%98-Redis%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8/pic2.png" srcset="/blog/img/loading.gif" class><p>针对读较多的场景，读由多个从节点来分担，但节点越多，主节点同步到多节点的次数也越多，影响带宽，也加重主节点的稳定。</p><h5 id="树状主从"><a href="#树状主从" class="headerlink" title="树状主从"></a>树状主从</h5><img src="/blog/2020/08/22/%E7%BC%93%E5%AD%98-Redis%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8/pic3.png" srcset="/blog/img/loading.gif" class><p>用来解决一主多从主节点的推送压力，主节点只推送一次数据到从节点B，再由从节点B推送到C和D，减轻主节点推送的压力</p><h4 id="复制原理"><a href="#复制原理" class="headerlink" title="复制原理"></a>复制原理</h4><img src="/blog/2020/08/22/%E7%BC%93%E5%AD%98-Redis%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8/pic4.png" srcset="/blog/img/loading.gif" class><ol><li><p>Slave服务启动，主动连接Master，并发送SYNC命令，请求初始化同步； </p></li><li><p>Master收到SYNC后，执行BGSAVE命令生成RDB文件，并缓存该时间段内的写命令； </p></li><li><p>Master完成RDB文件后，将其发送给所有Slave服务器； </p></li><li><p>Slave服务器接收到RDB文件后，删除内存中旧的缓存数据，并装载RDB文件； </p></li><li><p>Master在发送完RDB后，即刻向所有Slave服务器发送缓存中的写命令； </p></li></ol><h4 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h4><p>redis 2.8版本以上使用psync命令完成同步，复制方式分为全量与部分复制</p><ul><li><p>全量复制：一般用于初次复制场景（第一次建立SLAVE后全量）。</p></li><li><p>部分复制：网络出现问题，从节点再次连主节点时，主节点补发缺少的数据，每次数据增加同步。</p></li></ul><p>心跳：主从有长连接心跳，主节点默认每10S向从节点发ping命令，<code>repl-ping-slave-period</code>属性可以控制发送频率。</p><h4 id="集群扩容收容"><a href="#集群扩容收容" class="headerlink" title="集群扩容收容"></a>集群扩容收容</h4><p>上面虽然创建了主从复制，但如果手动给节点添加一个从节点，有可能添加从节点，也有可能添加从节点，这是我们想要干的。接下来我们给集群节点添加指定的从节点。 </p><p>我们安装 7007 、 7008 、 7009 几个Redis节点，然后将 7007 和 7008 作为主节点，添加到集群中， 7009 作为从节点添加到集群中。</p><table><thead><tr><th>Redis节点</th><th>IP</th><th>端口</th></tr></thead><tbody><tr><td>redis-7007</td><td>172.18.0.8</td><td>7007</td></tr><tr><td>redis-7008</td><td>172.18.0.9</td><td>7008</td></tr><tr><td>redis-7009</td><td>172.18.0.10</td><td>7009</td></tr></tbody></table><p>基于Docker安装Redis这里编写了一个脚本，安装脚本 redis-port.sh 如下：</p><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash </span><span class="hljs-comment">#在/usr/local/server/redis‐cluster下生成conf和data目标，并生成配置信息 </span><span class="hljs-comment">#换行</span><span class="hljs-built_in">echo</span> ‐e <span class="hljs-string">"\n"</span> <span class="hljs-comment">#输入信息 </span><span class="hljs-built_in">read</span> ‐p <span class="hljs-string">"请输入容器端口："</span> DOCKER_PORT <span class="hljs-comment">#输入端口赋值 </span>port=<span class="hljs-variable">$DOCKER_PORT</span>; <span class="hljs-built_in">echo</span> ‐e <span class="hljs-string">"<span class="hljs-variable">$port</span>"</span><span class="hljs-comment">#创建配置文件 </span>mkdir ‐p ./<span class="hljs-variable">$&#123;port&#125;</span>/conf &amp;&amp; PORT=<span class="hljs-variable">$&#123;port&#125;</span> envsubst &lt; ./redis‐cluster.tmpl &gt; ./<span class="hljs-variable">$&#123;port&#125;</span>/conf/redis.conf &amp;&amp; mkdir ‐p ./<span class="hljs-variable">$&#123;port&#125;</span>/data; <span class="hljs-comment">#创建redis容器 </span>docker run ‐d ‐it ‐p <span class="hljs-variable">$&#123;port&#125;</span>:<span class="hljs-variable">$&#123;port&#125;</span> ‐p 1<span class="hljs-variable">$&#123;port&#125;</span>:1<span class="hljs-variable">$&#123;port&#125;</span> ‐v /usr/<span class="hljs-built_in">local</span>/server/redis‐ cluster/<span class="hljs-variable">$&#123;port&#125;</span>/conf/redis.conf:/usr/<span class="hljs-built_in">local</span>/etc/redis/redis.conf ‐v /usr/<span class="hljs-built_in">local</span>/server/redis‐ cluster/<span class="hljs-variable">$&#123;port&#125;</span>/data:/data ‐‐privileged=<span class="hljs-literal">true</span> ‐‐restart always ‐‐name redis‐<span class="hljs-variable">$&#123;port&#125;</span> ‐‐net redis‐ net ‐‐sysctl net.core.somaxconn=1024 redis redis‐server /usr/<span class="hljs-built_in">local</span>/etc/redis/redis.conf; <span class="hljs-comment">#查找ip</span><span class="hljs-built_in">echo</span> ‐n <span class="hljs-string">"启动<span class="hljs-variable">$(docker inspect ‐‐format '&#123;&#123; (index .NetworkSettings.Networks "redis‐ net")</span>.IPAddress &#125;&#125;' "</span>redis‐<span class="hljs-variable">$&#123;port&#125;</span><span class="hljs-string">")"</span>:<span class="hljs-variable">$&#123;port&#125;</span><span class="hljs-string">" 成功！"</span>;<span class="hljs-built_in">echo</span> ‐e <span class="hljs-string">"\n"</span></code></pre><p>执行 redis-port.sh 脚本，实现 7007,7008,7009 节点安装。</p><p>查看集群状态 </p><p>主节点查看：</p><p><code>./redis‐cli ‐p 7001 cluster nodes|grep master</code></p><img src="/blog/2020/08/22/%E7%BC%93%E5%AD%98-Redis%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8/pic23.png" srcset="/blog/img/loading.gif" class><p>主节点状态信息如下： </p><p>从节点查看： </p><p><code>./redis‐cli ‐p 7001 cluster nodes|grep slave</code></p><p><img src="/blog/2020/08/22/%E7%BC%93%E5%AD%98-Redis%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8/pic24.png" srcset="/blog/img/loading.gif" class></p><p>从上面信息我们可以看出集群关系：</p><pre><code class="hljs angelscript">Master：<span class="hljs-number">7001</span> Slave：<span class="hljs-number">7005</span> Master：<span class="hljs-number">7002</span> Slave：<span class="hljs-number">7006</span> Master：<span class="hljs-number">7003</span> Slave：<span class="hljs-number">7004</span></code></pre><h5 id="添加集群主节点"><a href="#添加集群主节点" class="headerlink" title="添加集群主节点"></a>添加集群主节点</h5><p>我们需要给集群节点添加一个主节点，我们需要将 192.168.211.141:7007 节点添加到 192.168.211.141:7001 节点所在的集群中，并且添加后作为主节点，添加命令行如下：</p><p><code>./redis‐cli ‐‐cluster add‐node 192.168.211.141:7007 192.168.211.141:7001</code></p><p>执行命令后，效果如下： </p><img src="/blog/2020/08/22/%E7%BC%93%E5%AD%98-Redis%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8/pic25.png" srcset="/blog/img/loading.gif" class><p>此时我们可以进入到集群节点之一查看此时的集群状态，我们进入到 7002 节点中输入 cluster node 查询，操作方法如下：</p><pre><code class="hljs sh">进入容器 docker <span class="hljs-built_in">exec</span> ‐it redis‐7002 /bin/bash 进入到redis‐cli脚本目录 <span class="hljs-built_in">cd</span> /usr/<span class="hljs-built_in">local</span>/bin 登录7002节点 ./redis‐cli ‐p 7002 ‐c 查询集群状态 cluster nodes</code></pre><p>效果如下</p><img src="/blog/2020/08/22/%E7%BC%93%E5%AD%98-Redis%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8/pic26.png" srcset="/blog/img/loading.gif" class><h5 id="哈希槽分配"><a href="#哈希槽分配" class="headerlink" title="哈希槽分配"></a>哈希槽分配</h5><img src="/blog/2020/08/22/%E7%BC%93%E5%AD%98-Redis%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8/pic27.png" srcset="/blog/img/loading.gif" class><p>从上面的集群节点信息我们可以看出一个问题，其他主节点都有一串数字范围，而刚才添加的 7007 节点没有这段数字范围，这和Redis集群原理有关系，我们来讲解一下集群的原理，然后实现新增节点哈希槽(这段数字范围)的分配。</p><img src="/blog/2020/08/22/%E7%BC%93%E5%AD%98-Redis%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8/pic28.png" srcset="/blog/img/loading.gif" class><p>Redis Cluster 特性之一是引入了槽的概念。一个redis集群包含 16384 个哈希槽。 集群时，会将16384个哈希槽分别分配给每个Master节点，每个Master节点占16384个哈希槽中的一部分。执行GET/SET/DEL时，都会根据key进行操作，Redis通过CRC16算法对key进行计算得到该key所属Redis节点。 根据key去指定Redis节点操作数据。</p><p>从原理上分析，因为之前 7001,7002,7003 已经瓜分了16384个哈希槽，所以再增加一个新节点是没有剩余哈希槽分配的，所以新增的 7007 节点没有分配到哈希槽。我们只能重新分配哈希槽，才能让新增节点分配到一定的哈希槽，重新分配哈希槽后，我们还要考虑之前其他Redis节点中的数据迁移。  </p><p>重新分配<strong>Hash</strong>槽 </p><p>将 7001,7002,7003 中的 100 个哈希槽挪给 7007 ，命令如下： </p><pre><code class="hljs angelscript">./redis‐cli ‐‐cluster reshard <span class="hljs-number">192.168</span><span class="hljs-number">.211</span><span class="hljs-number">.141</span>:<span class="hljs-number">7001</span> \‐‐cluster‐<span class="hljs-keyword">from</span> c9687b2ebec8b99ee14fcbb885b5c3439c58827f,<span class="hljs-number">80</span>a69bb8af3737bce2913b2952b4456430a89eb3,<span class="hljs-number">612e4</span>af8eae484 <span class="hljs-number">26938</span>ce65d12a7d7376b0b37e3 \‐‐cluster‐to <span class="hljs-number">443096</span>af2ff8c1e89f1160faed4f6a02235822a7 \‐‐cluster‐slots <span class="hljs-number">100</span></code></pre><p>将节点c9687b2ebec8b99ee14fcbb885b5c3439c58827f、80a69bb8af3737bce2913b2952b4456430a89eb3、612e4af8eae48426938ce65d12a7d7376b0b37e3中的100个哈希槽移动到443096af2ff8c1e89f1160faed4f6a02235822a7中</p><p>参数说明： </p><pre><code class="hljs crmsh">‐‐cluster‐from：表示slot目前所在的节点的<span class="hljs-keyword">node</span> <span class="hljs-title">ID</span>，多个ID用逗号分隔‐‐cluster‐to：表示需要新分配节点的<span class="hljs-keyword">node</span> <span class="hljs-title">ID</span>‐‐cluster‐slots：分配的slot数量</code></pre><p>将100个哈希槽挪给7007后，我们查询下节点信息：</p><p><code>./redis‐cli ‐p 7001 cluster nodes|grep master</code></p><p>效果如下：</p><img src="/blog/2020/08/22/%E7%BC%93%E5%AD%98-Redis%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8/pic29.png" srcset="/blog/img/loading.gif" class><h5 id="添加集群从节点"><a href="#添加集群从节点" class="headerlink" title="添加集群从节点"></a>添加集群从节点</h5><p>我们需要往集群中给 7007 节点添加一个从节点 7008 ，添加从节点的主要目的是提高高可用，防止主节点宕机后该节点无法提供服务。添加从节点命令如下：</p><pre><code class="hljs angelscript">./redis‐cli ‐‐cluster add‐node <span class="hljs-number">192.168</span><span class="hljs-number">.211</span><span class="hljs-number">.141</span>:<span class="hljs-number">7008</span> <span class="hljs-number">192.168</span><span class="hljs-number">.211</span><span class="hljs-number">.141</span>:<span class="hljs-number">7007</span> \‐‐cluster‐slave ‐‐cluster‐master‐id <span class="hljs-number">443096</span>af2ff8c1e89f1160faed4f6a02235822a7</code></pre><p>命令说明： </p><pre><code class="hljs angelscript">将<span class="hljs-number">192.168</span><span class="hljs-number">.211</span><span class="hljs-number">.141</span>:<span class="hljs-number">7008</span>节点添加到<span class="hljs-number">192.168</span><span class="hljs-number">.211</span><span class="hljs-number">.141</span>:<span class="hljs-number">7007</span>对应的集群中，并且加入的节点为从节点，对应的主节点id是<span class="hljs-number">443096</span>af2ff8c1e89f1160faed4f6a02235822a7</code></pre><p>参数说明： </p><pre><code class="hljs crmsh">add‐<span class="hljs-keyword">node</span><span class="hljs-title">: 后面的分别跟着新加入的slave</span>和<span class="hljs-literal">slave</span>对应的<span class="hljs-keyword">master</span> <span class="hljs-title"></span><span class="hljs-title">cluster</span>‐<span class="hljs-literal">slave</span>：表示加入的是<span class="hljs-literal">slave</span>节点 ‐‐cluster‐<span class="hljs-literal">master</span>‐id：表示<span class="hljs-literal">slave</span>对应的<span class="hljs-literal">master</span>的<span class="hljs-keyword">node</span> <span class="hljs-title">ID</span></code></pre><p>执行命令后，效果如下：</p><img src="/blog/2020/08/22/%E7%BC%93%E5%AD%98-Redis%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8/pic30.png" srcset="/blog/img/loading.gif" class><p>集群信息查看： </p><img src="/blog/2020/08/22/%E7%BC%93%E5%AD%98-Redis%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8/pic31.png" srcset="/blog/img/loading.gif" class><h5 id="缩容"><a href="#缩容" class="headerlink" title="缩容"></a>缩容</h5><p>在真实生产环境中，我们也会跟着我们的业务和环境执行缩容处理，比如双十一过后，流量没有那么大了，我们往往会缩容处理，服务器开销。 </p><p>Redis实现缩容，需要哈希槽重新分配，将需要移除的节点所分配的所有哈希槽值分配给其他需要运行工作的节点，还需要移除该节点的从节点，然后再删除该节点。 </p><p>移除从节点</p><p>移除 7007 的从节点 7008 ，命令如下：</p><p><code>./redis‐cli ‐‐cluster del‐node 192.168.211.141:7008 98be71d8d6eff6bd40947fa0441e5a821dce20ae</code></p><p>参数说明： </p><p><code>del‐node:删除节点，后面跟着slave节点的 ip:port 和node ID</code></p><p>删除后，我们再来查看集群节点，此时再无7008节点</p><img src="/blog/2020/08/22/%E7%BC%93%E5%AD%98-Redis%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8/pic32.png" srcset="/blog/img/loading.gif" class><p>迁移<strong>Master</strong>的<strong>Slot</strong></p><p>我们需要将 7007 节点的哈希槽迁移到 7001,7002,7003 节点上，仍然用上面用过的 redis-cli –cluster reshard语法，命令如下： </p><p>第1次迁移：</p><pre><code class="hljs angelscript">./redis‐cli ‐‐cluster reshard <span class="hljs-number">192.168</span><span class="hljs-number">.211</span><span class="hljs-number">.141</span>:<span class="hljs-number">7007</span> ‐\‐cluster‐<span class="hljs-keyword">from</span> <span class="hljs-number">443096</span>af2ff8c1e89f1160faed4f6a02235822a7 \‐‐cluster‐to <span class="hljs-number">80</span>a69bb8af3737bce2913b2952b4456430a89eb3 \‐‐cluster‐slots <span class="hljs-number">33</span> ‐‐cluster‐yes</code></pre><p>命令说明： </p><p>将192.168.211.141:7007节点所在集群中443096af2ff8c1e89f1160faed4f6a02235822a7节点的33个哈希槽迁移给 80a69bb8af3737bce2913b2952b4456430a89eb3节点，不回显需要迁移的slot，直接迁移。</p><p>效果如下：</p><img src="/blog/2020/08/22/%E7%BC%93%E5%AD%98-Redis%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8/pic33.png" srcset="/blog/img/loading.gif" class><p>查看集群节点： </p><img src="/blog/2020/08/22/%E7%BC%93%E5%AD%98-Redis%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8/pic34.png" srcset="/blog/img/loading.gif" class><p>我们再次迁移其他哈希槽到其他节点，将剩余的哈希槽迁移到7002和7003去。 </p><p>第2次迁移： </p><pre><code class="hljs sh">./redis‐cli ‐‐cluster reshard 192.168.211.141:7007 \‐‐cluster‐from 443096af2ff8c1e89f1160faed4f6a02235822a7 \‐‐cluster‐to c9687b2ebec8b99ee14fcbb885b5c3439c58827f \‐‐cluster‐slots 34 ‐‐cluster‐yes</code></pre><p>第3次迁移： </p><pre><code class="hljs sh">./redis‐cli ‐‐cluster reshard 192.168.211.141:7007 \‐‐cluster‐from 443096af2ff8c1e89f1160faed4f6a02235822a7 \‐‐cluster‐to 612e4af8eae48426938ce65d12a7d7376b0b37e3 \‐‐cluster‐slots 33 ‐‐cluster‐yes</code></pre><p>集群状态查询： </p><img src="/blog/2020/08/22/%E7%BC%93%E5%AD%98-Redis%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8/pic35.png" srcset="/blog/img/loading.gif" class><p>删除<strong>7007</strong>主节点</p><p>删除节点命令如下： </p><p><code>./redis‐cli ‐‐cluster del‐node 192.168.211.141:7007 443096af2ff8c1e89f1160faed4f6a02235822a7</code></p><p>效果如下：</p><img src="/blog/2020/08/22/%E7%BC%93%E5%AD%98-Redis%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8/pic36.png" srcset="/blog/img/loading.gif" class><p>集群节点查看： </p><img src="/blog/2020/08/22/%E7%BC%93%E5%AD%98-Redis%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8/pic37.png" srcset="/blog/img/loading.gif" class><h2 id="Redis-Sentinel"><a href="#Redis-Sentinel" class="headerlink" title="Redis Sentinel"></a>Redis Sentinel</h2><p>redis主从复制结构主节点故障时，仍需要人工重新在从节点中执行<code>slaveof no one</code>后变为新主节点，其他的节点成为新主节点的丛节点，并从新节点复制数据，然后通知我们的应用程序更新了主节点的地址。这种处理方式无法实现高可用，使用哨兵机制可以在主节点出现故障时，由Redis Sentinel自动完成故障发现和转移，并通知应用方，实现高可用性。</p><p>注意：在代码中连接redis时，需要连接哨兵节点，由哨兵节点动态的选择redis主节点。</p><h4 id="监控机制"><a href="#监控机制" class="headerlink" title="监控机制"></a>监控机制</h4><img src="/blog/2020/08/22/%E7%BC%93%E5%AD%98-Redis%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8/pic5.png" srcset="/blog/img/loading.gif" class><p>哨兵的数量一般是奇数个，当节点出现故障是，首先使用Raft算法实现选举机制，选出一个哨兵节点来完成转移和通知。</p><p>哨兵有三个定时监控任务完成对各节点的发现和监控：</p><ul><li><p>每个哨兵节点每10秒会向主节点和从节点发送info命令获取最拓扑结构图，哨兵配置时只要配置对主节点的监控即可，通过向主节点发送info，获取从节点的信息，并当有新的从节点加入时可以马上感知到。</p><img src="/blog/2020/08/22/%E7%BC%93%E5%AD%98-Redis%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8/pic38.png" srcset="/blog/img/loading.gif" class></li><li><p>每个哨兵节点每隔2秒会向redis数据节点的 __sentinel__：hello频道上发送该哨兵节点对于主节点的判断以及当前哨兵节点的信息，同时每个哨兵节点也会订阅该频道，来了解其它哨兵节点的信息及对主节点的判断，其实就是通过消息publish和subscribe来完成的。该定时任务主要有2个作用：</p><ul><li>发现新的Sentinel节点：通过订阅主节点的<strong>sentinel</strong>：hello了解其他的Sentinel节点信息，如果是新加入的Sentinel节点，将该Sentinel节点信息保存起来，并与该Sentinel节点创建连接。 </li><li>Sentinel节点之间交换主节点的状态，作为后面客观下线以及领导者选举的依据。 </li></ul><img src="/blog/2020/08/22/%E7%BC%93%E5%AD%98-Redis%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8/pic39.png" srcset="/blog/img/loading.gif" class></li><li><p>每隔1秒每个哨兵会向主节点、从节点及其余哨兵节点发送一次ping命令做一次心跳检测，来确认这些节点当前是否可达，从而实现检查每个节点的健康状态。 </p><img src="/blog/2020/08/22/%E7%BC%93%E5%AD%98-Redis%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8/pic40.png" srcset="/blog/img/loading.gif" class></li></ul><p>主观下线：哨兵节点每隔1秒对主节点和从节点、其它哨兵节点发送ping做心跳检测，当这些心跳检测时间超过<code>down-after-milliseconds</code>时，哨兵节点则认为该节点故障或下线，但这这可能会存在误判。</p><p>客观下线：当主观下线的节点是主节点时，此时该哨兵节点会通过指令<code>sentinelis-masterdown-by-addr</code>寻求其它哨兵节点对主节点的判断，当认为该节点出现故障的哨兵数当超过<code>quorum</code>（法定人数）个数时，就是客观下线。</p><h4 id="主要任务"><a href="#主要任务" class="headerlink" title="主要任务"></a>主要任务</h4><p>Redis Sentinel是用于管理Redis集群,主要执行如下任务:</p><ol><li><p>监控(Monitoring) ：Sentinel会不断地检查你的主服务器和从服务器是否运作正常; </p></li><li><p>提醒(Notification) ：当被监控的某个Redis服务器出现问题时，Sentinel可以通过API向管理员或者其他应用程序发送通知; </p></li><li><p>自动故障迁移(Automatic failover) ：当一个主服务器不能正常工作时，Sentinel 会开始一次自动故障迁移操作，它会将失效主服务器的其中一个从服务器升级为新的主服务器，并让失效主服务器的其他从服务器改为复制新的主服务器；当客户端试图连接失效的主服务器时，集群也会向客户端返回新主服务器的地址,使得集群可以使用新主服务器代替失效服务器。</p></li></ol><h4 id="哨兵领导者选举流程"><a href="#哨兵领导者选举流程" class="headerlink" title="哨兵领导者选举流程"></a>哨兵领导者选举流程</h4><ol><li>每个在线的哨兵节点都可以成为领导者，当它发现主节点下线时，会向其它哨兵发<code>is-master-down-by-addr</code>命令，征求判断并要求将自己设置为领导者，由领导者处理故障转移；</li><li>当其它哨兵收到此命令时，可以同意或者拒绝它成为领导者；</li><li>如果哨兵3发现自己在选举的票数大于等于num(sentinels)/2+1时，将成为领导者，如果没有超过，继续选举；</li></ol><h4 id="故障转移机制"><a href="#故障转移机制" class="headerlink" title="故障转移机制"></a>故障转移机制</h4><ol><li>由Sentinel节点定期监控发现主节点是否出现了故障，sentinel会向master发送心跳PING来确认master是否存活，如果master在一定时间范围内不回应PONG或者是回复了一个错误消息，那么这个sentinel会主观地（单方面地）认为这个master已经不可用了。</li><li>当主节点出现故障，此时3个Sentinel节点共同选举了Sentinel3节点为领导，负载处理主节点的故障转移。</li><li>由Sentinel3领导者节点执行故障转移，过程和主从复制一样，但是自动执行。</li></ol><h4 id="故障处理流程"><a href="#故障处理流程" class="headerlink" title="故障处理流程"></a>故障处理流程</h4><img src="/blog/2020/08/22/%E7%BC%93%E5%AD%98-Redis%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8/pic6.png" srcset="/blog/img/loading.gif" class><ol><li>将slave-1脱离原从节点，升级主节点，</li><li>将从节点slave-2指向新的主节点。</li><li>通知客户端主节点已更换。</li><li>将原主节点（oldMaster）变成从节点，指向新的主节点。</li></ol><img src="/blog/2020/08/22/%E7%BC%93%E5%AD%98-Redis%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8/pic7.png" srcset="/blog/img/loading.gif" class><h4 id="主节点的选择方式"><a href="#主节点的选择方式" class="headerlink" title="主节点的选择方式"></a>主节点的选择方式</h4><img src="/blog/2020/08/22/%E7%BC%93%E5%AD%98-Redis%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8/pic8.png" srcset="/blog/img/loading.gif" class><ol><li>过滤掉不健康的(下线或断线)，没有回复过哨兵ping响应的从节点</li><li>选择slave-priority从节点优先级最高（redis.conf）</li><li>选择复制偏移量最大，指复制最完整的从节点</li></ol><h4 id="Sentinel搭建"><a href="#Sentinel搭建" class="headerlink" title="Sentinel搭建"></a>Sentinel搭建</h4><p>我们这里搭建3个哨兵，采用Docker的方式搭建。 </p><table><thead><tr><th>节点</th><th>IP</th><th>端口</th><th>监听节点</th></tr></thead><tbody><tr><td>Sentinel1</td><td>192.168.211.141</td><td>8001</td><td>7001,7002,7003</td></tr><tr><td>Sentinel2</td><td>192.168.211.141</td><td>8002</td><td>7001,7002,7003</td></tr><tr><td>Sentinel3</td><td>192.168.211.141</td><td>8003</td><td>7001,7002,7003</td></tr></tbody></table><p>新建文件夹 sentinel1 , sentinel2 , sentinel3 ，并在每个文件夹中创建 conf , data 目录，分别在每个 conf 目录下创建 sentinel.conf 文件,在 sentinelX 目录下执行安装命令。 </p><p>sentinel1/sentinel.conf配置： </p><pre><code class="hljs sh"><span class="hljs-comment">#端口 </span>port 8001 <span class="hljs-comment"># 配好master即可，sentinel可通过master找到slave </span>sentinel monitor redis‐7001 192.168.211.141 7001 1 sentinel monitor redis‐7002 192.168.211.141 7002 1 sentinel monitor redis‐7003 192.168.211.141 7003 1 <span class="hljs-comment"># 配置master的访问密码，否则master一直显示sdown </span><span class="hljs-comment">#sentinel auth‐pass redis‐7001 123456 </span><span class="hljs-comment">#sentinel auth‐pass redis‐7002 123456 </span><span class="hljs-comment">#sentinel auth‐pass redis‐7003 123456</span><span class="hljs-comment"># 以下默认值即可，不需要配置 </span><span class="hljs-comment"># sentinel down‐after‐milliseconds &#123;masterName&#125; &#123;time&#125; </span><span class="hljs-comment"># sentinel parallel‐syncs &#123;masterName&#125; &#123;number&#125; </span><span class="hljs-comment"># sentinel failover‐timeout &#123;masterName&#125; &#123;time&#125;</span></code></pre><p>配置说明： </p><pre><code class="hljs crmsh">【sentinel <span class="hljs-literal">monitor</span> <span class="hljs-tag">&lt;master‐name&gt;</span> <span class="hljs-tag">&lt;ip&gt;</span> <span class="hljs-tag">&lt;redis‐port&gt;</span> <span class="hljs-tag">&lt;quorum&gt;</span>】 告诉sentinel去监听地址为ip:port的一个<span class="hljs-literal">master</span>，这里的<span class="hljs-literal">master</span>‐name可以自定义，quorum是一个数字，指明当有多 少个sentinel认为一个<span class="hljs-literal">master</span>失效时，<span class="hljs-literal">master</span>才算真正失效。<span class="hljs-literal">master</span>‐name只能包含英文字母，数字，和“.‐_”这三个 字符需要注意的是<span class="hljs-literal">master</span>‐ip 要写真实的ip地址而不要用回环地址（<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>）。 【sentinel auth‐pass <span class="hljs-tag">&lt;master‐name&gt;</span> <span class="hljs-tag">&lt;password&gt;</span>】 设置连接<span class="hljs-literal">master</span>和<span class="hljs-literal">slave</span>时的密码，注意的是sentinel不能分别为<span class="hljs-literal">master</span>和<span class="hljs-literal">slave</span>设置不同的密码，因此<span class="hljs-literal">master</span>和 <span class="hljs-literal">slave</span>的密码应该设置相同。 配置示例：sentinel auth‐pass itheima itheima</code></pre><p>sentinel2/sentinel.conf</p><pre><code class="hljs sh"><span class="hljs-comment">#端口 </span>port 8002<span class="hljs-comment"># 配好master即可，sentinel可通过master找到slave </span>sentinel monitor redis‐7001 192.168.211.141 7001 1 sentinel monitor redis‐7002 192.168.211.141 7002 1 sentinel monitor redis‐7003 192.168.211.141 7003 1 <span class="hljs-comment"># 配置master的访问密码，否则master一直显示sdown </span><span class="hljs-comment">#sentinel auth‐pass redis‐7001 123456 </span><span class="hljs-comment">#sentinel auth‐pass redis‐7002 123456 </span><span class="hljs-comment">#sentinel auth‐pass redis‐7003 123456</span><span class="hljs-comment"># 以下默认值即可，不需要配置 </span><span class="hljs-comment"># sentinel down‐after‐milliseconds &#123;masterName&#125; &#123;time&#125; </span><span class="hljs-comment"># sentinel parallel‐syncs &#123;masterName&#125; &#123;number&#125; </span><span class="hljs-comment"># sentinel failover‐timeout &#123;masterName&#125; &#123;time&#125;</span></code></pre><p>sentinel3/sentinel.conf</p><pre><code class="hljs sh"><span class="hljs-comment">#端口 </span>port 8002<span class="hljs-comment"># 配好master即可，sentinel可通过master找到slave </span>sentinel monitor redis‐7001 192.168.211.141 7001 1 sentinel monitor redis‐7002 192.168.211.141 7002 1 sentinel monitor redis‐7003 192.168.211.141 7003 1 <span class="hljs-comment"># 配置master的访问密码，否则master一直显示sdown </span><span class="hljs-comment">#sentinel auth‐pass redis‐7001 123456 </span><span class="hljs-comment">#sentinel auth‐pass redis‐7002 123456 </span><span class="hljs-comment">#sentinel auth‐pass redis‐7003 123456</span><span class="hljs-comment"># 以下默认值即可，不需要配置 </span><span class="hljs-comment"># sentinel down‐after‐milliseconds &#123;masterName&#125; &#123;time&#125; </span><span class="hljs-comment"># sentinel parallel‐syncs &#123;masterName&#125; &#123;number&#125; </span><span class="hljs-comment"># sentinel failover‐timeout &#123;masterName&#125; &#123;time&#125;</span></code></pre><p><strong>Docker</strong>安装： </p><p>sentinel1</p><pre><code class="hljs sh">docker run ‐d ‐p 8001:8001 ‐v <span class="hljs-variable">$PWD</span>/data:/data \‐v <span class="hljs-variable">$PWD</span>/conf/sentinel.conf:/etc/redis/sentinel.conf \‐‐network redis‐net ‐‐name sentinel1 \‐‐privileged=<span class="hljs-literal">true</span> redis:6.0.5 redis‐sentinel /etc/redis/sentinel.conf</code></pre><p>sentinel2</p><pre><code class="hljs sh">docker run ‐d ‐p 8002:8002 ‐v <span class="hljs-variable">$PWD</span>/data:/data \‐v <span class="hljs-variable">$PWD</span>/conf/sentinel.conf:/etc/redis/sentinel.conf \‐‐network redis‐net ‐‐name sentinel2 \‐‐privileged=<span class="hljs-literal">true</span> redis:6.0.5 redis‐sentinel /etc/redis/sentinel.conf</code></pre><p>sentinel3</p><pre><code class="hljs sh">docker run ‐d ‐p 8003:8003 ‐v <span class="hljs-variable">$PWD</span>/data:/data \‐v <span class="hljs-variable">$PWD</span>/conf/sentinel.conf:/etc/redis/sentinel.conf \‐‐network redis‐net ‐‐name sentinel3 \‐‐privileged=<span class="hljs-literal">true</span> redis:6.0.5 redis‐sentinel /etc/redis/sentinel.conf</code></pre><h4 id="Sentinel集群讲解"><a href="#Sentinel集群讲解" class="headerlink" title="Sentinel集群讲解"></a>Sentinel集群讲解</h4><p>Sentinel1启动信息如下： </p><img src="/blog/2020/08/22/%E7%BC%93%E5%AD%98-Redis%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8/pic41.png" srcset="/blog/img/loading.gif" class><p>登录Sentinel1，输入 info 命令，查看集群信息：</p><img src="/blog/2020/08/22/%E7%BC%93%E5%AD%98-Redis%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8/pic42.png" srcset="/blog/img/loading.gif" class><p>关闭 redis-7001 ，此时会先进行一次+sdown，再进行一次+odown，也就是当前Sentinel先自己判断该Redis宕机了，此时满足宕机反馈数量为1，因此有执行了客观宕机提示+odown，效果如下： </p><img src="/blog/2020/08/22/%E7%BC%93%E5%AD%98-Redis%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8/pic43.png" srcset="/blog/img/loading.gif" class><p>此时再输入 info 可以看到如下信息，7001节点已经宕机,节点访问地址变成了7005。 </p><img src="/blog/2020/08/22/%E7%BC%93%E5%AD%98-Redis%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8/pic44.png" srcset="/blog/img/loading.gif" class><p>我们链接Redis集群，执行数据添加，看7001所在哈希槽的key能否添加。</p><img src="/blog/2020/08/22/%E7%BC%93%E5%AD%98-Redis%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8/pic45.png" srcset="/blog/img/loading.gif" class><p>集群状态查看 </p><img src="/blog/2020/08/22/%E7%BC%93%E5%AD%98-Redis%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8/pic46.png" srcset="/blog/img/loading.gif" class><p>启动 redis-7001 ，再查看集群状态，此时 redis-7001 是 redis-7005 的从节点。 </p><img src="/blog/2020/08/22/%E7%BC%93%E5%AD%98-Redis%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8/pic47.png" srcset="/blog/img/loading.gif" class><p>此时哨兵这边会出现如下日志，表示7001节点客观上宕机次数-1，并且将该节点添加为7005的从节点： </p><img src="/blog/2020/08/22/%E7%BC%93%E5%AD%98-Redis%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8/pic48.png" srcset="/blog/img/loading.gif" class><p>日志解读</p><pre><code class="hljs sql">+<span class="hljs-keyword">reset</span>‐<span class="hljs-keyword">master</span> &lt;<span class="hljs-keyword">instance</span> details&gt; ：主服务器已被重置。+<span class="hljs-keyword">slave</span> &lt;<span class="hljs-keyword">instance</span> details&gt; ：一个新的从服务器已经被 Sentinel 识别并关联。+<span class="hljs-keyword">failover</span>‐state‐reconf‐slaves &lt;<span class="hljs-keyword">instance</span> details&gt; ：故障转移状态切换到了 reconf‐slaves 状态。 +<span class="hljs-keyword">failover</span>‐detected &lt;<span class="hljs-keyword">instance</span> details&gt; ：另一个 Sentinel 开始了一次故障转移操作，或者一个从服务器转换 成了主服务器。 +<span class="hljs-keyword">slave</span>‐reconf‐sent &lt;<span class="hljs-keyword">instance</span> details&gt; ：领头（leader）的 Sentinel 向实例发送了 SLAVEOF 命令，为实例 设置新的主服务器。 +<span class="hljs-keyword">slave</span>‐reconf‐inprog &lt;<span class="hljs-keyword">instance</span> details&gt; ：实例正在将自己设置为指定主服务器的从服务器，但相应的同步过程 仍未完成。 +<span class="hljs-keyword">slave</span>‐reconf‐done &lt;<span class="hljs-keyword">instance</span> details&gt; ：从服务器已经成功完成对新主服务器的同步。 ‐dup‐sentinel &lt;<span class="hljs-keyword">instance</span> details&gt; ：对给定主服务器进行监视的一个或多个 Sentinel 已经因为重复出现而被移 除 —— 当 Sentinel 实例重启的时候，就会出现这种情况。 +sentinel &lt;<span class="hljs-keyword">instance</span> details&gt; ：一个监视给定主服务器的新 Sentinel 已经被识别并添加。 +sdown &lt;<span class="hljs-keyword">instance</span> details&gt; ：给定的实例现在处于主观下线状态。 ‐sdown &lt;<span class="hljs-keyword">instance</span> details&gt; ：给定的实例已经不再处于主观下线状态。 +odown &lt;<span class="hljs-keyword">instance</span> details&gt; ：给定的实例现在处于客观下线状态。 ‐odown &lt;<span class="hljs-keyword">instance</span> details&gt; ：给定的实例已经不再处于客观下线状态。 +<span class="hljs-keyword">new</span>‐epoch &lt;<span class="hljs-keyword">instance</span> details&gt; ：当前的纪元（epoch）已经被更新。 +try‐<span class="hljs-keyword">failover</span> &lt;<span class="hljs-keyword">instance</span> details&gt; ：一个新的故障迁移操作正在执行中，等待被大多数 Sentinel 选中 （waiting <span class="hljs-keyword">to</span> be elected <span class="hljs-keyword">by</span> the majority）。 +elected‐leader &lt;<span class="hljs-keyword">instance</span> details&gt; ：赢得指定纪元的选举，可以进行故障迁移操作了。 +<span class="hljs-keyword">failover</span>‐state‐<span class="hljs-keyword">select</span>‐<span class="hljs-keyword">slave</span> &lt;<span class="hljs-keyword">instance</span> details&gt; ：故障转移操作现在处于 <span class="hljs-keyword">select</span>‐<span class="hljs-keyword">slave</span> 状态 —— Sentinel 正在寻找可以升级为主服务器的从服务器。 <span class="hljs-keyword">no</span>‐good‐<span class="hljs-keyword">slave</span> &lt;<span class="hljs-keyword">instance</span> details&gt; ：Sentinel 操作未能找到适合进行升级的从服务器。Sentinel 会在一段时 间之后再次尝试寻找合适的从服务器来进行升级，又或者直接放弃执行故障转移操作。 selected‐<span class="hljs-keyword">slave</span> &lt;<span class="hljs-keyword">instance</span> details&gt; ：Sentinel 顺利找到适合进行升级的从服务器。 <span class="hljs-keyword">failover</span>‐state‐send‐slaveof‐noone &lt;<span class="hljs-keyword">instance</span> details&gt; ：Sentinel 正在将指定的从服务器升级为主服务 器，等待升级功能完成。 <span class="hljs-keyword">failover</span>‐<span class="hljs-keyword">end</span>‐<span class="hljs-keyword">for</span>‐<span class="hljs-keyword">timeout</span> &lt;<span class="hljs-keyword">instance</span> details&gt; ：故障转移因为超时而中止，不过最终所有从服务器都会开始复 制新的主服务器（slaves will eventually be configured <span class="hljs-keyword">to</span> <span class="hljs-keyword">replicate</span> <span class="hljs-keyword">with</span> the <span class="hljs-keyword">new</span> <span class="hljs-keyword">master</span> anyway）。<span class="hljs-keyword">failover</span>‐<span class="hljs-keyword">end</span> &lt;<span class="hljs-keyword">instance</span> details&gt; ：故障转移操作顺利完成。所有从服务器都开始复制新的主服务器了。 +<span class="hljs-keyword">switch</span>‐<span class="hljs-keyword">master</span> &lt;<span class="hljs-keyword">master</span> <span class="hljs-keyword">name</span>&gt; &lt;oldip&gt; &lt;oldport&gt; &lt;newip&gt; &lt;newport&gt; ：配置变更，主服务器的 IP 和地址已 经改变。 这是绝大多数外部用户都关心的信息。 +tilt ：进入 tilt 模式。 ‐tilt ：退出 tilt 模式。</code></pre><p>项目中链接Redis集群或者Redis哨兵，只需要配置一下 application.yml即可 ： </p><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span> <span class="hljs-comment">#Redis </span><span class="hljs-attr">redis:</span> <span class="hljs-comment">#timeout: 50000 </span><span class="hljs-attr">sentinel:</span> <span class="hljs-attr">nodes:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.211</span><span class="hljs-number">.141</span><span class="hljs-string">:8001,192.168.211.141:8002,192.168.211.141:8003</span> <span class="hljs-comment">#cluster:</span>      <span class="hljs-comment"># nodes: 192.168.211.141:7001,192.168.211.141:7002,192.168.211.141:7003,192.168.211.141:7004,192.168.211. 141:7005,192.168.211.141:7006</span></code></pre><h3 id="Redis-Cluster"><a href="#Redis-Cluster" class="headerlink" title="Redis Cluster"></a>Redis Cluster</h3><p>RedisCluster是Redis的分布式解决方案，在3.0版本后推出的方案，有效地解决了Redis分布式的需求，当遇到单机内存、并发等瓶颈时，可使用此方案来解决这些问题。</p><h4 id="分布式数据库概念"><a href="#分布式数据库概念" class="headerlink" title="分布式数据库概念"></a>分布式数据库概念</h4><p>分布式数据库把整个数据按分区规则映射到多个节点，即把数据划分到多个节点上，每个节点负责整体数据的一个子集。</p><p>比如我们库有900条用户数据，有3个redis节点，将900条分成3份，分别存入到3个redis节点</p><img src="/blog/2020/08/22/%E7%BC%93%E5%AD%98-Redis%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8/pic10.png" srcset="/blog/img/loading.gif" class><h4 id="分区规则"><a href="#分区规则" class="headerlink" title="分区规则"></a>分区规则</h4><p>常见的分区规则哈希分区和顺序分区，redis集群使用了哈希分区，顺序分区暂用不到，不做具体说明。</p><p>RedisCluster采用了哈希分区的“虚拟槽分区”方式（哈希分区分节点取余、一致性哈希分区和虚拟槽分区）。</p><h4 id="虚拟槽分区"><a href="#虚拟槽分区" class="headerlink" title="虚拟槽分区"></a>虚拟槽分区</h4><p>槽：slot</p><p>RedisCluster采用此分区，所有的键根据哈希函数(CRC16[key]&amp;16383)映射到0－16383槽内，共16384个槽位，每个节点维护部分槽及槽所映射的键值数据</p><p>哈希函数: Hash()=CRC16[key]&amp;16383</p><img src="/blog/2020/08/22/%E7%BC%93%E5%AD%98-Redis%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8/pic11.png" srcset="/blog/img/loading.gif" class><h4 id="槽、键、数据关系"><a href="#槽、键、数据关系" class="headerlink" title="槽、键、数据关系"></a>槽、键、数据关系</h4><img src="/blog/2020/08/22/%E7%BC%93%E5%AD%98-Redis%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8/pic12.png" srcset="/blog/img/loading.gif" class><h4 id="RedisCluster的缺陷"><a href="#RedisCluster的缺陷" class="headerlink" title="RedisCluster的缺陷"></a>RedisCluster的缺陷</h4><ul><li><p>键的批量操作支持有限，比如mset, mget，如果多个键映射在不同的槽就会出错。</p></li><li><p>键事务支持有限，当多个键分布在不同节点时无法使用事务，同一节点是支持事务</p></li><li><p>键是数据分区的最小粒度，不能将一个很大的键值对映射到不同的节点</p></li><li><p>不支持多数据库，标号为0的数据库。</p></li><li><p>复制结构只支持单层结构，不支持树型结构。</p></li></ul><h4 id="集群节点之间的通信"><a href="#集群节点之间的通信" class="headerlink" title="集群节点之间的通信"></a>集群节点之间的通信</h4><img src="/blog/2020/08/22/%E7%BC%93%E5%AD%98-Redis%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8/pic13.png" srcset="/blog/img/loading.gif" class><p>节点之间采用Gossip协议进行通信，节点彼此之间不断通信交换消息，当主从角色变化或新增节点，彼此通过ping/pong进行通信知道全部节点的最新状态并达到集群同步</p><p>Gossip协议的主要职责就是信息交换，信息交换的载体就是节点之间彼此发送的Gossip消息，常用的Gossip消息有ping消息、pong消息、meet消息、fail消息</p><ul><li><p>meet消息：用于通知新节点加入，消息发送者通知接收者加入到当前集群，meet消息通信完后，接收节点会加入到集群中，并进行周期性ping pong交换</p></li><li><p>ping消息：集群内交换最频繁的消息，集群内每个节点每秒向其它节点发ping消息，用于检测节点是在在线和状态信息，ping消息发送封装自身节点和其他节点的状态数据；</p></li><li><p>pong消息，当接收到ping meet消息时，作为响应消息返回给发送方，用来确认正常通信，pong消息也封闭了自身状态数据；</p></li><li><p>fail消息：当节点判定集群内的另一节点下线时，会向集群内广播一个fail消息</p></li></ul><img src="/blog/2020/08/22/%E7%BC%93%E5%AD%98-Redis%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8/pic14.png" srcset="/blog/img/loading.gif" class><p>以上的所有消息格式为：消息头、消息体，消息头包含发送节点自身状态数据（比如节点ID、槽映射、节点角色、是否下线等），接收节点根据消息头可以获取到发送节点的相关数据。</p><img src="/blog/2020/08/22/%E7%BC%93%E5%AD%98-Redis%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8/pic15.png" srcset="/blog/img/loading.gif" class><p>Gossip协议信息的交换机制具有天然的分布式特性，但ping pong发送的频率很高。</p><img src="/blog/2020/08/22/%E7%BC%93%E5%AD%98-Redis%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8/pic16.png" srcset="/blog/img/loading.gif" class><h5 id="命令重定向"><a href="#命令重定向" class="headerlink" title="命令重定向"></a>命令重定向</h5><img src="/blog/2020/08/22/%E7%BC%93%E5%AD%98-Redis%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8/pic17.png" srcset="/blog/img/loading.gif" class><h5 id="主观下线流程"><a href="#主观下线流程" class="headerlink" title="主观下线流程"></a>主观下线流程</h5><img src="/blog/2020/08/22/%E7%BC%93%E5%AD%98-Redis%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8/pic18.png" srcset="/blog/img/loading.gif" class><h5 id="客观下线流程"><a href="#客观下线流程" class="headerlink" title="客观下线流程"></a>客观下线流程</h5><p>节点真正的下线，集群内多个节点都认为该节点不可用，达成共识，将它下线，如果下线的节点为主节点，还要对它进行故障转移</p><img src="/blog/2020/08/22/%E7%BC%93%E5%AD%98-Redis%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8/pic19.png" srcset="/blog/img/loading.gif" class><h5 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h5><p>故障主节点下线后，如果下线节点的是主节点，则需要在它的从节点中选一个替换它，保证集群的高可用</p><img src="/blog/2020/08/22/%E7%BC%93%E5%AD%98-Redis%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8/pic20.png" srcset="/blog/img/loading.gif" class>]]></content>
    
    
    <categories>
      
      <category>缓存</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis集群</tag>
      
      <tag>redis高可用</tag>
      
      <tag>redis主从</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis的基本介绍</title>
    <link href="/blog/2020/08/22/%E7%BC%93%E5%AD%98-Redis%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/"/>
    <url>/blog/2020/08/22/%E7%BC%93%E5%AD%98-Redis%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h3 id="redis介绍"><a href="#redis介绍" class="headerlink" title="redis介绍"></a>redis介绍</h3><p>redis是一种基于键值对(key-value)数据库，其中value可以为string、hash、list、set、zset等多种数据结构，可以满足很多应用场景。还提供了键过期，发布订阅，事务，流水线，等附加功能。</p><p>流水线：Redis的流水线功能允许客户端一次将多个命令请求发送给服务器，并将被执行的多个命令请求的结果在一个命令回复中全部返回给客户端，使用这个功能可以有效地减少客户端在执行多个命令时需要与服务器进行通信的次数。</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ol><li>速度快，数据放在内存中，官方给出的读写性能10万/S，与机器性能也有关。<ul><li>数据放内存中是速度快的主要原因。</li><li>C语言实现，与操作系统距离近。</li><li>使用了单线程架构，预防多线程可能产生的竞争问题。</li><li>协议简单。</li></ul></li><li>键值对的数据结构丰富。</li><li>丰富的功能：见上功能</li><li>简单稳定：单线程</li><li>持久化：发生断电或机器故障，数据可能会丢失，持久化到硬盘</li><li>主从复制：实现多个相同数据的redis副本</li><li>高可用和分布式：哨兵机制实现高可用，保证redis节点故障发现和自动转移</li><li>客户端语言多：java、php、python、c、c++、nodejs等</li></ol><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>缓存：合理使用缓存加快数据访问速度，降低后端数据源压力 </li><li>排行榜：按照热度排名，按照发布时间排行，主要用到列表和有序集合</li><li>计数器应用：视频网站播放数，网站浏览数，使用 redis 计数 </li><li>社交网络：赞、踩、粉丝、下拉刷新</li><li>消息队列：发布和订阅</li></ul><h3 id="可执行文件介绍"><a href="#可执行文件介绍" class="headerlink" title="可执行文件介绍"></a>可执行文件介绍</h3><table><thead><tr><th>可执行文件</th><th>作用</th></tr></thead><tbody><tr><td>redis-server</td><td>启动redis</td></tr><tr><td>redis-cli</td><td>redis命令行客户端</td></tr><tr><td>redis-benchmark</td><td>基准测试工具</td></tr><tr><td>redis-check-aof</td><td>AOF持久化文件检测和修复工具</td></tr><tr><td>redis-check-dump</td><td>RDB持久化文件检测和修复工具</td></tr><tr><td>redis-sentinel</td><td>启动哨兵</td></tr></tbody></table><h3 id="redis的启动"><a href="#redis的启动" class="headerlink" title="redis的启动"></a>redis的启动</h3><h4 id="redis-server启动"><a href="#redis-server启动" class="headerlink" title="redis-server启动"></a>redis-server启动</h4><ul><li>默认配置：redis-server，日志输出版本信息，端口：6379</li><li>运行启动：redis-server –port 6380 不建议</li><li>配置文件启动:redis-server/opt/redis/redis.conf灵活生产环境使用这种</li></ul><h4 id="redis-cli启动"><a href="#redis-cli启动" class="headerlink" title="redis-cli启动"></a>redis-cli启动</h4><ul><li>交互式：redis-cli -h {host} -p {prot}连接到redis服务，没有h默认连 127.0.0.1，没有 p 默认连 6379 。</li><li>命令式：redis-cli -h 127.0.0.1 -p 6379 get hello，取key=hello的value</li><li>停止redis 服务： redis-cli shutdown<br>注意：<ul><li>关闭时：断开连接，持久化文件生成，相对安全</li><li>还可以用 kill 关闭，此方式不会做持久化，还会造成缓冲区非法关闭，可能会造成 AOF 和丢失数据</li><li>关闭前生成持久化文件：使用 redis-cli -a 123456 登录进去，再shutdown nosave|save</li></ul></li></ul><h3 id="版本特性介绍"><a href="#版本特性介绍" class="headerlink" title="版本特性介绍"></a>版本特性介绍</h3><p>Redis2.6</p><pre><code class="hljs angelscript">Redis2<span class="hljs-number">.6</span>在<span class="hljs-number">2012</span>年正是发布，经历了<span class="hljs-number">17</span>个版本，到<span class="hljs-number">2.6</span><span class="hljs-number">.17</span>版本，相对于Redis2<span class="hljs-number">.4</span>，主要特性如下： <span class="hljs-number">1</span>）服务端支持Lua脚本。 <span class="hljs-number">2</span>）去掉虚拟内存相关功能。 <span class="hljs-number">3</span>）放开对客户端连接数的硬编码限制。 <span class="hljs-number">4</span>）键的过期时间支持毫秒。 <span class="hljs-number">5</span>）从节点支持只读功能。 <span class="hljs-number">6</span>）两个新的位图命令：bitcount和bitop。 <span class="hljs-number">7</span>）增强了redis‐benchmark的功能：支持定制化的压测，CSV输出等功能。 <span class="hljs-number">8</span>）基于浮点数自增命令：incrbyfloat和hincrbyfloat。 <span class="hljs-number">9</span>）redis‐cli可以使用‐‐eval参数实现Lua脚本执行。 <span class="hljs-number">10</span>）shutdown命令增强。 <span class="hljs-number">11</span>）重构了大量的核心代码，所有集群相关的代码都去掉了，cluster功能将会是<span class="hljs-number">3.0</span>版本最大的亮点。 <span class="hljs-number">12</span>）info可以按照section输出，并且添加了一些统计项 <span class="hljs-number">13</span>）sort命令优化</code></pre><p>Redis2.8</p><pre><code class="hljs angelscript">Redis2<span class="hljs-number">.8</span>在<span class="hljs-number">2013</span>年<span class="hljs-number">11</span>月<span class="hljs-number">22</span>日正式发布，经历了<span class="hljs-number">24</span>个版本，到<span class="hljs-number">2.8</span><span class="hljs-number">.24</span>版本，相比于Redis2<span class="hljs-number">.6</span>，主要特性如下： <span class="hljs-number">1</span>）添加部分主从复制的功能，在一定程度上降低了由于网络问题，造成频繁全量复制生成RDB对系统造成的压力。 <span class="hljs-number">2</span>）尝试性的支持IPv6. <span class="hljs-number">3</span>）可以通过config <span class="hljs-keyword">set</span>命令设置maxclients。 <span class="hljs-number">4</span>）可以用bind命令绑定多个IP地址。 <span class="hljs-number">5</span>）Redis设置了明显的进程名，方便使用ps命令查看系统进程。 <span class="hljs-number">6</span>）config rewrite命令可以将config <span class="hljs-keyword">set</span>持久化到Redis配置文件中。 <span class="hljs-number">7</span>）发布订阅添加了pubsub。 <span class="hljs-number">8</span>）Redis Sentinel第二版，相比于Redis2<span class="hljs-number">.6</span>的Redis Sentinel，此版本已经变成生产可用。</code></pre><p>Redis3.0（里程碑）</p><pre><code class="hljs angelscript">Redis3<span class="hljs-number">.0</span>在<span class="hljs-number">2015</span>年<span class="hljs-number">4</span>月<span class="hljs-number">1</span>日正式发布，相比于Redis2<span class="hljs-number">.8</span>主要特性如下： Redis最大的改动就是添加Redis的分布式实现Redis Cluster。 <span class="hljs-number">1</span>）Redis Cluster：Redis的官方分布式实现。 <span class="hljs-number">2</span>）全新的embedded <span class="hljs-built_in">string</span>对象编码结果，优化小对象内存访问，在特定的工作负载下载速度大幅提升。 <span class="hljs-number">3</span>）Iru算法大幅提升。 <span class="hljs-number">4</span>）migrate连接缓存，大幅提升键迁移的速度。 <span class="hljs-number">5</span>）migrate命令两个新的参数copy和replace。 <span class="hljs-number">6</span>）新的client pause命令，在指定时间内停止处理客户端请求。 <span class="hljs-number">7</span>）bitcount命令性能提升。 <span class="hljs-number">8</span>）cinfig <span class="hljs-keyword">set</span>设置maxmemory时候可以设置不同的单位（之前只能是字节）。 <span class="hljs-number">9</span>）Redis日志小做调整：日志中会反应当前实例的角色（master或者slave）。 <span class="hljs-number">10</span>）incr命令性能提升。</code></pre><p>Redis3.2</p><pre><code class="hljs angelscript">Redis3<span class="hljs-number">.2</span>在<span class="hljs-number">2016</span>年<span class="hljs-number">5</span>月<span class="hljs-number">6</span>日正式发布，相比于Redis3<span class="hljs-number">.0</span>主要特征如下： <span class="hljs-number">1</span>）添加GEO相关功能。 <span class="hljs-number">2</span>）SDS在速度和节省空间上都做了优化。 <span class="hljs-number">3</span>）支持用upstart或者systemd管理Redis进程。 <span class="hljs-number">4</span>）新的List编码类型：quicklist。 <span class="hljs-number">5</span>）从节点读取过期数据保证一致性。 <span class="hljs-number">6</span>）添加了hstrlen命令。 <span class="hljs-number">7</span>）增强了debug命令，支持了更多的参数。 <span class="hljs-number">8</span>）Lua脚本功能增强。 <span class="hljs-number">9</span>）添加了Lua Debugger。 <span class="hljs-number">10</span>）config <span class="hljs-keyword">set</span> 支持更多的配置参数。 <span class="hljs-number">11</span>）优化了Redis崩溃后的相关报告。 <span class="hljs-number">12</span>）新的RDB格式，但是仍然兼容旧的RDB。 <span class="hljs-number">13</span>）加速RDB的加载速度。 <span class="hljs-number">14</span>）spop命令支持个数参数。 <span class="hljs-number">15</span>）cluster nodes命令得到加速。 <span class="hljs-number">16</span>）Jemalloc更新到<span class="hljs-number">4.0</span><span class="hljs-number">.3</span>版本。</code></pre><p>Redis4.0</p><pre><code class="hljs angelscript">可能出乎很多的意料，Redis3<span class="hljs-number">.2</span>之后的版本是<span class="hljs-number">4.0</span>，而不是<span class="hljs-number">3.4</span>、<span class="hljs-number">3.6</span>、<span class="hljs-number">3.8</span>。 一般这种重大版本号的升级也意味着软件或者工具本身发生了重大改革。下面是Redis4<span class="hljs-number">.0</span>的新特性： <span class="hljs-number">1</span>）提供了模块系统，方便第三方开发者拓展Redis的功能。 <span class="hljs-number">2</span>）PSYNC2<span class="hljs-number">.0</span>：优化了之前版本中，主从节点切换必然引起全量复制的问题。 <span class="hljs-number">3</span>）提供了新的缓存剔除算法：LFU（Last Frequently Used），并对已有算法进行了优化。 <span class="hljs-number">4</span>）提供了非阻塞del和flushall/flushdb功能，有效解决删除了bigkey可能造成的Redis阻塞。 <span class="hljs-number">5</span>）提供了memory命令，实现对内存更为全面的监控统计。 <span class="hljs-number">6</span>）提供了交互数据库功能，实现Redis内部数据库的数据置换。 <span class="hljs-number">7</span>）提供了RDB‐AOF混合持久化格式，充分利用了AOF和RDB各自优势。 <span class="hljs-number">8</span>）Redis Cluster 兼容NAT和Docker。</code></pre><p>Redis5.0</p><pre><code class="hljs angelscript"><span class="hljs-number">1.</span>新的Stream数据类型。[<span class="hljs-number">1</span>]<span class="hljs-number">5.0</span> <span class="hljs-number">2.</span>新的Redis模块API：Timers <span class="hljs-keyword">and</span> Cluster API。 <span class="hljs-number">3.</span> RDB现在存储LFU和LRU信息。 <span class="hljs-number">4.</span>集群管理器从Ruby（redis‐trib.rb）移植到C代码。可以在redis‐cli中。查看`redis‐cli —cluster help`了解 更多信息。 <span class="hljs-number">5.</span>新sorted <span class="hljs-keyword">set</span>命令：ZPOPMIN / MAX和阻塞变量。 <span class="hljs-number">6.</span>主动碎片整理V2。 <span class="hljs-number">7.</span>增强HyperLogLog实现。 <span class="hljs-number">8.</span>更好的内存统计报告。 <span class="hljs-number">9.</span>许多带有子命令的命令现在都有一个HELP子命令。 <span class="hljs-number">10.</span>客户经常连接和断开连接时性能更好。 <span class="hljs-number">11.</span>错误修复和改进。 <span class="hljs-number">12.</span> Jemalloc升级到<span class="hljs-number">5.1</span>版</code></pre><p>Redis6.0.5</p><pre><code class="hljs routeros">1.ACL用户权限控制功能 2.RESP3：新的 Redis 通信协议 3.Cluster 管理工具 4.SSL 支持 5.IO多线程支持 6.新的Module API 7.新的 Expire 算法 8.Redis Cluster<span class="hljs-built_in"> Proxy </span>9.Disque</code></pre><ul><li>版本号第二位为奇数，为非稳定版本（2.7、2.9、3.1），第二位偶数，为稳定版本（2.6、2.8、3.0）</li><li>当前奇数版本是下一个稳定版本的开发版本，如 2.9 是 3.0 的开发版本</li></ul><h3 id="缓存雪崩和穿透"><a href="#缓存雪崩和穿透" class="headerlink" title="缓存雪崩和穿透"></a>缓存雪崩和穿透</h3><h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>为节约内存，Redis一般会做定期清除操作。比如james值过期，当查询key=james的值，此时Redis没有数据，如果有5000个用户并发来查询key=james，就全部都会到Mysql里去查，导致Mysql压力过大这就是缓存雪崩。</p><p>解决方案有两种：设置热点数据永远不过期或者加互斥锁，保证只能有一个用户进入mysql查询，其他用户等待该用户查询完加入缓存后，从缓存中获取数据。</p><img src="/blog/2020/08/22/%E7%BC%93%E5%AD%98-Redis%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/pic1.png" srcset="/blog/img/loading.gif" class><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><img src="/blog/2020/08/22/%E7%BC%93%E5%AD%98-Redis%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/pic2.png" srcset="/blog/img/loading.gif" class><p>如果请求一个不存在的订单号会，redis中没有该数据，会直接到mysql中查询，可以将对订单表所有数据查询出来放到布隆过滤器，每次查订单表前，先到过滤器里查询当前订单号状态是0还是1，0的话代表数据库没有数据，直接拒绝查询。</p><h3 id="redis持久化"><a href="#redis持久化" class="headerlink" title="redis持久化"></a>redis持久化</h3><p>redis是一个支持持久化的内存数据库，持久化可以避免因进程退出而造成数据丢失，redis支持RDB和AOF两种持久化机制。</p><h4 id="RDB文件的操作"><a href="#RDB文件的操作" class="headerlink" title="RDB文件的操作"></a>RDB文件的操作</h4><p>RDB持久化把当前进程数据生成快照（.rdb）文件保存到硬盘的过程，有手动触发和自动触发两种。</p><p>手动触发有save和bgsave两命令</p><ul><li>save命令：阻塞当前Redis，直到RDB持久化过程完成为止，若内存实例比较大会造成长时间阻塞，线上环境不建议使用。</li><li>bgsave命令：redis进程执行fork操作创建子进程，由子进程完成持久化，阻塞时间很短(微秒级)，是对save命令的优化，在执行redis-cli shutdown关闭redis服务时，如果没有开启AOF持久化，自动执行bgsave运行流程。</li></ul><p>bgsave运行流程</p><img src="/blog/2020/08/22/%E7%BC%93%E5%AD%98-Redis%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/pic3.png" srcset="/blog/img/loading.gif" class><p>可以通过<code>config set dir /usr/local</code>命令设置rdb文件保存路径，可以通过<code>bgsave</code>命令将dump.rdb保存到usr/local下，恢复时将dump.rdb放到redis安装目录与redis.conf同级目录，重启redis即可。</p><p>优点：</p><ol><li>压缩后的二进制文，适用于备份、全量复制，用于灾难恢复</li><li>加载RDB恢复数据远快于AOF方式</li></ol><p>缺点：</p><ol><li>无法做到实时持久化，每次都要创建子进程，频繁操作成本过高。</li><li>保存后的二进制文件，存在老版本不兼容新版本rdb文件的问题。</li></ol><h4 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h4><p>针对RDB不适合实时持久化，redis提供了AOF持久化方式来解决。开启方式为到redis.conf文件中设置：<code>appendonly</code>属性为yes即可，备份数据的默认文件名：<code>appendfilename&quot;appendonly.aof</code>。<br>流程说明：</p><ol><li>所有的写入命令(sethset)会append追加到aof_buf缓冲区中。</li><li>AOF缓冲区向硬盘做sync同步。</li><li>随着AOF文件越来越大，需定期对AOF文件rewrite重写，达到压缩。</li><li>当redis服务重启，可load加载AOF文件进行恢复。</li></ol><img src="/blog/2020/08/22/%E7%BC%93%E5%AD%98-Redis%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/pic4.png" srcset="/blog/img/loading.gif" class><p>AOF持久化流程：命令写入(append)，文件同步(sync)，文件重写(rewrite)，重启加载(load)。</p><p>redis的AOF配置详解：</p><ul><li>appendonly yes：启用aof持久化方式。</li><li>appendfsync always：每收到写命令就立即强制写入磁盘，最慢的，但是保证完全的持久化，不推荐使用。</li><li>appendfsync everysec：每秒强制写入磁盘一次，性能和持久化方面做了折中，推荐。</li><li>appendfsync no：完全依赖os，性能最好，持久化没保证（操作系统自身的同步）。</li><li>no-appendfsync-on-rewrite yes：正在导出rdb快照的过程中，要不要停止同步aof。</li><li>auto-aof-rewrite-percentage 100：aof文件大小比起上次重写时的大小，增长率100%时，重写。</li><li>auto-aof-rewrite-min-size 64mb：aof文件，至少超过64M时，重写。</li></ul><p>如何从AOF恢复?</p><ol><li>设置appendonlyyes。</li><li>将appendonly.aof放到dir参数指定的目录。</li><li>启动Redis，Redis会自动加载appendonly.aof文件。</li></ol><img src="/blog/2020/08/22/%E7%BC%93%E5%AD%98-Redis%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/pic5.png" srcset="/blog/img/loading.gif" class><p>redis重启时恢复加载AOF与RDB顺序及流程:</p><ol><li>当AOF和RDB文件同时存在时，优先加载AOF。</li><li>若关闭了AOF，加载RDB文件。</li><li>加载AOF/RDB成功，redis重启成功，如果存在错误，redis启动失败并打印错误信息。</li></ol>]]></content>
    
    
    <categories>
      
      <category>缓存</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见算法与应用</title>
    <link href="/blog/2020/08/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    <url>/blog/2020/08/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E4%B8%8E%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="失效算法与应用"><a href="#失效算法与应用" class="headerlink" title="失效算法与应用"></a>失效算法与应用</h3><p>失效算法常见于缓存系统中。因为缓存往往占据大量内存，而内存空间是相对昂贵，且空间有限的，那么针对一部分值，就要依据相应的算法进行失效或移除操作。 </p><h4 id="先来先淘汰（FIFO）"><a href="#先来先淘汰（FIFO）" class="headerlink" title="先来先淘汰（FIFO）"></a>先来先淘汰（FIFO）</h4><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p>First In First Out，先来先淘汰。这种算法在每一次新数据插入时，如果队列已满，则将最早插入的数据移除。 </p><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p>可以方便的借助LinkedList来实现</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test;<span class="hljs-keyword">import</span> java.util.Iterator;<span class="hljs-keyword">import</span> java.util.LinkedList;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FIFO</span> </span>&#123;    LinkedList&lt;Integer&gt; fifo = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();    <span class="hljs-keyword">int</span> size = <span class="hljs-number">3</span>;    <span class="hljs-comment">//添加元素</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;        fifo.addFirst(i);        <span class="hljs-keyword">if</span> (fifo.size() &gt; size) &#123;            fifo.removeLast();        &#125;        print();    &#125;    <span class="hljs-comment">//缓存命中</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;        Iterator&lt;Integer&gt; iterator = fifo.iterator();        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;            <span class="hljs-keyword">int</span> j = iterator.next();            <span class="hljs-keyword">if</span> (i == j) &#123;                System.out.println(<span class="hljs-string">"find it!"</span>);                print();                <span class="hljs-keyword">return</span>;            &#125;        &#125;        System.out.println(<span class="hljs-string">"not found!"</span>);        print();    &#125;    <span class="hljs-comment">//打印缓存</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-keyword">this</span>.fifo);    &#125;    <span class="hljs-comment">//测试</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        FIFO fifo = <span class="hljs-keyword">new</span> FIFO();        System.out.println(<span class="hljs-string">"add 1‐3:"</span>);        fifo.add(<span class="hljs-number">1</span>);        fifo.add(<span class="hljs-number">2</span>);        fifo.add(<span class="hljs-number">3</span>);        System.out.println(<span class="hljs-string">"add 4:"</span>);        fifo.add(<span class="hljs-number">4</span>);        System.out.println(<span class="hljs-string">"read 2:"</span>);        fifo.read(<span class="hljs-number">2</span>);        System.out.println(<span class="hljs-string">"read 100:"</span>);        fifo.read(<span class="hljs-number">100</span>);        System.out.println(<span class="hljs-string">"add 5:"</span>);        fifo.add(<span class="hljs-number">5</span>);    &#125;&#125;</code></pre><h5 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h5><pre><code class="hljs angelscript">add <span class="hljs-number">1</span>‐<span class="hljs-number">3</span>:[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>, <span class="hljs-number">1</span>][<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]add <span class="hljs-number">4</span>:[<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>]read <span class="hljs-number">2</span>:find it![<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>]read <span class="hljs-number">100</span>:<span class="hljs-keyword">not</span> found![<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>]add <span class="hljs-number">5</span>:[<span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>]</code></pre><ul><li><p>1-3按顺序放入，没有问题 </p></li><li><p>4放入，那么1最早放入，被挤掉 </p></li><li><p>读取2，读到，但是不会影响队列顺序（2依然是时间最老的） </p></li><li><p>读取100，读不到，也不会产生任何影响 </p></li><li><p>5加入，踢掉了2，而不管2之前有没有被使用（不够理性） </p></li></ul><h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><ul><li>实现非常简单</li><li>不管元素的使用情况，哪怕有些数据会被频繁用到，时间最久也会被踢掉</li></ul><h4 id="最久未用淘汰（LRU）"><a href="#最久未用淘汰（LRU）" class="headerlink" title="最久未用淘汰（LRU）"></a>最久未用淘汰（<strong>LRU</strong>）</h4><h5 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h5><p>LRU全称是Least Recently Used，即淘汰最后一次使用时间最久远的数值。FIFO非常的粗暴，不管有没有用到，直接踢掉时间久的元素。而LRU认为，最近频繁使用过的数据，将来也很大程度上会被频繁用到，故而淘汰那些懒惰的数据。LinkedHashMap，数组，链表均可实现LRU，下面仍然以链表为例：新加入的数据放在头部，最近访问的，也移到头部，空间满时，将尾部元素删除。 </p><h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.release;<span class="hljs-keyword">import</span> java.util.Iterator;<span class="hljs-keyword">import</span> java.util.LinkedList;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRU</span> </span>&#123;    LinkedList&lt;Integer&gt; lru = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();    <span class="hljs-keyword">int</span> size = <span class="hljs-number">3</span>;    <span class="hljs-comment">//添加元素 </span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;        lru.addFirst(i);        <span class="hljs-keyword">if</span> (lru.size() &gt; size) &#123;            lru.removeLast();        &#125;        print();    &#125;    <span class="hljs-comment">//缓存命中 </span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;        Iterator&lt;Integer&gt; iterator = lru.iterator();        <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;            <span class="hljs-keyword">int</span> j = iterator.next();            <span class="hljs-keyword">if</span> (i == j) &#123;                System.out.println(<span class="hljs-string">"find it!"</span>);                lru.remove(index);                lru.addFirst(j);                print();                <span class="hljs-keyword">return</span>;            &#125;            index++;        &#125;        System.out.println(<span class="hljs-string">"not found!"</span>);        print();    &#125;    <span class="hljs-comment">//打印缓存 </span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-keyword">this</span>.lru);    &#125;    <span class="hljs-comment">//测试 </span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        LRU lru = <span class="hljs-keyword">new</span> LRU();        System.out.println(<span class="hljs-string">"add 1‐3:"</span>);        lru.add(<span class="hljs-number">1</span>);        lru.add(<span class="hljs-number">2</span>);        lru.add(<span class="hljs-number">3</span>);        System.out.println(<span class="hljs-string">"add 4:"</span>);        lru.add(<span class="hljs-number">4</span>);        System.out.println(<span class="hljs-string">"read 2:"</span>);        lru.read(<span class="hljs-number">2</span>);        System.out.println(<span class="hljs-string">"read 100:"</span>);        lru.read(<span class="hljs-number">100</span>);        System.out.println(<span class="hljs-string">"add 5:"</span>);        lru.add(<span class="hljs-number">5</span>);    &#125;&#125;</code></pre><h5 id="结果分析-1"><a href="#结果分析-1" class="headerlink" title="结果分析"></a>结果分析</h5><pre><code class="hljs angelscript">add <span class="hljs-number">1</span>‐<span class="hljs-number">3</span>:[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>, <span class="hljs-number">1</span>][<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]add <span class="hljs-number">4</span>:[<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>]read <span class="hljs-number">2</span>:find it![<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>]read <span class="hljs-number">100</span>:<span class="hljs-keyword">not</span> found![<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>]add <span class="hljs-number">5</span>:[<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>]</code></pre><ul><li><p>1-3加入，没有问题 </p></li><li><p>4加入，踢掉1，没问题 </p></li><li><p>读取2，读到，注意，2被移到了队首！ </p></li><li><p>读取100，读不到，没影响 </p></li><li><p>5加入，因为2之前被用到，不会被剔除，3和4都没人用，但是3更久，被剔除</p></li></ul><h4 id="最近最少使用（LFU）"><a href="#最近最少使用（LFU）" class="headerlink" title="最近最少使用（LFU）"></a>最近最少使用（<strong>LFU</strong>）</h4><h5 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h5><p>Least Frequently Used，即最近最少使用。它要淘汰的是最近一段时间内，使用次数最少的值。可以认为比LRU多了一重判断。LFU需要时间和次数两个维度的参考指标。需要注意的是，两个维度就可能涉及到同一时间段内，访问次数相同的情况，就必须内置一个计数器和一个队列，计数器算数，队列放置相同计数时的访问时间。 </p><h5 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h5><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.release;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dto</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Dto</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> Integer key;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> lastTime;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Dto</span><span class="hljs-params">(Integer key, <span class="hljs-keyword">int</span> count, <span class="hljs-keyword">long</span> lastTime)</span> </span>&#123;        <span class="hljs-keyword">this</span>.key = key;        <span class="hljs-keyword">this</span>.count = count;        <span class="hljs-keyword">this</span>.lastTime = lastTime;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Dto o)</span> </span>&#123;        <span class="hljs-keyword">int</span> compare = Integer.compare(<span class="hljs-keyword">this</span>.count, o.count);        <span class="hljs-keyword">return</span> compare == <span class="hljs-number">0</span> ? Long.compare(<span class="hljs-keyword">this</span>.lastTime, o.lastTime) : compare;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">"[key=%s,count=%s,lastTime=%s]"</span>, key, count, lastTime);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getKey</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> key;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setKey</span><span class="hljs-params">(Integer key)</span> </span>&#123;        <span class="hljs-keyword">this</span>.key = key;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> count;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> count)</span> </span>&#123;        <span class="hljs-keyword">this</span>.count = count;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getLastTime</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> lastTime;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLastTime</span><span class="hljs-params">(<span class="hljs-keyword">long</span> lastTime)</span> </span>&#123;        <span class="hljs-keyword">this</span>.lastTime = lastTime;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.release;<span class="hljs-keyword">import</span> java.util.Collections;<span class="hljs-keyword">import</span> java.util.HashMap;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LFU</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> size = <span class="hljs-number">3</span>;    <span class="hljs-keyword">private</span> Map&lt;Integer, Integer&gt; cache = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-keyword">private</span> Map&lt;Integer, Dto&gt; count = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-comment">//投放</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(Integer key, Integer value)</span> </span>&#123;        Integer v = cache.get(key);        <span class="hljs-keyword">if</span> (v == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">if</span> (cache.size() == size) &#123;                removeElement();            &#125;            count.put(key, <span class="hljs-keyword">new</span> Dto(key, <span class="hljs-number">1</span>, System.currentTimeMillis()));        &#125; <span class="hljs-keyword">else</span> &#123;            addCount(key);        &#125;        cache.put(key, value);    &#125;    <span class="hljs-comment">//读取</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">get</span><span class="hljs-params">(Integer key)</span> </span>&#123;        Integer value = cache.get(key);        <span class="hljs-keyword">if</span> (value != <span class="hljs-keyword">null</span>) &#123;            addCount(key);            <span class="hljs-keyword">return</span> value;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-comment">//淘汰元素</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeElement</span><span class="hljs-params">()</span> </span>&#123;        Dto dto = Collections.min(count.values());        cache.remove(dto.getKey());        count.remove(dto.getKey());    &#125;    <span class="hljs-comment">//更新计数器</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addCount</span><span class="hljs-params">(Integer key)</span> </span>&#123;        Dto Dto = count.get(key);        Dto.setCount(Dto.getCount() + <span class="hljs-number">1</span>);        Dto.setLastTime(System.currentTimeMillis());    &#125;    <span class="hljs-comment">//打印缓存结构和计数器结构</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"cache="</span> + cache);        System.out.println(<span class="hljs-string">"count="</span> + count);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        LFU lfu = <span class="hljs-keyword">new</span> LFU();        <span class="hljs-comment">//前3个容量没满，1,2,3均加入 </span>        System.out.println(<span class="hljs-string">"add 1‐3:"</span>);        lfu.put(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);        lfu.put(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);        lfu.put(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>);        lfu.print();        <span class="hljs-comment">//1,2有访问，3没有，加入4，淘汰3 </span>        System.out.println(<span class="hljs-string">"read 1,2"</span>);        lfu.get(<span class="hljs-number">1</span>);        lfu.get(<span class="hljs-number">2</span>);        lfu.print();        System.out.println(<span class="hljs-string">"add 4:"</span>);        lfu.put(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>);        lfu.print();        <span class="hljs-comment">//2=3次，1,4=2次，但是4加入较晚，再加入5时淘汰1 </span>        System.out.println(<span class="hljs-string">"read 2,4"</span>);        lfu.get(<span class="hljs-number">2</span>);        lfu.get(<span class="hljs-number">4</span>);        lfu.print();        System.out.println(<span class="hljs-string">"add 5:"</span>);        lfu.put(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>);        lfu.print();    &#125;&#125;</code></pre><h5 id="结果分析-2"><a href="#结果分析-2" class="headerlink" title="结果分析"></a>结果分析</h5><pre><code class="hljs angelscript">add <span class="hljs-number">1</span>‐<span class="hljs-number">3</span>:cache=&#123;<span class="hljs-number">1</span>=<span class="hljs-number">1</span>, <span class="hljs-number">2</span>=<span class="hljs-number">2</span>, <span class="hljs-number">3</span>=<span class="hljs-number">3</span>&#125;count=&#123;<span class="hljs-number">1</span>=[key=<span class="hljs-number">1</span>,count=<span class="hljs-number">1</span>,lastTime=<span class="hljs-number">1598000803514</span>], <span class="hljs-number">2</span>=[key=<span class="hljs-number">2</span>,count=<span class="hljs-number">1</span>,lastTime=<span class="hljs-number">1598000803514</span>], <span class="hljs-number">3</span>=[key=<span class="hljs-number">3</span>,count=<span class="hljs-number">1</span>,lastTime=<span class="hljs-number">1598000803514</span>]&#125;read <span class="hljs-number">1</span>,<span class="hljs-number">2</span>cache=&#123;<span class="hljs-number">1</span>=<span class="hljs-number">1</span>, <span class="hljs-number">2</span>=<span class="hljs-number">2</span>, <span class="hljs-number">3</span>=<span class="hljs-number">3</span>&#125;count=&#123;<span class="hljs-number">1</span>=[key=<span class="hljs-number">1</span>,count=<span class="hljs-number">2</span>,lastTime=<span class="hljs-number">1598000803535</span>], <span class="hljs-number">2</span>=[key=<span class="hljs-number">2</span>,count=<span class="hljs-number">2</span>,lastTime=<span class="hljs-number">1598000803535</span>], <span class="hljs-number">3</span>=[key=<span class="hljs-number">3</span>,count=<span class="hljs-number">1</span>,lastTime=<span class="hljs-number">1598000803514</span>]&#125;add <span class="hljs-number">4</span>:cache=&#123;<span class="hljs-number">1</span>=<span class="hljs-number">1</span>, <span class="hljs-number">2</span>=<span class="hljs-number">2</span>, <span class="hljs-number">4</span>=<span class="hljs-number">4</span>&#125;count=&#123;<span class="hljs-number">1</span>=[key=<span class="hljs-number">1</span>,count=<span class="hljs-number">2</span>,lastTime=<span class="hljs-number">1598000803535</span>], <span class="hljs-number">2</span>=[key=<span class="hljs-number">2</span>,count=<span class="hljs-number">2</span>,lastTime=<span class="hljs-number">1598000803535</span>], <span class="hljs-number">4</span>=[key=<span class="hljs-number">4</span>,count=<span class="hljs-number">1</span>,lastTime=<span class="hljs-number">1598000803535</span>]&#125;read <span class="hljs-number">2</span>,<span class="hljs-number">4</span>cache=&#123;<span class="hljs-number">1</span>=<span class="hljs-number">1</span>, <span class="hljs-number">2</span>=<span class="hljs-number">2</span>, <span class="hljs-number">4</span>=<span class="hljs-number">4</span>&#125;count=&#123;<span class="hljs-number">1</span>=[key=<span class="hljs-number">1</span>,count=<span class="hljs-number">2</span>,lastTime=<span class="hljs-number">1598000803535</span>], <span class="hljs-number">2</span>=[key=<span class="hljs-number">2</span>,count=<span class="hljs-number">3</span>,lastTime=<span class="hljs-number">1598000803536</span>], <span class="hljs-number">4</span>=[key=<span class="hljs-number">4</span>,count=<span class="hljs-number">2</span>,lastTime=<span class="hljs-number">1598000803536</span>]&#125;add <span class="hljs-number">5</span>:cache=&#123;<span class="hljs-number">2</span>=<span class="hljs-number">2</span>, <span class="hljs-number">4</span>=<span class="hljs-number">4</span>, <span class="hljs-number">5</span>=<span class="hljs-number">5</span>&#125;count=&#123;<span class="hljs-number">2</span>=[key=<span class="hljs-number">2</span>,count=<span class="hljs-number">3</span>,lastTime=<span class="hljs-number">1598000803536</span>], <span class="hljs-number">4</span>=[key=<span class="hljs-number">4</span>,count=<span class="hljs-number">2</span>,lastTime=<span class="hljs-number">1598000803536</span>], <span class="hljs-number">5</span>=[key=<span class="hljs-number">5</span>,count=<span class="hljs-number">1</span>,lastTime=<span class="hljs-number">1598000803536</span>]&#125;</code></pre><ul><li><p>1-3加入，没问题，计数器为1次 </p></li><li><p>访问1，2，使用次数计数器上升为2次，3没有访问，仍然为1 </p></li><li><p>4加入，3的访问次数最少（1次），所以踢掉3，剩下124</p></li><li><p>访问2，4，计数器上升，2=3次，1，4=2次，但是1时间久 </p></li><li><p>5加入，踢掉1，最后剩下2，4，5 </p></li></ul><h5 id="应用案例"><a href="#应用案例" class="headerlink" title="应用案例"></a>应用案例</h5><p>redis属于缓存失效的典型应用场景，常见策略如下： </p><ul><li><p>noeviction: 不删除策略, 达到最大内存限制时, 如果需要更多内存, 直接返回错误信息（ 比较危险）。 </p></li><li><p>allkeys-lru：对所有key，优先删除最近最少使用的 key (LRU)。 </p></li><li><p>allkeys-random： 对所有key， 随机删除一部分（听起来毫无道理）。 </p></li><li><p>volatile-lru：只限于设置了 expire 的key，优先删除最近最少使用的key (LRU)。 </p></li><li><p>volatile-random：只限于设置了 expire 的key，随机删除一部分。 </p></li><li><p>volatile-ttl：只限于设置了 expire 的key，优先删除剩余时间(TTL) 短的key。</p></li></ul><h3 id="限流算法与应用"><a href="#限流算法与应用" class="headerlink" title="限流算法与应用"></a>限流算法与应用</h3><p>限流是对系统的一种保护措施。即限制流量请求的频率（每秒处理多少个请求）。一般来说，当请求流量超过系统的瓶颈，则丢弃掉多余的请求流量，保证系统的可用性。即要么不放进来，放进来的就保证提供服务。</p><h4 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h4><h5 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h5><p>计数器采用简单的计数操作，到一段时间节点后自动清零 </p><h5 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h5><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.release;<span class="hljs-keyword">import</span> java.util.concurrent.*;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//计数器，这里用信号量实现 </span>        <span class="hljs-keyword">final</span> Semaphore semaphore = <span class="hljs-keyword">new</span> Semaphore(<span class="hljs-number">3</span>);        <span class="hljs-comment">//定时器，到点清零 </span>        ScheduledExecutorService service = Executors.newScheduledThreadPool(<span class="hljs-number">1</span>);        service.scheduleAtFixedRate(<span class="hljs-keyword">new</span> Runnable() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                semaphore.release(<span class="hljs-number">3</span>);            &#125;        &#125;, <span class="hljs-number">3000</span>, <span class="hljs-number">3000</span>, TimeUnit.MILLISECONDS);        <span class="hljs-comment">//模拟无数个请求从天而降 </span>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">//判断计数器</span>                semaphore.acquire();            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            <span class="hljs-comment">//如果准许响应，打印一个ok </span>            System.out.println(<span class="hljs-string">"ok"</span>);        &#125;    &#125;&#125;</code></pre><h5 id="结果分析-3"><a href="#结果分析-3" class="headerlink" title="结果分析"></a>结果分析</h5><p>3个ok一组呈现，到下一个计数周期之前被阻断 </p><h5 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h5><p>实现起来非常简单。 </p><p>控制力度太过于简略，假如1s内限制3次，那么如果3次在前100ms内已经用完，后面的900ms将只能处于阻塞状态，白白浪费掉。 </p><h5 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h5><p>使用计数器限流的场景较少，因为它的处理逻辑不够灵活。最常见的可能在web的登录密码验证，输入错误次数冻结一段时间的场景。如果网站请求使用计数器，那么恶意攻击者前100ms吃掉流量计数，使得后续正常的请求被全部阻断，整个服务很容易被搞垮。 </p><h4 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h4><h5 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h5><p>漏桶算法将请求缓存在桶中，服务流程匀速处理。超出桶容量的部分丢弃。漏桶算法主要用于保护内部的处理业务，保障其稳定有节奏的处理请求，但是无法根据流量的波动弹性调整响应能力。现实中，类似容纳人数有限的服务大厅开启了固定的服务窗口。</p><img src="/blog/2020/08/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E4%B8%8E%E5%BA%94%E7%94%A8/pic1.png" srcset="/blog/img/loading.gif" class><h5 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h5><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.release;<span class="hljs-keyword">import</span> java.util.concurrent.*;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Barrel</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//桶，用阻塞队列实现，容量为3 </span>        <span class="hljs-keyword">final</span> LinkedBlockingQueue&lt;Integer&gt; que = <span class="hljs-keyword">new</span> LinkedBlockingQueue(<span class="hljs-number">3</span>);        <span class="hljs-comment">//定时器，相当于服务的窗口，2s处理一个</span>        ScheduledExecutorService service = Executors.newScheduledThreadPool(<span class="hljs-number">1</span>);        service.scheduleAtFixedRate(<span class="hljs-keyword">new</span> Runnable() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-keyword">int</span> v = que.poll();                System.out.println(<span class="hljs-string">"处理："</span> + v);            &#125;        &#125;, <span class="hljs-number">2000</span>, <span class="hljs-number">2000</span>, TimeUnit.MILLISECONDS);        <span class="hljs-comment">//无数个请求，i 可以理解为请求的编号</span>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;            i++;            <span class="hljs-keyword">try</span> &#123;                System.out.println(<span class="hljs-string">"put:"</span> + i);                <span class="hljs-comment">//如果是put，会一直等待桶中有空闲位置，不会丢弃 </span>                <span class="hljs-comment">//que.put(i);</span>                <span class="hljs-comment">//等待1s如果进不了桶，就溢出丢弃 </span>                que.offer(i, <span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS);            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;</code></pre><h5 id="结果分析-4"><a href="#结果分析-4" class="headerlink" title="结果分析"></a>结果分析</h5><pre><code class="hljs vim"><span class="hljs-keyword">pu</span><span class="hljs-variable">t:1</span><span class="hljs-keyword">pu</span><span class="hljs-variable">t:2</span><span class="hljs-keyword">pu</span><span class="hljs-variable">t:3</span><span class="hljs-keyword">pu</span><span class="hljs-variable">t:4</span><span class="hljs-keyword">pu</span><span class="hljs-variable">t:5</span>处理：<span class="hljs-number">1</span><span class="hljs-keyword">pu</span><span class="hljs-variable">t:6</span><span class="hljs-keyword">pu</span><span class="hljs-variable">t:7</span>处理：<span class="hljs-number">2</span><span class="hljs-keyword">pu</span><span class="hljs-variable">t:8</span></code></pre><p>put任务号按照顺序入桶 </p><p>执行任务匀速的1s一个被处理 </p><p>因为桶的容量只有3，所以1-3完美执行，4被溢出丢弃，5正常执行 </p><h5 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h5><p>有效的挡住了外部的请求，保护了内部的服务不会过载 </p><p>内部服务匀速执行，无法应对流量洪峰，无法做到弹性处理突发任务</p><p>任务超时溢出时被丢弃。现实中可能需要缓存队列辅助保持一段时间 </p><h5 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h5><p>nginx中的限流是漏桶算法的典型应用，配置案例如下： </p><pre><code class="hljs yaml"><span class="hljs-string">http</span> <span class="hljs-string">&#123;</span><span class="hljs-comment">#$binary_remote_addr 表示通过remote_addr这个标识来做key，也就是限制同一客户端ip地址。</span>  <span class="hljs-comment">#zone=one:10m 表示生成一个大小为10M，名字为one的内存区域，用来存储访问的频次信息。 </span>  <span class="hljs-comment">#rate=1r/s 表示允许相同标识的客户端每秒1次访问</span>  <span class="hljs-string">limit_req_zone</span> <span class="hljs-string">$binary_remote_addr</span> <span class="hljs-string">zone=one:10m</span> <span class="hljs-string">rate=1r/s;</span>  <span class="hljs-string">server</span> <span class="hljs-string">&#123;</span>   <span class="hljs-string">location</span> <span class="hljs-string">/limited/</span> <span class="hljs-string">&#123;</span>   <span class="hljs-comment">#zone=one 与上面limit_req_zone 里的name对应。 </span>  <span class="hljs-comment">#burst=5 缓冲区，超过了访问频次限制的请求可以先放到这个缓冲区内，类似代码中的队列长度。</span>    <span class="hljs-comment">#nodelay 如果设置，超过访问频次而且缓冲区也满了的时候就会直接返回503，如果没有设置，则所有请求 会等待排队，类似代码中的put还是offer。</span>    <span class="hljs-string">limit_req</span> <span class="hljs-string">zone=one</span> <span class="hljs-string">burst=5</span> <span class="hljs-string">nodelay;</span>  <span class="hljs-string">&#125;</span> <span class="hljs-string">&#125;</span></code></pre><h4 id="令牌桶"><a href="#令牌桶" class="headerlink" title="令牌桶"></a>令牌桶</h4><h5 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h5><p>令牌桶算法可以认为是漏桶算法的一种升级，它不但可以将流量做一步限制，还可以解决漏桶中无法弹性伸缩处理请求的问题。体现在现实中，类似服务大厅的门口设置门禁卡发放。发放是匀速的，请求较少时，令牌可以缓存起来，供流量爆发时一次性批量获取使用。而内部服务窗口不设限。 </p><img src="/blog/2020/08/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E4%B8%8E%E5%BA%94%E7%94%A8/pic2.png" srcset="/blog/img/loading.gif" class><h5 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h5><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.release;<span class="hljs-keyword">import</span> java.util.concurrent.*;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Token</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-comment">//令牌桶，信号量实现，容量为3</span>        <span class="hljs-keyword">final</span> Semaphore semaphore = <span class="hljs-keyword">new</span> Semaphore(<span class="hljs-number">3</span>);        <span class="hljs-comment">//定时器，1s一个，匀速颁发令牌</span>        ScheduledExecutorService service = Executors.newScheduledThreadPool(<span class="hljs-number">1</span>);        service.scheduleAtFixedRate(<span class="hljs-keyword">new</span> Runnable() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-keyword">if</span> (semaphore.availablePermits() &lt; <span class="hljs-number">3</span>) &#123;                    semaphore.release();                &#125;                <span class="hljs-comment">// System.out.println("令牌数："+semaphore.availablePermits());</span>            &#125;        &#125;, <span class="hljs-number">1000</span>, <span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS);        <span class="hljs-comment">//等待，等候令牌桶储存</span>        Thread.sleep(<span class="hljs-number">5</span>);        <span class="hljs-comment">//模拟洪峰5个请求，前3个迅速响应，后两个排队 </span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;            semaphore.acquire();            System.out.println(<span class="hljs-string">"洪峰："</span> + i);        &#125;        <span class="hljs-comment">//模拟日常请求，2s一个 </span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;            Thread.sleep(<span class="hljs-number">1000</span>);            semaphore.acquire();            System.out.println(<span class="hljs-string">"日常："</span> + i);            Thread.sleep(<span class="hljs-number">1000</span>);        &#125;        <span class="hljs-comment">//再次洪峰</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;            semaphore.acquire();            System.out.println(<span class="hljs-string">"洪峰："</span> + i);        &#125;        <span class="hljs-comment">//检查令牌桶的数量</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;            Thread.sleep(<span class="hljs-number">2000</span>);            System.out.println(<span class="hljs-string">"令牌剩余："</span> + semaphore.availablePermits());        &#125;    &#125;&#125;</code></pre><h5 id="结果分析-5"><a href="#结果分析-5" class="headerlink" title="结果分析"></a>结果分析</h5><pre><code class="hljs angelscript">洪峰：<span class="hljs-number">0</span>洪峰：<span class="hljs-number">1</span>洪峰：<span class="hljs-number">2</span>洪峰：<span class="hljs-number">3</span>洪峰：<span class="hljs-number">4</span>日常：<span class="hljs-number">0</span>日常：<span class="hljs-number">1</span>日常：<span class="hljs-number">2</span>洪峰：<span class="hljs-number">0</span>洪峰：<span class="hljs-number">1</span>洪峰：<span class="hljs-number">2</span>洪峰：<span class="hljs-number">3</span>洪峰：<span class="hljs-number">4</span>令牌剩余：<span class="hljs-number">2</span>令牌剩余：<span class="hljs-number">3</span>令牌剩余：<span class="hljs-number">3</span></code></pre><ul><li><p>洪峰0-2迅速被执行，说明桶中暂存了3个令牌，有效应对了洪峰 </p></li><li><p>洪峰3，4被间隔性执行，得到了有效的限流 </p></li><li><p>日常请求被匀速执行，间隔均匀 </p></li><li><p>第二波洪峰来临，和第一次一样 </p></li><li><p>请求过去后，令牌最终被均匀颁发，积累到3个后不再上升 </p></li></ul><h5 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h5><p>springcloud中gateway可以配置令牌桶实现限流控制，案例如下： </p><pre><code class="hljs yml"><span class="hljs-attr">cloud:</span> <span class="hljs-attr">gateway:</span> <span class="hljs-attr">routes:</span> <span class="hljs-attr">id:</span> <span class="hljs-string">limit_route</span> <span class="hljs-attr">uri:</span> <span class="hljs-string">http://localhost:8080/test</span> <span class="hljs-attr">filters:</span> <span class="hljs-attr">name:</span> <span class="hljs-string">RequestRateLimiter</span> <span class="hljs-attr">args:</span> <span class="hljs-comment">#限流的key，ipKeyResolver为spring中托管的Bean，需要扩展KeyResolver接口 </span><span class="hljs-string">key‐resolver:</span> <span class="hljs-string">'#&#123;@ipResolver&#125;'</span> <span class="hljs-comment">#令牌桶每秒填充平均速率，相当于代码中的发放频率 </span><span class="hljs-string">redis‐rate‐limiter.replenishRate:</span> <span class="hljs-number">1</span> <span class="hljs-comment">#令牌桶总容量，相当于代码中，信号量的容量 </span><span class="hljs-string">redis‐rate‐limiter.burstCapacity:</span> <span class="hljs-number">3</span></code></pre><h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><h5 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h5><p>滑动窗口可以理解为细分之后的计数器，计数器粗暴的限定1分钟内的访问次数，而滑动窗口限流将1分钟拆为多个段，不但要求整个1分钟内请求数小于上限，而且要求每个片段请求数也要小于上限。相当于将原来的计数周期做了多个片段拆分。更为精细。 </p><img src="/blog/2020/08/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E4%B8%8E%E5%BA%94%E7%94%A8/pic3.png" srcset="/blog/img/loading.gif" class><h5 id="实现-6"><a href="#实现-6" class="headerlink" title="实现"></a>实现</h5><img src="/blog/2020/08/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E4%B8%8E%E5%BA%94%E7%94%A8/pic4.png" srcset="/blog/img/loading.gif" class><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.release;<span class="hljs-keyword">import</span> java.util.LinkedList;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-keyword">import</span> java.util.TreeMap;<span class="hljs-keyword">import</span> java.util.concurrent.Executors;<span class="hljs-keyword">import</span> java.util.concurrent.ScheduledExecutorService;<span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Window</span> </span>&#123;    <span class="hljs-comment">//整个窗口的流量上限，超出会被限流 </span>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> totalMax = <span class="hljs-number">5</span>;    <span class="hljs-comment">//每片的流量上限，超出同样会被拒绝，可以设置不同的值 </span>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> sliceMax = <span class="hljs-number">5</span>;    <span class="hljs-comment">//分多少片 </span>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> slice = <span class="hljs-number">3</span>;    <span class="hljs-comment">//窗口，分3段，每段1s，也就是总长度3s </span>    <span class="hljs-keyword">final</span> LinkedList&lt;Long&gt; linkedList = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    <span class="hljs-comment">//计数器，每片一个key，可以使用HashMap，这里为了控制台保持有序性和可读性，采用TreeMap </span>    Map&lt;Long, AtomicInteger&gt; map = <span class="hljs-keyword">new</span> TreeMap();    <span class="hljs-comment">//心跳，每1s跳动1次，滑动窗口向前滑动一步，实际业务中可能需要手动控制滑动窗口的时机。</span>    ScheduledExecutorService service = Executors.newScheduledThreadPool(<span class="hljs-number">1</span>);    <span class="hljs-comment">//获取key值，这里即是时间戳（秒）</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> Long <span class="hljs-title">getKey</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> System.currentTimeMillis() / <span class="hljs-number">1000</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Window</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//初始化窗口，当前时间指向的是最末端，前两片其实是过去的2s </span>        Long key = getKey();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; slice; i++) &#123;            linkedList.addFirst(key - i);            map.put(key - i, <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>));        &#125;        <span class="hljs-comment">//启动心跳任务，窗口根据时间，自动向前滑动，每秒1步 </span>        service.scheduleAtFixedRate(<span class="hljs-keyword">new</span> Runnable() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                Long key = getKey();                <span class="hljs-comment">//队尾添加最新的片</span>                linkedList.addLast(key);                map.put(key, <span class="hljs-keyword">new</span> AtomicInteger());                <span class="hljs-comment">//将最老的片移除</span>                map.remove(linkedList.getFirst());                linkedList.removeFirst();                System.out.println(<span class="hljs-string">"step:"</span> + key + <span class="hljs-string">":"</span> + map);                ;            &#125;        &#125;, <span class="hljs-number">1000</span>, <span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS);    &#125;    <span class="hljs-comment">//检查当前时间所在的片是否达到上限</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkCurrentSlice</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">long</span> key = getKey();        AtomicInteger integer = map.get(key);        <span class="hljs-keyword">if</span> (integer != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> integer.get() &lt; sliceMax;        &#125;        <span class="hljs-comment">//默认允许访问 </span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-comment">//检查整个窗口所有片的计数之和是否达到上限</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkAllCount</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> map.values().stream().mapToInt(value -&gt; value.get()).sum() &lt; totalMax;    &#125;    <span class="hljs-comment">//请求来临.... </span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">req</span><span class="hljs-params">()</span> </span>&#123;        Long key = getKey();        <span class="hljs-comment">//如果时间窗口未到达当前时间片，稍微等待一下 </span>        <span class="hljs-comment">// 其实是一个保护措施，放置心跳对滑动窗口的推动滞后于当前请求</span>        <span class="hljs-keyword">while</span> (linkedList.getLast() &lt; key) &#123;            <span class="hljs-keyword">try</span> &#123;                Thread.sleep(<span class="hljs-number">200</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;        <span class="hljs-comment">//开始检查，如果未达到上限，返回ok，计数器增加1 </span>        <span class="hljs-comment">// 如果任意一项达到上限，拒绝请求，达到限流的目的 </span>        <span class="hljs-comment">// 这里是直接拒绝。现实中可能会设置缓冲池，将请求放入缓冲队列暂存 </span>        <span class="hljs-keyword">if</span> (checkCurrentSlice() &amp;&amp; checkAllCount()) &#123;            map.get(key).incrementAndGet();            System.out.println(key + <span class="hljs-string">"=ok:"</span> + map);        &#125; <span class="hljs-keyword">else</span> &#123;            System.out.println(key + <span class="hljs-string">"=reject:"</span> + map);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        Window window = <span class="hljs-keyword">new</span> Window();        <span class="hljs-comment">//模拟10个离散的请求，相对之间有200ms间隔。会造成总数达到上限而被限流 </span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            Thread.sleep(<span class="hljs-number">200</span>);            window.req();        &#125;        <span class="hljs-comment">//等待一下窗口滑动，让各个片的计数器都置零</span>        Thread.sleep(<span class="hljs-number">3000</span>);        <span class="hljs-comment">//模拟突发请求，单个片的计数器达到上限而被限流</span>        System.out.println(<span class="hljs-string">"‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐"</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            window.req();        &#125;    &#125;&#125;</code></pre><h5 id="结果分析-6"><a href="#结果分析-6" class="headerlink" title="结果分析"></a>结果分析</h5><pre><code class="hljs routeros"><span class="hljs-attribute">1598005699</span>=ok:&#123;<span class="hljs-attribute">1598005697</span>=0, <span class="hljs-attribute">1598005698</span>=0, <span class="hljs-attribute">1598005699</span>=1&#125;<span class="hljs-attribute">1598005699</span>=ok:&#123;<span class="hljs-attribute">1598005697</span>=0, <span class="hljs-attribute">1598005698</span>=0, <span class="hljs-attribute">1598005699</span>=2&#125;<span class="hljs-keyword">step</span>:1598005700:&#123;<span class="hljs-attribute">1598005698</span>=0, <span class="hljs-attribute">1598005699</span>=2, <span class="hljs-attribute">1598005700</span>=0&#125;<span class="hljs-attribute">1598005700</span>=ok:&#123;<span class="hljs-attribute">1598005698</span>=0, <span class="hljs-attribute">1598005699</span>=2, <span class="hljs-attribute">1598005700</span>=1&#125;<span class="hljs-attribute">1598005700</span>=ok:&#123;<span class="hljs-attribute">1598005698</span>=0, <span class="hljs-attribute">1598005699</span>=2, <span class="hljs-attribute">1598005700</span>=2&#125;<span class="hljs-attribute">1598005700</span>=ok:&#123;<span class="hljs-attribute">1598005698</span>=0, <span class="hljs-attribute">1598005699</span>=2, <span class="hljs-attribute">1598005700</span>=3&#125;</code></pre><p>模拟零零散散的请求，会造成每个片里均有计数，总数达到上限后，不再响应，限流生效</p><p>再模拟突发的流量请求，会造成单片流量计数达到上限，不再响应而被限流</p><pre><code class="hljs routeros"><span class="hljs-attribute">1598005705</span>=reject:&#123;<span class="hljs-attribute">1598005703</span>=0, <span class="hljs-attribute">1598005704</span>=0, <span class="hljs-attribute">1598005705</span>=5&#125;<span class="hljs-attribute">1598005705</span>=reject:&#123;<span class="hljs-attribute">1598005703</span>=0, <span class="hljs-attribute">1598005704</span>=0, <span class="hljs-attribute">1598005705</span>=5&#125;<span class="hljs-attribute">1598005705</span>=reject:&#123;<span class="hljs-attribute">1598005703</span>=0, <span class="hljs-attribute">1598005704</span>=0, <span class="hljs-attribute">1598005705</span>=5&#125;<span class="hljs-attribute">1598005705</span>=reject:&#123;<span class="hljs-attribute">1598005703</span>=0, <span class="hljs-attribute">1598005704</span>=0, <span class="hljs-attribute">1598005705</span>=5&#125;<span class="hljs-attribute">1598005705</span>=reject:&#123;<span class="hljs-attribute">1598005703</span>=0, <span class="hljs-attribute">1598005704</span>=0, <span class="hljs-attribute">1598005705</span>=5&#125;</code></pre><h5 id="应用-3"><a href="#应用-3" class="headerlink" title="应用"></a>应用</h5><p>滑动窗口算法，在tcp协议发包过程中被使用。在web现实场景中，可以将流量控制做更细化处理，解决计数器模型控制力度太粗暴的问题。 </p><h3 id="调度算法与应用"><a href="#调度算法与应用" class="headerlink" title="调度算法与应用"></a>调度算法与应用</h3><p>调度算法常见于操作系统中，因为系统资源有限，当有多个进程（或多个进程发出的请求）要使用这些资源时，就 必须按照一定的原则选择进程（请求）来占用资源。这就是所谓的调度。在现实生活中也是一样，比如会议室的占用。</p><h4 id="先来先服务（FCFS）"><a href="#先来先服务（FCFS）" class="headerlink" title="先来先服务（FCFS）"></a>先来先服务（FCFS）</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>先来先服务，很好理解，就是按照服务提交申请的顺序，依次执行。讲究先来后到。 </p><h5 id="实现-7"><a href="#实现-7" class="headerlink" title="实现"></a>实现</h5><p>定义一个Task类作为任务实例，BlockingQueue作为服务队列 </p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.schedule;<span class="hljs-comment">/*** 任务类 */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Task</span> </span>&#123;    <span class="hljs-comment">//任务名称</span>    <span class="hljs-keyword">private</span> String name;    <span class="hljs-comment">//任务提交的时间 </span>    <span class="hljs-keyword">private</span> Long addTime;    <span class="hljs-comment">//任务的执行时间长短 </span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> servTime;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Task</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> servTime)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;        <span class="hljs-keyword">this</span>.servTime = servTime;        <span class="hljs-keyword">this</span>.addTime = System.currentTimeMillis();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// ！重点：执行时睡眠，表示该任务耗时servTime毫秒</span>            Thread.currentThread().sleep(servTime);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.out.println(String.format(<span class="hljs-string">"execute:name=%s,addTime=%s,servTime=%s"</span>, name, addTime, servTime));    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.schedule;<span class="hljs-keyword">import</span> java.util.Random;<span class="hljs-keyword">import</span> java.util.concurrent.LinkedBlockingQueue;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FCFS</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-comment">//阻塞队列，FCFS的基础 </span>        <span class="hljs-keyword">final</span> LinkedBlockingQueue&lt;Task&gt; queue = <span class="hljs-keyword">new</span> LinkedBlockingQueue(<span class="hljs-number">5</span>);        <span class="hljs-comment">//服务线程，任务由该线程获取和执行 </span>        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;                    <span class="hljs-keyword">try</span> &#123;                        queue.take().execute();                    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                        e.printStackTrace();                    &#125;                &#125;            &#125;        &#125;).start();        <span class="hljs-comment">//向队列中放入一个任务 </span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;            System.out.println(<span class="hljs-string">"add task:"</span> + i);            queue.put(<span class="hljs-keyword">new</span> Task(<span class="hljs-string">"task"</span> + i, <span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">1000</span>)));        &#125;    &#125;&#125;</code></pre><h5 id="结果分析-7"><a href="#结果分析-7" class="headerlink" title="结果分析"></a>结果分析</h5><pre><code class="hljs routeros"><span class="hljs-builtin-name">add</span> task:0<span class="hljs-builtin-name">add</span> task:1<span class="hljs-builtin-name">add</span> task:2<span class="hljs-builtin-name">add</span> task:3<span class="hljs-builtin-name">add</span> task:4execute:<span class="hljs-attribute">name</span>=task0,addTime=1598006103935,servTime=690execute:<span class="hljs-attribute">name</span>=task1,addTime=1598006103935,servTime=951execute:<span class="hljs-attribute">name</span>=task2,addTime=1598006103935,servTime=437execute:<span class="hljs-attribute">name</span>=task3,addTime=1598006103935,servTime=692execute:<span class="hljs-attribute">name</span>=task4,addTime=1598006103935,servTime=446</code></pre><ul><li><p>add按顺序放入，时间有序 </p></li><li><p>execute也按时间顺序执行，而不管后面的servTime，也就是不管执行任务长短，先来先执行 </p></li></ul><h5 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h5><ul><li><p>多应用于cpu密集型任务场景，对io密集型的不利。 </p></li><li><p>时间相对均衡的业务可以排队处理，比如现实中排队打卡进站。 </p></li><li><p>如果业务需要依赖大量的外部因素，执行时间片长短不一，FCFS算法不利于任务的整体处理进度，可能会因为一个长时间业务的阻塞而造成大量等待。 </p></li></ul><h4 id="短作业优先（SJF）"><a href="#短作业优先（SJF）" class="headerlink" title="短作业优先（SJF）"></a>短作业优先（SJF）</h4><h5 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h5><p>执行时间短的优先得到资源。即执行前申报一个我需要占据cpu的时间，根据时间长短，短的优先被调度。我不占时间所以我先来。 </p><h5 id="实现-8"><a href="#实现-8" class="headerlink" title="实现"></a>实现</h5><p>使用TreeMap可以实现优先级的任务排序。</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.schedule;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-keyword">import</span> java.util.Random;<span class="hljs-keyword">import</span> java.util.TreeMap;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SJF</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-comment">//有序Map，将服务时间作为key排序</span>        <span class="hljs-keyword">final</span> TreeMap&lt;Integer, Task&gt; treeMap = <span class="hljs-keyword">new</span> TreeMap();        <span class="hljs-comment">//向队列中放入5个任务 </span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;            System.out.println(<span class="hljs-string">"add task:"</span> + i);            <span class="hljs-keyword">int</span> servTime = <span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">1000</span>);            <span class="hljs-comment">//注意，key是servTime，即执行预估时间</span>            treeMap.put(servTime, <span class="hljs-keyword">new</span> Task(<span class="hljs-string">"task"</span> + i, servTime));        &#125;        <span class="hljs-comment">//服务线程，任务由该线程获取和执行 </span>        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;                    <span class="hljs-keyword">try</span> &#123;                        <span class="hljs-comment">//有序Map中，服务时间短的，置于顶部，那么自然就会优先被取出 </span>                        Map.Entry&lt;Integer, Task&gt; entry = treeMap.pollFirstEntry();                        <span class="hljs-keyword">if</span> (entry == <span class="hljs-keyword">null</span>) &#123;                            Thread.currentThread().sleep(<span class="hljs-number">100</span>);                        &#125; <span class="hljs-keyword">else</span> &#123;                            entry.getValue().execute();                        &#125;                    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                        e.printStackTrace();                    &#125;                &#125;            &#125;        &#125;).start();    &#125;&#125;</code></pre><h5 id="结果分析-8"><a href="#结果分析-8" class="headerlink" title="结果分析"></a>结果分析</h5><pre><code class="hljs routeros"><span class="hljs-builtin-name">add</span> task:0<span class="hljs-builtin-name">add</span> task:1<span class="hljs-builtin-name">add</span> task:2<span class="hljs-builtin-name">add</span> task:3<span class="hljs-builtin-name">add</span> task:4execute:<span class="hljs-attribute">name</span>=task4,addTime=1598006336903,servTime=116execute:<span class="hljs-attribute">name</span>=task2,addTime=1598006336902,servTime=117execute:<span class="hljs-attribute">name</span>=task0,addTime=1598006336902,servTime=575execute:<span class="hljs-attribute">name</span>=task3,addTime=1598006336902,servTime=689execute:<span class="hljs-attribute">name</span>=task1,addTime=1598006336902,servTime=935</code></pre><p>add任务有序，确实按照从前往后顺序提交的 </p><p>execute任务无序，按servtime排序，说明执行时间段的得到了优先执行 </p><h5 id="优缺点-4"><a href="#优缺点-4" class="headerlink" title="优缺点"></a>优缺点</h5><ul><li><p>适用于任务时间差别较大的场景，仍然以进站为例，拿出公交卡的优先刷卡，还没办卡的让一让。 </p></li><li><p>解决了FCFS整体处理时间长的问题，降低平均等待时间，提高了系统吞吐量。 </p></li><li><p>未考虑作业的紧迫程度，因而不能保证紧迫性作业（进程）的及时处理 </p></li><li><p>对长作业的不利，可能等待很久而得不到执行 </p></li><li><p>时间基于预估和申报，主观性因素在内，无法做到100%的精准</p></li></ul><h4 id="时间片轮转（RR）"><a href="#时间片轮转（RR）" class="headerlink" title="时间片轮转（RR）"></a>时间片轮转（RR）</h4><h5 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h5><p>时间片逐个扫描轮询，轮到谁谁执行。大家公平裁决来者有份，谁也别插队。像是棋牌游戏中的发牌操作，做到了时间和机会上的平均性。 </p><h5 id="实现-9"><a href="#实现-9" class="headerlink" title="实现"></a>实现</h5><p>基于数组做为数据插槽方式实现。</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.schedule;<span class="hljs-keyword">import</span> java.util.Random;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RR</span> </span>&#123;    <span class="hljs-comment">//定义数组作为插槽，每个插槽中可以放入任务</span>    Integer[] integers;    <span class="hljs-comment">//length插槽的个数 </span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RR</span><span class="hljs-params">(<span class="hljs-keyword">int</span> length)</span> </span>&#123;        integers = <span class="hljs-keyword">new</span> Integer[length];    &#125;    <span class="hljs-comment">//将任务放入插槽</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addTask</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;        <span class="hljs-keyword">int</span> slot = <span class="hljs-number">0</span>;        <span class="hljs-comment">//不停查找空的插槽</span>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;            <span class="hljs-comment">//发现空位，将当前任务放入 </span>            <span class="hljs-keyword">if</span> (integers[slot] == <span class="hljs-keyword">null</span>) &#123;                integers[slot] = value;                System.out.println(String.format(<span class="hljs-string">"‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐&gt;add task index=%s,value=%s"</span>, slot, value));                <span class="hljs-keyword">break</span>;            &#125;            <span class="hljs-comment">//如果当前位置有任务占用，看下一个位置</span>            slot++;            <span class="hljs-comment">//如果插槽遍历完还是没有空位置，那么从头开始再找，继续下一个轮回</span>            <span class="hljs-keyword">if</span> (slot == integers.length) &#123;                slot = <span class="hljs-number">0</span>;            &#125;        &#125;    &#125;    <span class="hljs-comment">//执行任务。轮询的策略就在这里 </span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//开启一个线程处理任务。在现实中可能有多个消费者来处理 </span>        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;                <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;                    <span class="hljs-comment">//指针轮询，如果到达尾部，下一步重新转向开头 </span>                    <span class="hljs-comment">// 数据物理结构是一个数组，逻辑上是一个环 </span>                    <span class="hljs-keyword">if</span> (index == integers.length) &#123;                        index = <span class="hljs-number">0</span>;                    &#125;                    <span class="hljs-comment">//如果当前位置没有任务，轮询到下一个插槽</span>                    <span class="hljs-keyword">if</span> (integers[index] == <span class="hljs-keyword">null</span>) &#123;                        index++;                        <span class="hljs-keyword">continue</span>;                    &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//随机等待，表示模拟当前任务有一个执行时间</span>                        <span class="hljs-keyword">try</span> &#123;                            Thread.currentThread().sleep(<span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">1000</span>));                        &#125; <span class="hljs-keyword">catch</span> (                                InterruptedException e) &#123;                            e.printStackTrace();                        &#125;<span class="hljs-comment">//模拟任务执行的内容，也就是打印一下当前插槽和里面的值 </span>                        System.out.println(String.format(<span class="hljs-string">"execute index=%s,value=%s"</span>, index, integers[index]));                        <span class="hljs-comment">//执行完，将当前插槽清空，腾出位置来给后续任务使用 </span>                        integers[index] = <span class="hljs-keyword">null</span>;                    &#125;                &#125;            &#125;        &#125;).start();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//测试开始，定义3个插槽 </span>        RR rr = <span class="hljs-keyword">new</span> RR(<span class="hljs-number">3</span>);        <span class="hljs-comment">//唤起执行者线程，开始轮询</span>        rr.execute();        <span class="hljs-comment">//放置10个任务</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            rr.addTask(i);        &#125;    &#125;&#125;</code></pre><h5 id="结果分析-9"><a href="#结果分析-9" class="headerlink" title="结果分析"></a>结果分析</h5><pre><code class="hljs smali">‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐&gt;add task index=0,value=0‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐&gt;add task index=1,value=1‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐&gt;add task index=2,value=2execute index=0,value=0‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐&gt;add task index=0,value=3execute index=1,value=1‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐&gt;add task index=1,value=4execute index=2,value=2‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐&gt;add task index=2,value=5execute index=0,value=3execute index=1,value=4‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐&gt;add task index=1,value=6‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐&gt;add task index=0,value=7execute index=2,value=5‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐&gt;add task index=2,value=8execute index=0,value=7execute index=1,value=6‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐&gt;add task index=1,value=9execute index=2,value=8execute index=1,value=9</code></pre><p>add任务index无序，value有序，说明是按顺序提交的，但是插槽无序，哪里有空放哪里 </p><p>execute执行index有序value无序，说明任务是轮询执行的，每个插槽里的任务不一定是谁 </p><h5 id="优缺点-5"><a href="#优缺点-5" class="headerlink" title="优缺点"></a>优缺点</h5><p>做到了机会的相对平均，不会因为某个任务执行时间超长而永远得不到执行 </p><p>缺乏任务主次的处理。重要的任务无法得到优先执行，必须等到时间片轮到自己，着急也没用</p><h4 id="优先级调度（HPF）"><a href="#优先级调度（HPF）" class="headerlink" title="优先级调度（HPF）"></a>优先级调度（HPF）</h4><h5 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a>概述</h5><p>进程调度每次将处理机分配给具有最高优先级的就绪进程。最高优先级算法可与不同的CPU方式结合形成可抢占式最高优先级算法和不可抢占式最高优先级算法。 </p><h5 id="实现-10"><a href="#实现-10" class="headerlink" title="实现"></a>实现</h5><p>在Task类中新增一个属性level作为优先级标识</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.schedule;<span class="hljs-comment">/*** 任务类 */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Task</span> </span>&#123;    <span class="hljs-comment">//任务名称</span>    <span class="hljs-keyword">private</span> String name;    <span class="hljs-comment">//任务提交的时间</span>    <span class="hljs-keyword">private</span> Long addTime;    <span class="hljs-comment">//任务的执行时间长短</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> servTime;    <span class="hljs-comment">//任务优先级</span>     <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> level;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Task</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> servTime)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;        <span class="hljs-keyword">this</span>.servTime = servTime;        <span class="hljs-keyword">this</span>.addTime = System.currentTimeMillis();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Task</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> servTime,<span class="hljs-keyword">int</span> level)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;        <span class="hljs-keyword">this</span>.servTime = servTime;        <span class="hljs-keyword">this</span>.addTime = System.currentTimeMillis();        <span class="hljs-keyword">this</span>.level = level;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// ！重点：执行时睡眠，表示该任务耗时servTime毫秒</span>            Thread.currentThread().sleep(servTime);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.out.println(String.format(<span class="hljs-string">"execute:name=%s,addTime=%s,servTime=%s"</span>, name, addTime, servTime));    &#125;&#125;</code></pre><p>依然使用TreeMap实现排序，注意的是，key要取优先级</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.schedule;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-keyword">import</span> java.util.Random;<span class="hljs-keyword">import</span> java.util.TreeMap;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HPF</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-comment">//有序Map，将服务优先级作为key排序 </span>        <span class="hljs-keyword">final</span> TreeMap&lt;Integer, Task&gt; treeMap = <span class="hljs-keyword">new</span> TreeMap();        <span class="hljs-comment">//向队列中放入5个任务 </span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;            System.out.println(<span class="hljs-string">"add task:"</span> + i);            <span class="hljs-keyword">int</span> servTime = <span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">1000</span>);            <span class="hljs-comment">//注意放入的key，是优先级，这里用i标识 </span>            treeMap.put(i, <span class="hljs-keyword">new</span> Task(<span class="hljs-string">"task"</span> + i, servTime, i));        &#125;        <span class="hljs-comment">//服务线程，任务由该线程获取和执行 </span>        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;                    <span class="hljs-keyword">try</span> &#123;                        <span class="hljs-comment">//有序Map中，优先级最高的，在底部部，那么自然就会优先被取出 </span>                        Map.Entry&lt;Integer, Task&gt; entry = treeMap.pollLastEntry();                        <span class="hljs-keyword">if</span> (entry == <span class="hljs-keyword">null</span>) &#123;                            Thread.currentThread().sleep(<span class="hljs-number">100</span>);                        &#125; <span class="hljs-keyword">else</span> &#123;                            entry.getValue().execute();                        &#125;                    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                        e.printStackTrace();                    &#125;                &#125;            &#125;        &#125;).start();    &#125;&#125;</code></pre><h5 id="结果分析-10"><a href="#结果分析-10" class="headerlink" title="结果分析"></a>结果分析</h5><pre><code class="hljs routeros"><span class="hljs-builtin-name">add</span> task:0<span class="hljs-builtin-name">add</span> task:1<span class="hljs-builtin-name">add</span> task:2<span class="hljs-builtin-name">add</span> task:3<span class="hljs-builtin-name">add</span> task:4execute:<span class="hljs-attribute">name</span>=task4,addTime=1598006945022,servTime=591execute:<span class="hljs-attribute">name</span>=task3,addTime=1598006945022,servTime=974execute:<span class="hljs-attribute">name</span>=task2,addTime=1598006945022,servTime=52execute:<span class="hljs-attribute">name</span>=task1,addTime=1598006945022,servTime=281execute:<span class="hljs-attribute">name</span>=task0,addTime=1598006945022,servTime=609</code></pre><p>按0-4顺序加入task </p><p>执行时，按4-0，优先级高的先得到执行，而与服务时间，加入的时间无关 </p><h4 id="应用案例-1"><a href="#应用案例-1" class="headerlink" title="应用案例"></a>应用案例</h4><p>CPU资源调度 </p><p>云计算资源调度 </p><p>容器化Docker编排与调度 </p><h3 id="定时算法与应用"><a href="#定时算法与应用" class="headerlink" title="定时算法与应用"></a>定时算法与应用</h3><p>系统或者项目中难免会遇到各种需要自动去执行的任务，实现这些任务的手段也多种多样，如操作系统的crontab，spring框架的quartz，java的Timer和ScheduledThreadPool都是定时任务中的典型手段。 </p><h4 id="最小堆"><a href="#最小堆" class="headerlink" title="最小堆"></a>最小堆</h4><h5 id="概述-8"><a href="#概述-8" class="headerlink" title="概述"></a>概述</h5><p>Timer是java中最典型的基于优先级队列+最小堆实现的定时器，内部维护一个存放定时任务的优先级队列，该优先级队列使用了最小堆排序。当我们调用schedule方法的时候，一个新的任务被加入queue，堆重排，始终保持堆顶是执行时间最小（即最近马上要执行）的。同时，内部相当于起了一个线程不断扫描队列，从队列中依次获取堆顶元素执行，任务得到调度。 </p><p>下面以Timer为例，介绍优先级队列+最小堆算法的实现原理： </p><h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.schedule;<span class="hljs-keyword">import</span> java.util.Timer;<span class="hljs-keyword">import</span> java.util.TimerTask;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Task</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TimerTask</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"running..."</span>);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TimerDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Timer t = <span class="hljs-keyword">new</span> Timer();        <span class="hljs-comment">//在1秒后执行,以后每2秒跑一次 </span>        t.schedule(<span class="hljs-keyword">new</span> Task(), <span class="hljs-number">1000</span>, <span class="hljs-number">2000</span>);    &#125;&#125;</code></pre><h5 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h5><p>新加任务时，t.schedule方法会add到队列 </p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(TimerTask task)</span> </span>&#123;    <span class="hljs-comment">// Grow backing store if necessary</span>    <span class="hljs-keyword">if</span> (size + <span class="hljs-number">1</span> == queue.length)         queue = Arrays.copyOf(queue, <span class="hljs-number">2</span> * queue.length);    queue[++size] = task;    fixUp(size);&#125;</code></pre><p>add实现了容量维护，不足时扩容，同时将新任务追加到队列队尾，触发堆排序，始终保持堆顶元素最小</p><pre><code class="hljs java"><span class="hljs-comment">//最小堆排序</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fixUp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span> </span>&#123;    <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">1</span>) &#123;        <span class="hljs-comment">//k指针指向当前新加入的节点，也就是队列的末尾节点，j为其父节点 </span>        <span class="hljs-keyword">int</span> j = k &gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-comment">//如果新加入的执行时间比父节点晚，那不需要动</span>        <span class="hljs-keyword">if</span> (queue[j].nextExecutionTime &lt;= queue[k].nextExecutionTime)            <span class="hljs-keyword">break</span>;        <span class="hljs-comment">//如果大于其父节点，父子交换 </span>        TimerTask tmp = queue[j];        queue[j] = queue[k];        queue[k] = tmp;        <span class="hljs-comment">//交换后，当前指针继续指向新加入的节点，继续循环，知道堆重排合格 </span>        k = j;    &#125;&#125;</code></pre><p>线程调度中的run，主要调用内部mainLoop()方法，使用while循环</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mainLoop</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;        <span class="hljs-keyword">try</span> &#123;            TimerTask task;            <span class="hljs-keyword">boolean</span> taskFired;            <span class="hljs-keyword">synchronized</span> (queue) &#123;                <span class="hljs-comment">//... </span>                <span class="hljs-comment">// Queue nonempty; look at first evt and do the right thing long currentTime, </span>                executionTime;                task = queue.getMin();                <span class="hljs-keyword">synchronized</span> (task.lock) &#123;                    <span class="hljs-comment">//... </span>                    <span class="hljs-comment">// 当前时间 </span>                    currentTime = System.currentTimeMillis();                    <span class="hljs-comment">//要执行的时间 </span>                    executionTime = task.nextExecutionTime;                    <span class="hljs-comment">//判断是否到了执行时间</span>                    <span class="hljs-keyword">if</span> (taskFired = (executionTime &lt;= currentTime)) &#123;                        <span class="hljs-comment">//判断下一次执行时间，单次的执行完移除 </span>                        <span class="hljs-comment">// 循环的修改下次执行时间 </span>                        <span class="hljs-keyword">if</span> (task.period == <span class="hljs-number">0</span>) &#123;                            <span class="hljs-comment">// Non‐repeating, remove </span>                            queue.removeMin();                            task.state = TimerTask.EXECUTED;                        &#125; <span class="hljs-keyword">else</span> &#123;                            <span class="hljs-comment">// Repeating task, reschedule </span>                            <span class="hljs-comment">// 下次时间的计算有两种策略 </span>                            <span class="hljs-comment">// 1.period是负数,那下一次的执行时间就是当前时间‐period </span>                            <span class="hljs-comment">// 2.period是正数,那下一次就是该任务本次的执行时间+period </span>                            <span class="hljs-comment">// 注意！这两种策略大不相同。因为Timer是单线程的 </span>                            <span class="hljs-comment">// 如果是1，那么currentTime是当前时间，就受任务执行长短影响 </span>                            <span class="hljs-comment">// 如果是2，那么executionTime是绝对时间戳，与任务长短无关 </span>                            queue.rescheduleMin(task.period &lt; <span class="hljs-number">0</span> ? currentTime ‐ task.period :                            executionTime + task.period);                        &#125;                    &#125;                &#125;                <span class="hljs-comment">//不到执行时间，等待 </span>                <span class="hljs-keyword">if</span> (!taskFired)                    <span class="hljs-comment">// Task hasn't yet fired; wait </span>                    queue.wait(executionTime - currentTime);            &#125;            <span class="hljs-comment">//到达执行时间，run！</span>            <span class="hljs-keyword">if</span> (taskFired)                <span class="hljs-comment">// Task fired; run it, holding no locks </span>                task.run();        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;        &#125;    &#125;&#125;</code></pre><h5 id="应用-4"><a href="#应用-4" class="headerlink" title="应用"></a>应用</h5><p>本节使用Timer为了介绍算法原理，但是Timer已过时，实际应用中推荐使用ScheduledThreadPoolExecutor（同样内部使用DelayedWorkQueue和最小堆排序）</p><p>Timer是单线程，一旦一个失败或出现异常，将打断全部任务队列，线程池不会</p><p>Timer在jdk1.3+，而线程池需要jdk1.5+ </p><h4 id="时间轮"><a href="#时间轮" class="headerlink" title="时间轮"></a>时间轮</h4><h5 id="概述-9"><a href="#概述-9" class="headerlink" title="概述"></a>概述</h5><p>时间轮是一种更为常见的定时调度算法，各种操作系统的定时任务调度，linux crontab，基于java的通信框架Netty等。其灵感来源于我们生活中的时钟。 </p><p>轮盘实际上是一个头尾相接的环状数组，数组的个数即是插槽数，每个插槽中可以放置任务。 </p><p>以1天为例，将任务的执行时间%12，根据得到的数值，放置在时间轮上，小时指针沿着轮盘扫描，扫到的点取出任务执行： </p><img src="/blog/2020/08/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E4%B8%8E%E5%BA%94%E7%94%A8/pic5.png" srcset="/blog/img/loading.gif" class><p>同时在每个槽上设置一个队列，队列可以无限追加，解决时间点冲突问题（类似HashMap结构）</p><img src="/blog/2020/08/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E4%B8%8E%E5%BA%94%E7%94%A8/pic6.png" srcset="/blog/img/loading.gif" class><p>问题：每个轮盘的时间有限，比如1个月后的第3天的5点怎么办？ </p><p>方案一：加长时间刻度，扩充到1年 </p><p>优缺点：简单，占据大量内存，即使插槽没有任务也要空轮询，白白的资源浪费，时间、空间复杂度都高 </p><p>方案二：每个任务记录一个计数器，表示转多少圈后才会执行。没当指针过来后，计数器减1，减到0的再执行 </p><p>优缺点：每到一个指针都需要取出链表遍历判断，时间复杂度高，但是空间复杂度低</p><p>方案三：设置多个时间轮，年轮，月轮，天轮。1天内的放入天轮，1年后的则放入年轮，当年轮指针读到后，将任务取出，放入下一级的月轮对应的插槽，月轮再到天轮，直到最小精度取到，任务被执行。 </p><p>优缺点：不需要额外的遍历时间，但是占据了多个轮的空间。空间复杂度升高，但是时间复杂度降低 </p><h5 id="实现-11"><a href="#实现-11" class="headerlink" title="实现"></a>实现</h5><p>定义Task类</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.timer;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RoundTask</span> </span>&#123;    <span class="hljs-comment">//延迟多少秒后执行 </span>    <span class="hljs-keyword">int</span> delay;    <span class="hljs-comment">//加入的序列号，只是标记一下加入的顺序 </span>    <span class="hljs-keyword">int</span> index;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RoundTask</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> delay)</span> </span>&#123;        <span class="hljs-keyword">this</span>.index = index;        <span class="hljs-keyword">this</span>.delay = delay;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"task "</span> + index + <span class="hljs-string">" start , delay = "</span> + delay);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> String.valueOf(index + <span class="hljs-string">"="</span> + delay);    &#125;&#125;</code></pre><p>时间轮算法</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.timer;<span class="hljs-keyword">import</span> java.util.LinkedList;<span class="hljs-keyword">import</span> java.util.Random;<span class="hljs-keyword">import</span> java.util.concurrent.Executors;<span class="hljs-keyword">import</span> java.util.concurrent.ScheduledExecutorService;<span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RoundDemo</span> </span>&#123;    <span class="hljs-comment">//小轮槽数</span>    <span class="hljs-keyword">int</span> size1 = <span class="hljs-number">10</span>;    <span class="hljs-comment">//大轮槽数</span>    <span class="hljs-keyword">int</span> size2 = <span class="hljs-number">5</span>;    <span class="hljs-comment">//小轮，数组，每个元素是一个链表</span>    LinkedList&lt;RoundTask&gt;[] t1 = <span class="hljs-keyword">new</span> LinkedList[size1];    <span class="hljs-comment">//大轮</span>    LinkedList&lt;RoundTask&gt;[] t2 = <span class="hljs-keyword">new</span> LinkedList[size2];    <span class="hljs-comment">//小轮计数器，指针跳动的格数，每秒加1</span>    <span class="hljs-keyword">final</span> AtomicInteger flag1 = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);    <span class="hljs-comment">//大轮计数器，指针跳动个格数，即每10s加1</span>    <span class="hljs-keyword">final</span> AtomicInteger flag2 = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);    <span class="hljs-comment">//调度器，拖动指针跳动</span>    ScheduledExecutorService service = Executors.newScheduledThreadPool(<span class="hljs-number">2</span>);    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RoundDemo</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//初始化时间轮</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size1; i++) &#123;            t1[i] = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size2; i++) &#123;            t2[i] = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        &#125;    &#125;    <span class="hljs-comment">//打印时间轮的结构，数组+链表</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"t1:"</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; t1.length; i++) &#123;            System.out.println(t1[i]);        &#125;        System.out.println(<span class="hljs-string">"t2:"</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; t2.length; i++) &#123;            System.out.println(t2[i]);        &#125;    &#125;    <span class="hljs-comment">//添加任务到时间轮</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(RoundTask task)</span> </span>&#123;        <span class="hljs-keyword">int</span> delay = task.delay;        <span class="hljs-keyword">if</span> (delay &lt; size1) &#123; <span class="hljs-comment">//10以内的，在小轮 t1[delay].addLast(task);</span>        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//超过小轮的放入大轮，槽除以小轮的长度</span>            t2[delay / size1].addLast(task);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">startT1</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//每秒执行一次，推动时间轮旋转，取到任务立马执行</span>        service.scheduleAtFixedRate(<span class="hljs-keyword">new</span> Runnable() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-keyword">int</span> point = flag1.getAndIncrement() % size1;                System.out.println(<span class="hljs-string">"t1 ‐‐‐‐‐&gt; slot "</span> + point);                LinkedList&lt;RoundTask&gt; list = t1[point];                <span class="hljs-keyword">if</span> (!list.isEmpty()) &#123;                    <span class="hljs-comment">//如果当前槽内有任务，取出来，依次执行，执行完移除</span>                    <span class="hljs-keyword">while</span> (list.size() != <span class="hljs-number">0</span>) &#123;                        list.getFirst().run();                        list.removeFirst();                    &#125;                &#125;            &#125;        &#125;, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">startT2</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//每10秒执行一次，推动时间轮旋转，取到任务下方到t1</span>        service.scheduleAtFixedRate(<span class="hljs-keyword">new</span> Runnable() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-keyword">int</span> point = flag2.getAndIncrement() % size2;                System.out.println(<span class="hljs-string">"t2 =====&gt; slot "</span> + point);                LinkedList&lt;RoundTask&gt; list = t2[point];                <span class="hljs-keyword">if</span> (!list.isEmpty()) &#123;                    <span class="hljs-comment">//如果当前槽内有任务，取出，放到定义的小轮</span>                    <span class="hljs-keyword">while</span> (list.size() != <span class="hljs-number">0</span>) &#123;                        RoundTask task = list.getFirst();                        <span class="hljs-comment">//放入小轮哪个槽呢？小轮的槽按10取余数 </span>                        t1[task.delay % size1].addLast(task);                        <span class="hljs-comment">//从大轮中移除</span>                        list.removeFirst();                    &#125;                &#125;            &#125;        &#125;, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>, TimeUnit.SECONDS);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        RoundDemo roundDemo = <span class="hljs-keyword">new</span> RoundDemo();        <span class="hljs-comment">//生成100个任务，每个任务的延迟时间随机 </span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;            roundDemo.add(<span class="hljs-keyword">new</span> RoundTask(i, <span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">50</span>)));        &#125;        <span class="hljs-comment">//打印，查看时间轮任务布局 </span>        roundDemo.print();        <span class="hljs-comment">//启动大轮</span>        roundDemo.startT2();        <span class="hljs-comment">//小轮启动</span>        roundDemo.startT1();    &#125;&#125;</code></pre><h5 id="结果分析-11"><a href="#结果分析-11" class="headerlink" title="结果分析"></a>结果分析</h5><pre><code class="hljs routeros">Connected <span class="hljs-keyword">to</span> the target VM, address: <span class="hljs-string">'127.0.0.1:50971'</span>, transport: <span class="hljs-string">'socket'</span><span class="hljs-attribute">1598005699</span>=ok:&#123;<span class="hljs-attribute">1598005697</span>=0, <span class="hljs-attribute">1598005698</span>=0, <span class="hljs-attribute">1598005699</span>=1&#125;<span class="hljs-attribute">1598005699</span>=ok:&#123;<span class="hljs-attribute">1598005697</span>=0, <span class="hljs-attribute">1598005698</span>=0, <span class="hljs-attribute">1598005699</span>=2&#125;<span class="hljs-keyword">step</span>:1598005700:&#123;<span class="hljs-attribute">1598005698</span>=0, <span class="hljs-attribute">1598005699</span>=2, <span class="hljs-attribute">1598005700</span>=0&#125;<span class="hljs-attribute">1598005700</span>=ok:&#123;<span class="hljs-attribute">1598005698</span>=0, <span class="hljs-attribute">1598005699</span>=2, <span class="hljs-attribute">1598005700</span>=1&#125;<span class="hljs-attribute">1598005700</span>=ok:&#123;<span class="hljs-attribute">1598005698</span>=0, <span class="hljs-attribute">1598005699</span>=2, <span class="hljs-attribute">1598005700</span>=2&#125;<span class="hljs-attribute">1598005700</span>=ok:&#123;<span class="hljs-attribute">1598005698</span>=0, <span class="hljs-attribute">1598005699</span>=2, <span class="hljs-attribute">1598005700</span>=3&#125;<span class="hljs-keyword">step</span>:1598005701:&#123;<span class="hljs-attribute">1598005699</span>=2, <span class="hljs-attribute">1598005700</span>=3, <span class="hljs-attribute">1598005701</span>=0&#125;<span class="hljs-attribute">1598005701</span>=reject:&#123;<span class="hljs-attribute">1598005699</span>=2, <span class="hljs-attribute">1598005700</span>=3, <span class="hljs-attribute">1598005701</span>=0&#125;<span class="hljs-attribute">1598005701</span>=reject:&#123;<span class="hljs-attribute">1598005699</span>=2, <span class="hljs-attribute">1598005700</span>=3, <span class="hljs-attribute">1598005701</span>=0&#125;<span class="hljs-attribute">1598005701</span>=reject:&#123;<span class="hljs-attribute">1598005699</span>=2, <span class="hljs-attribute">1598005700</span>=3, <span class="hljs-attribute">1598005701</span>=0&#125;<span class="hljs-keyword">step</span>:1598005702:&#123;<span class="hljs-attribute">1598005700</span>=3, <span class="hljs-attribute">1598005701</span>=0, <span class="hljs-attribute">1598005702</span>=0&#125;<span class="hljs-attribute">1598005702</span>=ok:&#123;<span class="hljs-attribute">1598005700</span>=3, <span class="hljs-attribute">1598005701</span>=0, <span class="hljs-attribute">1598005702</span>=1&#125;<span class="hljs-attribute">1598005702</span>=ok:&#123;<span class="hljs-attribute">1598005700</span>=3, <span class="hljs-attribute">1598005701</span>=0, <span class="hljs-attribute">1598005702</span>=2&#125;<span class="hljs-keyword">step</span>:1598005703:&#123;<span class="hljs-attribute">1598005701</span>=0, <span class="hljs-attribute">1598005702</span>=2, <span class="hljs-attribute">1598005703</span>=0&#125;<span class="hljs-keyword">step</span>:1598005704:&#123;<span class="hljs-attribute">1598005702</span>=2, <span class="hljs-attribute">1598005703</span>=0, <span class="hljs-attribute">1598005704</span>=0&#125;<span class="hljs-keyword">step</span>:1598005705:&#123;<span class="hljs-attribute">1598005703</span>=0, <span class="hljs-attribute">1598005704</span>=0, <span class="hljs-attribute">1598005705</span>=0&#125;‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐<span class="hljs-attribute">1598005705</span>=ok:&#123;<span class="hljs-attribute">1598005703</span>=0, <span class="hljs-attribute">1598005704</span>=0, <span class="hljs-attribute">1598005705</span>=1&#125;<span class="hljs-attribute">1598005705</span>=ok:&#123;<span class="hljs-attribute">1598005703</span>=0, <span class="hljs-attribute">1598005704</span>=0, <span class="hljs-attribute">1598005705</span>=2&#125;<span class="hljs-attribute">1598005705</span>=ok:&#123;<span class="hljs-attribute">1598005703</span>=0, <span class="hljs-attribute">1598005704</span>=0, <span class="hljs-attribute">1598005705</span>=3&#125;<span class="hljs-attribute">1598005705</span>=ok:&#123;<span class="hljs-attribute">1598005703</span>=0, <span class="hljs-attribute">1598005704</span>=0, <span class="hljs-attribute">1598005705</span>=4&#125;<span class="hljs-attribute">1598005705</span>=ok:&#123;<span class="hljs-attribute">1598005703</span>=0, <span class="hljs-attribute">1598005704</span>=0, <span class="hljs-attribute">1598005705</span>=5&#125;<span class="hljs-attribute">1598005705</span>=reject:&#123;<span class="hljs-attribute">1598005703</span>=0, <span class="hljs-attribute">1598005704</span>=0, <span class="hljs-attribute">1598005705</span>=5&#125;<span class="hljs-attribute">1598005705</span>=reject:&#123;<span class="hljs-attribute">1598005703</span>=0, <span class="hljs-attribute">1598005704</span>=0, <span class="hljs-attribute">1598005705</span>=5&#125;<span class="hljs-attribute">1598005705</span>=reject:&#123;<span class="hljs-attribute">1598005703</span>=0, <span class="hljs-attribute">1598005704</span>=0, <span class="hljs-attribute">1598005705</span>=5&#125;<span class="hljs-attribute">1598005705</span>=reject:&#123;<span class="hljs-attribute">1598005703</span>=0, <span class="hljs-attribute">1598005704</span>=0, <span class="hljs-attribute">1598005705</span>=5&#125;<span class="hljs-attribute">1598005705</span>=reject:&#123;<span class="hljs-attribute">1598005703</span>=0, <span class="hljs-attribute">1598005704</span>=0, <span class="hljs-attribute">1598005705</span>=5&#125;<span class="hljs-keyword">step</span>:1598005709:&#123;<span class="hljs-attribute">1598005704</span>=0, <span class="hljs-attribute">1598005705</span>=5, <span class="hljs-attribute">1598005709</span>=0&#125;<span class="hljs-keyword">step</span>:1598005709:&#123;<span class="hljs-attribute">1598005705</span>=5, <span class="hljs-attribute">1598005709</span>=0&#125;<span class="hljs-keyword">step</span>:1598005709:&#123;<span class="hljs-attribute">1598005709</span>=0&#125;<span class="hljs-keyword">step</span>:1598005709:&#123;&#125;<span class="hljs-keyword">step</span>:1598005710:&#123;<span class="hljs-attribute">1598005710</span>=0&#125;<span class="hljs-keyword">step</span>:1598005711:&#123;<span class="hljs-attribute">1598005710</span>=0, <span class="hljs-attribute">1598005711</span>=0&#125;<span class="hljs-keyword">step</span>:1598005712:&#123;<span class="hljs-attribute">1598005710</span>=0, <span class="hljs-attribute">1598005711</span>=0, <span class="hljs-attribute">1598005712</span>=0&#125;</code></pre><p>输出结果严格按delay顺序执行，而不管index是何时被提交的 </p><p>t1为小轮，10个槽，每个1s，10s一轮回 </p><p>t2为大轮，5个槽，每个10s，50s一轮回 </p><p>t1循环到每个槽时，打印槽内的任务数据，如 t1–&gt;slot9 ， 打印了3个9s执行的数据 </p><p>t2循环到每个槽时，将槽内的任务delay时间取余10后，放入对应的t1槽中，如 t2==&gt;slot1 </p><p>那么t1旋转对应的圈数后，可以取到t2下放过来的任务并执行，如10,11…. </p><h3 id="负载均衡算法与应用"><a href="#负载均衡算法与应用" class="headerlink" title="负载均衡算法与应用"></a>负载均衡算法与应用</h3><p>负载均衡，英文名称为Load Balance，其含义就是指将负载（工作任务）进行平衡、分摊到多个操作单元上进行运行，例如FTP服务器、Web服务器、企业核心应用服务器和其它主要任务服务器等，从而协同完成工作任务。既然涉及到多个机器，就涉及到任务如何分发，这就是负载均衡算法问题。 </p><h4 id="轮询（RoundRobin）"><a href="#轮询（RoundRobin）" class="headerlink" title="轮询（RoundRobin）"></a>轮询（RoundRobin）</h4><h5 id="概述-10"><a href="#概述-10" class="headerlink" title="概述"></a>概述</h5><p>轮询即排好队，一个接一个。前面调度算法中用到的时间片轮转，就是一种典型的轮询。但是前面使用数组和下标轮询实现。这里尝试手动写一个双向链表形式实现服务器列表的请求轮询算法。 </p><h5 id="实现-12"><a href="#实现-12" class="headerlink" title="实现"></a>实现</h5><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.balance;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RR</span> </span>&#123;    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Server</span> </span>&#123;        Server prev;        Server next;        String name;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Server</span><span class="hljs-params">(String name)</span> </span>&#123;            <span class="hljs-keyword">this</span>.name = name;        &#125;    &#125;    <span class="hljs-comment">//当前服务节点</span>    Server current;    <span class="hljs-comment">//初始化轮询类，多个服务器ip用逗号隔开</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RR</span><span class="hljs-params">(String serverName)</span> </span>&#123;        System.out.println(<span class="hljs-string">"init server list : "</span> + serverName);        String[] names = serverName.split(<span class="hljs-string">","</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; names.length; i++) &#123;            Server server = <span class="hljs-keyword">new</span> Server(names[i]);            <span class="hljs-keyword">if</span> (current == <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-comment">//如果当前服务器为空，说明是第一台机器，current就指向新创建的server </span>                <span class="hljs-keyword">this</span>.current = server;                <span class="hljs-comment">//同时，server的前后均指向自己。 </span>                current.prev = current;                current.next = current;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">//否则说明已经有机器了，按新加处理。</span>                addServer(names[i]);            &#125;        &#125;    &#125;    <span class="hljs-comment">//添加机器</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addServer</span><span class="hljs-params">(String serverName)</span> </span>&#123;        System.out.println(<span class="hljs-string">"add server : "</span> + serverName);        Server server = <span class="hljs-keyword">new</span> Server(serverName);        Server next = <span class="hljs-keyword">this</span>.current.next;        <span class="hljs-comment">//在当前节点后插入新节点</span>        <span class="hljs-keyword">this</span>.current.next = server;        server.prev = <span class="hljs-keyword">this</span>.current;        <span class="hljs-comment">//修改下一节点的prev指针 </span>        server.next = next;        next.prev = server;    &#125;    <span class="hljs-comment">//将当前服务器移除，同时修改前后节点的指针，让其直接关联 </span>    <span class="hljs-comment">// 移除的current会被回收器回收掉</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"remove current = "</span> + current.name);        <span class="hljs-keyword">this</span>.current.prev.next = <span class="hljs-keyword">this</span>.current.next;        <span class="hljs-keyword">this</span>.current.next.prev = <span class="hljs-keyword">this</span>.current.prev;        <span class="hljs-keyword">this</span>.current = current.next;    &#125;    <span class="hljs-comment">//请求。由当前节点处理即可 </span>    <span class="hljs-comment">// 注意：处理完成后，current指针后移 </span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-keyword">this</span>.current.name);        <span class="hljs-keyword">this</span>.current = current.next;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-comment">//初始化两台机器</span>        RR rr = <span class="hljs-keyword">new</span> RR(<span class="hljs-string">"192.168.0.1,192.168.0.2"</span>);        <span class="hljs-comment">//启动一个额外线程，模拟不停的请求 </span>        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;                    <span class="hljs-keyword">try</span> &#123;                        Thread.sleep(<span class="hljs-number">500</span>);                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                    rr.request();                &#125;            &#125;        &#125;).start();        <span class="hljs-comment">//3s后，3号机器加入清单 </span>        Thread.currentThread().sleep(<span class="hljs-number">3000</span>);        rr.addServer(<span class="hljs-string">"192.168.0.3"</span>);        <span class="hljs-comment">//3s后，当前服务节点被移除 </span>        Thread.currentThread().sleep(<span class="hljs-number">3000</span>);        rr.remove();    &#125;&#125;</code></pre><h5 id="结果分析-12"><a href="#结果分析-12" class="headerlink" title="结果分析"></a>结果分析</h5><pre><code class="hljs accesslog">init server list : <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>,<span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">2</span>add server : <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">2</span><span class="hljs-number">192.168.0.1</span><span class="hljs-number">192.168.0.2</span><span class="hljs-number">192.168.0.1</span><span class="hljs-number">192.168.0.2</span><span class="hljs-number">192.168.0.1</span>add server : <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">3</span><span class="hljs-number">192.168.0.2</span><span class="hljs-number">192.168.0.3</span><span class="hljs-number">192.168.0.1</span><span class="hljs-number">192.168.0.2</span><span class="hljs-number">192.168.0.3</span><span class="hljs-number">192.168.0.1</span>remove current = <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">2</span><span class="hljs-number">192.168.0.3</span><span class="hljs-number">192.168.0.1</span></code></pre><ul><li><p>初始化后，只有1，2，两者轮询 </p></li><li><p>3加入后，1，2，3，三者轮询 </p></li><li><p>移除2后，只剩1和3轮询</p></li></ul><h5 id="优缺点-6"><a href="#优缺点-6" class="headerlink" title="优缺点"></a>优缺点</h5><ul><li><p>实现简单，机器列表可以自由加减，且时间复杂度为o(1) </p></li><li><p>无法针对节点做偏向性定制，节点处理能力的强弱无法区分对待</p></li></ul><h4 id="随机（Random）"><a href="#随机（Random）" class="headerlink" title="随机（Random）"></a>随机（Random）</h4><h5 id="概述-11"><a href="#概述-11" class="headerlink" title="概述"></a>概述</h5><p>从可服务的列表中随机取一个提供响应。随机存取的场景下，适合使用数组更高效的实现下标随机读取。 </p><h5 id="实现-13"><a href="#实现-13" class="headerlink" title="实现"></a>实现</h5><p>定义一个数组，在数组长度内取随机数，作为其下标即可。非常简单</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.balance;<span class="hljs-keyword">import</span> java.util.ArrayList;<span class="hljs-keyword">import</span> java.util.Random;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rand</span> </span>&#123;    ArrayList&lt;String&gt; ips;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Rand</span><span class="hljs-params">(String nodeNames)</span> </span>&#123;        System.out.println(<span class="hljs-string">"init list : "</span> + nodeNames);        String[] nodes = nodeNames.split(<span class="hljs-string">","</span>);        <span class="hljs-comment">//初始化服务器列表，长度取机器数</span>        ips = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(nodes.length);        <span class="hljs-keyword">for</span> (String node : nodes) &#123;            ips.add(node);        &#125;    &#125;    <span class="hljs-comment">//请求</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//下标，随机数，注意因子</span>        <span class="hljs-keyword">int</span> i = <span class="hljs-keyword">new</span> Random().nextInt(ips.size());        System.out.println(ips.get(i));    &#125;    <span class="hljs-comment">//添加节点，注意，添加节点会造成内部数组扩容</span>    <span class="hljs-comment">// 可以根据实际情况初始化时预留一定空间</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addnode</span><span class="hljs-params">(String nodeName)</span> </span>&#123;        System.out.println(<span class="hljs-string">"add node : "</span> + nodeName);        ips.add(nodeName);    &#125;    <span class="hljs-comment">//移除</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(String nodeName)</span> </span>&#123;        System.out.println(<span class="hljs-string">"remove node : "</span> + nodeName);        ips.remove(nodeName);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        Rand rd = <span class="hljs-keyword">new</span> Rand(<span class="hljs-string">"192.168.0.1,192.168.0.2"</span>);        <span class="hljs-comment">//启动一个额外线程，模拟不停的请求</span>        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;                    <span class="hljs-keyword">try</span> &#123;                        Thread.sleep(<span class="hljs-number">500</span>);                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                    rd.request();                &#125;            &#125;        &#125;).start();        <span class="hljs-comment">//3s后，3号机器加入清单</span>        Thread.currentThread().sleep(<span class="hljs-number">3000</span>);        rd.addnode(<span class="hljs-string">"192.168.0.3"</span>);        <span class="hljs-comment">//3s后，当前服务节点被移除</span>        Thread.currentThread().sleep(<span class="hljs-number">3000</span>);        rd.remove(<span class="hljs-string">"192.168.0.2"</span>);    &#125;&#125;</code></pre><h5 id="结果分析-13"><a href="#结果分析-13" class="headerlink" title="结果分析"></a>结果分析</h5><pre><code class="hljs accesslog">init list : <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>,<span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">2</span><span class="hljs-number">192.168.0.2</span><span class="hljs-number">192.168.0.1</span><span class="hljs-number">192.168.0.1</span><span class="hljs-number">192.168.0.2</span><span class="hljs-number">192.168.0.1</span>add node : <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">3</span><span class="hljs-number">192.168.0.3</span><span class="hljs-number">192.168.0.2</span><span class="hljs-number">192.168.0.2</span><span class="hljs-number">192.168.0.2</span><span class="hljs-number">192.168.0.1</span><span class="hljs-number">192.168.0.1</span>remove node : <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">2</span><span class="hljs-number">192.168.0.3</span><span class="hljs-number">192.168.0.3</span><span class="hljs-number">192.168.0.1</span><span class="hljs-number">192.168.0.1</span><span class="hljs-number">192.168.0.3</span></code></pre><ul><li><p>初始化为1，2，两者不按顺序轮询，而是随机出现 </p></li><li><p>3加入服务节点列表 </p></li><li><p>移除2后，只剩1，3，依然是两者随机，无序 </p></li></ul><h4 id="源地址哈希（Hash）"><a href="#源地址哈希（Hash）" class="headerlink" title="源地址哈希（Hash）"></a>源地址哈希（Hash）</h4><h5 id="概述-12"><a href="#概述-12" class="headerlink" title="概述"></a>概述</h5><p>对当前访问的ip地址做一个hash值，相同的key被路由到同一台机器去。场景常见于分布式集群环境下，用户登录时的请求路由和会话保持。 </p><h5 id="实现-14"><a href="#实现-14" class="headerlink" title="实现"></a>实现</h5><p>使用HashMap可以实现请求值到对应节点的服务，其查找时的时间复杂度为o(1)。固定一种算法，将请求映射到key上即可。举例，将请求的来源ip末尾，按机器数取余作为key：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.balance;<span class="hljs-keyword">import</span> java.util.ArrayList;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hash</span> </span>&#123;    ArrayList&lt;String&gt; ips;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Hash</span><span class="hljs-params">(String nodeNames)</span> </span>&#123;        System.out.println(<span class="hljs-string">"init list : "</span> + nodeNames);        String[] nodes = nodeNames.split(<span class="hljs-string">","</span>);        <span class="hljs-comment">//初始化服务器列表，长度取机器数</span>        ips = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(nodes.length);        <span class="hljs-keyword">for</span> (String node : nodes) &#123;            ips.add(node);        &#125;    &#125;    <span class="hljs-comment">//添加节点，注意，添加节点会造成内部Hash重排，思考为什么呢？？？ </span>    <span class="hljs-comment">// 这是个问题！在一致性hash中会进入详细探讨</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addnode</span><span class="hljs-params">(String nodeName)</span> </span>&#123;        System.out.println(<span class="hljs-string">"add node : "</span> + nodeName);        ips.add(nodeName);    &#125;    <span class="hljs-comment">//移除</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(String nodeName)</span> </span>&#123;        System.out.println(<span class="hljs-string">"remove node : "</span> + nodeName);        ips.remove(nodeName);    &#125;    <span class="hljs-comment">//映射到key的算法，这里取余数做下标 </span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(String ip)</span> </span>&#123;        <span class="hljs-keyword">int</span> last = Integer.valueOf(ip.substring(ip.lastIndexOf(<span class="hljs-string">"."</span>) + <span class="hljs-number">1</span>, ip.length()));        <span class="hljs-keyword">return</span> last % ips.size();    &#125;    <span class="hljs-comment">//请求 </span>    <span class="hljs-comment">// 注意，这里和来访ip是有关系的，采用一个参数，表示当前的来访ip </span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">(String ip)</span> </span>&#123;        <span class="hljs-comment">//下标</span>        <span class="hljs-keyword">int</span> i = hash(ip);        System.out.println(ip + <span class="hljs-string">"‐‐&gt;"</span> + ips.get(i));    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Hash hash = <span class="hljs-keyword">new</span> Hash(<span class="hljs-string">"192.168.0.1,192.168.0.2"</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            <span class="hljs-comment">//模拟请求的来源ip</span>            String ip = <span class="hljs-string">"192.168.1."</span> + i;            hash.request(ip);        &#125;        hash.addnode(<span class="hljs-string">"192.168.0.3"</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            <span class="hljs-comment">//模拟请求的来源ip </span>            String ip = <span class="hljs-string">"192.168.1."</span> + i;            hash.request(ip);        &#125;    &#125;&#125;</code></pre><h5 id="结果分析-14"><a href="#结果分析-14" class="headerlink" title="结果分析"></a>结果分析</h5><pre><code class="hljs angelscript">init list : <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>,<span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.2</span><span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span>‐‐&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.2</span><span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.2</span>‐‐&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.3</span>‐‐&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.2</span><span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.4</span>‐‐&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.5</span>‐‐&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.2</span><span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.6</span>‐‐&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.7</span>‐‐&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.2</span><span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.8</span>‐‐&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.9</span>‐‐&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.2</span>add node : <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.3</span><span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span>‐‐&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.2</span><span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.2</span>‐‐&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.3</span><span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.3</span>‐‐&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.4</span>‐‐&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.2</span><span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.5</span>‐‐&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.3</span><span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.6</span>‐‐&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.7</span>‐‐&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.2</span><span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.8</span>‐‐&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.3</span><span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.9</span>‐‐&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span></code></pre><ul><li><p>初始化后，只有1，2，下标为末尾ip取余数，多次运行，响应的机器不变，实现了会话保持 </p></li><li><p>3加入后，重新hash，机器分布发生变化 </p></li><li><p>2被移除后，原来hash到2的请求被重新定位给3响应 </p></li></ul><h4 id="加权轮询（WRR）"><a href="#加权轮询（WRR）" class="headerlink" title="加权轮询（WRR）"></a>加权轮询（WRR）</h4><h5 id="概述-13"><a href="#概述-13" class="headerlink" title="概述"></a>概述</h5><p>WeightRoundRobin，轮询只是机械的旋转，加权轮询弥补了所有机器一视同仁的缺点。在轮询的基础上，初始化时，机器携带一个比重。 </p><h5 id="实现-15"><a href="#实现-15" class="headerlink" title="实现"></a>实现</h5><p>维护一个链表，每个机器根据权重不同，占据的个数不同。轮询时权重大的，个数多，自然取到的次数变大。举个例子：a，b，c 三台机器，权重分别为4，2，1，排位后会是a,a,a,a,b,b,c，每次请求时，从列表中依次取节点，下次请求再取下一个。到末尾时，再从头开始。 </p><p>但是这样有一个问题：机器分布不够均匀，扎堆出现了…. </p><p>解决：为解决机器平滑出现的问题，nginx的源码中使用了一种平滑的加权轮询的算法，规则如下：</p><ul><li><p>每个节点两个权重，weight和currentWeight，weight永远不变是配置时的值，current不停变化</p></li><li><p>变化规律如下：选择前所有current+=weight，选current最大的响应，响应后让它的current-=total</p></li></ul><table><thead><tr><th>次数</th><th>响应前</th><th>被选中</th><th>响应后</th></tr></thead><tbody><tr><td>1</td><td>4，2，1</td><td>a</td><td>-3，2，1</td></tr><tr><td>2</td><td>1，4，2</td><td>b</td><td>1，-3，2</td></tr><tr><td>3</td><td>5，-1，3</td><td>a</td><td>-2，-1，3</td></tr><tr><td>4</td><td>2，1，4</td><td>c</td><td>2，1，-3</td></tr><tr><td>5</td><td>6，3，-2</td><td>a</td><td>-1，3，-2</td></tr><tr><td>6</td><td>3，5，-1</td><td>b</td><td>3，-2，-1</td></tr><tr><td>7</td><td>7，0，0</td><td>a</td><td>0，0，0</td></tr></tbody></table><p>统计：a=4，b=2，c=1 且分布平滑均衡</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.balance;<span class="hljs-keyword">import</span> java.util.ArrayList;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WRR</span> </span>&#123;    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;        <span class="hljs-keyword">int</span> weight, currentWeight;        String name;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> weight)</span> </span>&#123;            <span class="hljs-keyword">this</span>.name = name;            <span class="hljs-keyword">this</span>.weight = weight;            <span class="hljs-keyword">this</span>.currentWeight = <span class="hljs-number">0</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> String.valueOf(currentWeight);        &#125;    &#125;    <span class="hljs-comment">//所有节点的列表</span>    ArrayList&lt;Node&gt; list;    <span class="hljs-comment">//总权重</span>    <span class="hljs-keyword">int</span> total;    <span class="hljs-comment">//初始化节点列表，格式：a#4,b#2,c#1</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WRR</span><span class="hljs-params">(String nodes)</span> </span>&#123;        String[] ns = nodes.split(<span class="hljs-string">","</span>);        list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(ns.length);        <span class="hljs-keyword">for</span> (String n : ns) &#123;            String[] n1 = n.split(<span class="hljs-string">"#"</span>);            <span class="hljs-keyword">int</span> weight = Integer.valueOf(n1[<span class="hljs-number">1</span>]);            list.add(<span class="hljs-keyword">new</span> Node(n1[<span class="hljs-number">0</span>], weight));            total += weight;        &#125;    &#125;    <span class="hljs-comment">//获取当前节点</span>    <span class="hljs-function">Node <span class="hljs-title">getCurrent</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//执行前，current加权重 </span>        <span class="hljs-keyword">for</span> (Node node : list) &#123;            node.currentWeight += node.weight;        &#125;        <span class="hljs-comment">//遍历，取权重最高的返回</span>        Node current = list.get(<span class="hljs-number">0</span>);        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (Node node : list) &#123;            <span class="hljs-keyword">if</span> (node.currentWeight &gt; i) &#123;                i = node.currentWeight;                current = node;            &#125;        &#125;        <span class="hljs-keyword">return</span> current;    &#125;    <span class="hljs-comment">//响应 </span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//获取当前节点 </span>        Node node = <span class="hljs-keyword">this</span>.getCurrent();        <span class="hljs-comment">//第一列，执行前的current</span>        System.out.print(list.toString() + <span class="hljs-string">"‐‐‐"</span>);        <span class="hljs-comment">//第二列，选中的节点开始响应</span>        System.out.print(node.name + <span class="hljs-string">"‐‐‐"</span>);        <span class="hljs-comment">//响应后，current减掉total</span>        node.currentWeight -= total;        <span class="hljs-comment">//第三列，执行后的current</span>        System.out.println(list);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        WRR wrr = <span class="hljs-keyword">new</span> WRR(<span class="hljs-string">"a#4,b#2,c#1"</span>);        <span class="hljs-comment">//7次执行请求，看结果</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">7</span>; i++) &#123;            wrr.request();        &#125;    &#125;&#125;</code></pre><h5 id="结果分析-15"><a href="#结果分析-15" class="headerlink" title="结果分析"></a>结果分析</h5><pre><code class="hljs java">[<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]‐‐‐a‐‐‐[-<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>][<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>]‐‐‐b‐‐‐[<span class="hljs-number">1</span>, -<span class="hljs-number">3</span>, <span class="hljs-number">2</span>][<span class="hljs-number">5</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">3</span>]‐‐‐a‐‐‐[-<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">3</span>][<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>]‐‐‐c‐‐‐[<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">3</span>][<span class="hljs-number">6</span>, <span class="hljs-number">3</span>, -<span class="hljs-number">2</span>]‐‐‐a‐‐‐[-<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, -<span class="hljs-number">2</span>][<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, -<span class="hljs-number">1</span>]‐‐‐b‐‐‐[<span class="hljs-number">3</span>, -<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>][<span class="hljs-number">7</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]‐‐‐a‐‐‐[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]</code></pre><h4 id="加权随机（WR）"><a href="#加权随机（WR）" class="headerlink" title="加权随机（WR）"></a>加权随机（WR）</h4><h5 id="概述-14"><a href="#概述-14" class="headerlink" title="概述"></a>概述</h5><p>WeightRandom，机器随机被筛选，但是做一组加权值，根据权值不同，选中的概率不同。在这个概念上，可以认为随机是一种等权值的特殊情况。</p><h5 id="实现-16"><a href="#实现-16" class="headerlink" title="实现"></a>实现</h5><p>设计思路依然相同，根据权值大小，生成不同数量的节点，节点排队后，随机获取。这里的数据结构主要涉及到随机的读取，所以优选为数组。 </p><p>与随机相同的是，同样为数组随机筛选，不同在于，随机只是每台机器1个，加权后变为多个。</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.balance;<span class="hljs-keyword">import</span> java.util.ArrayList;<span class="hljs-keyword">import</span> java.util.Random;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WR</span> </span>&#123;    <span class="hljs-comment">//所有节点的列表 </span>    ArrayList&lt;String&gt; list;    <span class="hljs-comment">//初始化节点列表</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WR</span><span class="hljs-params">(String nodes)</span> </span>&#123;        String[] ns = nodes.split(<span class="hljs-string">","</span>);        list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">for</span> (String n : ns) &#123;            String[] n1 = n.split(<span class="hljs-string">"#"</span>);            <span class="hljs-keyword">int</span> weight = Integer.valueOf(n1[<span class="hljs-number">1</span>]);            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; weight; i++) &#123;                list.add(n1[<span class="hljs-number">0</span>]);            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//下标，随机数，注意因子</span>        <span class="hljs-keyword">int</span> i = <span class="hljs-keyword">new</span> Random().nextInt(list.size());        System.out.println(list.get(i));    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        WR wr = <span class="hljs-keyword">new</span> WR(<span class="hljs-string">"a#2,b#1"</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;            wr.request();        &#125;    &#125;&#125;</code></pre><h5 id="结果分析-16"><a href="#结果分析-16" class="headerlink" title="结果分析"></a>结果分析</h5><pre><code class="hljs stylus">aabaaabaa</code></pre><ul><li><p>运行9次，a，b交替出现，a=6,b=3,满足2:1比例</p></li><li><p>注意！既然是随机，就存在随机性，不见得每次执行都会严格比例。样本趋向无穷时，比例约准确</p></li></ul><h4 id="最小连接数（LC）"><a href="#最小连接数（LC）" class="headerlink" title="最小连接数（LC）"></a>最小连接数（LC）</h4><h5 id="概述-15"><a href="#概述-15" class="headerlink" title="概述"></a>概述</h5><p>LeastConnections，即统计当前机器的连接数，选最少的去响应新的请求。前面的算法是站在请求维度，而最小连接数是站在机器的维度。</p><h5 id="实现-17"><a href="#实现-17" class="headerlink" title="实现"></a>实现</h5><p>定义一个链接表记录机器的节点id和机器连接数量的计数器。内部采用最小堆做排序处理，响应时取堆顶节点即是最小连接数。</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.balance;<span class="hljs-keyword">import</span> java.util.Arrays;<span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LC</span> </span>&#123;    <span class="hljs-comment">//节点列表</span>    Node[] nodes;    <span class="hljs-comment">//初始化节点，创建堆 </span>    <span class="hljs-comment">// 因为开始时各节点连接数都为0，所以直接填充数组即可</span>    LC(String ns) &#123;        String[] ns1 = ns.split(<span class="hljs-string">","</span>);        nodes = <span class="hljs-keyword">new</span> Node[ns1.length + <span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ns1.length; i++) &#123;            nodes[i + <span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> Node(ns1[i]);        &#125;    &#125;    <span class="hljs-comment">//节点下沉，与左右子节点比对，选里面最小的交换 </span>    <span class="hljs-comment">// 目的是始终保持最小堆的顶点元素值最小 </span>    <span class="hljs-comment">// i:要下沉的顶点序号 </span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;        <span class="hljs-comment">//顶点序号遍历，只要到1半即可，时间复杂度为O(log2n) </span>        <span class="hljs-keyword">while</span> (i &lt;&lt; <span class="hljs-number">1</span> &lt; nodes.length) &#123;            <span class="hljs-comment">//左子，为何左移1位？回顾一下二叉树序号 </span>            <span class="hljs-keyword">int</span> left = i &lt;&lt; <span class="hljs-number">1</span>;            <span class="hljs-comment">//右子，左+1即可 </span>            <span class="hljs-keyword">int</span> right = left + <span class="hljs-number">1</span>;            <span class="hljs-comment">//标记，指向 本节点，左、右子节点里最小的，一开始取i自己 </span>            <span class="hljs-keyword">int</span> flag = i;            <span class="hljs-comment">//判断左子是否小于本节点</span>            <span class="hljs-keyword">if</span> (nodes[left].get() &lt; nodes[i].get()) &#123;                flag = left;            &#125;            <span class="hljs-comment">//判断右子</span>            <span class="hljs-keyword">if</span> (right &lt; nodes.length &amp;&amp; nodes[flag].get() &gt; nodes[right].get()) &#123;                flag = right;            &#125;            <span class="hljs-comment">//两者中最小的与本节点不相等，则交换</span>            <span class="hljs-keyword">if</span> (flag != i) &#123;                Node temp = nodes[i];                nodes[i] = nodes[flag];                nodes[flag] = temp;                i = flag;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">//否则相等，堆排序完成，退出循环即可</span>                <span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;    <span class="hljs-comment">//请求。非常简单，直接取最小堆的堆顶元素就是连接数最少的机器</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐"</span>);        <span class="hljs-comment">//取堆顶元素响应请求</span>        Node node = nodes[<span class="hljs-number">1</span>];        System.out.println(node.name + <span class="hljs-string">" accept"</span>);        <span class="hljs-comment">//连接数加1</span>        node.inc();        <span class="hljs-comment">//排序前的堆 </span>        System.out.println(<span class="hljs-string">"before:"</span> + Arrays.toString(nodes));        <span class="hljs-comment">//堆顶下沉</span>        down(<span class="hljs-number">1</span>);        <span class="hljs-comment">//排序后的堆 </span>        System.out.println(<span class="hljs-string">"after:"</span> + Arrays.toString(nodes));    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//假设有7台机器</span>        LC lc = <span class="hljs-keyword">new</span> LC(<span class="hljs-string">"a,b,c,d,e,f,g"</span>);        <span class="hljs-comment">//模拟10个请求连接</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            lc.request();        &#125;    &#125;    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;        <span class="hljs-comment">//节点标识</span>        String name;        <span class="hljs-comment">// 计数器 </span>        AtomicInteger count = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(String name)</span> </span>&#123;            <span class="hljs-keyword">this</span>.name = name;        &#125;        <span class="hljs-comment">//计数器增加 </span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inc</span><span class="hljs-params">()</span> </span>&#123;            count.getAndIncrement();        &#125;        <span class="hljs-comment">//获取连接数 </span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> count.get();        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> name + <span class="hljs-string">"="</span> + count;        &#125;    &#125;&#125;</code></pre><h5 id="结果分析-17"><a href="#结果分析-17" class="headerlink" title="结果分析"></a>结果分析</h5><pre><code class="hljs routeros">‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐a acceptbefore:[<span class="hljs-literal">null</span>, <span class="hljs-attribute">a</span>=1, <span class="hljs-attribute">b</span>=0, <span class="hljs-attribute">c</span>=0, <span class="hljs-attribute">d</span>=0, <span class="hljs-attribute">e</span>=0, <span class="hljs-attribute">f</span>=0, <span class="hljs-attribute">g</span>=0]after:[<span class="hljs-literal">null</span>, <span class="hljs-attribute">b</span>=0, <span class="hljs-attribute">d</span>=0, <span class="hljs-attribute">c</span>=0, <span class="hljs-attribute">a</span>=1, <span class="hljs-attribute">e</span>=0, <span class="hljs-attribute">f</span>=0, <span class="hljs-attribute">g</span>=0]‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐b acceptbefore:[<span class="hljs-literal">null</span>, <span class="hljs-attribute">b</span>=1, <span class="hljs-attribute">d</span>=0, <span class="hljs-attribute">c</span>=0, <span class="hljs-attribute">a</span>=1, <span class="hljs-attribute">e</span>=0, <span class="hljs-attribute">f</span>=0, <span class="hljs-attribute">g</span>=0]after:[<span class="hljs-literal">null</span>, <span class="hljs-attribute">d</span>=0, <span class="hljs-attribute">e</span>=0, <span class="hljs-attribute">c</span>=0, <span class="hljs-attribute">a</span>=1, <span class="hljs-attribute">b</span>=1, <span class="hljs-attribute">f</span>=0, <span class="hljs-attribute">g</span>=0]‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐d acceptbefore:[<span class="hljs-literal">null</span>, <span class="hljs-attribute">d</span>=1, <span class="hljs-attribute">e</span>=0, <span class="hljs-attribute">c</span>=0, <span class="hljs-attribute">a</span>=1, <span class="hljs-attribute">b</span>=1, <span class="hljs-attribute">f</span>=0, <span class="hljs-attribute">g</span>=0]after:[<span class="hljs-literal">null</span>, <span class="hljs-attribute">e</span>=0, <span class="hljs-attribute">d</span>=1, <span class="hljs-attribute">c</span>=0, <span class="hljs-attribute">a</span>=1, <span class="hljs-attribute">b</span>=1, <span class="hljs-attribute">f</span>=0, <span class="hljs-attribute">g</span>=0]‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐e acceptbefore:[<span class="hljs-literal">null</span>, <span class="hljs-attribute">e</span>=1, <span class="hljs-attribute">d</span>=1, <span class="hljs-attribute">c</span>=0, <span class="hljs-attribute">a</span>=1, <span class="hljs-attribute">b</span>=1, <span class="hljs-attribute">f</span>=0, <span class="hljs-attribute">g</span>=0]after:[<span class="hljs-literal">null</span>, <span class="hljs-attribute">c</span>=0, <span class="hljs-attribute">d</span>=1, <span class="hljs-attribute">f</span>=0, <span class="hljs-attribute">a</span>=1, <span class="hljs-attribute">b</span>=1, <span class="hljs-attribute">e</span>=1, <span class="hljs-attribute">g</span>=0]‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐</code></pre><ul><li><p>初始化后，堆节点值都为0，即每个机器连接数都为0 </p></li><li><p>堆顶连接后，下沉，堆重新排序，最小堆规则保持成立 </p></li></ul><h4 id="应用案例-2"><a href="#应用案例-2" class="headerlink" title="应用案例"></a>应用案例</h4><h5 id="nginx-upstream"><a href="#nginx-upstream" class="headerlink" title="nginx upstream"></a>nginx upstream</h5><pre><code class="hljs yaml"><span class="hljs-string">upstream</span> <span class="hljs-string">frontend</span> <span class="hljs-string">&#123;</span> <span class="hljs-comment">#源地址hash </span><span class="hljs-string">ip_hash;</span>  <span class="hljs-string">server</span> <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:8081;</span>   <span class="hljs-string">server</span> <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.2</span><span class="hljs-string">:8082</span> <span class="hljs-string">weight=1</span> <span class="hljs-string">down;</span>   <span class="hljs-string">server</span> <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.3</span><span class="hljs-string">:8083</span> <span class="hljs-string">weight=2;</span>   <span class="hljs-string">server</span> <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.4</span><span class="hljs-string">:8084</span> <span class="hljs-string">weight=3</span> <span class="hljs-string">backup;</span>  <span class="hljs-string">server</span> <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.5</span><span class="hljs-string">:8085</span> <span class="hljs-string">weight=4</span> <span class="hljs-string">max_fails=3</span> <span class="hljs-string">fail_timeout=30s;</span> <span class="hljs-string">&#125;</span></code></pre><ul><li><p>ip_hash：即源地址hash算法 </p></li><li><p>down：表示当前的server暂时不参与负载 </p></li><li><p>weight：即加权算法，默认为1，weight越大，负载的权重就越大。 </p></li><li><p>backup：备份机器，只有其它所有的非backup机器down或者忙的时候，再请求backup机器。 </p></li><li><p>max_fails：最大失败次数，默认值为1，这里为3，也就是最多进行3次尝试 </p></li><li><p>fail_timeout：超时时间为30秒，默认值是10s。 </p></li></ul><p>注意！weight和backup不能和ip_hash关键字一起使用。 </p><h5 id="springcloud-ribbon-IRule"><a href="#springcloud-ribbon-IRule" class="headerlink" title="springcloud ribbon IRule"></a>springcloud ribbon IRule</h5><pre><code class="hljs routeros"><span class="hljs-comment">#设置负载均衡策略 eureka‐application‐service为调用的服务的名称 </span>eureka‐application‐ service.ribbon.<span class="hljs-attribute">NFLoadBalancerRuleClassName</span>=com.netflix.loadbalancer.RandomRule</code></pre><ul><li><p>RoundRobinRule：轮询 </p></li><li><p>RandomRule：随机 </p></li><li><p>AvailabilityFilteringRule：先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，还有并发的连接数量超过阈值的服务，然后对剩余的服务轮询 </p></li><li><p>WeightedResponseTimeRule：根据平均响应时间计算所有服务的权重，响应时间越快服务权重越大。刚启动时如果统计信息不足，则使用RoundRobinRule策略，等统计信息足够，会切换到该策略 </p></li><li><p>RetryRule：先按照RoundRobinRule的策略，如果获取服务失败则在指定时间内重试，获取可用的服务 </p></li><li><p>BestAvailableRule：会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择一个并发量最小的服务 </p></li><li><p>ZoneAvoidanceRule：默认规则，综合判断server所在区域的性能和server的可用性 </p></li></ul><h5 id="dubbo负载均衡"><a href="#dubbo负载均衡" class="headerlink" title="dubbo负载均衡"></a>dubbo负载均衡</h5><p>使用Service注解 </p><p><code>@Service(loadbalance = &quot;roundrobin&quot;,weight = 100)</code></p><ul><li><p>RandomLoadBalance: 随机，这种方式是dubbo默认的负载均衡策略 </p></li><li><p>RoundRobinLoadBalance：轮询 </p></li><li><p>LeastActiveLoadBalance：最少活跃次数，dubbo框架自定义了一个Filter，用于计算服务被调用的次数 </p></li><li><p>ConsistentHashLoadBalance：一致性hash </p></li></ul><h3 id="加密算法与应用"><a href="#加密算法与应用" class="headerlink" title="加密算法与应用"></a>加密算法与应用</h3><h4 id="散列"><a href="#散列" class="headerlink" title="散列"></a>散列</h4><h5 id="概述-16"><a href="#概述-16" class="headerlink" title="概述"></a>概述</h5><p>严格来讲这不算是一种加密，而应该叫做信息摘要算法。该算法使用散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。通过数据打乱混合，重新创建一个叫做散列值 </p><h5 id="常见算法"><a href="#常见算法" class="headerlink" title="常见算法"></a>常见算法</h5><p>MD5、SHA（128、256）系列</p><table><thead><tr><th>名称</th><th>安全性</th><th>速度</th></tr></thead><tbody><tr><td>SHA-1</td><td>高</td><td>🈵️</td></tr><tr><td>MD5</td><td>中</td><td>快</td></tr></tbody></table><h5 id="应用-5"><a href="#应用-5" class="headerlink" title="应用"></a>应用</h5><p>常用于密码存储，或文件指纹校验。</p><p>网站用户注册后，密码经过MD5加密后的值，存储进DB。再次登录时，将用户输入的密码按同样的方式加密，与数据库中的密文比对。这样即使数据库被破解，或者开发人员可见，基于MD5的不可逆性，仍然不知道密码是什么。</p><p>其次是文件校验场景。例如从某站下载的文件（尤其是大文件，比如系统镜像iso），官方网站都会放置一个签名（可能是MD5，或者SHA），当用户拿到文件后，可以本地执行散列算法与官网签名比对是否一致，来判断文件是否被篡改。如ubuntu20.04的镜像： </p><img src="/blog/2020/08/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E4%B8%8E%E5%BA%94%E7%94%A8/pic7.png" srcset="/blog/img/loading.gif" class><h5 id="实现-18"><a href="#实现-18" class="headerlink" title="实现"></a>实现</h5><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.pwd;<span class="hljs-keyword">import</span> org.apache.commons.codec.digest.DigestUtils;<span class="hljs-keyword">import</span> java.math.BigInteger;<span class="hljs-keyword">import</span> java.security.MessageDigest;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hash</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * jdk的security实现md5</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">md5</span><span class="hljs-params">(String src)</span> </span>&#123;        <span class="hljs-keyword">byte</span>[] pwd = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            pwd = MessageDigest.getInstance(<span class="hljs-string">"md5"</span>).digest(src.getBytes(<span class="hljs-string">"utf‐8"</span>));        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;        String code = <span class="hljs-keyword">new</span> BigInteger(<span class="hljs-number">1</span>, pwd).toString(<span class="hljs-number">16</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span> - code.length();             i++) &#123;            code = <span class="hljs-string">"0"</span> + code;        &#125;        <span class="hljs-keyword">return</span> code;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">commonsMd5</span><span class="hljs-params">(String src)</span> </span>&#123;        <span class="hljs-keyword">return</span> DigestUtils.md5Hex(src);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * jdk实现sha算法</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">sha</span><span class="hljs-params">(String src)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        MessageDigest sha = MessageDigest.getInstance(<span class="hljs-string">"sha"</span>);        <span class="hljs-keyword">byte</span>[] shaByte = sha.digest(src.getBytes(<span class="hljs-string">"utf‐8"</span>));        StringBuffer code = <span class="hljs-keyword">new</span> StringBuffer();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; shaByte.length; i++) &#123;            <span class="hljs-keyword">int</span> val = ((<span class="hljs-keyword">int</span>) shaByte[i]) &amp; <span class="hljs-number">0xff</span>;            <span class="hljs-keyword">if</span> (val &lt; <span class="hljs-number">16</span>) &#123;                code.append(<span class="hljs-string">"0"</span>);            &#125;            code.append(Integer.toHexString(val));        &#125;        <span class="hljs-keyword">return</span> code.toString();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">commonsSha</span><span class="hljs-params">(String src)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">return</span> DigestUtils.sha1Hex(src);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        String name = <span class="hljs-string">"架构师训练营"</span>;        System.out.println(name);        System.out.println(md5(name));        System.out.println(commonsMd5(name));        System.out.println(sha(name));        System.out.println(commonsSha(name));    &#125;&#125;</code></pre><h5 id="结果分析-18"><a href="#结果分析-18" class="headerlink" title="结果分析"></a>结果分析</h5><pre><code class="hljs llvm">架构师训练营d<span class="hljs-number">98</span><span class="hljs-keyword">c</span><span class="hljs-number">9e606978909</span>dd<span class="hljs-number">8</span>cbeda<span class="hljs-number">3409</span>b<span class="hljs-number">38</span>bad<span class="hljs-number">98</span><span class="hljs-keyword">c</span><span class="hljs-number">9e606978909</span>dd<span class="hljs-number">8</span>cbeda<span class="hljs-number">3409</span>b<span class="hljs-number">38</span>baa<span class="hljs-number">74474</span>a<span class="hljs-number">705</span>b<span class="hljs-number">01</span>a<span class="hljs-number">8</span>ed<span class="hljs-number">1</span>bfae<span class="hljs-number">76</span>f<span class="hljs-number">4</span>b<span class="hljs-number">8</span><span class="hljs-keyword">c</span><span class="hljs-number">36518341959</span>a<span class="hljs-number">74474</span>a<span class="hljs-number">705</span>b<span class="hljs-number">01</span>a<span class="hljs-number">8</span>ed<span class="hljs-number">1</span>bfae<span class="hljs-number">76</span>f<span class="hljs-number">4</span>b<span class="hljs-number">8</span><span class="hljs-keyword">c</span><span class="hljs-number">36518341959</span></code></pre><ul><li><p>jdk与commons均生成了相同的散列值 </p></li><li><p>多次运行，依然生成固定值 </p></li><li><p>commons-codec还有很多可用方法，如：sha256，sha512… </p></li></ul><h4 id="对称"><a href="#对称" class="headerlink" title="对称"></a>对称</h4><h5 id="概述-17"><a href="#概述-17" class="headerlink" title="概述"></a>概述</h5><p>加密与解密用的都是同一个秘钥，性能比非对称加密高很多。 </p><h5 id="常见算法-1"><a href="#常见算法-1" class="headerlink" title="常见算法"></a>常见算法</h5><p>常见的对称加密算法有 DES、3DES、AES </p><p>DES算法在POS、ATM、磁卡及智能卡（IC卡）、加油站、高速公路收费站等领域被广泛应用，以此来实现关键数据的保密，如信用卡持卡人的PIN的加密传输，IC卡与POS间的双向认证、金融交易数据包的MAC校验等</p><p>3DES是DES加密算法的一种模式，是DES的一个更安全的变形。从DES向AES的过渡算法</p><p>AES，是下一代的加密算法标准，速度快，安全级别更高。 </p><table><thead><tr><th>名称</th><th>密钥名称</th><th>运行速度</th><th>安全性</th><th>资源消耗</th></tr></thead><tbody><tr><td>DES</td><td>56位</td><td>较快</td><td>低</td><td>中</td></tr><tr><td>3DES</td><td>112位或168位</td><td>慢</td><td>中</td><td>高</td></tr><tr><td>AES</td><td>128、192、256位</td><td>快</td><td>高</td><td>低</td></tr></tbody></table><h5 id="应用-6"><a href="#应用-6" class="headerlink" title="应用"></a>应用</h5><p>常用于对效率要求较高的实时数据加密通信。 </p><h5 id="实现-19"><a href="#实现-19" class="headerlink" title="实现"></a>实现</h5><p>以AES为例： </p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.pwd;<span class="hljs-keyword">import</span> org.apache.commons.codec.binary.Base64;<span class="hljs-keyword">import</span> javax.crypto.Cipher;<span class="hljs-keyword">import</span> javax.crypto.KeyGenerator;<span class="hljs-keyword">import</span> javax.crypto.spec.SecretKeySpec;<span class="hljs-keyword">import</span> java.security.Key;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AES</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//生成KEY </span>        KeyGenerator keyGenerator = KeyGenerator.getInstance(<span class="hljs-string">"AES"</span>);        keyGenerator.init(<span class="hljs-number">128</span>);        <span class="hljs-comment">//key转换</span>        Key key = <span class="hljs-keyword">new</span> SecretKeySpec(keyGenerator.generateKey().getEncoded(), <span class="hljs-string">"AES"</span>);        Cipher cipher = Cipher.getInstance(<span class="hljs-string">"AES/ECB/PKCS5Padding"</span>);        String src = <span class="hljs-string">"架构师训练营"</span>;        System.out.println(<span class="hljs-string">"明文："</span> + src);        <span class="hljs-comment">//加密</span>        cipher.init(Cipher.ENCRYPT_MODE, key);        <span class="hljs-keyword">byte</span>[] result = cipher.doFinal(src.getBytes());        System.out.println(<span class="hljs-string">"加密："</span> + Base64.encodeBase64String(result));        <span class="hljs-comment">//解密 </span>        cipher.init(Cipher.DECRYPT_MODE, key);        result = cipher.doFinal(result);        System.out.println(<span class="hljs-string">"解密："</span> + <span class="hljs-keyword">new</span> String(result));    &#125;&#125;</code></pre><h5 id="结果分析-19"><a href="#结果分析-19" class="headerlink" title="结果分析"></a>结果分析</h5><pre><code class="hljs gcode">明文：架构师训练营加密：ea<span class="hljs-number">4</span>/<span class="hljs-symbol">nl4</span>a<span class="hljs-number">7</span>MadH<span class="hljs-symbol">nixqbKVHdBLJ6</span>kDpXle<span class="hljs-symbol">n0</span>Q<span class="hljs-number">4</span>bzH<span class="hljs-number">2</span>ZXk=解密：架构师训练营</code></pre><h4 id="非对称"><a href="#非对称" class="headerlink" title="非对称"></a>非对称</h4><h5 id="概述-18"><a href="#概述-18" class="headerlink" title="概述"></a>概述</h5><p>非对称即加密与解密不是同一把钥匙，而是分成公钥和私钥。私钥在个人手里，公钥公开。这一对钥匙一个用于加密，另一个用于解密。使用其中一个加密后，则原始明文只能用对应的另一个密钥解密，即使最初用于加密的密钥也不能用作解密。正是因为这种特性，所以称为非对称加密。</p><h5 id="常见算法-2"><a href="#常见算法-2" class="headerlink" title="常见算法"></a>常见算法</h5><p>RSA、ElGamal、背包算法、Rabin（RSA的特例）、迪菲－赫尔曼密钥交换协议中的公钥加密算法、椭圆曲线加密算法（英语：Elliptic Curve Cryptography, ECC）。使用最广泛的是RSA算法（发明者Rivest、Shmir和Adleman姓氏首字母缩写）</p><table><thead><tr><th>名称</th><th>成熟度</th><th>运行速度</th><th>运行速度</th><th>资源消耗</th></tr></thead><tbody><tr><td>RAS</td><td>高</td><td>高</td><td>中</td><td>中</td></tr><tr><td>ECC</td><td>高</td><td>高</td><td>慢</td><td>高</td></tr></tbody></table><h5 id="应用-7"><a href="#应用-7" class="headerlink" title="应用"></a>应用</h5><p>最常见的，两点：https和数字签名。 </p><p>严格意义上讲，https并非所有请求都使用非对称。基于性能考虑，https先使用非对称约定一个key，后期使用该key进行对称加密和数据传输。 </p><img src="/blog/2020/08/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E4%B8%8E%E5%BA%94%E7%94%A8/pic8.png" srcset="/blog/img/loading.gif" class><p>数字签名则是用于验证报文是否为服务器发出的，用于防伪和认证。过程如下：</p><p>签发：</p><ul><li><p>服务器外发布公钥，私钥保密 </p></li><li><p>服务器对消息M计算摘要（如MD5等公开算法），得到摘要D </p></li><li><p>服务器使用私钥对D进行签名，得到签名S </p></li><li><p>将M和S一起发给客户 </p></li></ul><p>验证：</p><ul><li><p>客户端对M使用同一摘要算法计算摘要，得到摘要D </p></li><li><p>使用服务器公钥对S进行解密，得到摘要D’ </p></li><li><p>如果D和D’相同，那么证明M确实是服务器发出的</p></li></ul><h5 id="实现-20"><a href="#实现-20" class="headerlink" title="实现"></a>实现</h5><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.pwd;<span class="hljs-keyword">import</span> org.apache.commons.codec.binary.Base64;<span class="hljs-keyword">import</span> javax.crypto.Cipher;<span class="hljs-keyword">import</span> java.nio.charset.StandardCharsets;<span class="hljs-keyword">import</span> java.security.*;<span class="hljs-keyword">import</span> java.security.interfaces.RSAPrivateKey;<span class="hljs-keyword">import</span> java.security.interfaces.RSAPublicKey;<span class="hljs-keyword">import</span> java.security.spec.PKCS8EncodedKeySpec;<span class="hljs-keyword">import</span> java.security.spec.X509EncodedKeySpec;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RSAUtil</span> </span>&#123;    <span class="hljs-keyword">static</span> String privKey;    <span class="hljs-keyword">static</span> String publicKey;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//生成公钥和私钥 </span>        genKeyPair();        <span class="hljs-comment">//加密字符串 </span>        String message = <span class="hljs-string">"架构师训练营"</span>;        System.out.println(<span class="hljs-string">"明文："</span> + message);        System.out.println(<span class="hljs-string">"随机公钥为:"</span> + publicKey);        System.out.println(<span class="hljs-string">"随机私钥为:"</span> + privKey);        String messageEn = encrypt(message, publicKey);        System.out.println(<span class="hljs-string">"公钥加密:"</span> + messageEn);        String messageDe = decrypt(messageEn, privKey);        System.out.println(<span class="hljs-string">"私钥解密:"</span> + messageDe);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 随机生成密钥对</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">genKeyPair</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> NoSuchAlgorithmException </span>&#123;        <span class="hljs-comment">// KeyPairGenerator类用于生成公钥和私钥对，基于RSA算法生成对象</span>        KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance(<span class="hljs-string">"RSA"</span>);        <span class="hljs-comment">// 初始化密钥对生成器，密钥大小为96‐1024位</span>        keyPairGen.initialize(<span class="hljs-number">1024</span>, <span class="hljs-keyword">new</span> SecureRandom());        <span class="hljs-comment">// 生成一个密钥对，保存在keyPair中</span>        KeyPair keyPair = keyPairGen.generateKeyPair();        privKey = <span class="hljs-keyword">new</span> String(Base64.encodeBase64((keyPair.getPrivate().getEncoded())));        publicKey = <span class="hljs-keyword">new</span> String(Base64.encodeBase64(keyPair.getPublic().getEncoded()));    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * RSA公钥加密</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">encrypt</span><span class="hljs-params">(String str, String publicKey)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//base64编码的公钥 </span>        <span class="hljs-keyword">byte</span>[] decoded = Base64.decodeBase64(publicKey);        RSAPublicKey pubKey = (RSAPublicKey) KeyFactory.getInstance(<span class="hljs-string">"RSA"</span>).generatePublic(<span class="hljs-keyword">new</span> X509EncodedKeySpec(decoded));        <span class="hljs-comment">//RSA加密</span>        Cipher cipher = Cipher.getInstance(<span class="hljs-string">"RSA"</span>);        cipher.init(Cipher.ENCRYPT_MODE, pubKey);        String outStr = Base64.encodeBase64String(cipher.doFinal(str.getBytes(StandardCharsets.UTF_8)));        <span class="hljs-keyword">return</span> outStr;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * RSA私钥解密</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">decrypt</span><span class="hljs-params">(String str, String privateKey)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//64位解码加密后的字符串 </span>        <span class="hljs-keyword">byte</span>[] inputByte = Base64.decodeBase64(str.getBytes(StandardCharsets.UTF_8));        <span class="hljs-keyword">byte</span>[] decoded = Base64.decodeBase64(privateKey);        RSAPrivateKey priKey = (RSAPrivateKey) KeyFactory.getInstance(<span class="hljs-string">"RSA"</span>).generatePrivate(<span class="hljs-keyword">new</span> PKCS8EncodedKeySpec(decoded));        Cipher cipher = Cipher.getInstance(<span class="hljs-string">"RSA"</span>);        cipher.init(Cipher.DECRYPT_MODE, priKey);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(cipher.doFinal(inputByte));    &#125;&#125;</code></pre><h5 id="结果分析-20"><a href="#结果分析-20" class="headerlink" title="结果分析"></a>结果分析</h5><pre><code class="hljs elixir">明文：架构师训练营随机公钥为<span class="hljs-symbol">:MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCbuScdNarQtGJJMf9lGZ9KsD1ArYX7BFMxXDok7Wk75ItYkYJHJaOz2+EpGstXQb5XzBXUlT9pZTXsPHafhxFdLp3v9twc8clU890Wi7vxC755qcEp6Lr6uTT6t9hT295OkLjDwaE+OCAZBLKo8WDl7Z7oL05kxkPc0Id5SaBi7wIDAQAB</span>随机私钥为<span class="hljs-symbol">:MIICdQIBADANBgkqhkiG9w0BAQEFAASCAl8wggJbAgEAAoGBAJu5Jx01qtC0Ykkx/</span><span class="hljs-number">2</span>UZn0qwPUCthfsEUzFcOiTtaTvki1iRgkclo7Pb4Skay1dBvlfMFdSVP2llNew8dp+HEV0une/<span class="hljs-number">23</span>BzxyVTz3RaLu/ELvnmpwSnouvq5NPq32FPb3k6QuMPBoT44IBkEsqjxYOXtnugvTmTGQ9zQh3lJoGLvAgMBAAECgYAXGSKlIYXByU/e3YyteVx4XqXnRxXdgum4I574RULbwG2u6H5zgTDEB/Rg/Xl16umJ6lq+mpi6UGnsLZfG1+kKNuTSLNkmXxk0UO1nIfAYC67BgL+bP21/wEBu5T9cpessLdyZDtx4LK6ORRBWLWA2UhRg+e/uwDOIO+<span class="hljs-number">4</span>ezto3WQJBANkEOTSnkMTnvr3umpV290+Eh3ve4bR/eKBQxO3P+<span class="hljs-number">3</span>CRvJq9AgBCGNszwhM/<span class="hljs-number">7</span>GQxJBZi9/<span class="hljs-number">7W6</span>t/M7hIPkEtSsJsCQQC3skhLCDGuv7xXA/IJuY9SjN6FLkIDtEZML8l02/leowZHz7NxiYSBpBQQHLiOYz/lwKM0XdxWAtZsxMnC1so9AkB1h7EHkDx6N1v49xEnI0/a89aAQnwQSfzlLfkJJltxYqw3TWeZBjL5/DT+Qd9ff7GgoibXEEQRwqWoiF9IO9dDAkBKqXbCsGDpItsdDuh4VWhQaBslTGjeco5D9wRNr/<span class="hljs-number">7</span>KHT63P08y7W7i9lqFNfc5QFO/QS3UYfXlK6AVc2KCA6UNAkBHEtQVQK4hr0bsTERt6t+FGFGsM2lc6PuBKMHt6phPTS0P5hCZZJM/E/LBkPD4ZuP7zORK7ZEbff9mZj+c+<span class="hljs-number">61</span>J公钥加密<span class="hljs-symbol">:bDB0sRUj2rISKIklqNAq+EPn2ptp1zxvuWdtU/eH4frYVw98SqNEq3fC3HLTzNRc4B2KozykgUWWR1tlBzAnhOy1/xuzzcwjFKonjZH0XR7mUzzz2glKN66vEdnFRngoleB9BpXk2nCuUCTmq6MJ2bxgc7pfAeCSFecDFixGcig=</span>私钥解密<span class="hljs-symbol">:</span>架构师训练营</code></pre><ul><li><p>加密解密实现完整还原 </p></li><li><p>必须用另一把钥匙解密，如果用公钥加密后再使用公钥解密，则失败 </p></li></ul><h3 id="一致性hash及其应用"><a href="#一致性hash及其应用" class="headerlink" title="一致性hash及其应用"></a>一致性<strong>hash</strong>及其应用</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>负载均衡策略中，我们提到过源地址hash算法，让某些请求固定的落在对应的服务器上。这样可以解决会话信息保留的问题。 </p><p>如果机器节点数发生变更。那么请求会被重新hash，打破了原始的设计初衷，这时就需要一致性hash来解决。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>以4台机器为例，一致性hash的算法如下：</p><ul><li><p>首先求出各个服务器的哈希值，并将其配置到0～232的圆上 </p></li><li><p>然后采用同样的方法求出存储数据的键的哈希值，也映射圆上 </p></li><li><p>从数据映射到的位置开始顺时针查找，将数据保存到找到的第一个服务器上 </p></li><li><p>如果到最大值仍然找不到，就取第一个。这就是为啥形象的称之为环 </p></li></ul><img src="/blog/2020/08/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E4%B8%8E%E5%BA%94%E7%94%A8/pic9.png" srcset="/blog/img/loading.gif" class><p>添加节点：</p><img src="/blog/2020/08/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E4%B8%8E%E5%BA%94%E7%94%A8/pic10.png" srcset="/blog/img/loading.gif" class><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul><li><p>单调性(Monotonicity)：单调性是指如果已经有一些请求通过哈希分派到了相应的服务器进行处理，又有新的服务器加入到系统中时候，应保证原有的请求可以被映射到原有的或者新的服务器中去，而不会被映射到原来的其它服务器上去。 </p></li><li><p>分散性(Spread)：分布式环境中，客户端请求时可能只知道其中一部分服务器，那么两个客户端看到不同的部分，并且认为自己看到的都是完整的hash环，那么问题来了，相同的key可能被路由到不同服务器上去。以上图为例，加入client1看到的是1,4；client2看到的是2,3；那么2-4之间的key会被俩客户端重复映射到3,4上去。分散性反应的是这种问题的严重程度。 </p></li><li><p>平衡性(Balance)：平衡性是指客户端hash后的请求应该能够分散到不同的服务器上去。一致性hash可以做到尽量分散，但是不能保证每个服务器处理的请求的数量完全相同。这种偏差称为hash倾斜。如果节点的分布算法设计不合理，那么平衡性就会收到很大的影响。 </p></li></ul><p>优化</p><p>增加虚拟节点可以优化hash算法，使得切段和分布更细化。即实际有m台机器，但是扩充n倍，在环上放置m*n个，那么均分后，key的段会分布更细化。</p><img src="/blog/2020/08/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E4%B8%8E%E5%BA%94%E7%94%A8/pic11.png" srcset="/blog/img/loading.gif" class><h3 id="实现-21"><a href="#实现-21" class="headerlink" title="实现"></a>实现</h3><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.hash;<span class="hljs-keyword">import</span> java.util.SortedMap;<span class="hljs-keyword">import</span> java.util.TreeMap;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 一致性Hash算法</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hash</span> </span>&#123;    <span class="hljs-comment">//服务器列表</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String[] servers = &#123;<span class="hljs-string">"192.168.0.1"</span>, <span class="hljs-string">"192.168.0.2"</span>, <span class="hljs-string">"192.168.0.3"</span>, <span class="hljs-string">"192.168.0.4"</span>&#125;;    <span class="hljs-comment">//key表示服务器的hash值，value表示服务器</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SortedMap&lt;Integer, String&gt; serverMap = <span class="hljs-keyword">new</span> TreeMap&lt;Integer, String&gt;();    <span class="hljs-keyword">static</span> &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; servers.length; i++) &#123;            <span class="hljs-keyword">int</span> hash = getHash(servers[i]);            <span class="hljs-comment">//理论上，hash环的最大值为2^32</span>            <span class="hljs-comment">// 这里为做实例，将ip末尾作为上限也就是254</span>            <span class="hljs-comment">// 那么服务器是0‐4，乘以60后可以均匀分布到 0‐254 的环上去</span>            <span class="hljs-comment">// 实际的请求ip到来时，在环上查找即可</span>            hash *= <span class="hljs-number">60</span>;            System.out.println(<span class="hljs-string">"add "</span> + servers[i] + <span class="hljs-string">", hash="</span> + hash);            serverMap.put(hash, servers[i]);        &#125;    &#125;    <span class="hljs-comment">//查找节点</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getServer</span><span class="hljs-params">(String key)</span> </span>&#123;        <span class="hljs-keyword">int</span> hash = getHash(key);        <span class="hljs-comment">//得到大于该Hash值的所有server</span>        SortedMap&lt;Integer, String&gt; subMap = serverMap.tailMap(hash);        <span class="hljs-keyword">if</span> (subMap.isEmpty()) &#123;            <span class="hljs-comment">//如果没有比该key的hash值大的，则从第一个node开始</span>            Integer i = serverMap.firstKey();            <span class="hljs-comment">//返回对应的服务器</span>            <span class="hljs-keyword">return</span> serverMap.get(i);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//第一个Key就是顺时针过去离node最近的那个结点</span>            Integer i = subMap.firstKey();            <span class="hljs-comment">//返回对应的服务器</span>            <span class="hljs-keyword">return</span> subMap.get(i);        &#125;    &#125;    <span class="hljs-comment">//运算hash值</span>    <span class="hljs-comment">// 该函数可以自由定义，只要做到取值离散即可</span>    <span class="hljs-comment">// 这里取ip地址的最后一节</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getHash</span><span class="hljs-params">(String str)</span> </span>&#123;        String last = str.substring(str.lastIndexOf(<span class="hljs-string">"."</span>) + <span class="hljs-number">1</span>, str.length());        <span class="hljs-keyword">return</span> Integer.valueOf(last);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//模拟5个随机ip请求 </span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">8</span>; i++) &#123;            String ip = <span class="hljs-string">"192.168.1."</span> + i * <span class="hljs-number">30</span>;            System.out.println(ip + <span class="hljs-string">" ‐‐‐&gt; "</span> + getServer(ip));        &#125;        <span class="hljs-comment">//将5号服务器加到2‐3之间，取中间位置，150 </span>        System.out.println(<span class="hljs-string">"add 192.168.0.5，hash=150"</span>);        serverMap.put(<span class="hljs-number">150</span>, <span class="hljs-string">"192.168.0.5"</span>);        <span class="hljs-comment">//再次发起5个请求 </span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">8</span>; i++) &#123;            String ip = <span class="hljs-string">"192.168.1."</span> + i * <span class="hljs-number">30</span>;            System.out.println(ip + <span class="hljs-string">" ‐‐‐&gt; "</span> + getServer(ip));        &#125;    &#125;&#125;</code></pre><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><pre><code class="hljs angelscript">add <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>, hash=<span class="hljs-number">60</span>add <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.2</span>, hash=<span class="hljs-number">120</span>add <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.3</span>, hash=<span class="hljs-number">180</span>add <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.4</span>, hash=<span class="hljs-number">240</span><span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.30</span> ‐‐‐&gt; <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.60</span> ‐‐‐&gt; <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.90</span> ‐‐‐&gt; <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.2</span><span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.120</span> ‐‐‐&gt; <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.2</span><span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.150</span> ‐‐‐&gt; <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.3</span><span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.180</span> ‐‐‐&gt; <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.3</span><span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.210</span> ‐‐‐&gt; <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.4</span>add <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.5</span>，hash=<span class="hljs-number">150</span><span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.30</span> ‐‐‐&gt; <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.60</span> ‐‐‐&gt; <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.90</span> ‐‐‐&gt; <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.2</span><span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.120</span> ‐‐‐&gt; <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.2</span><span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.150</span> ‐‐‐&gt; <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.5</span><span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.180</span> ‐‐‐&gt; <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.3</span><span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.210</span> ‐‐‐&gt; <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.4</span></code></pre><ul><li><p>4台机器加入hash环 </p></li><li><p>模拟请求，根据hash值，准确调度到下游节点 </p></li><li><p>添加节点5，key取150 </p></li><li><p>再次发起请求 </p></li></ul><h3 id="典型业务场景应用"><a href="#典型业务场景应用" class="headerlink" title="典型业务场景应用"></a>典型业务场景应用</h3><h4 id="网站敏感词过滤"><a href="#网站敏感词过滤" class="headerlink" title="网站敏感词过滤"></a>网站敏感词过滤</h4><h5 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h5><p>敏感词、文字过滤是一个网站必不可少的功能，高效的过滤算法是非常有必要的。针对过滤首先想到的可能是这样：</p><p>方案一、使用java里的String contains，逐个遍历敏感词： </p><pre><code class="hljs java">String[] s = <span class="hljs-string">"广告,广告词,中奖"</span>.split(<span class="hljs-string">","</span>);String text = <span class="hljs-string">"讨厌的广告词"</span>;<span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>;<span class="hljs-keyword">for</span> (String s1 : s) &#123;    <span class="hljs-keyword">if</span> (text.contains(s1)) &#123;        flag = <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">break</span>;    &#125;&#125;System.out.println(flag);</code></pre><p>方案二、正则表达式： </p><pre><code class="hljs java">System.out.println(text.matches(<span class="hljs-string">".*(广告|广告词|中奖).*"</span>));</code></pre><p>其实无论采取哪个方法，基本是换汤不换药。都是整体字符匹配，效率值得商榷。 </p><p>那怎么办呢？DFA算法出场。</p><h5 id="概述-19"><a href="#概述-19" class="headerlink" title="概述"></a>概述</h5><p>DFA即Deterministic Finite Automaton，也就是确定有穷自动机，它是是通过event和当前的state得到下一个state，即event+state=nextstate。 </p><p>对照到以上案例，查找和停止查找是动作，找没找到是状态，每一步的查找和结果决定下一步要不要继续。DFA算法在敏感词上应用的关键是构建敏感词库，如果我们把以上案例翻译成json表达如下：</p><pre><code class="hljs json">&#123;<span class="hljs-attr">"isEnd"</span>: <span class="hljs-number">0</span>,<span class="hljs-attr">"广"</span>: &#123;<span class="hljs-attr">"isEnd"</span>: <span class="hljs-number">0</span>,<span class="hljs-attr">"告"</span>: &#123;<span class="hljs-attr">"isEnd"</span>: <span class="hljs-number">1</span>,<span class="hljs-attr">"词"</span>: &#123;<span class="hljs-attr">"isEnd"</span>: <span class="hljs-number">1</span>&#125;&#125;&#125;,<span class="hljs-attr">"中"</span>: &#123;<span class="hljs-attr">"isEnd"</span>: <span class="hljs-number">0</span>,<span class="hljs-attr">"奖"</span>: &#123;<span class="hljs-attr">"isEnd"</span>: <span class="hljs-number">1</span>&#125;&#125;&#125;</code></pre><p>查找过程如下：首先把text按字拆分，逐个字查找词库的key，先从“讨”开始，没有就下一个字“厌”，直到“广”，找到就判断isEnd，如果为1，说明匹配成功包含敏感词，如果为0，那就继续匹配“告”，直到isEnd=1为止。 </p><p>匹配策略上，有两种。最小和最大匹配。最小则匹配【广告】，最大则需要匹配到底【广告词】 </p><h5 id="实现-22"><a href="#实现-22" class="headerlink" title="实现"></a>实现</h5><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.hash;<span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<span class="hljs-keyword">import</span> java.util.HashMap;<span class="hljs-keyword">import</span> java.util.HashSet;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-keyword">import</span> java.util.Set;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 敏感词处理DFA算法</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SensitiveWordUtil</span> </span>&#123;    <span class="hljs-comment">//短匹配规则，如：敏感词库["广告","广告词"]，语句："我是广告词"，匹配结果：我是[广告]</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SHORT_MATCH = <span class="hljs-number">1</span>;    <span class="hljs-comment">//长匹配规则，如：敏感词库["广告","广告词"]，语句："我是广告词"，匹配结果：我是[广告词]</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> LONG_MATCH = <span class="hljs-number">2</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 敏感词库</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> HashMap sensitiveWordMap;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 初始化敏感词库</span><span class="hljs-comment">     * words:敏感词，多个用英文逗号分隔</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initSensitiveWordMap</span><span class="hljs-params">(String words)</span> </span>&#123;        String[] w = words.split(<span class="hljs-string">","</span>);        sensitiveWordMap = <span class="hljs-keyword">new</span> HashMap(w.length);        Map nowMap;        <span class="hljs-keyword">for</span> (String key : w) &#123;            nowMap = sensitiveWordMap;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; key.length(); i++) &#123;                <span class="hljs-comment">//转换成char型</span>                <span class="hljs-keyword">char</span> keyChar = key.charAt(i);                <span class="hljs-comment">//库中获取关键字</span>                Map wordMap = (Map) nowMap.get(keyChar);                <span class="hljs-comment">//如果不存在新建一个，并加入词库</span>                <span class="hljs-keyword">if</span> (wordMap == <span class="hljs-keyword">null</span>) &#123;                    wordMap = <span class="hljs-keyword">new</span> HashMap();                    wordMap.put(<span class="hljs-string">"isEnd"</span>, <span class="hljs-string">"0"</span>);                    nowMap.put(keyChar, wordMap);                &#125;                nowMap = wordMap;                <span class="hljs-keyword">if</span> (i == key.length() - <span class="hljs-number">1</span>) &#123;                    <span class="hljs-comment">//最后一个</span>                    nowMap.put(<span class="hljs-string">"isEnd"</span>, <span class="hljs-string">"1"</span>);                &#125;            &#125;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 判断文字是否包含敏感字符 *<span class="hljs-doctag">@return</span> 若包含返回true，否则返回false</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(String txt, <span class="hljs-keyword">int</span> matchType)</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; txt.length(); i++) &#123;            <span class="hljs-keyword">int</span> matchFlag = checkSensitiveWord(txt, i, matchType);            <span class="hljs-comment">//判断是否包含敏感字符</span>            <span class="hljs-keyword">if</span> (matchFlag &gt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-comment">//大于0存在，返回true</span>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-comment">/*** 沿着文本字符挨个往后检索文字中的敏感词 */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Set&lt;String&gt; <span class="hljs-title">getSensitiveWord</span><span class="hljs-params">(String txt, <span class="hljs-keyword">int</span> matchType)</span> </span>&#123;        Set&lt;String&gt; sensitiveWordList = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; txt.length(); i++) &#123;            <span class="hljs-comment">//判断是否包含敏感字符</span>            <span class="hljs-keyword">int</span> length = checkSensitiveWord(txt, i, matchType);            <span class="hljs-keyword">if</span> (length &gt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-comment">//存在,加入list中</span>                sensitiveWordList.add(txt.substring(i, i + length));                <span class="hljs-comment">//指针沿着文本往后移动敏感词的长度</span>                <span class="hljs-comment">// 也就是一旦找到敏感词，加到列表后，越过这个词的字符，继续往下搜索</span>                <span class="hljs-comment">// 但是必须减1，因为for循环会自增，如果不减会造成下次循环跳格而忽略字符</span>                <span class="hljs-comment">// 这会造成严重误差</span>                i = i + length - <span class="hljs-number">1</span>;            &#125;            <span class="hljs-comment">//如果找不到，i就老老实实一个字一个字的往后移动，作为begin进行下一轮</span>        &#125;        <span class="hljs-keyword">return</span> sensitiveWordList;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 从第beginIndex个字符的位置，往后查找敏感词</span><span class="hljs-comment">     * 如果找到，返回敏感词字符的长度，不存在返回0</span><span class="hljs-comment">     * 这个长度用于找到后提取敏感词和后移指针，是个性能关注点</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">checkSensitiveWord</span><span class="hljs-params">(String txt, <span class="hljs-keyword">int</span> beginIndex, <span class="hljs-keyword">int</span> matchType)</span> </span>&#123;        <span class="hljs-comment">//敏感词结束标识位：用于敏感词只有1位的情况</span>        <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>;        <span class="hljs-comment">//匹配到的敏感字的个数，也就是敏感词长度</span>        <span class="hljs-keyword">int</span> length = <span class="hljs-number">0</span>;        <span class="hljs-keyword">char</span> word;        <span class="hljs-comment">//从根Map开始查找</span>        Map nowMap = sensitiveWordMap;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = beginIndex; i &lt; txt.length(); i++) &#123;            <span class="hljs-comment">//被判断语句的第i个字符开始</span>            word = txt.charAt(i);            <span class="hljs-comment">//获取指定key，并且将敏感库指针指向下级</span>            nowMap = (Map) nowMap.get(word);            <span class="hljs-keyword">if</span> (nowMap != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-comment">//存在，则判断是否为最后一个</span>                <span class="hljs-comment">// 找到相应key，匹配长度+1</span>                length++;                <span class="hljs-comment">//如果为最后一个匹配规则,结束循环，返回匹配标识数</span>                <span class="hljs-keyword">if</span> (<span class="hljs-string">"1"</span>.equals(nowMap.get(<span class="hljs-string">"isEnd"</span>))) &#123;                    <span class="hljs-comment">//结束标志位为true</span>                    flag = <span class="hljs-keyword">true</span>;                    <span class="hljs-comment">//短匹配，直接返回,长匹配还需继续查找</span>                    <span class="hljs-keyword">if</span> (SHORT_MATCH == matchType) &#123;                        <span class="hljs-keyword">break</span>;                    &#125;                &#125;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">//敏感库不存在，直接中断</span>                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-keyword">if</span> (length &lt; <span class="hljs-number">2</span> || !flag) &#123;            <span class="hljs-comment">//长度必须大于等于1才算是词，字的话就不必这么折腾了</span>            length = <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">return</span> length;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//初始化敏感词库</span>        SensitiveWordUtil.initSensitiveWordMap(<span class="hljs-string">"广告,广告词,中奖"</span>);        System.out.println(<span class="hljs-string">"敏感词库结构："</span> + JSON.toJSONString(sensitiveWordMap));        String string = <span class="hljs-string">"关于中奖广告的广告词筛选"</span>;        System.out.println(<span class="hljs-string">"被检测文本："</span> + string);        System.out.println(<span class="hljs-string">"待检测字数："</span> + string.length());        <span class="hljs-comment">//是否含有关键字</span>        <span class="hljs-keyword">boolean</span> result = SensitiveWordUtil.contains(string, SensitiveWordUtil.LONG_MATCH);        System.out.println(<span class="hljs-string">"长匹配："</span> + result);        result = SensitiveWordUtil.contains(string, SensitiveWordUtil.SHORT_MATCH);        System.out.println(<span class="hljs-string">"短匹配："</span> + result);        <span class="hljs-comment">//获取语句中的敏感词</span>        Set&lt;String&gt; set = SensitiveWordUtil.getSensitiveWord(string, SensitiveWordUtil.LONG_MATCH);        System.out.println(<span class="hljs-string">"长匹配到："</span> + set);        set = SensitiveWordUtil.getSensitiveWord(string, SensitiveWordUtil.SHORT_MATCH);        System.out.println(<span class="hljs-string">"短匹配到："</span> + set);    &#125;&#125;</code></pre><h5 id="结果分析-21"><a href="#结果分析-21" class="headerlink" title="结果分析"></a>结果分析</h5><pre><code class="hljs actionscript">敏感词库结构：&#123;<span class="hljs-string">"中"</span>:&#123;<span class="hljs-string">"奖"</span>:&#123;<span class="hljs-string">"isEnd"</span>:<span class="hljs-string">"1"</span>&#125;,<span class="hljs-string">"isEnd"</span>:<span class="hljs-string">"0"</span>&#125;,<span class="hljs-string">"广"</span>:&#123;<span class="hljs-string">"告"</span>:&#123;<span class="hljs-string">"isEnd"</span>:<span class="hljs-string">"1"</span>,<span class="hljs-string">"词"</span>:&#123;<span class="hljs-string">"isEnd"</span>:<span class="hljs-string">"1"</span>&#125;&#125;,<span class="hljs-string">"isEnd"</span>:<span class="hljs-string">"0"</span>&#125;&#125;被检测文本：关于中奖广告的广告词筛选待检测字数：<span class="hljs-number">12</span>长匹配：<span class="hljs-literal">true</span>短匹配：<span class="hljs-literal">true</span>长匹配到：[中奖, 广告, 广告词]短匹配到：[中奖, 广告]</code></pre><ul><li><p>敏感词结构初始化后符合预期 </p></li><li><p>检测和长短匹配有结果 </p></li><li><p>匹配的敏感词列表正确 </p></li></ul><h4 id="最优商品topk"><a href="#最优商品topk" class="headerlink" title="最优商品topk"></a>最优商品topk</h4><h5 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h5><p>topk是一个典型的业务场景，除了最优商品，包括推荐排名、积分排名所有涉及到排名前k的地方都是该算法的应用场合。 </p><p>topk即得到一个集合后，筛选里面排名前k个数值。问题看似简单，但是里面的数据结构和算法体现着对解决方案性能的思索和深度挖掘。到底有几种方法，这些方案里蕴含的优化思路究竟是怎么样的？这节来讨论 </p><h5 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h5><p>方案一： </p><p>全局排序，将集合整体排序后，取出最大的k个值就是需要的结果。 </p><p>这种方案最糟糕，我只需要排名前k的元素，其他n-k个的顺序我并不关心，但是运算过程中，都得跟着做了没用的排序操作。 </p><p>方案二： </p><p>局部排序，既然全局没必要，那我只取前k个，后面的就没必要理会了。 </p><p>冒泡排序在排序算法中可以胜任该操作。我们按最大值往上冒泡为例，只要执行k次冒泡，那前k名就可以确定。 </p><p>但是这种方案依然不是最优办法。因为我们需要的是前k名，那至于这k个，谁大谁小并不需要关心，排序依然是个浪费。 </p><p>方案三： </p><p>最小堆，既然没必要排序，那我们就不排序。 </p><p>先将前k个元素形成一个最小堆，后面的n-k个元素依次与堆顶比较，小则丢弃大则替换堆顶并调整堆。直到n个全部完成为止。最小堆是topk的经典解决方案。 </p><h5 id="实现-23"><a href="#实现-23" class="headerlink" title="实现"></a>实现</h5><p>下面就用最小堆实现topk</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.hash;<span class="hljs-keyword">import</span> java.util.Arrays;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Topk</span> </span>&#123;    <span class="hljs-comment">//堆元素下沉，形成最小堆，序号从i开始 </span>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nodes, <span class="hljs-keyword">int</span> i)</span> </span>&#123;        <span class="hljs-comment">//顶点序号遍历，只要到1半即可，时间复杂度为O(log2n)</span>        <span class="hljs-keyword">while</span> (i &lt;&lt; <span class="hljs-number">1</span> &lt; nodes.length) &#123;            <span class="hljs-comment">//左子，为何左移1位？回顾一下二叉树序号 </span>            <span class="hljs-keyword">int</span> left = i &lt;&lt; <span class="hljs-number">1</span>;            <span class="hljs-comment">//右子，左+1即可 </span>            <span class="hljs-keyword">int</span> right = left + <span class="hljs-number">1</span>;            <span class="hljs-comment">//标记，指向 本节点，左、右子节点里最小的，一开始取i自己 </span>            <span class="hljs-keyword">int</span> flag = i;            <span class="hljs-comment">//判断左子是否小于本节点 </span>            <span class="hljs-keyword">if</span> (nodes[left] &lt; nodes[i]) &#123;                flag = left;            &#125;            <span class="hljs-comment">//判断右子 </span>            <span class="hljs-keyword">if</span> (right &lt; nodes.length &amp;&amp; nodes[flag] &gt; nodes[right]) &#123;                flag = right;            &#125;            <span class="hljs-comment">//两者中最小的与本节点不相等，则交换 </span>            <span class="hljs-keyword">if</span> (flag != i) &#123;                <span class="hljs-keyword">int</span> temp = nodes[i];                nodes[i] = nodes[flag];                nodes[flag] = temp;                i = flag;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">//否则相等，堆排序完成，退出循环即可 </span>                <span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//原始数据 </span>        <span class="hljs-keyword">int</span>[] src = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>&#125;;        <span class="hljs-comment">//要取几个 </span>        <span class="hljs-keyword">int</span> k = <span class="hljs-number">5</span>;        <span class="hljs-comment">//堆，为啥是k+1？请注意，最小堆的0是无用的，序号从1开始 </span>        <span class="hljs-keyword">int</span>[] nodes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[k + <span class="hljs-number">1</span>];        <span class="hljs-comment">//取前k个数，注意这里只是个二叉树，还不满足最小堆的要求</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;            nodes[i + <span class="hljs-number">1</span>] = src[i];        &#125;        System.out.println(<span class="hljs-string">"before:"</span> + Arrays.toString(nodes));        <span class="hljs-comment">//从最底的子树开始，堆顶下沉 </span>        <span class="hljs-comment">// 这里才真正的形成最小堆</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = k &gt;&gt; <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">1</span>; i--) &#123;            down(nodes, i);        &#125;        System.out.println(<span class="hljs-string">"create:"</span> + Arrays.toString(nodes));        <span class="hljs-comment">//把余下的n‐k个数，放到堆顶，依次下沉，topk堆算法的开始 </span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = src.length - k; i &lt; src.length; i++) &#123;            <span class="hljs-keyword">if</span> (nodes[<span class="hljs-number">1</span>] &lt; src[i]) &#123;                nodes[<span class="hljs-number">1</span>] = src[i];                down(nodes, <span class="hljs-number">1</span>);            &#125;        &#125;        System.out.println(<span class="hljs-string">"topk:"</span> + Arrays.toString(nodes));    &#125;&#125;</code></pre><h5 id="结果分析-22"><a href="#结果分析-22" class="headerlink" title="结果分析"></a>结果分析</h5><pre><code class="hljs angelscript">before:[<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>]create:[<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>]topk:[<span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>]</code></pre><p>最终获取k个值成功，符合要求 </p><p>中间不涉及排序问题</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>加密算法</tag>
      
      <tag>失效算法</tag>
      
      <tag>限流算法</tag>
      
      <tag>调度算法</tag>
      
      <tag>定时算法</tag>
      
      <tag>负载均衡算法</tag>
      
      <tag>一致性Hash</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构和算法基础</title>
    <link href="/blog/2020/08/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    <url>/blog/2020/08/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p>数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。通 常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。 </p><h5 id="划分"><a href="#划分" class="headerlink" title="划分"></a>划分</h5><p>从关注的维度看，数据结构可以划分为数据的逻辑结构和物理结构，同一逻辑结构可以对应不同的存储结构。 </p><p>逻辑结构反映的是数据元素之间的逻辑关系，逻辑关系是指数据元素之间的前后间以什么形式相互关联，这与他们 在计算机中的存储位置无关。逻辑结构包括： </p><ul><li><p>集合：只是扎堆凑在一起，没有互相之间的关联 </p></li><li><p>线性结构：一对一关联，队形 </p></li><li><p>树形结构：一对多关联，树形 </p></li><li><p>图形结构：多对多关联，网状 </p></li></ul><p>数据物理结构指的是逻辑结构在计算机存储空间中的存放形式(也称为存储结构)。一般来说，一种数据结构的逻辑结构根据需要可以表示成多种存储结构，常用的存储结构有顺序存储、链式存储、索引存储和哈希存储等。</p><ul><li><p>顺序存储：用一组地址连续的存储单元依次存储集合的各个数据元素，可随机存取，但增删需要大批移动 </p></li><li><p>链式存储：不要求连续，每个节点都由数据域和指针域组成，占据额外空间，增删快，查找慢需要遍历 </p></li><li><p>索引存储：除建立存储结点信息外，还建立附加的索引表来标识结点的地址。检索快，空间占用大 </p></li><li><p>哈希存储：将数据元素的存储位置与关键码之间建立确定对应关系，检索快，存在映射函数碰撞问题</p></li></ul><h5 id="程序中常见的数据结构"><a href="#程序中常见的数据结构" class="headerlink" title="程序中常见的数据结构"></a>程序中常见的数据结构</h5><ul><li><p>数组(Array)：连续存储，线性结构，可根据偏移量随机读取，扩容困难 </p></li><li><p>栈( Stack)：线性存储，只允许一端操作，先进后出，类似水桶 </p></li><li><p>队列(Queue)：类似栈，可以双端操作。先进先出，类似水管 </p></li><li><p>链表( LinkedList)：链式存储，配备前后节点的指针，可以是双向的 </p></li><li><p>树( Tree)：典型的非线性结构，从唯一的根节点开始，子节点单向执行前驱（父节点） </p></li><li><p>图(Graph)：另一种非线性结构，由节点和关系组成，没有根的概念，互相之间存在关联</p></li><li><p>堆(Heap)：特殊的树，特点是根结点的值是所有结点中最小的或者最大的，且子树也是堆 </p></li><li><p>散列表(Hash)：源自于散列函数，将值做一个函数式映射，映射的输出作为存储的地址 </p></li></ul><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><p>算法指的是基于存储结构下，对数据如何有效的操作，采用什么方式可以更有效的处理数据，提高数据运算效率。数据的运算是定义在数据的逻辑结构上，但运算的具体实现要在存储结构上进行。一般涉及的操作有以下几种： </p><ul><li><p>检索：在数据结构里查找满足一定条件的节点。 </p></li><li><p>插入：往数据结构中增加新的节点，一般有一点位置上的要求。 </p></li><li><p>删除：把指定的结点从数据结构中去掉，本身可能隐含有检索的需求。 </p></li><li><p>更新：改变指定节点的一个或多个字段的值，同样隐含检索。 </p></li><li><p>排序：把节点里的数据，按某种指定的顺序重新排列，例如递增或递减。 </p></li></ul><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>简单理解，为了某种运算而花费的时间，使用大写O表示。一般来讲，时间是一个不太容易计量的维度，而为了计算时间复杂度，通常会估计算法的操作单元数量，而假定每个单元运行的时间都是相同的。因此，总运行时间和算法的操作单元数量一般来讲成正比，最多相差一个常量系数。一般来讲，常见时间复杂度有以下几种： </p><ol><li><p>常数阶O(1)：时间与数据规模无关，如交换两个变量值</p><pre><code class="hljs java"><span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>,j=<span class="hljs-number">2</span>,k k=i;i=j;j=k;</code></pre></li><li><p>线性阶O(n)：时间和数据规模呈线性，可以理解为n的1次方，如单循环里的操作</p><pre><code class="hljs java"><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123; <span class="hljs-keyword">do</span>();&#125;</code></pre></li><li><p>k次方阶O(nk)：执行次数是数量的k次方，如多重循环，以下为2次方阶实例</p><pre><code class="hljs java"><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;   <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;     <span class="hljs-keyword">do</span>();   &#125; &#125;</code></pre></li><li><p>指数阶O(2n)：随着n的上升，运算次数呈指数增长</p><pre><code class="hljs java"><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;= <span class="hljs-number">2</span>^n;i++)&#123;   <span class="hljs-keyword">do</span>(); &#125;</code></pre></li><li><p>对数阶O(log2n)：执行次数呈对数缩减，如下</p><pre><code class="hljs java"><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;)&#123;  i=<span class="hljs-number">2</span>^i;  <span class="hljs-keyword">do</span>();&#125;</code></pre></li><li><p>线性对数阶O(nlog2n)：在对数阶的基础上，进行线性n倍乘积 </p><pre><code class="hljs java"><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">2</span>^n;i++)&#123;   <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;     <span class="hljs-keyword">do</span>();   &#125; &#125;</code></pre></li></ol><p>总结：</p><p>时间复杂度由小到大依次为：Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n2)&lt;…＜Ο(nk)＜Ο(2n)＜Ο(n!) </p><img src="/blog/2020/08/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/pic1.png" srcset="/blog/img/loading.gif" class><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>与时间复杂度类似，空间复杂度是对一个算法在运行过程中占用内存空间大小的度量。一个程序执行时除了需要存储空间和存储本身所使用的指令、常数、变量和输入数据外，还需要一些对数据进行操作的辅助空间。而空间复杂度主要指的是这部分空间的量级。 </p><ul><li>固定空间：主要包括指令空间、常量、简单变量等所占的空间，这部分空间的大小与运算的数据多少无关，属于静态空间。</li><li>可变空间：主要包括运行期间动态分配的临时空间，以及递归栈所需的空间等，这部分的空间大小与算法有很大关系。 </li></ul><p>同样，空间复杂度也用大写O表示，相比时间复杂度场景相对简单，常见级别为O(1)和O(n)，以数组逆序为例，两种不同算法对复杂度影响如下： </p><ol><li><p>O(1)：常数阶，所占空间和数据量大小无关</p><pre><code class="hljs java"><span class="hljs-comment">//定义前后指针，和一个临时变量，往中间移动</span><span class="hljs-comment">//无论a多大，占据的临时空间只有一个temp</span><span class="hljs-keyword">int</span>[] a=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=a.length‐<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (i&lt;=j)&#123;   <span class="hljs-keyword">int</span> temp = a[i];  a[i]=a[j];  a[j]=temp;  i++;  j‐‐;&#125;</code></pre></li><li><p>O(n)：线性阶，与数据量大小呈线性关系 </p><pre><code class="hljs java"><span class="hljs-comment">//定义一个和a同等大小的数组b，与运算量a的大小呈线性关系 </span><span class="hljs-comment">//给b赋值时，倒序取a </span><span class="hljs-keyword">int</span>[] a=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<span class="hljs-keyword">int</span>[] b=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[a.length];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; a.length; i++) &#123;  b[i]=a[a.length‐<span class="hljs-number">1</span>‐i];&#125;</code></pre></li></ol><h4 id="类比"><a href="#类比" class="headerlink" title="类比"></a>类比</h4><p>对于一个算法，其时间复杂度和空间复杂度往往是相互影响的。时间复杂度低可能借助占用大的存储空间来弥补，反之，某个算法所占据空间小，那么可能就需要占用更多的运算时间。两者往往需要达到一种权衡。 </p><p>在特定环境下的业务，还需要综合考虑算法的各项性能，如使用频率，数据量的大小，所用的开发语言，运行的机器系统等。两者兼顾权衡利弊才能设计出最适合当前场景的算法。</p><img src="/blog/2020/08/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/pic2.png" srcset="/blog/img/loading.gif" class><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><h4 id="分而治之"><a href="#分而治之" class="headerlink" title="分而治之"></a>分而治之</h4><p>把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题，直到最后子问题小到可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)，大数据中的MR，现实中如汉诺塔游戏。 </p><p>分治法对问题有一定的要求： </p><ul><li><p>该问题缩小到一定程度后，就可以轻松解决 </p></li><li><p>问题具有可拆解性，不是一团无法拆分的乱麻 </p></li><li><p>拆解后的答案具有可合并性。能组装成最终结果 </p></li><li><p>拆解的子问题要相互独立，互相之间不存在或者很少有依赖关系 </p></li></ul><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p>基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他。依次解决各子问题，最后一个子问题就是初始问题的解。 </p><p>与分治法最大的不同在于，分治法的思想是并发，动态规划的思想是分步。该方法经分解后得到的子问题往往不是互相独立的，其下一个子阶段的求解往往是建立在上一个子阶段的解的基础上。</p><p>动态规划算法同样有一定的适用性，场景要求： </p><ul><li><p>最优化解：拆解后的子阶段具备最优化解，且该最优化解与追踪答案方向一致 </p></li><li><p>流程向前，无后效性：上一阶段的解决方案一旦确定，状态就确定，只会影响下一步，而不会反向影响 </p></li><li><p>阶段关联：上下阶段不是独立的，上一阶段会对下一阶段的行动提供决策性指导。这不是必须的，但是如果具备该特征，动态规划算法的意义才能更大的得到体现 </p></li></ul><h4 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h4><p>同样对问题要求作出拆解，但是每一步，以当前局部为目标，求得该局部的最优解。那么最终问题解决时，得到完整的最优解。也就是说，在对问题求解时，总是做出在当前看来是最好的选择，而不去从整体最优上加以考虑。从这一角度来讲，该算法具有一定的场景局限性。要求问题可拆解，并且拆解后每一步的状态无后效性（与动态规划算法类似） 。</p><p>要求问题每一步的局部最优，与整体最优解方向一致。至少会导向正确的主方向。</p><h4 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h4><p>回溯算法实际上是一个类似枚举的搜索尝试过程，在每一步的问题下，列举可能的解决方式。选择某个方案往深度探究，寻找问题的解，当发现已不满足求解条件，或深度达到一定数量时，就返回，尝试别的路径。回溯法一般适用于比较复杂的，规模较大的问题。有“通用解题法”之称。 </p><ul><li><p>问题的解决方案具备可列举性，数量有限</p></li><li><p>界定回溯点的深度。达到一定程度后，折返 </p></li></ul><h4 id="分支限界"><a href="#分支限界" class="headerlink" title="分支限界"></a>分支限界</h4><p>与回溯法类似，也是一种在空间上枚举寻找最优解的方式。但是回溯法策略为深度优先。分支法为广度优先。分支法一般找到所有相邻结点，先采取淘汰策略，抛弃不满足约束条件的结点，其余结点加入活结点表。然后从存活表中选择一个结点作为下一个操作对象。 </p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络安全</title>
    <link href="/blog/2020/08/14/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    <url>/blog/2020/08/14/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="HTTPS超文本传输安全协议"><a href="#HTTPS超文本传输安全协议" class="headerlink" title="HTTPS超文本传输安全协议"></a>HTTPS超文本传输安全协议</h3><h4 id="HTTP协议回顾"><a href="#HTTP协议回顾" class="headerlink" title="HTTP协议回顾"></a>HTTP协议回顾</h4><p>HTTP 协议于 1991 年引入，至今已有近 30 年的历史。自第一个文档化版本 (后来称为 0.9) 以来，它已经经历了一段相当长的历程（5年）。 HTTP 的第一个版本只能传输超文本标记语言 (HTML) 文件，因此我们称之为超文本传输协议。 </p><p>超文本传输协议是一个基于请求与响应，无状态的，应用层的协议 。基于TCP/IP协议传输（明文）数据，互联网上应用最为广泛的一种网络协议,所有的WWW都必须遵守这个标准。 </p><p>我们使用浏览器访问一个网站页面，在浏览器的地址栏中我们会看到一串URL，域名地址都很好理解，不同的域名地址表示网站中不同的页面，而通信协议，简单来说就是浏览器和服务器之间沟通的语言。 </p><h4 id="HTTP发展历程"><a href="#HTTP发展历程" class="headerlink" title="HTTP发展历程"></a>HTTP发展历程</h4><p>1997 年发布的 HTTP/1.1 引入了一些其它的改进。除了添加像 OPTIONS 这样的方法外，它还引入了Keep-Alive 头。它允许一个连接对多个 HTTP 请求保持打开状态。因为这点，连接不必在每次请求之后关闭，然后再重新打开。 </p><p>HTTP 2.0拥有更优异的表现，现在网络变得的复杂，甚至演变成了独有的应用，媒体的播放量，增进交互的脚本大小也增加了许多，更多的数据通过HTTP请求被传输，由此HTTP 2.0为网络效率做了大量的优化。</p><img src="/blog/2020/08/14/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/pic1.png" srcset="/blog/img/loading.gif" class><blockquote><p>tips： </p><p>HTTP 3.0 目前处于制订和测试阶段，是未来的全新的 HTTP 协议， HTTP 3.0 协议运行在 QUIC 协议之上，是在 UDP 的基础上实现了可靠传输</p><p>HTTP 3.0 不是 HTTP 2.0 的拓展， HTTP 3.0 将会是一个全新的协议 </p></blockquote><p>总结</p><ol><li><p>HTTP协议始于1989年蒂姆·伯纳斯-李的一篇论文 </p></li><li><p>HTTP/0.9是个简单的文本协议,只能获取文本资源(get获取纯文本) </p></li><li><p>HTTP/1.0确立了现在使用的大部分技术,但不是正式标准 </p></li><li><p>HTTP/1.1是目前互联网使用最为广泛的协议,功能也非常完善(第一个标准文档). </p></li><li><p>HTTP/2基于Google的SPDY协议,注重性能改善,但还未普及 </p></li><li><p>HTTP/3基于Google的QUIC协议,是将来的发展方向 </p></li></ol><img src="/blog/2020/08/14/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/pic2.png" srcset="/blog/img/loading.gif" class><img src="/blog/2020/08/14/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/pic4.png" srcset="/blog/img/loading.gif" class><h4 id="HTTPS与HTTP的区别"><a href="#HTTPS与HTTP的区别" class="headerlink" title="HTTPS与HTTP的区别"></a>HTTPS与HTTP的区别</h4><p>HTTPS协议可以理解为HTTP协议的升级，就是在HTTP的基础上增加了数据加密。在数据进行传输之前，对数 </p><p>据进行加密，然后再发送到服务器。这样，就算数据被第三者所截获，但是由于数据是加密的，所以你的个人 </p><p>信息让然是安全的。 </p><p>这就是HTTP和HTTPS的最大区别。 </p><img src="/blog/2020/08/14/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/pic3.png" srcset="/blog/img/loading.gif" class><p>其他区别：</p><ol><li><p>https协议需要申请CA,证书,http不需要证书 </p></li><li><p>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl/tls加密传输协议。 </p></li><li><p>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 </p></li><li><p>http的连接很简单，是无状态的；HTTPS协议是由SSL/TLS+HTTP协议构建的加密传输 </p></li><li><p>http直接与四层交互，https先给安全层交互，然后在与四层交互 </p></li></ol><h3 id="加密原理与算法剖析"><a href="#加密原理与算法剖析" class="headerlink" title="加密原理与算法剖析"></a>加密原理与算法剖析</h3><h4 id="加密原理介绍"><a href="#加密原理介绍" class="headerlink" title="加密原理介绍"></a>加密原理介绍</h4><img src="/blog/2020/08/14/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/pic5.png" srcset="/blog/img/loading.gif" class><p>简单理解</p><img src="/blog/2020/08/14/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/pic6.png" srcset="/blog/img/loading.gif" class><p>如上图所示 HTTPS 相比 HTTP 多了一层 SSL/TLS</p><img src="/blog/2020/08/14/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/pic7.png" srcset="/blog/img/loading.gif" class><p><strong>TLS（Transport Layer Security，传输层安全）：</strong> </p><p>其前身是 SSL，它最初的几个版本（SSL 1.0、SSL 2.0、SSL 3.0）由网景公司开发1999年从 3.1 开始被 IETF 标准化并改名，发展至今已经有 TLS 1.0、TLS 1.1、TLS 1.2 三个版本。 </p><p>TLS 1.3 改动会比较大，目前还未大规模推广，目前使用最广泛的是TLS 1.2 </p><h4 id="加密后通信流程"><a href="#加密后通信流程" class="headerlink" title="加密后通信流程"></a>加密后通信流程</h4><p>客户端在使用HTTPS方式与Web服务器通信时的步骤 </p><p>访问<a href="http://www.taobao.com" target="_blank" rel="noopener">www.taobao.com</a></p><img src="/blog/2020/08/14/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/pic8.png" srcset="/blog/img/loading.gif" class><h4 id="加密算法剖析"><a href="#加密算法剖析" class="headerlink" title="加密算法剖析"></a>加密算法剖析</h4><p>要建立一个密码体制，需要由五个空间组成，分别是： </p><ul><li><p>明文M：加密前或解密后的信息； </p></li><li><p>密文C：明文加密后的信息； </p></li><li><p>密钥K：由加密密钥和解密密钥组成； </p></li><li><p>加密E：从明文到密文的变换； </p></li><li><p>解密D：从密文到明文的变换 </p></li></ul><img src="/blog/2020/08/14/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/pic9.png" srcset="/blog/img/loading.gif" class><h5 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h5><p>也叫单钥加密，是指加密密钥和解密密钥相同的加密方式。 </p><p>对称加密的主要优势是：加密、解密运算速度快，效率高； </p><p>代表算法：AES算法、DES算法、RC4，3DES 、Triple-DES, RC2等； </p><p>特点： </p><ol><li><p>发送端和接收端共享相同的密钥才能通信，一定程度上保证了安全。 </p></li><li><p>对于枚举攻击，密码长度越长越难以破解 </p></li></ol><p>对称加密经典应用： </p><p>0010101010101010 明文 </p><p>0001010001001011 秘钥 </p><p>0011111011100001 密文（异或后） </p><p>0010101010101010 明文（解密后）</p><h5 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h5><p>加密使用的密钥和解密使用的密钥是不相同的，分别称为：公钥、私钥，公钥和算法都是公开的，私钥是保密的。 </p><p>非对称加密算法性能较低，但是安全性超强，由于其加密特性，非对称加密算法能加密的数据长度也是有限的。 </p><p>例如：RSA、DSA、ECDSA、 DH、ECDHE </p><p>局限性：加密、解密运算效率较低； </p><p>非对称加密算法：RSA，DSA（有一个公匙和一个私匙） </p><p>特点： </p><ol><li><p>编码密钥众所周知，但只有特定主机才知道私有解码密钥，解码密钥保密，保证了传输安全。 </p></li><li><p>所有的想向主机发送报文的人都可以使用相同的编码密钥，解决了对称加密密钥数量多管理不便的问题。 </p></li></ol><h5 id="对称、非对称区别"><a href="#对称、非对称区别" class="headerlink" title="对称、非对称区别"></a>对称、非对称区别</h5><p>对称加密算法相比非对称加密算法来说，加解密的效率要高得多。但是缺陷在于对于秘钥的管理上，以及在非安全信道中通讯时，密钥交换的安全性不能保障。所以在实际的网络环境中，会将两者混合使用. </p><img src="/blog/2020/08/14/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/pic10.png" srcset="/blog/img/loading.gif" class><h5 id="散列算法（或音译为哈希）"><a href="#散列算法（或音译为哈希）" class="headerlink" title="散列算法（或音译为哈希）"></a>散列算法（或音译为哈希）</h5><p>Hash算法特别的地方在于它是一种单向（输出不依赖于输入）算法，用户可以通过hash算法对目标信息生成一段特定长度的唯一hash值，却不能通过这个hash值重新获得目标信息。 </p><p>因此Hash算法常用在不可还原的密码存储、信息完整性校验等。 </p><p>将任意长度的信息转换为较短的固定长度的值，通常其长度要比信息小得多，且算法不可逆。 例如：MD5、SHA-1、SHA-2、SHA-256 等 </p><p>信息-摘要算法 </p><p>MD5 (“ADSFASFA”)=SSSSSS </p><p>把一个不定长的数据通过摘要算法处理成一个定长的数据</p><h4 id="HTTPS协议SSL加密解密流程"><a href="#HTTPS协议SSL加密解密流程" class="headerlink" title="HTTPS协议SSL加密解密流程"></a>HTTPS协议SSL加密解密流程</h4><h5 id="加密解密流程"><a href="#加密解密流程" class="headerlink" title="加密解密流程"></a>加密解密流程</h5><img src="/blog/2020/08/14/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/pic11.png" srcset="/blog/img/loading.gif" class><h5 id="会话密钥生成流程详解（重要）"><a href="#会话密钥生成流程详解（重要）" class="headerlink" title="会话密钥生成流程详解（重要）"></a>会话密钥生成流程详解（重要）</h5><p>以上第1、2、4部分【生成的key或者随机值】是核心中的核心 </p><p>也就是3次随机数生成会话秘钥的的过程 </p><p>重点在说下</p><img src="/blog/2020/08/14/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/pic12.png" srcset="/blog/img/loading.gif" class><p>三个随机数： </p><ol><li><p>客户端给出协议版本号，一个随机数（client random），以及客户端支持的加密方式 </p></li><li><p>服务端确认双方使用的加密方式，并给出数字证书，以及一个服务器生成的随机数（server random） </p></li><li><p>客户端确认证书有效，然后生成一个新的46字节随机数（称为预备主密钥premaster secret），使用数字证书的公钥加密这个随机数，发送给服务端 </p></li></ol><p>总结：</p><p>服务端用非对称加密算法RSA生成公钥和私钥，把公钥放在证书里发送给客户端，私钥自己保存。</p><p>客户端接收到公钥后，首先向一个权威的服务器检查证书的合法性，如果证书合法，客户端产生一段随机数，这个随机数就作为通信的密钥，我们称之为对称密钥，用公钥加密这段随机数，然后发送到服务器。</p><p>服务器用密钥解密获取对称密钥，然后，双方就已对称密钥进行加密解密通信了 </p><h5 id="CA证书"><a href="#CA证书" class="headerlink" title="CA证书"></a>CA证书</h5><p>CA证书顾名思义就是由CA（Certifification Authority，也叫“证书授权中心”）机构发布的数字证书 。</p><p>X.509规范中一般推荐使用PEM格式来存储证书相关的文件。证书文件的文件名后缀一般为.crt或.cer对应私钥文件的文件名后缀一般为.key。证书请求文件的文件名后綴为.csr。有时候也统一用pem作为文件名后缀。</p><p>编码格式总结: </p><ul><li><p>X.509 标准DER(Distinguished Encoding Rules)编码，后缀为：.der .cer .crt </p></li><li><p>X.509 BASE64编码(PEM格式)，后缀为：.pem .cer .crt </p></li></ul><p>CA证书具体包括以下内容 </p><ul><li><p>颁发者 </p></li><li><p>使用者 </p></li><li><p>版本</p></li><li><p>签名算法 </p></li><li><p>签名哈希算法 </p></li><li><p>使用者 </p></li><li><p>公钥</p></li><li><p>指纹</p></li><li><p>指纹算法 </p></li><li><p>….. </p></li></ul><p>证书策略 </p><p>由对象标识符和限定符组成，这些对象标识符说明证书的颁发和使用策略有关</p><p>X509v3 Certifificate Policies: </p><p>​    Policy: 1.3.6.1.4.1.4146.1.20 </p><p>​    CPS: <a href="https://www.globalsign.com/repository/" target="_blank" rel="noopener">https://www.globalsign.com/repository/</a> </p><p>​    Policy: 2.23.140.1.2.2</p><img src="/blog/2020/08/14/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/pic13.png" srcset="/blog/img/loading.gif" class><p>版本号（Version Number）：CA证书一个规范的版本号，目前为版本3，值为0x2； </p><p>序列号（Serial Number）：由CA维护的，为它所发的每个证书分配一个序列号，用来追踪和撤销证书。只要拥有签发者信息和序列号，就可以唯一标识一个证书，最大不能过20个字节； </p><p>签名算法（Signature Algorithm）：数字签名所采用的算法，如： </p><ul><li><p>sha256-with-RSA-Encryption </p></li><li><p>ccdsa-with-SHA2S6； </p></li></ul><p>颁发者（Issuer）：发证书单位的标识信息，如 ” C=CN，ST=Beijing, L=Beijing, O=org.example.com，CN=ca.org。example.com ”； </p><p>有效期（Validity）：证书的有效期很，包括起止时间。</p><img src="/blog/2020/08/14/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/pic14.png" srcset="/blog/img/loading.gif" class><img src="/blog/2020/08/14/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/pic15.png" srcset="/blog/img/loading.gif" class><img src="/blog/2020/08/14/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/pic16.png" srcset="/blog/img/loading.gif" class><p>服务器提供服务器的公钥给ca机构，生成证书，证书一般包含以下内容：</p><ul><li><p>Issuer (证书的发布机构)</p></li><li><p>Valid from , Valid to (证书的有效期)</p></li><li><p>Public key (公钥)</p></li><li><p>Subject (主题，使用者)</p></li><li><p>Signature algorithm (签名所使用的算法)</p></li><li><p>Thumbprint, Thumbprint algorithm (指纹以及指纹算法) </p></li></ul><p>生成证书的过程一般是：把Issuer (证书的发布机构),Public key (公钥),Subject (主题),Valid from,Valid to(证书的有效期)等信息以明文的形式写到证书里面作为内容，然后用一个指纹算法（淘宝是sha1）计算出这些数字证书内容的一个指纹（也就是签名），并把指纹和指纹算法用自己的私钥进行加密，然后生成证书。</p><h3 id="SSL-TLS实战与开发"><a href="#SSL-TLS实战与开发" class="headerlink" title="SSL/TLS实战与开发"></a>SSL/TLS实战与开发</h3><h4 id="WebSocket实战与应用"><a href="#WebSocket实战与应用" class="headerlink" title="WebSocket实战与应用"></a>WebSocket实战与应用</h4><h5 id="websocket通信"><a href="#websocket通信" class="headerlink" title="websocket通信"></a>websocket通信</h5><img src="/blog/2020/08/14/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/pic17.png" srcset="/blog/img/loading.gif" class><ol><li><p>发送连接请求 </p><p>客户端通过一个格式为：ws://host:port/的请求地址发起WebSocket连接请求，并由JavaScript实现WebSocket API与服务器建立WebSocket连接，其中host为服务器主机IP地址或域名，port为端口。 </p></li><li><p>握手</p><p>当服务器收到请求后，会解析请求头信息，根据升级后的协议判断该请求为WebSocket请求，并取出请求信息中的Sec-WebSocket-Key字段的数据按照某种算法重新生成一个新的字符串序列放入响应头Sec-WebSocket-Accept中</p><p>Sec-WebSocket-Accept：服务器接受客户端HTTP协议升级的证明</p></li><li><p>WebSocket建立连接客户端接收服务器的响应后，同样会解析请求头信息，取出请求信息中的Sec-WebSocket-Accept字段，并用服务器内部处理Sec-WebSocket-Key字段的算法处理之前发送的Sec-WebSocket-Key，把处理得到的结果与Sec-WebSocket-Accept进行对比，数据相同则表示客户端与服务器成功建立WebSocket连接，反之失败 </p></li></ol><p>传统HTTP客户端与服务器请求响应模式如下图所示</p><img src="/blog/2020/08/14/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/pic18.png" srcset="/blog/img/loading.gif" class><p>上图对比可以看出，相对于传统HTTP每次请求-应答都需要客户端与服务端建立连接的模式，WebSocket是类似Socket的TCP长连接通讯模式。一旦WebSocket连接建立后，后续数据都以帧序列的形式传输。 </p><h5 id="WebSocket与HTTP的关系"><a href="#WebSocket与HTTP的关系" class="headerlink" title="WebSocket与HTTP的关系"></a>WebSocket与HTTP的关系</h5><p>WebSocket就像HTTP一样，是一个典型的应用层协议。 </p><p>Socket是传输控制层接口，WebSocket是应用层协议。 </p><p>相同点： </p><ol><li><p>都是一样基于TCP的，都是可靠性传输协议。 </p></li><li><p>都是应用层协议。 </p></li></ol><p>不同点： </p><ol><li><p>WebSocket是双向通信协议，模拟Socket协议，可以双向发送或接受信息。HTTP是单向的。 </p></li><li><p>WebSocket是需要浏览器和服务器握手进行建立连接的。而http是浏览器发起向服务器的连接，服务器预先并不知道这个连接。 </p></li><li><p>WebSocket在建立握手时，数据是通过HTTP传输的。但是建立之后，在真正传输时候是不需要HTTP协议的。 </p></li><li><p>在WebSocket中，只需要服务器和浏览器通过HTTP协议进行一个握手的动作，然后单独建立一条TCP的通信通道进行数据的传送。</p></li></ol><h5 id="ws请求"><a href="#ws请求" class="headerlink" title="ws请求"></a>ws请求</h5><p>WebSocket利用了HTTP协议来建立连接，它的目的是在浏览器和服务器之间建立一个不受限的双向通信的通道，比如说，服务器可以在任意时刻发送消息给浏览器。</p><p>WebSocket连接必须由浏览器发起，因为请求协议是一个标准的HTTP请求， 比如下面的请求头，但比http请求多了几个字段</p><img src="/blog/2020/08/14/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/pic20.png" srcset="/blog/img/loading.gif" class><p>该请求和普通的HTTP请求有几点不同： </p><ol><li><p>GET请求的地址不是类似/http/，而是以ws://开头的地址； </p></li><li><p>请求头Upgrade:websocket和Connection: Upgrade表示这个连接将要被转换为WebSocket连接； </p></li><li><p>Sec-WebSocket-Key是由浏览器随机生成的，是用于标识这个连接，并非用于加密数据； </p></li><li><p>Sec-WebSocket-Version指定了WebSocket的协议版本 </p></li><li><p>Sec-WebSocket-Extensions请求扩展 </p></li></ol><img src="/blog/2020/08/14/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/pic19.png" srcset="/blog/img/loading.gif" class><h5 id="ws响应"><a href="#ws响应" class="headerlink" title="ws响应"></a>ws响应</h5><p>General是一个 http 请求以及响应，这里的 general 可以理解成为 http 请求和响应的请始行的一个公共部分</p><p>101 状态码表示服务器已经理解了客户端的请求，并将通过 Upgrade 消息头通知客户端采用不同的协议来完成这个请求； </p><img src="/blog/2020/08/14/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/pic21.png" srcset="/blog/img/loading.gif" class><img src="/blog/2020/08/14/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/pic22.png" srcset="/blog/img/loading.gif" class><p>响应代码101表示本次连接的HTTP协议即将被更改，更改后的协议就是Upgrade: websocket指定的WebSocket协议。 </p><p>版本号和子协议规定了双方能理解的数据格式，以及是否支持压缩等等。如果仅使用WebSocket的API，就不需关心这些。</p><h4 id="自签名证书HTTPS开发"><a href="#自签名证书HTTPS开发" class="headerlink" title="自签名证书HTTPS开发"></a>自签名证书HTTPS开发</h4><h5 id="SSL证书生成"><a href="#SSL证书生成" class="headerlink" title="SSL证书生成"></a>SSL证书生成</h5><p>JDK中keytool是一个证书管理工具，可以生成自签名证书</p><p><code>keytool -genkey -alias czbk -keypass 123456 -keyalg RSA -keysize 1024 -validity 365 -keystore c:/czbk.keystore -storepass 123456</code></p><p>下面内容可以全部一样</p><img src="/blog/2020/08/14/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/pic23.png" srcset="/blog/img/loading.gif" class><p>查看生成结果 </p><img src="/blog/2020/08/14/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/pic24.png" srcset="/blog/img/loading.gif" class><p>后续使用，将生成文件复制到spring boot项目中的resources目录中</p><p>命令解释：</p><pre><code class="hljs sh">keytool-genkey -<span class="hljs-built_in">alias</span> tomcat(别名) -keypass 123456(别名密码) -keyalg RSA(生证书的算法名称，RSA是一种非对称加密算法) -keysize 1024(密钥长度,证书大小) -validity 365(证书有效期，天单位) -keystore c:/czbk.keystore(指定生成证书的位置和证书名称) -storepass 123456(获取keystore信息的密码) - storetype (指定密钥仓库类型)</code></pre><h5 id="springboot集成SSL"><a href="#springboot集成SSL" class="headerlink" title="springboot集成SSL"></a>springboot集成SSL</h5><p>将xxx.keystore拷贝到项目src/java/resources目录下.配置application.properties</p><pre><code class="hljs properties"><span class="hljs-comment"># 端口 </span><span class="hljs-meta">http.port</span>=<span class="hljs-string">7777 </span><span class="hljs-meta">server.port</span>=<span class="hljs-string">8888 </span><span class="hljs-comment"># 指定签名文件，对应生成的密钥库文件 </span><span class="hljs-meta">server.ssl.key-store</span>=<span class="hljs-string">classpath:czbk.keystore </span><span class="hljs-comment"># 指定签名密码，设置的密钥库指令 </span><span class="hljs-meta">server.ssl.key-store-password</span>=<span class="hljs-string">123456 </span><span class="hljs-comment"># 指定密钥仓库类型，JKS </span><span class="hljs-meta">server.ssl.key-store-type</span>=<span class="hljs-string">JKS </span><span class="hljs-comment"># 指定别名，生成密钥库的时候进行了设定 </span><span class="hljs-meta">server.ssl.key-alias</span>=<span class="hljs-string">czbk</span></code></pre><p>将czbk.keystore放到classpath下面 </p><img src="/blog/2020/08/14/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/pic25.png" srcset="/blog/img/loading.gif" class><p>增加配置类</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.http;<span class="hljs-keyword">import</span> com.sun.jdi.connect.Connector;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@Class</span>: HttpRedirectHttps</span><span class="hljs-comment"> * <span class="hljs-doctag">@Package</span> com.itheima.websocket.config</span><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>: http访问重定向https * <span class="hljs-doctag">@Company</span>: http://www.itheima.com/</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpRedirectHttps</span> </span>&#123;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;http.port&#125;"</span>)    Integer httpPort;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;server.port&#125;"</span>)    Integer httpsPort;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@Description</span>: 配置一个TomcatServletWebServerFactory 的BEAN</span><span class="hljs-comment">     * 然后添加一个Tomcat中的Connector（监听80端口）,并将请求转发到80端口</span><span class="hljs-comment">     * <span class="hljs-doctag">@Method</span>: tomcatServletWebServerFactory</span><span class="hljs-comment">     * <span class="hljs-doctag">@Param</span>: []</span><span class="hljs-comment">     * <span class="hljs-doctag">@Update</span>:</span><span class="hljs-comment">     * <span class="hljs-doctag">@since</span>: 1.0.0</span><span class="hljs-comment">     * <span class="hljs-doctag">@Return</span>: org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory</span><span class="hljs-comment">     **/</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> TomcatServletWebServerFactory <span class="hljs-title">servletContainer</span><span class="hljs-params">()</span> </span>&#123;        TomcatServletWebServerFactory tomcat = <span class="hljs-keyword">new</span> TomcatServletWebServerFactory() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessContext</span><span class="hljs-params">(Context context)</span> </span>&#123;                SecurityConstraint securityConstraint = <span class="hljs-keyword">new</span> SecurityConstraint();                securityConstraint.setUserConstraint(<span class="hljs-string">"CONFIDENTIAL"</span>);                SecurityCollection collection = <span class="hljs-keyword">new</span> SecurityCollection();                collection.addPattern(<span class="hljs-string">"/*"</span>);                securityConstraint.addCollection(collection);                context.addConstraint(securityConstraint);            &#125;        &#125;;        tomcat.addAdditionalTomcatConnectors(createTomcatConnector());        <span class="hljs-keyword">return</span> tomcat;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@Description</span>: CONFIDENTIAL:要求用使SSL</span><span class="hljs-comment">     * Spring Boot 不支持同时启动 HTTP 和 HTTPS ，为了解决这个问题，我们这里可以配置一个请 求转发，当用户发起 HTTP 调用时，自动转发到 HTTPS 上</span><span class="hljs-comment">     * <span class="hljs-doctag">@Method</span>: createTomcatConnector *</span><span class="hljs-comment">     * <span class="hljs-doctag">@Param</span>: []</span><span class="hljs-comment">     * <span class="hljs-doctag">@Update</span>:</span><span class="hljs-comment">     * <span class="hljs-doctag">@since</span>: 1.0.0</span><span class="hljs-comment">     * <span class="hljs-doctag">@Return</span>: org.apache.catalina.connector.Connector</span><span class="hljs-comment">     **/</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Connector <span class="hljs-title">createTomcatConnector</span><span class="hljs-params">()</span> </span>&#123;        Connector connector = <span class="hljs-keyword">new</span> Connector(<span class="hljs-string">"org.apache.coyote.http11.Http11NioProtocol"</span>);        connector.setScheme(<span class="hljs-string">"http"</span>);        <span class="hljs-comment">//Connector监听的http的默认端口号</span>        connector.setPort(httpPort);        connector.setSecure(<span class="hljs-keyword">false</span>);        <span class="hljs-comment">//监听到http的端口号后转向到的https的端口号,也就是项目配置的port</span>        connector.setRedirectPort(httpsPort);        <span class="hljs-keyword">return</span> connector;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTTPS</tag>
      
      <tag>WebSocket</tag>
      
      <tag>加密算法</tag>
      
      <tag>SSL/TLS</tag>
      
      <tag>CA证书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络编程</title>
    <link href="/blog/2020/08/09/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <url>/blog/2020/08/09/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="网络编程概述"><a href="#网络编程概述" class="headerlink" title="网络编程概述"></a>网络编程概述</h3><p>网络编程就是直接或间接地通过网络协议与其他计算机进行通信，网络编程有时我们也将其称之为套接字 (Socket)编程。</p><img src="/blog/2020/08/09/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/pic1.png" srcset="/blog/img/loading.gif" class><h4 id="网络编程三要素"><a href="#网络编程三要素" class="headerlink" title="网络编程三要素"></a>网络编程三要素</h4><ul><li><p>ip地址 </p></li><li><p>端口号 </p></li><li><p>网络协议 </p></li></ul><h4 id="ip地址"><a href="#ip地址" class="headerlink" title="ip地址"></a>ip地址</h4><p>IP地址是分配给网络中每台机器的数字标识符，它指出了设备在网络中的具体位置。 </p><p>ip地址可以分为两个版本：ipv4以及ipv6</p><p>IPv4地址（二进制）</p><pre><code class="hljs dns"><span class="hljs-number">01100100</span>.<span class="hljs-number">00000100</span>.<span class="hljs-number">00000101</span>.<span class="hljs-number">00000110</span></code></pre><p>IP地址（十进制） </p><pre><code class="hljs accesslog"><span class="hljs-number">100.4.5.6</span></code></pre><p>IPv6采用128位的地址，而IPv4使用的是32位，ipv6版的ip地址支持2^128(3.4 * 10 ^ 38)个ip地址。</p><p>IPv6二进位制下为128位长度，以16位为一组，每组以冒号”:”隔开，可以分为8组，每组以4位十六进制方式表示。例如： </p><pre><code class="hljs angelscript"><span class="hljs-number">2001</span>:<span class="hljs-number">0</span>db8:<span class="hljs-number">85</span>a3:<span class="hljs-number">08</span>d3:<span class="hljs-number">1319</span>:<span class="hljs-number">8</span>a2e:<span class="hljs-number">0370</span>:<span class="hljs-number">7344</span></code></pre><p>类似于IPv4的点分十进制，同样也存在点分十六进制的写法，将8组4位十六进制地址的冒号去除后，每位以点号”.”分组，例如： </p><pre><code class="hljs angelscript"><span class="hljs-number">2001</span>:<span class="hljs-number">0</span>db8:<span class="hljs-number">85</span>a3:<span class="hljs-number">08</span>d3:<span class="hljs-number">1319</span>:<span class="hljs-number">8</span>a2e:<span class="hljs-number">0370</span>:<span class="hljs-number">7344</span></code></pre><p>可以标记为 </p><pre><code class="hljs css">2<span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.1</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.d</span><span class="hljs-selector-class">.b</span><span class="hljs-selector-class">.8</span><span class="hljs-selector-class">.8</span><span class="hljs-selector-class">.5</span><span class="hljs-selector-class">.a</span><span class="hljs-selector-class">.3</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.8</span><span class="hljs-selector-class">.d</span><span class="hljs-selector-class">.3</span><span class="hljs-selector-class">.1</span><span class="hljs-selector-class">.3</span><span class="hljs-selector-class">.1</span><span class="hljs-selector-class">.9</span><span class="hljs-selector-class">.8</span><span class="hljs-selector-class">.a</span><span class="hljs-selector-class">.2</span><span class="hljs-selector-class">.e</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.3</span><span class="hljs-selector-class">.7</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.7</span><span class="hljs-selector-class">.3</span><span class="hljs-selector-class">.4</span><span class="hljs-selector-class">.4</span></code></pre><p>同时IPv6在某些条件下可以省略 </p><ol><li><p>每项数字前导的0可以省略，省略后前导数字仍是0则继续，例如下组IPv6是等价的。 </p><pre><code class="hljs css">2001<span class="hljs-selector-pseudo">:0DB8</span><span class="hljs-selector-pseudo">:02de</span><span class="hljs-selector-pseudo">:0000</span><span class="hljs-selector-pseudo">:0000</span><span class="hljs-selector-pseudo">:0000</span><span class="hljs-selector-pseudo">:0000</span><span class="hljs-selector-pseudo">:0e13</span>2001<span class="hljs-selector-pseudo">:DB8</span><span class="hljs-selector-pseudo">:2de</span><span class="hljs-selector-pseudo">:000</span><span class="hljs-selector-pseudo">:000</span><span class="hljs-selector-pseudo">:000</span><span class="hljs-selector-pseudo">:000</span><span class="hljs-selector-pseudo">:e13</span>2001<span class="hljs-selector-pseudo">:DB8</span><span class="hljs-selector-pseudo">:2de</span><span class="hljs-selector-pseudo">:00</span><span class="hljs-selector-pseudo">:00</span><span class="hljs-selector-pseudo">:00</span><span class="hljs-selector-pseudo">:00</span><span class="hljs-selector-pseudo">:e13</span>2001<span class="hljs-selector-pseudo">:DB8</span><span class="hljs-selector-pseudo">:2de</span><span class="hljs-selector-pseudo">:0</span><span class="hljs-selector-pseudo">:0</span><span class="hljs-selector-pseudo">:0</span><span class="hljs-selector-pseudo">:0</span><span class="hljs-selector-pseudo">:e13</span></code></pre></li><li><p>可以用双冒号”::”表示一组0或多组连续的0，但只能出现一次，如果四组数字都是零，可以被省略。遵照以上省略规则，下面这两组IPv6都是相等的(使用”::”表示多组连续的0)。</p><pre><code class="hljs css">2001<span class="hljs-selector-pseudo">:DB8</span><span class="hljs-selector-pseudo">:wde</span><span class="hljs-selector-pseudo">:0</span><span class="hljs-selector-pseudo">:0</span><span class="hljs-selector-pseudo">:0</span><span class="hljs-selector-pseudo">:0</span><span class="hljs-selector-pseudo">:e13</span>2001<span class="hljs-selector-pseudo">:DB8</span><span class="hljs-selector-pseudo">:2de</span><span class="hljs-selector-pseudo">::e13</span></code></pre><p>2001::25de::cade 是非法的，因为双冒号出现了两次。它有可能是下种情形之一，造成无法推断。 </p><pre><code class="hljs angelscript"><span class="hljs-number">2001</span>:<span class="hljs-number">0000</span>:<span class="hljs-number">0000</span>:<span class="hljs-number">0000</span>:<span class="hljs-number">0000</span>:<span class="hljs-number">25</span>de:<span class="hljs-number">0000</span>:cade <span class="hljs-number">2001</span>:<span class="hljs-number">0000</span>:<span class="hljs-number">0000</span>:<span class="hljs-number">0000</span>:<span class="hljs-number">25</span>de:<span class="hljs-number">0000</span>:<span class="hljs-number">0000</span>:cade <span class="hljs-number">2001</span>:<span class="hljs-number">0000</span>:<span class="hljs-number">0000</span>:<span class="hljs-number">25</span>de:<span class="hljs-number">0000</span>:<span class="hljs-number">0000</span>:<span class="hljs-number">0000</span>:cade <span class="hljs-number">2001</span>:<span class="hljs-number">0000</span>:<span class="hljs-number">25</span>de:<span class="hljs-number">0000</span>:<span class="hljs-number">0000</span>:<span class="hljs-number">0000</span>:<span class="hljs-number">0000</span>:cade</code></pre></li></ol><h4 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h4><p>通过IP地址可以在网络中找到指定计算机，但如果想访问目标计算机中的某个应用程序，还需要指定端口号。</p><p>在计算机中，不同的应用程序是通过端口号区分的。端口号是用两个字节（16位的二进制数）表示的，它的取值范围是0<del>65535，其中，0</del>1023之间的端口号用于一些知名的网络服务和应用(一般都是系统服务和应用)，用户的普通应用程序需要使用1024以上的端口号， 从而避免端口号被另外一个应用或服务所占用。 </p><img src="/blog/2020/08/09/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/pic4.png" srcset="/blog/img/loading.gif" class><h4 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h4><img src="/blog/2020/08/09/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/pic5.png" srcset="/blog/img/loading.gif" class><h3 id="网络分层模型通信"><a href="#网络分层模型通信" class="headerlink" title="网络分层模型通信"></a>网络分层模型通信</h3><h4 id="站点间数据传输过程"><a href="#站点间数据传输过程" class="headerlink" title="站点间数据传输过程"></a>站点间数据传输过程</h4><img src="/blog/2020/08/09/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/pic6.png" srcset="/blog/img/loading.gif" class><h4 id="网络分层模型与协议族"><a href="#网络分层模型与协议族" class="headerlink" title="网络分层模型与协议族"></a>网络分层模型与协议族</h4><p>OSI（Open System Interconnect），即开放式系统互联。 一般都叫OSI参考模型，是ISO国际标准化组织在1985年研究的网络互联模型。该体系结构标准定义了网络互联的七层框架（物理层、数据链路层、网络层、传输层、会话层、表示层和应用层），即OSI开放系统互连参考模型。</p><p>TCP/IP协议族里的协议最早发源于美国国防部（缩写为DoD）的ARPA网项目，因此也被称作DoD模型（DoD Model）。 </p><img src="/blog/2020/08/09/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/pic7.png" srcset="/blog/img/loading.gif" class><ul><li><p>网络层</p><ul><li>ip协议：网络互连协议，将多个包在网络中联系起来，传输数据包（不可靠传输），最基本功能就是寻址和分段功能，不提供端到端，路由到路由的确认，不提供重发和流量控制。是计算机网络能够互相通信的基本规则。出错 则像ICMP报告，ICMP在IP模块中实现。 </li><li>ICMP协议：面向无连接协议，用户传输错误报告控制信息（控制信息是指网络不通畅，主机是否到达，路由是否可用的这些网络本身的消息，不涉及用户传输的数据）。 </li><li>ARP协议：地址解析协议，根据IP地址获取物理地址的协议（即MAC地址）。在同一子网内通过ARP协议可以实现数据包的互相传递。不在一个子网内则无法获得MAC地址，只有通过网关去处理。 </li><li>RAPP协议：反转地址协议，将主机的物理地址转换成IP地址。 </li><li>BOOTP协议：引导程序协议，用于无盘工作站的局域网中，可以无盘工作站从一个中心服务器上获得IP地址。</li></ul></li><li><p>传输层：提供两台主机间端到端的通信</p><ul><li>TCP协议：传输控制协议，主要用于网间传输的协议，分割处理报文并把结果包传到IP层，并接受处理IP曾传到的数据包。 </li><li>UDP：用户数据协议，主要用于需要在计算器之间传输数据的应用，将网络数据流量压缩成数据包。 </li></ul></li><li><p>应用层：用于不同的应用程序</p><ul><li>NET协议：网络地址转换协议，实现内网IP地址和公司地址之间的相互转换。将大量的内网IP转换成一个或者少量的公网IP。 </li><li>FTP协议：文件传输协议 ，通过FTP协议在FTP客户端访问FTP服务端，默认使用20和21端口，20用于传输数据，21用于传输控制信息。 </li><li>HTTP协议：超文本协议，是用于从WWW服务端传输超文本到本地浏览器的传输协议。是客户端浏览器或其他程序与WEB服务器之间的应用层通信协议。 </li><li>TELNET协议：是Internet远程登录服务的标准协议和主要方式，为用户提供了在本地计算机上完成远程主机工作的能力。 </li><li>SMTP：简单邮件传输协议，控制邮件传输的规则，以及邮件的中转方式。 </li><li>DNS协议：定义域名规则，将域名和IP相互映射。 </li></ul></li></ul><img src="/blog/2020/08/09/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/pic8.png" srcset="/blog/img/loading.gif" class><h4 id="网络传输层剖析"><a href="#网络传输层剖析" class="headerlink" title="网络传输层剖析"></a>网络传输层剖析</h4><h5 id="网络套接字剖析"><a href="#网络套接字剖析" class="headerlink" title="网络套接字剖析"></a>网络套接字剖析</h5><img src="/blog/2020/08/09/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/pic9.png" srcset="/blog/img/loading.gif" class><p>Socket其实并不是一个协议，而是为了方便使用TCP或UDP而抽象出来的一层，是位于应用层和传输控制层之间的一组接口。提供一套调用TCP/IP协议的API。 </p><p>在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。 </p><p>当两台主机通信时，必须通过Socket连接，Socket则利用TCP/IP协议建立TCP连接。TCP连接则更依靠于底层的IP协议，IP协议的连接则依赖于链路层等更低层次 </p><img src="/blog/2020/08/09/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/pic19.png" srcset="/blog/img/loading.gif" class><h5 id="Socket通信流程"><a href="#Socket通信流程" class="headerlink" title="Socket通信流程"></a>Socket通信流程</h5><img src="/blog/2020/08/09/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/pic10.png" srcset="/blog/img/loading.gif" class><h5 id="网络传输报头格式"><a href="#网络传输报头格式" class="headerlink" title="网络传输报头格式"></a>网络传输报头格式</h5><p>TCP是Transmission Control Protocol的简称,中文名称为传输控制协议。它具有几下几个特点： </p><ol><li><p>TCP协议是一种面向连接的协议。 数据传输之前必须先建立连接，数据传输完成之后，必须释放连接。</p></li><li><p>TCP协议是一种可靠的协议。 传送的数据无差错、不丢失、不重复且顺序与与源数据一致。</p></li><li><p>TCP协议是基于IO流进行数据传输,传输数据无大小限制。 将数据拆分成不同大小的的段，也就是segment进行传输。</p></li><li><p>TCP协议的它的通信效率比较低。 TCP是面向连接的协议，传输数据之前需要建立连接,因此它的通信效率比较低。</p></li></ol><img src="/blog/2020/08/09/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/pic11.png" srcset="/blog/img/loading.gif" class><p>每部分的含义和作用 </p><ul><li><p>源端口号/目的端口号：表示数据从哪个进程来，到哪个进程去。</p></li><li><p>序号和确认号：是TCP可靠传输的关键部分。序号是本报文段发送的数据组的第一个字节的序号。 </p></li><li><p>在TCP传送的流中，每一个字节一个序号:。</p></li><li><p>TCP首部长度：由于TCP首部包含一个长度可变的选项部分，所以需要这么一个值来指定这个TCP报文段到底有多长。</p></li><li><p>URG：表示本报文段中发送的数据是否包含紧急数据。URG=1，表示有紧急数据。后面的紧急指针字段只有当URG=1时才有效。 </p></li><li><p>ACK：表示是否前面的确认号字段是否有效。ACK=1，表示有效。只有当ACK=1时，前面的确认号字段才有效。TCP规定，连接建立后，ACK必须为1。 </p></li><li><p>PSH：告诉对方收到该报文段后是否应该立即把数据推送给上层。如果为1，则表示对方应当立即把数据提交给上层，而不是缓存起来。 </p></li><li><p>RST：只有当RST=1时才有用。如果你收到一个RST=1的报文，说明你与主机的连接出现了严重错误（如主机崩溃），必须释放连接，然后再重新建立连接。或者说明你上次发送给主机的数据有问题，主机拒绝响应。 </p></li><li><p>SYN：在建立连接时使用，用来同步序号。当SYN=1，ACK=0时，表示这是一个请求建立连接的报文段；当SYN=1，ACK=1时，表示对方同意建立连接。SYN=1，说明这是一个请求建立连接或同意建立连接的报文。只有在前两次握手中SYN才置为1。 </p></li><li><p>FIN：标记数据是否发送完毕。如果FIN=1，就相当于告诉对方：“我的数据已经发送完毕，你可以释放连接了“。</p></li><li><p>窗口：滑动窗口大小，用来告知发送端接受端的缓存大小，以此控制发送端发送数据的速率，从而达到流量控制。</p></li><li><p>选项和填充：最常见的可选字段是最长报文大小，又称为MSS（Maximum Segment Size），每个连接方通常都在通信的第一个报文段（为建立连接而设置SYN标志为1的那个段）中指明这个选项，它表示本端所能接受的最大报文段的长度。选项长度不一定是32位的整数倍，所以要加填充位，即在这个字段中加入额外的零，以保证TCP头是32的整数倍。</p></li><li><p>数据部分： TCP 报文段中的数据部分是可选的。在一个连接建立和一个连接终止时，双方交换的报文段仅有 TCP 首部。如果一方没有数据要发送，也使用没有任何数据的首部来确认收到的数据。在处理超时的许多情况中，也会发送不带任何数据的报文段。 </p></li></ul><h5 id="TCP连接断开原理剖析"><a href="#TCP连接断开原理剖析" class="headerlink" title="TCP连接断开原理剖析"></a>TCP连接断开原理剖析</h5><ul><li><p>TCP连接三次握手</p><p>TCP协议在双方建立连接的时候需要三次握手， 所谓的三次握手即TCP连接的建立。这个连接必须是一方主动打开，另一方被动打开的。以下为客户端主动发起连接的图解：</p><img src="/blog/2020/08/09/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/pic12.png" srcset="/blog/img/loading.gif" class><p>其中比较重要的字段有： </p><p>SYN(synchronous建立连接)、ACK(acknowledgement 确认)、PSH(push传送)、FIN(fifinish结束)、RST(reset重置)、URG(urgent紧急)</p><img src="/blog/2020/08/09/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/pic13.png" srcset="/blog/img/loading.gif" class><p>第三次握手是为了防止服务器端开启一些无用的连接增加服务器开销以及防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。 </p></li><li><p>TCP的四次挥手</p><p>所谓的四次挥手即TCP连接的释放(解除)。连接的释放必须是一方主动释放，另一方被动释放。以下为客户端 </p><p>主动发起释放连接的图解：</p><img src="/blog/2020/08/09/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/pic20.png" srcset="/blog/img/loading.gif" class><p>其中比较重要的字段有： </p><p>SYN(synchronous建立连接)、ACK(acknowledgement 确认)、PSH(push传送)、FIN(fifinish结束)、RST(reset重置)、URG(urgent紧急) </p><img src="/blog/2020/08/09/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/pic14.png" srcset="/blog/img/loading.gif" class><p>客户端在TIME-WAIT阶段等待2MSL的原因：MSL指的是Maximum Segment Lifetime，一段TCP报文在传输过程中的最大生命周期。2MSL即是服务器端发出为FIN报文和客户端发出的ACK确认报文所能保持有效的最大时长</p></li></ul><h3 id="Socket编程与实战"><a href="#Socket编程与实战" class="headerlink" title="Socket编程与实战"></a>Socket编程与实战</h3><h4 id="从传统网络编程看BIO并发问题"><a href="#从传统网络编程看BIO并发问题" class="headerlink" title="从传统网络编程看BIO并发问题"></a>从传统网络编程看BIO并发问题</h4><h5 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h5><p>JDK提供的ServerSocket类表示我们的服务端，使用该类可以接收客户端的连接请求进而实现两端的通信。</p><p>ServerSocket常用方法 </p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ServerSocket</span><span class="hljs-params">()</span> <span class="hljs-comment">// 无参构造方,系统自动分配一个可用端口 (匿名端口)，服务端一般不使用 </span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ServerSocket</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port)</span> <span class="hljs-comment">// 构造方法,用于创建服务端对象接收客户 端连接(默认连接数为50); port指定服务端程序所占用的端口 </span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ServerSocket</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port, <span class="hljs-keyword">int</span> backlog)</span> <span class="hljs-comment">// 构造方法,用于创建服务端对象; port 指定服务端程序所占用的端口,backlog指定可接收的客户端数量 </span></span><span class="hljs-function"><span class="hljs-keyword">public</span> Socket <span class="hljs-title">accept</span><span class="hljs-params">()</span> <span class="hljs-comment">// 接收客户端连接请求(监听客户端)，如果没有客户端连接该方法阻塞。</span></span></code></pre><p>服务端代码实现步骤： </p><ol><li><p>创建ServerSocket对象，用于客户端连接 </p></li><li><p>调用accept方法(监听客户端)，该方法是一个阻塞方法 </p></li><li><p>调用Socket对象的方法获取输入流对象 </p></li><li><p>使用输入流对象读取数据 </p></li><li><p>释放资源 </p></li></ol><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    <span class="hljs-comment">// 创建ServerSocket对象，用于客户端连接 </span>    ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">8080</span>);    <span class="hljs-comment">// 使用输入流对象读取数据</span>    <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;            <span class="hljs-comment">// 调用accept方法(监听客户端)，该方法是一个阻塞方法 </span>            Socket accept = serverSocket.accept();            <span class="hljs-comment">// 调用Socket对象的方法获取输入流对象</span>            InputStream inputStream = accept.getInputStream();            <span class="hljs-keyword">int</span> read = inputStream.read(bytes);            System.out.println(<span class="hljs-keyword">new</span> String(bytes, <span class="hljs-number">0</span>, read));            <span class="hljs-comment">//关闭资源 </span>            accept.close();        &#125;    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        e.printStackTrace();    &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-keyword">if</span> (serverSocket != <span class="hljs-keyword">null</span> &amp;&amp; !serverSocket.isClosed()) &#123;            <span class="hljs-keyword">try</span> &#123;                serverSocket.close();            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;</code></pre><h5 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h5><p>JDK为了TCP通信提供了两个核心类：Socket(客户端)，ServerSocket(服务端)。使用Socket可以与服务端建立连接，实现数据的发送与接收。 </p><p>Socket中的常用方法</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Socket</span><span class="hljs-params">(String host, <span class="hljs-keyword">int</span> port)</span> <span class="hljs-comment">// 构造方法，用于和服务端建立连接;address：表示要连接的主机地址，port表示端口号</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> OutputStream <span class="hljs-title">getOutputStream</span><span class="hljs-params">()</span> <span class="hljs-comment">// 获取输出流对象，写数据 </span></span><span class="hljs-function"><span class="hljs-keyword">public</span> InputStream <span class="hljs-title">getInputStream</span><span class="hljs-params">()</span> <span class="hljs-comment">// 获取输入流对象，读数据</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> <span class="hljs-comment">// 释放资源</span></span></code></pre><p>客户端代码实现步骤： </p><ol><li><p>创建Socket对象，与服务端建立连接 </p></li><li><p>获取输出流对象 </p></li><li><p>使用输出流对象写数据 </p></li><li><p>释放资源 </p></li></ol><p>代码实现</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    <span class="hljs-comment">// 创建Socket对象，与服务端建立连接</span>    Socket socket = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-number">8080</span>);    <span class="hljs-comment">// 获取输出流对象</span>    OutputStream outputStream = socket.getOutputStream();    <span class="hljs-comment">// 使用输出流对象写数据</span>    outputStream.write(<span class="hljs-string">"itheima-TCP"</span>.getBytes());    <span class="hljs-comment">// 释放资源</span>    socket.close();&#125;</code></pre><h5 id="三次握手剖析"><a href="#三次握手剖析" class="headerlink" title="三次握手剖析"></a>三次握手剖析</h5><p>TCP协议是面向连接的通信协议，即传输数据之前，在客户端和服务端需要建立逻辑连接，然后再传输数据。</p><p>客户端与服务端在进行连接建立的时候，需要经过三个步骤，这个3个步骤相当于3次握手。 </p><ol><li><p>客户端到服务端: 我要连接 </p></li><li><p>服务端到客户端: 好的，已经连接上了 </p></li><li><p>客户端到服务端: 收到，确认已连接上了 </p></li></ol><p>我们可以借助于一个工具wireshark来抓取TCP客户端与服务端建立连接时数据传输的过程。</p><p>客户端代码</p><pre><code class="hljs java"><span class="hljs-comment">// 创建Socket对象</span>Socket socket = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-number">8080</span>);<span class="hljs-comment">// 让线程休眠60s </span>TimeUnit.SECONDS.sleep(<span class="hljs-number">60</span>);</code></pre><p>服务端代码</p><pre><code class="hljs java"><span class="hljs-comment">// 创建ServerSocket对象</span>ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">9999</span>);<span class="hljs-comment">// 让线程休眠60s </span>TimeUnit.SECONDS.sleep(<span class="hljs-number">60</span>);</code></pre><p>首先运行服务端，然后在运行客户端，在wireshark工具中捕获完整的通信过程，结果如下图所示：</p><img src="/blog/2020/08/09/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/pic15.png" srcset="/blog/img/loading.gif" class><p>第一次”握手”如下图所示</p><img src="/blog/2020/08/09/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/pic16.png" srcset="/blog/img/loading.gif" class><p>在第一次”握手”时，客户端向服务端发送SYN标志位，目的是与服务端建立连接。Seq代表sequence number(发送数据流序号), 例如：Seq的值是5,说明在数据流中曾经一共发送了 1, 2, 3，4 这4次数据。 </p><p>而在本次”握手”中, Seq的值是0，代表客户端曾经没有给服务端发送数据。另外Len=0也可以看出来是没有数据可供发送的，客户端仅仅发送一个SYN标志位到服端代表要进行连接。</p><p>第二次”握手”如下图所示</p><img src="/blog/2020/08/09/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/pic17.png" srcset="/blog/img/loading.gif" class><p>第二次”握手”时，服务端向客户端发送 SYN ACK 标志位，其中ACK标志位表示是对收到的数据包的确认，说明服务端接收到了客户端的连接。ACK的值是1，表示服务端期待下一次从客户端发送数据流的序列号是1，而Seq=0代表服务端曾经并没有给客户端发送数据，而本次也没有发送数据，因为Len=0也证明了这一点。 </p><p>第三次”握手”如下图所示</p><img src="/blog/2020/08/09/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/pic18.png" srcset="/blog/img/loading.gif" class><p>第三次“握手”时，客户端向服务端发送的ACK标志位为1, Seq的值是1。Seq=l代表这正是服务端所期望的Ack=1。Len=0说明客户端这次还是没有向服务端传递数据，而客户端向服务端发送ACK 标志位为1的信息，说明客户端期待服务端下一次传送的Seq的值是1。 </p><h5 id="四次握手剖析"><a href="#四次握手剖析" class="headerlink" title="四次握手剖析"></a>四次握手剖析</h5><p>客户端与服务端在断开连接的时候需要进行4次”挥手”，4次”挥手”的过程如下： </p><ol><li><p>客户端到服务端：我关了 </p></li><li><p>服务端到客户端：好的，收到 </p></li><li><p>服务端到客户端：我也关了 </p></li><li><p>客户端到服务端：好的，收到 </p></li></ol><p>我们也可以借助于wireshark这个抓包工具来抓取连接断开的整个数据传输的过程。</p><p>客户端代码 </p><pre><code class="hljs java"><span class="hljs-comment">// 创建Socket对象</span>Socket socket = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-number">8080</span>); <span class="hljs-comment">// 线程休眠 </span>TimeUnit.SECONDS.sleep(<span class="hljs-number">10</span>); <span class="hljs-comment">// 关闭连接 </span>socket.close();</code></pre><p>服务端代码</p><pre><code class="hljs java"><span class="hljs-comment">// 创建ServerSocket对象 </span>ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">8080</span>); <span class="hljs-comment">// 获取连接对象 </span>Socket socket = serverSocket.accept(); <span class="hljs-comment">// 线程休眠 </span>TimeUnit.SECONDS.sleep(<span class="hljs-number">10</span>); <span class="hljs-comment">// 释放资源 </span>socket.close(); serverSocket.close();</code></pre><p>首先运行服务端，然后在运行客户端，在wireshark工具中捕获完整的通信过程，结果如下图所示：</p><img src="/blog/2020/08/09/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/pic21.png" srcset="/blog/img/loading.gif" class><p>第一次”挥手”如下图所示</p><img src="/blog/2020/08/09/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/pic22.png" srcset="/blog/img/loading.gif" class><p>在第一次”挥手”时，客户端到服务器发送标志位FIN ACK,告知服务端客户端关闭了。Seq=1表示本次数据流的序号为1，Ack=1表示客户端期望服务端下一次发送的数据流的序号为1。len=0，说明没有数据传输到服务端。 </p><p>第二次”挥手”如下图所示</p><img src="/blog/2020/08/09/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/pic23.png" srcset="/blog/img/loading.gif" class><p>在第二次”挥手”时,服务端向客户端发送标志位ACK,Seq=1代表的正是客户端想看的Ack=1。Ack=2表示服务端期望下一次客户端发送的数据流的序号为2。len=0,说明没有数据传输到客户端。 </p><p>第三次”挥手”如下图所示</p><img src="/blog/2020/08/09/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/pic24.png" srcset="/blog/img/loading.gif" class><p>在第三次”挥手”时,服务端向客户端发送标志位FIN ACK,告知客户端服务端关闭了。Seq=1代表的正是客户端想看的Ack=1。Ack=2表示服务端期望下一次客户端发送的数据流的序号为2。 len=0，说明没有数据传输到客户端。 </p><p>第四次”挥手”如下图所示 </p><img src="/blog/2020/08/09/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/pic25.png" srcset="/blog/img/loading.gif" class><p>在第四次”挥手”时,客户端向服务端发送标志位ACK，告知服务端客户端已经收到服务端关闭信息。Seq=2代表的正是服务端想看的Ack=2，ACK=2表示客户端期望下一次服务端发送的数据流的序号为2。 </p><h5 id="传统网络编程延迟消息发送"><a href="#传统网络编程延迟消息发送" class="headerlink" title="传统网络编程延迟消息发送"></a>传统网络编程延迟消息发送</h5><p>服务端</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    <span class="hljs-comment">// 创建ServerSocket对象，用于客户端连接</span>    ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">8080</span>);    <span class="hljs-comment">// 使用输入流对象读取数据 </span>    <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;            System.out.println(<span class="hljs-string">"发生阻塞，等待客户端连接....."</span>);            <span class="hljs-comment">// 调用accept方法(监听客户端)，该方法是一个阻塞方法 </span>            Socket accept = serverSocket.accept();            <span class="hljs-comment">// 调用Socket对象的方法获取输入流对象 </span>            InputStream inputStream = accept.getInputStream();            System.out.println(<span class="hljs-string">"发生阻塞，等待客户端传输数据....."</span>);            <span class="hljs-keyword">int</span> read = inputStream.read(bytes);            System.out.println(<span class="hljs-keyword">new</span> String(bytes, <span class="hljs-number">0</span>, read));            <span class="hljs-comment">//关闭资源 </span>            accept.close();        &#125;    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        e.printStackTrace();    &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-keyword">if</span> (serverSocket != <span class="hljs-keyword">null</span> &amp;&amp; !serverSocket.isClosed()) &#123;            <span class="hljs-keyword">try</span> &#123;                serverSocket.close();            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;</code></pre><p>客户端</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    <span class="hljs-comment">// 创建Socket对象，与服务端建立连接</span>    Socket socket = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-number">8080</span>);    <span class="hljs-comment">// 获取输出流对象 </span>    OutputStream outputStream = socket.getOutputStream();    System.out.println(<span class="hljs-string">"客户端阻塞,接受键盘录入..."</span>);    <span class="hljs-comment">//接受键盘输入，模拟延迟发送消息 </span>    Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);    String scannerString = scanner.next();    <span class="hljs-comment">// 使用输出流对象写数据 </span>    outputStream.write(scannerString.getBytes());    System.out.println(<span class="hljs-string">"客户端完成录入..."</span>);    <span class="hljs-comment">// 释放资源 </span>    socket.close();&#125;</code></pre><p>存在的问题： 如果客户端已经连接服务端，但尚未发送数据，read阻塞会阻塞当前线程，新的客户端将无法正常连接。</p><p>解决方法</p><ol><li><p>线程解决</p></li><li><p>线程池解决</p></li><li><p>NIO解决 </p></li><li><p>websocket解决</p></li></ol><h4 id="基于NIO多路复用解决并发问题"><a href="#基于NIO多路复用解决并发问题" class="headerlink" title="基于NIO多路复用解决并发问题"></a>基于NIO多路复用解决并发问题</h4><h5 id="NIO简述"><a href="#NIO简述" class="headerlink" title="NIO简述"></a>NIO简述</h5><p>特点： </p><ol><li><p>NIO是New IO的简称，是JDK1.4提出的一种新的IO模型，NIO所提供的类是在java.nio包中。 </p></li><li><p>JAVA API中提供了两套NIO: 一套是针对文件操作的NIO，另一套就是网络编程的NIO </p></li><li><p>NIO是一种非阻塞式IO </p></li></ol><p>核心的部分 </p><p>JAVA NIO中最为核心的部分：Buffer(缓冲区) ， Channel(通道) 。在网络编程的NIO模型中，还有一个核心部分：Selector（选择器） </p><ol><li><p>Buffer(缓冲区)</p><p>缓冲区分为直接缓冲区和堆字节缓冲区。 </p><p>我们既可以从Buffer中读取数据，也可以向Buffer中写数据，因此， Buffer分为两种模式：写模式和读模式。为了理解Buffer的工作原理，需要熟悉它的三个属性： </p><ul><li>capacity（容量）</li><li>position（位置）</li><li>limit（限制）</li></ul><p>写模式</p><img src="/blog/2020/08/09/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/pic26.png" srcset="/blog/img/loading.gif" class><ul><li>capacity：数组中可以存储元素的个数。</li><li>position：下一次可插入元素的位置，默认值为0，每添加一次元素向后移动一位。最大值：capacity - 1</li><li>limit：在写模式下，limit表示第一个不可写的位置（默认第一个不可写的位置，应该是数组容量值的下一个位置，limit是从0开始计算，因此默认值等于capacity的值）。</li></ul><p>读模式</p><img src="/blog/2020/08/09/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/pic27.png" srcset="/blog/img/loading.gif" class><ul><li>capacity：数组中可以存储元素的个数</li><li>position：当读取数据时，也是从某个特定位置读。当将Buffer从写模式切换到读模式（一般情况下我们在进行读取数据之前都需要对Buffer做一个读写转换），position会被重置为0。当从Buffer的position处读取数据时，position向前移动到下一个可读的位置。 </li><li>limit：在读模式下，limit表示第一个不可读的位置，从0开始进行计算。当切换Buffer到读模式 时，limit会被设置成写模式下的position值。换句话说，你能读到之前写入的所有数据；</li></ul></li><li><p>Channel(通道) </p><p>Java NIO的通道类似流(用于进行数据传输)，但和流是不同的。 </p><p>区别：通道是双向的，而流是单向的(大部分流对象的功能都是比较单一，要么进行读数据要么进行写数据)。 </p><p>通道使用的时候需要结合Buffffer。要将操作的数据从源打包到缓冲区中，而缓冲区中的数据想要传输到目的地是要依赖于通道的。NIO 技术中的数据要放在缓区中进行管理，再使用通道将缓冲区中的数据传输到目的地。通道中的数据总是要先读到一个Buffffer(从通道读取数据到缓冲区)，或者总是要从一个Buffffer中写入(从缓冲区写入数据到通道)。如下图所示： </p><img src="/blog/2020/08/09/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/pic28.png" srcset="/blog/img/loading.gif" class></li><li><p>Selector(选择器) </p><p>每一个通道都存在一个线程对其进行处理。如果在高并发环境下，就会存在很多个通道，那么就会创建很多的线程对象，造成内存占用率升高，增加CPU在多个线程之间切换的时间，因此，此种设计就不适用于高并发的场景。如下图所示：</p><img src="/blog/2020/08/09/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/pic29.png" srcset="/blog/img/loading.gif" class><img src="/blog/2020/08/09/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/pic30.png" srcset="/blog/img/loading.gif" class><p>这种通过一个线程来处理多个通道任务的机制，在NIO技术中称为”IO多路复用”。 </p><p>使用了I/O多路复用后，只需要使用1个线程就可操作多个通道，这对高并发高频段处理的业务环境有非常重要的优势。注：线程数会随着通道的多少动态地增减以进行适配，在内部其实并不永远是一个线程，多路复用的核心目的就是使用最少的线程去操作更多的通道JDK的源代码中，创建线程的个数是根据通道的数量来决定的，每注册1023个通道就创建1个新的线程。</p></li></ol><h5 id="NIO多路复用解决BIO并发"><a href="#NIO多路复用解决BIO并发" class="headerlink" title="NIO多路复用解决BIO并发"></a>NIO多路复用解决BIO并发</h5><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    <span class="hljs-comment">// 打开一个ServerSocketChannel通道</span>    ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();    <span class="hljs-comment">// 为ServerSocketChannel绑定地址信息(主机地址和端口号)</span>    serverSocketChannel.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-number">8080</span>));    <span class="hljs-comment">// 设置ServerSocketChannel为非阻塞</span>    serverSocketChannel.configureBlocking(<span class="hljs-keyword">false</span>);    <span class="hljs-comment">// 开启一个选择器</span>    Selector selector = Selector.open();    <span class="hljs-comment">// 将ServerSocketChannel通道注册到选择器上</span>    <span class="hljs-comment">// SelectionKey.OP_ACCEPT接收连接进行事件，表示服务器监听到了客户连接，那么服务器可 以接收这个连接了</span>    serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);    <span class="hljs-comment">// 需要不断的进行选择操作，选择哪些具有就绪任务的通道信息</span>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;        System.out.println(<span class="hljs-string">"等待连接，阻塞中...."</span>);        <span class="hljs-comment">// 调用选择器select()方法进行选择操作</span>        <span class="hljs-keyword">int</span> count = selector.select();        <span class="hljs-comment">// 此方法是一个阻塞方法，如果没有就绪 任务的通道此方法阻塞</span>        <span class="hljs-keyword">if</span> (count != <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// 调用Selector的selectedKeys()方法，获取"已选择的键的集合"</span>            Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();            <span class="hljs-comment">// 遍历集合</span>            Iterator&lt;SelectionKey&gt; iterator = selectedKeys.iterator();            <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;                <span class="hljs-comment">// 获取每一个SelectionKey</span>                SelectionKey selectionKey = iterator.next();                <span class="hljs-comment">// 判断每一个SelectionKey的就绪任务类型，针对不同的任务给出不同的处理 方案</span>                <span class="hljs-keyword">if</span> (selectionKey.isAcceptable()) &#123;                    <span class="hljs-comment">// 可接收连接任务就绪 </span>                    System.out.println(<span class="hljs-string">"客户端连接成功，但尚未发送数据"</span>);                    <span class="hljs-comment">// 获取该SelectionKey所关联的通道</span>                    ServerSocketChannel ssc = (ServerSocketChannel) selectionKey.channel();                    SocketChannel socketChannel = ssc.accept();                    <span class="hljs-comment">// 获取一个连接 </span>                    socketChannel.configureBlocking(<span class="hljs-keyword">false</span>);                    <span class="hljs-comment">// 将其设置为非阻塞 </span>                    <span class="hljs-comment">// 将该通道注册到选择器上，读就绪事件，表示通道中已经有了可读的数 据，可以执行读操作了 </span>                    socketChannel.register(selector, SelectionKey.OP_READ);                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (selectionKey.isReadable()) &#123;                    <span class="hljs-comment">// 可读取数据的任务就 绪 </span>                    System.out.println(<span class="hljs-string">"客户端成功发送数据"</span>);                    <span class="hljs-comment">// 获取该SelectionKey所关联的通道 </span>                    SocketChannel socketChannel = (SocketChannel) selectionKey.channel();                    <span class="hljs-comment">// 读取通道中的数据</span>                    ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);                    <span class="hljs-keyword">int</span> read = socketChannel.read(buffer);                    <span class="hljs-keyword">while</span> (read &gt; <span class="hljs-number">0</span>) &#123;                        <span class="hljs-comment">// 将Buffer从写模式切换到读模式 </span>                        buffer.flip();                        System.out.print(<span class="hljs-keyword">new</span> String(buffer.array(), <span class="hljs-number">0</span>, read));                        <span class="hljs-comment">//清除此缓冲区(数据还在)。位置设置为零，限制设置为容量</span>                        buffer.clear();                        read = socketChannel.read(buffer);                    &#125;                    <span class="hljs-comment">// 释放资源 </span>                    socketChannel.close();                &#125;                <span class="hljs-comment">// 任务处理完毕以后，将SelectionKey从"已选择的键的集合"移除掉</span>                iterator.remove();            &#125;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TCP/IP</tag>
      
      <tag>网络协议</tag>
      
      <tag>NIO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty源码剖析</title>
    <link href="/blog/2020/08/08/netty-%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    <url>/blog/2020/08/08/netty-%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h3 id="服务端启动过程"><a href="#服务端启动过程" class="headerlink" title="服务端启动过程"></a>服务端启动过程</h3><h4 id="创建服务端Channel"><a href="#创建服务端Channel" class="headerlink" title="创建服务端Channel"></a>创建服务端Channel</h4><p>主要流程：</p><ul><li><p>ServerBootstrap对象的bind()⽅法，也是⼊⼝⽅法</p></li><li><p>AbstractBootstrap中的initAndRegister()进⾏创建Channel</p><ul><li>创建Channel的⼯作由ReflectiveChannelFactory反射类中的newChannel()⽅法完成。</li></ul></li><li><p>NioServerSocketChannel中的构造⽅法中，通过jdk nio底层的SelectorProvider打开ServerSocketChannel。</p></li><li><p>在AbstractNioChannel的构造⽅法中，设置channel为⾮阻塞：ch.configureBlocking(false);</p></li><li><p>通过的AbstractChannel的构造⽅法，创建了id、unsafe、pipeline内容。</p></li><li><p>通过NioServerSocketChannelConfig获取tcp底层的⼀些参数</p></li></ul><h4 id="初始化服务端Channel"><a href="#初始化服务端Channel" class="headerlink" title="初始化服务端Channel"></a>初始化服务端Channel</h4><p>主流程：</p><ul><li><p>AbstractBootstrap中的initAndRegister()进⾏初始化channel，代码：init(channel);</p></li><li><p>在ServerBootstrap中的init()⽅法设置channelOptions以及Attributes。</p></li><li><p>紧接着，将⽤户⾃定义参数、属性保存到局部变量currentChildOptions、currentChildAttrs，以供后⾯使⽤</p></li><li><p>如果设置了serverBootstrap.handler()的话，会加⼊到pipeline中。</p></li><li><p>添加连接器ServerBootstrapAcceptor，有新连接加⼊后，将⾃定义的childHandler加⼊到连接的pipeline中：</p><pre><code class="hljs java">ch.eventLoop().execute(<span class="hljs-keyword">new</span> Runnable() &#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        pipeline.addLast(<span class="hljs-keyword">new</span> ChannelHandler[]&#123;<span class="hljs-keyword">new</span> ServerBootstrap.ServerBootstrapAcceptor(ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs)&#125;);    &#125;&#125;);</code></pre><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;    <span class="hljs-comment">//当客户端有连接时才会执⾏</span>    <span class="hljs-keyword">final</span> Channel child = (Channel) msg;    child.pipeline().addLast(childHandler);    <span class="hljs-comment">//将⾃定义的childHandler加⼊到连接的pipeline中</span>    setChannelOptions(child, childOptions, logger);    setAttributes(child, childAttrs);    <span class="hljs-keyword">try</span> &#123;        childGroup.register(child).addListener(<span class="hljs-keyword">new</span> ChannelFutureListener()        &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuture future)</span> <span class="hljs-keyword">throws</span></span><span class="hljs-function">                    Exception </span>&#123;                <span class="hljs-keyword">if</span> (!future.isSuccess()) &#123;                    forceClose(child, future.cause());                &#125;            &#125;        &#125;);    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;        forceClose(child, t);    &#125;&#125;</code></pre></li></ul><h4 id="注册selector"><a href="#注册selector" class="headerlink" title="注册selector"></a>注册selector</h4><p>主要流程：</p><ul><li><p>initAndRegister()⽅法中的ChannelFuture regFuture = config().group().register(channel); 进⾏注册</p></li><li><p>在io.netty.channel.AbstractChannel.AbstractUnsafe#register()中完成实际的注册</p><ul><li><p>AbstractChannel.this.eventLoop = eventLoop; 进⾏eventLoop的赋值操作，后续的IO事件⼯作将在由该eventLoop执⾏。</p></li><li><p>调⽤register0(promise)中的doRegister()进⾏实际的注册</p><ul><li><p>io.netty.channel.nio.AbstractNioChannel#doRegister进⾏了⽅法实现</p><pre><code class="hljs java"><span class="hljs-comment">//通过jdk底层进⾏注册多路复⽤器</span><span class="hljs-comment">//javaChannel() --前⾯创建的channel</span><span class="hljs-comment">//eventLoop().unwrappedSelector() -- 获取selector</span><span class="hljs-comment">//注册感兴趣的事件为0，表明没有感兴趣的事件，后⾯会进⾏重新注册事件</span><span class="hljs-comment">//将this对象以attachment的形式注册到selector，⽅便后⾯拿到当前对象的内容</span>selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>);</code></pre></li></ul></li></ul></li></ul><h4 id="绑定端⼝"><a href="#绑定端⼝" class="headerlink" title="绑定端⼝"></a>绑定端⼝</h4><p>主要流程：</p><ul><li><p>⼊⼝在io.netty.bootstrap.AbstractBootstrap#doBind0()，启动⼀个线程进⾏执⾏绑定端⼝操作调⽤io.netty.channel.AbstractChannelHandlerContext#bind(java.net.SocketAddress,</p></li><li><p>io.netty.channel.ChannelPromise)⽅法，再次启动线程执⾏</p></li><li><p>最终调⽤io.netty.channel.socket.nio.NioServerSocketChannel#doBind()⽅法进⾏绑定操作</p><pre><code class="hljs java"><span class="hljs-comment">//通过jdk底层的channel进⾏绑定</span><span class="hljs-meta">@SuppressJava</span>6Requirement(    reason = <span class="hljs-string">"Usage guarded by java version check"</span>)<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doBind</span><span class="hljs-params">(SocketAddress localAddress)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    <span class="hljs-keyword">if</span> (PlatformDependent.javaVersion() &gt;= <span class="hljs-number">7</span>) &#123;        <span class="hljs-keyword">this</span>.javaChannel().bind(localAddress, <span class="hljs-keyword">this</span>.config.getBacklog());    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">this</span>.javaChannel().socket().bind(localAddress, <span class="hljs-keyword">this</span>.config.getBacklog());    &#125;&#125;</code></pre></li><li><p>什么时候进⾏更新selector的主从事件？</p><ul><li><p>最终在io.netty.channel.nio.AbstractNioChannel#doBeginRead()⽅法中完成的</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doBeginRead</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    <span class="hljs-comment">// Channel.read() or ChannelHandlerContext.read() was called</span>    <span class="hljs-keyword">final</span> SelectionKey selectionKey = <span class="hljs-keyword">this</span>.selectionKey;    <span class="hljs-keyword">if</span> (!selectionKey.isValid()) &#123;        <span class="hljs-keyword">return</span>;    &#125;    readPending = <span class="hljs-keyword">true</span>;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> interestOps = selectionKey.interestOps();    <span class="hljs-keyword">if</span> ((interestOps &amp; readInterestOp) == <span class="hljs-number">0</span>) &#123;        selectionKey.interestOps(interestOps | readInterestOp); <span class="hljs-comment">//设置</span>        感兴趣的事件为OP_ACCEPT    &#125;&#125;<span class="hljs-comment">//在NioServerSocketChannel的构造⽅法中进⾏了赋值</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NioServerSocketChannel</span><span class="hljs-params">(ServerSocketChannel channel)</span> </span>&#123;    <span class="hljs-keyword">super</span>(<span class="hljs-keyword">null</span>, channel, SelectionKey.OP_ACCEPT);    config = <span class="hljs-keyword">new</span> NioServerSocketChannelConfig(<span class="hljs-keyword">this</span>,            javaChannel().socket());&#125;</code></pre></li></ul></li></ul><h3 id="连接请求过程源码剖析"><a href="#连接请求过程源码剖析" class="headerlink" title="连接请求过程源码剖析"></a>连接请求过程源码剖析</h3><h4 id="新连接的接⼊"><a href="#新连接的接⼊" class="headerlink" title="新连接的接⼊"></a>新连接的接⼊</h4><p>主要流程：</p><ul><li><p>⼊⼝在io.netty.channel.nio.NioEventLoop#processSelectedKey(java.nio.channels.SelectionKey,io.netty.channel.nio.AbstractNioChannel)中</p><ul><li><p>进⼊NioMessageUnsafe的read()⽅法</p></li><li><p>调⽤io.netty.channel.socket.nio.NioServerSocketChannel#doReadMessages() ⽅法，创建jdk底层的channel，封装成NioSocketChannel添加到List容器中</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">doReadMessages</span><span class="hljs-params">(List&lt;Object&gt; buf)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    SocketChannel ch = SocketUtils.accept(<span class="hljs-keyword">this</span>.javaChannel());    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">if</span> (ch != <span class="hljs-keyword">null</span>) &#123;            buf.add(<span class="hljs-keyword">new</span> NioSocketChannel(<span class="hljs-keyword">this</span>, ch));            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        &#125;    &#125; <span class="hljs-keyword">catch</span> (Throwable var6) &#123;        logger.warn(<span class="hljs-string">"Failed to create a new channel from an accepted socket."</span>, var6);        <span class="hljs-keyword">try</span> &#123;            ch.close();        &#125; <span class="hljs-keyword">catch</span> (Throwable var5) &#123;            logger.warn(<span class="hljs-string">"Failed to close a socket."</span>, var5);        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></li></ul></li><li><p>创建NioSocketChannel对象</p><ul><li><p>new NioSocketChannel(this, ch)，通过new的⽅式进⾏创建</p><ul><li><p>调⽤super的构造⽅法</p><ul><li>传⼊SelectionKey.OP_READ事件标识</li><li>创建id、unsafe、pipeline对象</li><li>设置⾮阻塞 ch.configureBlocking(false);</li></ul></li><li><p>创建NioSocketChannelConfig对象</p></li></ul></li></ul></li></ul><h4 id="注册读事件"><a href="#注册读事件" class="headerlink" title="注册读事件"></a>注册读事件</h4><ul><li><p>在io.netty.channel.nio.AbstractNioMessageChannel.NioMessageUnsafe中的：</p><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; localRead; ++i) &#123;    AbstractNioMessageChannel.<span class="hljs-keyword">this</span>.readPending = <span class="hljs-keyword">false</span>;    pipeline.fireChannelRead(<span class="hljs-keyword">this</span>.readBuf.get(i));&#125;</code></pre></li><li><p>在io.netty.channel.AbstractChannelHandlerContext#invokeChannelRead(java.lang.Object)⽅法中:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeChannelRead</span><span class="hljs-params">(Object msg)</span> </span>&#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.invokeHandler()) &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//执⾏channelRead，需要注意的是，第⼀次执⾏是HeadHandler，第⼆次是ServerBootstrapAcceptor</span>            <span class="hljs-comment">//通过ServerBootstrapAcceptor进⼊和 新连接接⼊的 注册selector相同的逻辑进⾏注册以及事件绑定</span>            ((ChannelInboundHandler)<span class="hljs-keyword">this</span>.handler()).channelRead(<span class="hljs-keyword">this</span>, msg);        &#125; <span class="hljs-keyword">catch</span> (Throwable var3) &#123;            <span class="hljs-keyword">this</span>.invokeExceptionCaught(var3);        &#125;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">this</span>.fireChannelRead(msg);    &#125;&#125;</code></pre></li></ul><h3 id="优化建议"><a href="#优化建议" class="headerlink" title="优化建议"></a>优化建议</h3><h4 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h4><p>Netty的零拷⻉主要体现在三个⽅⾯：</p><ul><li><p>Bytebuf 使⽤的是⽤池化的Direct Buffer类型使⽤的堆外内存，不需要进⾏字节缓冲区的⼆次拷⻉，如果使⽤堆内存，JVM会先拷⻉到堆内，再写⼊Socket，就多了⼀次拷⻉。</p></li><li><p>CompositeByteBuf将多个ByteBuf封装成⼀个ByteBuf，在添加ByteBuf时不需要进程拷⻉。</p></li><li><p>Netty的⽂件传输类DefaultFileRegion的transferTo⽅法将⽂件发送到⽬标channel中，不需要进⾏循环拷⻉，提升了性能。</p></li></ul><h4 id="使⽤EventLoop的任务调度"><a href="#使⽤EventLoop的任务调度" class="headerlink" title="使⽤EventLoop的任务调度"></a>使⽤EventLoop的任务调度</h4><p>在EventLoop的⽀持线程外使⽤channel：</p><pre><code class="hljs java">channel.eventLoop().execute(<span class="hljs-keyword">new</span> Runnable() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        channel.writeAndFlush(data);    &#125;&#125;);</code></pre><p>⽽不是直接使⽤channel.writeAndFlush(data)；</p><p>前者会直接放⼊channel所对应的EventLoop的执⾏队列，⽽后者会导致线程的切换。</p><blockquote><p>在writeAndFlush的底层，如果没有通过eventLoop执⾏的话，就会重新启动新的线程执⾏。</p></blockquote><h4 id="减少ChannelPipline的调⽤⻓度"><a href="#减少ChannelPipline的调⽤⻓度" class="headerlink" title="减少ChannelPipline的调⽤⻓度"></a>减少ChannelPipline的调⽤⻓度</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">YourHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> </span>&#123;        <span class="hljs-comment">// BAD (most of the times)</span>        ctx.channel().writeAndFlush(msg);        <span class="hljs-comment">// GOOD</span>        ctx.writeAndFlush(msg);    &#125;&#125;</code></pre><p>前者是将msg从整个ChannelPipline中⾛⼀遍，所有的handler都要经过，⽽后者是从当前handler⼀直到pipline的尾部，调⽤更短。</p><h4 id="减少ChannelHandler的创建"><a href="#减少ChannelHandler的创建" class="headerlink" title="减少ChannelHandler的创建"></a>减少ChannelHandler的创建</h4><p>如果channelhandler是⽆状态的（即不需要保存任何状态参数），那么使⽤Sharable注解，并在bootstrap时只创建⼀个实例，减少GC。否则每次连接都会new出handler对象。</p><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Shareable<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StatelessHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> </span>&#123;&#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">Channel</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ChannelHandler INSTANCE = <span class="hljs-keyword">new</span> StatelessHandler();    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel ch)</span> </span>&#123;        ch.pipeline().addLast(INSTANCE);    &#125;&#125;</code></pre><p>同时需要注意ByteToMessageDecoder之类的编解码器是有状态的，不能使⽤Sharable注解。</p><h4 id="⼀些配置参数的设置"><a href="#⼀些配置参数的设置" class="headerlink" title="⼀些配置参数的设置"></a>⼀些配置参数的设置</h4><p>ServerBootstrap启动时，通常bossGroup只需要设置为1即可，因为ServerSocketChannel在初始化阶段，只会注册到某⼀个eventLoop上，⽽这个eventLoop只会有⼀个线程在运⾏，所以没有必要设置为多线程。⽽ IO 线程，为了充分利⽤ CPU，同时考虑减少线上下⽂切换的开销，通常设置为 CPU 核数的两倍，这也是 Netty 提供的默认值。</p><p>在对于响应时间有⾼要求的场景，使⽤.childOption(ChannelOption.TCP_NODELAY, true)和.option(ChannelOption.TCP_NODELAY, true)来禁⽤nagle算法，不等待，⽴即发送。</p>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
      <tag>源码阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自定义RPC框架</title>
    <link href="/blog/2020/08/08/netty-%E8%87%AA%E5%AE%9A%E4%B9%89RPC%E6%A1%86%E6%9E%B6/"/>
    <url>/blog/2020/08/08/netty-%E8%87%AA%E5%AE%9A%E4%B9%89RPC%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="设计说明"><a href="#设计说明" class="headerlink" title="设计说明"></a>设计说明</h3><img src="/blog/2020/08/08/netty-%E8%87%AA%E5%AE%9A%E4%B9%89RPC%E6%A1%86%E6%9E%B6/pic1.png" srcset="/blog/img/loading.gif" class><ul><li><p>服务端</p><ul><li>接收到客户端发来的消息后，进⾏解码操作</li><li>根据消息中的接⼝信息，通过反射找到其实现类，执⾏⽬标⽅法</li><li>将返回的数据再进⾏编码操作，发送给客户端</li></ul></li><li><p>客户端</p><ul><li>客户端通过代理的⽅式，获取到接⼝的代理类</li><li>通过代理类进⾏发送消息，实际上是向服务端发送消息</li><li>通过编码器将消息进⾏编码操作</li><li>接收到服务端的响应后，进⾏解码操作，返回数据给⽅法的调⽤⽅</li></ul></li><li><p>注册中⼼</p><ul><li>暂不做实现</li></ul></li></ul><h3 id="⾃定义协议"><a href="#⾃定义协议" class="headerlink" title="⾃定义协议"></a>⾃定义协议</h3><p>分别定义请求对象和响应对象，⽤于数据的传输。</p><p>需要注意的是，RpcRequest、RpcResponse要序列化传输，需要实现java.io.Serializable接⼝。</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.myrpc.core.base;<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseRpcBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-keyword">private</span> String requestId; <span class="hljs-comment">//请求id</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getRequestId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> requestId;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRequestId</span><span class="hljs-params">(String requestId)</span> </span>&#123;        <span class="hljs-keyword">this</span>.requestId = requestId;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.myrpc.core.base;<span class="hljs-keyword">import</span> java.util.Arrays;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RpcRequest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseRpcBean</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = -<span class="hljs-number">4403913516658154989L</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> createMillisTime; <span class="hljs-comment">//创建请求时间</span>    <span class="hljs-keyword">private</span> String className; <span class="hljs-comment">//类名称，全包路径</span>    <span class="hljs-keyword">private</span> String methodName; <span class="hljs-comment">//执⾏⽅法名</span>    <span class="hljs-keyword">private</span> Class&lt;?&gt;[] parameterTypes; <span class="hljs-comment">//⽅法中的参数类型</span>    <span class="hljs-keyword">private</span> Object[] parameters; <span class="hljs-comment">//执⾏⽅法传⼊的参数</span><span class="hljs-comment">// getter、setter、toString⽅法省略，实际使⽤时⾃⼰⽣成</span>&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.myrpc.core.base;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RpcResponse</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseRpcBean</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = -<span class="hljs-number">7276479460065645174L</span>;    <span class="hljs-keyword">private</span> String errorMsg; <span class="hljs-comment">//错误消息</span>    <span class="hljs-keyword">private</span> Object result; <span class="hljs-comment">//结果数据</span><span class="hljs-comment">// getter、setter、toString⽅法省略，实际使⽤时⾃⼰⽣成</span>&#125;</code></pre><h3 id="编解码器"><a href="#编解码器" class="headerlink" title="编解码器"></a>编解码器</h3><p>编解码器是在服务端以及客户端通⽤的，所以设计时需要考虑其通⽤性，不能将泛型对象硬编码到代码中。</p><p>编码器：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.myrpc.core.codec;<span class="hljs-keyword">import</span> cn.itcast.myrpc.core.base.BaseRpcBean;<span class="hljs-keyword">import</span> cn.itcast.myrpc.core.util.HessianSerializer;<span class="hljs-keyword">import</span> cn.itcast.myrpc.core.util.MySerializer;<span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<span class="hljs-keyword">import</span> io.netty.handler.codec.MessageToByteEncoder;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 编码器</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyEncoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MessageToByteEncoder</span>&lt;<span class="hljs-title">BaseRpcBean</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> MySerializer hessianSerializer = <span class="hljs-keyword">new</span> HessianSerializer();    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(ChannelHandlerContext ctx, BaseRpcBean msg, ByteBuf</span></span><span class="hljs-function"><span class="hljs-params">            out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">byte</span>[] bytes = hessianSerializer.serialize(msg);        out.writeInt(bytes.length);        out.writeBytes(bytes);    &#125;&#125;</code></pre><p>解码器：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.myrpc.core.codec;<span class="hljs-keyword">import</span> cn.itcast.myrpc.core.base.BaseRpcBean;<span class="hljs-keyword">import</span> cn.itcast.myrpc.core.util.HessianSerializer;<span class="hljs-keyword">import</span> cn.itcast.myrpc.core.util.MySerializer;<span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<span class="hljs-keyword">import</span> io.netty.handler.codec.ReplayingDecoder;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 解码器</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyDecoder</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseRpcBean</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">ReplayingDecoder</span>&lt;<span class="hljs-title">Void</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> MySerializer hessianSerializer = <span class="hljs-keyword">new</span> HessianSerializer();    <span class="hljs-keyword">private</span> Class&lt;T&gt; clazz;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyDecoder</span><span class="hljs-params">(Class&lt;T&gt; clazz)</span> </span>&#123;        <span class="hljs-keyword">this</span>.clazz = clazz;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt;</span></span><span class="hljs-function"><span class="hljs-params">            out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[in.readInt()];        in.readBytes(bytes);        BaseRpcBean rpcBean = hessianSerializer.deserialize(bytes, clazz);        out.add(rpcBean);    &#125;&#125;</code></pre><p>Hessian序列化：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.myrpc.core.util;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MySerializer</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 将对象序列化成字节数组</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> obj</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    &lt;T&gt; <span class="hljs-keyword">byte</span>[] serialize(T obj);    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 将字节数组反序列化成对象</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bytes</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> clazz</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">deserialize</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] bytes, Class&lt;T&gt; clazz)</span></span>;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.myrpc.core.util;<span class="hljs-keyword">import</span> com.caucho.hessian.io.HessianInput;<span class="hljs-keyword">import</span> com.caucho.hessian.io.HessianOutput;<span class="hljs-keyword">import</span> java.io.ByteArrayInputStream;<span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Hessian序列化⼯具类</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HessianSerializer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MySerializer</span> </span>&#123;    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-keyword">byte</span>[] serialize(T obj) &#123;        ByteArrayOutputStream os = <span class="hljs-keyword">new</span> ByteArrayOutputStream();        HessianOutput ho = <span class="hljs-keyword">new</span> HessianOutput(os);        <span class="hljs-keyword">try</span> &#123;            ho.writeObject(obj);            ho.flush();            <span class="hljs-keyword">return</span> os.toByteArray();        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-keyword">try</span> &#123;                ho.close();            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);            &#125;            <span class="hljs-keyword">try</span> &#123;                os.close();            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);            &#125;        &#125;    &#125;    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">deserialize</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] bytes, Class&lt;T&gt; clazz)</span> </span>&#123;        ByteArrayInputStream is = <span class="hljs-keyword">new</span> ByteArrayInputStream(bytes);        HessianInput hi = <span class="hljs-keyword">new</span> HessianInput(is);        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">return</span> (T) hi.readObject(clazz);        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-keyword">try</span> &#123;                hi.close();            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);            &#125;            <span class="hljs-keyword">try</span> &#123;                is.close();            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);            &#125;        &#125;    &#125;&#125;</code></pre><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><h4 id="NettyServer"><a href="#NettyServer" class="headerlink" title="NettyServer"></a>NettyServer</h4><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.myrpc.core.server;<span class="hljs-keyword">import</span> io.netty.bootstrap.ServerBootstrap;<span class="hljs-keyword">import</span> io.netty.channel.ChannelFuture;<span class="hljs-keyword">import</span> io.netty.channel.EventLoopGroup;<span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;<span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;<span class="hljs-keyword">import</span> org.slf4j.Logger;<span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyServer</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER =            LoggerFactory.getLogger(NettyServer<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">(String host, <span class="hljs-keyword">int</span> port)</span> </span>&#123;        doStart(host, port);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doStart</span><span class="hljs-params">(String host, <span class="hljs-keyword">int</span> port)</span> </span>&#123;        <span class="hljs-comment">// 主线程，不处理任何业务逻辑，只是接收客户的连接请求</span>        EventLoopGroup boss = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);        <span class="hljs-comment">// ⼯作线程，线程数默认是：cpu*2</span>        EventLoopGroup worker = <span class="hljs-keyword">new</span> NioEventLoopGroup();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 服务器启动类</span>            ServerBootstrap serverBootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();            serverBootstrap.group(boss, worker) <span class="hljs-comment">//设置线程组</span>                    .channel(NioServerSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>) //配置<span class="hljs-title">server</span>通道</span><span class="hljs-class">                    .<span class="hljs-title">childHandler</span>(<span class="hljs-title">new</span> <span class="hljs-title">ServerInitializer</span>())</span>; <span class="hljs-comment">//worker线程的处理器</span>            ChannelFuture future = serverBootstrap.bind(host, port).sync();            LOGGER.info(<span class="hljs-string">"服务器启动完成，地址为："</span> + host + <span class="hljs-string">":"</span> + port);            <span class="hljs-comment">//等待服务端监听端⼝关闭</span>            future.channel().closeFuture().sync();        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            LOGGER.error(<span class="hljs-string">"服务器启动失败！"</span>, e);        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-comment">//优雅关闭</span>            boss.shutdownGracefully();            worker.shutdownGracefully();        &#125;    &#125;&#125;</code></pre><h4 id="ServerInitializer"><a href="#ServerInitializer" class="headerlink" title="ServerInitializer"></a>ServerInitializer</h4><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.myrpc.core.server;<span class="hljs-keyword">import</span> cn.itcast.myrpc.core.base.RpcRequest;<span class="hljs-keyword">import</span> cn.itcast.myrpc.core.codec.MyDecoder;<span class="hljs-keyword">import</span> cn.itcast.myrpc.core.codec.MyEncoder;<span class="hljs-keyword">import</span> com.ryhx.drools.test.ServerHandler;<span class="hljs-keyword">import</span> io.netty.channel.ChannelInitializer;<span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">SocketChannel</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ch.pipeline()                .addLast(<span class="hljs-keyword">new</span> MyDecoder(RpcRequest<span class="hljs-class">.<span class="hljs-keyword">class</span>)) //解码器，需要解码的对象是<span class="hljs-title">RpcRequest</span></span><span class="hljs-class">                .<span class="hljs-title">addLast</span>(<span class="hljs-title">new</span> <span class="hljs-title">MyEncoder</span>()) //编码器，⽤于数据的响应</span><span class="hljs-class">                .<span class="hljs-title">addLast</span>(<span class="hljs-title">new</span> <span class="hljs-title">ServerHandler</span>())</span>; <span class="hljs-comment">//⾃定义逻辑</span>    &#125;&#125;</code></pre><h4 id="ServerHandler"><a href="#ServerHandler" class="headerlink" title="ServerHandler"></a>ServerHandler</h4><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.myrpc.core.server;<span class="hljs-keyword">import</span> cn.itcast.myrpc.core.base.RpcRequest;<span class="hljs-keyword">import</span> cn.itcast.myrpc.core.base.RpcResponse;<span class="hljs-keyword">import</span> cn.itcast.myrpc.core.util.ClassUtil;<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<span class="hljs-keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;<span class="hljs-keyword">import</span> org.slf4j.Logger;<span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<span class="hljs-keyword">import</span> java.lang.reflect.Method;<span class="hljs-keyword">import</span> java.util.ArrayList;<span class="hljs-keyword">import</span> java.util.HashMap;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">RpcRequest</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER =            LoggerFactory.getLogger(ServerHandler<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;Class&lt;?&gt;, Object&gt; OBJECT_MAP = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, RpcRequest request)</span></span><span class="hljs-function">            <span class="hljs-keyword">throws</span> Exception </span>&#123;        RpcResponse rpcResponse = <span class="hljs-keyword">new</span> RpcResponse();        rpcResponse.setRequestId(request.getRequestId());        LOGGER.info(<span class="hljs-string">"开始处理消息：requestId = "</span> + request.getRequestId());        <span class="hljs-keyword">try</span> &#123;            Class&lt;?&gt; clazz = Class.forName(request.getClassName());            <span class="hljs-keyword">if</span> (!OBJECT_MAP.containsKey(clazz)) &#123;                <span class="hljs-comment">//获取接⼝的实现类，这⾥只获取第⼀个实现类，忽略其他实现类</span>                ArrayList&lt;Class&gt; allClassByInterface =                        ClassUtil.getAllClassByInterface(clazz);                <span class="hljs-keyword">for</span> (Class c : allClassByInterface) &#123;                    <span class="hljs-comment">//将对象缓存起来，提升效率</span>                    OBJECT_MAP.put(clazz, c.newInstance());                    <span class="hljs-keyword">break</span>;                &#125;            &#125;            <span class="hljs-comment">//通过反射找到⽅法执⾏</span>            Method method = clazz.getMethod(request.getMethodName(),                    request.getParameterTypes());            method.setAccessible(<span class="hljs-keyword">true</span>);            Object result = method.invoke(OBJECT_MAP.get(clazz),                    request.getParameters());            rpcResponse.setResult(result);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            LOGGER.error(<span class="hljs-string">"处理失败... requestId = "</span> + request.getRequestId(),                    e);            <span class="hljs-comment">//出错</span>            rpcResponse.setErrorMsg(<span class="hljs-string">"error"</span>);        &#125;        ctx.writeAndFlush(rpcResponse);    &#125;&#125;</code></pre><h4 id="ClassUtil"><a href="#ClassUtil" class="headerlink" title="ClassUtil"></a>ClassUtil</h4><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.myrpc.core.util;<span class="hljs-keyword">import</span> org.slf4j.Logger;<span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<span class="hljs-keyword">import</span> java.io.File;<span class="hljs-keyword">import</span> java.net.JarURLConnection;<span class="hljs-keyword">import</span> java.net.URL;<span class="hljs-keyword">import</span> java.util.ArrayList;<span class="hljs-keyword">import</span> java.util.Enumeration;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">import</span> java.util.jar.JarEntry;<span class="hljs-keyword">import</span> java.util.jar.JarFile;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 获取接⼝的所有实现类 理论上也可以⽤来获取类的所有⼦类</span><span class="hljs-comment"> * 查询路径有限制，只局限于接⼝所在模块下，⽐如pandora-gateway,⽽⾮整个pandora（会递归搜</span><span class="hljs-comment"> * 索该⽂件夹下所以的实现类）</span><span class="hljs-comment"> * 路径中不可含中⽂，否则会异常。若要⽀持中⽂路径，需对该模块代码中url.getPath() 返回值进⾏</span><span class="hljs-comment"> * urldecode.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassUtil</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOG = LoggerFactory.getLogger(ClassUtil<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ArrayList&lt;Class&gt; <span class="hljs-title">getAllClassByInterface</span><span class="hljs-params">(Class clazz)</span> </span>&#123;        ArrayList&lt;Class&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-comment">// 判断是否是⼀个接⼝</span>        <span class="hljs-keyword">if</span> (clazz.isInterface()) &#123;            <span class="hljs-keyword">try</span> &#123;                ArrayList&lt;Class&gt; allClass =                        getAllClass(clazz.getPackage().getName());                <span class="hljs-comment">/**</span><span class="hljs-comment">                 * 循环判断路径下的所有类是否实现了指定的接⼝ 并且排除接⼝类⾃⼰</span><span class="hljs-comment">                 */</span>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; allClass.size(); i++) &#123;                    <span class="hljs-comment">/**</span><span class="hljs-comment">                     * 判断是不是同⼀个接⼝</span><span class="hljs-comment">                     */</span>                    <span class="hljs-comment">// isAssignableFrom:判定此 Class 对象所表示的类或接⼝与指定的Class</span>                    <span class="hljs-comment">// 参数所表示的类或接⼝是否相同，或是否是其超类或超接⼝</span>                    <span class="hljs-keyword">if</span> (clazz.isAssignableFrom(allClass.get(i))) &#123;                        <span class="hljs-keyword">if</span> (!clazz.equals(allClass.get(i))) &#123;                            <span class="hljs-comment">// ⾃身并不加进去</span>                            list.add(allClass.get(i));                        &#125;                    &#125;                &#125;            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                LOG.error(<span class="hljs-string">"出现异常&#123;&#125;"</span>, e.getMessage());                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"出现异常"</span> + e.getMessage());            &#125;        &#125;        LOG.info(<span class="hljs-string">"class list size :"</span> + list.size());        <span class="hljs-keyword">return</span> list;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 从⼀个指定路径下查找所有的类</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> packagename</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ArrayList&lt;Class&gt; <span class="hljs-title">getAllClass</span><span class="hljs-params">(String packagename)</span> </span>&#123;        LOG.info(<span class="hljs-string">"packageName to search："</span> + packagename);        List&lt;String&gt; classNameList = getClassName(packagename);        ArrayList&lt;Class&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">for</span> (String className : classNameList) &#123;            <span class="hljs-keyword">try</span> &#123;                list.add(Class.forName(className));            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;                LOG.error(<span class="hljs-string">"load class from name failed:"</span> + className + e.getMessage());                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"load class from name failed:"</span> +                        className + e.getMessage());            &#125;        &#125;        LOG.info(<span class="hljs-string">"find list size :"</span> + list.size());        <span class="hljs-keyword">return</span> list;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获取某包下所有类</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> packageName 包名</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 类的完整名称</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title">getClassName</span><span class="hljs-params">(String packageName)</span> </span>&#123;        List&lt;String&gt; fileNames = <span class="hljs-keyword">null</span>;        ClassLoader loader = Thread.currentThread().getContextClassLoader();        String packagePath = packageName.replace(<span class="hljs-string">"."</span>, <span class="hljs-string">"/"</span>);        URL url = loader.getResource(packagePath);        <span class="hljs-keyword">if</span> (url != <span class="hljs-keyword">null</span>) &#123;            String type = url.getProtocol();            LOG.debug(<span class="hljs-string">"file type : "</span> + type);            <span class="hljs-keyword">if</span> (type.equals(<span class="hljs-string">"file"</span>)) &#123;                String fileSearchPath = url.getPath();                LOG.debug(<span class="hljs-string">"fileSearchPath: "</span> + fileSearchPath);                fileSearchPath = fileSearchPath.substring(<span class="hljs-number">0</span>,                        fileSearchPath.indexOf(<span class="hljs-string">"/classes"</span>));                LOG.debug(<span class="hljs-string">"fileSearchPath: "</span> + fileSearchPath);                fileNames = getClassNameByFile(fileSearchPath);            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type.equals(<span class="hljs-string">"jar"</span>)) &#123;                <span class="hljs-keyword">try</span> &#123;                    JarURLConnection jarURLConnection = (JarURLConnection)                            url.openConnection();                    JarFile jarFile = jarURLConnection.getJarFile();                    fileNames = getClassNameByJar(jarFile, packagePath);                &#125; <span class="hljs-keyword">catch</span> (java.io.IOException e) &#123;                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"open Package URL failed："</span> + e.getMessage());                &#125;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"file system not support! cannot load MsgProcessor！"</span>);            &#125;        &#125;        <span class="hljs-keyword">return</span> fileNames;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 从项⽬⽂件获取某包下所有类</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> filePath ⽂件路径</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 类的完整名称</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title">getClassNameByFile</span><span class="hljs-params">(String filePath)</span> </span>&#123;        List&lt;String&gt; myClassName = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();        File file = <span class="hljs-keyword">new</span> File(filePath);        File[] childFiles = file.listFiles();        <span class="hljs-keyword">for</span> (File childFile : childFiles) &#123;            <span class="hljs-keyword">if</span> (childFile.isDirectory()) &#123;                myClassName.addAll(getClassNameByFile(childFile.getPath()));            &#125; <span class="hljs-keyword">else</span> &#123;                String childFilePath = childFile.getPath();                <span class="hljs-keyword">if</span> (childFilePath.endsWith(<span class="hljs-string">".class"</span>)) &#123;                    childFilePath =                            childFilePath.substring(childFilePath.indexOf(<span class="hljs-string">"\\classes"</span>) + <span class="hljs-number">9</span>,                                    childFilePath.lastIndexOf(<span class="hljs-string">"."</span>));                    childFilePath = childFilePath.replace(<span class="hljs-string">"\\"</span>, <span class="hljs-string">"."</span>);                    myClassName.add(childFilePath);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> myClassName;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 从jar获取某包下所有类</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 类的完整名称</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title">getClassNameByJar</span><span class="hljs-params">(JarFile jarFile, String</span></span><span class="hljs-function"><span class="hljs-params">            packagePath)</span> </span>&#123;        List&lt;String&gt; myClassName = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();        <span class="hljs-keyword">try</span> &#123;            Enumeration&lt;JarEntry&gt; entrys = jarFile.entries();            <span class="hljs-keyword">while</span> (entrys.hasMoreElements()) &#123;                JarEntry jarEntry = entrys.nextElement();                String entryName = jarEntry.getName();                <span class="hljs-comment">//LOG.info("entrys jarfile:"+entryName);</span>                <span class="hljs-keyword">if</span> (entryName.endsWith(<span class="hljs-string">".class"</span>)) &#123;                    entryName = entryName.replace(<span class="hljs-string">"/"</span>, <span class="hljs-string">"."</span>).substring(<span class="hljs-number">0</span>,                            entryName.lastIndexOf(<span class="hljs-string">"."</span>));                    myClassName.add(entryName);                    <span class="hljs-comment">//LOG.debug("Find Class :"+entryName);</span>                &#125;            &#125;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            LOG.error(<span class="hljs-string">"发⽣异常:"</span> + e.getMessage());            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"发⽣异常:"</span> + e.getMessage());        &#125;        <span class="hljs-keyword">return</span> myClassName;    &#125;&#125;</code></pre><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><h4 id="NettyClient"><a href="#NettyClient" class="headerlink" title="NettyClient"></a>NettyClient</h4><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.myrpc.core.client;<span class="hljs-keyword">import</span> cn.itcast.myrpc.core.base.RpcRequest;<span class="hljs-keyword">import</span> io.netty.bootstrap.Bootstrap;<span class="hljs-keyword">import</span> io.netty.channel.Channel;<span class="hljs-keyword">import</span> io.netty.channel.ChannelFuture;<span class="hljs-keyword">import</span> io.netty.channel.EventLoopGroup;<span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;<span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyClient</span> </span>&#123;    <span class="hljs-keyword">private</span> Channel channel;    <span class="hljs-keyword">private</span> EventLoopGroup worker;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">(String host, <span class="hljs-keyword">int</span> port)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            doStart(host, port);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doStart</span><span class="hljs-params">(String host, <span class="hljs-keyword">int</span> port)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//定义⼯作线程组</span>        <span class="hljs-keyword">this</span>.worker = <span class="hljs-keyword">new</span> NioEventLoopGroup();        Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();        bootstrap.group(<span class="hljs-keyword">this</span>.worker)                .channel(NioSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">                .<span class="hljs-title">handler</span>(<span class="hljs-title">new</span> <span class="hljs-title">ClientInitializer</span>())</span>;        <span class="hljs-comment">//连接到远程服务</span>        ChannelFuture future = bootstrap.connect(host, port).sync();        <span class="hljs-comment">//保留channel对象，⽅便后⾯通过该通道发送消息</span>        <span class="hljs-keyword">this</span>.channel = future.channel();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != <span class="hljs-keyword">this</span>.channel &amp;&amp; <span class="hljs-keyword">this</span>.channel.isActive()) &#123;            <span class="hljs-keyword">this</span>.channel.close();        &#125;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != <span class="hljs-keyword">this</span>.worker &amp;&amp; !<span class="hljs-keyword">this</span>.worker.isShutdown()) &#123;            <span class="hljs-keyword">this</span>.worker.shutdownGracefully();        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 发送消息</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> request</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMsg</span><span class="hljs-params">(RpcRequest request)</span> </span>&#123;        <span class="hljs-keyword">this</span>.channel.writeAndFlush(request);    &#125;&#125;</code></pre><h4 id="ClientInitializer"><a href="#ClientInitializer" class="headerlink" title="ClientInitializer"></a>ClientInitializer</h4><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.myrpc.core.client;<span class="hljs-keyword">import</span> cn.itcast.myrpc.core.base.RpcResponse;<span class="hljs-keyword">import</span> cn.itcast.myrpc.core.codec.MyDecoder;<span class="hljs-keyword">import</span> cn.itcast.myrpc.core.codec.MyEncoder;<span class="hljs-keyword">import</span> io.netty.channel.ChannelInitializer;<span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClientInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">SocketChannel</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ch.pipeline()                .addLast(<span class="hljs-keyword">new</span> MyDecoder(RpcResponse<span class="hljs-class">.<span class="hljs-keyword">class</span>))</span><span class="hljs-class">                .<span class="hljs-title">addLast</span>(<span class="hljs-title">new</span> <span class="hljs-title">MyEncoder</span>())</span><span class="hljs-class">                .<span class="hljs-title">addLast</span>(<span class="hljs-title">new</span> <span class="hljs-title">ClientHandler</span>())</span>;    &#125;&#125;</code></pre><h4 id="ClientHandler"><a href="#ClientHandler" class="headerlink" title="ClientHandler"></a>ClientHandler</h4><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.myrpc.core.client;<span class="hljs-keyword">import</span> cn.itcast.myrpc.core.base.RpcResponse;<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<span class="hljs-keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;<span class="hljs-keyword">import</span> org.slf4j.Logger;<span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">RpcResponse</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER =            LoggerFactory.getLogger(ClientHandler<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, RpcResponse msg)</span></span><span class="hljs-function">            <span class="hljs-keyword">throws</span> Exception </span>&#123;        LOGGER.info(<span class="hljs-string">"接收到服务端的消息：requestId = "</span> + msg.getRequestId());        <span class="hljs-comment">//接收到服务端的消息后，通知响应已经完成</span>        <span class="hljs-comment">//通过RpcFutureResponse中的Map获取到RpcFutureResponse对象，进⾏⽅法回调</span>        RpcFutureResponse rpcFutureResponse =                RpcFutureResponse.getRpcFutureResponse(msg.getRequestId());        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != rpcFutureResponse) &#123;            rpcFutureResponse.setResponse(msg);        &#125; <span class="hljs-keyword">else</span> &#123;            LOGGER.warn(<span class="hljs-string">"没有找到对应的RpcFutureResponse对象~ requestId = "</span> +                    msg.getRequestId());        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span></span><span class="hljs-function">            <span class="hljs-keyword">throws</span> Exception </span>&#123;        LOGGER.error(<span class="hljs-string">"客户端出错~ "</span>, cause);        ctx.close();    &#125;&#125;</code></pre><h4 id="RpcFutureResponse"><a href="#RpcFutureResponse" class="headerlink" title="RpcFutureResponse"></a>RpcFutureResponse</h4><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.myrpc.core.client;<span class="hljs-keyword">import</span> cn.itcast.myrpc.core.base.RpcRequest;<span class="hljs-keyword">import</span> cn.itcast.myrpc.core.base.RpcResponse;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-keyword">import</span> java.util.concurrent.ConcurrentHashMap;<span class="hljs-keyword">import</span> java.util.concurrent.ExecutionException;<span class="hljs-keyword">import</span> java.util.concurrent.Future;<span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<span class="hljs-comment">/**</span><span class="hljs-comment"> * ⽤于异步的响应处理</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RpcFutureResponse</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Future</span>&lt;<span class="hljs-title">RpcResponse</span>&gt; </span>&#123;    <span class="hljs-comment">//存储requestId与RpcFutureResponse对象的映射关系</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;String, RpcFutureResponse&gt; MAP = <span class="hljs-keyword">new</span>            ConcurrentHashMap&lt;&gt;();    <span class="hljs-comment">//是否处理完成，默认为false</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> done = <span class="hljs-keyword">false</span>;    <span class="hljs-comment">//定义⼀个对象⽤于锁操作</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object lock = <span class="hljs-keyword">new</span> Object();    <span class="hljs-comment">//响应对象</span>    <span class="hljs-keyword">private</span> RpcResponse response;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 在构造函数中将当前对象存储到MAP中 *</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> rpcRequest</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RpcFutureResponse</span><span class="hljs-params">(RpcRequest rpcRequest)</span> </span>&#123;        MAP.put(rpcRequest.getRequestId(), <span class="hljs-keyword">this</span>);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 根据请求id查询RpcFutureResponse对象</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> requestId</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RpcFutureResponse <span class="hljs-title">getRpcFutureResponse</span><span class="hljs-params">(String requestId)</span> </span>&#123;        <span class="hljs-keyword">return</span> MAP.get(requestId);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">cancel</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> mayInterruptIfRunning)</span> </span>&#123;        <span class="hljs-comment">//TODO 暂不实现</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isCancelled</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//TODO 暂不实现</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 是否完成</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isDone</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> done;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获取数据，没有超时时间</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> InterruptedException</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> ExecutionException</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> RpcResponse <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.get(-<span class="hljs-number">1</span>, TimeUnit.MILLISECONDS);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获取数据，指定了超时时间</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> timeout 单位为毫秒</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> unit</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> InterruptedException</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> ExecutionException</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> RpcResponse <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span></span><span class="hljs-function">            InterruptedException, ExecutionException </span>&#123;        <span class="hljs-keyword">if</span> (isDone()) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.response;        &#125;        <span class="hljs-keyword">synchronized</span> (lock) &#123; <span class="hljs-comment">//确保只有⼀个线程在⼀个时刻执⾏操作</span>            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-keyword">if</span> (timeout &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//如果没有设置超时时间的话，就⼀直等待</span>                    lock.wait();                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-comment">// 如果设置了超时时间的话，就在给定时间内进⾏等待</span>                    <span class="hljs-keyword">long</span> timeoutMillis = (TimeUnit.MILLISECONDS == unit) ?                            timeout : TimeUnit.MILLISECONDS.convert(timeout, unit);                    lock.wait(timeoutMillis);                &#125;            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;        <span class="hljs-keyword">if</span> (isDone()) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.response;        &#125;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"获取数据，等待超时。。。"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setResponse</span><span class="hljs-params">(RpcResponse response)</span> </span>&#123;        <span class="hljs-keyword">this</span>.response = response;        <span class="hljs-keyword">synchronized</span> (lock) &#123; <span class="hljs-comment">//确保只有⼀个线程在⼀个时刻执⾏操作</span>            <span class="hljs-keyword">this</span>.done = <span class="hljs-keyword">true</span>;            <span class="hljs-keyword">this</span>.lock.notifyAll(); <span class="hljs-comment">//唤醒等待的线程</span>        &#125;        <span class="hljs-comment">//删除已缓存的对象</span>        MAP.remove(response.getRequestId());    &#125;&#125;</code></pre><h4 id="ClientInvocationHandler"><a href="#ClientInvocationHandler" class="headerlink" title="ClientInvocationHandler"></a>ClientInvocationHandler</h4><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.myrpc.core.client;<span class="hljs-keyword">import</span> cn.itcast.myrpc.core.base.RpcRequest;<span class="hljs-keyword">import</span> cn.itcast.myrpc.core.base.RpcResponse;<span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<span class="hljs-keyword">import</span> java.lang.reflect.Method;<span class="hljs-keyword">import</span> java.util.UUID;<span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 动态代理的业务逻辑实现</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClientInvocationHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;    <span class="hljs-keyword">private</span> NettyClient nettyClient;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 需要将NettyClient传⼊，因为要基于此发送消息数据</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> nettyClient</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ClientInvocationHandler</span><span class="hljs-params">(NettyClient nettyClient)</span> </span>&#123;        <span class="hljs-keyword">this</span>.nettyClient = nettyClient;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 执⾏的业务逻辑</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> proxy</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> method</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Throwable</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span></span><span class="hljs-function">            Throwable </span>&#123;        <span class="hljs-comment">//获取类、⽅法、参数等信息</span>        String className = method.getDeclaringClass().getName();        String methodName = method.getName();        Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();        Object[] parameters = args;        <span class="hljs-comment">//封装请求对象</span>        RpcRequest request = <span class="hljs-keyword">new</span> RpcRequest();        request.setRequestId(UUID.randomUUID().toString());        request.setCreateMillisTime(System.currentTimeMillis());        request.setClassName(className);        request.setMethodName(methodName);        request.setParameterTypes(parameterTypes);        request.setParameters(parameters);        <span class="hljs-comment">//定义异步的响应对象</span>        RpcFutureResponse futureResponse = <span class="hljs-keyword">new</span> RpcFutureResponse(request);        <span class="hljs-comment">//向服务端发送消息</span>        nettyClient.sendMsg(request);        <span class="hljs-comment">//获取异步响应的消息</span>        RpcResponse rpcResponse = futureResponse.get(<span class="hljs-number">5</span>, TimeUnit.SECONDS);        <span class="hljs-keyword">if</span> (rpcResponse.getErrorMsg() != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(rpcResponse.getErrorMsg());        &#125;        <span class="hljs-keyword">return</span> rpcResponse.getResult();    &#125;&#125;</code></pre><h4 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h4><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.myrpc.core.client;<span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 通过动态代理⽣成代理对象</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeanFactory</span> </span>&#123;    <span class="hljs-keyword">private</span> NettyClient nettyClient;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BeanFactory</span><span class="hljs-params">(NettyClient nettyClient)</span> </span>&#123;        <span class="hljs-keyword">this</span>.nettyClient = nettyClient;    &#125;    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getBean</span><span class="hljs-params">(Class&lt;T&gt; clazz)</span> </span>&#123;        <span class="hljs-keyword">return</span> (T) Proxy.newProxyInstance(                Thread.currentThread().getContextClassLoader(),                <span class="hljs-keyword">new</span> Class&lt;?&gt;[]&#123;clazz&#125;,                <span class="hljs-keyword">new</span> ClientInvocationHandler(nettyClient)        );    &#125;&#125;</code></pre><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="myrpc-demo-api"><a href="#myrpc-demo-api" class="headerlink" title="myrpc-demo-api"></a>myrpc-demo-api</h4><p>pom.xml：</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span></span><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0</span></span><span class="hljs-tag"><span class="hljs-string">http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>itcast-MyRPC<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.itcast.myrpc<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>myrpc-demo-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre><p>定义pojo：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.myrpc.order.pojo;<span class="hljs-keyword">import</span> java.util.Arrays;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Item</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = -<span class="hljs-number">1768340664273809021L</span>;    <span class="hljs-keyword">private</span> Long itemId;    <span class="hljs-keyword">private</span> String title;    <span class="hljs-keyword">private</span> String[] pics;    <span class="hljs-keyword">private</span> Long price;    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">getItemId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> itemId;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setItemId</span><span class="hljs-params">(Long itemId)</span> </span>&#123;        <span class="hljs-keyword">this</span>.itemId = itemId;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getTitle</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> title;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTitle</span><span class="hljs-params">(String title)</span> </span>&#123;        <span class="hljs-keyword">this</span>.title = title;    &#125;    <span class="hljs-keyword">public</span> String[] getPics() &#123;        <span class="hljs-keyword">return</span> pics;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPics</span><span class="hljs-params">(String[] pics)</span> </span>&#123;        <span class="hljs-keyword">this</span>.pics = pics;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">getPrice</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> price;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPrice</span><span class="hljs-params">(Long price)</span> </span>&#123;        <span class="hljs-keyword">this</span>.price = price;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"Item&#123;"</span> +                <span class="hljs-string">"itemId="</span> + itemId +                <span class="hljs-string">", title='"</span> + title + <span class="hljs-string">'\''</span> +                <span class="hljs-string">", pics="</span> + Arrays.toString(pics) +                <span class="hljs-string">", price="</span> + price +                <span class="hljs-string">'&#125;'</span>;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.myrpc.order.pojo;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Order</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">8069637444287105148L</span>;    <span class="hljs-keyword">private</span> String orderId;    <span class="hljs-keyword">private</span> Long userId;    <span class="hljs-keyword">private</span> Long date;    <span class="hljs-keyword">private</span> Integer itemCount;    <span class="hljs-keyword">private</span> Long totalPrice;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getOrderId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> orderId;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setOrderId</span><span class="hljs-params">(String orderId)</span> </span>&#123;        <span class="hljs-keyword">this</span>.orderId = orderId;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">getUserId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> userId;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUserId</span><span class="hljs-params">(Long userId)</span> </span>&#123;        <span class="hljs-keyword">this</span>.userId = userId;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">getDate</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> date;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDate</span><span class="hljs-params">(Long date)</span> </span>&#123;        <span class="hljs-keyword">this</span>.date = date;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getItemCount</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> itemCount;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setItemCount</span><span class="hljs-params">(Integer itemCount)</span> </span>&#123;        <span class="hljs-keyword">this</span>.itemCount = itemCount;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">getTotalPrice</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> totalPrice;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTotalPrice</span><span class="hljs-params">(Long totalPrice)</span> </span>&#123;        <span class="hljs-keyword">this</span>.totalPrice = totalPrice;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"Order&#123;"</span> +                <span class="hljs-string">"orderId='"</span> + orderId + <span class="hljs-string">'\''</span> +                <span class="hljs-string">", userId="</span> + userId +                <span class="hljs-string">", date="</span> + date +                <span class="hljs-string">", itemCount="</span> + itemCount +                <span class="hljs-string">", totalPrice="</span> + totalPrice +                <span class="hljs-string">'&#125;'</span>;    &#125;&#125;</code></pre><p>服务接⼝定义：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.myrpc.order.service;<span class="hljs-keyword">import</span> cn.itcast.myrpc.order.pojo.Item;<span class="hljs-keyword">import</span> cn.itcast.myrpc.order.pojo.Order;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">OrderService</span> </span>&#123;    <span class="hljs-function">Order <span class="hljs-title">submitOrder</span><span class="hljs-params">(Long userId, List&lt;Item&gt; itemList)</span></span>;&#125;</code></pre><h4 id="myrpc-demo-server"><a href="#myrpc-demo-server" class="headerlink" title="myrpc-demo-server"></a>myrpc-demo-server</h4><p>pom.xml:</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span></span><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0</span></span><span class="hljs-tag"><span class="hljs-string">http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>itcast-MyRPC<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.itcast.myrpc<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>myrpc-demo-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.itcast.myrpc<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>myrpc-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.itcast.myrpc<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>myrpc-demo-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre><p>服务实现：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.myrpc.order.service;<span class="hljs-keyword">import</span> cn.itcast.myrpc.order.pojo.Item;<span class="hljs-keyword">import</span> cn.itcast.myrpc.order.pojo.Order;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">import</span> java.util.UUID;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">cn</span>.<span class="hljs-title">itcast</span>.<span class="hljs-title">myrpc</span>.<span class="hljs-title">order</span>.<span class="hljs-title">service</span>.<span class="hljs-title">OrderService</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Order <span class="hljs-title">submitOrder</span><span class="hljs-params">(Long userId, List&lt;Item&gt; itemList)</span> </span>&#123;        Order order = <span class="hljs-keyword">new</span> Order();        order.setOrderId(UUID.randomUUID().toString());        order.setDate(System.currentTimeMillis());        order.setItemCount(itemList.size());        order.setUserId(userId);        Long count = <span class="hljs-number">0L</span>;        <span class="hljs-keyword">for</span> (Item item : itemList) &#123;            count += item.getPrice();        &#125;        order.setTotalPrice(count);        <span class="hljs-keyword">return</span> order;    &#125;&#125;</code></pre><p>启动服务：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.myrpc.order;<span class="hljs-keyword">import</span> cn.itcast.myrpc.core.server.NettyServer;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        NettyServer.start(<span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-number">5566</span>);    &#125;&#125;</code></pre><h4 id="myrpc-demo-client"><a href="#myrpc-demo-client" class="headerlink" title="myrpc-demo-client"></a>myrpc-demo-client</h4><p>pom.xml：</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span></span><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0</span></span><span class="hljs-tag"><span class="hljs-string">http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>itcast-MyRPC<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.itcast.myrpc<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>myrpc-demo-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.itcast.myrpc<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>myrpc-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.itcast.myrpc<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>myrpc-demo-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre><p>ClientServer：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.myrpc.order;<span class="hljs-keyword">import</span> cn.itcast.myrpc.core.client.BeanFactory;<span class="hljs-keyword">import</span> cn.itcast.myrpc.core.client.NettyClient;<span class="hljs-keyword">import</span> cn.itcast.myrpc.order.pojo.Item;<span class="hljs-keyword">import</span> cn.itcast.myrpc.order.pojo.Order;<span class="hljs-keyword">import</span> cn.itcast.myrpc.order.service.OrderService;<span class="hljs-keyword">import</span> java.util.ArrayList;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClientServer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        NettyClient nettyClient = <span class="hljs-keyword">new</span> NettyClient();        nettyClient.start(<span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-number">5566</span>);        BeanFactory beanFactory = <span class="hljs-keyword">new</span> BeanFactory(nettyClient);        OrderService orderService = beanFactory.getBean(OrderService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        List&lt;Item&gt; itemList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        Item item = <span class="hljs-keyword">new</span> Item();        item.setItemId(<span class="hljs-number">2001L</span>);        item.setPrice(<span class="hljs-number">100L</span>);        item.setTitle(<span class="hljs-string">"铅笔"</span>);        itemList.add(item);        item = <span class="hljs-keyword">new</span> Item();        item.setItemId(<span class="hljs-number">2002L</span>);        item.setPrice(<span class="hljs-number">50L</span>);        item.setTitle(<span class="hljs-string">"橡⽪"</span>);        itemList.add(item);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            Order order = orderService.submitOrder(<span class="hljs-number">1001L</span>, itemList);            System.out.println(<span class="hljs-string">"返回数据："</span> + order);        &#125;        nettyClient.close();    &#125;&#125;</code></pre><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>服务端：</p><pre><code class="hljs angelscript">[nioEventLoopGroup<span class="hljs-number">-3</span><span class="hljs-number">-1</span>] [cn.itcast.myrpc.core.server.ServerHandler]-[INFO] 开始处理消息：requestId = <span class="hljs-number">51209</span>bb0-a86e<span class="hljs-number">-4363</span>-b966-aa989a3c3908[nioEventLoopGroup<span class="hljs-number">-3</span><span class="hljs-number">-1</span>] [cn.itcast.myrpc.core.server.ServerHandler]-[INFO] 开始处理消息：requestId = <span class="hljs-number">0400</span>ab1a-b0d7<span class="hljs-number">-4f</span>37<span class="hljs-number">-8</span>ad5<span class="hljs-number">-4</span>ea6401a03f6[nioEventLoopGroup<span class="hljs-number">-3</span><span class="hljs-number">-1</span>] [cn.itcast.myrpc.core.server.ServerHandler]-[INFO] 开始处理消息：requestId = <span class="hljs-number">776f</span>501f<span class="hljs-number">-7963</span><span class="hljs-number">-4917</span><span class="hljs-number">-983e-4f</span>8e38e70903[nioEventLoopGroup<span class="hljs-number">-3</span><span class="hljs-number">-1</span>] [cn.itcast.myrpc.core.server.ServerHandler]-[INFO] 开始处理消息：requestId = caac11ae-f695<span class="hljs-number">-4135</span><span class="hljs-number">-8</span>d9f<span class="hljs-number">-231425</span>d36699[nioEventLoopGroup<span class="hljs-number">-3</span><span class="hljs-number">-1</span>] [cn.itcast.myrpc.core.server.ServerHandler]-[INFO] 开始处理消息：requestId = <span class="hljs-number">29841e2f</span><span class="hljs-number">-310f</span><span class="hljs-number">-47e3</span><span class="hljs-number">-9</span>d74-e3b9e153e378[nioEventLoopGroup<span class="hljs-number">-3</span><span class="hljs-number">-1</span>] [cn.itcast.myrpc.core.server.ServerHandler]-[INFO] 开始处理消息：requestId = f9f13486<span class="hljs-number">-2841</span><span class="hljs-number">-45f</span>5<span class="hljs-number">-8</span>d6c-a017d14a4101[nioEventLoopGroup<span class="hljs-number">-3</span><span class="hljs-number">-1</span>] [cn.itcast.myrpc.core.server.ServerHandler]-[INFO] 开始处理消息：requestId = c994ecac-c427<span class="hljs-number">-41</span>a0<span class="hljs-number">-87</span>b3-d0e66d67551e[nioEventLoopGroup<span class="hljs-number">-3</span><span class="hljs-number">-1</span>] [cn.itcast.myrpc.core.server.ServerHandler]-[INFO] 开始处理消息：requestId = <span class="hljs-number">81708019</span>-d7d7<span class="hljs-number">-4679</span><span class="hljs-number">-946f</span><span class="hljs-number">-3</span>da89b944651[nioEventLoopGroup<span class="hljs-number">-3</span><span class="hljs-number">-1</span>] [cn.itcast.myrpc.core.server.ServerHandler]-[INFO] 开始处理消息：requestId = b513d5d7<span class="hljs-number">-50</span>b8<span class="hljs-number">-434</span>a<span class="hljs-number">-937</span>b<span class="hljs-number">-97</span>d8bba8c65e</code></pre><p>客户端：</p><pre><code class="hljs routeros">[nioEventLoopGroup-2-1] [io.netty.util.ResourceLeakDetectorFactory]-[<span class="hljs-builtin-name">DEBUG</span>]Loaded<span class="hljs-built_in"> default </span>ResourceLeakDetector: io.netty.util.ResourceLeakDetector@2f4b36[nioEventLoopGroup-2-1] [cn.itcast.myrpc.core.client.ClientHandler]-[<span class="hljs-builtin-name">INFO</span>] 接收到服务端的消息：requestId = e72bf59a-7149-4d35-84e4-e463fe14858e返回数据：Order&#123;<span class="hljs-attribute">orderId</span>=<span class="hljs-string">'34245455-2034-4da3-94d3-926a46d018ed'</span>, <span class="hljs-attribute">userId</span>=1001,<span class="hljs-attribute">date</span>=1593161672169, <span class="hljs-attribute">itemCount</span>=2, <span class="hljs-attribute">totalPrice</span>=150&#125;[nioEventLoopGroup-2-1] [cn.itcast.myrpc.core.client.ClientHandler]-[<span class="hljs-builtin-name">INFO</span>] 接收到服务端的消息：requestId = 51209bb0-a86e-4363-b966-aa989a3c3908返回数据：Order&#123;<span class="hljs-attribute">orderId</span>=<span class="hljs-string">'b895fd40-7dc1-4176-bfc1-e71867b4162e'</span>, <span class="hljs-attribute">userId</span>=1001,<span class="hljs-attribute">date</span>=1593161672188, <span class="hljs-attribute">itemCount</span>=2, <span class="hljs-attribute">totalPrice</span>=150&#125;[nioEventLoopGroup-2-1] [cn.itcast.myrpc.core.client.ClientHandler]-[<span class="hljs-builtin-name">INFO</span>] 接收到服务端的消息：requestId = 0400ab1a-b0d7-4f37-8ad5-4ea6401a03f6返回数据：Order&#123;<span class="hljs-attribute">orderId</span>=<span class="hljs-string">'dbe3f5be-7a6d-4e1d-af73-6600f76c14a5'</span>, <span class="hljs-attribute">userId</span>=1001,<span class="hljs-attribute">date</span>=1593161672191, <span class="hljs-attribute">itemCount</span>=2, <span class="hljs-attribute">totalPrice</span>=150&#125;[nioEventLoopGroup-2-1] [cn.itcast.myrpc.core.client.ClientHandler]-[<span class="hljs-builtin-name">INFO</span>] 接收到服务端的消息：requestId = 776f501f-7963-4917-983e-4f8e38e70903返回数据：Order&#123;<span class="hljs-attribute">orderId</span>=<span class="hljs-string">'d00d5490-7f03-470b-9d61-e35b66883d8b'</span>, <span class="hljs-attribute">userId</span>=1001,<span class="hljs-attribute">date</span>=1593161672194, <span class="hljs-attribute">itemCount</span>=2, <span class="hljs-attribute">totalPrice</span>=150&#125;[nioEventLoopGroup-2-1] [cn.itcast.myrpc.core.client.ClientHandler]-[<span class="hljs-builtin-name">INFO</span>] 接收到服务端的消息：requestId = caac11ae-f695-4135-8d9f-231425d36699返回数据：Order&#123;<span class="hljs-attribute">orderId</span>=<span class="hljs-string">'6fb2146b-97af-47d2-a782-4b6cc8a3b108'</span>, <span class="hljs-attribute">userId</span>=1001,<span class="hljs-attribute">date</span>=1593161672196, <span class="hljs-attribute">itemCount</span>=2, <span class="hljs-attribute">totalPrice</span>=150&#125;[nioEventLoopGroup-2-1] [cn.itcast.myrpc.core.client.ClientHandler]-[<span class="hljs-builtin-name">INFO</span>] 接收到服务端的消息：requestId = 29841e2f-310f-47e3-9d74-e3b9e153e378返回数据：Order&#123;<span class="hljs-attribute">orderId</span>=<span class="hljs-string">'ae2f0b0c-445f-4500-9c61-086faa3b866f'</span>, <span class="hljs-attribute">userId</span>=1001,<span class="hljs-attribute">date</span>=1593161672196, <span class="hljs-attribute">itemCount</span>=2, <span class="hljs-attribute">totalPrice</span>=150&#125;[nioEventLoopGroup-2-1] [cn.itcast.myrpc.core.client.ClientHandler]-[<span class="hljs-builtin-name">INFO</span>] 接收到服务端的消息：requestId = f9f13486-2841-45f5-8d6c-a017d14a4101返回数据：Order&#123;<span class="hljs-attribute">orderId</span>=<span class="hljs-string">'ec0da70a-b557-4dbf-ba59-4745b98a37d4'</span>, <span class="hljs-attribute">userId</span>=1001,<span class="hljs-attribute">date</span>=1593161672196, <span class="hljs-attribute">itemCount</span>=2, <span class="hljs-attribute">totalPrice</span>=150&#125;[nioEventLoopGroup-2-1] [cn.itcast.myrpc.core.client.ClientHandler]-[<span class="hljs-builtin-name">INFO</span>] 接收到服务端的消息：requestId = c994ecac-c427-41a0-87b3-d0e66d67551e返回数据：Order&#123;<span class="hljs-attribute">orderId</span>=<span class="hljs-string">'bce9265f-e155-41b7-b789-d17da44ca4cd'</span>, <span class="hljs-attribute">userId</span>=1001,<span class="hljs-attribute">date</span>=1593161672196, <span class="hljs-attribute">itemCount</span>=2, <span class="hljs-attribute">totalPrice</span>=150&#125;[nioEventLoopGroup-2-1] [cn.itcast.myrpc.core.client.ClientHandler]-[<span class="hljs-builtin-name">INFO</span>] 接收到服务端的消息：requestId = 81708019-d7d7-4679-946f-3da89b944651返回数据：Order&#123;<span class="hljs-attribute">orderId</span>=<span class="hljs-string">'58f34bb9-279f-46a6-9a8d-7c1b569b4230'</span>, <span class="hljs-attribute">userId</span>=1001,<span class="hljs-attribute">date</span>=1593161672196, <span class="hljs-attribute">itemCount</span>=2, <span class="hljs-attribute">totalPrice</span>=150&#125;[nioEventLoopGroup-2-1] [cn.itcast.myrpc.core.client.ClientHandler]-[<span class="hljs-builtin-name">INFO</span>] 接收到服务端的消息：requestId = b513d5d7-50b8-434a-937b-97d8bba8c65e返回数据：Order&#123;<span class="hljs-attribute">orderId</span>=<span class="hljs-string">'6e5cbe4f-9060-43ee-b0c8-25d2ea345771'</span>, <span class="hljs-attribute">userId</span>=1001,<span class="hljs-attribute">date</span>=1593161672196, <span class="hljs-attribute">itemCount</span>=2, <span class="hljs-attribute">totalPrice</span>=150&#125;[nioEventLoopGroup-2-1] [io.netty.buffer.PoolThreadCache]-[<span class="hljs-builtin-name">DEBUG</span>] Freed 6thread-local buffer(s) <span class="hljs-keyword">from</span> thread: nioEventLoopGroup-2-1</code></pre>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
      <tag>项目实战</tag>
      
      <tag>自定义框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP拆包粘包问题</title>
    <link href="/blog/2020/08/08/netty-TCP%E6%8B%86%E5%8C%85%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <url>/blog/2020/08/08/netty-TCP%E6%8B%86%E5%8C%85%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="ReplayingDecoder"><a href="#ReplayingDecoder" class="headerlink" title="ReplayingDecoder"></a>ReplayingDecoder</h3><p>在前⾯案例中，当需要获取int数据时，需要进⾏判断是否够4个字节，如果解码业务过于复杂的话，这样的判断会显得⾮常的繁琐，在Netty中提供了ReplayingDecoder就可以解决这样的问题。</p><p>ReplayingDecoder也是继承了ByteToMessageDecoder进⾏的扩展。</p><p>javadoc⽂档中的⼀个示例：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntegerHeaderFrameDecoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ByteToMessageDecoder</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext ctx,ByteBuf buf, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">if</span> (buf.readableBytes() &lt; <span class="hljs-number">4</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        buf.markReaderIndex();        <span class="hljs-keyword">int</span> length = buf.readInt();        <span class="hljs-keyword">if</span> (buf.readableBytes() &lt; length) &#123;            buf.resetReaderIndex();            <span class="hljs-keyword">return</span>;        &#125;        out.add(buf.readBytes(length));    &#125;&#125;</code></pre><p>使⽤ReplayingDecoder后：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntegerHeaderFrameDecoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ReplayingDecoder</span>&lt;<span class="hljs-title">Void</span>&gt; </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext ctx,ByteBuf buf, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        out.add(buf.readBytes(buf.readInt()));    &#125;&#125;</code></pre><p>基本原理：</p><ul><li><p>使⽤了特殊的ByteBuf，叫做ReplayingDecoderByteBuf，扩展了ByteBuf</p></li><li><p>重写了ByteBuf的readXxx()等⽅法，会先检查可读字节⻓度，⼀旦检测到不满⾜要求就直接抛出REPLAY（REPLAY继承ERROR）</p></li><li><p>ReplayingDecoder重写了ByteToMessageDecoder的callDecode()⽅法，捕获Signal并在catch块中重置ByteBuf的readerIndex。</p></li><li><p>继续等待数据，直到有了数据后继续读取，这样就可以保证读取到需要读取的数据。</p></li><li><p>类定义中的泛型 S 是⼀个⽤于记录解码状态的状态机枚举类，在state(S s)、checkpoint(S s)等⽅法中会⽤到。在简单解码时也可以⽤java.lang.Void来占位。</p></li></ul><p>需要注意：</p><ul><li><p>buffer的部分操作（readBytes(ByteBuffer dst)、retain()、release()等⽅法会直接抛出异常）</p></li><li><p>在某些情况下会影响性能（如多次对同⼀段消息解码）</p></li></ul><p>TCP是基于流的，只保证接收到数据包分⽚顺序，⽽不保证接收到的数据包每个分⽚⼤⼩。因此在使⽤ReplayingDecoder时，即使不存在多线程，同⼀个线程也可能多次调⽤decode()⽅法。在decode中修改ReplayingDecoder的类变量时必须⼩⼼谨慎。</p><pre><code class="hljs java"><span class="hljs-comment">//这是⼀个错误的例⼦：</span><span class="hljs-comment">//消息中包含了2个integer，代码中decode⽅法会被调⽤两次，此时队列size不等于2，这段代码达不到期望结果。</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyDecoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ReplayingDecoder</span>&lt;<span class="hljs-title">Void</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Queue&lt;Integer&gt; values = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ByteBuf buf, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">// A message contains 2 integers.</span>        values.offer(buf.readInt());        values.offer(buf.readInt());        <span class="hljs-keyword">assert</span> values.size() == <span class="hljs-number">2</span>;        out.add(values.poll() + values.poll());    &#125;&#125;<span class="hljs-comment">//正确的做法：</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyDecoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ReplayingDecoder</span>&lt;<span class="hljs-title">Void</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Queue&lt;Integer&gt; values = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ByteBuf buf, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">// Revert the state of the variable that might have been changed</span>        <span class="hljs-comment">// since the last partial decode.</span>        values.clear();        <span class="hljs-comment">// A message contains 2 integers.</span>        values.offer(buf.readInt());        values.offer(buf.readInt());        <span class="hljs-comment">// Now we know this assertion will never fail.</span>        <span class="hljs-keyword">assert</span> values.size() == <span class="hljs-number">2</span>;        out.add(values.poll() + values.poll());    &#125;&#125;</code></pre><p>ByteToIntegerDecoder2的实现：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.netty.coder;<span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<span class="hljs-keyword">import</span> io.netty.handler.codec.ByteToMessageDecoder;<span class="hljs-keyword">import</span> io.netty.handler.codec.ReplayingDecoder;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ByteToIntegerDecoder2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ReplayingDecoder</span>&lt;<span class="hljs-title">Void</span>&gt; </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ctx 上下⽂</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> in  输⼊的ByteBuf消息数据</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> out 转化后输出的容器</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        out.add(in.readInt()); <span class="hljs-comment">//读取到int类型数据，放⼊到输出，完成数据类型的转化</span>    &#125;&#125;</code></pre><h3 id="TCP粘包-拆包问题"><a href="#TCP粘包-拆包问题" class="headerlink" title="TCP粘包/拆包问题"></a>TCP粘包/拆包问题</h3><p>TCP是流传递的，所谓流，就是⼀串没有界限的数据，服务端接收到客户端发来的数据，并不确定这是⼀条数据，还是多条数据，应该如何拆包，服务端是不知道的。</p><p>所以，客户端与服务端就需要约定好拆包的规则，客户端按照此规则进⾏粘包，⽽服务端按照此规则进⾏拆包，这就是TCP的粘包与拆包，如果不约定好，就会出现服务端不能按照期望拿到数据。</p><p>实际上，彼此约定的规则就是协议，⾃定义协议就是⾃定义规则。</p><p>解决⽅法</p><p>⼀般来讲有三种⽅法解决TCP的粘包与拆包问题：</p><ul><li><p>在发送的数据包中添加头，在头⾥存储数据的⼤⼩，服务端就可以按照此⼤⼩来读取数据，这样就知道界限在哪⾥了。</p></li><li><p>以固定的⻓度发送数据，超出的分多次发送，不⾜的以0填充，接收端就以固定⻓度接收即可。</p></li><li><p>在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。</p></li></ul><h3 id="解决TCP的粘包-拆包问题"><a href="#解决TCP的粘包-拆包问题" class="headerlink" title="解决TCP的粘包/拆包问题"></a>解决TCP的粘包/拆包问题</h3><p>⾃定义协议</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.netty.tcppackage2;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyProtocol</span> </span>&#123;    <span class="hljs-keyword">private</span> Integer length; <span class="hljs-comment">//数据头：⻓度</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">byte</span>[] body; <span class="hljs-comment">//数据体</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getLength</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> length;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLength</span><span class="hljs-params">(Integer length)</span> </span>&#123;        <span class="hljs-keyword">this</span>.length = length;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span>[] getBody() &#123;        <span class="hljs-keyword">return</span> body;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBody</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] body)</span> </span>&#123;        <span class="hljs-keyword">this</span>.body = body;    &#125;&#125;</code></pre><p>编码器</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.netty.tcppackage2;<span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<span class="hljs-keyword">import</span> io.netty.handler.codec.MessageToByteEncoder;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyEncoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MessageToByteEncoder</span>&lt;<span class="hljs-title">MyProtocol</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(ChannelHandlerContext ctx, MyProtocol msg, ByteBuf</span></span><span class="hljs-function"><span class="hljs-params">            out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        out.writeInt(msg.getLength());        out.writeBytes(msg.getBody());    &#125;&#125;</code></pre><p>解码器</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.netty.tcppackage2;<span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<span class="hljs-keyword">import</span> io.netty.handler.codec.ReplayingDecoder;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyDecoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ReplayingDecoder</span>&lt;<span class="hljs-title">Void</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt;</span></span><span class="hljs-function"><span class="hljs-params">            out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">int</span> length = in.readInt(); <span class="hljs-comment">//获取⻓度</span>        <span class="hljs-keyword">byte</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[length]; <span class="hljs-comment">//根据⻓度定义byte数组</span>        in.readBytes(data); <span class="hljs-comment">//读取数据</span>        MyProtocol myProtocol = <span class="hljs-keyword">new</span> MyProtocol();        myProtocol.setLength(length);        myProtocol.setBody(data);        out.add(myProtocol);    &#125;&#125;</code></pre><p>客户端</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.netty.tcppackage2.client;<span class="hljs-keyword">import</span> cn.itcast.netty.tcppackage2.MyProtocol;<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<span class="hljs-keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;<span class="hljs-keyword">import</span> io.netty.util.CharsetUtil;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">MyProtocol</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, MyProtocol msg)</span></span><span class="hljs-function">            <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(<span class="hljs-string">"接收到服务端的消息："</span> + <span class="hljs-keyword">new</span> String(msg.getBody(),                CharsetUtil.UTF_8));        System.out.println(<span class="hljs-string">"接收到服务端的消息数量："</span> + (++count));    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            <span class="hljs-keyword">byte</span>[] data = <span class="hljs-string">"from client a message!"</span>.getBytes(CharsetUtil.UTF_8);            MyProtocol myProtocol = <span class="hljs-keyword">new</span> MyProtocol();            myProtocol.setLength(data.length);            myProtocol.setBody(data);            ctx.writeAndFlush(myProtocol);        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span></span><span class="hljs-function">            <span class="hljs-keyword">throws</span> Exception </span>&#123;        cause.printStackTrace();        ctx.close();    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.netty.tcppackage2.client;<span class="hljs-keyword">import</span> cn.itcast.netty.tcppackage2.MyDecoder;<span class="hljs-keyword">import</span> cn.itcast.netty.tcppackage2.MyEncoder;<span class="hljs-keyword">import</span> io.netty.bootstrap.Bootstrap;<span class="hljs-keyword">import</span> io.netty.channel.ChannelFuture;<span class="hljs-keyword">import</span> io.netty.channel.ChannelInitializer;<span class="hljs-keyword">import</span> io.netty.channel.EventLoopGroup;<span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;<span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;<span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyClient</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        EventLoopGroup worker = <span class="hljs-keyword">new</span> NioEventLoopGroup();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 服务器启动类</span>            Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();            bootstrap.group(worker);            bootstrap.channel(NioSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;            bootstrap.handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> MyEncoder());                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> MyDecoder());                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> ClientHandler());                &#125;            &#125;);            ChannelFuture future = bootstrap.connect(<span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-number">5566</span>).sync();            future.channel().closeFuture().sync();        &#125; <span class="hljs-keyword">finally</span> &#123;            worker.shutdownGracefully();        &#125;    &#125;&#125;</code></pre><p>服务端</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.netty.tcppackage2.server;<span class="hljs-keyword">import</span> cn.itcast.netty.tcppackage2.MyProtocol;<span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;<span class="hljs-keyword">import</span> io.netty.buffer.Unpooled;<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<span class="hljs-keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;<span class="hljs-keyword">import</span> io.netty.util.CharsetUtil;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">MyProtocol</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, MyProtocol msg)</span></span><span class="hljs-function">            <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(<span class="hljs-string">"服务端接收到消息："</span> + <span class="hljs-keyword">new</span> String(msg.getBody(),                CharsetUtil.UTF_8));        System.out.println(<span class="hljs-string">"服务端接收到消息数量："</span> + (++count));        <span class="hljs-keyword">byte</span>[] data = <span class="hljs-string">"ok"</span>.getBytes(CharsetUtil.UTF_8);        MyProtocol myProtocol = <span class="hljs-keyword">new</span> MyProtocol();        myProtocol.setLength(data.length);        myProtocol.setBody(data);        ctx.writeAndFlush(myProtocol);    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.netty.tcppackage2.server;<span class="hljs-keyword">import</span> cn.itcast.netty.tcppackage2.MyDecoder;<span class="hljs-keyword">import</span> cn.itcast.netty.tcppackage2.MyEncoder;<span class="hljs-keyword">import</span> com.ryhx.drools.test.ServerHandler;<span class="hljs-keyword">import</span> io.netty.bootstrap.ServerBootstrap;<span class="hljs-keyword">import</span> io.netty.channel.ChannelFuture;<span class="hljs-keyword">import</span> io.netty.channel.ChannelInitializer;<span class="hljs-keyword">import</span> io.netty.channel.EventLoopGroup;<span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;<span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;<span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyServer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">// 主线程，不处理任何业务逻辑，只是接收客户的连接请求</span>        EventLoopGroup boss = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);        <span class="hljs-comment">// ⼯作线程，线程数默认是：cpu*2</span>        EventLoopGroup worker = <span class="hljs-keyword">new</span> NioEventLoopGroup();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 服务器启动类</span>            ServerBootstrap serverBootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();            serverBootstrap.group(boss, worker);            <span class="hljs-comment">//配置server通道</span>            serverBootstrap.channel(NioServerSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;            serverBootstrap.childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;                    () &#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                    ch.pipeline()                            .addLast(<span class="hljs-keyword">new</span> MyDecoder())                            .addLast(<span class="hljs-keyword">new</span> MyEncoder())                            .addLast(<span class="hljs-keyword">new</span> ServerHandler());                &#125;            &#125;); <span class="hljs-comment">//worker线程的处理器</span>            ChannelFuture future = serverBootstrap.bind(<span class="hljs-number">5566</span>).sync();            System.out.println(<span class="hljs-string">"服务器启动完成。。。。。"</span>);            <span class="hljs-comment">//等待服务端监听端⼝关闭</span>            future.channel().closeFuture().sync();        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-comment">//优雅关闭</span>            boss.shutdownGracefully();            worker.shutdownGracefully();        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
      <tag>TCP拆包粘包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty编解码器</title>
    <link href="/blog/2020/08/08/netty-Netty%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8/"/>
    <url>/blog/2020/08/08/netty-Netty%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="编解码器"><a href="#编解码器" class="headerlink" title="编解码器"></a>编解码器</h3><p>⽹络中进行数据传输时，⽆论发送的数据是什么格式（int、String、Long等）都会以字节流的⽅式进⾏传递，客户端将原来的数据转化为字节，称之为编码（encode），服务端将字节形式转化为原来的格式，称之为解码（decode），编解码统称为codec。</p><h4 id="解码器"><a href="#解码器" class="headerlink" title="解码器"></a>解码器</h4><p>解码器是负责⼊站的数据操作，那么解码器也⼀定实现了ChannelInboundHandler接⼝，所以编解码器本质上也是ChannelHandler。</p><p>Netty中提供了ByteToMessageDecoder的抽象实现，⾃定义解码器只需要继承该类，实现decode()即可。Netty也提供了⼀些常⽤的解码器实现，基本都是开箱即⽤的。⽐如：</p><ul><li><p>RedisDecoder 基于Redis协议的解码器</p></li><li><p>XmlDecoder 基于XML格式的解码器</p></li><li><p>JsonObjectDecoder 基于json数据格式的解码器</p></li><li><p>HttpObjectDecoder 基于http协议的解码器</p></li></ul><p>Netty也提供了MessageToMessageDecoder，将⼀种格式转化为另⼀种格式的解码器，也提供了⼀些实现：</p><ul><li><p>StringDecoder 将接收到ByteBuf转化为字符串</p></li><li><p>ByteArrayDecoder 将接收到ByteBuf转化字节数组</p></li><li><p>Base64Decoder 将由ByteBuf或US-ASCII字符串编码的Base64解码为ByteBuf。</p></li></ul><p>示例</p><p>将传⼊的字节流转化为Integer类型。</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.ryhx.drools.test;<span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<span class="hljs-keyword">import</span> io.netty.handler.codec.ByteToMessageDecoder;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ByteToIntegerDecoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ByteToMessageDecoder</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ctx 上下⽂</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> in  输⼊的ByteBuf消息数据</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> out 转化后输出的容器</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt;</span></span><span class="hljs-function"><span class="hljs-params">            out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">if</span> (in.readableBytes() &gt;= <span class="hljs-number">4</span>) &#123; <span class="hljs-comment">//int类型占⽤4个字节，所以需要判断是否存在有4个字节，再进⾏读取</span>            out.add(in.readInt()); <span class="hljs-comment">//读取到int类型数据，放⼊到输出，完成数据类型的转化</span>        &#125;    &#125;&#125;</code></pre><p>在Handler中使⽤：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.ryhx.drools.test;<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<span class="hljs-keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span></span><span class="hljs-function">            Exception </span>&#123;        Integer i = (Integer) msg; <span class="hljs-comment">//这⾥可以直接拿到Integer类型的数据</span>        System.out.println(<span class="hljs-string">"服务端接收到的消息为："</span> + i);    &#125;&#125;</code></pre><p>在pipeline中添加解码器：</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;   ch.pipeline()           .addLast(<span class="hljs-keyword">new</span> ByteToIntegerDecoder())           .addLast(<span class="hljs-keyword">new</span> ServerHandler());&#125;</code></pre><h4 id="编码器"><a href="#编码器" class="headerlink" title="编码器"></a>编码器</h4><p>编码器与解码器是相反的操作，将原有的格式转化为字节的过程，在Netty中提供了MessageToByteEncoder的抽象实现，它实现了ChannelOutboundHandler接⼝，本质上也是ChannelHandler。</p><p>⼀些实现类：</p><ul><li><p>ObjectEncoder 将对象（需要实现Serializable接⼝）编码为字节流</p></li><li><p>SocksMessageEncoder 将SocksMessage编码为字节流</p></li><li><p>HAProxyMessageEncoder 将HAProxyMessage编码成字节流</p></li></ul><p>Netty也提供了MessageToMessageEncoder，将⼀种格式转化为另⼀种格式的编码器，也提供了⼀些实现：</p><ul><li><p>RedisEncoder 将Redis协议的对象进⾏编码</p></li><li><p>StringEncoder 将字符串进⾏编码操作</p></li><li><p>Base64Encoder 将Base64字符串进⾏编码操作</p></li></ul><p>示例</p><p>将Integer类型编码为字节进⾏传递。</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.ryhx.drools.test;<span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<span class="hljs-keyword">import</span> io.netty.handler.codec.MessageToByteEncoder;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntegerToByteEncoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MessageToByteEncoder</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(ChannelHandlerContext ctx, Integer msg, ByteBuf out)</span></span><span class="hljs-function">            <span class="hljs-keyword">throws</span> Exception </span>&#123;        out.writeInt(msg);    &#125;&#125;</code></pre><p>在Handler直接输出数字即可：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.ryhx.drools.test;<span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;<span class="hljs-keyword">import</span> io.netty.buffer.Unpooled;<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<span class="hljs-keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;<span class="hljs-keyword">import</span> io.netty.util.CharsetUtil;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">ByteBuf</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf msg)</span> <span class="hljs-keyword">throws</span></span><span class="hljs-function">            Exception </span>&#123;        System.out.println(<span class="hljs-string">"接收到服务端的消息："</span> +                msg.toString(CharsetUtil.UTF_8));    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ctx.writeAndFlush(<span class="hljs-number">123</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span></span><span class="hljs-function">            <span class="hljs-keyword">throws</span> Exception </span>&#123;        cause.printStackTrace();        ctx.close();    &#125;&#125;</code></pre><p>在pipeline中添加编码器：</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    ch.pipeline().addLast(<span class="hljs-keyword">new</span> IntegerToByteEncoder());    ch.pipeline().addLast(<span class="hljs-keyword">new</span> ClientHandler());&#125;</code></pre><h4 id="案例：开发http服务器"><a href="#案例：开发http服务器" class="headerlink" title="案例：开发http服务器"></a>案例：开发<strong>http</strong>服务器</h4><p>在Netty中提供了http的解码器，我们通过该解码器进⾏http服务器的开发。</p><p>Server：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.ryhx.drools.test;<span class="hljs-keyword">import</span> io.netty.bootstrap.ServerBootstrap;<span class="hljs-keyword">import</span> io.netty.channel.ChannelFuture;<span class="hljs-keyword">import</span> io.netty.channel.ChannelInitializer;<span class="hljs-keyword">import</span> io.netty.channel.EventLoopGroup;<span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;<span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;<span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;<span class="hljs-keyword">import</span> io.netty.handler.codec.http.HttpObjectAggregator;<span class="hljs-keyword">import</span> io.netty.handler.codec.http.HttpRequestDecoder;<span class="hljs-keyword">import</span> io.netty.handler.codec.http.HttpResponseEncoder;<span class="hljs-keyword">import</span> io.netty.handler.stream.ChunkedWriteHandler;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyHttpServer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">// 主线程，不处理任何业务逻辑，只是接收客户的连接请求</span>        EventLoopGroup boss = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);        <span class="hljs-comment">// ⼯作线程，线程数默认是：cpu*2</span>        EventLoopGroup worker = <span class="hljs-keyword">new</span> NioEventLoopGroup();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 服务器启动类</span>            ServerBootstrap serverBootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();            serverBootstrap.group(boss, worker);            <span class="hljs-comment">//配置server通道</span>            serverBootstrap.channel(NioServerSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;            serverBootstrap.childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;                    () &#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                    ch.pipeline()                            .addLast(<span class="hljs-keyword">new</span> HttpRequestDecoder()) <span class="hljs-comment">//http请求的解码器</span>                    <span class="hljs-comment">//将http请求中的uri以及请求体聚合成⼀个完整的</span>                    FullHttpRequest对象                            .addLast(<span class="hljs-keyword">new</span> HttpObjectAggregator(<span class="hljs-number">1024</span> * <span class="hljs-number">128</span>))                            .addLast(<span class="hljs-keyword">new</span> HttpResponseEncoder()) <span class="hljs-comment">//http响应的编码</span>                    器                            .addLast(<span class="hljs-keyword">new</span> ChunkedWriteHandler()) <span class="hljs-comment">//⽀持异步的⼤⽂</span>                    件传输，防⽌内存溢出                            .addLast(<span class="hljs-keyword">new</span> ServerHandler());                &#125;            &#125;); <span class="hljs-comment">//worker线程的处理器</span>            ChannelFuture future = serverBootstrap.bind(<span class="hljs-number">8080</span>).sync();            System.out.println(<span class="hljs-string">"服务器启动完成。。。。。"</span>);            <span class="hljs-comment">//等待服务端监听端⼝关闭</span>            future.channel().closeFuture().sync();        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-comment">//优雅关闭</span>            boss.shutdownGracefully();            worker.shutdownGracefully();        &#125;    &#125;&#125;</code></pre><p>ServerHandler：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.netty.codec.http;<span class="hljs-keyword">import</span> io.netty.buffer.Unpooled;<span class="hljs-keyword">import</span> io.netty.channel.ChannelFutureListener;<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<span class="hljs-keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;<span class="hljs-keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;<span class="hljs-keyword">import</span> io.netty.handler.codec.http.*;<span class="hljs-keyword">import</span> io.netty.util.CharsetUtil;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">FullHttpRequest</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, FullHttpRequest</span></span><span class="hljs-function"><span class="hljs-params">            request)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//解析FullHttpRequest，得到请求参数</span>        Map&lt;String, String&gt; paramMap = <span class="hljs-keyword">new</span> RequestParser(request).parse();        String name = paramMap.get(<span class="hljs-string">"name"</span>);        <span class="hljs-comment">//构造响应对象</span>        FullHttpResponse httpResponse = <span class="hljs-keyword">new</span>                DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);        httpResponse.headers().set(HttpHeaderNames.CONTENT_TYPE,                <span class="hljs-string">"text/html;charset=utf-8"</span>);        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();        sb.append(<span class="hljs-string">"&lt;h1&gt;"</span>);        sb.append(<span class="hljs-string">"你好，"</span> + name);        sb.append(<span class="hljs-string">"&lt;/h1&gt;"</span>);        httpResponse.content().writeBytes(Unpooled.copiedBuffer(sb,                CharsetUtil.UTF_8));        ctx.writeAndFlush(httpResponse)                .addListener(ChannelFutureListener.CLOSE); <span class="hljs-comment">//操作完成后，将channel关闭</span>    &#125;&#125;</code></pre><p>RequestParser：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.netty.codec.http;<span class="hljs-keyword">import</span> io.netty.handler.codec.http.FullHttpRequest;<span class="hljs-keyword">import</span> io.netty.handler.codec.http.HttpMethod;<span class="hljs-keyword">import</span> io.netty.handler.codec.http.QueryStringDecoder;<span class="hljs-keyword">import</span> io.netty.handler.codec.http.multipart.Attribute;<span class="hljs-keyword">import</span> io.netty.handler.codec.http.multipart.HttpPostRequestDecoder;<span class="hljs-keyword">import</span> io.netty.handler.codec.http.multipart.InterfaceHttpData;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.util.HashMap;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-comment">/**</span><span class="hljs-comment"> * HTTP请求参数解析器, ⽀持GET, POST</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RequestParser</span> </span>&#123;    <span class="hljs-keyword">private</span> FullHttpRequest fullReq;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 构造⼀个解析器</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> req</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RequestParser</span><span class="hljs-params">(FullHttpRequest req)</span> </span>&#123;        <span class="hljs-keyword">this</span>.fullReq = req;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 解析请求参数</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 包含所有请求参数的键值对, 如果没有参数, 则返回空Map</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, String&gt; <span class="hljs-title">parse</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        HttpMethod method = fullReq.method();        Map&lt;String, String&gt; parmMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-keyword">if</span> (HttpMethod.GET == method) &#123;            <span class="hljs-comment">// 是GET请求</span>            QueryStringDecoder decoder = <span class="hljs-keyword">new</span> QueryStringDecoder(fullReq.uri());            decoder.parameters().entrySet().forEach(entry -&gt; &#123;                <span class="hljs-comment">// entry.getValue()是⼀个List, 只取第⼀个元素</span>                parmMap.put(entry.getKey(), entry.getValue().get(<span class="hljs-number">0</span>));            &#125;);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (HttpMethod.POST == method) &#123;            <span class="hljs-comment">// 是POST请求</span>            HttpPostRequestDecoder decoder = <span class="hljs-keyword">new</span>                    HttpPostRequestDecoder(fullReq);            decoder.offer(fullReq);            List&lt;InterfaceHttpData&gt; parmList = decoder.getBodyHttpDatas();            <span class="hljs-keyword">for</span> (InterfaceHttpData parm : parmList) &#123;                Attribute data = (Attribute) parm;                parmMap.put(data.getName(), data.getValue());            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 不⽀持其它⽅法</span>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"不⽀持其它⽅法"</span>); <span class="hljs-comment">// 这是个⾃定义的异常, 可删掉这⼀⾏</span>        &#125;        <span class="hljs-keyword">return</span> parmMap;    &#125;&#125;</code></pre><h4 id="对象的编解码"><a href="#对象的编解码" class="headerlink" title="对象的编解码"></a>对象的编解码</h4><p>对于JavaBean对象，Netty也⽀持了Object对象的编解码，其实也就是对象的序列化，要求java对象需要java.io.Serializable接⼝。</p><p>定义javabean对象：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.netty.codec.obj;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = -<span class="hljs-number">89217070354741790L</span>;    <span class="hljs-keyword">private</span> Long id;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> Integer age;    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(Long id)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> age;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(Integer age)</span> </span>&#123;        <span class="hljs-keyword">this</span>.age = age;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"User&#123;"</span> +                <span class="hljs-string">"id="</span> + id +                <span class="hljs-string">", name='"</span> + name + <span class="hljs-string">'\''</span> +                <span class="hljs-string">", age="</span> + age +                <span class="hljs-string">'&#125;'</span>;    &#125;&#125;</code></pre><h5 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h5><p>NettyObjectServer：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.netty.codec.obj;<span class="hljs-keyword">import</span> com.ryhx.drools.test.ServerHandler;<span class="hljs-keyword">import</span> io.netty.bootstrap.ServerBootstrap;<span class="hljs-keyword">import</span> io.netty.channel.ChannelFuture;<span class="hljs-keyword">import</span> io.netty.channel.ChannelInitializer;<span class="hljs-keyword">import</span> io.netty.channel.EventLoopGroup;<span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;<span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;<span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;<span class="hljs-keyword">import</span> io.netty.handler.codec.serialization.ClassResolvers;<span class="hljs-keyword">import</span> io.netty.handler.codec.serialization.ObjectDecoder;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyObjectServer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">// 主线程，不处理任何业务逻辑，只是接收客户的连接请求</span>        EventLoopGroup boss = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);        <span class="hljs-comment">// ⼯作线程，线程数默认是：cpu*2</span>        EventLoopGroup worker = <span class="hljs-keyword">new</span> NioEventLoopGroup();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 服务器启动类</span>            ServerBootstrap serverBootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();            serverBootstrap.group(boss, worker);            <span class="hljs-comment">//配置server通道</span>            serverBootstrap.channel(NioServerSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;            serverBootstrap.childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                    ch.pipeline()                            .addLast(<span class="hljs-keyword">new</span>                                    ObjectDecoder(ClassResolvers.weakCachingResolver(<span class="hljs-keyword">this</span>.getClass().getClassLoader                                    ())))                            .addLast(<span class="hljs-keyword">new</span> ServerHandler());                &#125;            &#125;);             <span class="hljs-comment">//worker线程的处理器</span>            ChannelFuture future = serverBootstrap.bind(<span class="hljs-number">6677</span>).sync();            System.out.println(<span class="hljs-string">"服务器启动完成。。。。。"</span>);            <span class="hljs-comment">//等待服务端监听端⼝关闭</span>            future.channel().closeFuture().sync();        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-comment">//优雅关闭</span>            boss.shutdownGracefully();            worker.shutdownGracefully();        &#125;    &#125;&#125;</code></pre><p>ServerHandler：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.netty.codec.obj;<span class="hljs-keyword">import</span> io.netty.buffer.Unpooled;<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<span class="hljs-keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;<span class="hljs-keyword">import</span> io.netty.util.CharsetUtil;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">User</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, User user)</span> <span class="hljs-keyword">throws</span></span><span class="hljs-function">            Exception </span>&#123;        <span class="hljs-comment">//获取到user对象</span>        System.out.println(user);        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">"ok"</span>, CharsetUtil.UTF_8));    &#125;&#125;</code></pre><h5 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h5><p>NettyObjectClient：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.netty.codec.obj;<span class="hljs-keyword">import</span> com.ryhx.drools.test.ClientHandler;<span class="hljs-keyword">import</span> io.netty.bootstrap.Bootstrap;<span class="hljs-keyword">import</span> io.netty.channel.ChannelFuture;<span class="hljs-keyword">import</span> io.netty.channel.ChannelInitializer;<span class="hljs-keyword">import</span> io.netty.channel.EventLoopGroup;<span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;<span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;<span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;<span class="hljs-keyword">import</span> io.netty.handler.codec.serialization.ObjectEncoder;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyObjectClient</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        EventLoopGroup worker = <span class="hljs-keyword">new</span> NioEventLoopGroup();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 服务器启动类</span>            Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();            bootstrap.group(worker);            bootstrap.channel(NioSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;            bootstrap.handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> ObjectEncoder());                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> ClientHandler());                &#125;            &#125;);            ChannelFuture future = bootstrap.connect(<span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-number">6677</span>).sync();            future.channel().closeFuture().sync();        &#125; <span class="hljs-keyword">finally</span> &#123;            worker.shutdownGracefully();        &#125;    &#125;&#125;</code></pre><p>ClientHandler：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.netty.codec.obj;<span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<span class="hljs-keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;<span class="hljs-keyword">import</span> io.netty.util.CharsetUtil;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">ByteBuf</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf msg)</span> <span class="hljs-keyword">throws</span></span><span class="hljs-function">            Exception </span>&#123;        System.out.println(<span class="hljs-string">"接收到服务端的消息："</span> +                msg.toString(CharsetUtil.UTF_8));    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        User user = <span class="hljs-keyword">new</span> User();        user.setId(<span class="hljs-number">1L</span>);        user.setName(<span class="hljs-string">"张三"</span>);        user.setAge(<span class="hljs-number">20</span>);        ctx.writeAndFlush(user);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span></span><span class="hljs-function">            <span class="hljs-keyword">throws</span> Exception </span>&#123;        cause.printStackTrace();        ctx.close();    &#125;&#125;</code></pre><h4 id="Hessian编解码"><a href="#Hessian编解码" class="headerlink" title="Hessian编解码"></a><strong>Hessian</strong>编解码</h4><p>JDK序列化使⽤是⽐较⽅便，但是它的性能较差，序列化后的字节⼤⼩也⽐较⼤，所以⼀般在项⽬中不会使⽤⾃带的序列化，⽽是会采⽤第三⽅的序列化框架。</p><p>导⼊Hessian依赖：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.caucho<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hessian<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.63<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>User对象：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.netty.codec.hessian;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = -<span class="hljs-number">8200798627910162221L</span>;    <span class="hljs-keyword">private</span> Long id;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> Integer age;    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(Long id)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> age;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(Integer age)</span> </span>&#123;        <span class="hljs-keyword">this</span>.age = age;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"User&#123;"</span> +                <span class="hljs-string">"id="</span> + id +                <span class="hljs-string">", name='"</span> + name + <span class="hljs-string">'\''</span> +                <span class="hljs-string">", age="</span> + age +                <span class="hljs-string">'&#125;'</span>;    &#125;&#125;</code></pre><h5 id="编解码器-1"><a href="#编解码器-1" class="headerlink" title="编解码器"></a>编解码器</h5><p>Hessian序列化⼯具类：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.netty.codec.hessian.codec;<span class="hljs-keyword">import</span> com.caucho.hessian.io.HessianInput;<span class="hljs-keyword">import</span> com.caucho.hessian.io.HessianOutput;<span class="hljs-keyword">import</span> java.io.ByteArrayInputStream;<span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Hessian序列化⼯具类</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HessianSerializer</span> </span>&#123;    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-keyword">byte</span>[] serialize(T obj) &#123;        ByteArrayOutputStream os = <span class="hljs-keyword">new</span> ByteArrayOutputStream();        HessianOutput ho = <span class="hljs-keyword">new</span> HessianOutput(os);        <span class="hljs-keyword">try</span> &#123;            ho.writeObject(obj);            ho.flush();            <span class="hljs-keyword">return</span> os.toByteArray();        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-keyword">try</span> &#123;                ho.close();            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);            &#125;            <span class="hljs-keyword">try</span> &#123;                os.close();            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);            &#125;        &#125;    &#125;    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">Object <span class="hljs-title">deserialize</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] bytes, Class&lt;T&gt; clazz)</span> </span>&#123;        ByteArrayInputStream is = <span class="hljs-keyword">new</span> ByteArrayInputStream(bytes);        HessianInput hi = <span class="hljs-keyword">new</span> HessianInput(is);        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">return</span> (T) hi.readObject(clazz);        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-keyword">try</span> &#123;                hi.close();            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);            &#125;            <span class="hljs-keyword">try</span> &#123;                is.close();            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);            &#125;        &#125;    &#125;&#125;</code></pre><p>编码器：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.netty.codec.hessian.codec;<span class="hljs-keyword">import</span> cn.itcast.netty.coder.hessian.User;<span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<span class="hljs-keyword">import</span> io.netty.handler.codec.MessageToByteEncoder;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HessianEncoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MessageToByteEncoder</span>&lt;<span class="hljs-title">User</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> HessianSerializer hessianSerializer = <span class="hljs-keyword">new</span> HessianSerializer();    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(ChannelHandlerContext ctx, User msg, ByteBuf out)</span></span><span class="hljs-function">            <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">byte</span>[] bytes = hessianSerializer.serialize(msg);        out.writeBytes(bytes);    &#125;&#125;</code></pre><p>解码器：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.netty.codec.hessian.codec;<span class="hljs-keyword">import</span> cn.itcast.netty.coder.hessian.User;<span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<span class="hljs-keyword">import</span> io.netty.handler.codec.ByteToMessageDecoder;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HessianDecoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ByteToMessageDecoder</span> </span>&#123;    <span class="hljs-keyword">private</span> HessianSerializer hessianSerializer = <span class="hljs-keyword">new</span> HessianSerializer();    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt;</span></span><span class="hljs-function"><span class="hljs-params">            out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//复制⼀份ByteBuf数据，轻复制，⾮完全拷⻉</span>        <span class="hljs-comment">//避免出现异常：did not read anything but decoded a message</span>        <span class="hljs-comment">//Netty检测没有读取任何字节就会抛出该异常</span>        ByteBuf in2 = in.retainedDuplicate();        <span class="hljs-keyword">byte</span>[] dst;        <span class="hljs-keyword">if</span> (in2.hasArray()) &#123;            <span class="hljs-comment">//堆缓冲区模式</span>            dst = in2.array();        &#125; <span class="hljs-keyword">else</span> &#123;            dst = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[in2.readableBytes()];            in2.getBytes(in2.readerIndex(), dst);        &#125;        in.skipBytes(in.readableBytes());        <span class="hljs-comment">//跳过所有的字节，表示已经读取过了</span>        Object obj = hessianSerializer.deserialize(dst, User<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        <span class="hljs-comment">//反序列化</span>        out.add(obj);    &#125;&#125;</code></pre><h5 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h5><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.netty.codec.hessian;<span class="hljs-keyword">import</span> cn.itcast.netty.coder.hessian.codec.HessianDecoder;<span class="hljs-keyword">import</span> cn.itcast.netty.coder.hessian.handler.ServerHandler;<span class="hljs-keyword">import</span> io.netty.bootstrap.ServerBootstrap;<span class="hljs-keyword">import</span> io.netty.buffer.UnpooledByteBufAllocator;<span class="hljs-keyword">import</span> io.netty.channel.ChannelFuture;<span class="hljs-keyword">import</span> io.netty.channel.ChannelInitializer;<span class="hljs-keyword">import</span> io.netty.channel.ChannelOption;<span class="hljs-keyword">import</span> io.netty.channel.EventLoopGroup;<span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;<span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;<span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyHessianServer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">// System.setProperty("io.netty.noUnsafe", "true");</span>        <span class="hljs-comment">// 主线程，不处理任何业务逻辑，只是接收客户的连接请求</span>        EventLoopGroup boss = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);        <span class="hljs-comment">// ⼯作线程，线程数默认是：cpu*2</span>        EventLoopGroup worker = <span class="hljs-keyword">new</span> NioEventLoopGroup();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 服务器启动类</span>            ServerBootstrap serverBootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();            serverBootstrap.group(boss, worker);            <span class="hljs-comment">//配置server通道</span>            serverBootstrap.channel(NioServerSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;            serverBootstrap.childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;                    () &#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                    ch.pipeline()                            .addLast(<span class="hljs-keyword">new</span> HessianDecoder())                            .addLast(<span class="hljs-keyword">new</span> ServerHandler());                &#125;            &#125;);            <span class="hljs-comment">//worker线程的处理器</span>            <span class="hljs-comment">// serverBootstrap.childOption(ChannelOption.ALLOCATOR,</span>            UnpooledByteBufAllocator.DEFAULT);            ChannelFuture future = serverBootstrap.bind(<span class="hljs-number">6677</span>).sync();            System.out.println(<span class="hljs-string">"服务器启动完成。。。。。"</span>);            <span class="hljs-comment">//等待服务端监听端⼝关闭</span>            future.channel().closeFuture().sync();        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-comment">//优雅关闭</span>            boss.shutdownGracefully();            worker.shutdownGracefully();        &#125;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.netty.codec.hessian.handler;<span class="hljs-keyword">import</span> cn.itcast.netty.coder.hessian.User;<span class="hljs-keyword">import</span> io.netty.buffer.Unpooled;<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<span class="hljs-keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;<span class="hljs-keyword">import</span> io.netty.util.CharsetUtil;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">User</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, User user)</span> <span class="hljs-keyword">throws</span></span><span class="hljs-function">            Exception </span>&#123;        <span class="hljs-comment">//获取到user对象</span>        System.out.println(user);        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">"ok"</span>, CharsetUtil.UTF_8));    &#125;&#125;</code></pre><h5 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h5><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.netty.codec.hessian;<span class="hljs-keyword">import</span> cn.itcast.netty.coder.hessian.codec.HessianEncoder;<span class="hljs-keyword">import</span> cn.itcast.netty.coder.hessian.handler.ClientHandler;<span class="hljs-keyword">import</span> io.netty.bootstrap.Bootstrap;<span class="hljs-keyword">import</span> io.netty.channel.ChannelFuture;<span class="hljs-keyword">import</span> io.netty.channel.ChannelInitializer;<span class="hljs-keyword">import</span> io.netty.channel.EventLoopGroup;<span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;<span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;<span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;<span class="hljs-keyword">import</span> io.netty.handler.codec.serialization.ObjectEncoder;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyHessianClient</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        EventLoopGroup worker = <span class="hljs-keyword">new</span> NioEventLoopGroup();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 服务器启动类</span>            Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();            bootstrap.group(worker);            bootstrap.channel(NioSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;            bootstrap.handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> HessianEncoder());                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> ClientHandler());                &#125;            &#125;);            ChannelFuture future = bootstrap.connect(<span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-number">6677</span>).sync();            future.channel().closeFuture().sync();        &#125; <span class="hljs-keyword">finally</span> &#123;            worker.shutdownGracefully();        &#125;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.netty.codec.hessian.handler;<span class="hljs-keyword">import</span> cn.itcast.netty.coder.hessian.User;<span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<span class="hljs-keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;<span class="hljs-keyword">import</span> io.netty.util.CharsetUtil;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">ByteBuf</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf msg)</span> <span class="hljs-keyword">throws</span></span><span class="hljs-function">            Exception </span>&#123;        System.out.println(<span class="hljs-string">"接收到服务端的消息："</span> +                msg.toString(CharsetUtil.UTF_8));    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        User user = <span class="hljs-keyword">new</span> User();        user.setId(<span class="hljs-number">1L</span>);        user.setName(<span class="hljs-string">"张三"</span>);        user.setAge(<span class="hljs-number">20</span>);        ctx.writeAndFlush(user);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span></span><span class="hljs-function">            <span class="hljs-keyword">throws</span> Exception </span>&#123;        cause.printStackTrace();        ctx.close();    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty结构解析</title>
    <link href="/blog/2020/08/07/netty-Netty%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/"/>
    <url>/blog/2020/08/07/netty-Netty%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h3 id="Java中的IO模型"><a href="#Java中的IO模型" class="headerlink" title="Java中的IO模型"></a>Java中的IO模型</h3><p>在JDK1.4之前，基于Java所有的socket通信都采⽤了同步阻塞模型（BIO），这种模型性能低下，当时⼤型的服务均采⽤C或C++开发，因为它们可以直接使⽤操作系统提供的异步IO或者AIO，使得性能得到⼤幅提升。</p><p>2002年，JDK1.4发布，新增了java.nio包，提供了许多异步IO开发的API和类库。新增的NIO，极⼤的促进了基于Java的异步⾮阻塞的发展和应⽤。</p><p>2011年，JDK7发布，将原有的NIO进⾏了升级，称为NIO2.0，其中也对AIO进⾏了⽀持。</p><h4 id="BIO模型"><a href="#BIO模型" class="headerlink" title="BIO模型"></a>BIO模型</h4><p>java中的BIO是blocking I/O的简称，它是同步阻塞型IO，其相关的类和接⼝在java.io下。BIO模型简单来讲，就是服务端为每⼀个请求都分配⼀个线程进⾏处理，如下：</p><img src="/blog/2020/08/07/netty-Netty%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/pic1.png" srcset="/blog/img/loading.gif" class><p>示例</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.bio;<span class="hljs-keyword">import</span> java.io.InputStream;<span class="hljs-keyword">import</span> java.net.ServerSocket;<span class="hljs-keyword">import</span> java.net.Socket;<span class="hljs-keyword">import</span> java.nio.charset.StandardCharsets;<span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<span class="hljs-keyword">import</span> java.util.concurrent.Executors;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BIOServer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">6666</span>);        ExecutorService executorService = Executors.newCachedThreadPool();        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;            System.out.println(<span class="hljs-string">"等待客户端连接。。。。"</span>);            Socket socket = serverSocket.accept(); <span class="hljs-comment">//阻塞</span>            executorService.execute(() -&gt; &#123;                <span class="hljs-keyword">try</span> &#123;                    InputStream inputStream = socket.getInputStream(); <span class="hljs-comment">//阻塞</span>                    <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];                    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;                        <span class="hljs-keyword">int</span> length = inputStream.read(bytes);                        <span class="hljs-keyword">if</span> (length == -<span class="hljs-number">1</span>) &#123;                            <span class="hljs-keyword">break</span>;                        &#125;                        System.out.println(<span class="hljs-keyword">new</span> String(bytes, <span class="hljs-number">0</span>, length, StandardCharsets.UTF_8));                    &#125;                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                    e.printStackTrace();                &#125;            &#125;);        &#125;    &#125;&#125;</code></pre><p>这种模式存在的问题：</p><ul><li>客户端的并发数与后端的线程数成1:1的⽐例，线程的创建、销毁是⾮常消耗系统资源的，随着并发量增⼤，服务端性能将显著下降，甚⾄会发⽣线程堆栈溢出等错误。</li><li>当连接创建后，如果该线程没有操作时，会进⾏阻塞操作，这样极⼤的浪费了服务器资源。</li></ul><h4 id="NIO模型"><a href="#NIO模型" class="headerlink" title="NIO模型"></a>NIO模型</h4><p>NIO，称之为New IO 或是 non-block IO （⾮阻塞IO），这两种说法都可以，其实称之为⾮阻塞IO更恰当⼀些。</p><p>NIO相关的代码都放在了java.nio包下，其三⼤核⼼组件：<strong>Buffer</strong>（缓冲区）、<strong>Channel</strong>（通道）、<strong>Selector</strong>（选择器<strong>/</strong>多路复⽤器）</p><ul><li><p>Buffer</p><p>在NIO中，所有的读写操作都是基于缓冲区完成的，底层是通过数组实现的，常⽤的缓冲区是ByteBuffer，每⼀种java基本类型都有对应的缓冲区对象（除了Boolean类型），如：CharBuffer、IntBuffer、LongBuffer等。</p></li><li><p>Channel</p><p>在BIO中是基于Stream实现，⽽在NIO中是基于通道实现，与流不同的是，通道是双向的，既可以读也可以写。</p></li><li><p>Selector</p><p>Selector是多路复⽤器，它会不断的轮询注册在其上的Channel，如果某个Channel上发⽣读或写事件，这个Channel就处于就绪状态，会被Selector轮询出来，然后通过SelectionKey获取就绪Channel的集合，进⾏IO的读写操作。</p></li></ul><img src="/blog/2020/08/07/netty-Netty%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/pic2.png" srcset="/blog/img/loading.gif" class><p>可以看出，NIO模型要优于BIO模型，主要是：</p><ul><li><p>通过多路复⽤器就可以实现⼀个线程处理多个通道，避免了多线程之间的上下⽂切换导致系统开销过⼤。</p></li><li><p>NIO⽆需为每⼀个连接开⼀个线程处理，并且只有通道真正有有事件时，才进⾏读写操作，这样⼤⼤的减少了系统开销。</p></li></ul><p>示例代码：</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.net.InetSocketAddress;<span class="hljs-keyword">import</span> java.net.ServerSocket;<span class="hljs-keyword">import</span> java.nio.ByteBuffer;<span class="hljs-keyword">import</span> java.nio.channels.SelectionKey;<span class="hljs-keyword">import</span> java.nio.channels.Selector;<span class="hljs-keyword">import</span> java.nio.channels.ServerSocketChannel;<span class="hljs-keyword">import</span> java.nio.channels.SocketChannel;<span class="hljs-keyword">import</span> java.util.Iterator;<span class="hljs-keyword">import</span> java.util.Set;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SelectorDemo</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 注册事件</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> Selector <span class="hljs-title">getSelector</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//获取selector对象</span>        Selector selector = Selector.open();        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();        serverSocketChannel.configureBlocking(<span class="hljs-keyword">false</span>); <span class="hljs-comment">//⾮阻塞</span>        <span class="hljs-comment">//获取通道并且绑定端⼝</span>        ServerSocket socket = serverSocketChannel.socket();        socket.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">6677</span>));        <span class="hljs-comment">//注册感兴趣的事件</span>        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);        <span class="hljs-keyword">return</span> selector;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listen</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        Selector selector = <span class="hljs-keyword">this</span>.getSelector();        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;            selector.select(); <span class="hljs-comment">//该⽅法会阻塞，直到⾄少有⼀个事件的发⽣</span>            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();            <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;                SelectionKey selectionKey = iterator.next();                process(selectionKey, selector);                iterator.remove();            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(SelectionKey key, Selector selector)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123; <span class="hljs-comment">//新连接请求</span>            ServerSocketChannel server = (ServerSocketChannel) key.channel();            SocketChannel channel = server.accept();            channel.configureBlocking(<span class="hljs-keyword">false</span>); <span class="hljs-comment">//⾮阻塞</span>            channel.register(selector, SelectionKey.OP_READ);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isReadable()) &#123; <span class="hljs-comment">//读数据</span>            SocketChannel channel = (SocketChannel) key.channel();            ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);            channel.read(byteBuffer);            System.out.println(<span class="hljs-string">"form 客户端 "</span> + <span class="hljs-keyword">new</span> String(byteBuffer.array(),                    <span class="hljs-number">0</span>, byteBuffer.position()));        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">new</span> SelectorDemo().listen();    &#125;&#125;</code></pre><h4 id="AIO模型"><a href="#AIO模型" class="headerlink" title="AIO模型"></a>AIO模型</h4><p>在NIO中，Selector多路复⽤器在做轮询时，如果没有事件发⽣，也会进⾏阻塞，如何能把这个阻塞也优化掉呢？那么AIO就在这样的背景下诞⽣了。</p><p>AIO是asynchronous I/O的简称，是异步IO，该异步IO是需要依赖于操作系统底层的异步IO实现。</p><p>AIO的基本流程是：⽤户线程通过系统调⽤，告知kernel内核启动某个IO操作，⽤户线程返回。kernel内核在整个IO操作（包括数据准备、数据复制）完成后，通知⽤户程序，⽤户执⾏后续的业务操作。</p><blockquote><p>kernel的数据准备</p><p>将数据从⽹络物理设备（⽹卡）读取到内核缓冲区。</p><p>kernel的数据复制</p><p>将数据从内核缓冲区拷⻉到⽤户程序空间的缓冲区。</p></blockquote><img src="/blog/2020/08/07/netty-Netty%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/pic3.png" srcset="/blog/img/loading.gif" class><p>⽬前AIO模型存在的不⾜：</p><ul><li><p>需要完成事件的注册与传递，这⾥边需要底层操作系统提供⼤量的⽀持，去做⼤量的⼯作。</p></li><li><p>Windows 系统下通过 IOCP 实现了真正的异步 I/O。但是，就⽬前的业界形式来说，Windows 系统，很少作为百万级以上或者说⾼并发应⽤的服务器操作系统来使⽤。</p></li><li><p>⽽在 Linux 系统下，异步IO模型在2.6版本才引⼊，⽬前并不完善。所以，这也是在 Linux 下，实现⾼并发⽹络编程时都是以 NIO 多路复⽤模型模式为主。</p></li></ul><h3 id="Reactor线程模型"><a href="#Reactor线程模型" class="headerlink" title="Reactor线程模型"></a>Reactor线程模型</h3><p>Reactor线程模型不是Java专属，也不是Netty专属，它其实是⼀种并发编程模型，是⼀种思想，具有指导意义。⽐如，Netty就是结合了NIO的特点，应⽤了Reactor线程模型所实现的。</p><p>Reactor模型中定义的三种⻆⾊：</p><ul><li><p>Reactor：负责监听和分配事件，将I/O事件分派给对应的Handler。新的事件包含连接建⽴就绪、读就绪、写就绪等。</p></li><li><p>Acceptor：处理客户端新连接，并分派请求到处理器链中。</p></li><li><p>Handler：将⾃身与事件绑定，执⾏⾮阻塞读/写任务，完成channel的读⼊，完成处理业务逻辑后，负责将结果写出channel。</p></li></ul><p>常⻅的Reactor线程模型有三种，如下：</p><ul><li><p>Reactor单线程模型 </p></li><li><p>Reactor多线程模型</p></li><li><p>主从Reactor多线程模型</p></li></ul><h4 id="单Reactor单线程模型"><a href="#单Reactor单线程模型" class="headerlink" title="单Reactor单线程模型"></a>单Reactor单线程模型</h4><img src="/blog/2020/08/07/netty-Netty%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/pic4.png" srcset="/blog/img/loading.gif" class><ul><li><p>Reactor充当多路复⽤器⻆⾊，监听多路连接的请求，由单线程完成</p></li><li><p>Reactor收到客户端发来的请求时，如果是新建连接通过Acceptor完成，其他的请求由Handler完成。</p></li><li><p>Handler完成业务逻辑的处理，基本的流程是：Read –&gt; 业务处理 –&gt; Send 。</p></li></ul><p>这种模型的优缺点：</p><ul><li><p>优点</p><ul><li>结构简单，由单线程完成，没有多线程、进程通信等问题。</li><li>适合⽤在⼀些业务逻辑⽐较简单、对于性能要求不⾼的应⽤场景。</li></ul></li><li><p>缺点</p><ul><li>由于是单线程操作，不能充分发挥多核CPU的性能。</li><li>当Reactor线程负载过重之后，处理速度将变慢，这会导致⼤量客户端连接超时，超时之后往往会进⾏重发，这更加重Reactor线程的负载，最终会导致⼤量消息积压和处理超时，成为系统的性能瓶颈。</li><li>可靠性差，如果该线程进⼊死循环或意外终⽌，就会导致整个通信系统不可⽤，容易造成单点故障。</li></ul></li></ul><h4 id="单Reactor多线程模型"><a href="#单Reactor多线程模型" class="headerlink" title="单Reactor多线程模型"></a>单Reactor多线程模型</h4><img src="/blog/2020/08/07/netty-Netty%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/pic5.png" srcset="/blog/img/loading.gif" class><p>说明：</p><ul><li><p>在Reactor多线程模型相⽐较单线程模型⽽⾔，不同点在于，Handler不会处理业务逻辑，只是负责响应⽤户请求，真正的业务逻辑，在另外的线程中完成。</p></li><li><p>这样可以降低Reactor的性能开销，充分利⽤CPU资源，从⽽更专注的做事件分发⼯作了，提升整个应⽤的吞吐。</p></li></ul><p>但是这个模型存在的问题：</p><ul><li><p>多线程数据共享和访问⽐较复杂。如果⼦线程完成业务处理后，把结果传递给主线程Reactor进⾏发送，就会涉及共享数据的互斥和保护机制。</p></li><li><p>Reactor承担所有事件的监听和响应，只在主线程中运⾏，可能会存在性能问题。例如并发百万客户端连接，或者服务端需要对客户端握⼿进⾏安全认证，但是认证本身⾮常损耗性能。</p></li></ul><p>为了解决性能问题，产⽣了第三种主从Reactor多线程模型。</p><h4 id="主从Reactor多线程模型"><a href="#主从Reactor多线程模型" class="headerlink" title="主从Reactor多线程模型"></a>主从Reactor多线程模型</h4><img src="/blog/2020/08/07/netty-Netty%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/pic6.png" srcset="/blog/img/loading.gif" class><p>在主从模型中，将Reactor分成2部分：</p><ul><li><p>MainReactor负责监听server socket，⽤来处理⽹络IO连接建⽴操作，将建⽴的socketChannel指定注册给SubReactor。</p></li><li><p>SubReactor主要完成和建⽴起来的socket的数据交互和事件业务处理操作。</p></li></ul><p>该模型的优点：</p><ul><li><p>响应快，不必为单个同步事件所阻塞，虽然Reactor本身依然是同步的。</p></li><li><p>可扩展性强，可以⽅便地通过增加SubReactor实例个数来充分利⽤CPU资源。</p></li><li><p>可复⽤性⾼，Reactor模型本身与具体事件处理逻辑⽆关，具有很⾼的复⽤性。</p></li></ul><h4 id="Netty模型"><a href="#Netty模型" class="headerlink" title="Netty模型"></a>Netty模型</h4><p>Netty模型是基于Reactor模型实现的，对于以上三种模型都有⾮常好的⽀持，也⾮常的灵活，⼀般情况，在服务端会采⽤主从架构模型，基本示意图如下：</p><img src="/blog/2020/08/07/netty-Netty%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/pic7.png" srcset="/blog/img/loading.gif" class><p>说明：</p><ul><li><p>在Netty模型中，负责处理新连接事件的是BossGroup，负责处理其他事件的是WorkGroup。Group就是线程池的概念。</p></li><li><p>NioEventLoop表示⼀个不断循环的执⾏处理任务的线程，⽤于监听绑定在其上的读/写事件。</p></li><li><p>通过Pipeline（管道）执⾏业务逻辑的处理，Pipeline中会有多个ChannelHandler，真正的业务逻辑是在ChannelHandler中完成的。</p></li></ul><h3 id="Netty核⼼组件"><a href="#Netty核⼼组件" class="headerlink" title="Netty核⼼组件"></a>Netty核⼼组件</h3><h4 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h4><p>Channel可以理解为是socket连接，在客户端与服务端连接的时候就会建⽴⼀个Channel，它负责基本的IO操作，⽐如：bind()、connect()，read()，write() 等。</p><p>Netty 的 Channel 接⼝所提供的 API，⼤⼤地降低了直接使⽤ Socket 类的复杂性。</p><p>不同协议、不同的阻塞类型的连接都有不同的 Channel 类型与之对应，常⽤的 Channel 类型:</p><ul><li><p>NioSocketChannel，NIO的客户端 TCP Socket 连接。</p></li><li><p>NioServerSocketChannel，NIO的服务器端 TCP Socket 连接。</p></li><li><p>NioDatagramChannel，UDP 连接。</p></li><li><p>NioSctpChannel，客户端 Sctp 连接。</p></li><li><p>NioSctpServerChannel，Sctp 服务器端连接，这些通道涵盖了 UDP 和 TCP ⽹络 IO 以及⽂件IO。</p></li></ul><h4 id="EventLoop、EventLoopGroup"><a href="#EventLoop、EventLoopGroup" class="headerlink" title="EventLoop、EventLoopGroup"></a>EventLoop、EventLoopGroup</h4><p>有了 Channel 连接服务，连接之间可以消息流动。如果服务器发出的消息称作“出站”消息，服务器接受的消息称作“⼊站”消息。那么消息的“出站”/“⼊站”就会产⽣事件（Event）。</p><p>例如：连接已激活；数据读取；⽤户事件；异常事件；打开链接；关闭链接等等。</p><p>有了事件，就需要⼀个机制去监控和协调事件，这个机制（组件）就是EventLoop。 </p><p>在 Netty 中每个 Channel 都会被分配到⼀个 EventLoop。⼀个 EventLoop 可以服务于多个 Channel。每个 EventLoop 会占⽤⼀个 Thread，同时这个 Thread 会处理 EventLoop 上⾯发⽣的所有 IO 操作和事件。</p><img src="/blog/2020/08/07/netty-Netty%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/pic8.png" srcset="/blog/img/loading.gif" class><p>EventLoopGroup 是⽤来⽣成 EventLoop 的，在前⾯的例⼦中，第⼀⾏代码就是 new NioEventLoopGroup();</p><pre><code class="hljs java"><span class="hljs-comment">// 主线程，不处理任何业务逻辑，只是接收客户的连接请求</span>EventLoopGroup boss = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);<span class="hljs-comment">// ⼯作线程，线程数默认是：cpu*2</span>EventLoopGroup worker = <span class="hljs-keyword">new</span> NioEventLoopGroup();</code></pre><p>如果没有指定线程数⼤⼩，默认线程数为：cpu核数*2，源码如下：</p><pre><code class="hljs java"><span class="hljs-keyword">static</span> &#123;DEFAULT_EVENT_LOOP_THREADS = Math.max(<span class="hljs-number">1</span>, SystemPropertyUtil.getInt(<span class="hljs-string">"io.netty.eventLoopThreads"</span>, NettyRuntime.availableProcessors()* <span class="hljs-number">2</span>)); <span class="hljs-comment">//可⽤cpu核数 * 2</span><span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;logger.debug(<span class="hljs-string">"-Dio.netty.eventLoopThreads: &#123;&#125;"</span>,DEFAULT_EVENT_LOOP_THREADS); &#125;&#125;</code></pre><p>关系为：</p><ul><li><p>⼀个 EventLoopGroup 包含⼀个或者多个 EventLoop;</p></li><li><p>⼀个 EventLoop 在它的⽣命周期内只和⼀个 Thread 绑定;</p></li><li><p>所有由 EventLoop 处理的 I/O 事件都将在它专有的 Thread 上被处理;</p></li><li><p>⼀个 Channel 在它的⽣命周期内只注册于⼀个 EventLoop;</p></li><li><p>⼀个 EventLoop 可能会被分配给⼀个或多个 Channel。</p></li></ul><h4 id="ChannelHandler"><a href="#ChannelHandler" class="headerlink" title="ChannelHandler"></a>ChannelHandler</h4><p>ChannelHandler对使⽤者⽽⾔，可以说是最重要的组件了，因为对于数据的⼊站和出站的业务逻辑的编写都是在ChannelHandler中完成的。</p><p>在前⾯的例⼦中，MyChannelHandler就是实现了channelRead⽅法，获取到客户端传来的数据。</p><p>对于数据的出站和⼊站，有着不同的ChannelHandler类型与之对应：</p><ul><li><p>ChannelInboundHandler ⼊站事件处理器</p></li><li><p>ChannelOutBoundHandler 出站事件处理器</p></li></ul><p>接⼝继承关系如下：</p><img src="/blog/2020/08/07/netty-Netty%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/pic9.png" srcset="/blog/img/loading.gif" class><p>ChannelHandlerAdapter提供了⼀些⽅法的默认实现，可减少⽤户对于ChannelHandler的编写。</p><blockquote><p>ChannelInboundHandlerAdapter 与 SimpleChannelInboundHandler的区别：</p><ul><li><p>在服务端编写ChannelHandler时继承的是ChannelInboundHandlerAdapter</p></li><li><p>在客户端编写ChannelHandler时继承的是SimpleChannelInboundHandler</p></li><li><p>两者的区别在于，前者不会释放消息数据的引⽤，⽽后者会释放消息数据的引⽤。</p></li></ul></blockquote><img src="/blog/2020/08/07/netty-Netty%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/pic10.png" srcset="/blog/img/loading.gif" class><h4 id="ChannelPipeline"><a href="#ChannelPipeline" class="headerlink" title="ChannelPipeline"></a>ChannelPipeline</h4><p>在Channel的数据传递过程中，对应着有很多的业务逻辑需要处理，⽐如：编码解码处理、读写操作等，那么对于每种业务逻辑实现都需要有个ChannelHandler完成，也就意味着，⼀个Channel对应着多个ChannelHandler，多个ChannelHandler如何去管理它们，它们的执⾏顺序⼜该是怎么样的，这就需要ChannelPipeline进⾏管理了。</p><p>⼀个Channel包含了⼀个ChannelPipeline，⽽ChannelPipeline中维护了⼀个ChannelHandler的列表。</p><p>ChannelHandler与Channel和ChannelPipeline之间的映射关系，由ChannelHandlerContext进⾏维护。</p><p>它们关系如下：</p><img src="/blog/2020/08/07/netty-Netty%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/pic11.png" srcset="/blog/img/loading.gif" class><p>ChannelHandler按照加⼊的顺序会组成⼀个双向链表，⼊站事件从链表的head往后传递到最后⼀个ChannelHandler，出站事件从链表的tail向前传递，直到最后⼀个ChannelHandler，两种类型的ChannelHandler相互不会影响。</p><h4 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h4><p>Bootstrap是引导的意思，它的作⽤是配置整个Netty程序，将各个组件都串起来，最后绑定端⼝、启动Netty服务。</p><p>Netty中提供了2种类型的引导类，⼀种⽤于客户端(Bootstrap)，⽽另⼀种(ServerBootstrap)⽤于服务器。</p><p>它们的区别在于：</p><ul><li>ServerBootstrap 将绑定到⼀个端⼝，因为服务器必须要监听连接，⽽ Bootstrap 则是由想要连接到远程节点的客户端应⽤程序所使⽤的。</li><li>引导⼀个客户端只需要⼀个EventLoopGroup，但是⼀个ServerBootstrap则需要两个。<ul><li>因为服务器需要两组不同的 Channel</li><li>第⼀组将只包含⼀个 ServerChannel，代表服务器⾃身的已绑定到某个本地端⼝的正在监听的套接字。</li><li>第⼆组将包含所有已创建的⽤来处理传⼊客户端连接。</li></ul></li></ul><img src="/blog/2020/08/07/netty-Netty%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/pic12.png" srcset="/blog/img/loading.gif" class><p>与ServerChannel相关联的EventLoopGroup 将分配⼀个负责为传⼊连接请求创建 Channel 的 EventLoop。⼀旦连接被接受，第⼆个 EventLoopGroup 就会给它的 Channel 分配⼀个 EventLoop。</p><h4 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h4><p>Future提供了⼀种在操作完成时通知应⽤程序的⽅式。这个对象可以看作是⼀个异步操作的结果的占位符，它将在未来的某个时刻完成，并提供对其结果的访问。</p><p>JDK 预置了 interface java.util.concurrent.Future，但是其所提供的实现，只允许⼿动检查对应的操作是否已经完成，或者⼀直阻塞直到它完成。这是⾮常繁琐的，所以 Netty 提供了它⾃⼰的实现——ChannelFuture，⽤于在执⾏异步操作的时候使⽤。</p><ul><li><p>ChannelFuture提供了⼏种额外的⽅法，这些⽅法使得我们能够注册⼀个或者多个ChannelFutureListener实例。</p></li><li><p>监听器的回调⽅法operationComplete()，将会在对应的 操作完成时被调⽤ 。然后监听器可以判断该操作是成功地完成了还是出错了。</p></li><li><p>每个 Netty 的出站 I/O 操作都将返回⼀个 ChannelFuture，也就是说，它们都不会阻塞。 所以说，Netty完全是异步和事件驱动的。</p></li></ul><img src="/blog/2020/08/07/netty-Netty%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/pic13.png" srcset="/blog/img/loading.gif" class><p>上图是 serverBootstrap.bind(port) ⽅法底层的逻辑实现。</p><h4 id="关系图"><a href="#关系图" class="headerlink" title="关系图"></a>关系图</h4><img src="/blog/2020/08/07/netty-Netty%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/pic14.png" srcset="/blog/img/loading.gif" class><h3 id="详解ByteBuf"><a href="#详解ByteBuf" class="headerlink" title="详解ByteBuf"></a>详解ByteBuf</h3><h4 id="⼯作原理"><a href="#⼯作原理" class="headerlink" title="⼯作原理"></a>⼯作原理</h4><p>Java NIO 提供了ByteBuffer 作为它 的字节容器，但是这个类使⽤起来过于复杂，⽽且也有些繁琐。Netty 的 ByteBuffer 替代品是 ByteBuf，⼀个强⼤的实现，既解决了JDK API 的局限性， ⼜为⽹络应⽤程序的开发者提供了更好的API。</p><p>从结构上来说，ByteBuf 由⼀串字节数组构成。数组中每个字节⽤来存放信息。</p><p>ByteBuf 提供了两个索引，⼀个⽤于读取数据，⼀个⽤于写⼊数据。这两个索引通过在字节数组中移动，来定位需要读或者写信息的位置。</p><p>当从 ByteBuf 读取时，它的 readerIndex（读索引）将会根据读取的字节数递增。</p><p>同样，当写 ByteBuf 时，它的 writerIndex（写索引） 也会根据写⼊的字节数进⾏递增。</p><pre><code class="hljs sh">+-------------------+------------------+------------------+| discardable bytes | readable bytes | writable bytes || | (CONTENT) | |+-------------------+------------------+------------------+| | | |0 &lt;= readerIndex &lt;= writerIndex &lt;= capacity<span class="hljs-comment">#discardable bytes -- 可丢弃的字节空间</span><span class="hljs-comment">#readable bytes -- 可读的字节空间</span><span class="hljs-comment">#writable bytes --可写的字节空间</span><span class="hljs-comment">#capacity -- 最⼤的容量</span></code></pre><p>如果 readerIndex 超过了 writerIndex 的时候，Netty 会抛出 IndexOutOf-BoundsException 异常。</p><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><h5 id="读取操作"><a href="#读取操作" class="headerlink" title="读取操作"></a>读取操作</h5><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.myrpc.test;<span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;<span class="hljs-keyword">import</span> io.netty.buffer.Unpooled;<span class="hljs-keyword">import</span> io.netty.util.CharsetUtil;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestByteBuf01</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//构造</span>        ByteBuf byteBuf = Unpooled.copiedBuffer(<span class="hljs-string">"hello world"</span>,                CharsetUtil.UTF_8);        System.out.println(<span class="hljs-string">"byteBuf的容量为："</span> + byteBuf.capacity());        System.out.println(<span class="hljs-string">"byteBuf的可读容量为："</span> + byteBuf.readableBytes());        System.out.println(<span class="hljs-string">"byteBuf的可写容量为："</span> + byteBuf.writableBytes());        <span class="hljs-keyword">while</span> (byteBuf.isReadable()) &#123; <span class="hljs-comment">//⽅法⼀：内部通过移动readerIndex进⾏读取</span>            System.out.println((<span class="hljs-keyword">char</span>) byteBuf.readByte());        &#125;        <span class="hljs-comment">//⽅法⼆：通过下标直接读取</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; byteBuf.readableBytes(); i++) &#123;            System.out.println((<span class="hljs-keyword">char</span>) byteBuf.getByte(i));        &#125;        <span class="hljs-comment">//⽅法三：转化为byte[]进⾏读取</span>        <span class="hljs-keyword">byte</span>[] bytes = byteBuf.array();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">byte</span> b : bytes) &#123;            System.out.println((<span class="hljs-keyword">char</span>) b);        &#125;    &#125;&#125;</code></pre><h5 id="写入操作"><a href="#写入操作" class="headerlink" title="写入操作"></a>写入操作</h5><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.myrpc.test;<span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;<span class="hljs-keyword">import</span> io.netty.buffer.Unpooled;<span class="hljs-keyword">import</span> io.netty.util.CharsetUtil;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestByteBuf02</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//构造空的字节缓冲区，初始⼤⼩为10，最⼤为20</span>        ByteBuf byteBuf = Unpooled.buffer(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);        System.out.println(<span class="hljs-string">"byteBuf的容量为："</span> + byteBuf.capacity());        System.out.println(<span class="hljs-string">"byteBuf的可读容量为："</span> + byteBuf.readableBytes());        System.out.println(<span class="hljs-string">"byteBuf的可写容量为："</span> + byteBuf.writableBytes());        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;            byteBuf.writeInt(i); <span class="hljs-comment">//写⼊int类型，⼀个int占4个字节</span>        &#125;        System.out.println(<span class="hljs-string">"ok"</span>);        System.out.println(<span class="hljs-string">"byteBuf的容量为："</span> + byteBuf.capacity());        System.out.println(<span class="hljs-string">"byteBuf的可读容量为："</span> + byteBuf.readableBytes());        System.out.println(<span class="hljs-string">"byteBuf的可写容量为："</span> + byteBuf.writableBytes());        <span class="hljs-keyword">while</span> (byteBuf.isReadable()) &#123;            System.out.println(byteBuf.readInt());        &#125;    &#125;&#125;</code></pre><h5 id="丢弃已读字节"><a href="#丢弃已读字节" class="headerlink" title="丢弃已读字节"></a>丢弃已读字节</h5><pre><code class="hljs sh"><span class="hljs-comment">#通过discardReadBytes()⽅可以将已经读取的数据进⾏丢弃处理，就可以回收已经读取的字节空间</span>BEFORE discardReadBytes()+-------------------+------------------+------------------+| discardable bytes | readable bytes | writable bytes |+-------------------+------------------+------------------+| | | |0 &lt;= readerIndex &lt;= writerIndex &lt;= capacityAFTER discardReadBytes()+------------------+--------------------------------------+| readable bytes | writable bytes (got more space) |+------------------+--------------------------------------+| | |readerIndex (0) &lt;= writerIndex (decreased)</code></pre><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.myrpc.test;<span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;<span class="hljs-keyword">import</span> io.netty.buffer.Unpooled;<span class="hljs-keyword">import</span> io.netty.util.CharsetUtil;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestByteBuf03</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ByteBuf byteBuf = Unpooled.copiedBuffer(<span class="hljs-string">"hello world"</span>,                CharsetUtil.UTF_8);        System.out.println(<span class="hljs-string">"byteBuf的容量为："</span> + byteBuf.capacity());        System.out.println(<span class="hljs-string">"byteBuf的可读容量为："</span> + byteBuf.readableBytes());        System.out.println(<span class="hljs-string">"byteBuf的可写容量为："</span> + byteBuf.writableBytes());        <span class="hljs-keyword">while</span> (byteBuf.isReadable()) &#123;            System.out.println((<span class="hljs-keyword">char</span>) byteBuf.readByte());        &#125;        byteBuf.discardReadBytes(); <span class="hljs-comment">//丢弃已读的字节空间</span>        System.out.println(<span class="hljs-string">"byteBuf的容量为："</span> + byteBuf.capacity());        System.out.println(<span class="hljs-string">"byteBuf的可读容量为："</span> + byteBuf.readableBytes());        System.out.println(<span class="hljs-string">"byteBuf的可写容量为："</span> + byteBuf.writableBytes());    &#125;&#125;</code></pre><h5 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h5><pre><code class="hljs sh"><span class="hljs-comment">#通过clear() 重置readerIndex 、 writerIndex 为0，需要注意的是，重置并没有删除真正的内容</span>BEFORE clear()+-------------------+------------------+------------------+| discardable bytes | readable bytes | writable bytes |+-------------------+------------------+------------------+| | | |0 &lt;= readerIndex &lt;= writerIndex &lt;= capacityAFTER clear()+---------------------------------------------------------+| writable bytes (got more space) |+---------------------------------------------------------+| |0 = readerIndex = writerIndex &lt;= capacity</code></pre><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.myrpc.test;<span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;<span class="hljs-keyword">import</span> io.netty.buffer.Unpooled;<span class="hljs-keyword">import</span> io.netty.util.CharsetUtil;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestByteBuf04</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ByteBuf byteBuf = Unpooled.copiedBuffer(<span class="hljs-string">"hello world"</span>,                CharsetUtil.UTF_8);        System.out.println(<span class="hljs-string">"byteBuf的容量为："</span> + byteBuf.capacity());        System.out.println(<span class="hljs-string">"byteBuf的可读容量为："</span> + byteBuf.readableBytes());        System.out.println(<span class="hljs-string">"byteBuf的可写容量为："</span> + byteBuf.writableBytes());        byteBuf.clear(); <span class="hljs-comment">//重置readerIndex 、 writerIndex 为0</span>        System.out.println(<span class="hljs-string">"byteBuf的容量为："</span> + byteBuf.capacity());        System.out.println(<span class="hljs-string">"byteBuf的可读容量为："</span> + byteBuf.readableBytes());        System.out.println(<span class="hljs-string">"byteBuf的可写容量为："</span> + byteBuf.writableBytes());    &#125;&#125;</code></pre><h4 id="ByteBuf-使⽤模式"><a href="#ByteBuf-使⽤模式" class="headerlink" title="ByteBuf 使⽤模式"></a>ByteBuf 使⽤模式</h4><p>根据存放缓冲区的不同分为三类：</p><ul><li><p>堆缓冲区（<strong>HeapByteBuf</strong>），内存的分配和回收速度⽐较快，可以被JVM⾃动回收，缺点是，如果进⾏socket的IO读写，需要额外做⼀次内存复制，将堆内存对应的缓冲区复制到内核Channel中，性能会有⼀定程度的下降。</p><p>由于在堆上被 JVM 管理，在不被使⽤时可以快速释放。可以通过 ByteBuf.array() 来获取 byte[] 数据。</p></li><li><p>直接缓冲区（<strong>DirectByteBuf</strong>），⾮堆内存，它在对外进⾏内存分配，相⽐堆内存，它的分配和回收速度会慢⼀些，但是将它写⼊或从Socket Channel中读取时，由于减少了⼀次内存拷⻉，速度⽐堆内存块。</p></li><li><p>复合缓冲区，顾名思义就是将上述两类缓冲区聚合在⼀起。Netty 提供了⼀个 CompsiteByteBuf，可以将堆缓冲区和直接缓冲区的数据放在⼀起，让使⽤更加⽅便。</p></li></ul><pre><code class="hljs java"><span class="hljs-comment">//默认使⽤的是DirectByteBuf，如果需要使⽤HeapByteBuf模式，则需要进⾏系统参数的设置</span>System.setProperty(<span class="hljs-string">"io.netty.noUnsafe"</span>, <span class="hljs-string">"true"</span>); <span class="hljs-comment">//netty中IO操作都是基于Unsafe完</span>成的<span class="hljs-comment">//ByteBuf 的分配要设置为⾮池化，否则不能切换到堆缓冲器模式</span>serverBootstrap.childOption(ChannelOption.ALLOCATOR,UnpooledByteBufAllocator.DEFAULT);</code></pre><h4 id="ByteBuf-的分配"><a href="#ByteBuf-的分配" class="headerlink" title="ByteBuf 的分配"></a>ByteBuf 的分配</h4><p>Netty 提供了两种 ByteBufAllocator 的实现，分别是：</p><ul><li><p><strong>PooledByteBufAllocator</strong>，实现了 ByteBuf 的对象的池化，提⾼性能减少并最⼤限度地减少内存碎⽚。</p></li><li><p><strong>UnpooledByteBufAllocator</strong>，没有实现对象的池化，每次会⽣成新的对象实例。</p></li></ul><pre><code class="hljs java"><span class="hljs-comment">//通过ChannelHandlerContext获取ByteBufAllocator实例</span>ctx.alloc();<span class="hljs-comment">//通过channel也可以获取</span>channel.alloc();<span class="hljs-comment">//Netty默认使⽤了PooledByteBufAllocator</span><span class="hljs-comment">//可以在引导类中设置⾮池化模式</span>serverBootstrap.childOption(ChannelOption.ALLOCATOR,UnpooledByteBufAllocator.DEFAULT);<span class="hljs-comment">//或通过系统参数设置</span>System.setProperty(<span class="hljs-string">"io.netty.allocator.type"</span>, <span class="hljs-string">"pooled"</span>);System.setProperty(<span class="hljs-string">"io.netty.allocator.type"</span>, <span class="hljs-string">"unpooled"</span>);</code></pre><h4 id="ByteBuf-的释放"><a href="#ByteBuf-的释放" class="headerlink" title="ByteBuf 的释放"></a>ByteBuf 的释放</h4><p>ByteBuf如果采⽤的是堆缓冲区模式的话，可以由GC回收，但是如果采⽤的是直接缓冲区，就不受GC的管理，就得⼿动释放，否则会发⽣内存泄露。</p><p>关于ByteBuf的释放，分为⼿动释放与⾃动释放。</p><h5 id="⼿动释放"><a href="#⼿动释放" class="headerlink" title="⼿动释放"></a>⼿动释放</h5><p>⼿动释放，就是在使⽤完成后，调⽤ReferenceCountUtil.release(byteBuf); 进⾏释放。</p><p>通过release⽅法减去 byteBuf 的使⽤计数，Netty 会⾃动回收 byteBuf 。</p><p>示例：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 获取客户端发来的数据</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> ctx</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> msg</span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> Exception</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span></span><span class="hljs-function">        Exception </span>&#123;    ByteBuf byteBuf = (ByteBuf) msg;    String msgStr = byteBuf.toString(CharsetUtil.UTF_8);    System.out.println(<span class="hljs-string">"客户端发来数据："</span> + msgStr);    <span class="hljs-comment">//释放资源</span>    ReferenceCountUtil.release(byteBuf);&#125;</code></pre><p>⼿动释放可以达到⽬的，但是这种⽅式会⽐较繁琐，如果⼀旦忘记释放就可能会造成内存泄露。</p><h5 id="⾃动释放"><a href="#⾃动释放" class="headerlink" title="⾃动释放"></a>⾃动释放</h5><p>⾃动释放有三种⽅式，分别是：⼊站的TailHandler、继承SimpleChannelInboundHandler、HeadHandler的出站释放。</p><p><strong>TailHandler</strong></p><p>Netty的ChannelPipleline的流⽔线的末端是TailHandler，默认情况下如果每个⼊站处理器Handler都把消息往下传，TailHandler会释放掉ReferenceCounted类型的消息。</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 获取客户端发来的数据</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> ctx</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> msg</span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> Exception</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span></span><span class="hljs-function">        Exception </span>&#123;    ByteBuf byteBuf = (ByteBuf) msg;    String msgStr = byteBuf.toString(CharsetUtil.UTF_8);    System.out.println(<span class="hljs-string">"客户端发来数据："</span> + msgStr);    <span class="hljs-comment">//向客户端发送数据</span>    ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">"ok"</span>, CharsetUtil.UTF_8));    ctx.fireChannelRead(msg); <span class="hljs-comment">//将ByteBuf向下传递</span>&#125;</code></pre><p>在DefaultChannelPipeline中的TailContext内部类会在最后执⾏：</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;    onUnhandledInboundMessage(ctx, msg);&#125;<span class="hljs-comment">//最后会执⾏</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onUnhandledInboundMessage</span><span class="hljs-params">(Object msg)</span> </span>&#123;    <span class="hljs-keyword">try</span> &#123;        logger.debug(                <span class="hljs-string">"Discarded inbound message &#123;&#125; that reached at the tail of the</span><span class="hljs-string">                pipeline."</span> +                <span class="hljs-string">"Please check your pipeline configuration."</span>, msg);    &#125; <span class="hljs-keyword">finally</span> &#123;        ReferenceCountUtil.release(msg); <span class="hljs-comment">//释放资源</span>    &#125;&#125;</code></pre><p>需要注意的是，如果没有进⾏向下传递，那么在TailHandler中是不会进⾏释放操作的。</p><p><strong>SimpleChannelInboundHandler</strong></p><p>当ChannelHandler继承了SimpleChannelInboundHandler后，在SimpleChannelInboundHandler的channelRead()⽅法中，将会进⾏资源的释放，我们的业务代码也需要写⼊到channelRead0()中。</p><pre><code class="hljs java"><span class="hljs-comment">//SimpleChannelInboundHandler中的channelRead()</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span></span><span class="hljs-function">        Exception </span>&#123;    <span class="hljs-keyword">boolean</span> release = <span class="hljs-keyword">true</span>;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">if</span> (acceptInboundMessage(msg)) &#123;            <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>) I imsg = (I) msg;            channelRead0(ctx, imsg);        &#125; <span class="hljs-keyword">else</span> &#123;            release = <span class="hljs-keyword">false</span>;            ctx.fireChannelRead(msg);        &#125;    &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-keyword">if</span> (autoRelease &amp;&amp; release) &#123;            ReferenceCountUtil.release(msg); <span class="hljs-comment">//在这⾥释放</span>        &#125;    &#125;&#125;</code></pre><p>使用</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.myrpc.client.handler;<span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;<span class="hljs-keyword">import</span> io.netty.buffer.Unpooled;<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<span class="hljs-keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;<span class="hljs-keyword">import</span> io.netty.util.CharsetUtil;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">ByteBuf</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf msg)</span> <span class="hljs-keyword">throws</span></span><span class="hljs-function">            Exception </span>&#123;        System.out.println(<span class="hljs-string">"接收到服务端的消息："</span> +                msg.toString(CharsetUtil.UTF_8));    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">// 向服务端发送数据</span>        String msg = <span class="hljs-string">"hello"</span>;        ctx.writeAndFlush(Unpooled.copiedBuffer(msg, CharsetUtil.UTF_8));    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span></span><span class="hljs-function">            <span class="hljs-keyword">throws</span> Exception </span>&#123;        cause.printStackTrace();        ctx.close();    &#125;&#125;</code></pre><p><strong>HeadHandler</strong></p><p>出站处理流程中，申请分配到的 ByteBuf，通过 HeadHandler 完成⾃动释放。</p><p>出站处理⽤到的 Bytebuf 缓冲区，⼀般是要发送的消息，通常由应⽤所申请。在出站流程开始的时候，通过调⽤ ctx.writeAndFlush(msg)，Bytebuf 缓冲区开始进⼊出站处理的 pipeline 流⽔线 。</p><p>在每⼀个出站Handler中的处理完成后，最后消息会来到出站的最后⼀棒 HeadHandler，再经过⼀轮复杂的调⽤，在flush完成后终将被release掉。</p><p>示例：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.myrpc.client.handler;<span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;<span class="hljs-keyword">import</span> io.netty.buffer.Unpooled;<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<span class="hljs-keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;<span class="hljs-keyword">import</span> io.netty.util.CharsetUtil;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">ByteBuf</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf msg)</span> <span class="hljs-keyword">throws</span></span><span class="hljs-function">            Exception </span>&#123;        System.out.println(<span class="hljs-string">"接收到服务端的消息："</span> +                msg.toString(CharsetUtil.UTF_8));    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">// 向服务端发送数据</span>        String msg = <span class="hljs-string">"hello"</span>;        ctx.writeAndFlush(Unpooled.copiedBuffer(msg, CharsetUtil.UTF_8));    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span></span><span class="hljs-function">            <span class="hljs-keyword">throws</span> Exception </span>&#123;        cause.printStackTrace();        ctx.close();    &#125;&#125;</code></pre><p>执⾏⽅法调⽤链：</p><img src="/blog/2020/08/07/netty-Netty%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/pic15.png" srcset="/blog/img/loading.gif" class><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>⼊站处理流程中，如果对原消息不做处理，调⽤ ctx.fireChannelRead(msg) 把原消息往下传，由流⽔线最后⼀棒 TailHandler 完成⾃动释放。</p></li><li><p>如果截断了⼊站处理流⽔线，则可以继承 SimpleChannelInboundHandler ，完成⼊站ByteBuf ⾃动释放。</p></li><li><p>出站处理过程中，申请分配到的 ByteBuf，通过 HeadHandler 完成⾃动释放。</p></li><li><p>⼊站处理中，如果将原消息转化为新的消息并调⽤ ctx.fireChannelRead(newMsg)往下传，那必须把原消息release掉;</p></li><li><p>⼊站处理中，如果已经不再调⽤ ctx.fireChannelRead(msg) 传递任何消息，也没有继承SimpleChannelInboundHandler 完成⾃动释放，那更要把原消息release掉;</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty入门</title>
    <link href="/blog/2020/08/07/netty-Netty%E5%85%A5%E9%97%A8/"/>
    <url>/blog/2020/08/07/netty-Netty%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Netty是⼀个⾼性能的、异步的、基于事件驱动的⽹络应⽤框架。官⽹：<a href="https://netty.io/" target="_blank" rel="noopener">https://netty.io/</a></p><p>官方描述</p><blockquote><p>Netty is <em>an asynchronous event-driven network application framework</em> for rapid development of maintainable high performance protocol servers &amp; clients.</p></blockquote><h4 id="异步、事件驱动"><a href="#异步、事件驱动" class="headerlink" title="异步、事件驱动"></a>异步、事件驱动</h4><p>同步、异步是相对的，在请求或执⾏过程中，如果会阻塞等待，就是同步操作，反之就是异步操作。</p><img src="/blog/2020/08/07/netty-Netty%E5%85%A5%E9%97%A8/pic1.png" srcset="/blog/img/loading.gif" class><h4 id="核⼼架构"><a href="#核⼼架构" class="headerlink" title="核⼼架构"></a>核⼼架构</h4><img src="/blog/2020/08/07/netty-Netty%E5%85%A5%E9%97%A8/pic2.png" srcset="/blog/img/loading.gif" class><ul><li><p>核⼼</p><ul><li><p>可扩展的事件模型</p></li><li><p>统⼀的通信api</p><ul><li>⽆论是http还是socket都使⽤统⼀的api，简化了操作</li></ul></li><li><p>零拷⻉机制与字节缓冲区</p></li></ul></li><li><p>传输服务</p><ul><li>⽀持socket以及datagram（数据报）</li><li>⽀持http协议</li><li>In-VM Pipe （管道协议）</li></ul></li><li><p>协议⽀持</p><ul><li>http 以及 websocket</li><li>SSL 安全套接字协议⽀持</li><li>Google Protobuf （序列化框架）</li><li>⽀持zlib、gzip压缩</li><li>⽀持⼤⽂件的传输</li><li>RTSP（实时流传输协议，是TCP/IP协议体系中的⼀个应⽤层协议）</li><li>⽀持⼆进制协议并且提供了完整的单元测试</li></ul></li></ul><h4 id="Netty优势"><a href="#Netty优势" class="headerlink" title="Netty优势"></a>Netty优势</h4><ul><li>Netty是基于Java的NIO实现的，Netty将各种传输类型、协议的实现API进⾏了统⼀封装，实现了阻塞和⾮阻塞Socket。</li><li>基于事件模型实现，可以清晰的分离关注点，让开发者可以聚焦业务，提升开发效率。</li><li>⾼度可定制的线程模型-单线程、⼀个或多个线程池，如SEDA（Staged Event-Driven Architecture）<ul><li>SEDA：把⼀个请求处理过程分成⼏个Stage，不同资源消耗的Stage使⽤不同数量的线程来处理，Stage间使⽤事件驱动的异步通信模式。</li></ul></li><li>Netty只依赖了JDK底层api，没有其他的依赖，如：Netty 3.X依赖JDK5以上，Netty4.x依赖JDK6以上。</li><li>Netty在⽹络通信⽅⾯更加的⾼性能、低延迟，尽可能的减少不必要的内存拷⻉，提⾼性能。</li><li>在安全⽅⾯，完整的SSL/TLS和StartTLS⽀持。</li><li>社区⽐较活跃，版本迭代周期短，发现bug可以快速修复，新版本也会不断的加⼊。</li></ul><h4 id="版本说明"><a href="#版本说明" class="headerlink" title="版本说明"></a>版本说明</h4><p>Netty的版本分为，3.x、4.x和5.x，其中5.x版本已经被官⽅废弃，详情查看github的issue：<a href="https://github.com/netty/netty/issues/4466" target="_blank" rel="noopener">https://github.com/netty/netty/issues/4466</a></p><p>废弃5.x的主要原因是，使⽤ForkJoinPool后复杂度提升了，但是性能⽅⾯并没有明显的优势，反⽽给项⽬的维护带来了很⼤的⼯作量，因此还有到发布新版本的时机，所以将5.x废弃。</p><h4 id="相比原生NIO的优势"><a href="#相比原生NIO的优势" class="headerlink" title="相比原生NIO的优势"></a>相比原生NIO的优势</h4><ul><li><p>在⽹络编程⽅⾯，⼀般都不会选择原⽣的NIO，⽽是会选择Netty、Mina等封装后的框架，主要原因是：NIO的类库和API繁杂，使⽤麻烦，需要熟练掌握Selector、ServerSocketChannel、SocketChannel、ByteBuffer等。</p></li><li><p>需要具备其他的额外技能做铺垫，例如熟悉Java多线程编程。这是因为NIO编程涉及到Reactor模式，你必须对多线程和⽹路编程⾮常熟悉，才能编写出⾼质量的NIO程序。</p></li><li><p>可靠性能⼒补⻬，⼯作量和难度都⾮常⼤。例如客户端⾯临断连重连、⽹络闪断、半包读写、失败缓存、⽹络拥塞和异常码流的处理等问题，NIO编程的特点是功能开发相对容易，但是可靠性能⼒补⻬的⼯作量和难度都⾮常⼤。</p></li><li><p>JDK NIO的BUG，例如臭名昭著的epoll bug，它会导致Selector空轮询，最终导致CPU 100%。官⽅声称在JDK 1.6版本的update18修复了该问题，但是直到JDK 1.7版本该问题仍旧存在，只不过该BUG发⽣概率降低了⼀些⽽已，它并没有得到根本性解决。具体问题查看：<a href="https://www.jianshu.com/p/3ec120ca46b2" target="_blank" rel="noopener">https://www.jianshu.com/p/3ec120ca46b2</a></p></li></ul><h3 id="快速使用"><a href="#快速使用" class="headerlink" title="快速使用"></a>快速使用</h3><p>pom.xml文件</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>netty-demo<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>netty-demo<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>    <span class="hljs-comment">&lt;!-- FIXME change it to the project's website --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://www.example.com<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.netty<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>netty-all<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.1.50.Final<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">encoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">encoding</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.server;<span class="hljs-keyword">import</span> io.netty.bootstrap.ServerBootstrap;<span class="hljs-keyword">import</span> io.netty.channel.ChannelFuture;<span class="hljs-keyword">import</span> io.netty.channel.EventLoopGroup;<span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;<span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        EventLoopGroup boss = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);        NioEventLoopGroup worker = <span class="hljs-keyword">new</span> NioEventLoopGroup();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 服务器启动类</span>            ServerBootstrap serverBootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();            <span class="hljs-comment">// 设置线程组 配置server通道 worker线程处理器</span>            serverBootstrap.group(boss, worker)                    .channel(NioServerSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">                    .<span class="hljs-title">childHandler</span>(<span class="hljs-title">new</span> <span class="hljs-title">MyChannelInitializer</span>())</span>;            ChannelFuture future = serverBootstrap.bind(port).sync();            System.out.println(<span class="hljs-string">"服务器启动完成，端口："</span> + port);            future.channel().closeFuture().sync();        &#125; <span class="hljs-keyword">finally</span> &#123;            boss.shutdownGracefully();            worker.shutdownGracefully();        &#125;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.server;<span class="hljs-keyword">import</span> io.netty.channel.ChannelInitializer;<span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyChannelInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">SocketChannel</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> MyChannelHandler());    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.server;<span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;<span class="hljs-keyword">import</span> io.netty.buffer.Unpooled;<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<span class="hljs-keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;<span class="hljs-keyword">import</span> io.netty.util.CharsetUtil;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyChannelHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ByteBuf byteBuf = (ByteBuf) msg;        String msgStr = byteBuf.toString(CharsetUtil.UTF_8);        System.out.println(<span class="hljs-string">"客户端发来数据："</span> + msgStr);        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">"ok"</span>, CharsetUtil.UTF_8));        <span class="hljs-keyword">super</span>.channelRead(ctx, msg);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        cause.printStackTrace();        ctx.close();    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestServer</span> </span>&#123;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testServer</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;        MyServer myServer = <span class="hljs-keyword">new</span> MyServer();        myServer.start(<span class="hljs-number">5566</span>);    &#125;&#125;</code></pre><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.client;<span class="hljs-keyword">import</span> io.netty.bootstrap.Bootstrap;<span class="hljs-keyword">import</span> io.netty.channel.ChannelFuture;<span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;<span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClient</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">(String host,<span class="hljs-keyword">int</span> port)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;        NioEventLoopGroup worker = <span class="hljs-keyword">new</span> NioEventLoopGroup();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// client使用的是Bootstrap</span>            Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();            bootstrap.group(worker)                    .channel(NioSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">                    .<span class="hljs-title">handler</span>(<span class="hljs-title">new</span> <span class="hljs-title">MyClientHandler</span>())</span>;            <span class="hljs-comment">// 连接到远程服务</span>            ChannelFuture future = bootstrap.connect(host, port).sync();            future.channel().closeFuture().sync();        &#125;<span class="hljs-keyword">finally</span> &#123;            worker.shutdownGracefully();        &#125;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.client;<span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;<span class="hljs-keyword">import</span> io.netty.buffer.Unpooled;<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<span class="hljs-keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;<span class="hljs-keyword">import</span> io.netty.util.CharsetUtil;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">ByteBuf</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(<span class="hljs-string">"接收到服务端消息："</span> + byteBuf.toString(CharsetUtil.UTF_8));    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">// 向服务端发送数据</span>        String msg = <span class="hljs-string">"hello"</span>;        ctx.writeAndFlush(Unpooled.copiedBuffer(msg, CharsetUtil.UTF_8));    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        cause.printStackTrace();        ctx.close();    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.client;<span class="hljs-keyword">import</span> org.junit.Test;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestClient</span> </span>&#123;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testClient</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;        <span class="hljs-keyword">new</span> MyClient().start(<span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-number">5566</span>);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AQS详解</title>
    <link href="/blog/2020/07/30/JUC-AQS%E8%AF%A6%E8%A7%A3/"/>
    <url>/blog/2020/07/30/JUC-AQS%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h3 id="AQS使用方式"><a href="#AQS使用方式" class="headerlink" title="AQS使用方式"></a>AQS使用方式</h3><p>AQS在之前锁的笔记中已经做了简要介绍，本篇着重分析其实现方式。</p><p>AQS的主要使用方式是继承，子类通过继承AQS并实现它的抽象方法来管理同步状态，在AQS里由一个int型的state来代表这个状态，在抽象方法的实现过程中免不了要对同步状态进行更改，这时就需要使用同步器提供的3个方法（getState()、setState(int newState)和compareAndSetState(int expect,int update)）来进行操作，因为它们能够保证状态的改变是安全的。</p><p>AQS自身没有实现任何同步接口，它仅仅是定义了若干同步状态获取和释放的方法来供自定义同步组件使用，同步器既可以支持独占式地获取同步状态，也可以支持共享式地获取同步状态，这样就可以方便实现不同类型的同步组件（ReentrantLock、ReentrantReadWriteLock和CountDownLatch等）。</p><p>同步器是实现锁（也可以是任意同步组件）的关键，在锁的实现中聚合同步器。可以这样理解二者之间的关系：锁是面向使用者的，它定义了使用者与锁交互的接口（比如可以允许两个线程并行访问），隐藏了实现细节；同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。锁和同步器很好地隔离了使用者和实现者所需关注的领域。</p><p>实现者需要继承同步器并重写指定的方法，随后将同步器组合在自定义同步组件的实现中，并调用同步器提供的模板方法，而这些模板方法将会调用使用者重写的方法。</p><h3 id="AQS中的方法"><a href="#AQS中的方法" class="headerlink" title="AQS中的方法"></a>AQS中的方法</h3><h4 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h4><p>实现自定义同步组件时，将会调用同步器提供的模板方法，</p><table><thead><tr><th align="left">方法名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">void acquire(int arg)</td><td align="left">独占式获取同步状态，如果当前线程获取同步状态成功，则由该方法返回，否则，将会进人同步队列等待，该方法将会调用重写的tryAcquire(int  arg)方法</td></tr><tr><td align="left">void acquireInterruptibly(int arg)</td><td align="left">与acquire(int arg)相同，但是该方法响应中断，当前线程未获取到同步状态而进入同步队列中，如果当前线程被中断，则该方法会抛出InterruptedException并返回</td></tr><tr><td align="left">boolean tryAcquireNanos(int arg,long nanos)</td><td align="left">在acquireInterruptibly(int arg)基础上增加了超时限制，如果当前线程在超时时间内没有获取到同步状态，那么将会返回false.如果获取到了返回true</td></tr><tr><td align="left">void acquireShared(int arg)</td><td align="left">共享式的获取同步状态，如果当前线程未获取到同步状态,将会进人同步队列等待，与独占式获取的主要区别是在同一时刻可以有多个线程获取到同步状态</td></tr><tr><td align="left">void acquireSharedInteruptibly(int arg)</td><td align="left">与acquireShared(int arg)相同，该方法响应中断</td></tr><tr><td align="left">boolean tryAcquireSharedNanos(int arg, long nanos)</td><td align="left">在acquireSharedInterruptibly(int arg)基础上增加了超时限制</td></tr><tr><td align="left">boolean release(int arg)</td><td align="left">独占式的释放同步状态，该方法会在释放同步状态之后，将同步队列中第一个节点包含的线程唤醒</td></tr><tr><td align="left">boolean releaseShared(int arg)</td><td align="left">共享式的释放同步状态</td></tr><tr><td align="left">Collection&lt; Thread&gt; getQueuedThreads()</td><td align="left">获取等待在同步队列上的线程集合</td></tr></tbody></table><p>这些模板方法同步器提供的模板方法基本上分为3类：独占式获取与释放同步状态、共享式获取与释放、同步状态和查询同步队列中的等待线程情况。</p><h4 id="可重写的方法"><a href="#可重写的方法" class="headerlink" title="可重写的方法"></a>可重写的方法</h4><table><thead><tr><th align="left">方法名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">protected boolean tryAcquire(int arg)</td><td align="left">独占式获取同步状态，实现该方法需要查询当前状态并判断同步状态是否符合预期，然后再进行CAS设置同步状态</td></tr><tr><td align="left">protected boolean tryRelease(int arg)</td><td align="left">独占式释放同步状态，等待获取同步状态的线程将有机会获取同步状态</td></tr><tr><td align="left">protected int tryAcquireShared(int arg)</td><td align="left">共享式获取同步状态，返回大于等于0的值，表示获取成功，反之，获取失败</td></tr><tr><td align="left">protected boolean tryReleaseShared(int arg)</td><td align="left">共享式释放同步状态</td></tr><tr><td align="left">protected boolean isHeldExclusively()</td><td align="left">当前同步器是否在独占模式下被线程占用，一般该方法表示是否被当前线程所独占</td></tr></tbody></table><h4 id="访问或修改同步状态的方法"><a href="#访问或修改同步状态的方法" class="headerlink" title="访问或修改同步状态的方法"></a>访问或修改同步状态的方法</h4><p>重写同步器指定的方法时，需要使用同步器提供的如下3个方法来访问或修改同步状态。</p><ul><li><p>getState()：获取当前同步状态。</p></li><li><p>setState(int newState)：设置当前同步状态。</p></li><li><p>compareAndSetState(int expect,int update)：使用CAS设置当前状态，该方法能够保证状态设置的原子性。 </p></li></ul><h3 id="AQS中的数据结构"><a href="#AQS中的数据结构" class="headerlink" title="AQS中的数据结构"></a>AQS中的数据结构</h3><img src="/blog/2020/07/30/JUC-AQS%E8%AF%A6%E8%A7%A3/pic8.png" srcset="/blog/img/loading.gif" class><h4 id="节点Node"><a href="#节点Node" class="headerlink" title="节点Node"></a>节点Node</h4><p>AQS其实是CLH队列锁的一种变体实现，所以必然要有一个节点的数据结构来保存我们前面所说的CLH中的各种域，比如前驱节点，节点的状态等，这个数据结构就是AQS中的内部类Node。Node中保存的信息有：</p><ul><li><p>前驱和后继线程</p></li><li><p>线程信息</p></li><li><p>队列中线程状态</p></li></ul><h4 id="Node类的设计"><a href="#Node类的设计" class="headerlink" title="Node类的设计"></a>Node类的设计</h4><img src="/blog/2020/07/30/JUC-AQS%E8%AF%A6%E8%A7%A3/pic7.png" srcset="/blog/img/loading.gif" class><p>线程的2种等待模式：</p><ul><li><p><strong>SHARED</strong>：表示线程以共享的模式等待锁（如ReadLock）</p></li><li><p><strong>EXCLUSIVE</strong>：表示线程以互斥的模式等待锁（如ReetrantLock）</p></li></ul><p>线程在队列中的状态枚举：</p><ul><li><p><strong>CANCELLED</strong>：值为1，表示线程已经取消获取锁的请求</p></li><li><p><strong>SIGNAL</strong>：值为-1，表示该线程已经准备就绪，等待获取锁</p></li><li><p><strong>CONDITION</strong>：值为-2，表示线程等待某一个条件（Condition）被满足</p></li><li><p><strong>PROPAGATE</strong>：值为-3，表示下一个的acquireShared值应该被无条件的传播下去，在线程处于SHARED模式时才会被用到。</p></li></ul><p>成员变量：</p><ul><li><p><strong>waitStatus</strong>：该int变量表示线程在队列中的状态，其值就是上述提到的状态：CANCELLED、SIGNAL、CONDITION、PROPAGATE</p></li><li><p><strong>prev</strong>：该变量类型为Node对象，表示该节点的前一个Node节点（前驱）</p></li><li><p><strong>next</strong>：该变量类型为Node对象，表示该节点的后一个Node节点（后继）</p></li><li><p><strong>thread</strong>：该变量类型为Thread对象，表示该节点的代表的线程</p></li><li><p><strong>nextWaiter</strong>：该变量类型为Node对象，表示等待condition条件的Node节点</p></li></ul><p>当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成为一个节点（Node）并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步状态。同步队列中的节点（Node）用来保存获取同步状态失败的线程引用、等待状态以及前驱和后继节点。</p><h4 id="head和tail"><a href="#head和tail" class="headerlink" title="head和tail"></a>head和tail</h4><p>AQS还拥有首节点（head）和尾节点（tail）两个引用，一个指向队列头节点，而另一个指向队列尾节点。</p><p>注意 ：因为首节点head是不保存线程信息的节点，仅仅是因为数据结构设计上的需要，在数据结构上，这种做法往往叫做“空头节点链表”，对应的就有“非空头结点链表”。</p><h4 id="节点在同步队列中的增加和移出"><a href="#节点在同步队列中的增加和移出" class="headerlink" title="节点在同步队列中的增加和移出"></a>节点在同步队列中的增加和移出</h4><h5 id="节点加入到同步队列"><a href="#节点加入到同步队列" class="headerlink" title="节点加入到同步队列"></a>节点加入到同步队列</h5><p>当一个线程成功地获取了同步状态（或者锁），其他线程将无法获取到同步状态，也就是获取同步状态失败，AQS会通过addWaiter()方法将这个线程以及等待状态等信息构造成为一个节点（Node）并将其加入同步队列的尾部。而这个加入队列的过程必须要保证线程安全，因此同步器提供了一个基于CAS的设置尾节点的方法：compareAndSetTail(Node expect,Nodeupdate)，AQS它需要传递当前线程“认为”的尾节点和当前节点，只有设置成功后，当前节点才正式与之前的尾节点建立关联。</p><img src="/blog/2020/07/30/JUC-AQS%E8%AF%A6%E8%A7%A3/pic9.png" srcset="/blog/img/loading.gif" class><h5 id="首节点的变化"><a href="#首节点的变化" class="headerlink" title="首节点的变化"></a>首节点的变化</h5><p>首节点是获取同步状态成功的节点，首节点的线程在释放同步状态时，将会唤醒后继节点，而后继节点将会在获取同步状态成功时将自己设置为首节点。设置首节点是通过获取同步状态成功的线程来完成的，由于只有一个线程能够成功获取到同步状态，因此设置头节点的方法并不需要使用CAS来保证，它只需要将首节点设置成为原首节点的后继节点并断开原首节点的next引用即可。</p><img src="/blog/2020/07/30/JUC-AQS%E8%AF%A6%E8%A7%A3/pic10.png" srcset="/blog/img/loading.gif" class><h5 id="独占式同步状态获取与释放"><a href="#独占式同步状态获取与释放" class="headerlink" title="独占式同步状态获取与释放"></a>独占式同步状态获取与释放</h5><img src="/blog/2020/07/30/JUC-AQS%E8%AF%A6%E8%A7%A3/pic11.png" srcset="/blog/img/loading.gif" class><h6 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h6><p>通过调用同步器的acquire(int arg)方法可以获取同步状态，主要完成了同步状态获取、节点构造、加入同步队列以及在同步队列中自旋等待的相关工作，其主要逻辑是：</p><p>首先调用自定义同步器实现的tryAcquire(int arg)方法，该方法需要保证线程安全的获取同步状态。</p><p>如果同步状态获取失败（tryAcquire返回false），则构造同步节点（独占式Node.EXCLUSIVE，同一时刻只能有一个线程成功获取同步状态）并通过addWaiter(Node node)方法将该节点加入到同步队列的尾部，在addWaiter()方法中会尝试通过compareAndSetTail()方法设置首尾节点关系，如果设置不成功才会进入enq()方法循环尝试设置节点关系。</p><p>最后调用acquireQueued(Node node,int arg)方法，使得该节点以“死循环”的方式获取同步状态。如果获取不到则阻塞节点中的线程，而被阻塞线程的唤醒主要依靠前驱节点的出队或阻塞线程被中断来实现。</p><p>addWaiter(Node node)方法中</p><img src="/blog/2020/07/30/JUC-AQS%E8%AF%A6%E8%A7%A3/pic12.png" srcset="/blog/img/loading.gif" class><p>将当前线程包装成Node后，队列不为空的情况下，先尝试把当前节点加入队列并成为尾节点，如果不成功或者队列为空进入enq(final Node node)方法。</p><img src="/blog/2020/07/30/JUC-AQS%E8%AF%A6%E8%A7%A3/pic13.png" srcset="/blog/img/loading.gif" class><p>在enq(final Node node)方法中，同步器通过“死循环”来保证节点的正确添加，这个死循环中，做了两件事，第一件，如果队列为空，初始化队列，new出一个空节点，并让<strong>首节点</strong>（head）和<strong>尾节点</strong>（tail）两个引用都指向这个空节点；第二件事，把当前节点加入队列。</p><p>在“死循环”中只有通过CAS将节点设置成为尾节点之后，当前线程才能从该方法返回，否则，当前线程不断地尝试设置。</p><p>节点进入同步队列之后，观察acquireQueued(Node node,int arg)方法</p><img src="/blog/2020/07/30/JUC-AQS%E8%AF%A6%E8%A7%A3/pic14.png" srcset="/blog/img/loading.gif" class><p>其实就是一个自旋的过程，每个节点（或者说每个线程）都在自省地观察，当条件满足，获取到了同步状态，就可以从这个自旋过程中退出，否则依旧留在这个自旋过程中（并会阻塞节点的线程）。</p><p>在acquireQueued(final Node node,int arg)方法中，当前线程在“死循环”中尝试获取同步状态，而只有前驱节点是头节点才能够尝试获取同步状态，这是为什么？原因有两个。</p><p>第一，头节点是成功获取到同步状态的节点，而头节点的线程释放了同步状态之后，将会唤醒其后继节点，后继节点的线程被唤醒后需要检查自己的前驱节点是否是头节点。</p><p>第二，维护同步队列的FIFO原则。</p><p>当前线程获取到同步状态后，让<strong>首节点</strong>（head）这个引用指向自己所在节点。当同步状态获取成功后，当前线程就从acquire方法返回了。如果同步器实现的是锁，那就代表当前线程获得了锁。</p><h6 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h6><p>当前线程获取同步状态并执行了相应逻辑之后，就需要释放同步状态，使得后续节点能够继续获取同步状态。通过调用同步器的release(int arg)方法可以释放同步状态，该方法在释放了同步状态之后，会唤醒其后继节点（进而使后继节点重新尝试获取同步状态）。</p><img src="/blog/2020/07/30/JUC-AQS%E8%AF%A6%E8%A7%A3/pic15.png" srcset="/blog/img/loading.gif" class><p>该方法执行时，会唤醒<strong>首节点</strong>（head）所指向节点的后继节点线程，unparkSuccessor(Node node)方法使用LockSupport来唤醒处于等待状态的线程。</p><p>而在unparkSuccessor中， </p><img src="/blog/2020/07/30/JUC-AQS%E8%AF%A6%E8%A7%A3/pic16.png" srcset="/blog/img/loading.gif" class><p>这段代码的意思，一般情况下，被唤醒的是head指向节点的后继节点线程，如果这个后继节点处于被cancel状态，（我推测开发者的思路这样的：后继节点处于被cancel状态，意味着当锁竞争激烈时，队列的第一个节点等了很久（一直被还未加入队列的节点抢走锁），包括后续的节点cancel的几率都比较大，所以）先从尾开始遍历，找到最前面且没有被cancel的节点。</p><h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><p>在获取同步状态时，同步器维护一个同步队列，获取状态失败的线程都会被加入到队列中并在队列中进行自旋；移出队列（或停止自旋）的条件是前驱节点为头节点且成功获取了同步状态。在释放同步状态时，同步器调用tryRelease(int arg)方法释放同步状态，然后唤醒head指向节点的后继节点。</p><h5 id="共享式同步状态获取与释放"><a href="#共享式同步状态获取与释放" class="headerlink" title="共享式同步状态获取与释放"></a>共享式同步状态获取与释放</h5><p>共享式获取与独占式获取最主要的区别在于同一时刻能否有多个线程同时获取到同步状态。以读写为例，如果一个程序在进行读操作，那么这一时刻写操作均被阻塞，而读操作能够同时进行。写操作要求对资源的独占式访问，而读操作可以是共享式访问。</p><p>在acquireShared(int arg)方法中，同步器调用tryAcquireShared(int arg)方法尝试获取同步状态，tryAcquireShared(int arg)方法返回值为int类型，当返回值大于等于0时，表示能够获取到同步状态。因此，在共享式获取的自旋过程中，成功获取到同步状态并退出自旋的条件就是tryAcquireShared(int arg)方法返回值大于等于0。可以看到，在doAcquireShared(int arg)方法的自旋过程中，如果当前节点的前驱为头节点时，尝试获取同步状态，如果返回值大于等于0，表示该次获取同步状态成功并从自旋过程中退出。</p><p>该方法在释放同步状态之后，将会唤醒后续处于等待状态的节点。对于能够支持多个线程同时访问的并发组件（比如Semaphore），它和独占式主要区别在于tryReleaseShared(int arg)方法必须确保同步状态（或者资源数）线程安全释放，一般是通过循环和CAS来保证的，因为释放同步状态的操作会同时来自多个线程。</p><h5 id="共享式的同步工具类"><a href="#共享式的同步工具类" class="headerlink" title="共享式的同步工具类"></a>共享式的同步工具类</h5><p>设计一个同步工具：该工具在同一时刻，只允许至多3个线程同时访问，超过3个线程的访问将被阻塞。</p><p>首先，确定访问模式。TrinityLock能够在同一时刻支持多个线程的访问，这显然是共享式访问，因此，需要使用同步器提供的acquireShared(int args)方法等和Shared相关的方法，这就要求TwinsLock必须重写tryAcquireShared(int args)方法和tryReleaseShared(int args)方法，这样才能保证同步器的共享式同步状态的获取与释放方法得以执行。</p><p>其次，定义资源数。TrinityLock在同一时刻允许至多三个线程的同时访问，表明同步资源数为3，这样可以设置初始状态status为3，当一个线程进行获取，status减1，该线程释放，则status加1，状态的合法范围为0、1和2,3，其中0表示当前已经有3个线程获取了同步资源，此时再有其他线程对同步状态进行获取，该线程只能被阻塞。在同步状态变更时，需要使用compareAndSet(int expect,int update)方法做原子性保障。</p><p>最后，组合自定义同步器。前面的章节提到，自定义同步组件通过组合自定义同步器来完成同步功能，一般情况下自定义同步器会被定义为自定义同步组件的内部类。</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> *类说明：共享同步工具类</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TrinityLock</span>  <span class="hljs-keyword">implements</span> <span class="hljs-title">Lock</span> </span>&#123;    <span class="hljs-comment">//为n表示允许n个线程同时获得锁</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Sync sync = <span class="hljs-keyword">new</span> Sync(<span class="hljs-number">4</span>);    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> </span>&#123;        <span class="hljs-comment">//private static final long serialVersionUID = -7889272986162341211L;</span>        Sync(<span class="hljs-keyword">int</span> count) &#123;            <span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"count must large than zero."</span>);            &#125;            setState(count);        &#125;        <span class="hljs-comment">/**</span><span class="hljs-comment">         *</span><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> reduceCount  扣减个数</span><span class="hljs-comment">         * <span class="hljs-doctag">@return</span>  返回小于0，表示当前线程获得同步状态失败</span><span class="hljs-comment">         * 大于0，表示当前线程获得同步状态成功</span><span class="hljs-comment">         */</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> reduceCount)</span> </span>&#123;            <span class="hljs-keyword">for</span> (;;) &#123;                <span class="hljs-keyword">int</span> current = getState();                <span class="hljs-keyword">int</span> newCount = current - reduceCount;                <span class="hljs-keyword">if</span> (newCount &lt; <span class="hljs-number">0</span> || compareAndSetState(current, newCount)) &#123;                    <span class="hljs-keyword">return</span> newCount;                &#125;            &#125;        &#125;        <span class="hljs-comment">/**</span><span class="hljs-comment">         *</span><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> returnCount 归还个数</span><span class="hljs-comment">         * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">         */</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> returnCount)</span> </span>&#123;            <span class="hljs-keyword">for</span> (;;) &#123;                <span class="hljs-keyword">int</span> current = getState();                <span class="hljs-keyword">int</span> newCount = current + returnCount;                <span class="hljs-keyword">if</span> (compareAndSetState(current, newCount)) &#123;                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;                &#125;            &#125;        &#125;        <span class="hljs-function"><span class="hljs-keyword">final</span> ConditionObject <span class="hljs-title">newCondition</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConditionObject();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;        sync.acquireShared(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;        sync.releaseShared(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        sync.acquireSharedInterruptibly(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> sync.tryAcquireShared(<span class="hljs-number">1</span>) &gt;= <span class="hljs-number">0</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">(<span class="hljs-keyword">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">return</span> sync.tryAcquireSharedNanos(<span class="hljs-number">1</span>, unit.toNanos(time));    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Condition <span class="hljs-title">newCondition</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> sync.newCondition();    &#125;&#125;</code></pre><h3 id="AQS的实现"><a href="#AQS的实现" class="headerlink" title="AQS的实现"></a>AQS的实现</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SelfLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Lock</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 静态内部类，自定义同步器</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> </span>&#123;        <span class="hljs-comment">//private static final long serialVersionUID = -4387327721959839431L;</span>        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 是否处于占用状态</span><span class="hljs-comment">         */</span>        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isHeldExclusively</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> getState() == <span class="hljs-number">1</span>;        &#125;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 获得锁</span><span class="hljs-comment">         */</span>        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;            <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;                setExclusiveOwnerThread(Thread.currentThread());                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 释放锁</span><span class="hljs-comment">         */</span>        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;            <span class="hljs-keyword">if</span> (getState() == <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();            &#125;            setExclusiveOwnerThread(<span class="hljs-keyword">null</span>);            setState(<span class="hljs-number">0</span>);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 返回一个Condition，每个condition都包含了一个condition队列</span><span class="hljs-comment">         */</span>        <span class="hljs-function">Condition <span class="hljs-title">newCondition</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConditionObject();        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 仅需要将操作代理到Sync上即可</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Sync sync = <span class="hljs-keyword">new</span> Sync();    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" ready get lock"</span>);        sync.acquire(<span class="hljs-number">1</span>);        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" already got lock"</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> sync.tryAcquire(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" ready release lock"</span>);        sync.release(<span class="hljs-number">1</span>);        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" already released lock"</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Condition <span class="hljs-title">newCondition</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> sync.newCondition();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isLocked</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> sync.isHeldExclusively();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasQueuedThreads</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> sync.hasQueuedThreads();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        sync.acquireInterruptibly(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">return</span> sync.tryAcquireNanos(<span class="hljs-number">1</span>, unit.toNanos(timeout));    &#125;&#125;</code></pre><p><strong>测试类</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestMyLock</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">final</span> Lock lock = <span class="hljs-keyword">new</span> SelfLock();        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;         <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                lock.lock();                System.out.println(Thread.currentThread().getName());                <span class="hljs-keyword">try</span> &#123;                    SleepTools.second(<span class="hljs-number">1</span>);                &#125; <span class="hljs-keyword">finally</span> &#123;                    lock.unlock();                &#125;            &#125;        &#125;        <span class="hljs-comment">// 启动4个子线程</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;            Worker w = <span class="hljs-keyword">new</span> Worker();            <span class="hljs-comment">//w.setDaemon(true);</span>            w.start();        &#125;        <span class="hljs-comment">// 主线程每隔1秒换行</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;           SleepTools.second(<span class="hljs-number">1</span>);            <span class="hljs-comment">//System.out.println();</span>        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        TestMyLock testMyLock = <span class="hljs-keyword">new</span> TestMyLock();        testMyLock.test();    &#125;&#125;</code></pre><h3 id="Condition分析"><a href="#Condition分析" class="headerlink" title="Condition分析"></a>Condition分析</h3><p>任意一个Java对象，都拥有一组监视器方法（定义在java.lang.Object上），主要包括wait()、wait(long timeout)、notify()以及notifyAll()方法，这些方法与synchronized同步关键字配合，可以实现等待/通知模式。Condition接口也提供了类似Object的监视器方法await()，signal()，以便与Lock配合可以实现等待/通知模式。</p><h4 id="用Lock和Condition实现等待通知"><a href="#用Lock和Condition实现等待通知" class="headerlink" title="用Lock和Condition实现等待通知"></a>用Lock和Condition实现等待通知</h4><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 类说明：</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExpressCond</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String CITY = <span class="hljs-string">"ShangHai"</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 快递运输里程数</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> km;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 快递到达地点</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> String site;    <span class="hljs-keyword">private</span> Lock kmLock = <span class="hljs-keyword">new</span> ReentrantLock();    <span class="hljs-keyword">private</span> Lock siteLock = <span class="hljs-keyword">new</span> ReentrantLock();    <span class="hljs-keyword">private</span> Condition kmCondition = kmLock.newCondition();    <span class="hljs-keyword">private</span> Condition siteCondition = siteLock.newCondition();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ExpressCond</span><span class="hljs-params">(<span class="hljs-keyword">int</span> km, String site)</span> </span>&#123;        <span class="hljs-keyword">this</span>.km = km;        <span class="hljs-keyword">this</span>.site = site;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 变化公里数，然后通知处于wait状态并需要处理公里数的线程进行业务处理</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">changeKm</span><span class="hljs-params">()</span> </span>&#123;        kmLock.lock();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">this</span>.km = <span class="hljs-number">101</span>;            kmCondition.signal();        &#125; <span class="hljs-keyword">finally</span> &#123;            kmLock.unlock();        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 变化地点，然后通知处于wait状态并需要处理地点的线程进行业务处理</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">changeSite</span><span class="hljs-params">()</span> </span>&#123;        siteLock.lock();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">this</span>.site = <span class="hljs-string">"BeiJing"</span>;            siteCondition.signal();        &#125; <span class="hljs-keyword">finally</span> &#123;            siteLock.unlock();        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 当快递的里程数大于100时更新数据库</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">waitKm</span><span class="hljs-params">()</span> </span>&#123;        kmLock.lock();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.km &lt; <span class="hljs-number">100</span>) &#123;                <span class="hljs-keyword">try</span> &#123;                    kmCondition.await();                    System.out.println(<span class="hljs-string">"check Site thread["</span> + Thread.currentThread().getId()                            + <span class="hljs-string">"] is be notified"</span>);                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125; <span class="hljs-keyword">finally</span> &#123;            kmLock.unlock();        &#125;        System.out.println(<span class="hljs-string">"the Km is "</span> + <span class="hljs-keyword">this</span>.km + <span class="hljs-string">",I will change db"</span>);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 当快递到达目的地时通知用户</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">waitSite</span><span class="hljs-params">()</span> </span>&#123;        siteLock.lock();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.site.equals(CITY)) &#123;                <span class="hljs-keyword">try</span> &#123;                    siteCondition.await();<span class="hljs-comment">//当前线程进行等待</span>                    System.out.println(<span class="hljs-string">"check Site thread["</span> + Thread.currentThread().getName()                            + <span class="hljs-string">"] is be notify"</span>);                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125; <span class="hljs-keyword">finally</span> &#123;            siteLock.unlock();        &#125;        System.out.println(<span class="hljs-string">"the site is "</span> + <span class="hljs-keyword">this</span>.site + <span class="hljs-string">",I will call user"</span>);    &#125;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ExpressCond express = <span class="hljs-keyword">new</span> ExpressCond(<span class="hljs-number">0</span>, ExpressCond.CITY);    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 检查里程数变化的线程,不满足条件，线程一直等待</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CheckKm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            express.waitKm();        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 检查地点变化的线程,不满足条件，线程一直等待</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CheckSite</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            express.waitSite();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;            <span class="hljs-keyword">new</span> ExpressCond.CheckSite().start();        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;            <span class="hljs-keyword">new</span> ExpressCond.CheckKm().start();        &#125;        Thread.sleep(<span class="hljs-number">1000</span>);        express.changeKm();<span class="hljs-comment">//快递里程变化</span>    &#125;&#125;</code></pre><h4 id="Condition的数据结构"><a href="#Condition的数据结构" class="headerlink" title="Condition的数据结构"></a>Condition的数据结构</h4><p>等待队列是一个FIFO的队列，在队列中的每个节点都包含了一个线程引用，该线程就是在Condition对象上等待的线程，如果一个线程调用了Condition.await()方法，那么该线程将会释放锁、构造成节点加入等待队列并进入等待状态。事实上，节点的定义复用了同步器中节点的定义，也就是说，同步队列和等待队列中节点类型都是同步器的静态内部类。</p><img src="/blog/2020/07/30/JUC-AQS%E8%AF%A6%E8%A7%A3/pic17.png" srcset="/blog/img/loading.gif" class><p>一个Condition包含一个等待队列，Condition拥有首节点（firstWaiter）和尾节点（lastWaiter）。当前线程调用Condition.await()方法，将会以当前线程构造节点，并将节点从尾部加入等待队列。Condition拥有首尾节点的引用，而新增节点只需要将原有的尾节点nextWaiter指向它，并且更新尾节点即可。上述节点引用更新的过程并没有使用CAS保证，原因在于调用await()方法的线程必定是获取了锁的线程，也就是说该过程是由锁来保证线程安全的。</p><p>Lock（更确切地说是同步器）拥有一个同步队列和多个等待队列。</p><img src="/blog/2020/07/30/JUC-AQS%E8%AF%A6%E8%A7%A3/pic18.png" srcset="/blog/img/loading.gif" class><p>调用Condition的await()方法（或者以await开头的方法），会使当前线程进入等待队列并释放锁，同时线程状态变为等待状态。当从await()方法返回时，当前线程一定获取了Condition相关联的锁。</p><p>如果从队列（同步队列和等待队列）的角度看await()方法，当调用await()方法时，相当于同步队列的首节点（获取了锁的节点）移动到Condition的等待队列中。调用该方法的线程成功获取了锁的线程，也就是同步队列中的首节点，该方法会将当前线程构造成节点并加入等待队列中，然后释放同步状态，唤醒同步队列中的后继节点，然后当前线程会进入等待状态。当等待队列中的节点被唤醒，则唤醒节点的线程开始尝试获取同步状态。如果不是通过其他线程调用Condition.signal()方法唤醒，而是对等待线程进行中断，则会抛出InterruptedException。</p><img src="/blog/2020/07/30/JUC-AQS%E8%AF%A6%E8%A7%A3/pic19.png" srcset="/blog/img/loading.gif" class><p>如图所示，同步队列的首节点并不会直接加入等待队列，而是通过addConditionWaiter()方法把当前线程构造成一个新的节点并将其加入等待队列中。</p><img src="/blog/2020/07/30/JUC-AQS%E8%AF%A6%E8%A7%A3/pic20.png" srcset="/blog/img/loading.gif" class><p>调用Condition的signal()方法，将会唤醒在等待队列中等待时间最长的节点（首节点），在唤醒节点之前，会将节点移到同步队列中。</p><p>调用该方法的前置条件是当前线程必须获取了锁，可以看到signal()方法进行了isHeldExclusively()检查，也就是当前线程必须是获取了锁的线程。接着获取等待队列的首节点，将其移动到同步队列并使用LockSupport唤醒节点中的线程。</p><p>通过调用同步器的enq(Node node)方法，等待队列中的头节点线程安全地移动到同步队列。当节点移动到同步队列后，当前线程再使用LockSupport唤醒该节点的线程。</p><p>被唤醒后的线程，将从await()方法中的while循环中退出（isOnSyncQueue(Node node)方法返回true，节点已经在同步队列中），进而调用同步器的acquireQueued()方法加入到获取同步状态的竞争中。</p><p>成功获取同步状态（或者说锁）之后，被唤醒的线程将从先前调用的await()方法返回，此时该线程已经成功地获取了锁。</p><p>Condition的signalAll()方法，相当于对等待队列中的每个节点均执行一次signal()方法，效果就是将等待队列中所有节点全部移动到同步队列中，并唤醒每个节点的线程。</p><h3 id="JDK中基于AQS的Lock"><a href="#JDK中基于AQS的Lock" class="headerlink" title="JDK中基于AQS的Lock"></a>JDK中基于AQS的Lock</h3><h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><h5 id="锁的可重入"><a href="#锁的可重入" class="headerlink" title="锁的可重入"></a>锁的可重入</h5><p>重进入是指任意线程在获取到锁之后能够再次获取该锁而不会被锁所阻塞，该特性的实现需要解决以下两个问题。</p><ol><li><p>线程再次获取锁。锁需要去识别获取锁的线程是否为当前占据锁的线程，如果是，则再次成功获取。</p></li><li><p>锁的最终释放。线程重复n次获取了锁，随后在第n次释放该锁后，其他线程能够获取到该锁。锁的最终释放要求锁对于获取进行计数自增，计数表示当前锁被重复获取的次数，而锁被释放时，计数自减，当计数等于0时表示锁已经成功释放。</p></li></ol><p>nonfairTryAcquire方法增加了再次获取同步状态的处理逻辑：通过判断当前线程是否为获取锁的线程来决定获取操作是否成功，如果是获取锁的线程再次请求，则将同步状态值进行增加并返回true，表示获取同步状态成功。同步状态表示锁被一个线程重复获取的次数。</p><p>如果该锁被获取了n次，那么前(n-1)次tryRelease(int releases)方法必须返回false，而只有同步状态完全释放了，才能返回true。可以看到，该方法将同步状态是否为0作为最终释放的条件，当同步状态为0时，将占有线程设置为null，并返回true，表示释放成功。</p><h5 id="公平和非公平锁"><a href="#公平和非公平锁" class="headerlink" title="公平和非公平锁"></a>公平和非公平锁</h5><p>先对锁进行获取的线程即等待时间最长的线程一定先获取到锁，那么这个锁是公平的，也可以说锁获取是顺序的，反之就是不公平的。 ReentrantLock提供了一个构造函数，能够控制锁是否是公平的，synchronized是非公平锁。事实上，公平的锁机制往往没有非公平的效率高。  </p><p>线程被唤醒的上下文切换时间周期在5000-10000之间，在激烈竞争的情况下，非公平锁的性能高于公平锁的性能的一个原因是：在恢复一个被挂起的线程与该线程真正开始运行之间存在着严重的延迟。假设线程A持有一个锁，并且线程B请求这个锁。由于这个锁已被线程A持有，因此B将被挂起。当A释放锁时，B将被唤醒，B完全唤醒后会再次尝试获取锁。与此同时，如果C也请求这个锁，那么C很可能会在B被完全唤醒之前获得、使用以及释放这个锁。这样的情况是一种“双赢”的局面：B获得锁的时刻并没有推迟，C更早地获得了锁，并且吞吐量也获得了提高。</p><p>ReentrantLock的构造函数中，默认的无参构造函数将会把Sync对象创建为NonfairSync对象，这是一个非公平锁；而另一个构造函数ReentrantLock(boolean fair)传入参数为true时将会把Sync对象创建为公平锁FairSync。</p><p>公平锁的tryAcquire()方法与非公平锁的nonfairTryAcquire(int acquires)相比，唯一不同的位置为判断条件多了hasQueuedPredecessors()方法，即加入了同步队列中当前节点是否有前驱节点的判断，如果该方法返回true，则表示有线程比当前线程更早地请求获取锁，因此需要等待前驱线程获取并释放锁之后才能继续获取锁，而非公平锁只要CAS设置同步状态成功，则表示当前线程获取了锁。</p><h5 id="改造之前的独占锁为可重入"><a href="#改造之前的独占锁为可重入" class="headerlink" title="改造之前的独占锁为可重入"></a>改造之前的独占锁为可重入</h5><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> *类说明：实现我们自己独占锁,可重入</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReenterSelfLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Lock</span> </span>&#123;    <span class="hljs-comment">// 静态内部类，自定义同步器</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> </span>&#123;        <span class="hljs-comment">// 是否处于占用状态</span>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isHeldExclusively</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> getState() &gt; <span class="hljs-number">0</span>;        &#125;        <span class="hljs-comment">// 当状态为0的时候获取锁</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;            <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;                setExclusiveOwnerThread(Thread.currentThread());                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(getExclusiveOwnerThread()==Thread.currentThread())&#123;                setState(getState()+<span class="hljs-number">1</span>);                <span class="hljs-keyword">return</span>  <span class="hljs-keyword">true</span>;            &#125;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-comment">// 释放锁，将状态设置为0</span>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> releases)</span> </span>&#123;            <span class="hljs-keyword">if</span>(getExclusiveOwnerThread()!=Thread.currentThread())&#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();            &#125;            <span class="hljs-keyword">if</span> (getState() == <span class="hljs-number">0</span>)                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();            setState(getState()-<span class="hljs-number">1</span>);            <span class="hljs-keyword">if</span>(getState()==<span class="hljs-number">0</span>)&#123;                setExclusiveOwnerThread(<span class="hljs-keyword">null</span>);            &#125;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-comment">// 返回一个Condition，每个condition都包含了一个condition队列</span>        <span class="hljs-function">Condition <span class="hljs-title">newCondition</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConditionObject();        &#125;    &#125;    <span class="hljs-comment">// 仅需要将操作代理到Sync上即可</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Sync sync = <span class="hljs-keyword">new</span> Sync();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;       System.out.println(Thread.currentThread().getName()+<span class="hljs-string">" ready get lock"</span>);        sync.acquire(<span class="hljs-number">1</span>);        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">" already got lock"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> sync.tryAcquire(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;       System.out.println(Thread.currentThread().getName()+<span class="hljs-string">" ready release lock"</span>);        sync.release(<span class="hljs-number">1</span>);        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">" already released lock"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Condition <span class="hljs-title">newCondition</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> sync.newCondition();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isLocked</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> sync.isHeldExclusively();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasQueuedThreads</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> sync.hasQueuedThreads();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        sync.acquireInterruptibly(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">return</span> sync.tryAcquireNanos(<span class="hljs-number">1</span>, unit.toNanos(timeout));    &#125;&#125;</code></pre><p>测试类</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> *类说明：</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestReenterSelfLock</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Lock lock = <span class="hljs-keyword">new</span> ReenterSelfLock();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reenter</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;        lock.lock();        <span class="hljs-keyword">try</span> &#123;            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">":递归层级:"</span>+x);            <span class="hljs-keyword">int</span> y = x - <span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span> (y==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;            <span class="hljs-keyword">else</span>&#123;                reenter(y);            &#125;        &#125; <span class="hljs-keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                System.out.println(Thread.currentThread().getName());                SleepTools.second(<span class="hljs-number">1</span>);                reenter(<span class="hljs-number">3</span>);            &#125;        &#125;        <span class="hljs-comment">// 启动3个子线程</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;            Worker w = <span class="hljs-keyword">new</span> Worker();            w.start();        &#125;        <span class="hljs-comment">// 主线程每隔1秒换行</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;        SleepTools.second(<span class="hljs-number">1</span>);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        TestReenterSelfLock testMyLock = <span class="hljs-keyword">new</span> TestReenterSelfLock();        testMyLock.test();    &#125;&#125;</code></pre><h4 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h4><p>之前提到锁（如synchronized和ReentrantLock）基本都是排他锁即独占锁，这些锁在同一时刻只允许一个线程进行访问，而读写锁在同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其他写线程均被阻塞。读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大提升。写锁为独占锁，读锁为共享锁，读写之前相互排斥。</p><p>除了保证写操作对读操作的可见性以及提升并发性之外，读写锁能够简化读写交互场景的编程方式。假设在程序中定义一个共享的用作缓存数据结构，它大部分时间提供读服务（例如查询和搜索），而写操作占有的时间很少，但是写操作完成之后的更新需要对后续的读服务可见。在没有读写锁支持的（Java 5之前）时候，如果需要完成上述工作就要使用Java的等待通知机制，就是当写操作开始时，所有晚于写操作的读操作均会进入等待状态，只有写操作完成并进行通知之后，所有等待的读操作才能继续执行（写操作之间依靠synchronized关键进行同步），这样做的目的是使读操作能读取到正确的数据，不会出现脏读。改用读写锁实现上述功能，只需要在读操作时获取读锁，写操作时获取写锁即可。当写锁被获取到时，后续（非当前写操作线程）的读写操作都会被阻塞，写锁释放之后，所有操作继续执行，编程方式相对于使用等待通知机制的实现方式而言，变得简单明了。 </p><p>ReentrantReadWriteLock实现了ReadAndWriteLock接口，ReadAndWriteLock接口提供了readLock()方法获取读锁，writeLock()方法获取写锁，读锁和写锁的使用方式与Lock标准用法相同。</p><p>一般情况下，读写锁的性能都会比排它锁好，因为大多数场景读是多于写的，读写的比例约为10:1。在读多于写的情况下，读写锁能够提供比排它锁更好的并发性和吞吐量。</p><h5 id="读写状态的设计"><a href="#读写状态的设计" class="headerlink" title="读写状态的设计"></a>读写状态的设计</h5><p>读写锁同样依赖自定义同步器来实现同步功能，而读写状态就是其同步器的同步状态。</p><p>回想ReentrantLock中自定义同步器的实现，同步状态表示锁被一个线程重复获取的次数，而读写锁的自定义同步器需要在同步状态（一个整型变量）上维护多个读线程和一个写线程的状态，使得该状态的设计成为读写锁实现的关键。</p><p>如果在一个整型变量上维护多种状态，就一定需要按位切割使用这个变量，读写锁将变量切分成了两个部分，高16位表示读，低16位表示写，读写锁通过位运算来维护各自的运算。假设当前同步状态值为S，写状态等于S&amp;0x0000FFFF（将高16位全部抹去），读状态等于S&gt;&gt;&gt;16（无符号补0右移16位）。当写状态增加1时，等于S+1，当读状态增加1时，等于S+(1&lt;&lt;16)，也就是S+0x00010000。根据状态的划分能得出一个推论：S不等于0时，当写状态（S&amp;0x0000FFFF）等于0时，则读状态（S&gt;&gt;&gt;16）大于0，即读锁已被获取。</p><h5 id="写锁的获取与释放"><a href="#写锁的获取与释放" class="headerlink" title="写锁的获取与释放"></a>写锁的获取与释放</h5><p>写锁是一个支持重进入的排它锁。如果当前线程已经获取了写锁，则增加写状态。读写锁在内部有一个ThreadLocal记录写状态。如果当前线程在获取写锁时，读锁已经被获取（读状态不为0）或者该线程不是已经获取写锁的线程，则当前线程进入等待状态。</p><p>该方法除了重入条件（当前线程为获取了写锁的线程）之外，增加了一个读锁是否存在的判断。如果存在读锁，则写锁不能被获取，原因在于：读写锁要确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。因此，只有等待其他读线程都释放了读锁，写锁才能被当前线程获取，而写锁一旦被获取，则其他读写线程的后续访问均被阻塞。</p><p>写锁的释放与ReentrantLock的释放过程基本类似，每次释放均减少写状态，当写状态为0时表示写锁已被释放，从而等待的读写线程能够继续访问读写锁，同时前次写线程的修改对后续读写线程可见。</p><h5 id="读锁的获取与释放"><a href="#读锁的获取与释放" class="headerlink" title="读锁的获取与释放"></a>读锁的获取与释放</h5><p>读锁是一个支持重进入的共享锁，它能够被多个线程同时获取，在没有其他写线程访问（或者写状态为0）时，读锁总会被成功地获取，而所做的也只是（线程安全的）增加读状态。如果当前线程已经获取了读锁，则增加读状态。</p><p>如果当前线程在获取读锁时，写锁已被其他线程获取，则进入等待状态。读状态是所有线程获取读锁次数的总和，而每个线程各自获取读锁的次数只能选择保存在ThreadLocal中，由线程自身维护。在tryAcquireShared(int unused)方法中，如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，依靠CAS保证）增加读状态，成功获取读锁。读锁的每次释放（线程安全的，可能有多个读线程同时释放读锁）均减少读状态。</p><h5 id="锁的升降级"><a href="#锁的升降级" class="headerlink" title="锁的升降级"></a>锁的升降级</h5><p>锁降级指的是写锁降级成为读锁。如果当前线程拥有写锁，然后将其释放，最后再获取读锁，这种分段完成的过程不能称之为锁降级。</p><p>锁降级是指把持住（当前拥有的）写锁，再获取到读锁，随后释放（先前拥有的）写锁的过程。</p><p>RentrantReadWriteLock不支持锁升级（把持读锁、获取写锁，最后释放读锁的过程）。目的是保证数据可见性，如果读锁已被多个线程获取，其中任意线程成功获取了写锁并更新了数据，则其更新对其他获取到读锁的线程是不可见的。</p><h3 id="LockSupport工具"><a href="#LockSupport工具" class="headerlink" title="LockSupport工具"></a>LockSupport工具</h3><p>LockSupport定义了一组的公共静态方法，这些方法提供了最基本的线程阻塞和唤醒功能，而LockSupport也成为构建同步组件的基础工具。</p><p>LockSupport定义了一组以park开头的方法用来阻塞当前线程，以及unpark(Thread thread)方法来唤醒一个被阻塞的线程。在JDK1.6之后LockSupport增加了park(Object blocker)、parkNanos(Object blocker,long nanos)和parkUntil(Object blocker,long deadline)3个方法，便于问题排查和系统监控，其中参数blocker是用来标识当前线程在等待的对象即被阻塞对象。</p><h3 id="CLH队列锁"><a href="#CLH队列锁" class="headerlink" title="CLH队列锁"></a>CLH队列锁</h3><p>CLH队列锁即Craig, Landin, and Hagersten (CLH) locks。</p><p>CLH队列锁是一种基于链表的可扩展、高性能、公平的自旋锁，申请线程仅仅在本地变量上自旋，它不断自旋判断前驱节点的状态，假设发现前驱节点释放了锁就结束自旋。</p><p>当一个线程需要获取锁时会创建一个的QNode，将其中的locked设置为true表示需要获取锁，myPred表示对其前驱节点的引用</p><img src="/blog/2020/07/30/JUC-AQS%E8%AF%A6%E8%A7%A3/pic1.png" srcset="/blog/img/loading.gif" class><p>线程A对tail域调用getAndSet方法，使自己成为队列的尾部，同时获取一个指向其前驱结点的引用myPred</p><img src="/blog/2020/07/30/JUC-AQS%E8%AF%A6%E8%A7%A3/pic2.png" srcset="/blog/img/loading.gif" class><p>线程B需要获得锁，同样的流程再来一遍</p><img src="/blog/2020/07/30/JUC-AQS%E8%AF%A6%E8%A7%A3/pic3.png" srcset="/blog/img/loading.gif" class><p>线程就在前驱结点的locked字段上自旋，直到前驱结点释放锁(前驱节点的锁值 locked == false)</p><p>当一个线程需要释放锁时，将当前结点的locked域设置为false，同时回收前驱结点</p><img src="/blog/2020/07/30/JUC-AQS%E8%AF%A6%E8%A7%A3/pic4.png" srcset="/blog/img/loading.gif" class><p>如上图所示，前驱结点释放锁，线程A的myPred所指向的前驱结点的locked字段变为false，线程A就可以获取到锁。</p><p>CLH队列锁的优点是空间复杂度低（如果有n个线程，L个锁，每个线程每次只获取一个锁，那么需要的存储空间是O（L+n），n个线程有n个myNode，L个锁有L个tail）。CLH队列锁常用在SMP体系结构下。</p><p>Java中的AQS是CLH队列锁的一种变体实现。</p><p><strong>扩展知识点</strong></p><p>SMP（Symmetric Multi-Processor）对称多处理器结构，指server中多个CPU对称工作，每一个CPU访问内存地址所需时间同样。其主要特征是共享，包括对CPU，内存，I/O等进行共享。SMP的长处是可以保证内存一致性。缺点是这些共享的资源非常可能成为性能瓶颈。随着CPU数量的添加，每一个CPU都要访问同样的内存资源，可能导致内存访问冲突，可能会导致CPU资源的浪费。经常使用的PC机就属于这样的。</p><img src="/blog/2020/07/30/JUC-AQS%E8%AF%A6%E8%A7%A3/pic5.png" srcset="/blog/img/loading.gif" class><p>NUMA（Non Uniform Memory Access Architecture）非一致存储访问，将CPU分为CPU模块，每个CPU模块由多个<em>CPU*组成，并且具有独立的本地内存、I/O槽口等，模块之间可以通过互联模块相互访问，访问本地内存（本CPU模块的内存）的速度将远远高于访问远地内存</em>(<em>其他CPU模块的内存</em>)*的速度，这也是非一致存储访问的由来。NUMA较好地解决SMP的扩展问题，当CPU数量增加时，因为访问远地内存的延时远远超过本地内存，系统性能无法线性增加。</p><img src="/blog/2020/07/30/JUC-AQS%E8%AF%A6%E8%A7%A3/pic6.png" srcset="/blog/img/loading.gif" class><p>CLH唯一的缺点是在NUMA系统结构下性能很差，但是在SMP系统结构下该法还是非常有效的。解决NUMA系统结构的思路是MCS队列锁。</p>]]></content>
    
    
    <categories>
      
      <category>并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AQS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发容器</title>
    <link href="/blog/2020/07/28/JUC-%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/"/>
    <url>/blog/2020/07/28/JUC-%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>java中的集合类非常丰富（ArrayList，HashMap之类），在单线程下用的顺风顺水，但这些集合类都是非线程安全的，即在多线程的环境下，都需要其他额外的手段来保证数据的正确性。常见手段有两种：</p><ul><li><p>自己通过synchronized关键字将所有使用到非线程安全的容器代码全部同步执行</p></li><li><p>使用Vector、Stack、HashTable、Collections.synchronized等同步容器法，在早期的jdk中用的比较多，实现方式和上面几乎一样，而且多步操作时如果外面不额外加一层synchronized，依然锁不住。实际效果还不如上面</p></li></ul><p>于是，并发容器诞生……</p><h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><p>HashTable容器使用synchronized来保证线程安全，这会导致在线程竞争激烈的情况下HashTable的效率非常低下。当一个线程访问HashTable的同步方法，其他线程也访问HashTable的同步方法时，会进入阻塞或轮询状态。如线程1使用put进行元素添加，线程2不但不能使用put方法添加元素，也不能使用get方法来获取元素，所以竞争越激烈效率越低。</p><h3 id="ConcurrentSkipListMap和ConcurrentSkipListSet"><a href="#ConcurrentSkipListMap和ConcurrentSkipListSet" class="headerlink" title="ConcurrentSkipListMap和ConcurrentSkipListSet"></a>ConcurrentSkipListMap和ConcurrentSkipListSet</h3><p>TreeMap和TreeSet使用红黑树按照key的顺序（自然顺序、自定义顺序）来使得键值对有序存储，但是只能在单线程下安全使用；多线程下想要使键值对按照key的顺序来存储，则需要使用ConcurrentSkipListMap和ConcurrentSkipListSet，分别用以代替TreeMap和TreeSet，存入的数据按key排序。在实现上，ConcurrentSkipListSet 本质上就是ConcurrentSkipListMap，ConcurrentSkipListMap实际上就是一个跳表的实现。</p><p>ConcurrentSkipListMap和ConcurrentHashMap都是线程安全的Map实现，ConcurrentHashMap的性能和存储空间要优于ConcurrentSkipListMap，但是ConcurrentSkipListMap有一个功能： 它会按照键的顺序进行排序。</p><h4 id="二分查找和AVL树查找"><a href="#二分查找和AVL树查找" class="headerlink" title="二分查找和AVL树查找"></a>二分查找和AVL树查找</h4><p>二分查找要求元素可以随机访问，所以决定了需要把元素存储在连续内存。这样查找确实很快，但是插入和删除元素的时候，为了保证元素的有序性，就需要大量的移动元素了。</p><p>如果需要的是一个能够进行二分查找，又能快速添加和删除元素的数据结构，首先就是二叉查找树，二叉查找树在最坏情况下可能变成一个链表。</p><p>于是，就出现了平衡二叉树，根据平衡算法的不同有AVL树，B-Tree，B+Tree，红黑树等，但是AVL树实现起来比较复杂，平衡操作较难理解，这时候就可以用SkipList跳跃表结构。</p><h4 id="跳表（SkipList）"><a href="#跳表（SkipList）" class="headerlink" title="跳表（SkipList）"></a>跳表（SkipList）</h4><p>传统意义的单链表是一个线性结构，向有序的链表中插入一个节点需要O(n)的时间，查找操作需要O(n)的时间。</p><img src="/blog/2020/07/28/JUC-%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/pic1.png" srcset="/blog/img/loading.gif" class><p>如果我们使用上图所示的跳跃表，就可以减少查找所需时间为O(n/2)，因为我们可以先通过每个节点的最上面的指针先进行查找，这样子就能跳过一半的节点。</p><p>比如我们想查找50，首先和20比较，大于20之后，在和40进行比较，然后在和70进行比较，发现70大于50，说明查找的点在40和50之间，从这个过程中，我们可以看出，查找的时候跳过了30。</p><p>跳跃表其实也是一种通过“空间来换取时间”的一个算法，令链表的每个结点不仅记录next结点位置，还可以按照level层级分别记录后继第level个结点。此法使用的就是“<strong>先大步查找确定范围，再逐渐缩小迫近</strong>”的思想进行的查找。跳跃表在算法效率上很接近红黑树。</p><p>跳跃表又被称为概率，或者说是随机化的数据结构，目前开源软件 Redis 和 lucence都有用到它。</p><h3 id="CopyOnWriteArrayList和CopyOnWriteArraySet"><a href="#CopyOnWriteArrayList和CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArrayList和CopyOnWriteArraySet"></a>CopyOnWriteArrayList和CopyOnWriteArraySet</h3><h4 id="写时复制容器概念"><a href="#写时复制容器概念" class="headerlink" title="写时复制容器概念"></a>写时复制容器概念</h4><p>CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。</p><p>这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。如果读的时候有多个线程正在向CopyOnWriteArrayList添加数据，读还是会读到旧的数据，因为写的时候不会锁住旧的CopyOnWriteArrayList。</p><p>CopyOnWrite容器用于对于绝大部分访问都是读，且只是偶尔写的并发场景。比如白名单，黑名单，商品类目的访问和更新场景，假如我们有一个搜索网站，用户在这个网站的搜索框中，输入关键字搜索内容，但是某些关键字不允许被搜索。这些不能被搜索的关键字会被放在一个黑名单当中，黑名单每天晚上更新一次。当用户搜索时，会检查当前关键字在不在黑名单当中，如果在，则提示不能搜索。</p><h4 id="使用CopyOnWriteMap需要注意两件事情："><a href="#使用CopyOnWriteMap需要注意两件事情：" class="headerlink" title="使用CopyOnWriteMap需要注意两件事情："></a>使用CopyOnWriteMap需要注意两件事情：</h4><ol><li><p>减少扩容开销。根据实际需要，初始化CopyOnWriteMap的大小，避免写时CopyOnWriteMap扩容的开销。</p></li><li><p>使用批量添加。因为每次添加，容器每次都会进行复制，所以减少添加次数，可以减少容器的复制次数。</p></li></ol><h4 id="写时复制容器的问题："><a href="#写时复制容器的问题：" class="headerlink" title="写时复制容器的问题："></a>写时复制容器的问题：</h4><ol><li><p>性能问题：每次修改都创建一个新数组，然后复制所有内容，如果数组比较大，修改操作又比较频繁，可以想象，性能是很低的，而且内存开销会很大。</p></li><li><p>数据一致性问题：CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，不要使用CopyOnWrite容器。</p></li></ol><h3 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h3><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><img src="/blog/2020/07/28/JUC-%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/pic2.png" srcset="/blog/img/loading.gif" class><p>队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。</p><p>在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为先进先出（FIFO—first in first out）线性表。</p><h4 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h4><table><thead><tr><th>方法/处理方式</th><th>抛出异常</th><th>返回特殊值</th><th>一直阻塞</th><th>超时退出</th></tr></thead><tbody><tr><td><strong>插入方法</strong></td><td>add(e)</td><td>offer(e)</td><td>put(e)</td><td>offer(e,time,unit)</td></tr><tr><td><strong>移除方法</strong></td><td>remove()</td><td>poll()</td><td>take()</td><td>poll(time, unit)</td></tr><tr><td><strong>检查方法</strong></td><td>element()</td><td>peek()</td><td>不可用</td><td>不可用</td></tr></tbody></table><ul><li><p>支持阻塞的插入方法：当队列满时，队列会阻塞插入元素的线程直到队列不满。</p></li><li><p>支持阻塞的移除方法：在队列为空时，获取元素的线程会被阻塞直到队列变为非空。</p></li><li><p>抛出异常：当队列满时，如果再往队列里插入元素，会抛出IllegalStateException（”Queuefull”）异常。当队列空时，从队列里获取元素会抛出NoSuchElementException异常。</p></li><li><p>返回特殊值：当往队列插入元素时，会返回元素是否插入成功，成功返回true。如果是移除方法，则是从队列里取出一个元素，如果没有则返回null。</p></li><li><p>一直阻塞：当阻塞队列满时，如果线程往队列里put元素，队列会一直阻塞线程，直到队列可用或者响应中断退出。当队列空时，如果线程从队列里take元素，队列会阻塞住消费者线程，直到队列不为空。</p></li><li><p>超时退出：当阻塞队列满时，如果线程往队列里插入元素，队列会阻塞生产者线程一段时间，如果超过了指定的时间，线程就会退出。</p></li></ul><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>在并发编程中使用生产者和消费者模式能够解决绝大多数并发问题。该模式通过平衡生产线程和消费线程的工作能力来提高程序整体处理数据的速度。</p><p>在线程世界里，生产者就是生产数据的线程，消费者就是消费数据的线程。在多线程开发中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据。同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。</p><p>为了解决这种生产消费能力不均衡的问题，便有了生产者和消费者模式。生产者和消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通信，而是通过阻塞队列来进行通信，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。</p><p>阻塞队列常用于生产者和消费者的场景，生产者是向队列里添加元素的线程，消费者是从队列里取元素的线程。阻塞队列就是生产者用来存放元素、消费者用来获取元素的容器。</p><h4 id="有界无界"><a href="#有界无界" class="headerlink" title="有界无界"></a>有界无界</h4><p>有限队列就是长度有限，满了以后生产者会阻塞，无界队列就是里面能放无数的东西而不会因为队列长度限制被阻塞，当然空间限制来源于系统资源的限制，如果处理不及时，导致队列越来越大越来越大，超出一定的限制致使内存超限，操作系统或者JVM帮你解决烦恼，直接把你 OOM kill 省事了。</p><h4 id="阻塞队列的实现原理"><a href="#阻塞队列的实现原理" class="headerlink" title="阻塞队列的实现原理"></a>阻塞队列的实现原理</h4><p>使用了等待通知模式实现。所谓通知模式，就是当生产者往满的队列里添加元素时会阻塞住生产者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用。通过查看JDK源码发现ArrayBlockingQueue使用了Condition来实现。其余队列的实现，大家可以自行查看，队列的实现的代码总体来说，并不复杂。</p><h4 id="常用阻塞队列"><a href="#常用阻塞队列" class="headerlink" title="常用阻塞队列"></a>常用阻塞队列</h4><ul><li><p>ArrayBlockingQueue：是一个用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序。默认情况下不保证线程公平的访问队列，所谓公平访问队列是指阻塞的线程，可以按照阻塞的先后顺序访问队列，即先阻塞线程先访问队列。非公平性是对先等待的线程是非公平的，当队列可用时，阻塞的线程都可以争夺访问队列的资格，有可能先阻塞的线程最后才访问队列。初始化时有参数可以设置</p></li><li><p>LinkedBlockingQueue：是一个用链表实现的有界阻塞队列。此队列的默认和最大长度为Integer.MAX_VALUE，按照先进先出的原则对元素进行排序。和ArrayBlockingQueue实现的区别：</p><ol><li><p>队列中锁的实现不同ArrayBlockingQueue实现的队列中的锁是没有分离的，即生产和消费用的是同一个锁；LinkedBlockingQueue实现的队列中的锁是分离的，即生产用的是putLock，消费是takeLock。</p></li><li><p>在生产或消费时操作不同：ArrayBlockingQueue实现的队列中在生产和消费的时候，是直接将枚举对象插入或移除的；LinkedBlockingQueue实现的队列中在生产和消费的时候，需要把枚举对象转换为Node<E>进行插入或移除，会影响性能。</E></p></li><li><p>队列大小初始化方式不同：ArrayBlockingQueue实现的队列中必须指定队列的大小LinkedBlockingQueue实现的队列中可以不指定队列的大小，但是默认是Integer.MAX_VALUE（20来个亿）一般的服务器是扛不住的，所以在使用LinkedBlockingQueue时还是尽量指定大小。</p></li></ol></li><li><p>PriorityBlockingQueue：是一个支持优先级的无界阻塞队列。默认情况下元素采取自然顺序升序排列。也可以自定义类实现compareTo()方法来指定元素排序规则，或者初始化PriorityBlockingQueue时，指定构造参数Comparator来对元素进行排序。需要注意的是不能保证同优先级元素的顺序。</p></li><li><p>DelayQueue：是一个支持延时获取元素的无界阻塞队列。队列使用PriorityQueue来实现。队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。DelayQueue非常有用，可以将DelayQueue运用在以下应用场景。缓存系统的设计：可以用DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelayQueue中获取元素时，表示缓存有效期到了。还有订单到期，限时支付等等</p></li><li><p>SynchronousQueue：是一个不存储元素的阻塞队列。每一个put操作必须等待一个take操作，否则不能继续添加元素。SynchronousQueue可以看成是一个传球手，负责把生产者线程处理的数据直接传递给消费者线程。队列本身并不存储任何元素，非常适合传递性场景。SynchronousQueue的吞吐量高于LinkedBlockingQueue和ArrayBlockingQueue。</p></li><li><p>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列，多了tryTransfer和transfer方法。如果当前有消费者正在等待接收元素（消费者使用take()方法或带时间限制的poll()方法时），transfer方法可以把生产者传入的元素立刻transfer（传输）给消费者。如果没有消费者在等待接收元素，transfer方法会将元素存放在队列的tail节点，并等到该元素被消费者消费了才返回。tryTransfer方法是用来试探生产者传入的元素是否能直接传给消费者。如果没有消费者等待接收元素，则返回false。和transfer方法的区别是tryTransfer方法无论消费者是否接收，方法立即返回，而transfer方法是必须等到消费者消费了才返回。</p></li><li><p>LinkedBlockingDeque：是一个由链表结构组成的双向阻塞队列。所谓双向队列指的是可以从队列的两端插入和移出元素。双向队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。多了addFirst、addLast、offerFirst、offerLast、peekFirst和peekLast等方法，以First单词结尾的方法，表示插入、获取（peek）或移除双端队列的第一个元素。以Last单词结尾的方法，表示插入、获取或移除双端队列的最后一个元素。另外，插入方法add等同于addLast，移除方法remove等效于removeFirst。但是take方法却等同于takeFirst，不知道是不是JDK的bug，使用时还是用带有First和Last后缀的方法更清楚。在初始化LinkedBlockingDeque时可以设置容量防止其过度膨胀。另外，双向阻塞队列可以运用在“工作窃取”模式中。</p></li></ul><h3 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h3><p>ConcurrentLinkedQueue是一个无界非阻塞队列，它是基于链表的无界线程安全队列。该队列的元素遵循先进先出的原则。头是最先加入的，尾是最近加入的。插入元素是追加到尾上，提取一个元素是从头提取。</p><p>可以看成是LinkedList的并发版本，常用方法：</p><ul><li><p>add(e):插入指定元素</p></li><li><p>offer(e):将指定元素插入到此队列的尾部。  </p></li><li><p>peek():检索此队列的头但并不移除，如果此队列为空，则返回 null。  </p></li><li><p>poll(): 检索并移除此队列的头，如果此队列为空，则返回 null。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并发容器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>volatile</title>
    <link href="/blog/2020/07/28/JUC-volatile/"/>
    <url>/blog/2020/07/28/JUC-volatile/</url>
    
    <content type="html"><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>Java 内存模型中的可见性、原子性和有序性：</p><ul><li><p>可见性，是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。</p></li><li><p>原子性，指的是这个操作是原子不可拆分的，不允许别的线程中间插队操作。</p></li><li><p>有序性指的是你写的代码的顺序要和最终执行的指令保持一致。因为在Java内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p></li></ul><p>volatile要解决的就是可见性和有序性问题。</p><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VolatileTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">true</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">while</span> (flag) ;        System.out.println(<span class="hljs-string">"finish"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">new</span> VolatileTest().start();        Thread.sleep(<span class="hljs-number">2000</span>);        flag = <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>Java内存模型分为主内存和线程工作内存两大类。</p><ul><li><p>主内存：多个线程共享的内存。方法区和堆属于主内存区域。</p></li><li><p>线程工作内存：每个线程独享的内存。虚拟机栈、本地方法栈、程序计数器属于线程独享的工作内存。</p></li></ul><img src="/blog/2020/07/28/JUC-volatile/pic1.png" srcset="/blog/img/loading.gif" class><p>Java内存模型规定，所有变量都需要存储在主内存中，线程需要时，可以在自己的工作内存保存变量的副本，线程对变量的所有操作都在工作内存中进行，执行结束后再同步到主内存中去。这里必然会存在时间差，在这个时间差内，该线程对副本的操作，对于其他线程是不见的，从而造成了可见性问题。</p><p>但是，当对volatile变量进行写操作的时候，JVM会向处理器发送一条lock前缀的指令，将这个缓存中的变量回写到系统主存中。</p><p>同时，在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议。每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期，一旦发现过期就会将当前处理器的缓存行设置成无效状态，强制从主内存读取，这就保障了可见性。</p><p>而volatile变量，通过内存屏障（JMM课程）可以禁止指令重排。从而实现指令的有序性。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>volatile不能保证原子性</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BadVolatile</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> i;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inc</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">int</span> j = get();        <span class="hljs-keyword">try</span> &#123;            Thread.sleep(<span class="hljs-number">100</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        i = j + <span class="hljs-number">1</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">final</span> BadVolatile counter = <span class="hljs-keyword">new</span> BadVolatile();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                    counter.inc();                &#125;            &#125;).start();        &#125;        Thread.sleep(<span class="hljs-number">3000</span>);        <span class="hljs-comment">//理论上10才对。可是.... </span>        System.out.println(counter.i);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>volatile</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ForkJoin</title>
    <link href="/blog/2020/07/28/JUC-ForkJoin/"/>
    <url>/blog/2020/07/28/JUC-ForkJoin/</url>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>ForkJoin是由JDK1.7后提供多线并发处理框架。ForkJoinPool由Java大师Doug Lea主持编写，处理逻辑大概分为两步。</p><ol><li><p>任务分割：fork，先把大的任务分割成足够小的子任务，如果子任务比较大的话还要对子任务进行继续分割。</p></li><li><p>合并结果：join，分割后的子任务被多个线程执行后，再合并结果，得到最终的完整输出。</p></li></ol><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><ul><li><p><strong>ForkJoinTask</strong>：主要提供fork和join两个方法用于任务拆分与合并；多数使用RecursiveAction（无返回值的任务）和RecursiveTask（需要返回值）来实现compute()方法；</p><img src="/blog/2020/07/28/JUC-ForkJoin/pic1.png" srcset="/blog/img/loading.gif" class></li><li><p><strong>ForkJoinPool</strong>：调度ForkJoinTask的线程池；</p><img src="/blog/2020/07/28/JUC-ForkJoin/pic2.png" srcset="/blog/img/loading.gif" class></li><li><p><strong>ForkJoinWorkerThread</strong>：Thread的子类，存放于线程池中的工作线程（Worker）；</p><img src="/blog/2020/07/28/JUC-ForkJoin/pic3.png" srcset="/blog/img/loading.gif" class></li><li><p><strong>WorkQueue</strong>：任务队列，用于保存任务；</p></li></ul><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.thread;<span class="hljs-keyword">import</span> java.util.concurrent.*;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SumTask</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer MAX = <span class="hljs-number">100</span>;    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RecursiveTask</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123;        <span class="hljs-comment">// 子任务开始计算的值</span>        <span class="hljs-keyword">private</span> Integer start;        <span class="hljs-comment">// 子任务结束计算的值 </span>        <span class="hljs-keyword">private</span> Integer end;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SubTask</span><span class="hljs-params">(Integer start, Integer end)</span> </span>&#123;            <span class="hljs-keyword">this</span>.start = start;            <span class="hljs-keyword">this</span>.end = end;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">protected</span> Integer <span class="hljs-title">compute</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">if</span> (end - start &lt; MAX) &#123;                <span class="hljs-comment">//小于边界，开始计算 </span>                System.out.println(<span class="hljs-string">"start = "</span> + start + <span class="hljs-string">";end = "</span> + end);                Integer totalValue = <span class="hljs-number">0</span>;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> index = <span class="hljs-keyword">this</span>.start; index &lt;= <span class="hljs-keyword">this</span>.end; index++) &#123;                    totalValue += index;                &#125;                <span class="hljs-keyword">return</span> totalValue;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">//否则，中间劈开继续拆分</span>                SubTask subTask1 = <span class="hljs-keyword">new</span> SubTask(start, (start + end) / <span class="hljs-number">2</span>);                subTask1.fork();                SubTask subTask2 = <span class="hljs-keyword">new</span> SubTask((start + end) / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, end);                subTask2.fork();                <span class="hljs-keyword">return</span> subTask1.join() + subTask2.join();            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ForkJoinPool pool = <span class="hljs-keyword">new</span> ForkJoinPool();        Future&lt;Integer&gt; taskFuture = pool.submit(<span class="hljs-keyword">new</span> SubTask(<span class="hljs-number">1</span>, <span class="hljs-number">1000</span>));        <span class="hljs-keyword">try</span> &#123;            Integer result = taskFuture.get();            System.out.println(<span class="hljs-string">"result = "</span> + result);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException | ExecutionException e) &#123;            e.printStackTrace(System.out);        &#125;    &#125;&#125;</code></pre><h3 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h3><p>ForkJoinPool中维护着多个线程（一般为CPU核数）在不断地执行Task，每个线程除了执行自己职务内的Task之外，还会根据自己工作线程的闲置情况去获取其他繁忙的工作线程的Task，如此一来就能能够减少线程阻塞或是闲置的时间，提高CPU利用率。</p><p>普通线程池内部有两个重要容器：工作线程和任务队列。ForkJoinPool也类似，工作线程里放的是特殊线程ForkJoinWorkerThread，任务队列里放的是特殊任务ForkJoinTask。不同之处在于，普通线程池只有一个任务队列。而ForkJoinPool的工作线程ForkJoinWorkerThread内都绑定一个双端任务队列。</p><p>在fork，也就是任务拆分的时候，拆分后的task会被当前线程放到自己的队列中。队列中的任务被线程执行时，有两种模式，默认是同步模式（asyncMode==false）从队尾取任务（LIFO），当自己队列中执行完后，工作线程会到其他队列的队首获取任务（FIFO），取到后如果任务再次fork，拆分会被放入当前线程的队列。</p><blockquote><p>注意：任务切分的粒度，也就是fork的界限，并非越小越好。任务量不是太大的话，串行可能优于并行，因为多线程会涉及到上下文的切换。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ForkJoin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ConcurrentHashMap</title>
    <link href="/blog/2020/07/27/JUC-ConcuttrentHashMap/"/>
    <url>/blog/2020/07/27/JUC-ConcuttrentHashMap/</url>
    
    <content type="html"><![CDATA[<h3 id="Hash算法"><a href="#Hash算法" class="headerlink" title="Hash算法"></a>Hash算法</h3><p>Hash就是把任意长度的输入（又叫做预映射， pre-image），通过散列算法，变换成固定长度的散列值。这种转换是一种压缩映射，散列值的空间通常小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来确定唯一的输入值。因为其不可逆的特性，Hash算法也可以用来作为加密算法。</p><p>处理Hash冲突方法:</p><ol><li>开放寻址法：出现hash冲突时，从当前地址向后寻找</li><li>再散列法：出现hash冲突时，再次进行hash运算</li><li>链地址法（拉链法）：将有hash冲突的元素存储在链表或其他数据结构中</li></ol><p>常用hash算法的介绍：</p><ol><li>MD4 </li><li>MD5（常被用为加密算法）</li><li>SHA-1及其他。</li></ol><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><h4 id="常用位运算"><a href="#常用位运算" class="headerlink" title="常用位运算"></a>常用位运算</h4><ul><li><p>位与 &amp; (1&amp;1=1,0&amp;0=0,1&amp;0=0)</p></li><li><p>位或 | (1|1=1,0|0=0,1|0=1)</p></li><li><p>位非 ~ ( ~1=0,~0=1)</p></li><li><p>位异或 ^ (1^1=0,1^0=1,0^0=0)</p></li><li><p>有符号右移&gt;&gt;(正数高位补0,负数高位补1)</p></li><li><p>有符号左移&lt;&lt;(低位补0)</p></li><li><p>无符号右移&gt;&gt;&gt;(不论正负,高位均补0)</p></li></ul><p>有趣的取模性质：取模a % (2^n) 等价于 a &amp; (2^n - 1)，所以在map里的数组个数一定是2的乘方数，计算key值在哪个元素中的时候，就用位运算来快速定位。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntToBinary</span> </span>&#123;       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> UnsupportedEncodingException </span>&#123;        System.out.println(<span class="hljs-string">"the 4 is : "</span> + Integer.toBinaryString(<span class="hljs-number">4</span>));        System.out.println(<span class="hljs-string">"the 6 is : "</span> + Integer.toBinaryString(<span class="hljs-number">6</span>));        <span class="hljs-comment">//位与&amp;(真真为真 真假为假 假假为假)</span>        System.out.println(<span class="hljs-string">"the 4&amp;6 is : "</span> + Integer.toBinaryString(<span class="hljs-number">6</span>&amp;<span class="hljs-number">4</span>));        <span class="hljs-comment">//位或|(真真为真 真假为真 假假为假)</span>        System.out.println(<span class="hljs-string">"the 4|6 is : "</span> + Integer.toBinaryString(<span class="hljs-number">6</span>|<span class="hljs-number">4</span>));        <span class="hljs-comment">//位非~</span>        System.out.println(<span class="hljs-string">"the ~4 is : "</span> + Integer.toBinaryString(~<span class="hljs-number">4</span>));        <span class="hljs-comment">//位异或^(真真为假 真假为真 假假为假)</span>        System.out.println(<span class="hljs-string">"the 4^6 is : "</span> + Integer.toBinaryString(<span class="hljs-number">6</span>^<span class="hljs-number">4</span>));        <span class="hljs-comment">//有符号右移&gt;&gt;(若正数,高位补0,负数,高位补1)</span>        System.out.println(<span class="hljs-string">"the 4&gt;&gt;1 is : "</span> + Integer.toBinaryString(<span class="hljs-number">4</span>&gt;&gt;<span class="hljs-number">1</span>));        <span class="hljs-comment">//有符号左移&lt;&lt;(若正数,高位补0,负数,高位补1)</span>        System.out.println(<span class="hljs-string">"the 4&lt;&lt;1 is : "</span> + Integer.toBinaryString(<span class="hljs-number">4</span>&lt;&lt;<span class="hljs-number">1</span>));        <span class="hljs-comment">//无符号右移&gt;&gt;&gt;(不论正负,高位均补0)</span>        System.out.println(<span class="hljs-string">"the 234567 is : "</span> + Integer.toBinaryString(<span class="hljs-number">234567</span>));        System.out.println(<span class="hljs-string">"the 234567&gt;&gt;&gt;4 is : "</span> + Integer.toBinaryString(<span class="hljs-number">234567</span>&gt;&gt;&gt;<span class="hljs-number">4</span>));        <span class="hljs-comment">//无符号右移&gt;&gt;&gt;(不论正负,高位均补0)</span>        System.out.println(<span class="hljs-string">"the -4 is : "</span> + Integer.toBinaryString(-<span class="hljs-number">4</span>));        System.out.println(<span class="hljs-string">"the -4&gt;&gt;&gt;4 is : "</span> + Integer.toBinaryString(-<span class="hljs-number">4</span>&gt;&gt;&gt;<span class="hljs-number">4</span>));        System.out.println(Integer.parseInt(Integer.toBinaryString(-<span class="hljs-number">4</span>&gt;&gt;&gt;<span class="hljs-number">4</span>), <span class="hljs-number">2</span>));                <span class="hljs-comment">//取模a % (2^n) 等价于 a &amp; (2^n - 1) </span>        System.out.println(<span class="hljs-string">"the 345 % 16 is : "</span> + (<span class="hljs-number">345</span>%<span class="hljs-number">16</span>)+<span class="hljs-string">" or "</span>+(<span class="hljs-number">345</span>&amp;(<span class="hljs-number">16</span>-<span class="hljs-number">1</span>)));                System.out.println(<span class="hljs-string">"Mark hashCode is : "</span>+<span class="hljs-string">"Mark"</span>.hashCode()+<span class="hljs-string">"="</span>              +Integer.toBinaryString(<span class="hljs-string">"Mark"</span>.hashCode()));        System.out.println(<span class="hljs-string">"Bill hashCode is : "</span>+<span class="hljs-string">"Bill"</span>.hashCode()+<span class="hljs-string">"="</span>              +Integer.toBinaryString(<span class="hljs-string">"Bill"</span>.hashCode()));                    &#125; &#125;</code></pre><h4 id="位运算运用场景"><a href="#位运算运用场景" class="headerlink" title="位运算运用场景"></a>位运算运用场景</h4><ul><li><p>Java中的类修饰符、成员变量修饰符、方法修饰符，比如Class类中</p></li><li><p>Java容器中的HashMap和ConcurrentHashMap的实现</p></li><li><p>权限控制或者商品属性</p></li><li><p>简单可逆加密，比如异或运算(1^1=0,0^1=1 )</p></li></ul><p>实战：权限控制</p><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Permission</span> &#123;</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ALLOW_SELECT = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">0</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ALLOW_INSERT = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">1</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ALLOW_UPDATE = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ALLOW_DELETE = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>;    <span class="hljs-comment">// 当前状态</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> flag;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPermission</span><span class="hljs-params">(<span class="hljs-keyword">int</span> permission)</span> </span>&#123;        <span class="hljs-keyword">this</span>.flag = permission;    &#125;    <span class="hljs-comment">// 增加权限，可以一项或者多项</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addPermission</span><span class="hljs-params">(<span class="hljs-keyword">int</span> permission)</span> </span>&#123;        <span class="hljs-keyword">this</span>.flag = flag | permission;    &#125;    <span class="hljs-comment">// 删除权限，可以一项或者多项</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">disablePermission</span><span class="hljs-params">(<span class="hljs-keyword">int</span> permission)</span> </span>&#123;        <span class="hljs-keyword">this</span>.flag = flag &amp; ~permission;    &#125;    <span class="hljs-comment">// 是否拥有权限</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAllow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> permission)</span> </span>&#123;        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.flag &amp; permission) == permission;    &#125;    <span class="hljs-comment">// 是否不拥有权限</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isNotAllow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> permission)</span> </span>&#123;        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.flag &amp; permission) == <span class="hljs-number">0</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;      <span class="hljs-keyword">int</span> flag = <span class="hljs-number">15</span>;      Permission permission = <span class="hljs-keyword">new</span> Permission();      permission.setPermission(flag);      permission.disablePermission(ALLOW_DELETE|ALLOW_INSERT);      System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"ALLOW_SELECT="</span>+permission.isAllow(ALLOW_SELECT));      System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"ALLOW_INSERT="</span>+permission.isAllow(ALLOW_INSERT));      System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"ALLOW_UPDATE="</span>+permission.isAllow(ALLOW_UPDATE));      System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"ALLOW_DELETE="</span>+permission.isAllow(ALLOW_DELETE));    &#125;</code></pre><p>使用位运算可以节省很多代码量，而且效率高、属性变动影响小，但位运算不太直观，会对代码可读性产生一定的影响。</p><h3 id="HashMap死循环的分析"><a href="#HashMap死循环的分析" class="headerlink" title="HashMap死循环的分析"></a>HashMap死循环的分析</h3><p>在多线程环境下，HashMap在并发执行put操作时会导致HashMap的Entry链表形成环形数据结构，一旦形成环形数据结构，Entry的next节点永远不为空，就会产生死循环获取Entry，导致CPU利用率接近100%。</p><h4 id="HashMap扩容流程"><a href="#HashMap扩容流程" class="headerlink" title="HashMap扩容流程"></a>HashMap扩容流程</h4><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>正常的扩容操作是这个流程。HashMap的扩容在put操作中会触发扩容，主要是三个方法：</p><p>综合来说，HashMap一次扩容的过程：</p><ol><li><p>取当前table的2倍作为新table的大小；</p></li><li><p>根据算出的新table的大小new出一个新的Entry数组来，名为newTable；</p></li><li><p>轮询原table的每一个位置，将每个位置上连接的Entry，算出在新table上的位置，并以链表形式连接；</p></li><li><p>原table上的所有Entry全部轮询完毕之后，HashMap中的table指向newTable；</p></li></ol><h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><p>现在hashmap中有三个元素，key分别为3、7、5，Hash表的size=2, 通过hash计算后这三个元素都将分配到table[1]。</p><p>按照方法中的代码</p><p>对table[1]中的链表来说，进入while循环，此时e=key(3)，那么next=key(7)，经过计算重新定位e=key(3)在新表中的位置，并把e=key(3)分配newTable[3]的位置</p><p>这样循环下去，将table[1]中的链表循环完成后，于是HashMap就完成了扩容</p><p>HashMap在hash冲突插入元素时采用的是头插法，先将新的元素的next指向当前table[i]，之后再将table[i]指向当前元素</p><h4 id="并发下的扩容"><a href="#并发下的扩容" class="headerlink" title="并发下的扩容"></a>并发下的扩容</h4><p>初始的HashMap还是：</p><p>现在假设有两个线程并发操作，都进入了扩容操作线程1执行到Entry&lt;K,V&gt; next = e.next;时被操作系统调度挂起了，而线程2执行完成了扩容操作:</p><p>于是，在线程1,2看来，就应该是这个样子</p><p>接下来，线程1被调度回来执行： </p><ol><li></li><li></li><li></li><li></li><li></li><li></li><li></li></ol><p>循环列表产生后，一旦线程1调用get（11,15之类的元素）时，就会进入一个死循环的情况，将CPU的消耗到100%。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>HashMap之所以在并发下的扩容造成死循环，是因为多个线程并发进行时，一个线程先期完成了扩容，将原Map的链表重新散列到自己的表中，并将链表变成了倒序，后一个线程再扩容时，又进行自己的散列，再次将倒序链表变为正序链表，于是形成了一个环形链表，当get表中不存在的元素时，会去遍历链表造成死循环。</p><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><h4 id="JDK1-7中的实现分析"><a href="#JDK1-7中的实现分析" class="headerlink" title="JDK1.7中的实现分析"></a>JDK1.7中的实现分析</h4><h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5><p>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁（ReentrantLock），HashEntry则用于存储键值对数据。ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构。一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素，每个Segment守护着一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得与它对应的Segment锁。Segment数组初始化之后大小不再改变，当需要扩容时Segment下的table数组进行扩容。</p><h5 id="初始化方法"><a href="#初始化方法" class="headerlink" title="初始化方法"></a>初始化方法</h5><p>ConcurrentHashMap初始化方法是通过initialCapacity（初始化容量）、loadFactor（负载因子）和concurrencyLevel（并发级别）来初始化segment数组、段偏移量segmentShift、段掩码segmentMask和每个segment里的HashEntry数组来实现的。</p><p>参数concurrencyLevel（并发度）可以理解为程序运行时能够同时更新ConccurentHashMap且不产生锁竞争的最大线程数，实际上就是ConcurrentHashMap中的分段锁个数，即Segment[]的数组长度。ConcurrentHashMap默认的并发度为16，用户也可以在构造函数中设置并发度，设置之后将不再改变。当用户设置并发度时，ConcurrentHashMap会使用大于等于该值的最小2幂指数作为实际并发度（假如用户设置并发度为17，实际并发度则为32）。如果设置的过小，会带来严重的锁竞争问题；如果设置的过大，原本位于同一个Segment内的访问会扩散到不同的Segment中，CPU cache命中率会下降，从而引起程序性能下降。大小可以通过cpu核心数或实际使用该Map的线程数量来确定。</p><p>参数initialCapacity是ConcurrentHashMap的初始化容量，loadfactor是每个Segment的负载因子，在构造方法里需要通过这两个参数来初始化数组中的每个Segment。上面代码中的变量cap就是Segment里HashEntry数组的长度，它等于initialCapacity除以ssize的倍数c，如果c大于1，就会取大于等于c的2的N次方值，所以segment里HashEntry数组的长度不是1，就是2的N次方。</p><p>在默认情况下， ssize = 16，initialCapacity = 16，loadFactor = 0.75f，那么cap = 1，threshold = (int) cap * loadFactor = 0。</p><p>在初始化时，默认只初始化Segment[0]中的table，其他Segment中的table在put时再进行初始化。</p><p>初始化segmentShift和segmentMask（了解即可，无需深究）这两个全局变量需要在定位segment时的散列算法里使用，shift等于size从1向左移位的次数，在默认情况下concurrencyLevel等于16，1需要向左移位移动4次，所以sshift等于4。segmentShift用于定位参与散列运算的位数，segmentShift等于32减sshift，所以等于28，这里之所以用<em>32</em>是因为ConcurrentHashMap里的hash()方法输出的最大数是<em>32</em>位的。segmentMask是散列运算的掩码，等于ssize减1，即15，掩码的二进制各个位的值都是<em>1</em>。因为ssize的最大长度是65536，所以segmentShift最大值是16，segmentMask最大值是65535，对应的二进制是16位，每个位都是1。</p><h5 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h5><p>既然ConcurrentHashMap使用分段锁Segment来保护不同段的数据，那么在插入和获取元素的时候，必须先通过散列算法定位到Segment。get操作先获取hash值，然后使用这个hash值通过hash运算定位到Segment(使用了hash值的高位部分)，再通过hash算法定位到table(使用了散列值的全部)。</p><p>整个get过程没有加锁，而是通过volatile保证get总是可以拿到最新值。</p><p>ConcurrentHashMap中使用的hash算法为Wang/Jenkins hash的变种算法，其产生的hash的值更加均匀，减少了hash冲突</p><h5 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h5><p>put方法首先会根据key计算出所在的Segment，然后调用ensureSegment()方法获取Segment。因为ConcurrentHashMap初始化时只会初始化第一个槽 segment[0]，所以其他槽在插入第一个值时会在ensureSegment()方法中进行初始化。</p><p>ensureSegment方法考虑了并发情况，当多个线程同时进入初始化同一个槽 segment[k]会进行循环CAS操作保证只有一个线程成功。</p><p>put方法在获取到Segment之后会调用Segment中的put方法，Segment中的put方法会通过tryLock()方法尝试获得锁，如果成功获得锁会将node置为null然后进入try语句块，如果没有获得锁会调用scanAndLockForPut()方法自旋等待获得锁。</p><p>scanAndLockForPut方法里在尝试获得锁的过程中会对对应HashEntity链表进行遍历，如果遍历完毕仍然找不到与key相同的HashEntry节点，则为后续的put操作提前创建一个HashEntry。当tryLock一定次数（当cpu可用核心数大于1时重试64次，否则只重试1次）后仍无法获得锁，则通过lock()阻塞式申请锁。</p><p>在获得锁之后，Segment对链表进行遍历，如果某个HashEntry节点具有相同的key，则更新该HashEntry的value值</p><p>否则新建一个HashEntry节点，采用头插法，将它设置为链表的新head节点并将原头节点设为新head的下一个节点。新建过程中如果节点总数（含新建的HashEntry）超过threshold，则调用rehash()方法对Segment进行扩容，最后将新建HashEntry写入到数组中。</p><h5 id="rehash方法"><a href="#rehash方法" class="headerlink" title="rehash方法"></a>rehash方法</h5><p>rehash方法扩容时会先创建数组newTable，然后进行将table中的节点迁移至newTable，最后用newTable取代table。</p><p>由于扩容是基于2的幂指来操作，假设扩容前某HashEntry对应到Segment中数组的index为i，数组的容量为capacity，那么扩容后该HashEntry对应到新数组中的index只可能为i或者i+capacity，因此很多HashEntry节点在扩容前后index可以保持不变，避免让所有的节点都进行复制操作。</p><p>假设原来table长度为4，那么元素在table中的分布是这样的</p><table><thead><tr><th>Hash值</th><th>15</th><th>23</th><th>34</th><th>56</th><th>77</th></tr></thead><tbody><tr><td>在table中的下标</td><td>3 = 15%4</td><td>3=23%4</td><td>2 = 34%4</td><td>0= 56%4</td><td>1 =77 %4</td></tr></tbody></table><p>扩容后table长度变为8，那么元素在table中的分布变成：</p><table><thead><tr><th>Hash值</th><th>15</th><th>23</th><th>34</th><th>56</th><th>77</th></tr></thead><tbody><tr><td>在table中的下标</td><td>7</td><td>7</td><td>2</td><td>0</td><td>5</td></tr></tbody></table><p>可以看见 hash值为34和56的下标保持不变，而15,23,77的下标都是在原来下标的基础上+4即可，可以快速定位和减少重排次数。</p><p>该方法没有考虑并发，因为执行该方法之前已经获取了锁。</p><h5 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h5><p>与put方法类似，都是在操作前需要拿到锁，以保证操作的线程安全性。</p><h5 id="size、containsValue方法"><a href="#size、containsValue方法" class="headerlink" title="size、containsValue方法"></a>size、containsValue方法</h5><p>这些方法都是基于整个ConcurrentHashMap来进行操作的，他们的原理也基本类似：首先不加锁循环执行以下操作：循环所有的Segment，获得对应的值以及所有Segment的modcount之和。在 put、remove 和 clean 方法里操作元素前都会将变量 modCount 进行变动，如果连续两次所有Segment的modcount和相等，则过程中没有发生其他线程修改ConcurrentHashMap的情况，返回获得的值。</p><p>当循环次数超过预定义的值时，这时需要对所有的Segment依次进行加锁，获取返回值后再依次解锁。所以一般来说，应该避免在多线程环境下使用size和containsValue方法。</p><h5 id="ConcurrentHashMap的弱一致性"><a href="#ConcurrentHashMap的弱一致性" class="headerlink" title="ConcurrentHashMap的弱一致性"></a>ConcurrentHashMap的弱一致性</h5><p>ConcurrentHashMap的get()和containsKey()方法并没有加锁，在遍历链表节点判断key是否相同以及获得该节点的value时，其他线程对链表结构做的调整（put新的key或者remove操作）会由于HashEntity数组并不是volita修饰的导致返回的可能是过时的数据。如果要求强一致性，那么必须使用Collections.synchronizedMap()方法。</p><h4 id="JDK1-8中的实现分析"><a href="#JDK1-8中的实现分析" class="headerlink" title="JDK1.8中的实现分析"></a>JDK1.8中的实现分析</h4><h5 id="相比JDK1-7的改进"><a href="#相比JDK1-7的改进" class="headerlink" title="相比JDK1.7的改进"></a>相比JDK1.7的改进</h5><ol><li>取消segments字段，直接采用transient volatile HashEntry&lt;K,V&gt;[] table保存数据，使用table数组元素作为锁，由于table是可以扩容的，数据的增加时锁的粒度也会缩小以减少并发冲突的概率，同时大量使用了使用 CAS + synchronized 来保证并发安全性。</li><li>将原本的table数组＋单向链表的数据结构，变更为table数组＋单向链表＋红黑树的结构。hash表最核心的能力在于将key hash之后能均匀的分布在数组中，理想的情况下table数组中的每个队列长度主要为0或者1，但实际情况并非如此。在数据量过大的情况下，即使ConcurrentHashMap类会依据默认的加载因子0.75进行扩容、增加table数组长度，但是如果hash结果不均匀，也会使数据集中在某个队列导致队列过长。此时查询某个节点的时间复杂度为O(n)。所以对于个数超过8(默认值)的列表jdk1.8中采用了红黑树的结构，查询的时间复杂度可以降低到O(logN)，从而改进性能。</li><li>使用 Node（jdk1.7 为 HashEntry）作为链表的数据结点，仍然包含 key，value，hash 和 next 四个属性。 红黑树中使用的是 TreeNode（extends Node）。所以根据数组元素中第一个结点数据类型是 Node 还是 TreeNode 可以判断该位置下是链表还是红黑树。</li></ol><p>当链表的长度大于8时会转为红黑树</p><p>当红黑树的大小小于6时会转为链表</p><h5 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h5><p>Node是最核心的内部类，它包装了key-value键值对。</p><p>定义基本和1.7中的HashEntry相同。Map本身所持有的也是一个Node型的数组</p><p>增加了一个find方法来用以辅助map.get()方法。其实就是遍历链表，子类中会覆盖这个方法。</p><p>在map中还定义了Segment这个类，不过只是为了向前兼容而已，不做过多考虑。</p><h5 id="TreeNode"><a href="#TreeNode" class="headerlink" title="TreeNode"></a>TreeNode</h5><p>树节点类，另外一个核心的数据结构。当链表长度过长的时候，会转换为TreeNode。</p><p>与1.8中HashMap不同点：</p><ol><li><p>它并不是直接转换为红黑树，而是把这些结点放在TreeBin对象中，由TreeBin完成对红黑树的包装。</p></li><li><p>TreeNode在ConcurrentHashMap继承Node类，HashMap中的继承LinkedHashMap.Entry&lt;K,V&gt;类，ConcurrentHashMap中的TreeNode带有next指针。</p></li></ol><h5 id="TreeBin"><a href="#TreeBin" class="headerlink" title="TreeBin"></a>TreeBin</h5><p>负责TreeNode节点。它代替了TreeNode的根节点，也就是说在实际ConcurrentHashMap的table数组中存放的是TreeBin对象，而不是TreeNode对象。另外这个类还带有了读写锁机制。</p><h5 id="ForwardingNode"><a href="#ForwardingNode" class="headerlink" title="ForwardingNode"></a>ForwardingNode</h5><p>ForwardingNode是一个特殊的 Node 结点，hash 值为 -1，内部存储nextTable的引用。在table发生扩容的时作为一个占位符放在 table 中表示当前结点为 null 或者已经被移动。</p><h5 id="sizeCtl"><a href="#sizeCtl" class="headerlink" title="sizeCtl"></a>sizeCtl</h5><p>用来控制 table 的初始化和扩容操作。</p><p>负数代表正在进行初始化或扩容操作：-1代表正在初始化，-N 表示有N-1个线程正在进行扩容操作，0为默认值，代表当时的table还没有被初始化。</p><p>正数表示初始化大小或Map中的元素达到这个数量时，需要进行扩容了。</p><h5 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h5><h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><p>可以发现，在new出一个map的实例时，并不会创建其中的数组等等相关的部件，只是进行简单的属性设置而已。同样的，table的大小也被规定为必须是2的乘方数。</p><p>真正的初始化在放在了是在向ConcurrentHashMap中插入元素的时候发生的。如调用put()、computeIfAbsent()、compute()、merge()等方法的时候，调用时机是检查table==null。</p><h5 id="get操作"><a href="#get操作" class="headerlink" title="get操作"></a>get操作</h5><p>get方法比较简单，给定一个key来确定value的时候，必须满足两个条件 key相同 hash值相同，对于节点可能在链表或树上的情况，需要分别去查找。</p><h5 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h5><p>总结来说，put方法也继续沿用HashMap的put方法的思想，首先不允许key或value为null的情况放入，对于每一个放入的值，利用spread方法对key的hashcode进行一次hash计算，由此来确定这个值在table中的位置i，如果i位置是空的，直接放进去且不需要加锁操作，否则对i位置节点进行加锁，然后对节点进行判断，如果是树节点则按照树的方式插入新的节点，如果是链表节点，则得到的结点就是由hash值相同的节点组成的链表的头节点。此时需要向后遍历链表，如果遇到key值一致的情况，则需要更新其value值，否则依次向后遍历，到链表尾插入这个结点（尾插法）。如果加入这个节点以后链表长度大于8，就把这个链表转换成红黑树。</p><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>前面说过，构造方法中并没有真正初始化，真正的初始化在放在了是在向ConcurrentHashMap中插入元素的时候发生的。具体实现的方法就是initTable</p><h5 id="transfer"><a href="#transfer" class="headerlink" title="transfer"></a>transfer</h5><p>当ConcurrentHashMap容量不足的时需要对table进行扩容。这个方法的基本思想跟HashMap是很像的，但是由于它是支持并发扩容的，所以要复杂的多。我们不深入源码去讲述，只讲述其大概原理。</p><p>扩容的时总是会涉及到从一个“数组”到另一个“数组”拷贝的操作，并发扩容就是使这个操作能够并发进行，利用并发处理去减少扩容带来的时间影响。transfer中的并发扩容就是将数据迁移任务根据变量stride作为步长拆分成多个小迁移任务，每个线程每次负责迁移其中的一部分。</p><p>整个扩容操作分为两个部分：</p><p>第一部分是构建一个nextTable,它的容量是原来的2倍。</p><p>第二个部分就是将原来table中的元素复制到nextTable中，这里允许多线程进行操作。</p><p>整个扩容流程就是遍历和复制：</p><p>为null或者已经处理过的节点，会被设置为forwardNode节点，当线程准备扩容时，发现节点是forwardNode节点，跳过这个节点，继续寻找未处理的节点，找到之后对节点上锁。</p><p>如果这个位置是Node节点（fh&gt;=0），说明它是一个链表，就构造一个反序链表，把他们分别放在nextTable的i和i+n的位置上</p><p>如果这个位置是TreeBin节点（fh&lt;0），也做一个反序处理，并且判断是否需要红黑树转链表，把处理的结果分别放在nextTable的i和i+n的位置上</p><p>遍历过所有的节点以后就完成了复制工作，这时让nextTable作为新的table，并且更新sizeCtl为新容量的0.75倍 ，完成扩容。</p><h5 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h5><p>移除方法的基本流程和put方法很类似，只不过操作由插入数据变为移除数据而已，而且如果存在红黑树的情况下，会检查是否需要将红黑树转为链表的步骤。不再重复讲述。</p><h5 id="treeifyBin"><a href="#treeifyBin" class="headerlink" title="treeifyBin"></a>treeifyBin</h5><p>用于将过长的链表转换为TreeBin对象。但是他并不是直接转换，而是进行一次容量判断，没有达到转换的要求，直接进行扩容操作并返回；如果满足条件才将链表的结构转换为TreeBin ，这与HashMap不同的是，它并没有把TreeNode直接放入红黑树，而是利用了TreeBin这个小容器来封装所有的TreeNode。</p><h5 id="size"><a href="#size" class="headerlink" title="size"></a>size</h5><p>JDK1.8中，调用put()方法时就会调用addCount()方法计算size的数量，扩容过程也会修改size的数量，因此在调用size()方法时可以直接返回，JDK1.7是调用size()方法时才会去计算。</p><p>调用addCount()方法时，会使用CAS更新baseCount，因为CAS只允许一个线程做修改，如果修改失败就会使用counterCells，大致的流程就是：</p><ol><li><p>对 baseCount 做 CAS 自增操作。</p></li><li><p>如果并发导致 baseCount CAS 失败了，则使用 counterCells。</p></li><li><p>如果counterCells CAS 失败了，在 fullAddCount 方法中，会继续死循环操作，直到成功。</p></li></ol><p>在具体实现上，计算大小的核心方法都是 sumCount()</p><p>JDK1.8中sumCount()会获取baseCount和CounterCell数组然后遍历CounterCell数组，将baseCount与CounterCell的值累加后返回。</p><p>其实去计算并发集合中实时在变的size是没有多大的意义的，但Doug Lea仍花费了很多心思去优化他的性能。</p><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ul><li><p>HashMap与HashTable的区别</p><ul><li>HashMap 是线程不安全的，HashTable 是线程安全的；</li><li>由于线程安全，HashTable的效率比HashMap要低；</li><li>HashMap是允许key为null的，HashTable是不允许的，ConcurrentHashMap也是不允许的。</li><li>HashMap最多只允许一条记录的键为null，允许多条记录的值为null，而 HashTable 不允许；</li><li>HashMap 默认初始化数组的大小为16，HashTable 为 11，前者扩容时，扩大两倍，后者扩大两倍+1；</li><li>HashMap 需要重新计算 hash 值，而 HashTable 直接使用对象的 hashCode</li></ul></li><li><p>ConcurrentHashMap与HashTable的区别</p><p>HashTable只是简单的使用synchronize关键字保证线程安全，使用过程中只有一把锁，效率十分感人。</p><p>ConcurrentHashMap是 Java并发包java.util.concurrent中提供的一个线程安全且高效的HashMap 实现，使用分段锁的方式细化了锁的粒度，以提升效率。在JDK 1.7中的结构是ReentranLock+Segment+HashEntry，Segment是一种ReentranLock的实现，锁的粒度是基于Segment的，Segment中包含多个HashEntry，HashEntry中存储着key跟value，但Segment的数量是固定的，无法随着扩容增加。JDK 1.8中进行了改进，采用CAS + synchronized + Node + 红黑树，锁力度基于table中的Node节点来实现的线程安全，进一步缩小了锁的粒度。</p></li><li><p>HashMap与ConcurrentHashMap的区别</p><p>原理上没有太大区别，只不过ConcurrentHashMap是线程安全的，另外HashMap 的键值对允许有null，但是ConCurrentHashMap 都不允许，还有在数据结构上，红黑树相关的节点类不同、继承的类不同</p></li><li><p>ConcurrentHashMap锁机制</p><p>JDK 1.7 中，采用分段锁的机制，实现并发的更新操作，底层采用数组+链表的存储结构，包括两个核心静态内部类 Segment 和 HashEntry。Segment 继承 ReentrantLock（重入锁） 用来充当锁的角色，每个 Segment 对象守护每个散列映射表的若干个桶；HashEntry 用来封装映射表的键-值对；每个桶是由若干个 HashEntry 对象链接起来的链表。</p><p>JDK 1.8 中，采用Node + CAS + Synchronized来保证并发安全。取消类 Segment，当需要锁时直接用synchronized锁住table数组中的对象，键值对直接存储在table中；当 Node 对象组成的链表长度超过 TREEIFY_THRESHOLD 时，链表转换为红黑树，Node对象被包装为TreeNode，以提升检索性能。此时底层变更为数组 + 链表 + 红黑树。</p></li><li><p>ConcurrentHashMap在JDK 1.8中使用内置锁 synchronized 来代替重入锁 ReentrantLock的原因</p><ul><li>JVM 开发团队对 synchronized做了大量性能上的优化，而且基于 JVM 的 synchronized 优化空间更大，更加自然。</li><li>在大量的数据操作下，ReentrantLock 会开销更多的内存。</li></ul></li><li><p>ConcurrentHashMap注意点</p><ul><li>重要的常量：<strong>private transient volatile int sizeCtl</strong>，当为负数时，-1 表示正在初始化，-N 表示 N - 1 个线程正在进行扩容；当为 0 时，表示 table 还没有初始化；当为其他正数时，表示初始化或者下一次进行扩容的大小。</li><li>数据结构：<strong>Node 是存储结构的基本单元</strong>，继承 HashMap 中的 Entry，用于存储数据；TreeNode 继承 Node，但是数据结构换成了二叉树结构，是红黑树的存储结构，用于红黑树中存储数据；TreeBin 是封装 TreeNode 的容器，提供转换红黑树的一些条件和锁的控制。</li><li>put()方法：如果没有初始化，就调用 initTable() 方法来进行初始化；如果没有 hash 冲突就直接 CAS 无锁插入；如果需要扩容，就先进行扩容；如果存在 hash 冲突，就加锁来保证线程安全，两种情况：一种是链表形式就直接遍历到尾端插入，一种是红黑树就按照红黑树结构插入；如果该链表的数量大于阀值 8，就要先转换成红黑树的结构，break 再一次进入循环如果添加成功就调用 addCount() 方法统计 size，并且检查是否需要扩容。</li><li>扩容方法 transfer()：默认容量为 16，扩容时，容量变为原来的两倍。helpTransfer()：调用多个工作线程一起帮助进行扩容，这样的效率就会更高。</li><li>get()方法：计算 hash 值，定位到该 table 索引位置，如果是首结点符合就返回；如果遇到扩容时，会调用标记正在扩容结点 ForwardingNode.find()方法，查找该结点，匹配就返回；以上都不符合的话，就往下遍历结点，匹配就返回，否则最后就返回 null。</li></ul></li><li><p>ConcurrentHashMap的并发度</p><p>并发度表示程序运行时能够同时更新 ConccurentHashMap 且不产生锁竞争的最大线程数。JDK1.7种默认为 16，即Segment的数量，可以在构造函数中设置。当用户设置并发度时，ConcurrentHashMap 会使用大于等于该值的最小2幂指数作为实际并发度（假如用户设置并发度为17，实际并发度则为32）。1.8中由于直接使用table中的节点数量作为分段锁的数量，并发度已经没有太大的实际意义了，主要用处就是当设置的初始容量小于并发度，将初始容量提升至并发度大小。 </p></li></ul>]]></content>
    
    
    <categories>
      
      <category>并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ConcurrentHashMap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ThreadLocal</title>
    <link href="/blog/2020/07/27/JUC-ThreadLocal/"/>
    <url>/blog/2020/07/27/JUC-ThreadLocal/</url>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>ThreadLocal类并不是用来解决多线程环境下的共享变量问题，而是用来提供线程内部的共享变量。在多线程环境下，可以保证各个线程之间的变量互相隔离、相互独立。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>ThreadLocal实例一般定义为private static类型的，在一个线程内，该变量共享一份，类似上下文作用，可以用来上下传递信息。</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.local;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocalDemo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;Integer&gt; threadLocal = <span class="hljs-keyword">new</span> ThreadLocal&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;            threadLocal.set(i);            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">",value="</span> + threadLocal.get());        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ThreadLocalDemo demo = <span class="hljs-keyword">new</span> ThreadLocalDemo();        <span class="hljs-keyword">new</span> Thread(demo).start();        <span class="hljs-keyword">new</span> Thread(demo).start();    &#125;&#125;</code></pre><p>ThreadLocal类接口很简单，只有4个方法</p><ul><li><strong>void set(Object value)</strong> ：设置当前线程的线程局部变量的值。</li><li><strong>public Object get()</strong> ：返回当前线程所对应的线程局部变量。</li><li><strong>public void remove()</strong> ：将当前线程局部变量的值删除，目的是为了减少内存的占用，该方法是JDK 5.0新增的方法。需要指出的是，当线程结束后，对应该线程的局部变量将自动被垃圾回收，所以显式调用该方法清除线程的局部变量并不是必须的操作，但它可以加快内存回收的速度。</li><li><strong>protected Object initialValue()</strong>： 返回该线程局部变量的初始值，该方法是一个protected的方法，显然是为了让子类覆盖而设计的。这个方法是一个延迟调用方法，在线程第1次调用get()或set(Object)时才执行，并且仅执行1次。ThreadLocal中的缺省实现直接返回一个null。</li><li><strong>public final static ThreadLocal&lt;String&gt; RESOURCE = new ThreadLocal&lt;String&gt;();</strong>RESOURCE代表一个能够存放String类型的ThreadLocal对象。此时不论什么一个线程能够并发访问这个变量，对它进行写入、读取操作，都是线程安全的。</li></ul><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><img src="/blog/2020/07/27/JUC-ThreadLocal/pic1.png" srcset="/blog/img/loading.gif" class><p>ThreadLocal中有一个ThreadLocalMap对象，ThreadLocalMap是ThreadLocal的静态内部类，存储的对象为Entry类型的数组，Entry类型的key为ThreadLocal对象，value为ThreadLocal对象的值，ThreadLocal的get方法会获取当前Thread，然后调用getMap()获取当前Thread的ThreadLocalMap，再从ThreadLocalMap中通过ThreadLocal找到对应的值。</p><h4 id="内存泄露分析"><a href="#内存泄露分析" class="headerlink" title="内存泄露分析"></a>内存泄露分析</h4><p>线程中维护的ThreadLocalMap中的Entry对key的引用是弱引用，如果外部对ThreadLocal实例的强引用失效，Entry中的key以及ThreadLocal实例会被gc回收，但value会依然存在，因为线程中依然存有ThreadLocalMap的强引用，Entry会继续存在，所以value也会存在，这就有可能造成内存泄漏。只有当前线程结束以后，ThreadLocalMap强引用断开才会被GC回收。</p><p>jdk对此提供了相应的补偿机制，ThreadLocal的get()，set()有可能会去调用expungeStaleEntry()，replaceStaleEntry()方法去清除key为null（ThreadLocal为null）的value值。但最好还是在使用完threadLocal变量后，手动调用它的remove()方法清除数据。</p><p>如果对key的引用为强引用的话，set()，get()方法中对Model的释放就一定不会触发，必然会造成内存泄漏。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>当多个线程的ThreadLocalMap的value保存的是同一个对象实例的引用时，线程通过这个引用对对象实例做修改，也同样会影响了其他线程中引用的这个对象实例。显然要避免ThreadLocal线程不安全就应该让每个线程中的ThreadLocal都应该持有一个新的对象。</p>]]></content>
    
    
    <categories>
      
      <category>并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ThreadLocal</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原子操作</title>
    <link href="/blog/2020/07/27/JUC-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/"/>
    <url>/blog/2020/07/27/JUC-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>原子（atom）本意是“不能被进一步分割的最小粒子”，而原子操作（atomic operation）意为”不可被中断的一个或一系列操作” ，不会被线程调度机制打断的操作，这种操作一旦开始，就一直运行到结束。类比于数据库事务，redis的multi。</p><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>Compare And Set（或Compare And Swap），翻译过来就是比较并替换，CAS是利用CPU的多处理能力，实现硬件层面的阻塞，再加上volatile变量的特性即可实现基于原子操作的线程安全。当前的处理器基本都支持CAS指令，只不过每个厂家所实现的算法并不一样。每一个CAS操作过程都包含三个运算符：一个内存地址V，一个期望的值A和一个新值B，操作的时候如果这个地址上存放的值等于这个期望的值A，则将地址上的值赋为新值B，否则将循环这个指令直到成功为止。</p><h3 id="原子操作的三大问题"><a href="#原子操作的三大问题" class="headerlink" title="原子操作的三大问题"></a>原子操作的三大问题</h3><h4 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h4><p>CAS在更新值的时候，需要检查值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。</p><p>ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加1，那么A→B→A就会变成1A→2B→3A。</p><h4 id="循环时间长开销大"><a href="#循环时间长开销大" class="headerlink" title="循环时间长开销大"></a>循环时间长开销大</h4><p>多个线程争夺同一个资源时，如果自旋一直不成功，将会一直占用CPU。</p><p>解决方法：破坏掉死循环，当超过一定时间或者一定次数时退出。或者使用JDK8新增的LongAddr和ConcurrentHashMap类似的方法，当多个线程竞争时将粒度变小，将一个变量拆分为多个变量，达到多个线程访问多个资源的效果，最后再调用sum把它合起来。</p><h4 id="只能保证一个共享变量的原子操作"><a href="#只能保证一个共享变量的原子操作" class="headerlink" title="只能保证一个共享变量的原子操作"></a>只能保证一个共享变量的原子操作</h4><p>CAS指令同时刻只能保证对一个地址的操作是原子的，当同时刻对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法使用，这个时候就可以用锁。还有一个取巧的办法，就是把多个共享变量合并成一个共享变量或者封装为对象来操作。比如，有两个共享变量i＝2，j=a，合并一下ij=2a，然后用CAS来操作ij。从Java 1.5开始，JDK提供了AtomicReference类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行CAS操作。</p><h3 id="基于CAS的原子操作类"><a href="#基于CAS的原子操作类" class="headerlink" title="基于CAS的原子操作类"></a>基于CAS的原子操作类</h3><h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><ul><li><p>AtomicBoolean：以原子更新的方式更新boolean； </p></li><li><p>AtomicInteger：以原子更新的方式更新Integer;</p></li><li><p>AtomicLong：以原子更新的方式更新Long；</p></li></ul><h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><ul><li><p>AtomicReference ： 原子更新引用类型</p></li><li><p>AtomicReferenceFieldUpdater ：原子更新引用类型的字段</p></li><li><p>AtomicMarkableReference ： 原子更新带有标志位的引用类型</p></li></ul><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><ul><li><p>AtomicIntegerArray：原子更新整型数组里的元素。</p></li><li><p>AtomicLongArray：原子更新长整型数组里的元素。</p></li><li><p>AtomicReferenceArray：原子更新引用类型数组里的元素。</p></li></ul><h4 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h4><ul><li><p>AtomicIntegerFieldUpdater：原子更新整型的字段的更新器。</p></li><li><p>AtomicLongFieldUpdater：原子更新长整型字段的更新器。</p></li><li><p>AtomicStampedReference：原子更新带有版本号的引用类型。</p></li></ul><h3 id="相关方法"><a href="#相关方法" class="headerlink" title="相关方法"></a>相关方法</h3><h4 id="更新基本类型"><a href="#更新基本类型" class="headerlink" title="更新基本类型"></a>更新基本类型</h4><p><strong>AtomicInteger</strong></p><ul><li><p>int addAndGet(int delta)：以原子方式将输入的数值与实例中的值相加，并返回结果。</p></li><li><p>Int  (int delta)：返回实例中的值之后，以原子操作与输入的值相加。</p></li><li><p>int getAndIncrement()：返回实例中的值之后以原子方式加1</p></li><li><p>int incrementAndGet()：以原子操作将实例中的值加1之后返回</p></li><li><p>int getAndDecrement()：返回实例中的值之后以原子方式减1</p></li><li><p>int decrementAndGet()：以原子操作将实例中的值减1之后返回</p></li><li><p>int getAndSet(int newValue)：返回实例中的值之后以原子方式设置为newValue的值。</p></li><li><p>boolean compareAndSet(int expect，int update)：如果实例中的值等于expect值，则以原子方式设置为update的值。</p></li></ul><h4 id="更新数组类型"><a href="#更新数组类型" class="headerlink" title="更新数组类型"></a>更新数组类型</h4><p><strong>AtomicIntegerArray</strong></p><p>主要是提供原子的方式更新数组里的整型，其常用方法如下。</p><ul><li><p>int addAndGet(int i，int delta)：以原子方式将输入值与实例中索引i的元素相加后返回。</p></li><li><p>boolean compareAndSet(int i，int expect，int update)：如果实例中索引i的元素等于预期值，则以原子方式将实例中索引i的元素设置成update值。</p></li><li><p>int getAndAccumulate(int i, int x,IntBinaryOperator accumulatorFunction)：将实例中索引i的元素返回之后以原子方式设置为accumulatorFunction中的操作返回的值，accumulatorFunction的left为原始值，left为传入的值。</p></li></ul><p>需要注意的是，AtomicIntegerArray中存储的数组是复制之后的原数组，当使用AtomicIntegerArray对内部的数组元素进行修改时，不会影响原数组。</p><h4 id="更新引用类型"><a href="#更新引用类型" class="headerlink" title="更新引用类型"></a>更新引用类型</h4><p>原子更新基本类型的AtomicInteger，只能更新一个变量，如果要原子更新多个变量，就需要使用这个原子更新引用类型提供的类。Atomic包提供了以下3个类。</p><p><strong>AtomicReference</strong></p><p>原子更新引用类型（不能解决ABA问题）。</p><ul><li>boolean compareAndSet(V expect，V update)：如果实例中对象等于预期值，则以原子方式将实例中对象替换为输入的对象</li></ul><p><strong>AtomicMarkableReference</strong></p><p>可以解决ABA问题，  可以记录更新过程中有没有变化</p><ul><li>AtomicMarkableReference(V initialRef, boolean initialMark)：initialRef（要关联的对象），initialMark（版本戳）</li></ul><p>AtomicStampedReference利用版本戳的形式记录了每次改变以后的版本号，版本戳为boolean类型，可以记录值是否被修改过。</p><p><strong>AtomicStampedReference</strong></p><p>能够解决ABA问题，并且可以记录变化次数</p><ul><li>AtpmicStampedReference(V initialRef,int initialStamp)：构造函数，initialRef（要关联的对象），initialStamp（版本戳）</li><li>V getStamp()：获取当前版本号</li><li>V getReference()：获取当前对象</li><li>boolean compareAndSet(V   expectedReference,V   newReference,int expectedStamp,int newStamp) ：更新当前对象及版本号</li></ul><p>AtomicStampedReference跟AtomicMarkableReference差不多， AtomicStampedReference是使用int类型的值作为版本戳，AtomicMarkableReference使用boolean mark作为版本戳。 </p><h4 id="原子更新字段类"><a href="#原子更新字段类" class="headerlink" title="原子更新字段类"></a>原子更新字段类</h4><p>如果需原子地更新某个类里的某个字段时，就需要使用原子更新字段类，Atomic包提供了以下3个类进行原子字段更新。</p><ul><li><p>AtomicIntegerFieldUpdater：原子更新整型的字段的更新器。</p></li><li><p>AtomicLongFieldUpdater：原子更新长整型字段的更新器。</p></li><li><p>AtomicReferenceFieldUpdater：原子更新引用类型里的字段。</p></li></ul><p>要想原子地更新字段类需要两步。第一步，因为原子更新字段类都是抽象类，每次使用的时候必须使用静态方法newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。第二步，更新类的字段（属性）必须使用public volatile修饰符。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>使用atomic要注意原子性的边界，把握不好会起不到应有的效果，原子性被破坏。</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima;<span class="hljs-keyword">import</span> java.util.Random;<span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BadAtomic</span> </span>&#123;    AtomicInteger i = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">badInc</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">int</span> k = i.incrementAndGet();        <span class="hljs-keyword">try</span> &#123;            Thread.currentThread().sleep(<span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">100</span>));        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        j = k;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        BadAtomic atomic = <span class="hljs-keyword">new</span> BadAtomic();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;                atomic.badInc();            &#125;).start();        &#125;        Thread.sleep(<span class="hljs-number">3000</span>);        System.out.println(atomic.j);    &#125;&#125;</code></pre><p>结果分析：</p><ul><li><p>每次都不一样，总之不是10</p></li><li><p>在badInc上加synchronized，问题解决</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CAS</tag>
      
      <tag>原子操作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>锁</title>
    <link href="/blog/2020/07/27/JUC-%E9%94%81/"/>
    <url>/blog/2020/07/27/JUC-%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>锁是一种互斥的机制，在多线程环境中实现对资源的协调与控制，凡是有资源被多线程共享，涉及到修改的情况就要考虑锁的加持。</p><h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><ol><li>synchronized</li></ol><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inc</span><span class="hljs-params">()</span></span></code></pre><ol start="2"><li>Lock</li></ol><pre><code class="hljs java">Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inc</span><span class="hljs-params">()</span> </span>&#123;  lock.lock();   <span class="hljs-comment">//... </span>  lock.unlock();&#125;</code></pre><p>两者区别在于Lock更加灵活，而且synchronized获取锁时会一直等待直到获取锁为止，Lock提供lockInterruptibly()方法可以在等待获取到锁的过程中能够响应中断，tryLock()方法可以尝试获取锁如果失败会返回false，然后线程可以做其他的事，之后再进行tryLock()，tryLock()方法还可以接收long类型及TimeUnit类型的参数超时的获取锁。</p><p>如果尝试取锁及中断取锁尽量使用synchronized关键字，在目前的发展趋势jdk一直在对synchronized进行优化，synchronized的开销要比Lock接口更少。</p><h3 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h3><h4 id="乐观锁-悲观锁"><a href="#乐观锁-悲观锁" class="headerlink" title="乐观锁/悲观锁"></a>乐观锁/悲观锁</h4><p>乐观锁每次读取数据的时不去加锁。但是在回写的时候对比一下原来的值，查看是否被更改过。适用于读多写少的场景。比如mysql中根据version号更新，以及java中的atomic包中的乐观锁实现，即CAS。</p><p>悲观锁在读取数据时就会加锁，阻塞其他线程，直到这个线程释放锁，适合写操作比较多的场景。比如mysql中的for update，以及synchronized实现的就是悲观锁（1.6之后优化为锁升级机制），悲观锁书写不当很容易影响性能。</p><h4 id="独享锁-共享锁"><a href="#独享锁-共享锁" class="headerlink" title="独享锁/共享锁"></a>独享锁/共享锁</h4><p>独享锁是指该锁一次只能被一个线程所持有，而共享锁是指该锁可被多个线程所持有。</p><p>ReentrantReadWriteLock读写锁就是共享锁的一种，ReentrantReadWriteLock实现了ReadAndWriteLock接口，ReadAndWriteLock接口提供了readLock()方法获取读锁，writeLock()方法获取写锁，读锁和写锁的使用方式与Lock标准用法相同。</p><p>一般情况下，读写锁的性能都会比排它锁好，因为大多数场景读是多于写的，读写的比例约为10:1。在读多于写的情况下，读写锁能够提供比排它锁更好的并发性和吞吐量。</p><ul><li><p>读锁的共享锁可保证并发读是非常高效的，读写，写读 ，写写的过程是互斥的。</p></li><li><p>独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。</p></li></ul><h4 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h4><p>比如JDK1.7中基于分段锁的ConcurrentHashMap，ConcurrentHashMap使用Segment（分段锁）技术，将数据分成一段一段的存储，Segment数组的意义就是将一个大的table分割成多个小的table来进行加锁，Segment数组中每一个元素一把锁，每一个Segment元素存储的是HashEntry数组+链表，这个和HashMap的数据存储结构一样。当访问其中一个段数据被某个线程加锁的时候，其他段的数据也能被其他线程访问，这就使得ConcurrentHashMap不仅保证了线程安全，而且提高了性能。</p><p>但是这也引来一个负面影响：ConcurrentHashMap 定位一个元素的过程需要进行两次Hash操作，第一次 Hash 定位到 Segment，第二次 Hash 定位到元素所在的链表。所以 Hash 的过程比普通的HashMap 要长。</p><img src="/blog/2020/07/27/JUC-%E9%94%81/pic1.png" srcset="/blog/img/loading.gif" class><blockquote><p>JDK1.8ConcurrentHashMap中抛弃了原有的 Segment 分段锁，而采用了 CAS + synchronized 来保证并发安全性。</p></blockquote><h4 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h4><p>可重入锁指的获取到锁后，如果同步块内需要再次获取同一把锁的时候，直接放行，而不是等待。其意义在于防止死锁。前面使用的synchronized 和ReentrantLock 都是可重入锁。</p><p>实现原理实现是通过为每个锁关联一个请求计数器和一个占有它的线程。如果同一个线程再次请求这个锁，计数器将递增，线程退出同步块，计数器值将递减。直到计数器为0锁被释放。</p><p>场景见于父类和子类的锁的重入（调super方法），以及多个加锁方法的嵌套调用。</p><h5 id="父子可重入"><a href="#父子可重入" class="headerlink" title="父子可重入"></a>父子可重入</h5><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ParentLock</span> </span>&#123;    <span class="hljs-keyword">byte</span>[] lock = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">0</span>];    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">synchronized</span> (lock) &#123;            System.out.println(<span class="hljs-string">"f1 from parent"</span>);        &#125;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SonLock</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ParentLock</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">super</span>.lock) &#123;            <span class="hljs-keyword">super</span>.f1();            System.out.println(<span class="hljs-string">"f1 from son"</span>);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SonLock lock = <span class="hljs-keyword">new</span> SonLock();        lock.f1();    &#125;&#125;</code></pre><h5 id="内嵌方法可重入"><a href="#内嵌方法可重入" class="headerlink" title="内嵌方法可重入"></a>内嵌方法可重入</h5><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SonLock</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ParentLock</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">super</span>.lock) &#123;            <span class="hljs-keyword">super</span>.f1();            System.out.println(<span class="hljs-string">"f1 from son"</span>);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SonLock lock = <span class="hljs-keyword">new</span> SonLock();        lock.f1();    &#125;&#125;</code></pre><h4 id="公平锁-非公平锁"><a href="#公平锁-非公平锁" class="headerlink" title="公平锁/非公平锁"></a>公平锁/非公平锁</h4><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><p>公平锁就是在并发环境中，每个线程在获取锁时会先查看此锁维护的等待队列，如果为空，或者当前线程是等待队列的第一个，就占有锁，否则就会加入到等待队列中，直到按照FIFO的规则从队列中取到自己。</p><p>非公平锁与公平锁基本类似，只是在放入队列前先判断当前锁是否被线程持有。如果锁空闲，那么他可以直接抢占，而不需要判断当前队列中是否有等待线程。只有锁被占用的话，才会进入排队。</p><p>ReentrantLock支持创建公平锁和非公平锁（默认），想要实现公平锁，使用new ReentrantLock(true)。</p><h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><p>公平锁的优点是等待锁的线程不会饿死，进入队列规规矩矩的排队，迟早会轮到。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。</p><p>非公平锁的性能要高于公平锁，因为线程有几率不阻塞直接获得锁。ReentrantLock默认使用非公平锁就是基于性能考量。但是非公平锁的缺点是可能引发队列中的线程始终拿不到锁，一直排队被饿死。</p><h5 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h5><p>在jdk1.6之后，对synchronized重量级锁进行了优化，不是直接获取到重量级锁，而是有一个锁膨胀的过程，这样能够在很大程度上减少了同步原语或者操作系统底层互斥量带来的性能性消耗。</p><p>锁有四种级别，按照量级从轻到重分为：无锁、偏向锁、轻量级锁、重量级锁。</p><p>比如A占了锁，B就要阻塞等。但是在操作系统中，阻塞就要存储当前线程状态，唤醒就要再恢复，这个过程是要消耗时间的。如果A使用锁的时间远远小于B被阻塞和挂起的执行时间，那么我们将B挂起阻塞就相当的不合算。于是出现自旋：自旋指的是锁已经被其他线程占用时，当前线程不会被挂起，而是在不停的试图获取锁（可以理解为不停的循环），每循环一次表示一次自旋过程。显然这种操作会消耗CPU时间，但是相比线程下文切换时间要少的时候，自旋划算。</p><p>而偏向锁、轻量锁、重量锁就是围绕如何使得cpu的占用更划算而展开的。</p><p>上面几种锁都是JVM自己内部实现，我们不需要干预，但是可以配置jvm参数开启/关闭自旋锁、偏向锁。</p><p>锁可以升级，但是不能反向降级：偏向锁→轻量级锁→重量级锁。</p><p>无锁争用的时候使用偏向锁，第二个线程到了升级为轻量级锁进行竞争，更多线程时，进入重量级锁阻塞。</p><table><thead><tr><th>锁</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>偏向锁</td><td>加锁和解锁不需要CAS操作，没有额外的性能消耗，和执行非同步方法相比仅存在纳秒级的差距。</td><td>若线程间存在锁竞争，会带来额外的锁撤销的消耗</td><td>只有一个线程访问同步块或者同步方法</td></tr><tr><td>轻量级锁</td><td>竞争的线程不会阻塞，提高了程序的响应速度</td><td>若线程长时间竞争不到锁，自旋会消耗 CPU 性 能</td><td>线程交替执行同步块或者同步方法，追求响应时间，锁占用时间很短，阻塞还不如自旋的场景</td></tr><tr><td>重量级锁</td><td>线程竞争不使用自旋，不会消耗 CPU</td><td>线程阻塞，响应时间缓慢，在多线程下，频繁的获取释放锁，会带来巨大的性能消耗</td><td>追求吞吐量，锁占用时间较长</td></tr></tbody></table><h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>AbstractQuenedSynchronizer抽象的队列式同步器，是一个抽象类，这个类在java.util.concurrent.locks包。是除了java自带的synchronized关键字之外，jdk提供的另外一种锁机制，用来构建锁或者其他同步组件的基础框架，它使用了一个int成员变量表示同步状态，通过内置的队列来完成资源获取线程的排队工作。并发包的大师（Doug Lea）期望它能够成为实现大部分同步需求的基础。</p><p>jdk中使用AQS的线程工具类很多，自旋锁、互斥锁、读锁写锁、信号量、通过类继承关系可以轻松查看：</p><img src="/blog/2020/07/27/JUC-%E9%94%81/pic2.png" srcset="/blog/img/loading.gif" class><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><img src="/blog/2020/07/27/JUC-%E9%94%81/pic3.png" srcset="/blog/img/loading.gif" class><ul><li>AQS使用一个int类型的成员变量state来表示同步状态，当state&gt;0时表示已经获取了锁，当state = 0时表示释放了锁。它提供了三个方法（getState()、setState(int newState)、compareAndSetState(int expect,int update)）来对同步状态state进行操作</li><li>AQS通过内置的FIFO同步队列来完成资源获取线程的排队工作，如果当前线程获取同步状态失败（锁）时，AQS则会将当前线程以及等待状态等信息构造成一个节点（Node）并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，则会把节点中的线程唤醒，使其再次尝试获取同步状态。</li><li>CLH（Craig，Landin，and Hagersten）队列是一个虚拟的双向队列，即不存在队列实例，使用前后节点和指针来实现关联。</li></ul><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><p>AQS使用了模板设计模式。只需要实现指定的锁获取方法即可，内部的机制AQS已帮你封装好。</p><p>需要子类继承AQS，并实现的方法（protected）：</p><table><thead><tr><th align="center">方法名称</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">protected boolean tryAcquire(int arg)</td><td align="center">独占式获取同步状态，实现该方法需要查询当前状态并判断同步状态是否符合预期，然后再进行CAS设置同步状态</td></tr><tr><td align="center">protected boolean tryRelease(int arg)</td><td align="center">独占式释放同步状态，等待获取同步状态的线程将有机会获取同步状态</td></tr><tr><td align="center">protected int tryAcquireShared(int arg)</td><td align="center">共享式获取同步状态，返回大于等于0的值，表示获取成功，反之，获取失败</td></tr><tr><td align="center">protected boolean tryReleaseShared(int arg)</td><td align="center">共享式释放同步状态</td></tr><tr><td align="center">protected boolean isHeldExclusively()</td><td align="center">当前同步器是否在独占模式下被线程占用，一般该方法表示是否被当前线程所独占</td></tr></tbody></table><p>使用时，调用的是父类的方法（public）:</p><p>实现自定义同步组件时，将会调用同步器提供的模板方法，</p><table><thead><tr><th align="center">方法名称</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">void acquire(int arg)</td><td align="center">独占式获取同步状态，如果当前线程获取同步状态成功，则由该方法返回，否则，将会进人同步队列等待，该方法将会调用重写的tryAcquire(int  arg)方法</td></tr><tr><td align="center">void acquireInterruptibly(int arg)</td><td align="center">与acquire(int arg)相同，但是该方法响应中断，当前线程未获取到同步状态而进入同步队列中，如果当前线程被中断，则该方法会抛出InterruptedException并返回</td></tr><tr><td align="center">boolean tryAcquireNanos(int arg,long nanos)</td><td align="center">在acquireInterruptibly(int arg)基础上增加了超时限制，如果当前线程在超时时间内没有获取到同步状态，那么将会返回false.如果获取到了返回true</td></tr><tr><td align="center">void acquireShared(int arg)</td><td align="center">共享式的获取同步状态，如果当前线程未获取到同步状态,将会进人同步队列等待，与独占式获取的主要区别是在同一时刻可以有多个线程获取到同步状态</td></tr><tr><td align="center">void acquireSharedInteruptibly(int arg)</td><td align="center">与acquireShared(int arg)相同，该方法响应中断</td></tr><tr><td align="center">boolean tryAcquireSharedNanos(int arg, long nanos)</td><td align="center">在acquireSharedInterruptibly(int arg)基础上增加了超时限制</td></tr><tr><td align="center">boolean release(int arg)</td><td align="center">独占式的释放同步状态，该方法会在释放同步状态之后，将同步队列中第一个节点包含的线程唤醒</td></tr><tr><td align="center">boolean releaseShared(int arg)</td><td align="center">共享式的释放同步状态</td></tr><tr><td align="center">Collection&lt; Thread&gt; getQueuedThreads()</td><td align="center">获取等待在同步队列上的线程集合</td></tr></tbody></table><p>这些模板方法同步器提供的模板方法基本上分为3类：独占式获取与释放同步状态、共享式获取与释放、同步状态和查询同步队列中的等待线程情况。</p><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.locks.AbstractOwnableSynchronizer;<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractOwnableSynchronizer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-comment">//可共享式获取锁，外部调用，模板模式</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;        <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>) doAcquireShared(arg);    &#125;    <span class="hljs-comment">//需要实现的部分，空protected方法，被上面的对外方法所调用</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();    &#125;    <span class="hljs-comment">//同理，锁的释放，模板模式</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">releaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;        <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;            doReleaseShared();            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();    &#125;    <span class="hljs-comment">//独占式获取</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;        <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();    &#125;    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();    &#125;    <span class="hljs-comment">//独占式释放</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">release</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;        <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;            Node h = head;            <span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>) unparkSuccessor(h);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();    &#125;&#125;</code></pre><h3 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h3><ul><li><p>减少锁的时间 不需要同步执行的代码，能不放在同步快里面执行就不要放在同步快内，可以让锁尽快释放。</p></li><li><p>减少锁的粒度 将物理上的一个锁，拆成逻辑上的多个锁，增加并行度，从而降低锁竞争，典型如分段锁。</p></li><li><p>锁的粒度，拆锁的粒度不能无限拆，最多可以将一个锁拆为当前cup数量相等。</p></li><li><p>减少加减锁的次数 假如有一个循环，循环内的操作需要加锁，我们应该把锁放到循环外面，否则每次进出循环，都要加锁。</p></li><li><p>使用读写锁根据业务细分，读操作加读锁，可以并发读，写操作使用写锁，只能单线程写。</p></li><li><p>善用volatile，volatile的控制比synchronized更轻量化，在某些变量上可以加以运用，如单例模式中。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程池</title>
    <link href="/blog/2020/07/27/JUC-%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <url>/blog/2020/07/27/JUC-%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><h5 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h5><img src="/blog/2020/07/27/JUC-%E7%BA%BF%E7%A8%8B%E6%B1%A0/pic1.png" srcset="/blog/img/loading.gif" class><ul><li><p>NEW：刚刚创建，没做任何操作</p></li><li><p>RUNNABLE：调用run，可以执行，但不代表一定在执行（RUNNING,READY）</p></li><li><p>BLOCKED：取锁失败，等待进入</p></li><li><p>WAITING：等待</p></li><li><p>TIMED_WAITING：超时等待</p></li><li><p>TERMINATED：终止</p></li></ul><h5 id="线程池的基本概念"><a href="#线程池的基本概念" class="headerlink" title="线程池的基本概念"></a>线程池的基本概念</h5><p>根据上面的状态，普通线程执行完，就会进入TERMINATED销毁掉，而线程池就是创建一个缓冲池存放线程，执行结束以后，该线程并不会死亡，而是再次返回线程池中成为空闲状态，等候下次任务来临，这使得线程池比手动创建线程有着更多的优势：</p><ul><li><p>降低系统资源消耗，通过重用已存在的线程，降低线程创建和销毁造成的消耗；</p></li><li><p>提高系统响应速度，当有任务到达时，通过复用已存在的线程，无需等待新线程的创建便能立即执行；</p></li><li><p>方便线程并发数的管控。因为线程若是无限制的创建，可能会导致内存占用过多而产生OOM</p></li><li><p>节省cpu切换线程的时间成本（需要保持当前执行线程的现场，并恢复要执行线程的现场）。</p></li><li><p>提供更强大的功能，延时定时线程池。</p></li></ul><h5 id="线程池类结构"><a href="#线程池类结构" class="headerlink" title="线程池类结构"></a>线程池类结构</h5><img src="/blog/2020/07/27/JUC-%E7%BA%BF%E7%A8%8B%E6%B1%A0/pic2.png" srcset="/blog/img/loading.gif" class><ul><li><p>最常用的是ThreadPoolExecutor</p></li><li><p>调度用ScheduledThreadPoolExecutor</p></li><li><p>Executors是工具类，协助创建线程池的</p></li></ul><h4 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h4><p>任务提交到线程池后，线程池拿到任务，就在内部寻找是否有空闲的线程，如果有，则将任务交给某个空闲的线程。一个线程同时只能执行一个任务，但可以同时向一个线程池提交多个任务。</p><h5 id="线程池的状态"><a href="#线程池的状态" class="headerlink" title="线程池的状态"></a>线程池的状态</h5><ul><li><p>RUNNING：初始化状态是RUNNING。线程池被一旦被创建，就处于RUNNING状态，并且线程<br>池中的任务数为0。RUNNING状态下，能够接收新任务，以及对已添加的任务进行处理。</p></li><li><p>SHUTDOWN：SHUTDOWN状态时，不接收新任务，但能处理已添加的任务。调用线程池的<br>shutdown()接口时，线程池由RUNNING -&gt; SHUTDOWN。</p></li><li><p>STOP：不接收新任务，不处理已添加的任务，并且会中断正在处理的任务。调用线程池的<br>shutdownNow()接口时，线程池由(RUNNING 或 SHUTDOWN ) -&gt; STOP。</p></li><li><p>TIDYING：所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为TIDYING。线程池变为<br>TIDYING状态时，会执行钩子函数terminated()，可以通过重载terminated()函数来实现自定义行<br>为。</p></li><li><p>TERMINATED：线程池处在TIDYING状态时，执行完terminated()之后，就会由 TIDYING -&gt;<br>TERMINATED。</p></li></ul><h5 id="结构说明"><a href="#结构说明" class="headerlink" title="结构说明"></a>结构说明</h5><img src="/blog/2020/07/27/JUC-%E7%BA%BF%E7%A8%8B%E6%B1%A0/pic4.png" srcset="/blog/img/loading.gif" class><ul><li><p>添加任务，如果线程池中线程数没达到corePoolSize，直接创建新线程执行。</p></li><li><p>如果达到corePoolSize，则放入BlockingQueue。</p></li><li><p>如果BlockingQueue已满，未达到maxPoolSize则继续创建线程。</p></li><li><p>如果达到maxPoolSize，则调用调用RejectedExecutionHandler.rejectedExecution()方法。</p></li><li><p>如果线程获取任务超时，则释放线程，直至下降到corePoolSize。</p></li></ul><h5 id="源码剖析"><a href="#源码剖析" class="headerlink" title="源码剖析"></a>源码剖析</h5><pre><code class="hljs java"><span class="hljs-comment">//任务提交阶段：</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable command)</span> </span>&#123;    <span class="hljs-keyword">if</span> (command == <span class="hljs-keyword">null</span>)      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();    <span class="hljs-keyword">int</span> c = ctl.get();    <span class="hljs-comment">//判断工作数，如果小于coreSize，addWork，注意第二个参数core=true</span>    <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;        <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-keyword">true</span>)) <span class="hljs-keyword">return</span>;        c = ctl.get();    &#125;    <span class="hljs-comment">//否则，如果线程池还在运行，offer到队列</span>    <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;        <span class="hljs-comment">//再检查一下状态</span>        <span class="hljs-keyword">int</span> recheck = ctl.get();        <span class="hljs-comment">// 如果线程池已经终止，直接移除任务，不再响应</span>        <span class="hljs-keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))            reject(command);        <span class="hljs-comment">//否则，如果没有线程干活的话，创建一个空work，该work会从队列获取任务去执行</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)            addWorker(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);    &#125;    <span class="hljs-comment">//队列也满，继续调addWork，但是注意，core=false，开启到maxSize的大门</span>    <span class="hljs-comment">//超出max的话，addWork会返回false，进入reject</span>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-keyword">false</span>))        reject(command);&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">//线程创建</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addWorker</span><span class="hljs-params">(Runnable firstTask, <span class="hljs-keyword">boolean</span> core)</span> </span>&#123;    <span class="hljs-comment">//第一步，计数判断，不符合条件打回false retry:</span>    <span class="hljs-keyword">for</span> (;;) &#123;        <span class="hljs-keyword">int</span> c = ctl.get();        <span class="hljs-keyword">int</span> rs = runStateOf(c);        <span class="hljs-comment">// Check if queue empty only if necessary.</span>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; !(rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-keyword">null</span> &amp;&amp; !workQueue.isEmpty()))          <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">for</span> (;;) &#123;            <span class="hljs-keyword">int</span> wc = workerCountOf(c);            <span class="hljs-comment">//判断线程数，注意这里！</span>            <span class="hljs-comment">//也就说明线程池的线程数是不可能设置任意大的。</span>            <span class="hljs-comment">//最大29位（CAPACITY=29位二进制）</span>            <span class="hljs-keyword">if</span> (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize))                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            <span class="hljs-keyword">if</span> (compareAndIncrementWorkerCount(c))                <span class="hljs-keyword">break</span> retry;            c = ctl.get(); <span class="hljs-comment">// Re-read ctl</span>            <span class="hljs-keyword">if</span> (runStateOf(c) != rs)                <span class="hljs-keyword">continue</span> retry;            <span class="hljs-comment">// else CAS failed due to workerCount change; retry inner loop</span>        &#125;    &#125;    <span class="hljs-comment">//第二步，创建新work放入线程集合works（一个HashSet）</span>    <span class="hljs-keyword">boolean</span> workerStarted = <span class="hljs-keyword">false</span>;    <span class="hljs-keyword">boolean</span> workerAdded = <span class="hljs-keyword">false</span>;    Worker w = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">//符合条件，创建新的work并包装task</span>        w = <span class="hljs-keyword">new</span> Worker(firstTask);        <span class="hljs-keyword">final</span> Thread t = w.thread;        <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;            mainLock.lock();            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">// Recheck while holding lock. </span>                <span class="hljs-comment">// Back out on ThreadFactory failure or if </span>                <span class="hljs-comment">// shut down before lock acquired.</span>                <span class="hljs-keyword">int</span> rs = runStateOf(ctl.get());                <span class="hljs-keyword">if</span> (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-keyword">null</span>)) &#123;                    <span class="hljs-keyword">if</span> (t.isAlive())<span class="hljs-comment">// precheck that t is startable</span>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalThreadStateException();                    <span class="hljs-comment">//在这里！！！</span>                    workers.add(w);                    <span class="hljs-keyword">int</span> s = workers.size();                    <span class="hljs-keyword">if</span> (s &gt; largestPoolSize)                        largestPoolSize = s;                    workerAdded = <span class="hljs-keyword">true</span>;                &#125;            &#125; <span class="hljs-keyword">finally</span> &#123;                mainLock.unlock();            &#125;            <span class="hljs-keyword">if</span> (workerAdded) &#123;                <span class="hljs-comment">//注意，只要是成功add了新的work，那么将该新work立即启动，任务得到执行</span>                t.start();                workerStarted = <span class="hljs-keyword">true</span>;            &#125;        &#125;    &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-keyword">if</span> (!workerStarted)            addWorkerFailed(w);    &#125;    <span class="hljs-keyword">return</span> workerStarted;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">//任务获取与执行 </span><span class="hljs-comment">//在worker执行runWorker的时候，会调用getTask，获取任务 </span><span class="hljs-function"><span class="hljs-keyword">private</span> Runnable <span class="hljs-title">getTask</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">boolean</span> timedOut = <span class="hljs-keyword">false</span>; <span class="hljs-comment">// Did the last poll() time out? </span>    <span class="hljs-keyword">for</span> (;;) &#123;        <span class="hljs-keyword">int</span> c = ctl.get();        <span class="hljs-keyword">int</span> rs = runStateOf(c);              <span class="hljs-comment">// Check if queue empty only if necessary. </span>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;            decrementWorkerCount();            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;              <span class="hljs-keyword">int</span> wc = workerCountOf(c);              <span class="hljs-comment">// Are workers subject to culling? </span>        <span class="hljs-comment">//判断是不是要超时处理，重点！！！决定了当前线程要不要被释放</span>        <span class="hljs-keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;        <span class="hljs-comment">//线程数超出max，并且上次循环中poll等待超时了，那么说明该线程已终止 </span>        <span class="hljs-comment">//将线程队列数量原子性减 </span>        <span class="hljs-keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) &amp;&amp; (wc &gt; <span class="hljs-number">1</span> || workQueue.isEmpty())) &#123;            <span class="hljs-keyword">if</span> (compareAndDecrementWorkerCount(c)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//重点！！！ </span>            <span class="hljs-comment">//如果线程可被释放，那就poll，释放的时间为：keepAliveTime </span>            <span class="hljs-comment">//否则，线程是不会被释放的，take一直被阻塞在这里，知道来了新任务继续工作 </span>            Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take();            <span class="hljs-keyword">if</span> (r != <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> r;            <span class="hljs-comment">//到这里说明可被释放的线程等待超时，已经销毁，设置该标记，下次循环将线程数减少 </span>            timedOut = <span class="hljs-keyword">true</span>;        &#125; <span class="hljs-keyword">catch</span> (InterruptedException retry) &#123;            timedOut = <span class="hljs-keyword">false</span>;        &#125;    &#125;&#125;</code></pre><h5 id="完整过程"><a href="#完整过程" class="headerlink" title="完整过程"></a>完整过程</h5><img src="/blog/2020/07/27/JUC-%E7%BA%BF%E7%A8%8B%E6%B1%A0/pic5.png" srcset="/blog/img/loading.gif" class><h4 id="关键机制"><a href="#关键机制" class="headerlink" title="关键机制"></a>关键机制</h4><ul><li>线程池是如何保证线程不被销毁：如果队列中没有任务时，核心线程会一直阻塞在获取任务的方法，直到返回任务。</li><li>线程池中线程的状态：TIMED_WAITING、RUNNABLE、WAITING。</li><li>核心线程与非核心线程：两者并没有区别，只有在addWorker()中进行线程数判断时，区分核心线程数或最大线程数。在getTask()内部，并没有针对性的区分当前work是否是核心线程或者类似的标记。只要判断works数量超出core，就会调用poll()，否则take()。</li></ul><h4 id="构造函数参数含义"><a href="#构造函数参数含义" class="headerlink" title="构造函数参数含义"></a>构造函数参数含义</h4><p>public ThreadPoolExecutor(int <strong>corePoolSize</strong>,int <strong>maximumPoolSize</strong>,long <strong>keepAliveTime</strong>,TimeUnit <strong>unit</strong>,BlockingQueue&lt;Runnable&gt; <strong>workQueue</strong>,ThreadFactory <strong>threadFactory</strong>,RejectedExecutionHandler <strong>handler</strong>)</p><ul><li><p><strong>corePoolSize</strong>：线程池中的核心线程数。当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize；如果当前线程数已经达到corePoolSize，继续提交的任务会被保存到阻塞队列中，等待被执行；如果执行了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程。</p></li><li><p><strong>maximumPoolSize</strong>：线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于maximumPoolSize</p></li><li><p><strong>keepAliveTime</strong>：线程空闲时的存活时间，即当线程没有任务执行时，继续存活的时间。默认情况下，该参数只在线程数大于corePoolSize时才有用</p></li><li><p><strong>unit</strong>：keepAliveTime的时间单位</p></li><li><p><strong>workQueue</strong>：workQueue必须是BlockingQueue阻塞队列，通过workQueue，线程池实现了阻塞功能。当线程池中的线程数超过它的corePoolSize的时候，线程会进入阻塞队列进行阻塞等待。一般来说，我们应该尽量使用有界队列，因为使用无界队列作为工作队列会对线程池带来如下影响：</p><ol><li>当线程池中的线程数达到corePoolSize后，新任务将在无界队列中等待，因此线程池中的线程数不会超过corePoolSize。</li><li>由于1，使用无界队列时maximumPoolSize将是一个无效参数。</li><li>由于1和2，使用无界队列时keepAliveTime将是一个无效参数。</li><li>更重要的，使用无界queue可能会耗尽系统资源，有界队列则有助于防止资源耗尽，同时即使使用有界队列，也要尽量控制队列的大小在一个合适的范围。</li></ol><p>所以我们一般会使用，ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue、PriorityBlockingQueue。</p></li><li><p><strong>threadFactory</strong>：创建线程的工厂，通过自定义的线程工厂可以给每个新建的线程设置一个具有识别度的线程名，当然还可以更加自由的对线程做更多的设置，比如设置所有的线程为守护线程。Executors静态工厂里默认的threadFactory，线程的命名规则是“pool-数字-thread-数字”。</p></li><li><p><strong>handler</strong>：线程池的饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了4种策略：</p><ol><li>AbortPolicy：默认策略直接抛出异常；</li><li>CallerRunsPolicy：用调用者所在的线程来执行任务；</li><li>DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；</li><li>DiscardPolicy：直接丢弃任务；</li></ol><p>当然也可以根据应用场景实现RejectedExecutionHandler接口，自定义饱和策略，如记录日志或持久化存储不能处理的任务。</p></li></ul><h4 id="参数设置建议"><a href="#参数设置建议" class="headerlink" title="参数设置建议"></a>参数设置建议</h4><ul><li><p>corePoolSize</p><p>基本线程数，一旦有任务进来，在core范围内会立刻创建线程进入工作。所以这个值应该参考业务并发量在绝大多数时间内的并发情况。同时分析任务的特性。</p><p>高并发，执行时间短的，要尽可能小的线程数，如配置CPU个数+1，减少线程上下文的切换。因为它不怎么占时间，让少量线程快跑干活。</p><p>并发不高、任务执行时间长的要分开看：如果时间都花在了IO上，那就调大CPU，如配置两倍CPU个数+1。不能让CPU闲下来，线程多了并行处理更快。如果时间都花在了运算上，运算的任务还很重，本身就很占cpu，那尽量减少cpu，减少切换时间。参考第一条</p><p>如果高并发，执行时间还很长<em>……</em></p></li><li><p>workQueue</p><p>任务队列，用于传输和保存等待执行任务的阻塞队列。这个需要根据业务可接受的等待时间。是一个需要权衡时间还是空间的地方，如果机器cpu资源紧张，jvm内存够大，同时任务又不是那么紧迫，减少coresize，加大这里。如果cpu不是问题，对内存比较敏感比较害怕内存溢出，同时任务又要求快点响应。那么减少这里。</p></li><li><p>maximumPoolSize</p><p>线程池最大数量，这个值和队列要搭配使用，如果采用了无界队列，那很大程度上，这个参数没有意义。同时要注意，队列盛满，同时达到max的时候，再来的任务可能会丢失（下面的handler会讲）。</p><p>任务波动较大，同时任务波峰来的时候，实时性要求比较高。也就是来的很突然并且都是着急的。那么调小队列，加大这里。如果任务不那么着急，可以慢慢做，那就扔队列吧。队列与max是一个权衡。队列空间换时间，多花内存少占cpu，轻视任务紧迫度。max舍得cpu线程开销，少占内存，给任务最快的响应。</p></li><li><p>keepaliveTime</p><p>线程存活保持时间，超出该时间后，线程会从max下降到core。如果不缺cpu，同时任务来的时间没法琢磨，波峰波谷的间隔比较短。经常性的来一波。那么实当的延长销毁时间，避免频繁创建和销毁线程带来的开销。如果任务波峰出现后，很长一段时间不再出现，间隔比较久，那么要适当调小该值，让闲着不干活的线程尽快销毁，不要占据资源。</p></li><li><p>threadFactory（自定义展示实例）</p><p>线程工厂，用于创建新线程。threadFactory创建的线程也是采用new Thread()方式，threadFactory创建的线程名都具有统一的风格：pool-m-thread-n（m为线程池的编号，n为线程池内的线程编号）。如果需要定义线程的某些属性，如个性化的线程名，可以在这里动手。一般不需要折腾它。</p></li><li><p>handler</p><p>线程饱和策略，当线程池和队列都满了，再加入线程会执行此策略。默认不处理的话会扔出异常，打进日志。这个与任务处理的数据重要程度有关。如果数据是可丢弃的，那不需要额外处理。如果数据极其重要，那需要在这里采取措施防止数据丢失，如扔消息队列或者至少详细打入日志文件可追踪。</p></li></ul><h4 id="Executors工具"><a href="#Executors工具" class="headerlink" title="Executors工具"></a>Executors工具</h4><p>线程池构造函数比较多，为了方便使用，提供了一个Executors工具类</p><ul><li>newCachedThreadPool() ： 弹性线程数</li><li>newFixedThreadPool(int nThreads) ： 固定线程数</li><li>newSingleThreadExecutor() : 单一线程数</li><li>newScheduledThreadPool(int corePoolSize) ： 可调度，常用于定时</li></ul>]]></content>
    
    
    <categories>
      
      <category>并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并发编程</tag>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程基础</title>
    <link href="/blog/2020/07/27/JUC-%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <url>/blog/2020/07/27/JUC-%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><ul><li><strong>CPU核心和线程数的关系</strong>：核心数比线程数一般为1:1，超线程技术1:2</li><li><strong>CPU时间片轮转机制(RR调度)</strong>：古老、简单、公平、应用最广泛的算法。在时间片用完、线程阻塞、线程完成时会剥夺线程cpu使用权。在进行线程调度时会产生上下文切换，上下文切换时需要保存上个线程在寄存器中的数据，同时载入下个线程的数据，这个步骤大约需要5000-20000个cpu时钟周期。如果线程过多导致上下文切换频繁进行，多线程的效率可能不如单线程。</li><li><strong>进程和线程</strong>：进程是程序进行资源分配的最小单位，一个进程可能会有多个线程会共享这个进程的资源。线程是cpu资源调度的最小单位。</li><li><strong>并行和并发</strong>：并行是指同一时刻的处理能力、并发和事件相关是指在单位时间内处理事件的能力。</li><li><strong>高并发编程的意义、好处和注意事项</strong>：提高资源利用效率，但由于共享资源可能存在冲突、死锁，过多的线程还会造成服务器崩溃。</li></ul><h3 id="Java中的线程"><a href="#Java中的线程" class="headerlink" title="Java中的线程"></a>Java中的线程</h3><p>java中的程序天生就是多线程的，线程间的关系为协作式。可以通过虚拟机的线程管理接口查看当前进行的线程。</p><pre><code class="hljs reasonml">public static void main(String<span class="hljs-literal">[]</span> args) &#123;    ThreadMXBean threadMXBean = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ManagementFactory</span>.</span></span>get<span class="hljs-constructor">ThreadMXBean()</span>;    ThreadInfo<span class="hljs-literal">[]</span> threadInfos=threadMXBean.dump<span class="hljs-constructor">AllThreads(<span class="hljs-params">false</span>, <span class="hljs-params">false</span>)</span>;    for(ThreadInfo threadInfo:threadInfos)&#123;        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">"["</span>+threadInfo.get<span class="hljs-constructor">ThreadId()</span>+<span class="hljs-string">"]"</span>+<span class="hljs-string">" "</span>+threadInfo.get<span class="hljs-constructor">ThreadName()</span>);    &#125;&#125;</code></pre><h4 id="启动线程的方式"><a href="#启动线程的方式" class="headerlink" title="启动线程的方式"></a>启动线程的方式</h4><ol><li>继承Thread类后通过start()方法启动。</li><li>实现Runable接口后通过new Thread(runable).start()启动。</li><li>实现Callable接口之后使用new FutureTask&lt;&gt;(callable)创建task后通过new Thread(task).start()启动，启动后可以通过futureTask的get()方法获取线程返回值，获取返回值时当前线程会阻塞直至task执行结束。</li></ol><p>注：</p><ul><li><p>start()方法会判断线程是否被启动，如果已经被启动会抛出异常。</p></li><li><p>Thread是线程的抽象，Runnable是任务的抽象。</p></li></ul><h4 id="停止线程的方式"><a href="#停止线程的方式" class="headerlink" title="停止线程的方式"></a>停止线程的方式</h4><ol><li>thread中的stop()，resume()，suspend()方法都可以停止线程，但是这三个方法过于强势，stop()无法保证线程资源释放可能导致不可知的错误，suspend()挂起线程时不会释放资源可能导致死锁问题。</li><li>interrupt()可以中断一个线程，并不是强行关闭这个线程，调用interrupt()方法后，讲线程的中断标识为置为true，线程是否停止由线程决定，以此确保每个线程有充足的时间做好后续工作。</li><li>isInterrupted()、interrupted()都可以判断当前线程是否处于中断状态（中断标志位是否为true），但是interrupted()调用之后将中断标识为改为flase。</li><li>如果使用自定义标志位停止线程，如果线程被挂起，标识位的判断就无法进行，但调用interrupt()方法会使中断方法抛出InterruptException，此时可以捕获这个异常，然后进行资源的释放，但要注意抛出异常后interrupt标志位将重新设置为false，如果要中断线程还需要在调用一次interrupt()方法。</li></ol><h4 id="interrupt-的使用示例"><a href="#interrupt-的使用示例" class="headerlink" title="interrupt()的使用示例"></a>interrupt()的使用示例</h4><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> Main &#123;    <span class="hljs-keyword">private</span> static <span class="hljs-keyword">class</span> UserThread extends Thread&#123;        public <span class="hljs-constructor">UserThread(String <span class="hljs-params">name</span>)</span>&#123;            super(name);        &#125;        @Override        public void run<span class="hljs-literal">()</span> &#123;            String threadName=<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>;            <span class="hljs-keyword">while</span>(!is<span class="hljs-constructor">Interrupted()</span>)&#123;                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(threadName);            &#125;            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(threadName+<span class="hljs-string">" interrput flag is "</span>+is<span class="hljs-constructor">Interrupted()</span>);        &#125;    &#125;    <span class="hljs-comment">// 实现Runnable中断的方法</span>    <span class="hljs-keyword">private</span> static <span class="hljs-keyword">class</span> UserThread implements Runnable&#123;        @Override        public void run<span class="hljs-literal">()</span> &#123;            String threadName=<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>;            <span class="hljs-keyword">while</span>(!<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.is<span class="hljs-constructor">Interrupted()</span>)&#123;                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(threadName);            &#125;            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(threadName+<span class="hljs-string">" interrput flag is "</span>+<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.is<span class="hljs-constructor">Interrupted()</span>);        &#125;    &#125;    public static void main(String<span class="hljs-literal">[]</span> args) throws InterruptedException &#123;        Thread endThread=<span class="hljs-keyword">new</span> <span class="hljs-constructor">UserThread(<span class="hljs-string">"endThread"</span>)</span>;        endThread.start<span class="hljs-literal">()</span>;        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>sleep(<span class="hljs-number">20L</span>);        endThread.interrupt<span class="hljs-literal">()</span>;    &#125;&#125;</code></pre><p>当线程处于阻塞状态时调用interrupted方法时会抛出InterruptedExcetion异常时，抛出异常后，线程的中断标识为会被复位为false。</p><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> Main &#123;    <span class="hljs-keyword">private</span> static <span class="hljs-keyword">class</span> UserThread extends Thread &#123;        public <span class="hljs-constructor">UserThread(String <span class="hljs-params">name</span>)</span> &#123;            super(name);        &#125;        @Override        public void run<span class="hljs-literal">()</span> &#123;            String threadName = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>;            <span class="hljs-keyword">while</span> (!is<span class="hljs-constructor">Interrupted()</span>) &#123;                <span class="hljs-keyword">try</span> &#123;                    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>sleep(<span class="hljs-number">100</span>);                &#125; catch (InterruptedException e) &#123;                    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(threadName+<span class="hljs-string">" interrput flag is "</span>+is<span class="hljs-constructor">Interrupted()</span>);                    interrupt<span class="hljs-literal">()</span>;                    e.print<span class="hljs-constructor">StackTrace()</span>;                &#125;                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(threadName);            &#125;            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(threadName+<span class="hljs-string">" interrput flag is "</span>+is<span class="hljs-constructor">Interrupted()</span>);        &#125;    &#125;    public static void main(String<span class="hljs-literal">[]</span> args) throws InterruptedException &#123;        Thread endThread=<span class="hljs-keyword">new</span> <span class="hljs-constructor">UserThread(<span class="hljs-string">"endThread"</span>)</span>;        endThread.start<span class="hljs-literal">()</span>;        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>sleep(<span class="hljs-number">500</span>);        endThread.interrupt<span class="hljs-literal">()</span>;    &#125;&#125;</code></pre><h4 id="线程常用方法和线程的状态"><a href="#线程常用方法和线程的状态" class="headerlink" title="线程常用方法和线程的状态"></a>线程常用方法和线程的状态</h4><img src="/blog/2020/07/27/JUC-%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/pic1.png" srcset="/blog/img/loading.gif" class><ul><li><p>线程处于阻塞态时，系统不会进行资源分配。</p></li><li><p>守护线程大多用来支持程序，可以用线程的setDaemon()方法设置，当用户线程停止后，所有的守护线程也将停止。守护线程大多用于资源管理，当用户线程结束后，作为资源管理的守护线程也就没有必要释放资源。操作系统在判定当前线程被结束时就不会分配资源，但也有可能在终止进程关闭时有一段很短的时间使守护线程执行finally中的方法。 守护线程中的finally不一定会执行，用户线程中的finally一定会执行。</p></li><li><p>线程从阻塞态唤醒时会进入就绪态，等待cpu使用权。</p></li><li><p>interrupt()：改变线程中断标识位，对线程的影响取决于开发者对标志位的处理。</p></li><li><p>yield()：让出当前线程的cpu使用权进入就绪态，并参与下次cpu时间片分配。与sleep()方法的区别在于 sleep()是让出线程资源及cpu使用权进入阻塞态，且不会参与时间片分配直至休眠结束。</p></li><li><p>join()：让出当前线程资源及cpu使用权后进入阻塞态，等待join的线程执行完之后唤醒当前线程。</p></li><li><p>setPriority()：设置线程的优先级但不一定会起作用。范围为1-10，有些系统范围为1-3，优先级是否发挥作用完全由操作系统决定。 通常将需要休眠或者io操作比较多的设置高优先级，计算操作设置低优先级，确保处理器时间不会被计算型的线程占据。</p></li><li><p><strong>run()方法和start()方法</strong>：调用run()方法后，run()方法会被打包为栈帧在当前线程所在栈进行入栈，调用start()方法后，虚拟机会创建新的线程，在新线程中调用run()方法，此时打包后的栈帧会在新线程所在的栈进行入栈。</p></li></ul><h3 id="线程间的共享"><a href="#线程间的共享" class="headerlink" title="线程间的共享"></a>线程间的共享</h3><h4 id="synchronized内置锁"><a href="#synchronized内置锁" class="headerlink" title="synchronized内置锁"></a>synchronized内置锁</h4><p>synchronized可以修饰方法或者设置同步块，确保在同一时刻只有一个线程处于同步方法或者同步块中，保证线程对变量访问的可见性和排它性，又称为内置锁机制。</p><h5 id="实例锁和类锁"><a href="#实例锁和类锁" class="headerlink" title="实例锁和类锁"></a>实例锁和类锁</h5><p>实例锁是加在实例对象上的，实例对象是存储在堆上的，每个实例都有自己的堆内存空间，所以不同实例间的实例锁互不影响。实例锁的用法共有三种：锁住类的非静态变量、锁住this对象、直接在非静态方法上加synchronized。类锁是加在类上的，JVM会为每个类创建类对象，类对象是存储在在方法区的，且整个JVM只有一份，所以类锁所有线程共享的。类锁的用法也有三种：锁住类中的静态变量、直接在静态方法上加 synchronized、锁住 xxx.class。</p><h5 id="错误的加锁和原因分析"><a href="#错误的加锁和原因分析" class="headerlink" title="错误的加锁和原因分析"></a>错误的加锁和原因分析</h5><p>通常是在线程执行过程中，锁住的对象被改变，导致加锁的对象并不是同一个。</p><h4 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h4><p>volatile是<strong>最轻量的同步机制</strong>。volatile保证多个线程对volatile变量的可见性，但不能保证原子性。当一个线程改变了volatile变量的值，改变后的值对其他线程是可见的，但volatile变量在多个线程写的情况下是不安全的，volatile最适用的场景为一写多读。</p><h3 id="线程间的协作"><a href="#线程间的协作" class="headerlink" title="线程间的协作"></a>线程间的协作</h3><p>是指线程之间相互配合，完成某项工作。如一个线程对对象做了初步处理，另一个线程感知到初步处理完成，然后进行下一步的处理。整个过程开始于一个线程，而继续执行又是另一个线程。相对而言，前者是生产者，后者就是消费者，简单的办法是让消费者线程轮询检查变量是否符合预期，如果条件满足则退出循环，从而完成消费者的工作。但如果要确保及时性就要缩短轮询的间隔，就会不可避免的消耗更多资源。</p><h4 id="等待和通知"><a href="#等待和通知" class="headerlink" title="等待和通知"></a>等待和通知</h4><p> 是指一个线程调用Object的wait()方法后，释放占有的资源进入阻塞态，另一个线程调用Object的notify()或者notifyAll()之后阻塞的线程被唤醒，但notify()和notifyAll()不会立即释放锁，而是等待之后的业务代码执行完之后才会释放锁，阻塞的线程被唤醒之后继续执行后续操作。上述两个线程必须通过一个Object进行操作完成交互，而wait()和notify()用来构建等待方和通知方的通信。</p><ul><li><p>notify()：随机通知一个在对象上等待的线程，使其结束wait()。返回的前提是该线程获取到了对象的锁，没有获得锁的线程重新进入阻塞态。</p></li><li><p>notifyAll()：通知所有等待在该对象上的线程。</p></li><li><p>wait()：调用该方法的线程进入阻塞态，调用wait()方法后,会释放对象的锁。</p></li><li><p>wait(long)：设置一个最大等待时长，如果n毫秒之后没有通知，就会自动唤醒等待锁。</p></li><li><p>wait (long,int)：对于超时时间更细粒度的控制，可以达到纳秒。</p></li></ul><h5 id="等待标准范式"><a href="#等待标准范式" class="headerlink" title="等待标准范式"></a>等待标准范式</h5><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(对象)&#123;<span class="hljs-keyword">while</span>(预期不满足)&#123;对象.wait();&#125;&#125;</code></pre><h5 id="通知标准范式"><a href="#通知标准范式" class="headerlink" title="通知标准范式"></a>通知标准范式</h5><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(对象)&#123;<span class="hljs-comment">//业务逻辑，改变条件</span>对象.notify()/notifyAll();&#125;</code></pre><p>在调用wait()、notify()系列方法之前，线程必须要获得该对象的对象级别锁，即只能在同步方法或同步块中调用wait()、notify()。进入wait()方法后，当前线程释放锁，在从wait()返回前，线程与其他线程竞争重新获得锁。执行notify()系列方法的线程退出后，释放对象锁，其他线程就回去竞争对象锁。如果其中一个线程获得了该对象锁，它就会继续往下执行，在它退出synchronized代码块，释放锁后，其他的已经被唤醒的线程将会继续竞争获取该锁，一直进行下去，直到所有被唤醒的线程都执行完毕。</p><h4 id="notify和notifyAll的选择"><a href="#notify和notifyAll的选择" class="headerlink" title="notify和notifyAll的选择"></a>notify和notifyAll的选择</h4><p>尽可能用notifyAll()，谨慎使用notify()，因为notify()只会唤醒一个线程，我们无法确保被唤醒的这个线程一定就是需要唤醒的线程</p><h4 id="调用yield-，sleep-，wait-，notify-notifyAll-方法对锁的影响"><a href="#调用yield-，sleep-，wait-，notify-notifyAll-方法对锁的影响" class="headerlink" title="调用yield()，sleep()，wait()，notify()/notifyAll()方法对锁的影响"></a>调用yield()，sleep()，wait()，notify()/notifyAll()方法对锁的影响</h4><p>yield()调用之后只是让出cpu使用权进入就绪态，sleep()不会释放任何资源包括cpu使用权，所以yield()跟sleep()都不会释放锁，wait()方法被调用之后会释放当前线程所持有的所有资源进入阻塞态，等待唤醒，当线程被唤醒之后会去竞争锁，竞争到锁之后才会去继续执行。notify()也不会释放锁，而是等notify()/notifyAll()所在的同步代码块执行完之后才会释放锁，所以notify()/notifyAll()通常在同步代码块的最后一行。</p><h4 id="等待超时模式实现连接池"><a href="#等待超时模式实现连接池" class="headerlink" title="等待超时模式实现连接池"></a>等待超时模式实现连接池</h4><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.enjoyedu.ch1.pool;<span class="hljs-keyword">import</span> java.sql.Connection;<span class="hljs-keyword">import</span> java.util.LinkedList;<span class="hljs-comment">/**</span><span class="hljs-comment"> *类说明：连接池的实现</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DBPool</span> </span>&#123;    <span class="hljs-comment">/*容器，存放连接*/</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> LinkedList&lt;Connection&gt; pool = <span class="hljs-keyword">new</span> LinkedList&lt;Connection&gt;();    <span class="hljs-comment">/*限制了池的大小=20*/</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DBPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialSize)</span> </span>&#123;        <span class="hljs-keyword">if</span> (initialSize &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; initialSize; i++) &#123;                pool.addLast(SqlConnectImpl.fetchConnection());            &#125;        &#125;    &#125;    <span class="hljs-comment">/*释放连接,通知其他的等待连接的线程*/</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">releaseConnection</span><span class="hljs-params">(Connection connection)</span> </span>&#123;        <span class="hljs-keyword">if</span> (connection != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">synchronized</span> (pool)&#123;                pool.addLast(connection);                <span class="hljs-comment">//通知其他等待连接的线程</span>                pool.notifyAll();            &#125;        &#125;    &#125;    <span class="hljs-comment">/*获取*/</span>    <span class="hljs-comment">// 在mills内无法获取到连接，将会返回null 1S</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Connection <span class="hljs-title">fetchConnection</span><span class="hljs-params">(<span class="hljs-keyword">long</span> mills)</span></span><span class="hljs-function">            <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">synchronized</span> (pool)&#123;            <span class="hljs-comment">//永不超时</span>            <span class="hljs-keyword">if</span>(mills&lt;=<span class="hljs-number">0</span>)&#123;                <span class="hljs-keyword">while</span>(pool.isEmpty())&#123;                    pool.wait();                &#125;                <span class="hljs-keyword">return</span> pool.removeFirst();            &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-comment">/*超时时刻*/</span>                <span class="hljs-keyword">long</span> future = System.currentTimeMillis()+mills;                <span class="hljs-comment">/*等待时长*/</span>                <span class="hljs-keyword">long</span> remaining = mills;                <span class="hljs-keyword">while</span>(pool.isEmpty()&amp;&amp;remaining&gt;<span class="hljs-number">0</span>)&#123;                    pool.wait(remaining);                    <span class="hljs-comment">/*唤醒一次，重新计算等待时长*/</span>                    remaining = future-System.currentTimeMillis();                &#125;                Connection connection = <span class="hljs-keyword">null</span>;                <span class="hljs-keyword">if</span>(!pool.isEmpty())&#123;                    connection = pool.removeFirst();                &#125;                <span class="hljs-keyword">return</span> connection;            &#125;        &#125;    &#125;&#125;</code></pre><p>DBPoolTest.java</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.enjoyedu.ch1.pool;<span class="hljs-keyword">import</span> java.sql.Connection;<span class="hljs-keyword">import</span> java.util.concurrent.CountDownLatch;<span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;<span class="hljs-comment">/**</span><span class="hljs-comment"> *类说明：</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DBPoolTest</span> </span>&#123;    <span class="hljs-keyword">static</span> DBPool pool  = <span class="hljs-keyword">new</span> DBPool(<span class="hljs-number">10</span>);    <span class="hljs-comment">// 控制器:控制main线程将会等待所有Woker结束后才能继续执行</span>    <span class="hljs-keyword">static</span> CountDownLatch end;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    <span class="hljs-comment">// 线程数量</span>        <span class="hljs-keyword">int</span> threadCount = <span class="hljs-number">50</span>;        end = <span class="hljs-keyword">new</span> CountDownLatch(threadCount);        <span class="hljs-keyword">int</span> count = <span class="hljs-number">20</span>;<span class="hljs-comment">//每个线程的操作次数</span>        AtomicInteger got = <span class="hljs-keyword">new</span> AtomicInteger();<span class="hljs-comment">//计数器：统计可以拿到连接的线程</span>        AtomicInteger notGot = <span class="hljs-keyword">new</span> AtomicInteger();<span class="hljs-comment">//计数器：统计没有拿到连接的线程</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; threadCount; i++) &#123;            Thread thread = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Worker(count, got, notGot),             <span class="hljs-string">"worker_"</span>+i);            thread.start();        &#125;        end.await();<span class="hljs-comment">// main线程在此处等待</span>        System.out.println(<span class="hljs-string">"总共尝试了: "</span> + (threadCount * count));        System.out.println(<span class="hljs-string">"拿到连接的次数：  "</span> + got);        System.out.println(<span class="hljs-string">"没能连接的次数： "</span> + notGot);    &#125;    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;        <span class="hljs-keyword">int</span>           count;        AtomicInteger got;        AtomicInteger notGot;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Worker</span><span class="hljs-params">(<span class="hljs-keyword">int</span> count, AtomicInteger got,</span></span><span class="hljs-function"><span class="hljs-params">                               AtomicInteger notGot)</span> </span>&#123;            <span class="hljs-keyword">this</span>.count = count;            <span class="hljs-keyword">this</span>.got = got;            <span class="hljs-keyword">this</span>.notGot = notGot;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">while</span> (count &gt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">try</span> &#123;                    <span class="hljs-comment">// 从线程池中获取连接，如果1000ms内无法获取到，将会返回null</span>                    <span class="hljs-comment">// 分别统计连接获取的数量got和未获取到的数量notGot</span>                    Connection connection = pool.fetchConnection(<span class="hljs-number">1000</span>);                    <span class="hljs-keyword">if</span> (connection != <span class="hljs-keyword">null</span>) &#123;                        <span class="hljs-keyword">try</span> &#123;                            connection.createStatement();<span class="hljs-comment">//                            PreparedStatement preparedStatement</span><span class="hljs-comment">//                                    = connection.prepareStatement("");</span><span class="hljs-comment">//                            preparedStatement.execute();</span>                            connection.commit();                        &#125; <span class="hljs-keyword">finally</span> &#123;                            pool.releaseConnection(connection);                            got.incrementAndGet();                        &#125;                    &#125; <span class="hljs-keyword">else</span> &#123;                        notGot.incrementAndGet();                        System.out.println(Thread.currentThread().getName()                        +<span class="hljs-string">"等待超时!"</span>);                    &#125;                &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;                &#125; <span class="hljs-keyword">finally</span> &#123;                    count--;                &#125;            &#125;            end.countDown();        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线程</tag>
      
      <tag>thread</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LongAdder原子类与Disruptor高速队列</title>
    <link href="/blog/2020/07/24/JDK8-LongAdder%E4%B8%8EDisruptor/"/>
    <url>/blog/2020/07/24/JDK8-LongAdder%E4%B8%8EDisruptor/</url>
    
    <content type="html"><![CDATA[<h3 id="LongAdder"><a href="#LongAdder" class="headerlink" title="LongAdder"></a>LongAdder</h3><p>JDK1.8时，java.util.concurrent.atomic包中提供了一个新的原子类：LongAdder。<br> 根据Oracle官方文档的介绍，LongAdder在高并发的场景下会比它的前辈AtomicLong 具有更好的性能，代价是消耗更多的内存空间。</p><p><strong>AtomicLong</strong>是利用了底层的CAS操作来提供并发性的，调用了<strong>Unsafe</strong>类的<strong>getAndAddLong</strong>方法，该方法是个<strong>native</strong>方法，它的逻辑是采用自旋的方式不断更新目标值，直到更新成功。</p><p>在并发量较低的环境下，线程冲突的概率比较小，自旋的次数不会很多。但是，高并发环境下，N个线程同时进行自旋操作，会出现大量失败并不断自旋的情况，此时<strong>AtomicLong</strong>的自旋会成为瓶颈。</p><p>这就是<strong>LongAdder</strong>引入的初衷——解决高并发环境下<strong>AtomicLong</strong>的自旋瓶颈问题。</p><p><strong>AtomicLong</strong>中有个内部变量<strong>value</strong>保存着实际的long值，所有的操作都是针对该变量进行。也就是说，高并发环境下，value变量其实是一个热点，也就是N个线程竞争一个热点。</p><img src="/blog/2020/07/24/JDK8-LongAdder%E4%B8%8EDisruptor/pic1.png" srcset="/blog/img/loading.gif" class><p><strong>LongAdder</strong>的基本思路就是<strong>分散热点</strong>，将value值分散到一个数组中，不同线程会命中到数组的不同槽中，各个线程只对自己槽中的那个值进行CAS操作，这样热点就被分散了，冲突的概率就小很多。如果要获取真正的long值，只要将各个槽中的变量值累加返回。</p><p>这种做法和ConcurrentHashMap中的“分段锁”其实就是类似的思路。</p><p><strong>LongAdder</strong>提供的API和<strong>AtomicLong</strong>比较接近，两者都能以原子的方式对long型变量进行增减。</p><p>但是<strong>AtomicLong</strong>提供的功能其实更丰富，尤其是<strong>addAndGet</strong>、<strong>decrementAndGet</strong>、<strong>compareAndSet</strong>这些方法。</p><p><strong>addAndGet</strong>、<strong>decrementAndGet</strong>除了单纯的做自增自减外，还可以立即获取增减后的值，而<strong>LongAdder</strong>则需要做同步控制才能精确获取增减后的值。如果业务需求需要精确的控制计数，做计数比较，<strong>AtomicLong</strong>也更合适。</p><p>另外，从空间方面考虑，<strong>LongAdder</strong>其实是一种“空间换时间”的思想，从这一点来讲<strong>AtomicLong</strong>更适合。</p><p>总之，低并发、一般的业务场景下AtomicLong是足够了。如果并发量很多，存在大量写多读少的情况，那LongAdder可能更合适。适合的才是最好的，如果真出现了需要考虑到底用AtomicLong好还是LongAdder的业务场景，那么这样的讨论是没有意义的，因为这种情况下要么进行性能测试，以准确评估在当前业务场景下两者的性能，要么换个思路寻求其它解决方案。</p><p>对于<strong>LongAdder</strong>来说，内部有一个base变量，一个Cell[]数组。</p><p>base变量：非竞态条件下，直接累加到该变量上。</p><p>Cell[]数组：竞态条件下，累加个各个线程自己的槽Cell[i]中。</p><img src="/blog/2020/07/24/JDK8-LongAdder%E4%B8%8EDisruptor/pic2.png" srcset="/blog/img/loading.gif" class><p>所以，最终结果的计算应该是</p><img src="/blog/2020/07/24/JDK8-LongAdder%E4%B8%8EDisruptor/pic3.png" srcset="/blog/img/loading.gif" class><p>在实际运用的时候，只有从未出现过并发冲突的时候，base基数才会使用到，一旦出现了并发冲突，之后所有的操作都只针对Cell[]数组中的单元Cell。</p><img src="/blog/2020/07/24/JDK8-LongAdder%E4%B8%8EDisruptor/pic4.png" srcset="/blog/img/loading.gif" class><p>而LongAdder最终结果的求和，并没有使用全局锁，返回值不是绝对准确的，因为调用这个方法时还有其他线程可能正在进行计数累加，所以只能得到某个时刻的近似值，这也就是<strong>LongAdder</strong>并不能完全替代<strong>LongAtomic</strong>的原因之一。</p><p>而且从测试情况来看，线程数越多，并发操作数越大，LongAdder的优势越大，线程数较小时，AtomicLong的性能还超过了LongAdder。</p><h3 id="其他新增"><a href="#其他新增" class="headerlink" title="其他新增"></a>其他新增</h3><p>除了新引入LongAdder外，还有引入了它的三个兄弟类：<strong>LongAccumulator</strong>、<strong>DoubleAdder</strong>、<strong>DoubleAccumulator</strong>。</p><p>LongAccumulator是LongAdder的增强版。LongAdder只能针对数值的进行加减运算，而LongAccumulator提供了自定义的函数操作。</p><p>通过LongBinaryOperator，可以自定义对入参的任意操作，并返回结果（LongBinaryOperator接收2个long作为参数，并返回1个long）。</p><p>LongAccumulator内部原理和LongAdder几乎完全一样。</p><p>DoubleAdder和DoubleAccumulator用于操作double原始类型。</p><h3 id="Disruptor"><a href="#Disruptor" class="headerlink" title="Disruptor"></a>Disruptor</h3><h4 id="应用背景和介绍"><a href="#应用背景和介绍" class="headerlink" title="应用背景和介绍"></a>应用背景和介绍</h4><p>Disruptor是英国外汇交易公司LMAX开发的一个高性能队列，研发的初衷是解决内部的内存队列的延迟问题，而不是分布式队列。基于Disruptor开发的系统单线程能支撑每秒600万订单，2010年在QCon演讲后，获得了业界关注。</p><p>据目前资料显示：应用Disruptor的知名项目有如下的一些：Storm, Camel, Log4j2,还有目前的美团点评技术团队也有很多不少的应用，或者说有一些借鉴了它的设计机制。 </p><p>Disruptor是一个高性能的线程间异步通信的框架，即在同一个JVM进程中的多线程间消息传递。</p><h4 id="传统队列问题"><a href="#传统队列问题" class="headerlink" title="传统队列问题"></a>传统队列问题</h4><p>在JDK中，Java内部的队列BlockQueue的各种实现，仔细分析可以得知，队列的底层数据结构一般分成三种：数组、链表和堆，堆这里是为了实现带有优先级特性的队列暂且不考虑。 </p><p>在稳定性和性能要求特别高的系统中，为了防止生产者速度过快，导致内存溢出，只能选择有界队列；同时，为了减少Java的垃圾回收对系统性能的影响，会尽量选择 Array格式的数据结构。这样筛选下来，符合条件的队列就只有ArrayBlockingQueue。但是ArrayBlockingQueue是通过<strong>加锁</strong>的方式保证线程安全，而且ArrayBlockingQueue还存在<strong>伪共享</strong>问题，这两个问题严重影响了性能。</p><p>ArrayBlockingQueue的这个伪共享问题存在于哪里呢，分析下核心的部分源码，其中最核心的三个成员变量为</p><img src="/blog/2020/07/24/JDK8-LongAdder%E4%B8%8EDisruptor/pic5.png" srcset="/blog/img/loading.gif" class><p>是在ArrayBlockingQueue的核心enqueue和dequeue方法中经常会用到的，这三个变量很容易放到同一个缓存行中，进而产生伪共享问题。</p><h4 id="高性能的原理"><a href="#高性能的原理" class="headerlink" title="高性能的原理"></a>高性能的原理</h4><ol><li><p>引入环形的数组结构：数组元素不会被回收，避免频繁的GC，</p></li><li><p>无锁的设计：采用CAS无锁方式，保证线程的安全性</p></li><li><p>属性填充：通过添加额外的无用信息，避免伪共享问题</p></li></ol><p>环形数组结构是整个Disruptor的核心所在。 </p><img src="/blog/2020/07/24/JDK8-LongAdder%E4%B8%8EDisruptor/pic6.png" srcset="/blog/img/loading.gif" class><p>首先因为是数组，所以要比链表快，而且根据我们对上面缓存行的解释知道，数组中的一个元素加载，相邻的数组元素也是会被预加载的，因此在这样的结构中，cpu无需时不时去主存加载数组中的下一个元素。而且，你可以为数组预先分配内存，使得数组对象一直存在（除非程序终止）。这就意味着不需要花大量的时间用于垃圾回收。此外，不像链表那样，需要为每一个添加到其上面的对象创造节点对象—对应的，当删除节点时，需要执行相应的内存清理操作。环形数组中的元素采用覆盖方式，避免了jvm的GC。 </p><p>其次结构作为环形，数组的大小为2的n次方，这样元素定位可以通过位运算效率会更高，这个跟一致性哈希中的环形策略有点像。在disruptor中，这个牛逼的环形结构就是RingBuffer，既然是数组，那么就有大小，而且这个大小必须是2的n次方</p><p>其实质只是一个普通的数组，只是当放置数据填充满队列（即到达2^n-1位置）之后，再填充数据，就会从0开始，覆盖之前的数据，于是就相当于一个环。</p><p>每个生产者首先通过CAS竞争获取可以写的空间，然后再进行慢慢往里放数据，如果正好这个时候消费者要消费数据，那么每个消费者都需要获取最大可消费的下标。</p><p>同时，Disruptor 不像传统的队列，分为一个队头指针和一个队尾指针，而是只有一个角标（上图的seq），它属于一个volatile变量，同时也是我们能够不用锁操作就能实现Disruptor的原因之一，而且通过缓存行补充，避免伪共享问题。该指针是通过一直自增的方式来获取下一个可写或者可读数据。</p>]]></content>
    
    
    <categories>
      
      <category>java8新特性</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jdk8</tag>
      
      <tag>LongAdder</tag>
      
      <tag>Disruptor</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>StampedLock锁</title>
    <link href="/blog/2020/07/24/JDK8-StampedLock/"/>
    <url>/blog/2020/07/24/JDK8-StampedLock/</url>
    
    <content type="html"><![CDATA[<h3 id="StampedLock锁"><a href="#StampedLock锁" class="headerlink" title="StampedLock锁"></a>StampedLock锁</h3><p>StampedLock类是在JDK8引入的一把新锁，其是对原有ReentrantReadWriteLock读写锁的增强，增加了一个乐观读模式，内部提供了相关API不仅优化了读锁、写锁的访问，也可以让读锁与写锁间可以互相转换，从而更细粒度的控制并发。 </p><h4 id="ReentrantReadWriteLock回顾"><a href="#ReentrantReadWriteLock回顾" class="headerlink" title="ReentrantReadWriteLock回顾"></a>ReentrantReadWriteLock回顾</h4><p>读写锁适用于读多写少的场景，内部有写锁和读锁。 读锁是一把共享锁，当一个线程持有某一个数据的读锁时，其他线程也可以对这条数据进行读取，但是不能写。写锁是一把独占锁，一个线程持有某一个数据的写锁时，其他线程是不可以获取到这条数据的写锁和读锁的。</p><p>对于锁升级来说，当一个线程在没有释放读锁的情况下，就去申请写锁，是不支持的。对于锁降级来说，当一个线程在没有释放写锁的情况下，去申请读锁，是支持的。 </p><p>另外在使用读写锁时，还容易出现写线程饥饿的问题。主要是因为读锁和写锁互斥。比方说：当线程 A 持有读锁读取数据时，线程 B 要获取写锁修改数据就只能到队列里排队。此时又来了线程 C 读取数据，那么线程 C 就可以获取到读锁，而要执行写操作线程 B 就要等线程 C 释放读锁。由于该场景下读操作远远大于写的操作，此时可能会有很多线程来读取数据而获取到读锁，那么要获取写锁的线程 B 就只能一直等待下去，最终导致饥饿。 </p><p>对于写线程饥饿问题，可以通过公平锁进行一定程度的解决，但是它是以牺牲系统吞吐量为代价的。 </p><h4 id="StampedLock特点"><a href="#StampedLock特点" class="headerlink" title="StampedLock特点"></a>StampedLock特点</h4><ol><li><p>获取锁的方法，会返回一个票据（stamp），当该值为0代表获取锁失败，其他值都代表成功。 </p></li><li><p>释放锁的方法，都需要传递获取锁时返回的票据，从而控制是同一把锁。 </p></li><li><p>StampedLock是不可重入的，如果一个线程已经持有了写锁，再去获取写锁就会造成死锁。 </p></li><li><p>StampedLock提供了三种模式控制读写操作：写锁、悲观读锁、乐观读锁 </p><ul><li><p>写锁：使用类似于ReentrantReadWriteLock，是一把独占锁，当一个线程获取该锁后，其他请求线程会阻塞等待。对于一条数据没有线程持有写锁或悲观读锁时，才可以获取到写锁，获取成功后会返回一个票据，当释放写锁时，需要传递获取锁时得到的票据。 </p></li><li><p>悲观读锁：使用类似于ReentrantReadWriteLock，是一把共享锁，多个线程可以同时持有该锁。当一个数据没有线程获取写锁的情况下，多个线程可以同时获取到悲观读锁，当获取到后会返回一个票据，并且阻塞线程获取写锁。当释放锁时， 需要传递获取锁时得到的票据。 </p></li><li><p>乐观读锁：这把锁是StampedLock新增加的。可以把它理解为是一个悲观锁的弱化版。当没有线程持有写锁时，可以获取乐观读锁，并且返回一个票据。值得注意的是，它认为在获取到乐观读锁后，数据不会发生修改，获取到乐观读锁后，其并不会阻塞写入的操作。 </p><p>那这样的话，它是如何保证数据一致性的呢？ 乐观读锁在获取票据时，会将需要的数据拷贝一份，在真正读取数据时，会调用StampedLock中的API，验证票据是否有效。如果在获取到票据到使用数据这期间，有线程获取到了写锁并修改数据的话，则票据就会失效。 如果验证票据有效性时，当返回true，代表票据仍有效，数据没有被修改过，则直接读取原有数据。当返回flase，代表票据失效，数据被修改过，则重新拷贝最新数据使用。 </p><p>乐观读锁使用与一些很短的只读代码，它可以降低线程之间的锁竞争，从而提高系统吞吐量。但对于读锁获取数据结果必须要进行校验。 </p></li></ul></li><li><p>在StampedLock中读锁和写锁可以相互转换，而在ReentrantReadWriteLock中，写锁可以降级为读锁，而读锁不能升级为写锁。 </p></li></ol><h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><h5 id="实现原理解析"><a href="#实现原理解析" class="headerlink" title="实现原理解析"></a>实现原理解析</h5><h6 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h6><ol><li><p>StampedLock是基于CLH自旋锁实现，锁会维护一个等待线程链表队列，所有没有成功申请到锁的线程都以FIFO的策略记录到队列中，队列中每个节点代表一个线程，节点保存一个标记位，判断当前线程是否已经释放锁。 </p><p>当一个线程试图获取锁时，首先取得当前队列的尾部节点作为其前序节点，并判断前序节点是否已经释放锁，如果前序节点没有释放锁，则当前线程还不能执行，进入自旋等待。如果前序节点已经释放锁，则当前线程执行。 </p></li><li><p>首先需要先了解一些StampedLock类的常量值，方便与后面源码的理解。</p><img src="/blog/2020/07/24/JDK8-StampedLock/pic1.png" srcset="/blog/img/loading.gif" class><p>另外还有两个很重要的属性：state、readerOverFlow </p><pre><code class="hljs angelscript">state: 当前锁的状态，是由写锁占用还是由读锁占用。其中long的倒数第八位是<span class="hljs-number">1</span>，则表示由写锁占用（<span class="hljs-number">0000</span> <span class="hljs-number">0001</span>），前七位由读锁占用(<span class="hljs-number">1</span>‐<span class="hljs-number">126</span>)。 readerOverFlow： 当读锁的数量超过了范围，通过该值进行记录。</code></pre></li><li><p>当实例化StampedLock时，会设置节点状态值为ORIGIN（0000 0000）。</p><img src="/blog/2020/07/24/JDK8-StampedLock/pic2.png" srcset="/blog/img/loading.gif" class></li></ol><h6 id="获取锁过程分析"><a href="#获取锁过程分析" class="headerlink" title="获取锁过程分析"></a>获取锁过程分析</h6><p>假设现在有四个线程：ThreadA获取写锁、ThreadB获取读锁、ThreadC获取读锁、ThreadD获取写锁。</p><ol><li><p>ThreadA获取写锁</p><img src="/blog/2020/07/24/JDK8-StampedLock/pic3.png" srcset="/blog/img/loading.gif" class><p>该方法用于获取写锁，如果当前读锁和写锁都未被使用的话，则获取成功并更新state，返回一个long值，代表当前写锁的票据，如果获取失败，则调用acquireWrite()将写锁放入等待队列中。因为当前还没有任务线程获取到锁，所以ThreadA获取写锁成功。 </p></li><li><p>ThreadB获取读锁</p><img src="/blog/2020/07/24/JDK8-StampedLock/pic4.png" srcset="/blog/img/loading.gif" class><p>该方法用于获取读锁，如果写锁未被占用，则获取成功，返回一个long值，并更新state，如果有写锁存在，则调用<strong>acquireRead()</strong>，将当前线程包装成一个WNODE放入等待队列，线程会被阻塞。 </p><p>因为现在ThreadA已经获取到了写锁并且没有释放，所以ThreadB在获取读锁时，一定会阻塞，被包装成WNode进入等待队列中。 </p><p>在acquireRead()内部会进行两次for循环进行自旋尝试获取锁，每次for循环次数由CPU核数决定，进入到该方法后，首先第一次自旋会尝试获取读锁，获取成功，则直接返回。否则，ThreadB会初始化等待队列，并创建一个WNode，作为队头放入等待队列，其内部模式为写模式，线程对象为null，status为0【初始化】。同时还会将当前线程ThreadB包装为WNode放入等待队列的队尾中，其内部模式为读模式，thread为当前ThreadB对象，status为0。</p><img src="/blog/2020/07/24/JDK8-StampedLock/pic5.png" srcset="/blog/img/loading.gif" class><p>当进入到第二次自旋后，还是先尝试获取读锁，如果仍没有获取到，则将前驱节点的状态设置为-1【WAITING】， 用于代表当前ThreadB已经进入等待阻塞。 </p><img src="/blog/2020/07/24/JDK8-StampedLock/pic6.png" srcset="/blog/img/loading.gif" class></li><li><p>ThreadC获取读锁</p><p>ThreadC在获取读锁时，其过程与ThreadB类似，因为ThreadA的写锁没有释放，ThreadC也会进入等待队列。但与ThreadB不同的是，ThreadC不会占用等待队列中的一个新节点，因为其前面的ThreadB也是一个读节点，它会赋值给用于表达ThreadB的WNode中的cowait属性，实际上构成一个栈。</p><img src="/blog/2020/07/24/JDK8-StampedLock/pic7.png" srcset="/blog/img/loading.gif" class></li><li><p>ThreadD获取写锁</p><p>由于ThreadA的写锁仍然没有释放，当ThreadD调用writeLock()获取写锁时，内部会调用<strong>acquireWrite()</strong></p><img src="/blog/2020/07/24/JDK8-StampedLock/pic8.png" srcset="/blog/img/loading.gif" class><p><strong>acquireWrite()</strong>内部的逻辑和<strong>acquireRead()</strong>类似，也会进行两次自旋。第一次自旋会先尝试获取写锁，获取成功则直接返回，获取失败，则会将当前线程TheadD包装成WNode放入等待队列并移动队尾指针，内部属性模式为写模式，thread为ThreadD对象，status=0【初始化】。</p><img src="/blog/2020/07/24/JDK8-StampedLock/pic9.png" srcset="/blog/img/loading.gif" class><p>当进入到第二次自旋，仍然会尝试获取写锁，如果获取不到，会修改其前驱节点状态为-1【等待】，并阻塞当前线程。</p><img src="/blog/2020/07/24/JDK8-StampedLock/pic10.png" srcset="/blog/img/loading.gif" class></li></ol><h6 id="释放锁过程分析"><a href="#释放锁过程分析" class="headerlink" title="释放锁过程分析"></a>释放锁过程分析</h6><ol><li><p>ThreadA释放写锁</p><p>当要释放写锁时，需要调用<strong>unlockWrite()</strong>，其内部首先会判断，传入的票据与获取锁时得到的票据是否相同，不同的话，则抛出异常。如果相同先修改state，接着调用release()，唤醒等待队列中的队首节点【即头结点whead的后继节点】 </p><img src="/blog/2020/07/24/JDK8-StampedLock/pic11.png" srcset="/blog/img/loading.gif" class><img src="/blog/2020/07/24/JDK8-StampedLock/pic12.png" srcset="/blog/img/loading.gif" class><p>在<strong>release()</strong>中，它会先将头结点whead的状态修改从-1变为0，代表要唤醒其后继节点，接着会判断头结点whead的后继节点是否为null或者其后继节点的状态是否为1【取消】。 如果不是，则直接调用unpark()唤醒队首节点，如果是的话，再从队尾开始查找距离头结点最近的状态&lt;=0【WAITING或初始化】的节点。</p><img src="/blog/2020/07/24/JDK8-StampedLock/pic13.png" srcset="/blog/img/loading.gif" class><p>当ThreadB被唤醒后，它会从cowait中唤醒栈中的所有线程，因为读锁是一把共享锁，允许多线程同时占有。</p><img src="/blog/2020/07/24/JDK8-StampedLock/pic14.png" srcset="/blog/img/loading.gif" class><p>当所有的读锁都被唤醒后，头结点指针会后移，指向ThreadB这个WNode，并将原有的头结点移出等待队列</p><img src="/blog/2020/07/24/JDK8-StampedLock/pic15.png" srcset="/blog/img/loading.gif" class><p>此时ThreadC已经成为了孤立节点，最终会被GC。最终队列结构：</p><img src="/blog/2020/07/24/JDK8-StampedLock/pic16.png" srcset="/blog/img/loading.gif" class></li><li><p>ThreadB和ThreadC释放读锁</p><p>读锁释放需要调用<strong>unlockRead()</strong>，其内部先判断票据是否正确，接着会对读锁数量进行扣减，当读锁数量为0， 会调用release()唤醒队首节点 </p><img src="/blog/2020/07/24/JDK8-StampedLock/pic17.png" srcset="/blog/img/loading.gif" class><p>其内部同样会先将头结点状态从-1该为0，标识要唤醒后继节点</p><img src="/blog/2020/07/24/JDK8-StampedLock/pic18.png" srcset="/blog/img/loading.gif" class><p>当ThreadD被唤醒获取到写锁后，头结点指针会后移指向ThreadD，并原有头部节点移出队列。</p><img src="/blog/2020/07/24/JDK8-StampedLock/pic19.png" srcset="/blog/img/loading.gif" class></li></ol><h5 id="乐观读锁解析"><a href="#乐观读锁解析" class="headerlink" title="乐观读锁解析"></a>乐观读锁解析</h5><p>在ReentrantReadWriteLock中，只有写锁和读锁的概念，但是在读多写少的环境下，容易出现写线程饥饿问题，虽然能够通过公平锁解决，但会造成系统吞吐量降低。 </p><p>乐观读锁只需要获取，不需要释放。在获取时，只要没有线程获取写锁，则可以获取到乐观读锁，同时将共享数据储存到局部变量中。同时在获取到乐观读锁后，并不会阻塞其他线程对共享数据进行修改。 </p><p>因为就会造成当使用共享数据时，出现数据不一致的问题。因为在使用乐观读锁时，要反复的对数据进行校验。</p><img src="/blog/2020/07/24/JDK8-StampedLock/pic20.png" srcset="/blog/img/loading.gif" class><img src="/blog/2020/07/24/JDK8-StampedLock/pic21.png" srcset="/blog/img/loading.gif" class><h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><p>此处引用Oracle官方案例。 </p><p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/StampedLock.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/StampedLock.html</a></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123;    <span class="hljs-comment">//定义共享数据</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> x, y;    <span class="hljs-comment">//实例化锁</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> StampedLock sl = <span class="hljs-keyword">new</span> StampedLock();    <span class="hljs-comment">//写锁案例</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">move</span><span class="hljs-params">(<span class="hljs-keyword">double</span> deltaX, <span class="hljs-keyword">double</span> deltaY)</span> </span>&#123;        <span class="hljs-comment">//获取写锁</span>        <span class="hljs-keyword">long</span> stamp = sl.writeLock();        <span class="hljs-keyword">try</span> &#123;            x += deltaX;            y += deltaY;        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-comment">//释放写锁</span>            sl.unlockWrite(stamp);        &#125;    &#125;    <span class="hljs-comment">//使用乐观读锁案例</span>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">distanceFromOrigin</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">long</span> stamp = sl.tryOptimisticRead();        <span class="hljs-comment">//获得一个乐观读锁</span>        <span class="hljs-keyword">double</span> currentX = x, currentY = y;        <span class="hljs-comment">//将两个字段读入本地局部变量</span>        <span class="hljs-keyword">if</span> (!sl.validate(stamp)) &#123;            <span class="hljs-comment">//检查发出乐观读锁后同时是否有其他写锁发生？</span>            stamp = sl.readLock();            <span class="hljs-comment">//如果有，我们再次获得一个读悲观锁</span>            <span class="hljs-keyword">try</span> &#123;                currentX = x;                <span class="hljs-comment">// 将两个字段读入本地局部变量</span>                currentY = y;                <span class="hljs-comment">// 将两个字段读入本地局部变量</span>            &#125; <span class="hljs-keyword">finally</span> &#123;                sl.unlockRead(stamp);            &#125;        &#125;        <span class="hljs-keyword">return</span> Math.sqrt(currentX * currentX + currentY * currentY);    &#125;    <span class="hljs-comment">//使用悲观读锁并锁升级案例</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">moveIfAtOrigin</span><span class="hljs-params">(<span class="hljs-keyword">double</span> newX, <span class="hljs-keyword">double</span> newY)</span> </span>&#123;        <span class="hljs-comment">// 获取悲观读锁</span>        <span class="hljs-keyword">long</span> stamp = sl.readLock();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">while</span> (x == <span class="hljs-number">0.0</span> &amp;&amp; y == <span class="hljs-number">0.0</span>) &#123;                <span class="hljs-comment">//循环，检查当前状态是否符合</span>                <span class="hljs-comment">// 锁升级，将读锁转为写锁</span>                <span class="hljs-keyword">long</span> ws = sl.tryConvertToWriteLock(stamp);                <span class="hljs-comment">//确认转为写锁是否成功</span>                <span class="hljs-keyword">if</span> (ws != <span class="hljs-number">0L</span>) &#123;                    stamp = ws;                    <span class="hljs-comment">//如果成功 替换票据 </span>                    x = newX;                    <span class="hljs-comment">//进行状态改变 </span>                    y = newY;                    <span class="hljs-comment">//进行状态改变 </span>                    <span class="hljs-keyword">break</span>;                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-comment">//如果不成功 </span>                    sl.unlockRead(stamp);                    <span class="hljs-comment">//显式释放读锁</span>                    stamp = sl.writeLock();                    <span class="hljs-comment">//显式直接进行写锁 然后再通过循环再试</span>                &#125;            &#125;        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-comment">//释放读锁或写锁 </span>            sl.unlock(stamp);        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>java8新特性</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jdk8</tag>
      
      <tag>StampedLock</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CompleTableFuture异步编程</title>
    <link href="/blog/2020/07/24/JDK8-CompleTableFuture/"/>
    <url>/blog/2020/07/24/JDK8-CompleTableFuture/</url>
    
    <content type="html"><![CDATA[<h3 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h3><p>CompletableFuture是Java1.8提供的一个新类，其实现了Future与CompletionStage两个接口。提供了诸多API扩 展功能，可以通过Stream形式简化异步编程的复杂度，同时提供通过回调方式处理计算结果。 </p><h4 id="Future不足"><a href="#Future不足" class="headerlink" title="Future不足"></a>Future不足</h4><p>Future是Java 5添加的类，用来描述一个异步计算的结果。可以使用isDone方法检查计算是否完成，或者使用get阻塞住调用线程，直到计算完成返回结果，你也可以使用cancel方法停止任务的执行。</p><p>虽然Future以及相关使用方法提供了异步执行任务的能力，但是对于结果的获取却是很不方便，只能通过阻塞或者轮询的方式得到任务的结果。阻塞的方式显然和我们的异步编程的初衷相违背，轮询的方式又会耗费无谓的CPU资源，而且也不能及时地得到计算结果，为什么不能用观察者设计模式当计算结果完成及时通知监听者呢？。</p><p>Java的一些框架，比如Netty，自己扩展了Java的 Future接口，提供了addListener等多个扩展方法，Google guava也提供了通用的扩展Future:ListenableFuture、SettableFuture 以及辅助类Futures等,方便异步编程。</p><p>同时Future接口很难直接表述多个Future 结果之间的依赖性。实际开发中，我们经常需要达成以下目的：</p><ul><li><p>将两个异步计算合并为一个——这两个异步计算之间相互独立，同时第二个又依赖于第一个的结果。</p></li><li><p>等待 Future 集合中的所有任务都完成。</p></li><li><p>仅等待 Future集合中最快结束的任务完成（有可能因为它们试图通过不同的方式计算同一个值），并返回它的结果。</p></li><li><p>应对 Future 的完成事件（即当 Future 的完成事件发生时会收到通知，并能使用 Future 计算的结果进行下一步的操作，不只是简单地阻塞等待操作的结果）</p></li></ul><h4 id="异步任务创建"><a href="#异步任务创建" class="headerlink" title="异步任务创建"></a>异步任务创建</h4><p>在CompletableFuture中提供了四个静态方法用于创建异步任务</p><pre><code class="hljs java">runAsync(Runnable runnable)runAsync(Runnable runnable,Executor executor)supplyAsync(Supplier&lt;U&gt; supplier)supplyAsync(Supplier&lt;U&gt; supplier,Executor executor)</code></pre><h5 id="runAsync-源码解析"><a href="#runAsync-源码解析" class="headerlink" title="runAsync()源码解析"></a>runAsync()源码解析</h5><img src="/blog/2020/07/24/JDK8-CompleTableFuture/pic1.png" srcset="/blog/img/loading.gif" class><p>根据源码可知，runAsync()分为一个参数和两个参数，并且其内部都会调用asyncRunStage()。</p><img src="/blog/2020/07/24/JDK8-CompleTableFuture/pic2.png" srcset="/blog/img/loading.gif" class><p>在该方法内部会创建异步任务，并把任务放入线程池中。并且runAsync()是没有返回值的。 </p><p>根据源码可知，当传入Executor会使用指定线程池执行，如果没有传入则使用默认ForkJoinPool.commonPool()执行，值得注意的是，commonPool中都是守护线程，主线程执行完，子线程也就over了。因此建议当任务非常耗时，使用自定义线程池。</p><h5 id="supplyAsync-源码解析"><a href="#supplyAsync-源码解析" class="headerlink" title="supplyAsync()源码解析"></a>supplyAsync()源码解析</h5><img src="/blog/2020/07/24/JDK8-CompleTableFuture/pic3.png" srcset="/blog/img/loading.gif" class><p>根据源码可知，supplyAsync()分为一个参数和两个参数，并且其内部都会调用asyncSupplyStage()。</p><img src="/blog/2020/07/24/JDK8-CompleTableFuture/pic4.png" srcset="/blog/img/loading.gif" class><p>现在可知，其实supplyAsync()与runAsync()内部原理类似，但supplyAsync()有返回值。</p><h4 id="异步计算结果触发回调"><a href="#异步计算结果触发回调" class="headerlink" title="异步计算结果触发回调"></a>异步计算结果触发回调</h4><p>当异步任务结束或者抛出异常时，还要根据结果来完成特定的操作，对于这种需求CompletableFuture也提供了方 法进行实现 </p><pre><code class="hljs reasonml">public CompletableFuture&lt;T&gt; <span class="hljs-keyword">when</span><span class="hljs-constructor">Complete(BiConsumer&lt;? <span class="hljs-params">super</span> T,? <span class="hljs-params">super</span> Throwable&gt; <span class="hljs-params">action</span>)</span>public CompletableFuture&lt;T&gt; <span class="hljs-keyword">when</span><span class="hljs-constructor">CompleteAsync(BiConsumer&lt;? <span class="hljs-params">super</span> T,? <span class="hljs-params">super</span> Throwable&gt; <span class="hljs-params">action</span>)</span>public CompletableFuture&lt;T&gt; <span class="hljs-keyword">when</span><span class="hljs-constructor">CompleteAsync(BiConsumer&lt;? <span class="hljs-params">super</span> T,? <span class="hljs-params">super</span> Throwable&gt; <span class="hljs-params">action</span>, Executor <span class="hljs-params">executor</span>)</span>public CompletableFuture&lt;T&gt; exceptionally(Function&lt;Throwable,? extends T&gt; fn)</code></pre><h5 id="whenComplete-与whenCompleteAsync-使用与源码解析"><a href="#whenComplete-与whenCompleteAsync-使用与源码解析" class="headerlink" title="whenComplete()与whenCompleteAsync()使用与源码解析"></a>whenComplete()与whenCompleteAsync()使用与源码解析</h5><img src="/blog/2020/07/24/JDK8-CompleTableFuture/pic5.png" srcset="/blog/img/loading.gif" class><p>根据源码可知，上述三个方法都会接收BiConsumer并调用uniWhenCompleteStage，BiConsumer用于定义后续处理业务，处理正常计算结果或异常情况。在uniWhenCompleteStage主要用于判断任务执行状态以及构建任务。</p><p>值得注意的一点是，whenComplete是在当前任务线程中继续执行指定的特定处理，而whenCompleteAsync会将 指定的特定交给线程池另开启一个线程来执行。</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.ryhx.drools.test;<span class="hljs-keyword">import</span> java.util.concurrent.CompletableFuture;<span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<span class="hljs-keyword">import</span> java.util.concurrent.Executors;<span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<span class="hljs-keyword">import</span> java.util.function.BiConsumer;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ExecutorService executor = Executors.newFixedThreadPool(<span class="hljs-number">100</span>);        System.out.println(Thread.currentThread().getName());        CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;            <span class="hljs-keyword">try</span> &#123;                System.out.println(<span class="hljs-string">"异步任务线程："</span> + Thread.currentThread().getName());                TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);                System.out.println(<span class="hljs-string">"child run"</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            <span class="hljs-keyword">return</span> <span class="hljs-number">123</span>;        &#125;, executor);        System.out.println(<span class="hljs-string">"main end"</span>);        <span class="hljs-keyword">try</span> &#123;            future.whenComplete(<span class="hljs-keyword">new</span> BiConsumer&lt;Integer, Throwable&gt;() &#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Integer integer, Throwable throwable)</span> </span>&#123;                    System.out.println(<span class="hljs-string">"结果触发任务线程："</span> + Thread.currentThread().getName());                    System.out.println(<span class="hljs-string">"特定任务执行"</span>);                &#125;            &#125;);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;        executor.shutdown();    &#125;&#125;</code></pre><p>执行后结果</p><pre><code class="hljs angelscript">mainmain end异步任务线程：pool<span class="hljs-number">-1</span>-thread<span class="hljs-number">-1</span>child run结果触发任务线程：pool<span class="hljs-number">-1</span>-thread<span class="hljs-number">-1</span>特定任务执行</code></pre><p>根据执行结果可知，异步任务结束后，当使用whenComplete()时，后续的特定处理任务使用的线程与异步任务线程相同。 </p><p>当使用whenCompleteAsync()，并指定线程池后</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.ryhx.drools.test;<span class="hljs-keyword">import</span> java.util.concurrent.CompletableFuture;<span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<span class="hljs-keyword">import</span> java.util.concurrent.Executors;<span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<span class="hljs-keyword">import</span> java.util.function.BiConsumer;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ExecutorService executor = Executors.newFixedThreadPool(<span class="hljs-number">100</span>);        System.out.println(Thread.currentThread().getName());        CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;            <span class="hljs-keyword">try</span> &#123;                System.out.println(<span class="hljs-string">"异步任务线程："</span> + Thread.currentThread().getName());                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);                System.out.println(<span class="hljs-string">"child run"</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            <span class="hljs-keyword">return</span> <span class="hljs-number">123</span>;        &#125;, executor);        System.out.println(<span class="hljs-string">"main end"</span>);        <span class="hljs-keyword">try</span> &#123;            future.whenCompleteAsync(<span class="hljs-keyword">new</span> BiConsumer&lt;Integer, Throwable&gt;() &#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Integer integer, Throwable throwable)</span> </span>&#123;                    System.out.println(<span class="hljs-string">"结果触发任务线程："</span> + Thread.currentThread().getName());                    System.out.println(<span class="hljs-string">"特定任务执行"</span>);                &#125;            &#125;);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;        executor.shutdown();    &#125;&#125;</code></pre><p>运行结果</p><pre><code class="hljs angelscript">mainmain end异步任务线程：pool<span class="hljs-number">-1</span>-thread<span class="hljs-number">-1</span>child run结果触发任务线程：ForkJoinPool.commonPool-worker<span class="hljs-number">-1</span>特定任务执行</code></pre><p>根据结果可知，后续的处理任务在线程池中又开启了一个新的线程进行使用。 </p><h5 id="exceptionally-使用与源码解析"><a href="#exceptionally-使用与源码解析" class="headerlink" title="exceptionally()使用与源码解析"></a>exceptionally()使用与源码解析</h5><p>exceptionally()与上述两个方法类似，都是用于当异步任务结束后，执行特定处理，但不同的是，上述两个方法即可以处理正常的返回结果也可以处理异常，而exceptionally()只对异常进行处理，且其使用的是主线程。</p><img src="/blog/2020/07/24/JDK8-CompleTableFuture/pic6.png" srcset="/blog/img/loading.gif" class><img src="/blog/2020/07/24/JDK8-CompleTableFuture/pic7.png" srcset="/blog/img/loading.gif" class><p>根据源码可知，其内部实现原理与上述两个方法类似，都是判断任务是否执行完，如果执行完构建一个后续任务进行执行。</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.ryhx.drools.test;<span class="hljs-keyword">import</span> java.util.concurrent.CompletableFuture;<span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<span class="hljs-keyword">import</span> java.util.concurrent.Executors;<span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<span class="hljs-keyword">import</span> java.util.function.Function;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ExecutorService executor = Executors.newFixedThreadPool(<span class="hljs-number">100</span>);        System.out.println(Thread.currentThread().getName());        CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;            <span class="hljs-keyword">try</span> &#123;                System.out.println(<span class="hljs-string">"异步任务线程："</span> + Thread.currentThread().getName());                <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;                TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);                System.out.println(<span class="hljs-string">"child run"</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            <span class="hljs-keyword">return</span> <span class="hljs-number">123</span>;        &#125;, executor);        System.out.println(<span class="hljs-string">"main end"</span>);        future.exceptionally(<span class="hljs-keyword">new</span> Function&lt;Throwable, Integer&gt;() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">apply</span><span class="hljs-params">(Throwable throwable)</span> </span>&#123;                System.out.println(<span class="hljs-string">"异常结果触发任务线程："</span> + Thread.currentThread().getName());                System.out.println(<span class="hljs-string">"异步任务执行失败："</span> + throwable.getMessage());                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;            &#125;        &#125;);    &#125;&#125;</code></pre><p>返回结果</p><pre><code class="hljs sql">mainmain <span class="hljs-keyword">end</span>异步任务线程：pool<span class="hljs-number">-1</span>-<span class="hljs-keyword">thread</span><span class="hljs-number">-1</span>异常结果触发任务线程：<span class="hljs-keyword">main</span>异步任务执行失败：java.lang.ArithmeticException: / <span class="hljs-keyword">by</span> zero</code></pre><p>根据返回结果可以看到，当异步任务出现异常之后，whenCompleteAsync与exceptionally都被触发了，但exceptionally使用的是当前主线程。 </p><h4 id="多任务依赖执行"><a href="#多任务依赖执行" class="headerlink" title="多任务依赖执行"></a>多任务依赖执行</h4><p>在异步编程中，有时会涉及到异步任务间存在依赖关系，如第二个任务的执行需要依赖与第一个任务的执行结果。 对于这种需求，CompletableFuture中也提供了方法实现</p><h5 id="thenApply-使用"><a href="#thenApply-使用" class="headerlink" title="thenApply()使用"></a>thenApply()使用</h5><img src="/blog/2020/07/24/JDK8-CompleTableFuture/pic8.png" srcset="/blog/img/loading.gif" class><p>该方法会接收一个Function，用于声明后续要执行的业务，其中T代表上一个方法的执行结果，fn代表当前任务的结果数据类型，最终其会映射到CompletableFuture中的结果数据类型。 </p><p>thenApply()使用与刚才的方法内部实现原理都是类似的，此处重点关注对于该方法的使用</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Random;<span class="hljs-keyword">import</span> java.util.concurrent.CompletableFuture;<span class="hljs-keyword">import</span> java.util.concurrent.ExecutionException;<span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<span class="hljs-keyword">import</span> java.util.concurrent.Executors;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThenApplyDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ExecutorService executor = Executors.newFixedThreadPool(<span class="hljs-number">100</span>);        CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;            <span class="hljs-keyword">int</span> value = <span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">100</span>);            System.out.println(value);            <span class="hljs-keyword">return</span> value;        &#125;, executor).thenApply(value -&gt; &#123;            <span class="hljs-keyword">int</span> result = value * <span class="hljs-number">10</span>;            System.out.println(result);            <span class="hljs-keyword">return</span> result;        &#125;);        <span class="hljs-keyword">try</span> &#123;            Integer result = future.get();            System.out.println(result);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();            future.cancel(<span class="hljs-keyword">true</span>);        &#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;            e.printStackTrace();            future.cancel(<span class="hljs-keyword">true</span>);        &#125; <span class="hljs-keyword">finally</span> &#123;            executor.shutdown();        &#125;    &#125;&#125;</code></pre><p>根据运行结果可以看到，此处通过thenApply()串接了两个任务，第二个方法会在第一个方法执行完成后触发，且第二个方法的执行依赖于第一个方法的执行结果。 </p><h5 id="handle-使用"><a href="#handle-使用" class="headerlink" title="handle()使用"></a>handle()使用</h5><p>handle()的使用效果与thenApply()类似，但不同的是thenApply()只能处理任务的正常返回结果，一旦出现异常则无法进行后续处理。而handle()即可以处理正常结果，也可以处理异常结果。</p><img src="/blog/2020/07/24/JDK8-CompleTableFuture/pic9.png" srcset="/blog/img/loading.gif" class><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Random;<span class="hljs-keyword">import</span> java.util.concurrent.CompletableFuture;<span class="hljs-keyword">import</span> java.util.concurrent.ExecutionException;<span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<span class="hljs-keyword">import</span> java.util.concurrent.Executors;<span class="hljs-keyword">import</span> java.util.function.BiFunction;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThenApplyDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ExecutorService executor = Executors.newFixedThreadPool(<span class="hljs-number">100</span>);        CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;        <span class="hljs-keyword">int</span> value = <span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">100</span>);        <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;        System.out.println(value);        <span class="hljs-keyword">return</span> value; &#125;,executor) .handle(<span class="hljs-keyword">new</span> BiFunction&lt;Integer, Throwable, Integer&gt;() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">apply</span><span class="hljs-params">(Integer integer, Throwable throwable)</span> </span>&#123;                <span class="hljs-keyword">int</span> result = <span class="hljs-number">1</span>;                <span class="hljs-keyword">if</span> (throwable == <span class="hljs-keyword">null</span>) &#123;                    result = integer * <span class="hljs-number">10</span>;                    System.out.println(result);                &#125; <span class="hljs-keyword">else</span> &#123;                    System.out.println(throwable.getMessage());                &#125;                <span class="hljs-keyword">return</span> result;            &#125;        &#125;);        <span class="hljs-keyword">try</span> &#123;            Integer result = future.get();            System.out.println(result);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();            future.cancel(<span class="hljs-keyword">true</span>);        &#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;            e.printStackTrace();            future.cancel(<span class="hljs-keyword">true</span>);        &#125; <span class="hljs-keyword">finally</span> &#123;            executor.shutdown();        &#125;    &#125;&#125;</code></pre><p>根据上述代码的运行可以看到，当第一个任务出现异常后，第二个任务会对该异常进行后续的处理，完成串性操作。</p><h5 id="thenAccept-使用"><a href="#thenAccept-使用" class="headerlink" title="thenAccept()使用"></a>thenAccept()使用</h5><img src="/blog/2020/07/24/JDK8-CompleTableFuture/pic10.png" srcset="/blog/img/loading.gif" class><p>当将多个任务连接起来执行时，有时最终是不需要返回结果，CompletableFuture中也提供了方法实现。 </p><p>thenAccept()使用与上述方法类似，接收任务执行结果，并使用，但其没有结果返回。 </p><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Random;<span class="hljs-keyword">import</span> java.util.concurrent.CompletableFuture;<span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<span class="hljs-keyword">import</span> java.util.concurrent.Executors;<span class="hljs-keyword">import</span> java.util.function.Consumer;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThenAcceptDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ExecutorService executor = Executors.newFixedThreadPool(<span class="hljs-number">100</span>);        CompletableFuture.supplyAsync(() -&gt; &#123;            <span class="hljs-keyword">int</span> value = <span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">100</span>);            System.out.println(value);            <span class="hljs-keyword">return</span> value;        &#125;).thenAcceptAsync(<span class="hljs-keyword">new</span> Consumer&lt;Integer&gt;() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Integer integer)</span> </span>&#123;                System.out.println(<span class="hljs-string">"接收上一个任务结果为："</span> + integer);            &#125;        &#125;, executor);        executor.shutdown();    &#125;&#125;</code></pre><h5 id="thenRun-使用"><a href="#thenRun-使用" class="headerlink" title="thenRun()使用"></a>thenRun()使用</h5><img src="/blog/2020/07/24/JDK8-CompleTableFuture/pic11.png" srcset="/blog/img/loading.gif" class><p>thenRun()与thenAccept()使用基本相同，都是不会进行结果返回，但不同的是，thenRun()不关心方法是否有结果，只要它完成，就会触发其执行。</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Random;<span class="hljs-keyword">import</span> java.util.concurrent.CompletableFuture;<span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<span class="hljs-keyword">import</span> java.util.concurrent.Executors;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThenRunDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number">100</span>);        CompletableFuture.supplyAsync(() -&gt; &#123;            <span class="hljs-keyword">int</span> i = <span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">100</span>);            <span class="hljs-keyword">return</span> i;        &#125;).thenRun(() -&gt; System.out.println(<span class="hljs-string">"run方法执行"</span>));        executorService.shutdown();    &#125;&#125;</code></pre><h4 id="两任务合并执行"><a href="#两任务合并执行" class="headerlink" title="两任务合并执行"></a>两任务合并执行</h4><h5 id="两个任务全部完成触发"><a href="#两个任务全部完成触发" class="headerlink" title="两个任务全部完成触发"></a>两个任务全部完成触发</h5><p>在进行多异步任务执行时，有时不光要让任务之间串联执行，有时还要将多个任务执行结果进行合并处理，CompletableFuture中也提供了一些方法实现。 </p><h6 id="thenCombine-使用"><a href="#thenCombine-使用" class="headerlink" title="thenCombine()使用"></a>thenCombine()使用</h6><p>当两个异步任务都执行完毕后，它可以将两个任务进行合并，获取到两个任务的执行结果，进行合并处理，最后会 有返回值。 </p><img src="/blog/2020/07/24/JDK8-CompleTableFuture/pic12.png" srcset="/blog/img/loading.gif" class><p>根据源码其内部都执行了biApplyStage()</p><img src="/blog/2020/07/24/JDK8-CompleTableFuture/pic13.png" srcset="/blog/img/loading.gif" class><p>内部会判断当前要执行的函数是否为null，或者任务有没有执行完。如果为true，则抛出空指针异常。接着会构建一个新的任务，将任务放入栈中，线程池会为其分配线程让其执行。 </p><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.CompletableFuture;<span class="hljs-keyword">import</span> java.util.concurrent.ExecutionException;<span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<span class="hljs-keyword">import</span> java.util.concurrent.Executors;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThenCombineDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;        ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number">100</span>);        CompletableFuture future1 = CompletableFuture.supplyAsync(() -&gt; &#123;            System.out.println(<span class="hljs-string">"future1："</span> + Thread.currentThread().getName());            <span class="hljs-keyword">return</span> <span class="hljs-string">"hello"</span>;        &#125;, executorService);        CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;            System.out.println(<span class="hljs-string">"future2："</span> + Thread.currentThread().getName());            <span class="hljs-keyword">return</span> <span class="hljs-string">"itheima"</span>;        &#125;, executorService);        CompletableFuture result = future1.thenCombineAsync(future2, (f1, f2) -&gt; &#123;            System.out.println(<span class="hljs-string">"result："</span> + Thread.currentThread().getName());            <span class="hljs-keyword">return</span> f1 + <span class="hljs-string">" "</span> + f2;        &#125;, executorService);        System.out.println(result.get());        executorService.shutdown();    &#125;&#125;</code></pre><p>返回结果</p><pre><code class="hljs angelscript">future1：pool‐<span class="hljs-number">1</span>‐thread‐<span class="hljs-number">1</span> future2：pool‐<span class="hljs-number">1</span>‐thread‐<span class="hljs-number">2</span> result：pool‐<span class="hljs-number">1</span>‐thread‐<span class="hljs-number">3</span> hello itheima</code></pre><p>根据返回结果可以看到，这一系列操作相当于构建了三个异步任务进行执行。</p><h6 id="thenAcceptBoth-使用"><a href="#thenAcceptBoth-使用" class="headerlink" title="thenAcceptBoth()使用"></a>thenAcceptBoth()使用</h6><p>thenAcceptBoth()使用与thenCombine()类似，当两个任务执行完，获取两个任务的结果进行特定处理，但thenAcceptBoth()没有返回值</p><img src="/blog/2020/07/24/JDK8-CompleTableFuture/pic14.png" srcset="/blog/img/loading.gif" class><p>其内部都调用了biAcceptStage()，其内部实现原理与上述方法类似。</p><img src="/blog/2020/07/24/JDK8-CompleTableFuture/pic15.png" srcset="/blog/img/loading.gif" class><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Random;<span class="hljs-keyword">import</span> java.util.concurrent.CompletableFuture;<span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<span class="hljs-keyword">import</span> java.util.concurrent.Executors;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThenAcceptBothDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number">100</span>);        CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;            <span class="hljs-keyword">int</span> f1 = <span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">100</span>);            System.out.println(<span class="hljs-string">"f1 value："</span> + f1);            <span class="hljs-keyword">return</span> f1;        &#125;, executorService);        CompletableFuture&lt;Integer&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;            <span class="hljs-keyword">int</span> f2 = <span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">100</span>);            System.out.println(<span class="hljs-string">"f2 value："</span> + f2);            <span class="hljs-keyword">return</span> f2;        &#125;, executorService);        future1.thenAcceptBoth(future2, (f1, f2) -&gt; System.out.println(f1 + f2));        executorService.shutdown();    &#125;&#125;</code></pre><h6 id="runAfterBoth-使用"><a href="#runAfterBoth-使用" class="headerlink" title="runAfterBoth()使用"></a>runAfterBoth()使用</h6><p>当两个任务执行完毕，触发特定任务处理，但不要两个异步任务结果，且不会进行值返回。</p><img src="/blog/2020/07/24/JDK8-CompleTableFuture/pic16.png" srcset="/blog/img/loading.gif" class><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Random;<span class="hljs-keyword">import</span> java.util.concurrent.CompletableFuture;<span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<span class="hljs-keyword">import</span> java.util.concurrent.Executors;<span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RunAfterBothDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number">100</span>);        CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;            <span class="hljs-keyword">int</span> f1 = <span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">100</span>);            System.out.println(<span class="hljs-string">"f1 value："</span> + f1);            <span class="hljs-keyword">return</span> f1;        &#125;, executorService);        CompletableFuture&lt;Integer&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;            <span class="hljs-keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            <span class="hljs-keyword">int</span> f2 = <span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">100</span>);            System.out.println(<span class="hljs-string">"f2 value："</span> + f2);            <span class="hljs-keyword">return</span> f2;        &#125;, executorService);        future1.runAfterBothAsync(future2, () -&gt; &#123;            System.out.println(<span class="hljs-string">"两个任务都已执行完"</span>);            executorService.shutdown();        &#125;, executorService);    &#125;&#125;</code></pre><h5 id="两个任务任意一个完成触发"><a href="#两个任务任意一个完成触发" class="headerlink" title="两个任务任意一个完成触发"></a>两个任务任意一个完成触发</h5><h6 id="applyToEither-使用"><a href="#applyToEither-使用" class="headerlink" title="applyToEither()使用"></a>applyToEither()使用</h6><p>当两个任务异步任务执行，谁先执行完，就以谁的结果为准，完成后续的业务处理，并且会进行结果值返回。</p><img src="/blog/2020/07/24/JDK8-CompleTableFuture/pic17.png" srcset="/blog/img/loading.gif" class><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.*;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApplyToEitherDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;        ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number">100</span>);        CompletableFuture future1 = CompletableFuture.supplyAsync(() -&gt; &#123;            <span class="hljs-keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.println(<span class="hljs-string">"future1："</span> + Thread.currentThread().getName());            <span class="hljs-keyword">return</span> <span class="hljs-string">"hello"</span>;        &#125;, executorService);        CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;            <span class="hljs-keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.println(<span class="hljs-string">"future2："</span> + Thread.currentThread().getName());            <span class="hljs-keyword">return</span> <span class="hljs-string">"itheima"</span>;        &#125;, executorService);        CompletableFuture result = future1.applyToEitherAsync(future2, (value) -&gt; &#123;            System.out.println(<span class="hljs-string">"result："</span> + Thread.currentThread().getName());            <span class="hljs-keyword">return</span> value;        &#125;, executorService);        System.out.println(result.get());        executorService.shutdown();    &#125;&#125;</code></pre><h6 id="acceptEither-使用"><a href="#acceptEither-使用" class="headerlink" title="acceptEither()使用"></a><strong>acceptEither()</strong>使用</h6><p>acceptEither()的使用效果与applyToEither()类似，但acceptEither()没有返回值</p><img src="/blog/2020/07/24/JDK8-CompleTableFuture/pic18.png" srcset="/blog/img/loading.gif" class><p>其内部调用了orAcceptStage()</p><img src="/blog/2020/07/24/JDK8-CompleTableFuture/pic19.png" srcset="/blog/img/loading.gif" class><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.*;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AcceptEitherDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;        ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number">100</span>);        CompletableFuture future1 = CompletableFuture.supplyAsync(() -&gt; &#123;            <span class="hljs-keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.println(<span class="hljs-string">"future1："</span> + Thread.currentThread().getName());            <span class="hljs-keyword">return</span> <span class="hljs-string">"hello"</span>;        &#125;, executorService);        CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;            <span class="hljs-keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.println(<span class="hljs-string">"future2："</span> + Thread.currentThread().getName());            <span class="hljs-keyword">return</span> <span class="hljs-string">"itheima"</span>;        &#125;, executorService);        future1.acceptEitherAsync(future2, (value) -&gt; &#123;            System.out.println(<span class="hljs-string">"result："</span> + Thread.currentThread().getName());            System.out.println(value);            executorService.shutdown();        &#125;, executorService);    &#125;&#125;</code></pre><h6 id="runAfterEither-使用"><a href="#runAfterEither-使用" class="headerlink" title="runAfterEither()使用"></a>runAfterEither()使用</h6><p>当两个任务执行，只要有一个任务执行完，则触发特定处理执行，无需使用异步任务的执行结果，且特定处理不会进行值的返回。</p><img src="/blog/2020/07/24/JDK8-CompleTableFuture/pic20.png" srcset="/blog/img/loading.gif" class><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.*;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RunAfterEitherDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;        ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number">100</span>);        CompletableFuture future1 = CompletableFuture.supplyAsync(() -&gt; &#123;            <span class="hljs-keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.println(<span class="hljs-string">"future1："</span> + Thread.currentThread().getName());            <span class="hljs-keyword">return</span> <span class="hljs-string">"hello"</span>;        &#125;, executorService);        CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;            <span class="hljs-keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.println(<span class="hljs-string">"future2："</span> + Thread.currentThread().getName());            <span class="hljs-keyword">return</span> <span class="hljs-string">"itheima"</span>;        &#125;, executorService);        future1.runAfterEitherAsync(future2, () -&gt; System.out.println(<span class="hljs-string">"其中一个任务处理完成 了"</span>), executorService);    &#125;&#125;</code></pre><h4 id="多任务组合执行"><a href="#多任务组合执行" class="headerlink" title="多任务组合执行"></a>多任务组合执行</h4><p>刚才的操作异步任务的数量，只能局限在两个，现在如果需要有任意多个异步任务进行组合操作的话，CompletableFuture中也提供了对应方法进行实现</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CompletableFuture&lt;Void&gt; <span class="hljs-title">allOf</span><span class="hljs-params">(CompletableFuture&lt;?&gt;... cfs)</span> </span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CompletableFuture&lt;Object&gt; <span class="hljs-title">anyOf</span><span class="hljs-params">(CompletableFuture&lt;?&gt;... cfs)</span></span></code></pre><h5 id="allOf-使用与源码分析"><a href="#allOf-使用与源码分析" class="headerlink" title="allOf()使用与源码分析"></a><strong>allOf()</strong>使用与源码分析</h5><p>当一个特定业务处理任务的执行需要一组异步任务完成后才能执行的话，就可以通过allOf()实现。适用场景：假设现在有一个Z任务，它的执行需要[A,B,C,D,E,F]这一组异步任务全部执行完才能触发。</p><img src="/blog/2020/07/24/JDK8-CompleTableFuture/pic21.png" srcset="/blog/img/loading.gif" class><p>其内部调用了andTree()，传递任意多个异步任务。其内部会基于二分查找法，将一个数组构建成一个二叉树，并且同时将两个任务添加到栈中执行。</p><img src="/blog/2020/07/24/JDK8-CompleTableFuture/pic22.png" srcset="/blog/img/loading.gif" class><p>判断任务何时添加到栈中，其内部又会调用biRelay()传递两个任务，如果a,b都结束了才继续往下。</p><img src="/blog/2020/07/24/JDK8-CompleTableFuture/pic23.png" srcset="/blog/img/loading.gif" class><p>使用示例如下：</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">import</span> java.util.Random;<span class="hljs-keyword">import</span> java.util.concurrent.*;<span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicReference;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AllOfDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number">100</span>);        CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;            <span class="hljs-keyword">int</span> f1 = <span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">100</span>);            System.out.println(<span class="hljs-string">"f1 value："</span> + f1);            <span class="hljs-keyword">return</span> f1;        &#125;, executorService);        CompletableFuture&lt;Integer&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;            <span class="hljs-keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            <span class="hljs-keyword">int</span> f2 = <span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">100</span>);            System.out.println(<span class="hljs-string">"f2 value："</span> + f2);            <span class="hljs-keyword">return</span> f2;        &#125;, executorService);        CompletableFuture&lt;Integer&gt; future3 = CompletableFuture.supplyAsync(() -&gt; &#123;            <span class="hljs-keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            <span class="hljs-keyword">int</span> f3 = <span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">100</span>);            System.out.println(<span class="hljs-string">"f3 value："</span> + f3);            <span class="hljs-keyword">return</span> f3;        &#125;, executorService);        List&lt;CompletableFuture&lt;Integer&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        list.add(future1);        list.add(future2);        list.add(future3);        CompletableFuture&lt;Void&gt; all = CompletableFuture.allOf(list.toArray(<span class="hljs-keyword">new</span> CompletableFuture[]&#123;&#125;));        all.thenRunAsync(() -&gt; &#123;            AtomicReference&lt;Integer&gt; result = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;(<span class="hljs-number">0</span>);            list.parallelStream().forEach(future -&gt; &#123;                <span class="hljs-keyword">try</span> &#123;                    Integer value = future.get();                    result.updateAndGet(v -&gt; v + value);                    System.out.println(result);                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;                    e.printStackTrace();                &#125;            &#125;);        &#125;);    &#125;&#125;</code></pre><h5 id="anyOf-使用与源码分析"><a href="#anyOf-使用与源码分析" class="headerlink" title="anyOf()使用与源码分析"></a>anyOf()使用与源码分析</h5><p>anyOf()与allOf()类似，但不同的是，使用anyOf()时，当一组异步任务中，只要有一个执行完毕，则会被触发，利用该特性可以用来获取最快的那个线程结果。 </p><p>其内部实现原理与allOf()都是一样的，内部也会基于二分查找构建一个二叉树。</p><img src="/blog/2020/07/24/JDK8-CompleTableFuture/pic24.png" srcset="/blog/img/loading.gif" class><img src="/blog/2020/07/24/JDK8-CompleTableFuture/pic25.png" srcset="/blog/img/loading.gif" class><p>使用示例如下：</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">import</span> java.util.Random;<span class="hljs-keyword">import</span> java.util.concurrent.*;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnyOfDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number">100</span>);        CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;            <span class="hljs-keyword">int</span> f1 = <span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">100</span>);            System.out.println(<span class="hljs-string">"f1 value："</span> + f1);            <span class="hljs-keyword">return</span> f1;        &#125;, executorService);        CompletableFuture&lt;Integer&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;            <span class="hljs-keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            <span class="hljs-keyword">int</span> f2 = <span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">100</span>);            System.out.println(<span class="hljs-string">"f2 value："</span> + f2);            <span class="hljs-keyword">return</span> f2;        &#125;, executorService);        CompletableFuture&lt;Integer&gt; future3 = CompletableFuture.supplyAsync(() -&gt; &#123;            <span class="hljs-keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            <span class="hljs-keyword">int</span> f3 = <span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">100</span>);            System.out.println(<span class="hljs-string">"f3 value："</span> + f3);            <span class="hljs-keyword">return</span> f3;        &#125;, executorService);        List&lt;CompletableFuture&lt;Integer&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        list.add(future1);        list.add(future2);        list.add(future3);        CompletableFuture&lt;Object&gt; future = CompletableFuture.anyOf(list.toArray(<span class="hljs-keyword">new</span> CompletableFuture[]&#123;&#125;));        future.thenRunAsync(() -&gt; &#123;            <span class="hljs-keyword">try</span> &#123;                System.out.println(<span class="hljs-string">"有一个任务执行完了，其值为:"</span> + future.get());            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;                e.printStackTrace();            &#125;        &#125;);        executorService.shutdown();    &#125;&#125;</code></pre><p>运行结果</p><pre><code class="hljs angelscript">f1 value：<span class="hljs-number">84</span>有一个任务执行完了，其值为:<span class="hljs-number">84</span>f2 value：<span class="hljs-number">87</span>f3 value：<span class="hljs-number">88</span></code></pre><h4 id="获得结果的方法"><a href="#获得结果的方法" class="headerlink" title="获得结果的方法"></a>获得结果的方法</h4><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getNow</span><span class="hljs-params">(T valueIfAbsent)</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">join</span><span class="hljs-params">()</span></span></code></pre><p>getNow有点特殊，如果结果已经计算完则返回结果或者抛出异常，否则返回给定的valueIfAbsent值。</p><p>join返回计算的结果或者抛出一个unchecked异常(CompletionException)，它和get对抛出的异常的处理有些细微的区别。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ol><li><p>当一个操作需要依赖与一个或多个比较耗时的操作时，可以通过异步任务改善程序性能，加快响应速度。 </p></li><li><p>在功能实现时，根据当前需求，应该尽量的使用异步API。 </p></li><li><p>将同步API封装到CompletableFuture，以异步形式执行。 </p></li><li><p>结合自身业务确定异步任务何时结束，是全部执行完毕还是只要有一个首先完成就结束。 </p></li><li><p>CompletableFuture提供了回调操作，当任务执行完毕可以通过回调触发后续特定任务处理。 </p></li></ol>]]></content>
    
    
    <categories>
      
      <category>java8新特性</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jdk8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Stream流的使用</title>
    <link href="/blog/2020/07/24/JDK8-Stream%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/blog/2020/07/24/JDK8-Stream%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>流操作是Java8提供一个重要新特性，它允许开发人员以声明性方式处理集合，其核心类库主要改进了对集合类的API和新增Stream操作。Stream类中每一个方法都对应集合上的一种操作。将真正的函数式编程引入到Java中，能让代码更加简洁，极大地简化了集合的处理操作，提高了开发的效率和生产力。 </p><p>同时<strong>stream</strong>不是一种数据结构，它只是某种数据源的一个视图，数据源可以是一个数组，<strong>Java</strong>容器或<strong>I/O</strong>、<strong>channel</strong>等。在<strong>Stream</strong>中的操作每一次都会产生新的流，内部不会像普通集合操作一样立刻获取值，而是惰性取值，只有等到用户真正需要结果的时候才会执行。 </p><h3 id="实现思想"><a href="#实现思想" class="headerlink" title="实现思想"></a>实现思想</h3><p>Stream流以更高层次的抽象思想，完成了对于集合的复杂操作，将集合的操作由外部迭代转换为了内部迭代。 </p><ul><li>外部迭代：在java8之前，在使用集合时，无非就是在集合上进行迭代，然后处理每一个元素。所有的集合迭代所及都是在我们自己编写的代码中，所以这种显式的方式称之为外部迭代。主要关注于数据本身。并且一般都是串行的。</li><li>内部迭代：内部迭代所操作的就是不是一个集合了，而是一个流。它会将所有的操作融合在流中，由其在内部进行处理，这种隐式的方式称之为内部迭代。并且内部迭代支持并行处理，更利于集合操作的性能优化。其关注与对数据的操作。 </li></ul><h3 id="流操作详解"><a href="#流操作详解" class="headerlink" title="流操作详解"></a>流操作详解</h3><p>Stream流接口中定义了许多对于集合的操作方法，总的来说可以分为两大类：中间操作和终端操作。 </p><ul><li><p>中间操作：会返回一个流，通过这种方式可以将多个中间操作连接起来，形成一个调用链，从而转换为另外一个流。除非调用链最后存在一个终端操作，否则中间操作对流不会进行任何结果处理。 </p></li><li><p>终端操作：会返回一个具体的结果，如boolean、list、integer等。</p></li></ul><h4 id="筛选"><a href="#筛选" class="headerlink" title="筛选"></a>筛选</h4><p>对于集合的操作，经常性的会涉及到对于集中符合条件的数据筛选，Stream中对于数据筛选两个常见的API： filter(过滤)、distinct(去重) </p><p>filter：该方法会接收一个返回boolean的函数作为参数，最终返回一个包括所有符合条件元素的流。</p><pre><code class="hljs java">List&lt;Student&gt; list = studentList.stream().filter(Student::getIsPass).collect(Collectors.toList());</code></pre><p>distinct：基于LinkedHashSet对流中数据进行去重，在进行复杂对象的去重时，需要重写hashCode()及equals()方法</p><pre><code class="hljs java">List&lt;Integer&gt; result = numberList.stream().filter(n ‐&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).distinct().collect(Collectors.toList());</code></pre><h4 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h4><p>可以基于limit()实现数据截取，该方法会返回一个不超过给定长度的流。 </p><pre><code class="hljs java">List&lt;Integer&gt; collect = numberList.stream().limit(<span class="hljs-number">5</span>).collect(Collectors.toList());</code></pre><p>基于skip()实现数据跳过</p><pre><code class="hljs java">List&lt;Integer&gt; collect = numberList.stream().limit(<span class="hljs-number">5</span>).skip(<span class="hljs-number">2</span>).collect(Collectors.toList());</code></pre><h4 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h4><p>map()可以对选择性的提取集合中对象的某些元素</p><pre><code class="hljs java">List&lt;String&gt; nameList = studentList.stream().map(Student::getName).collect(Collectors.toList());</code></pre><h4 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h4><p>anyMatch、allMatch可以判断集合中某些元素是否匹配对应的条件。</p><p>anyMatch()主要用于判断流中是否至少存在一个符合条件的元素，它会返回一个boolean值，并且对于它的操作， 一般叫做短路求值 。当流中只要有一个符合条件的元素，则会立刻中止后续的操作，立即返回一个布尔值，无需遍历整个流。 </p><pre><code class="hljs java"><span class="hljs-keyword">boolean</span> result = studentList.stream().anyMatch(s‐&gt;s.getAge()&lt;<span class="hljs-number">20</span>;</code></pre><p>allMatch()的工作原理与anyMatch()类似，但是anyMatch执行时，只要流中有一个元素符合条件就会返回true，而allMatch会判断流中是否所有条件都符合条件，全部符合才会返回true。 </p><pre><code class="hljs java"><span class="hljs-keyword">boolean</span> result = studentList.stream().allMatch(Student::getIsPass);</code></pre><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><p>findAny()和findFirst()可以与其他流操作组合使用，findAny用于获取流中随机的某一个元素，findFirst用于获取流中的第一个元素。</p><p>findAny用于获取流中随机的某一个元素，并且利用短路在找到结果时，立即结束。</p><pre><code class="hljs java">Optional&lt;Student&gt; optional = studentList.stream().filter(s ‐&gt; s.getAge() &lt; <span class="hljs-number">20</span>).findAny();</code></pre><blockquote><p>findAny对于同一数据源的多次操作会返回不同的结果。但是，串行操作在数据较少的情况下，一般会返回第一个结果，但是如果在并行的情况下，那就不能确保返回的是第一个。这种设计主要是为了获取更加高效的性能。</p></blockquote><p>findFirst使用原理与findAny类似，但不管是在并行还是串行，指定返回流中的第一个元素。</p><pre><code class="hljs fortran"><span class="hljs-keyword">Optional</span>&lt;Student&gt; <span class="hljs-keyword">optional</span> = studentList.stream().filter(s ‐&gt; s.getAge() &lt; <span class="hljs-number">20</span>).findFirst();</code></pre><h4 id="归约"><a href="#归约" class="headerlink" title="归约"></a>归约</h4><p>在集合操作中，经常会涉及对元素进行统计计算之类的操作，如求和、求最大值、最小值等，从而返回不同的数据结果。 </p><p>基于<strong>reduce()</strong>进行累积求和</p><pre><code class="hljs java">Integer reduce = numbers.stream().reduce(<span class="hljs-number">0</span>, (a, b) ‐&gt; a + b);</code></pre><p>上述代码中，在reduce里的第一个参数声明为初始值，第二个参数接收一个lambda表达式，代表当前流中的两个元素，它会反复相加每一个元素，直到流被归约成一个最终结果。</p><p>reduce()的重载方法可以不传入初始值，使用Integer类中的sum()方法再次优化</p><pre><code class="hljs java">Integer reduce = numbers.stream().reduce(Integer::sum);</code></pre><p>Integer除了提供sum()外，还提供了其他的操作，如获取最大值，获取最小值等。</p><pre><code class="hljs java">Optional&lt;Integer&gt; optional = numbers.stream().reduce(Integer::max);</code></pre><p>stream中同样也提供了获取最大值的方法</p><pre><code class="hljs java">Optional&lt;Integer&gt; optional = numbers.stream().max(Integer::compareTo);</code></pre><p>获取最小值</p><pre><code class="hljs java">Optional&lt;Integer&gt; min = numbers.stream().min(Integer::compareTo);</code></pre><h3 id="流的构建"><a href="#流的构建" class="headerlink" title="流的构建"></a>流的构建</h3><p>流可以基于值、数组甚至文件构建。</p><h4 id="基于值构建"><a href="#基于值构建" class="headerlink" title="基于值构建"></a>基于值构建</h4><pre><code class="hljs java">Stream&lt;String&gt; stringStream = Stream.of(<span class="hljs-string">"1"</span>, <span class="hljs-string">"2"</span>, <span class="hljs-string">"3"</span>);Stream&lt;Object&gt; stream = Stream.of(<span class="hljs-string">"1"</span>, <span class="hljs-string">"2"</span>, <span class="hljs-number">3</span>,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">new</span> St());</code></pre><h4 id="基于数组创建流"><a href="#基于数组创建流" class="headerlink" title="基于数组创建流"></a>基于数组创建流</h4><pre><code class="hljs java">Integer[] numbers = <span class="hljs-keyword">new</span> Integer[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;;Stream&lt;Integer&gt; integerStream = Arrays.stream(numbers);</code></pre><h4 id="基于文件创建流"><a href="#基于文件创建流" class="headerlink" title="基于文件创建流"></a>基于文件创建流</h4><pre><code class="hljs java">Files.list(Paths.get(<span class="hljs-string">"D:\\workspace\\itheima\\course‐JDK8\\demo"</span>)).forEach(path ‐&gt; &#123;<span class="hljs-keyword">try</span> &#123;System.out.println(path);  <span class="hljs-comment">//读取每一个文件中的内容</span>  Files.lines(path).forEach(content‐&gt; System.out.println(content));   &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;  e.printStackTrace();   &#125;   &#125;);</code></pre><h3 id="收集器"><a href="#收集器" class="headerlink" title="收集器"></a>收集器</h3><p>通过收集器可以实现一些复杂的数据返回，比如返回一个Map或者List。 </p><p>通过使用收集器，可以让代码更加方便的进行简化与重用。其内部主要核心是通过Collectors完成更加复杂的计算转换，从而获取到最终结果。Collectors内部提供了很多的常用静态方法，如toList。</p><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><h5 id="toList-toSet"><a href="#toList-toSet" class="headerlink" title="toList()/toSet()"></a>toList()/toSet()</h5><p>将流中的元素放置到一个List或Set中去。这个列表默认为ArrayList/HashSet。</p><h5 id="通过toMap-获取一个map"><a href="#通过toMap-获取一个map" class="headerlink" title="通过toMap()获取一个map"></a>通过toMap()获取一个map</h5><p>toMap()方法是根据给定的键生成器和值生成器生成的键和值保存到一个map中返回，键和值的生成都依赖于元素，可以指定出现重复键时的处理方案和保存结果的map。</p><pre><code class="hljs java">Map&lt;String,String&gt; map = list.stream().limit(<span class="hljs-number">3</span>).collect(Collectors.toMap(e -&gt; e.substring(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>),e -&gt; e));<span class="hljs-comment">// 指定冲突时的处理方案</span>Map&lt;String,String&gt; map1 = list.stream().collect(Collectors.toMap(e -&gt; e.substring(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>),e-&gt;e,(a,b)-&gt; b));<span class="hljs-comment">// 指定保存结果的map</span>Map&lt;String,String&gt; map2 = list.stream().collect(Collectors.toMap(e -&gt; e.substring(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>),e-&gt;e,(a,b)-&gt; b,HashMap::<span class="hljs-keyword">new</span>));</code></pre><h5 id="通过counting-统计集合总数"><a href="#通过counting-统计集合总数" class="headerlink" title="通过counting()统计集合总数"></a>通过counting()统计集合总数</h5><pre><code class="hljs java">Long collect = studentList.stream().collect(Collectors.counting());</code></pre><p>简写</p><pre><code class="hljs java"><span class="hljs-keyword">long</span> count = studentList.stream().count();</code></pre><h5 id="通过maxBy-与minBy-获取最大值最小值"><a href="#通过maxBy-与minBy-获取最大值最小值" class="headerlink" title="通过maxBy()与minBy()获取最大值最小值"></a>通过maxBy()与minBy()获取最大值最小值</h5><pre><code class="hljs java">Optional&lt;Student&gt; optional = studentList.stream().collect(Collectors.maxBy(Comparator.comparing(Student::getAge)));</code></pre><p>简写</p><pre><code class="hljs java">Optional&lt;Student&gt; studentOptional = studentList.stream().max(Comparator.comparing(Student::getAge));</code></pre><blockquote><p>同样，获取最小值可以使用min()实现</p></blockquote><h5 id="通过summingInt-summingLong-summingDouble进行数据汇总"><a href="#通过summingInt-summingLong-summingDouble进行数据汇总" class="headerlink" title="通过summingInt/summingLong/summingDouble进行数据汇总"></a>通过summingInt/summingLong/summingDouble进行数据汇总</h5><pre><code class="hljs java">Integer collect = studentList.stream().collect(Collectors.summingInt(Student::getAge));</code></pre><p>简写</p><pre><code class="hljs java"><span class="hljs-keyword">int</span> sum = studentList.stream().mapToInt(Student::getAge).sum();</code></pre><h5 id="通过averagingInt-averagingLong-averagingDouble进行平均值获取"><a href="#通过averagingInt-averagingLong-averagingDouble进行平均值获取" class="headerlink" title="通过averagingInt/averagingLong/averagingDouble进行平均值获取"></a>通过averagingInt/averagingLong/averagingDouble进行平均值获取</h5><pre><code class="hljs java">Double collect = studentList.stream().collect(Collectors.averagingInt(Student::getAge));</code></pre><h5 id="复杂结果返回"><a href="#复杂结果返回" class="headerlink" title="复杂结果返回"></a>复杂结果返回</h5><pre><code class="hljs java">IntSummaryStatistics collect = studentList.stream().collect(Collectors.summarizingInt(Student::getAge));</code></pre><p>IntSummaryStatistics类内部提供了相关getter方法用于获取汇总值、总和、最大值最小值等方法，直接调用即可。</p><pre><code class="hljs java"><span class="hljs-keyword">long</span> count = collect.getCount();<span class="hljs-keyword">long</span> sum = collect.getSum();<span class="hljs-keyword">int</span> max = collect.getMax();<span class="hljs-keyword">int</span> min = collect.getMin();<span class="hljs-keyword">double</span> average = collect.getAverage();</code></pre><h5 id="通过joining-进行数据拼接"><a href="#通过joining-进行数据拼接" class="headerlink" title="通过joining()进行数据拼接"></a>通过joining()进行数据拼接</h5><pre><code class="hljs java">String collect = studentList.stream().map(Student::getName).collect(Collectors.joining());</code></pre><p>这种方式相当于将流中每一个元素的name属性获取映射，内部通过StringBuilder来把每一个映射的值进行拼接。joining()提供了一个重载方法，用于接收元素之间的分隔符。 </p><pre><code class="hljs java">String collect = studentList.stream().map(Student::getName).collect(Collectors.joining(<span class="hljs-string">","</span>));</code></pre><h5 id="通过mapping进行映射后收集"><a href="#通过mapping进行映射后收集" class="headerlink" title="通过mapping进行映射后收集"></a>通过mapping进行映射后收集</h5><pre><code class="hljs java">List&lt;Integer&gt; ll = list.stream().limit(<span class="hljs-number">5</span>).collect(Collectors.mapping(Integer::valueOf,Collectors.toList()));</code></pre><h5 id="collectingAndThen归纳之后，对结果再处理"><a href="#collectingAndThen归纳之后，对结果再处理" class="headerlink" title="collectingAndThen归纳之后，对结果再处理"></a>collectingAndThen归纳之后，对结果再处理</h5><pre><code class="hljs java"><span class="hljs-keyword">int</span> length = list.stream().collect(Collectors.collectingAndThen(Collectors.toList(),e -&gt; e.size()));</code></pre><h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h4><h5 id="groupingBy"><a href="#groupingBy" class="headerlink" title="groupingBy()"></a>groupingBy()</h5><p>如通过性别对学生集合进行分组，使用Collectors.groupingBy()即可</p><pre><code class="hljs java">Map&lt;Integer, List&lt;Student&gt;&gt; map = studentList.stream().collect(Collectors.groupingBy(Student::getAge))</code></pre><p>于groupingBy()它提供了两个参数的重载方法，可以完成多级分组</p><pre><code class="hljs java">Map&lt;Integer, Map&lt;String, List&lt;Student&gt;&gt;&gt; collect = studentList.stream().collect(Collectors.groupingBy(Student::getAge, Collectors.groupingBy(student ‐&gt; &#123; <span class="hljs-keyword">if</span> (student.getIsPass()) &#123; <span class="hljs-keyword">return</span> <span class="hljs-string">"pass"</span>; &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-string">"not pass"</span>; &#125; &#125;)));</code></pre><p>二级分组收集器传递给外层分组收集器的可以任意数据类型， 而不一定是它的数据集合</p><pre><code class="hljs java"><span class="hljs-comment">//根据年龄与是否及格进行分组，并汇总人数 </span>Map&lt;Integer, Map&lt;Boolean, Long&gt;&gt; collect = studentList.stream().collect(Collectors.groupingBy(Student::getAge, Collectors.groupingBy(Student::getIsPass, Collectors.counting())));</code></pre><pre><code class="hljs java"><span class="hljs-comment">//要根据年龄与是否集合进行分组，并获取每组中分数最高的学生</span>Map&lt;Integer, Map&lt;Boolean, Student&gt;&gt; collect = studentList.stream().collect( Collectors.groupingBy(Student::getAge, Collectors.groupingBy(Student::getIsPass, Collectors.collectingAndThen( Collectors.maxBy( Comparator.comparing(Student::getScore)), Optional::get))));</code></pre><h5 id="partitioningBy"><a href="#partitioningBy" class="headerlink" title="partitioningBy()"></a>partitioningBy()</h5><p>与groupingBy()基本相同，只不过map的键是Boolean类型，该方法将流中的元素按照给定的校验规则的结果分为两个部分。</p><pre><code class="hljs java">Map&lt;Boolean,List&lt;String&gt;&gt; map = list.stream().collect(Collectors.partitioningBy(e -&gt; e.length()&gt;<span class="hljs-number">5</span>));</code></pre><h4 id="自定义收集器"><a href="#自定义收集器" class="headerlink" title="自定义收集器"></a>自定义收集器</h4><p>对于自定义收集器实现，可以对Collector接口中的方法进行实现。Collector接口需要三个参数。T：流中要收集的元素类型、A：累加器的类型、R：收集的结果类型。如想自定义收集器，需要实现Collector接口中的五个方法：supplier、accumulator、fifinisher、combiner、 characteristics</p><ul><li><p>supplier：用于创建一个容器，在调用它时，需要创建一个空的累加器实例，供后续方法使用。 </p></li><li><p>accumulator：基于supplier中创建的累加容器，进行累加操作。 </p></li><li><p>finisher：当遍历完流后，在其内部完成最终转换，返回一个最终结果。 </p></li><li><p>combiner：用于在并发情况下，将每个线程的容器进行合并。 </p></li><li><p>characteristics：用于定义收集器行为，如是否可以并行或使用哪些优化。其本身是一个枚举，内部有三个值，分别为： </p><ul><li>CONCURRENT：表明收集器是并行的且只会存在一个中间容器。 </li><li>UNORDERED：表明结果不受流中顺序影响，收集是无序的。 </li><li>IDENTITY_FINISH：表明累积器的结果将会直接作为归约的最终结果，跳过finisher()。 </li></ul></li></ul><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><p>自定义收集器，返回所有合格的学员</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCollector</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Collector</span>&lt;<span class="hljs-title">Student</span>, <span class="hljs-title">List</span>&lt;<span class="hljs-title">Student</span>&gt;, <span class="hljs-title">List</span>&lt;<span class="hljs-title">Student</span>&gt;&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> Supplier&lt;List&lt;Student&gt;&gt; supplier() &#123;        <span class="hljs-keyword">return</span> ArrayList::<span class="hljs-keyword">new</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> BiConsumer&lt;List&lt;Student&gt;, Student&gt; accumulator() &#123;        <span class="hljs-keyword">return</span> (studentList, student) -&gt; &#123;            <span class="hljs-keyword">if</span> (student.getIsPass()) &#123;                studentList.add(student);            &#125;        &#125;;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> BinaryOperator&lt;List&lt;Student&gt;&gt; combiner() &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> Function&lt;List&lt;Student&gt;, List&lt;Student&gt;&gt; finisher() &#123;        <span class="hljs-keyword">return</span> Function.identity();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Set&lt;Characteristics&gt; <span class="hljs-title">characteristics</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> EnumSet.of(Characteristics.IDENTITY_FINISH, Characteristics.UNORDERED);    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCollectorTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        List&lt;Student&gt; studentList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        studentList.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-number">1</span>, <span class="hljs-string">"张三"</span>, <span class="hljs-string">"M"</span>, <span class="hljs-number">19</span>, <span class="hljs-keyword">true</span>));        studentList.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-number">2</span>, <span class="hljs-string">"李四"</span>, <span class="hljs-string">"M"</span>, <span class="hljs-number">18</span>, <span class="hljs-keyword">true</span>));        studentList.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-number">3</span>, <span class="hljs-string">"王五"</span>, <span class="hljs-string">"F"</span>, <span class="hljs-number">21</span>, <span class="hljs-keyword">true</span>));        studentList.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-number">4</span>, <span class="hljs-string">"赵六"</span>, <span class="hljs-string">"F"</span>, <span class="hljs-number">20</span>, <span class="hljs-keyword">false</span>));        List&lt;Student&gt; list = studentList.stream().collect(<span class="hljs-keyword">new</span> MyCollector());        System.out.println(list);    &#125;&#125;</code></pre><h3 id="并行流"><a href="#并行流" class="headerlink" title="并行流"></a>并行流</h3><p>之前Stream的操作，都是基于串行的方式来执行的。为了让数据处理更加高效，Java8对于Stream也提供了并行的操作方式，在Java7之前如果要对数据并行处理，需要开发人员做的事情很多，如数据如何进行分块、开启多少个线程、哪个线程负责哪部分数据、出现 线程竞争怎么办等等的问题。 </p><p>Java8对于数据并行化处理的实现非常简单，直接调用一个parallelStream()就可以开启并行化处理。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    List&lt;Integer&gt; numbers = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    numbers.add(<span class="hljs-number">1</span>);    numbers.add(<span class="hljs-number">2</span>);    numbers.add(<span class="hljs-number">3</span>);    numbers.add(<span class="hljs-number">4</span>);    numbers.add(<span class="hljs-number">5</span>);    numbers.add(<span class="hljs-number">6</span>);    numbers.add(<span class="hljs-number">7</span>);    <span class="hljs-keyword">int</span> sum = numbers.parallelStream().mapToInt(i -&gt; i).sum();    System.out.println(sum);&#125;</code></pre><h4 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h4><p>底层实现是沿用了Java7提供的fork/join分解合并框架进行实现。fork根据<strong>cpu</strong>核数进行数据分块，join对各个fork进行合并。实现过程如下所示：</p><img src="/blog/2020/07/24/JDK8-Stream%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8/pic1.png" srcset="/blog/img/loading.gif" class><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>对于并行流，一定不要陷入一个误区：并行一定比串行快。并行在不同的情况下它不一定是串行快的。影响并行流性能主要存在5个因素： </p><ol><li><p>数据大小：输入数据的大小，直接影响了并行处理的性能。因为在并行内部实现中涉及到了fork/join操作，它本身就存在性能上的开销。因此只有当数据量很大，使用并行处理才有意义。 </p></li><li><p>源数据结构：fork时会对源数据进行分割，数据源的特性直接影响了fork的性能。 </p><p>ArrayList、数组或IntStream.range，可分解性最佳，因为他们都支持随机读取，因此可以被任意分割。 </p><p>HashSet、TreeSet，可分解性一般，其虽然可被分解，但因为其内部数据结构，很难被平均分解。 </p><p>LinkedList、Streams.iterate、BufferedReader.lines，可分解性极差，因为他们长度未知，无法确定在哪里进行分割。 </p></li><li><p>装箱拆箱：尽量使用基本数据类型，避免装箱拆箱。 </p></li><li><p>CPU核数：fork的产生数量是与可用CPU核数相关，可用的核数越多，获取的性能提升就会越大。 </p></li><li><p>单元处理开销：花在流中每个元素的时间越长，并行操作带来的性能提升就会越明显。</p></li></ol><h3 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h3><p>此处使用常见线上服务器配置。12核24线程，96G内存的配置。通过基本类型、对象类型和复杂对象来对普通for循环、串行流和并行流进行分别的性能测试。 </p><h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><img src="/blog/2020/07/24/JDK8-Stream%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8/pic2.png" srcset="/blog/img/loading.gif" class><p>从上图可知，对于基本数据类型Stream串行的性能开销是普通for循环的两倍左右。同时Stream并行的性能比普通for循环和串行都要好。 </p><p>此时，Stream串行&gt;for循环&gt;Stream并行。</p><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><img src="/blog/2020/07/24/JDK8-Stream%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8/pic3.png" srcset="/blog/img/loading.gif" class><p>根据上图可知，当操作对象类型时，Stream串行的性能开销仍高于普通for循环一倍左右。同时Stream并行的性能比普通for循环和串行都要好。</p><p>此时，Stream串行&gt;for循环&gt;Stream并行。</p><h4 id="复杂对象"><a href="#复杂对象" class="headerlink" title="复杂对象"></a>复杂对象</h4><img src="/blog/2020/07/24/JDK8-Stream%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8/pic4.png" srcset="/blog/img/loading.gif" class><p>根据上图可知，当操作复杂对象时，普通for循环的性能开销会高于Stream串行，同时仍然是Stream并行性能最优</p><p>此时，for循环&gt;Stream串行&gt;Stream并行。</p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>根据上述测试可知，对于简单操作，如果环境机是多核的话，建议使用Stream并行，同时在不考虑核数的情况下，普通for循环性能要明显高于Stream串行，相差两倍左右。 </p><p>对于复杂操作，推荐使用Stream API操作。 </p>]]></content>
    
    
    <categories>
      
      <category>java8新特性</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jdk8</tag>
      
      <tag>stream</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lambda表达式</title>
    <link href="/blog/2020/07/24/JDK8-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/blog/2020/07/24/JDK8-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Lambda表达式是基于函数式编程的思想，支持将代码片段作为方法参数进行使用。可以理解为一种更加简洁的可传递匿名函数的书写方式。 </p><p>Lambda表达式没有名称，而且不属于某一个类，但是可以有参数列表、代码体、返回值。</p><blockquote><p>当在Lambda方法体内使用外部变量时，其必须声明为final。</p></blockquote><h3 id="使用规范"><a href="#使用规范" class="headerlink" title="使用规范"></a>使用规范</h3><pre><code class="hljs dust"><span class="xml">(参数列表) ‐&gt; </span><span class="hljs-template-variable">&#123;</span><span class="hljs-template-variable">    方法体</span><span class="hljs-template-variable">&#125;</span></code></pre><p>-&gt; ：Lambda运算符 </p><p>方法体：用于执行业务逻辑。可以是单一语句，也可以是语句块。如果是单一语句，可以省略花括号。当需要返回 值，如果方法体中只有一条语句，可以省略return，会自动根据结果进行返回。 </p><p>没有参数、一条语句的Lambda表达式</p><pre><code class="hljs haxe">()‐&gt;<span class="hljs-keyword">new</span> <span class="hljs-type">Student</span>();</code></pre><p>一个参数、多条语句的Lambda表达式</p><pre><code class="hljs sas"><span class="hljs-meta">x</span> ‐&gt; &#123;    System.<span class="hljs-meta">out</span>.print<span class="hljs-meta">ln(</span><span class="hljs-meta">x</span>);    <span class="hljs-meta">return</span> <span class="hljs-meta">x</span>; &#125;</code></pre><p>多个参数、一条语句的Lambda表达式</p><pre><code class="hljs gml">(<span class="hljs-symbol">x</span>,<span class="hljs-symbol">y</span>) ‐&gt; <span class="hljs-symbol">x</span>+<span class="hljs-symbol">y</span>;</code></pre><p>在Lambda中，JVM会根据上下文推断参数列表中参数的数据类型，不用定义类型。</p><h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><p>在编译时，Lambda表达式的内容会被编译为所在类的静态私有方法，在执行时，对Lambda表达式的调用会进入LambdaMetafactory类的metafactory中，该方法会为Lambda表达式创建内部类，并调用Lambda编译后的方法。</p><h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>函数式接口是仅有一个抽象方法的普通接口，为了让现有的函数能够更加友好的使用Lambda表达式。可以通过在接口上添加<code>@FunctionalInterface</code>注解来自定义一个函数式接口，函数式接口中如果声明多个抽象方法则会报错，但是默认方法和静态方法在此接口中可以定义多个。</p><p>在Java8的类库设计中，已经引入了几个函数式接口：Predicate、Consumer、Function、Supplier</p><ul><li>Predicate：Predicate接口是Java8定义的一个函数式接口，属于<strong>java.util.function</strong>包下，用于进行判断操作，内部定义一个抽象方法test、三个默认方法and，negate，or、一个静态方法isEqual。test()方法接收一个泛型T对象，返回boolean。</li><li>Consumer：Consumer也是JDK8提供的函数式接口，用于进行获取数据的操作，其内部定义了一个抽象方法accept、一个默认方法andThen。accept()方法接收一个泛型T对象，无返回值。</li><li>Function：Function主要用于进行类型转换的操作。内部提供一个抽象方法apply、两个默认方法compose，andThen、一个静态方法identity 。apply()方法接收一个泛型T对象，并返回一个泛型R的对象。</li><li>Supplier：Supplier用来进行值获取操作，内部只有一个抽象方法get，返回一个范性T的对象。</li><li>UnaryOperator：扩展至Function&lt;T,T&gt;，所以这个本质上也是一个映射转换接口，只不过映射转换后的类型保持不变</li><li>BiFunction：包含apply方法，接受泛型的T、U，返回R，可以视为复合型映射转换接口</li><li>BinaryOperator：扩展至Function BiFunction&lt;T,T,T&gt;，所以这个本质上也是一个复合型映射转换接口，只不过映射转换后的类型保持不变</li><li>BiPredicate：包含test方法，接受泛型的T，U，返回boolean，可以视为复合型断言（检查）接口</li><li>BiConsumer&lt;T,U&gt;：包含accept方法，接受泛型的T，U，无返回，可以视为复合型数据消费接口</li></ul>]]></content>
    
    
    <categories>
      
      <category>java8新特性</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jdk8</tag>
      
      <tag>lambda</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解java内存模型</title>
    <link href="/blog/2020/07/23/JVM-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <url>/blog/2020/07/23/JVM-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="Java内存模型与计算机原理"><a href="#Java内存模型与计算机原理" class="headerlink" title="Java内存模型与计算机原理"></a>Java内存模型与计算机原理</h3><p>Java内存模型即Java Memory Model，简称JMM。JMM定义了Java 虚拟机(JVM)在计算机内存(RAM)中的工作方式。JVM是整个计算机虚拟模型，所以JMM是隶属于JVM的。Java1.5版本对其进行了重构，现在的Java仍沿用了Java1.5的版本。Jmm遇到的问题与现代计算机中遇到的问题是差不多的。</p><p>物理计算机中的并发问题，物理机遇到的并发问题与虚拟机中的情况有不少相似之处，物理机对并发的处理方案对于虚拟机的实现也有相当大的参考意义。</p><p>根据《Jeff Dean在Google全体工程大会的报告》我们可以看到</p><table><thead><tr><th>操作</th><th>响应时间</th></tr></thead><tbody><tr><td>打开一个站点</td><td>几秒</td></tr><tr><td>数据库查询一条记录（有索引）</td><td>十几毫秒</td></tr><tr><td>1.6G的CPU执行一条指令</td><td>0.6纳秒</td></tr><tr><td>从机械磁盘顺序读取1M数据</td><td>2-10毫秒</td></tr><tr><td>从机械磁盘顺序读取1M数据</td><td>0.3毫秒</td></tr><tr><td>从机械磁盘顺序读取1M数据</td><td>250微秒</td></tr><tr><td>CPU读取一次内存</td><td>100纳秒</td></tr><tr><td>1G网卡，网络传输2Kb数据</td><td>20微秒</td></tr></tbody></table><p>计算机在做一些我们平时的基本操作时，需要的响应时间是不一样的。</p><p>如果从内存中读取1M的int型数据由CPU进行累加，耗时要多久？</p><p>做个简单的计算，1M的数据，Java里int型为32位，4个字节，共有1024<em>1024/4 = 262144个整数 ，则CPU 计算耗时：262144 \</em>0.6 = 157 286 纳秒，而我们知道从内存读取1M数据需要250000纳秒，两者虽然有差距（当然这个差距并不小，十万纳秒的时间足够CPU执行将近二十万条指令了），但是还在一个数量级上。但是，没有任何缓存机制的情况下，意味着每个数都需要从内存中读取，这样加上CPU读取一次内存需要100纳秒，262144个整数从内存读取到CPU加上计算时间一共需要262144*100+250000 = 26 464 400 纳秒，这就存在着数量级上的差异了。</p><p>而且现实情况中绝大多数的运算任务都不可能只靠处理器“计算”就能完成，处理器至少要与内存交互，如读取运算数据、存储运算结果等，这个I/O操作是基本上是无法消除的（无法仅靠寄存器来完成所有运算任务）。早期计算机中cpu和内存的速度是差不多的，但在现代计算机中，cpu的指令速度远超内存的存取速度,由于计算机的存储设备与处理器的运算速度有几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（Cache）来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。</p><img src="/blog/2020/07/23/JVM-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/pic1.png" srcset="/blog/img/loading.gif" class><p>在计算机系统中，寄存器划是L0级缓存，接着依次是L1，L2，L3（接下来是内存，本地磁盘，远程存储）。越往上的缓存存储空间越小，速度越快，成本也更高；越往下的存储空间越大，速度更慢，成本也更低。从上至下，每一层都可以看做是更下一层的缓存，即：L0寄存器是L1一级缓存的缓存，L1是L2的缓存，依次类推；每一层的数据都是来至它的下一层，所以每一层的数据是下一层的数据的子集。</p><img src="/blog/2020/07/23/JVM-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/pic2.png" srcset="/blog/img/loading.gif" class><p>在现代CPU上，一般来说L0， L1，L2，L3都集成在CPU内部，而L1还分为一级数据缓存（Data Cache，D-Cache，L1d）和一级指令缓存（Instruction Cache，I-Cache，L1i），分别用于存放数据和执行数据的指令解码。每个核心拥有独立的运算处理单元、控制器、寄存器、L1、L2缓存，然后一个CPU的多个核心共享最后一层CPU缓存L3</p><h4 id="物理内存模型带来的问题"><a href="#物理内存模型带来的问题" class="headerlink" title="物理内存模型带来的问题"></a>物理内存模型带来的问题</h4><p>基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是也为计算机系统带来更高的复杂度，因为它引入了一个新的问题：缓存一致性（Cache Coherence）。在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存（MainMemory）。当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致。</p><img src="/blog/2020/07/23/JVM-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/pic3.png" srcset="/blog/img/loading.gif" class><p>现代的处理器使用写缓冲区临时保存向内存写入的数据。写缓冲区可以保证指令流水线持续运行，它可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟。同时，通过以批处理的方式刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写，减少对内存总线的占用。虽然写缓冲区有这么多好处，但每个处理器上的写缓冲区，仅仅对它所在的处理器可见。这个特性会对内存操作的执行顺序产生重要的影响：处理器对内存的读/写操作的执行顺序，不一定与内存实际发生的读/写操作顺序一致。</p><img src="/blog/2020/07/23/JVM-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/pic5.png" srcset="/blog/img/loading.gif" class><p>处理器A和处理器B按程序的顺序并行执行内存访问，最终可能得到x=y=0的结果。</p><p>处理器A和处理器B可以同时把共享变量写入自己的写缓冲区（步骤A1，B1），然后从内存中读取另一个共享变量（步骤A2，B2），最后才把自己写缓存区中保存的脏数据刷新到内存中（步骤A3，B3）。当以这种时序执行时，程序就可以得到x=y=0的结果。</p><p>从内存操作实际发生的顺序来看，直到处理器A执行A3来刷新自己的写缓存区，写操作A1才算真正执行了。虽然处理器A执行内存操作的顺序为：A1→A2，但内存操作实际发生的顺序却是A2→A1。</p><img src="/blog/2020/07/23/JVM-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/pic4.png" srcset="/blog/img/loading.gif" class><p>如果真的发生这种情况，那同步回到主内存时以谁的缓存数据为准呢？为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有MSI、MESI（Illinois Protocol）、MOSI、Synapse、Firefly及Dragon Protocol等。</p><h4 id="伪共享"><a href="#伪共享" class="headerlink" title="伪共享"></a>伪共享</h4><p>前面我们已经知道，CPU中有好几级高速缓存。但是CPU缓存系统中是以缓存行（cache line）为单位存储的。目前主流的CPU Cache的Cache Line大小都是64Bytes。Cache Line可以简单的理解为CPU Cache中的最小缓存单位，今天的CPU不再是按字节访问内存，而是以64字节为单位的块(chunk)拿取，称为一个缓存行(cache line)。当读一个特定的内存地址，整个缓存行将从主存换入缓存。</p><p>一个缓存行可以存储多个变量（存满当前缓存行的字节数）；而CPU对缓存的修改又是以缓存行为最小单位的，在多线程情况下，如果同时修改一个缓存行中的变量，就会无意中影响彼此的性能，这就是伪共享（False Sharing）。</p><p>为了避免伪共享，我们可以使用数据填充的方式来避免，即单个数据填充满一个CacheLine。这本质是一种空间换时间的做法。但是这种方式在Java7以后可能失效。</p><p>Java8中已经提供了官方的解决方案，Java8中新增了一个注解@sun.misc.Contended。</p><p>比如JDK的ConcurrentHashMap中就有使用</p><img src="/blog/2020/07/23/JVM-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/pic6.png" srcset="/blog/img/loading.gif" class><h3 id="Java内存模型带来的问题"><a href="#Java内存模型带来的问题" class="headerlink" title="Java内存模型带来的问题"></a>Java内存模型带来的问题</h3><p>从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地内存（Local Memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。</p><img src="/blog/2020/07/23/JVM-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/pic9.png" srcset="/blog/img/loading.gif" class><img src="/blog/2020/07/23/JVM-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/pic7.png" srcset="/blog/img/loading.gif" class><h4 id="可见性问题"><a href="#可见性问题" class="headerlink" title="可见性问题"></a>可见性问题</h4><img src="/blog/2020/07/23/JVM-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/pic8.png" srcset="/blog/img/loading.gif" class><p>左边CPU中运行的线程从主存中拷贝共享对象obj到它的CPU缓存，把对象obj的count变量改为2。但这个变更对运行在右边CPU中的线程不可见，因为这个更改还没有flush到主存中。</p><p>在多线程的环境下，如果某个线程首次读取共享变量，则首先到主内存中获取该变量，然后存入工作内存中，以后只需要在工作内存中读取该变量即可。同样如果对该变量执行了修改的操作，则先将新值写入工作内存中，然后再刷新至主内存中。但是什么时候最新的值会被刷新至主内存中是不太确定，一般来说会很快，但具体时间不知。</p><p>要解决共享对象可见性这个问题，我们可以使用volatile关键字或者是加锁。</p><h4 id="竞争问题"><a href="#竞争问题" class="headerlink" title="竞争问题"></a>竞争问题</h4><p>线程A和线程B共享一个对象obj。假设线程A从主存读取Obj.count变量到自己的CPU缓存，同时，线程B也读取了Obj.count变量到它的CPU缓存，并且这两个线程都对Obj.count做了加1操作。此时，Obj.count加1操作被执行了两次，不过都在不同的CPU缓存中。</p><img src="/blog/2020/07/23/JVM-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/pic10.png" srcset="/blog/img/loading.gif" class><p>如果这两个加1操作是串行执行的，那么Obj.count变量便会在原始值上加2，最终主存中的Obj.count的值会是3。然而图中两个加1操作是并行的，不管是线程A还是线程B先flush计算结果到主存，最终主存中的Obj.count只会增加1次变成2，尽管一共有两次加1操作。 要解决上面的问题我们可以使用java synchronized代码块</p><h4 id="重排序问题"><a href="#重排序问题" class="headerlink" title="重排序问题"></a>重排序问题</h4><h5 id="重排序类型"><a href="#重排序类型" class="headerlink" title="重排序类型"></a>重排序类型</h5><p>除了共享内存和工作内存带来的问题，还存在重排序的问题：在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。重排序分3种类型。</p><ol><li><p>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</p></li><li><p>指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-LevelParallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</p></li><li><p>内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</p></li></ol><h5 id="数据依赖性"><a href="#数据依赖性" class="headerlink" title="数据依赖性"></a>数据依赖性</h5><p>数据依赖性：如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。数据依赖分为下列3种类型</p><img src="/blog/2020/07/23/JVM-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/pic11.png" srcset="/blog/img/loading.gif" class><p>上面3种情况，只要重排序两个操作的执行顺序，程序的执行结果就会被改变。</p><p>例如</p><img src="/blog/2020/07/23/JVM-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/pic12.png" srcset="/blog/img/loading.gif" class><p>很明显，A和C存在数据依赖，B和C也存在数据依赖，而A和B之间不存在数据依赖，如果重排序了A和C或者B和C的执行顺序，程序的执行结果就会被改变。</p><p>很明显，不管如何重排序，都必须保证代码在单线程下的运行正确，连单线程下都无法正确，更不用讨论多线程并发的情况，所以就提出了一个as-if-serial的概念。</p><p>as-if-serial语义的意思是：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。</p><p>为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。（强调一下，这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。）但是，如果操作之间不存在数据依赖关系，这些操作依然可能被编译器和处理器重排序。</p><p>A和C之间存在数据依赖关系，同时B和C之间也存在数据依赖关系。因此在最终执行的指令序列中，C不能被重排序到A和B的前面（C排到A和B的前面，程序的结果将会被改变）。但A和B之间没有数据依赖关系，编译器和处理器可以重排序A和B之间的执行顺序。</p><img src="/blog/2020/07/23/JVM-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/pic13.png" srcset="/blog/img/loading.gif" class><p>as-if-serial语义把单线程程序保护了起来，遵守as-if-serial语义的编译器、runtime和处理器可以让我们感觉到：单线程程序看起来是按程序的顺序来执行的。asif-serial语义使单线程程序员无需担心重排序会干扰他们，也无需担心内存可见性问题。</p><h5 id="控制依赖性"><a href="#控制依赖性" class="headerlink" title="控制依赖性"></a>控制依赖性</h5><img src="/blog/2020/07/23/JVM-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/pic14.png" srcset="/blog/img/loading.gif" class><p>上述代码中，flag变量是个标记，用来标识变量a是否已被写入，在use方法中变量i的赋值依赖if (flag)的判断，这里就叫控制依赖，如果发生了重排序，结果就不对了。</p><p>操作1和操作2没有数据依赖关系，编译器和处理器可以对这两个操作重排序；同样，操作3和操作4没有数据依赖关系，编译器和处理器也可以对这两个操作重排序。操作3和操作4则存在所谓<strong>控制依赖关系</strong>。</p><p>在程序中，当代码中存在控制依赖性时，会影响指令序列执行的并行度。为此，编译器和处理器会采用猜测（Speculation）执行来克服控制相关性对并行度的影响。以处理器的猜测执行为例，执行线程B的处理器可以提前读取并计算a*a，然后把计算结果临时保存到一个名为重排序缓冲（Reorder Buffer，ROB）的硬件缓存中。当操作3的条件判断为真时，就把该计算结果写入变量i中。猜测执行实质上对操作3和4做了重排序，问题在于这时候，a的值还没被线程A赋值。</p><p>在单线程程序中，对存在控制依赖的操作重排序，不会改变执行结果（这也是as-if-serial语义允许对存在控制依赖的操作做重排序的原因）。</p><p>但是对多线程来说就完全不同了：这里假设有两个线程A和B，A首先执行init ()方法，随后B线程接着执行use ()方法。线程B在执行操作4时，能否看到线程A在操作1对共享变量a的写入呢？答案是：不一定能看到。</p><p>让我们先来看看，当操作1和操作2重排序，操作3和操作4重排序时，可能会产生什么效果？操作1和操作2做了重排序。程序执行时，线程A首先写标记变量flag，随后线程B读这个变量。由于条件判断为真，线程B将读取变量a。此时，变量a还没有被线程A写入，这时就会发生错误！</p><p>所以在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。</p><h3 id="JMM规范"><a href="#JMM规范" class="headerlink" title="JMM规范"></a>JMM规范</h3><h4 id="规则-1-Race-Condition"><a href="#规则-1-Race-Condition" class="headerlink" title="规则 1 - Race Condition"></a>规则 1 - Race Condition</h4><p>在多线程下，没有依赖关系的代码，在执行共享变量读写操作（至少有一个线程写）时，并不能保证以编写顺序 （Program Order）执行，这称为发生了竞态条件（Race Condition） 。</p><h4 id="规则-2-Synchronization-Order"><a href="#规则-2-Synchronization-Order" class="headerlink" title="规则 2 - Synchronization Order"></a>规则 2 - Synchronization Order</h4><p>表示同步动作，用于保证多线程下，单个线程中代码的执行顺序（Synchronization Order）按编写顺序（Program Order）执行。常用的同步动作有：</p><ul><li><p>lock，unlock - synchronized， ReentrantLock</p></li><li><p>volatile 方式读写变量 - 保证可见性，防止重排序</p></li><li><p>VarHandle 方式读写变量 （JDK9中提供，与volatile类似，但更加轻量级的方式）</p></li></ul><blockquote><p>Synchronization Order也称之为Total Order</p></blockquote><h4 id="规则-3-Happens-Before"><a href="#规则-3-Happens-Before" class="headerlink" title="规则 3 - Happens-Before"></a>规则 3 - Happens-Before</h4><p>用于保证线程切换时代码的顺序和可见性 </p><p>若是变量读写时发生线程切换（例如，线程 1 写入 x，切换至线程 2，线程 2 读取 x）在这些边界的处理上如果有<strong>action1</strong> 先于 <strong>action 2</strong> 发生，那么代码可以按确定的顺序执行，这称之为 <strong>Happens-Before Order</strong> 规则。</p><blockquote><p>Happens-Before Order也称之为Partial Order</p></blockquote><p>用公式表达为</p><img src="/blog/2020/07/23/JVM-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/pic39.png" srcset="/blog/img/loading.gif" class><p>含义为：如果 action1 先于 action2 发生，那么 action1 之前的共享变量的修改对于 action2 可见，且代码按 PO顺序执行。</p><p>常见的边界：</p><ul><li><p>线程启动和运行的边界</p><img src="/blog/2020/07/23/JVM-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/pic51.png" srcset="/blog/img/loading.gif" class></li><li><p>线程结束和join的边界</p><img src="/blog/2020/07/23/JVM-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/pic52.png" srcset="/blog/img/loading.gif" class></li><li><p>线程打断和得知打断的边界</p><img src="/blog/2020/07/23/JVM-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/pic53.png" srcset="/blog/img/loading.gif" class></li><li><p>lock和unlock的边界</p><img src="/blog/2020/07/23/JVM-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/pic54.png" srcset="/blog/img/loading.gif" class></li><li><p>volatile write和volatile read的边界，write需要在read前</p><img src="/blog/2020/07/23/JVM-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/pic55.png" srcset="/blog/img/loading.gif" class></li><li><p>传递性</p><img src="/blog/2020/07/23/JVM-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/pic56.png" srcset="/blog/img/loading.gif" class></li></ul><h4 id="规则-4-Causality"><a href="#规则-4-Causality" class="headerlink" title="规则 4 - Causality"></a>规则 4 - Causality</h4><p>Causality 即因果律：代码之间如存在依赖关系，即使没有加同步动作，代码的执行顺序也是可以预见的</p><h4 id="规则-5-安全发布"><a href="#规则-5-安全发布" class="headerlink" title="规则 5 - 安全发布"></a>规则 5 - 安全发布</h4><p>若要安全构造对象，并将其共享使用，需要用 <strong>final</strong> 或 <strong>volatile</strong> 修饰其成员变量，这样可以避免部分构造的情况，但volatile需要加在类的最后一个属性上才能生效，还要避免避免 <strong>this</strong> 溢出情况。</p><blockquote><p>静态成员变量可以安全地发布</p></blockquote><h3 id="同步动作"><a href="#同步动作" class="headerlink" title="同步动作"></a>同步动作</h3><h4 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h4><p>共有四种内存屏障，具体实现与 <em>CPU</em> 架构相关，不必钻研太深，只需知道它们的效果</p><h5 id="LoadLoad"><a href="#LoadLoad" class="headerlink" title="LoadLoad"></a>LoadLoad</h5><ul><li><p>防止 B 的 Load 重排到 A 的 Load 之前 </p><pre><code class="hljs java"><span class="hljs-keyword">if</span>(A) &#123; LoadLoad<span class="hljs-keyword">return</span> B&#125;read(A) LoadLoad read(B)</code></pre></li><li><p>意义：A == true 时，再去获取 B，否则可能会由于重排导致 B 的值相对于 A 是过期的 </p></li></ul><h5 id="LoadStore"><a href="#LoadStore" class="headerlink" title="LoadStore"></a>LoadStore</h5><ul><li>防止 B 的 Store 被重排到 A 的 Load 之前 </li></ul><h5 id="StoreStore"><a href="#StoreStore" class="headerlink" title="StoreStore"></a>StoreStore</h5><ul><li><p>防止 A 的 Store 被重排到 B 的 Store 之后</p><pre><code class="hljs java">A = x StoreStore B = <span class="hljs-keyword">true</span></code></pre></li><li><p>意义：在 B 修改为 true 之前，其它线程别想看到 A 的修改 </p><ul><li>有点类似于 sql 中更新后，commit 之前，其它事务不能看到这些更新（B 的赋值会触发 commit 并撤除屏障） </li></ul></li></ul><h5 id="StoreLoad"><a href="#StoreLoad" class="headerlink" title="StoreLoad(*)"></a>StoreLoad(*)</h5><ul><li><p>意义</p><ul><li><p>屏障前的改动都同步到主存1，屏障后的 Load 获取主存最新数据</p></li><li><p>防止屏障前所有的写操作，被重排序到屏障后的任何的读操作，可以认为此 store -&gt; load 是连续的 </p></li><li><p>有点类似于 git 中先 commit，再远程 poll，而且这个动作是原子的 </p></li></ul></li><li><p>使用方式</p><ul><li><code>LoadLoad + LoadStore = Acquire</code>：即让同一线程内读操作之后的读写上不去，第一个 Load 能读到主存最新值 </li><li><code>LoadStore + StoreStore = Release</code>：即让同一线程内写操作之前的读写下不来，后一个 Store 能将改动都写入主存</li><li><code>StoreLoad</code>：最为特殊，还能用在线程切换时，对变量的写操作 <strong>+</strong> 读操作做同步，只要是对同一变量先写后读，那么屏障就能生效</li></ul></li></ul><h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><h5 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h5><img src="/blog/2020/07/23/JVM-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/pic40.png" srcset="/blog/img/loading.gif" class><p>事实上对 volatile 而言 StoreLoad，与 LoadLoad 屏障最为有用，简化起见以后的分析省略部分其他屏障</p><ul><li>单一变量的赋值原子性</li><li>控制了可能的执行路径：线程内按屏障有序，线程切换时按 HB 有序</li><li>可见性：线程切换时若发生了 写 -&gt;读 则变量可见，顺带影响普通变量可见</li></ul><h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><h5 id="本质-1"><a href="#本质-1" class="headerlink" title="本质"></a>本质</h5><p>monitorenter 与 monitorexit 工作原理</p><img src="/blog/2020/07/23/JVM-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/pic41.png" srcset="/blog/img/loading.gif" class><p>相关的内存屏障</p><img src="/blog/2020/07/23/JVM-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/pic42.png" srcset="/blog/img/loading.gif" class><h5 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h5><ul><li><p>重量级</p><ul><li>当有竞争时，仍会向系统申请 Monitor 互斥锁</li></ul></li><li><p>轻量级锁</p><ul><li>如果线程加锁、解锁时间上刚好是错开的，这时候就可以使用轻量级锁，只是使用 cas 尝试将对象头替换为该线程的锁记录地址，如果 cas 失败，会锁重入或触发重量级锁升级 </li></ul></li><li><p>偏向锁</p><ul><li>打个比方，轻量级锁就好比用课本占座，线程每次占座前还得比较一下，课本是不是自己的（cas），频繁 cas 性能也会受到影响</li><li>而偏向锁就好比座位上已经刻好了线程的名字，线程【专用】这个座位，比 cas 更为轻量</li><li>但是一旦其他线程访问偏向对象，那么比较麻烦，需要把座位上的名字擦去，这称之为偏向锁撤销，锁也升级为轻量级锁 </li><li>偏向锁撤销也属于昂贵的操作，怎么减少呢，JVM 会记录这一类对象被撤销的次数，如果超过了20这个阈值，下次新线程访问偏向对象时，就不用撤销了，而是刻上新线程的名字，这称为重偏向</li><li>如果撤销次数进一步增加，超过 40 这个阈值，JVM 会认为这一类对象不适合采用偏向锁，会对它们禁用偏向锁，下次新建对象会直接加轻量级锁 </li></ul></li></ul><h5 id="无锁vs有锁"><a href="#无锁vs有锁" class="headerlink" title="无锁vs有锁"></a>无锁vs有锁</h5><ul><li><p>synchronized 更为重量，申请锁、锁重入都要发起系统调用，频繁调用性能会受影响 </p></li><li><p>synchronized 如果无法获取锁时，线程会陷入阻塞，引起的线程上下文切换成本高 </p></li><li><p>虽然做了一系列优化，但轻量级锁、偏向锁都是针对无数据竞争场景的 </p></li><li><p>如果数据的原子操作时间较长，仍应该让线程阻塞，无锁适合的是短频快的共享数据修改操作主要用于计数器、停止标记、或是阻塞前的有限尝试</p></li></ul><h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><p>编译器和处理器要遵守的两个重排序规则：</p><ol><li><p><strong>在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</strong></p><img src="/blog/2020/07/23/JVM-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/pic25.png" srcset="/blog/img/loading.gif" class><p>我们假设一个线程A执行writer方法，随后另一个线程B执行reader方法。</p><p>write()方法中只包含一行代码 <em>obj</em> = new FinalMemory();。这一行代码包含两个步骤：</p><ol><li>构造一个FinalMemory类型的对象。</li><li>把这个对象的引用赋值给引用变量obj。</li></ol><p>假设线程B读对象引用（FinalMemory object = obj）与读对象的成员域之间（int a = object.i;int b = object.j）没有重排序，下面的图是一种可能的执行时序：</p><img src="/blog/2020/07/23/JVM-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/pic26.png" srcset="/blog/img/loading.gif" class><p>从上面可能的时序图中我们可以看到，读普通域被编译器重排序到了构造函数执行之前，读线程B错误的读取了普通变量i初始化之前的值。而写final域的操作，被写final域的重排序规则“限制”到了构造函数之内，读线程B正确读取了final变量初始化之后的值。</p><p>总结：写final域的重排序规则可以确保在对象引用为任意线程可见之前，对象的final域已经被正常的初始化了，而普通域不具有这样的保证。</p></li><li><p><strong>初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。</strong></p><p>在一个线程中，初次读对象引用与初次读该对象包含的final域，JMM禁止处理器重排序这两个操作。编译器会在读final域操作的前面插入一个LoadLoad屏障。</p><p>reader()方法包含3个步骤：</p><ol><li><p>初次读引用变量obj</p></li><li><p>初次读引用变量obj指向对象的普通域 i</p></li><li><p>初次读引用变量obj指向对象的final域 j</p></li></ol><p>我们假设写线程A没有发生任何重排序，则下图是一种可能的时序：</p><img src="/blog/2020/07/23/JVM-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/pic27.png" srcset="/blog/img/loading.gif" class><p>读对象的普通域的操作被处理器重排序到读对象引用之前。读普通域时，该域还没有被线程A写入，所以上面的是一个错误的读取操作。但是读final域的重排序规则把读对象final域的操作“限定”在读对象引用之后，该final域已经被A线程初始化了，是一个正确的读取操作。</p><p>总结：读final域的重排序规则可以确保在读一个对象的final域之前，一定会先读包含这个final域的对象的引用.</p></li></ol><h5 id="final域为引用类型"><a href="#final域为引用类型" class="headerlink" title="final域为引用类型"></a>final域为引用类型</h5><img src="/blog/2020/07/23/JVM-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/pic28.png" srcset="/blog/img/loading.gif" class><p>在上面的代码中，final域是一个引用类型，它引用了一个int类型的数组，对于引用类型，写final域的重排序规则对编译器和处理器增加了一下的约束：在构造函数内对一个final引用的对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</p><p>我们假设线程A先执行write0操作，执行完后线程B执行write1操作，执行完后线程C执行reader操作，下图是一种可能的执行时序：</p><img src="/blog/2020/07/23/JVM-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/pic29.png" srcset="/blog/img/loading.gif" class><p>1是对final域的写入，2是对这个final域引用的对象的成员域的写入，3是把被构造的对象的引用赋值给某个引用变量。这里除了前面提到的1不能和3重排序外，2和3也不能重排序。</p><p>JMM可以确保读线程C至少能看到写线程A在构造函数中对final引用对象的成员域的写入。即C至少能看到数组下标0的值为1。而写线程B对数组元素的写入，读线程C可能看得到，也可能看不到。JMM不保证线程B的写入对读线程C可见，因为写线程B和读线程C之间存在数据竞争，此时的执行结果不可预知。</p><p>如果想要确保读线程C看到写线程B对数组元素的写入，写线程B和读线程C之间需要使用同步（lock或volatile）来确保内存可见性。</p><h5 id="final引用不能从构造函数内逃逸"><a href="#final引用不能从构造函数内逃逸" class="headerlink" title="final引用不能从构造函数内逃逸"></a>final引用不能从构造函数内逃逸</h5><p>写final域的重排序规则可以确保：在引用变量为任意线程可见之前，该引用变量指向的对象的final域已经在构造函数中被正确初始化过了。其实，要得到这个效果，还需要一个保证：在构造函数内部，不能让这个被构造对象的引用为其他线程所见，也就是对象引用不能在构造函数中逃逸。</p><img src="/blog/2020/07/23/JVM-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/pic30.png" srcset="/blog/img/loading.gif" class><p>假设一个线程A执行writer()方法，另一个线程B执行reader()方法。这里的操作2使得对象还未完成构造前就为线程B可见。即使这里的操作2是构造函数的最后一步，且在程序中操作2排在操作1后面，执行read()方法的线程仍然可能无法看到final域被初始化后的值，因为这里的操作1和操作2之间可能被重排序。</p><img src="/blog/2020/07/23/JVM-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/pic31.png" srcset="/blog/img/loading.gif" class><p>因此在构造函数返回前，被构造对象的引用不能为其他线程所见，因为此时的final域可能还没有被初始化。</p><h5 id="final语义的实现"><a href="#final语义的实现" class="headerlink" title="final语义的实现"></a>final语义的实现</h5><p>会要求编译器在final域的写之后，构造函数return之前插入一个StoreStore障屏。</p><p>读final域的重排序规则要求编译器在读final域的操作前面插入一个LoadLoad屏障</p><h4 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h4><img src="/blog/2020/07/23/JVM-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/pic15.png" srcset="/blog/img/loading.gif" class><p>JMM会在退出临界区和进入临界区这两个关键时间点做一些特别处理，使得多线程在这两个时间点按某种顺序执行。</p><p>临界区内的代码则可以重排序（但JMM不允许临界区内的代码“逸出”到临界区之外，那样会破坏监视器的语义）。虽然线程A在临界区内做了重排序，但由于监视器互斥执行的特性，这里的线程B根本无法“观察”到线程A在临界区内的重排序。这种重排序既提高了执行效率，又没有改变程序的执行结果。</p><p>因为临界区内的代码依然会重排序，所以线程安全的单例模式中一般的双重检查并不能保证真正的线程安全。</p><h3 id="了解各种锁"><a href="#了解各种锁" class="headerlink" title="了解各种锁"></a>了解各种锁</h3><h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。</p><p>但是线程自旋是需要消耗CPU的，说白了就是让CPU在做无用功，线程不能一直占用CPU自旋做无用功，所以需要设定一个自旋等待的最大时间。</p><p>如果持有锁的线程执行的时间超过自旋等待的最大时间扔没有释放锁，就会导致其它争用锁的线程在最大等待时间内还是获取不到锁，这时争用线程会停止自旋进入阻塞状态。</p><h5 id="自旋锁的优缺点"><a href="#自旋锁的优缺点" class="headerlink" title="自旋锁的优缺点"></a>自旋锁的优缺点</h5><p>在锁的竞争不激烈，且占用锁的同步块执行时间非常短的情况下，自旋的消耗小于线程阻塞挂起操作的消耗，这时自旋锁能够尽可能的减少线程的阻塞，提升代码块性能。</p><p>但是如果锁的竞争激烈，或者占用锁的同步块执行时间比较长，这时候就不适合使用自旋锁了，因为自旋锁在获取锁前一直都是占用cpu做无用功，线程自旋的消耗大于线程阻塞挂起操作的消耗，其它需要cup的线程又不能获取到cpu，造成cpu的浪费。</p><h5 id="自旋锁时间阈值"><a href="#自旋锁时间阈值" class="headerlink" title="自旋锁时间阈值"></a>自旋锁时间阈值</h5><p>自旋锁的目的是为了占着CPU的资源不释放，等到获取到锁立即进行处理。但是如何去选择自旋的执行时间呢？如果自旋执行时间太长，会有大量的线程处于自旋状态占用CPU资源，进而会影响整体系统的性能。因此自旋次数很重要</p><p>JVM对于自旋次数的选择，jdk1.5默认为10次，在1.6引入了适应性自旋锁，适应性自旋锁意味着自旋的时间不在是固定的了，而是由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定，基本认为一个线程上下文切换的时间是最佳的一个时间。</p><p>JDK1.6中-XX:+UseSpinning开启自旋锁； JDK1.7后，去掉此参数，由jvm控制；</p><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>偏向锁，顾名思义，它会偏向于第一个访问锁的线程，如果在运行过程中，只有一个线程访问锁，不存在多线程竞争的情况，则线程是不需要触发同步的，减少加锁／解锁的一些CAS操作（比如等待队列的一些CAS操作），这种情况下，就会给线程加一个偏向锁。 如果在运行过程中，遇到了其他线程抢占锁，则持有偏向锁的线程会被挂起，JVM会消除它身上的偏向锁，将锁恢复到标准的轻量级锁。它通过消除资源无竞争情况下的同步原语，进一步提高了程序的运行性能。</p><h5 id="引入背景"><a href="#引入背景" class="headerlink" title="引入背景"></a>引入背景</h5><p>大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁，减少不必要的CAS操作。</p><h5 id="锁的状态"><a href="#锁的状态" class="headerlink" title="锁的状态"></a>锁的状态</h5><p>一共有四种状态，无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态，它会随着竞争情况逐渐升级。锁可以升级但不能降级，目的是为了提高获得锁和释放锁的效率。</p><h5 id="偏向锁获取过程"><a href="#偏向锁获取过程" class="headerlink" title="偏向锁获取过程"></a>偏向锁获取过程</h5><ol><li><p>访问Mark Word中偏向锁的标识是否设置成1，锁标志位是否为01，确认为可偏向状态。</p></li><li><p>如果为可偏向状态，则测试线程ID是否指向当前线程，如果是，进入步骤5，否则进入步骤3。</p></li><li><p>如果线程ID并未指向当前线程，则通过CAS操作竞争锁。如果竞争成功，则将Mark Word中线程ID设置为当前线程ID，然后执行5；如果竞争失败，执行4。</p></li><li><p>如果CAS获取偏向锁失败，则表示有竞争。当到达全局安全点（safepoint）时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。（撤销偏向锁的时候会导致stop the word）</p></li><li><p>执行同步代码。</p></li></ol><img src="/blog/2020/07/23/JVM-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/pic37.png" srcset="/blog/img/loading.gif" class><h5 id="偏向锁的释放"><a href="#偏向锁的释放" class="headerlink" title="偏向锁的释放"></a>偏向锁的释放</h5><p>偏向锁的撤销在上述第四步骤中有提到。偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放偏向锁，线程不会主动去释放偏向锁。偏向锁的撤销需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态，撤销偏向锁后恢复到未锁定（标志位为“01”）或轻量级锁（标志位为“00”）的状态。</p><h5 id="偏向锁的适用场景"><a href="#偏向锁的适用场景" class="headerlink" title="偏向锁的适用场景"></a>偏向锁的适用场景</h5><p>始终只有一个线程在执行同步块，在它没有执行完释放锁之前，没有其它线程去执行同步块，在锁无竞争的情况下使用，一旦有了竞争就升级为轻量级锁，升级为轻量级锁的时候需要撤销偏向锁，撤销偏向锁的时候会导致stop the word操作； </p><p>在有锁的竞争时，偏向锁会多做很多额外操作，尤其是撤销偏向所的时候会导致进入安全点，安全点会导致stw，导致性能下降，这种情况下应当禁用。</p><h5 id="jvm开启-关闭偏向锁"><a href="#jvm开启-关闭偏向锁" class="headerlink" title="jvm开启/关闭偏向锁"></a>jvm开启/关闭偏向锁</h5><p>开启偏向锁：-XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0</p><p>关闭偏向锁：-XX:-UseBiasedLocking</p><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>轻量级锁是由偏向锁升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁争用的时候，偏向锁就会升级为轻量级锁。</p><h5 id="轻量级锁的加锁过程"><a href="#轻量级锁的加锁过程" class="headerlink" title="轻量级锁的加锁过程"></a>轻量级锁的加锁过程</h5><ol><li><p>在代码进入同步块的时候，如果同步对象锁状态为无锁状态且不允许进行偏向（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，官方称之为 Displaced Mark Word。</p></li><li><p>拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock record里的owner指针指向object mark word。</p></li><li><p>如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，即表示此对象处于轻量级锁定状态</p></li><li><p>如果这个更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行。否则说明多个线程竞争锁，当竞争线程尝试占用轻量级锁失败多次之后，轻量级锁就会膨胀为重量级锁，重量级线程指针指向竞争线程，竞争线程也会阻塞，等待轻量级线程释放锁后唤醒他。锁标志的状态值变为“10”，Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。</p></li></ol><img src="/blog/2020/07/23/JVM-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/pic38.png" srcset="/blog/img/loading.gif" class><h4 id="不同锁的比较"><a href="#不同锁的比较" class="headerlink" title="不同锁的比较"></a>不同锁的比较</h4><table><thead><tr><th>锁</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>偏向锁</td><td>加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。</td><td>如果线程间存在锁竞争,会带来额外的锁撤销的消耗。</td><td>适用于只有一个线程访问同步块场景。</td></tr><tr><td>轻量级锁</td><td>竞争的线程不会阻塞，提高了程序的响应速度。</td><td>如果线程始终得不到锁，使用自旋会消耗CPU。</td><td>追求响应时间。同步块执行速度非常快</td></tr><tr><td>重量级锁</td><td>线程竞争不使用自旋，不会消耗CPU.</td><td>线程阻塞,响应时间缓慢。</td><td>追求吞吐量。同步块执行速度较长。</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>JVM虚拟机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java内存模型</tag>
      
      <tag>计算机原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式</title>
    <link href="/blog/2020/07/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/blog/2020/07/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="设计模式简介"><a href="#设计模式简介" class="headerlink" title="设计模式简介"></a>设计模式简介</h3><p>软件设计模式（Software Design Pattern），俗称设计模式，<strong>设计模式</strong>是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。使用设计模式的<strong>目的</strong>是为了代码重用、让代码更容易被他人理解、保证代码可靠性。</p><h4 id="GOF"><a href="#GOF" class="headerlink" title="GOF"></a>GOF</h4><p>《Design Patterns: Elements of Reusable Object-Oriented Software》（即后述《设计模式》一书），由 ErichGamma、Richard Helm、Ralph Johnson 和 John Vlissides 合著（Addison-Wesley，1995）。这几位作者常被称为”四人组（Gang of Four）”，而这本书也就被称为”四人组（或 GoF）”书。在《设计模式》这本书的最大部分是一个目录，该目录列举并描述了 23 种设计模式。</p><h4 id="使用目的"><a href="#使用目的" class="headerlink" title="使用目的"></a>使用目的</h4><pre><code class="hljs angelscript"><span class="hljs-number">1</span>、单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多 例模式。 <span class="hljs-number">2</span>、原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。 <span class="hljs-number">3</span>、工厂方法（Factory Method）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。 <span class="hljs-number">4</span>、抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。 <span class="hljs-number">5</span>、建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该 复杂对象。 <span class="hljs-number">6</span>、代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、 增强或修改该对象的一些特性。 <span class="hljs-number">7</span>、适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的 那些类能一起工作。 <span class="hljs-number">8</span>、桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽 象和实现这两个可变维度的耦合度。 <span class="hljs-number">9</span>、装饰（Decorator）模式：动态的给对象增加一些职责，即增加其额外的功能。 <span class="hljs-number">10</span>、外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。 <span class="hljs-number">11</span>、享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。 <span class="hljs-number">12</span>、组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。 <span class="hljs-number">13</span>、模板方法（TemplateMethod）模式：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以 不改变该算法结构的情况下重定义该算法的某些特定步骤。 <span class="hljs-number">14</span>、策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响 使用算法的客户。 <span class="hljs-number">15</span>、命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。 <span class="hljs-number">16</span>、职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通 过这种方式去除对象之间的耦合。 <span class="hljs-number">17</span>、状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。 <span class="hljs-number">18</span>、观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象， 从而影响其他对象的行为。 <span class="hljs-number">19</span>、中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有 对象之间不必相互了解。 <span class="hljs-number">20</span>、迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。 <span class="hljs-number">21</span>、访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多 个访问者对象访问。 <span class="hljs-number">22</span>、备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。 <span class="hljs-number">23</span>、解释器（Interpreter）模式：提供如何定义语言的放法，以及对语言句子的解释方法，即解释器。</code></pre><h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><p>面向对象编程常用的设计原则包括7个，这些原则并不是孤立存在的，它们相互依赖，相互补充。</p><ul><li>单一职责原则(Single Responsibility Principle, SRP)：类的职责要单一，不能将太多的职责放在一个类中。该原则是实现高内聚、低耦合的指导方针。</li><li>开闭原则(OpenClosed Principle, OCP)：一个软件实体应当对扩展开放，对修改关闭。即在不修改源代码的情<br>况下改变对象的行为。</li><li>里氏代换原则(Liskov Substitution Principle, LSP)：在软件系统中，一个可以接受基类(父类)对象的地方必然可以接受一个子类对象。里氏原则属于开闭原则的实现。</li><li>依赖倒转原则(Dependency Inversion Principle,DIP)：抽象不应该依赖于细节(实现)，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。 用到接口的地方，通过依赖注入将接口的实现对象注入进去。</li><li>接口隔离原则(Interface Segregation Principle, ISP)：使用多个专门的接口来取代一个统一的接口。</li><li>合成复用原则(Composite Reuse Principle, CRP)：在系统中应该尽量多使用组合和聚合关联，尽量少使用甚至不使用继承关系。</li><li>迪米特法则(Law of Demeter, LoD)：一个软件实体应当尽可能少地与其他实体发生相互作用。通过引入一个合理的第三者来降低现有对象之间的耦合度。</li></ul><h4 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h4><p><strong>定义：</strong>一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中。</p><p><strong>解说：</strong>一个类（或者大到模块，小到方法）承担的职责越多，它被复用的可能性越小，而且如果一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作。类的职责主要包括两个方面：数据职责和行为职责，数据职责通过其属性来体现，而行为职责通过其方法来体现。单一职责原则是实现高内聚、低耦合的指导方针，在很多代码重构方法中都能找到它的存在，它是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，而发现类的多重职责需要设计人员具有较强的分析设计能力和相关重构经验。</p><h4 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h4><p><strong>定义：</strong>一个软件实体应当对扩展开放，对修改关闭。也就是说在设计一个模块的时候，应当使这个模块可以在不被修改的前提下被扩展，即实现在不修改源代码的情况下改变这个模块的行为。</p><p><strong>解说：</strong>开闭原则还可以通过一个更加具体的“对可变性封装原则”来描述，对可变性封装原则(EVP)要求找到系统的可变因素并将其封装起来。如果一个软件设计符合开闭原则，那么可以非常方便地对系统进行扩展，而且在扩展时无须修改现有代码，使得软件系统在拥有适应性和灵活性的同时具备较好的稳定性和延续性。为了满足开闭原则，需要对系统进行抽象化设计，抽象化是开闭原则的关键。</p><h4 id="里氏代换原则"><a href="#里氏代换原则" class="headerlink" title="里氏代换原则"></a>里氏代换原则</h4><p><strong>定义：</strong>所有引用基类（父类）的地方必须能透明地使用其子类的对象。</p><p><strong>解说：</strong>里氏代换原则可以通俗表述为：在软件中将一个基类对象替换成它的子类对象，程序将不会产生任 何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不 一定能够使用基类对象。里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对 象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用 子类对象来替换父类对象。</p><p><strong>使用里氏代换原则需要注意</strong>：</p><p>(1)子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。根据里氏代 换原则，为了保证系统的扩展性，在程序中通常使用父类来进行定义，如果一个方法只存在子类中，在父类中不提供相应的声明，则无法在以父类定义的对象中使用该方法</p><p>(2) 我们在运用里氏代换原则时，尽量把父类设计为抽象类或者接口，让子类继承父类或实现 父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地 扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类 来实现。里氏代换原则是开闭原则的具体实现手段之一。</p><p>(3) Java语言中，在编译阶段，Java编译器会检查一个程序是否符合里氏代换原则，这是一个 与实现无关的、纯语法意义上的检查，但Java编译器的检查是有局限的。</p><h4 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h4><p><strong>定义：</strong>抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。</p><p><strong>注意点：</strong>依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层 类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据 类型的转换等，而不要用具体类来做这些事情。为了确保该原则的应用，一个具体类应当只 实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增 加的新方法。</p><p>在引入抽象层后，系统将具有很好的灵活性，在程序中尽量使用抽象层进行编程，而将具体 类写在配置文件中，这样一来，如果系统行为发生变化，只需要对抽象层进行扩展，并修改 配置文件，而无须修改原有系统的源代码，在不修改的情况下来扩展系统的功能，满足开闭原则的要求。</p><p>在实现依赖倒转原则时，我们需要针对抽象层编程，而将具体类的对象通过依赖注入 (DependencyInjection, DI)的方式注入到其他对象中，依赖注入是指当一个对象要与其他对象发 生依赖关系时，通过抽象来注入所依赖的对象。常用的注入方式有三种，分别是：构造注 入，设值注入（Setter注入）和接口注入。构造注入是指通过构造函数来传入具体类的对象， 设值注入是指通过Setter方法来传入具体类的对象，而接口注入是指通过在接口中声明的业务 方法来传入具体类的对象。这些方法在定义时使用的是抽象类型，在运行时再传入具体类型 的对象，由子类对象来覆盖父类对象。</p><p><strong>总结</strong>：</p><ol><li>针对接口编程</li><li>在接口或抽象类中定义方法、声明变量</li><li>类只实现接口或抽象类中的方法，不要定义多余的方法</li><li>给抽象对象或接口注入依赖对象时，采用依赖注入方式</li></ol><h4 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h4><p><strong>定义：</strong>使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。</p><p><strong>讲解：</strong>接口仅仅提供客户端 需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口， 而不要提供大的总接口。在面向对象编程语言中，实现一个接口就需要实现该接口中定义的 所有方法，因此大的总接口使用起来不一定很方便，为了使接口的职责单一，需要将大接口 中的方法根据其职责不同分别放在不同的小接口中，以确保每个接口使用起来都较为方便， 并都承担某一单一角色。接口应该尽量细化，同时接口中的方法应该尽量少，每个接口中只 包含一个客户端（如子模块或业务逻辑类）所需的方法即可，这种机制也称为“定制服务”，即为不同的客户端提供宽窄不同的接口。</p><p><strong>总结：</strong>需要用到哪些方法，接口中就只提供哪些方法，用不到的方法，接口中不提供。</p><p><strong>注意：</strong>我们需要注意控制接口的粒度，接口不能太小，如果太小会导致系 统中接口泛滥，不利于维护；接口也不能太大，太大的接 </p><p>口将违背接口隔离原则，灵活性较 差，使用起来很不方便。一般而言，接口中仅包含为某一类用户定制的方法即可，不应该 </p><p>强迫客户依赖于那些它们不用的方法。</p><h4 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h4><p><strong>定义：</strong>尽量使用对象组合，而不是继承来达到复用的目的。</p><p><strong>讲解：</strong>合成复用原则就是在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些 已有的对象，使之成为新对象的一部分；新对象通过委派调用已有对象的方法达到复用功能 的目的。简言之：复用时要尽量使用组合/聚合关系（关联关系），少用继承。</p><p>在面向对象设计中，可以通过两种方法在不同的环境中复用已有的设计和实现，即通过组合/ 聚合关系或通过继承，但首先应该考虑使用组合/聚合，组合/聚合可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少；其次才考虑继承，在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继 承复用。</p><p>通过继承来进行复用的主要问题在于继承复用会破坏系统的封装性，因为继承会将基类的实 现细节暴露给子类，由于基类的内部细节通常对子类来说是可见的，所以这种复用又称“白 箱”复用，如果基类发生改变，那么子类的实现也不得不发生改变；由于组合或聚合关系可以将已有的对象（也可称为成员对象）纳入到新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能，这样做可以使得成员对象的内部实现 细节对于新对象不可见。</p><p><strong>总结：</strong>复用的方式： </p><ol><li>组合/聚合关系实现复用 </li><li>继承实现复用 </li></ol><p>继承复用问题：会破坏系统的封装性，会把基类实现暴露给子类。 </p><p>组合/聚合复用：已有对象的功能细节，对组合而成的新对象是不可见的，封装性教好。</p><h4 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h4><p><strong>定义：</strong>一个软件实体应当尽可能少地与其他实体发生相互作用。</p><p><strong>讲解：</strong>如果一个系统符合迪米特法则，那么当其中某一个模块发生修改时，就会尽量少地影响其他模块，扩展会相对容易，这是对软件实体之间通信的限制，迪米特法则要求限制软件实体之 间通信的宽度和深度。迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系。迪米特法则要求我们在设计系统时，应该尽量减少对象之间的交互，如果两个对象之间不必 彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需 要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用。简言之，就是<strong>通过引 入一个合理的第三者来降低现有对象之间的耦合度</strong>。</p><p><strong>作用：</strong>降低系统的耦合度</p><h3 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h3><p>GOF中共提到了23种设计模式不是孤立存在的，很多模式之间存在一定的关联关系，在大的系统开发中常常同时使用多种设计模式。这23种设计模式根据功能作用来划分，可以划分为3类：</p><ol><li>创建型模式：用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”，单例、原型、工厂方法、抽象工厂、建造者5种设计模式属于创建型模式。</li><li>结构型模式：用于描述如何将类或对象按某种布局组成更大的结构，代理、适配器、桥接、装饰、外观、享元、组合7种设计模式属于结构型模式。</li><li>行为型模式：用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责。模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器11种设计模式属于行为型模式。</li></ol>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>GOF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译优化</title>
    <link href="/blog/2020/07/14/JVM-%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96/"/>
    <url>/blog/2020/07/14/JVM-%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h3 id="前端编译器"><a href="#前端编译器" class="headerlink" title="前端编译器"></a>前端编译器</h3><p>前端编译器就是将*.java文件编译成*.class文件的过程。</p><p>前端编译器能够做的优化是非常有限的，主要的优化工作在后端编译器完成。</p><h4 id="javac编译过程"><a href="#javac编译过程" class="headerlink" title="javac编译过程"></a>javac编译过程</h4><p>javac的编译过程大致可以分为1个准备过程和3个处理过程，它们分别如下所示。</p><ol><li><p>准备过程：初始化插入式注解处理器。</p></li><li><p>解析与填充符号表过程</p><ul><li>词法、语法分析。将源代码的字符流转变为标记集合，构造出抽象语法树。</li><li>填充符号表。产生符号地址和符号信息。<ul><li>符号表（Symbol Table）是由一组符号地址和符号信息构成的数据结构。</li></ul></li></ul></li><li><p>插入式注解处理器的注解处理过程。</p></li><li><p>分析与字节码生成过程</p><ul><li>标注检查。对语法的静态信息进行检查。</li><li>数据流及控制流分析。对程序动态运行过程进行检查。</li><li>解语法糖。将简化代码编写的语法糖还原为原有的形式。</li><li>字节码生成。将前面各个步骤所生成的信息转化成字节码。</li></ul></li></ol><img src="/blog/2020/07/14/JVM-%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96/pic1.png" srcset="/blog/img/loading.gif" class><p>上图是Javac编译动作的入口是com.sun.tools.javac.main.JavaCompiler类主要执行流程，页反应出javac的执行流程。</p><h3 id="后端编译与优化"><a href="#后端编译与优化" class="headerlink" title="后端编译与优化"></a>后端编译与优化</h3><p>后端编译器是指把Class文件转换成与本地基础设施（硬件指令集、操作系统）相关的二进制机器码的过程。</p><p>后端编译器一般分为即时编译器与提前编译器：</p><ul><li>即时编译器：在HotSpot中有三种编译器<ul><li>客户端编译器”（Client Compiler）</li><li>服务端编译器”（Server Compiler）</li><li>Graal编译器（JDK10中出现）</li></ul></li><li>提前编译器<ul><li>Android中的ART就是提前编译器</li></ul></li></ul><h4 id="编译器的优化"><a href="#编译器的优化" class="headerlink" title="编译器的优化"></a>编译器的优化</h4><p>编译器的目标虽然是做由程序代码翻译为本地机器码的工作，但其实难点并不在于能不能成功翻译出机器码，输出代码优化质量的高低才是决定编译器优秀与否的关键。</p><p>OpenJDK的官方Wiki上，HotSpot虚拟机设计团队列出了一个相对比较全面的、即时编译器中采用的优化技术列表，地址：<a href="https://wiki.openjdk.java.net/display/HotSpot/PerformanceTacticIndex" target="_blank" rel="noopener">https://wiki.openjdk.java.net/display/HotSpot/PerformanceTacticIndex</a></p><img src="/blog/2020/07/14/JVM-%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96/pic2.png" srcset="/blog/img/loading.gif" class><p>一般来讲，最具代表性的优化技术有四种，分别是：</p><ul><li>方法内联</li><li>逃逸分析</li><li>公共子表达式消除</li><li>数组边界检查消除</li></ul><h4 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h4><p>方法内联，是指JVM在运行时将调用次数达到一定阈值的方法调用替换为方法体本身，从而消除调用成本，并为接下来进一步的代码性能优化提供基础，是JVM的一个重要优化手段之一。</p><h4 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h4><p>逃逸分析（Escape Analysis）是目前Java虚拟机中比较前沿的优化技术，它并不是直接优化代码的手段，而是为其他优化措施提供依据的分析技术。</p><p>逃逸分析的基本原理是：</p><ul><li>分析对象动态作用域，当一个对象在方法里面被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他方法中，这种称为方法逃逸；</li><li>甚至还有可能被外部线程访问到，譬如赋值给可以在其他线程中访问的实例变量，这种称为线程逃逸；</li><li>从不逃逸、方法逃逸到线程逃逸，称为对象由低到高的不同逃逸程度。</li></ul><p>如果能证明一个对象不会逃逸到方法或线程之外，或者逃逸程度比较低，则可能为这个对象实例采取不同程度的优化。</p><blockquote><p>从JDK 7时服务端编译器默认开启了这项优化服务。</p></blockquote><p>示例（伪代码）：</p><pre><code class="hljs java"><span class="hljs-comment">// 完全未优化的代码 </span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;    <span class="hljs-keyword">int</span> xx = x + <span class="hljs-number">2</span>;    Point p = <span class="hljs-keyword">new</span> Point(xx, <span class="hljs-number">42</span>); <span class="hljs-comment">//包含x和y坐标的POJO return p.getX(); </span>&#125;<span class="hljs-comment">//第一步，将Point的构造函数和getX()方法进行内联优化： </span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;     <span class="hljs-keyword">int</span> xx = x + <span class="hljs-number">2</span>;     Point p = point_memory_alloc(); <span class="hljs-comment">// 在堆中分配P对象的示意方法 </span>    p.x = xx; <span class="hljs-comment">// Point构造函数被内联后的样子 </span>    p.y = <span class="hljs-number">42</span>     <span class="hljs-keyword">return</span> p.x; <span class="hljs-comment">// Point::getX()被内联后的样子 </span>&#125;<span class="hljs-comment">//第二步，经过逃逸分析，发现在整个test()方法的范围内Point对象实例不会发生任何程度的逃逸 </span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;     <span class="hljs-keyword">int</span> xx = x + <span class="hljs-number">2</span>;     <span class="hljs-keyword">int</span> px = xx;     <span class="hljs-keyword">int</span> py = <span class="hljs-number">42</span>;    <span class="hljs-keyword">return</span> px; &#125;<span class="hljs-comment">//第二步的优化，将内存的开销从堆转移到栈，内存空间会随着线程销毁而释放，省去了堆中垃圾回收 等操作 </span><span class="hljs-comment">//第三步，通过数据流分析，发现py的值其实对方法不会造成任何影响，那就可以放心地去做无效代码 消除得到最终优化结果 </span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;     <span class="hljs-keyword">return</span> x + <span class="hljs-number">2</span>;&#125;</code></pre><h4 id="公共子表达式消除"><a href="#公共子表达式消除" class="headerlink" title="公共子表达式消除"></a>公共子表达式消除</h4><p>公共子表达式消除是一项非常经典的、普遍应用于各种编译器的优化技术。</p><p>它的含义是：如果一个表达式E之前已经被计算过了，并且从先前的计算到现在E中所有变量的值都没有发生变化，那么E的这次出现就称为公共子表达式。</p><p>对于这种表达式，没有必要花时间再对它重新进行计算，只需要直接用前面计算过的表达式结果代替E。 </p><h4 id="数组边界检查消除"><a href="#数组边界检查消除" class="headerlink" title="数组边界检查消除"></a>数组边界检查消除</h4><p>数组边界检查消除是即时编译器中的一项语言相关的经典优化技术。</p><p>如果有一个数组foo[]，在Java语言中访问数组元素foo[i]的时候系统将会自动进行上下界的范围检查，即i必须满足“i&gt;=0&amp;&amp;i&lt;foo.length”的访问条件，否则将抛出一个运行时异常：java.lang.ArrayIndexOutOfBoundsException。</p><p>对于虚拟机的执行子系统来说，每次数组元素的读写都带有一次隐含的条件判定操作，对于拥有大量数组访问的程序代码，这必定是一种性能负担。</p><p>对于编译器而言，根据数据流分析来确定是否越界，如果没有越界，那么执行时就不需要再判断了。</p><p>如果在循环中，本身就是通过循环变量来控制对数组的访问，执行时也就不用再判断了，</p><p>这样就可以把整个数组的上下界检查消除掉，这可以节省很多次的条件判断操作。</p>]]></content>
    
    
    <categories>
      
      <category>JVM虚拟机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类加载机制</title>
    <link href="/blog/2020/07/14/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <url>/blog/2020/07/14/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h3><p>Java源代码经过编译器编译成字节码之后，最终都需要加载到虚拟机之后才能运行。虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的<strong>类加载机制</strong>。</p><p>一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载（Loading）、验证（Verifification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）七个阶段，其中验证、准备、解析三个部分统称为连接（Linking）。这七个阶段的发生顺序如下图所示。</p><img src="/blog/2020/07/14/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/pic1.png" srcset="/blog/img/loading.gif" class><p>上图中，加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定特性（也称为动态绑定或晚期绑定）。</p><blockquote><p>需要注意的是，按部就班地“开始”，而不是按部就班地“进行”或按部就班地“完成”，强调这点是因为这些阶段通常都是互相交叉地混合进行的，会在一个阶段执行的过程中调用、激活另一个阶段。</p></blockquote><p>关于在什么情况下需要开始类加载过程的第一个阶段“加载”，《Java虚拟机规范》中并没有进行强制约束，这点可以交给虚拟机的具体实现来自由把握。</p><p>但是对于初始化阶段，《Java虚拟机规范》则是严格规定了有且只有六种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：</p><ul><li><p>遇到 new、getstatic、putstatic 或 invokestatic 这 4 条字节码指令；</p></li><li><p>使用 java.lang.reflflect 包的方法对类进行反射调用的时候；</p></li><li><p>当初始化一个类的时候，发现其父类还没有进行初始化的时候，需要先触发其父类的初始化；</p></li><li><p>当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先初始化这个类；</p></li><li><p>当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有初始化。</p></li><li><p>当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</p></li></ul><p>对于这六种会触发类型进行初始化的场景，《Java虚拟机规范》中使用了一个非常强烈的限定语——“有且只有”，这六种场景中的行为称为对一个类型进行主动引用。除此之外，所有引用类型的方式都不会触发初始化，称为被动引用。</p><p>比如如下几种场景就是被动引用：</p><ul><li>通过子类引用父类的静态字段，不会导致子类的初始化；</li><li>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化；</li></ul><h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>在加载阶段，Java虚拟机需要完成以下三件事情：</p><ul><li><p>通过一个类的全限定名来获取定义此类的二进制字节流。</p></li><li><p>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</p></li><li><p>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</p></li></ul><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>验证是连接阶段的第一步，这一阶段的目的是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。</p><p>验证阶段大致上会完成下面 4 个阶段的检验动作：</p><ul><li><p><strong>文件格式验证</strong></p><ul><li>第一阶段要验证字节流是否符合 Class 文件格式的规范，并且能够被当前版本的虚拟机处理。验证点主要包括：<ul><li>是否以魔数 0xCAFEBABE 开头；</li><li>主、次版本号是否在当前虚拟机处理范围之内；</li><li>常量池的常量中是否有不被支持的常量类型；</li><li>Class 文件中各个部分及文件本身是否有被删除的或者附加的其它信息等等。</li></ul></li></ul></li><li><p><strong>元数据验证</strong></p><ul><li>第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合 Java 语言规范的要求，这个阶段的验证点包括：<ul><li>这个类是否有父类；</li><li>这个类的父类是否继承了不允许被继承的类；</li><li>如果这个类不是抽象类，是否实现了其父类或者接口之中要求实现的所有方法；</li><li>类中的字段、方法是否与父类产生矛盾等等。</li></ul></li></ul></li><li><p><strong>字节码验证</strong></p><ul><li>第三阶段是整个验证过程中最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li></ul></li><li><p><strong>符号引用验证</strong></p><ul><li>最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段–解析阶段中发生。</li><li>符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的各类信息进行匹配性校验，通俗来说就是，该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。</li></ul></li></ul><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段。</p><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>类初始化阶段是类加载过程中的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全是由虚拟机主导和控制的。</p><p>到了初始化阶段，才真正开始执行类中定义的 Java 程序代码。</p><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>Java虚拟机设计团队有意把类加载阶段中的“通过一个类的全限定名来获取描述该类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为“类加载器”（Class Loader）。</p><h4 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h4><p>类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远超类加载阶段。</p><p>对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。</p><p>这句话可以表达得更通俗一些：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。</p><h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p>从 Java 虚拟机的角度来讲，只存在两种不同的类加载器：一种是启动类加载器（BootstrapClassLoader），这个类加载器使用 C++ 来实现，是虚拟机自身的一部分；另一种就是所有其他的类加载器，这些类加载器都由 Java 来实现，独立于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader 。</p><p>从 Java 开发者的角度来看，类加载器可以划分为：</p><ul><li>启动类加载器（Bootstrap ClassLoader）：这个类加载器负责将存放在 <java_home>\lib 目录中的类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，那直接使用 null 代替即可；</java_home></li><li>扩展类加载器（Extension ClassLoader）：这个类加载器由sun.misc.Launcher$ExtClassLoader 实现，它负责加载 <java_home>\lib\ext 目录中，或者被java.ext.dirs 系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器；</java_home></li><li>应用程序类加载器（Application ClassLoader）：这个类加载器由 sun.misc.Launcher$App- ClassLoader 实现。 getSystemClassLoader() 方法返回的就是这个类加载器，因此也被称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库。开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li></ul><p>我们的应用程序都是由这 3 种类加载器互相配合进行加载的，在必要时还可以自己定义类加载器。它们的关系如下图所示：</p><img src="/blog/2020/07/14/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/pic2.png" srcset="/blog/img/loading.gif" class><p>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。</p><p>双亲委派模型的工作过程是：</p><ul><li>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类</li><li>而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此</li><li>因此所有的加载请求最终都应该传送到最顶层的启动类加载器中</li><li>只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。</li></ul><p>这样做的好处就是 Java 类随着它的类加载器一起具备了一种带有优先级的层次关系。例如java.lang.Object，它放在 rt.jar 中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型顶端的启动类加载器来加载，因此Object 类在程序的各种类加载器环境中都是同一个类。</p><p>相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为java.lang.Object 的类，并放在程序的 ClassPath 中，那系统中将会出现多个不同的 Object 类，Java类型体系中最基本的行为也就无法保证了。</p><p>双亲委派模型对于保证Java程序的稳定运作极为重要，但它的实现却异常简单，用以实现双亲委派的代码只有短短十余行，全部集中在java.lang.ClassLoader的loadClass()方法之中：</p><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">synchronized</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-keyword">boolean</span> resolve) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;    <span class="hljs-comment">// 首先，检查请求的类是不是已经被加载过</span>    Class&lt;?&gt; c = findLoadedClass(name);    <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;                c = parent.loadClass(name, <span class="hljs-keyword">false</span>);             &#125; <span class="hljs-keyword">else</span> &#123;                c = findBootstrapClassOrNull(name);            &#125;         &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;            <span class="hljs-comment">// 如果父类抛出 ClassNotFoundException 说明父类加载器无法完成加载</span>        &#125;        <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">// 如果父类加载器无法加载，则调用自己的 findClass 方法来进行类加载</span>            c = findClass(name);        &#125;     &#125;    <span class="hljs-keyword">if</span> (resolve) &#123;         esolveClass(c);     &#125;    <span class="hljs-keyword">return</span> c;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>JVM虚拟机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>类加载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类文件结构</title>
    <link href="/blog/2020/07/14/JVM-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
    <url>/blog/2020/07/14/JVM-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h3 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h3><p>通过winhex软件打开class文件如下：</p><img src="/blog/2020/07/14/JVM-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/pic1.png" srcset="/blog/img/loading.gif" class><h4 id="字节码表"><a href="#字节码表" class="headerlink" title="字节码表"></a>字节码表</h4><p>class文件只有两种数据类型：</p><ul><li>无符号数<ul><li>无符号数可以用来描述数字、索引引用、数量值或按照utf-8编码构成的字符串值。</li><li>其中无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节。</li></ul></li><li>表<ul><li>表是由多个无符号数或其他表构成的复合数据结构。</li><li>所有的表都以“_info”结尾，由于表没有固定长度，所以通常会在其前面加上个数说明。</li></ul></li></ul><table><thead><tr><th>类型</th><th>名称</th><th>说明</th><th>长度</th></tr></thead><tbody><tr><td>u4</td><td>magic</td><td>魔数，识别Class文件格式</td><td>4个字节</td></tr><tr><td>u2</td><td>minor_version</td><td>副版本号</td><td>2个字节</td></tr><tr><td>u2</td><td>major_version</td><td>主版本号</td><td>2个字节</td></tr><tr><td>u2</td><td>constant_pool_count</td><td>常量池计算器</td><td>2个字节</td></tr><tr><td>cp_info</td><td>constant_pool</td><td>常量池</td><td>n个字节</td></tr><tr><td>u2</td><td>access_flflags</td><td>访问标志</td><td>2个字节</td></tr><tr><td>u2</td><td>this_class</td><td>类索引</td><td>2个字节</td></tr><tr><td>u2</td><td>super_class</td><td>父类索引</td><td>2个字节</td></tr><tr><td>u2</td><td>interfaces_count</td><td>接口计数器</td><td>2个字节</td></tr><tr><td>u2</td><td>interfaces</td><td>接口索引集合</td><td>2个字节</td></tr><tr><td>u2</td><td>fields_count</td><td>字段个数</td><td>2个字节</td></tr><tr><td>field_info</td><td>fields</td><td>字段集合</td><td>n个字节</td></tr><tr><td>u2</td><td>methods_count</td><td>方法计数器</td><td>2个字节</td></tr><tr><td>method_info</td><td>methods</td><td>方法集合</td><td>n个字节</td></tr><tr><td>u2</td><td>attributes_count</td><td>附加属性计数器</td><td>2个字节</td></tr><tr><td>attribute_info</td><td>attributes</td><td>附加属性集合</td><td>n个字节</td></tr></tbody></table><h4 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h4><p>在class文件中，前4个字节就是魔数，如下：</p><p>魔数是用来区分文件类型的一种标识，0XCAFEBABE （咖啡豆/咖啡宝贝）表示就是class文件，之所以不使用文件后缀名区别就是后缀名比较容易篡改。</p><img src="/blog/2020/07/14/JVM-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/pic2.png" srcset="/blog/img/loading.gif" class><h4 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h4><p>魔数后面的4位就是版本号了，同样也是4个字节，其中前2个字节表示副版本号，后2个字节表示主版本号。</p><img src="/blog/2020/07/14/JVM-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/pic3.png" srcset="/blog/img/loading.gif" class><p>前面两个字节是0x0000,也就是其值为0; 后面两个字节是0x0034,也就是其值为52； 所以上面的代码就是52.0版本来编译的，也就是jdk1.8.0。</p><img src="/blog/2020/07/14/JVM-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/pic4.png" srcset="/blog/img/loading.gif" class><h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>版本号后就是常量池</p><h4 id="容量计数器"><a href="#容量计数器" class="headerlink" title="容量计数器"></a>容量计数器</h4><img src="/blog/2020/07/14/JVM-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/pic5.png" srcset="/blog/img/loading.gif" class><p>前面两个字节是0x0000,也就是其值为0; 后面两个字节是0x0034,也就是其值为52； 所以上面的代码就是52.0版本来编译的，也就是jdk1.8.0。</p><blockquote><p>与Java中语言习惯不同，这个容量计数是从1而不是0开始的，在Class文件格式规范制定之时，设计者将第0项常量空出来是有特殊考虑的，这样做的目的在于，如果后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义，可以把索引值设置为0来表示。</p></blockquote><h4 id="常量类型和结构"><a href="#常量类型和结构" class="headerlink" title="常量类型和结构"></a>常量类型和结构</h4><p>常量池中的每一项都是一个表，其项目类型共有14种，如下表格所示：</p><table><thead><tr><th>类型</th><th>标志</th><th>描述</th></tr></thead><tbody><tr><td>CONSTANT_utf8_info</td><td>1</td><td>UTF-8编码的字符串</td></tr><tr><td>CONSTANT_Integer_info</td><td>3</td><td>整形字面量</td></tr><tr><td>CONSTANT_Float_info</td><td>4</td><td>浮点型字面量</td></tr><tr><td>CONSTANT_Long_info</td><td>5</td><td>长整型字面量</td></tr><tr><td>CONSTANT_Double_info</td><td>6</td><td>双精度浮点型字面量</td></tr><tr><td>CONSTANT_Class_info</td><td>7</td><td>类或接口的符号引用</td></tr><tr><td>CONSTANT_String_info</td><td>8</td><td>字符串类型字面量</td></tr><tr><td>CONSTANT_Fieldref_info</td><td>9</td><td>字段的符号引用</td></tr><tr><td>CONSTANT_Methodref_info</td><td>10</td><td>类中方法的符号引用</td></tr><tr><td>CONSTANT_InterfaceMethodref_info</td><td>11</td><td>接口中方法的符号引用</td></tr><tr><td>CONSTANT_NameAndType_info</td><td>12</td><td>字段或方法的符号引用</td></tr><tr><td>CONSTANT_MethodHandle_info</td><td>15</td><td>表示方法句柄</td></tr><tr><td>CONSTANT_MothodType_info</td><td>16</td><td>标志方法类型</td></tr><tr><td>CONSTANT_InvokeDynamic_info</td><td>18</td><td>表示一个动态方法调用点</td></tr></tbody></table><p>这14种类型的结构各不相同，如下表格所示：</p><img src="/blog/2020/07/14/JVM-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/pic6.png" srcset="/blog/img/loading.gif" class><blockquote><p>注：此表格的类型的单位不对，不是bit，应该是byte(字节)。</p></blockquote><p>从上面的表格可以看到，虽然每一项的结构都各不相同，但是他们有个共同点，就是每一项的第一个字节都是一个标志位，标识这一项是哪种类型的常量。</p><h4 id="第一个常量"><a href="#第一个常量" class="headerlink" title="第一个常量"></a>第一个常量</h4><img src="/blog/2020/07/14/JVM-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/pic7.png" srcset="/blog/img/loading.gif" class><p>可以看到，第一个常量的值为10，对应到表中的标志位，找到常量为 CONSTANT_Methodref_info（类中方法的符号引用），它的结构为：</p><img src="/blog/2020/07/14/JVM-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/pic8.png" srcset="/blog/img/loading.gif" class><p>第一个索引值为：0X0009，也就是9，指向常量池中第9项的索引。</p><p>第二个索引值为：0X001E，也就是30，指向常量池中第30项的索引。</p><h4 id="第二个常量"><a href="#第二个常量" class="headerlink" title="第二个常量"></a>第二个常量</h4><img src="/blog/2020/07/14/JVM-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/pic9.png" srcset="/blog/img/loading.gif" class><p>可以看到，第一个常量的值为9，对应到表中的标志位，找到常量为 CONSTANT_Fieldref_info（字段的符号引用），它的结构为：</p><img src="/blog/2020/07/14/JVM-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/pic10.png" srcset="/blog/img/loading.gif" class><p>后面的4个字节都是它的内容，记录着2个索引值：</p><img src="/blog/2020/07/14/JVM-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/pic11.png" srcset="/blog/img/loading.gif" class><p>第一个索引值为：0X0004，也就是4，指向常量池中第4项的索引。</p><p>第二个索引值为：0X001F，也就是31，指向常量池中第31项的索引。</p><h3 id="描述符"><a href="#描述符" class="headerlink" title="描述符"></a>描述符</h3><h4 id="字段描述符"><a href="#字段描述符" class="headerlink" title="字段描述符"></a>字段描述符</h4><p>官网：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.3.2" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.3.2</a></p><table><thead><tr><th>FieldType term</th><th>Type</th><th>Interpretation</th></tr></thead><tbody><tr><td>B</td><td>byte</td><td>signed byte</td></tr><tr><td>C</td><td>char</td><td>Unicode character code point in the Basic Multilingual Plane, encoded with UTF-16</td></tr><tr><td>D</td><td>double</td><td>double-precision flfloating-point value</td></tr><tr><td>E</td><td>float</td><td>single-precision flfloating-point value</td></tr><tr><td>F</td><td>int</td><td>integer</td></tr><tr><td>J</td><td>long</td><td>long integer</td></tr><tr><td>LClassName</td><td>reference</td><td>an instance of class <em>ClassName</em></td></tr><tr><td>S</td><td>short</td><td>signed short</td></tr><tr><td>Z</td><td>boolean</td><td>true or false</td></tr><tr><td>[</td><td>reference</td><td>one array dimension</td></tr></tbody></table><h4 id="方法描述符"><a href="#方法描述符" class="headerlink" title="方法描述符"></a>方法描述符</h4><p>官网：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.3.3" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.3.3</a></p><p>示例：</p><p>The method descriptor for the method:</p><pre><code class="hljs java"><span class="hljs-function">Object <span class="hljs-title">m</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">double</span> d, Thread t)</span> </span>&#123;...&#125;</code></pre><p>is</p><pre><code class="hljs java">(IDLjava/lang/Thread;)Ljava/lang/Object;</code></pre>]]></content>
    
    
    <categories>
      
      <category>JVM虚拟机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>class文件结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GC日志分析工具</title>
    <link href="/blog/2020/07/14/JVM-GC%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/"/>
    <url>/blog/2020/07/14/JVM-GC%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<h3 id="GC日志输出参数"><a href="#GC日志输出参数" class="headerlink" title="GC日志输出参数"></a>GC日志输出参数</h3><pre><code class="hljs groovy">-<span class="hljs-string">XX:</span>+PrintGC 输出GC日志-<span class="hljs-string">XX:</span>+PrintGCDetails 输出GC的详细日志-<span class="hljs-string">XX:</span>+PrintGCTimeStamps 输出GC的时间戳（以基准时间的形式） -<span class="hljs-string">XX:</span>+PrintGCDateStamps 输出GC的时间戳（以日期的形式，如 <span class="hljs-number">2013</span><span class="hljs-number">-05</span>- <span class="hljs-number">04</span><span class="hljs-string">T21:</span><span class="hljs-number">53</span>:<span class="hljs-number">59.234</span>+<span class="hljs-number">0800</span>） -<span class="hljs-string">XX:</span>+PrintHeapAtGC 在进行GC的前后打印出堆的信息 -<span class="hljs-string">Xloggc:</span>..<span class="hljs-regexp">/logs/</span>gc.log 日志文件的输出路径</code></pre><h3 id="GC-Easy可视化工具"><a href="#GC-Easy可视化工具" class="headerlink" title="GC Easy可视化工具"></a>GC Easy可视化工具</h3><p>GC Easy是一款在线的可视化工具，易用、功能强大，地址：<a href="http://gceasy.io/" target="_blank" rel="noopener">http://gceasy.io/</a></p><img src="/blog/2020/07/14/JVM-GC%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/pic1.png" srcset="/blog/img/loading.gif" class><p>上传后，点击Analyze按钮，即可查看报告。</p><h4 id="JVM内存统计"><a href="#JVM内存统计" class="headerlink" title="JVM内存统计"></a>JVM内存统计</h4><img src="/blog/2020/07/14/JVM-GC%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/pic2.png" srcset="/blog/img/loading.gif" class><p>上图中的年轻代与老年代在高峰时，可用空间基本都占满了，说明内存空间不足，需要调整内存大小。</p><img src="/blog/2020/07/14/JVM-GC%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/pic5.png" srcset="/blog/img/loading.gif" class><p>调整内存区域后，基本符合需求</p><h4 id="关键指标"><a href="#关键指标" class="headerlink" title="关键指标"></a>关键指标</h4><img src="/blog/2020/07/14/JVM-GC%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/pic6.png" srcset="/blog/img/loading.gif" class><p>关键指标中，吞吐量为98.694%，gc平均停顿时间为8.19ms，最大停顿时间为180ms。</p><p>可以看出，在初始状态时，吞吐量并不高，最大停顿时间较长，平均停顿时间表现不错。</p><h4 id="图表"><a href="#图表" class="headerlink" title="图表"></a>图表</h4><img src="/blog/2020/07/14/JVM-GC%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/pic3.png" srcset="/blog/img/loading.gif" class><p>在图表中可以看出，gc之后堆内存的使用基本是在60m ~ 80m之间。</p><img src="/blog/2020/07/14/JVM-GC%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/pic7.png" srcset="/blog/img/loading.gif" class><p>在图表中可以看出，gc之前的堆内存的使用在高峰时，将占用到80m ~ 120m之间。</p><img src="/blog/2020/07/14/JVM-GC%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/pic8.png" srcset="/blog/img/loading.gif" class><p>在gc持续时间统计中，可以看出full gc的时间要远高于young gc的时间，在调优时应当尽量的减少full gc。</p><img src="/blog/2020/07/14/JVM-GC%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/pic9.png" srcset="/blog/img/loading.gif" class><p>在清理垃圾的统计中，可以看出gc清理的垃圾基本维持在40m左右，最多的一次是发生在full gc，可以推断此次是内存即将耗尽，发生了full gc，释放了大量的内存空间，这可能是之前由于年轻代空间不足，年轻代对象有部分进入到老年代，在此次full gc时被清理了。</p><img src="/blog/2020/07/14/JVM-GC%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/pic10.png" srcset="/blog/img/loading.gif" class><p>从年轻代的gc情况来看，gc之前与gc之后差较大，说明垃圾对象在年轻代被清理的比较多，就是说临时性的对象居多。</p><img src="/blog/2020/07/14/JVM-GC%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/pic11.png" srcset="/blog/img/loading.gif" class><p>从老年代的gc情况来看，gc之前与之后的差并不大，说明老年代的垃圾对象并不是很多。</p><img src="/blog/2020/07/14/JVM-GC%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/pic12.png" srcset="/blog/img/loading.gif" class><p>Meta Space空间充足，基本没有变化，占用空间40m左右。</p><img src="/blog/2020/07/14/JVM-GC%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/pic13.png" srcset="/blog/img/loading.gif" class><p>从该图中看出，晋升到老年代的对象与可以分配对象相比，非常的少，也说明了上面我们看到的，对象主要集中在young区。</p><h4 id="GC统计"><a href="#GC统计" class="headerlink" title="GC统计"></a>GC统计</h4><img src="/blog/2020/07/14/JVM-GC%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/pic4.png" srcset="/blog/img/loading.gif" class><ul><li>Minor GC清理掉的垃圾对象合计24.13gb，说明产生的临时对象非常的多</li><li>Minor GC的执行间隔为636ms，说明发生gc的行为是比较频繁的</li><li>Full GC发生了10次，较为频繁</li><li>Full GC的平均持续时间为90ms，时间较长</li><li>GC的暂停次数为690次，暂停次数将影响到服务的响应时间</li></ul><h4 id="对象统计"><a href="#对象统计" class="headerlink" title="对象统计"></a>对象统计</h4><img src="/blog/2020/07/14/JVM-GC%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/pic14.png" srcset="/blog/img/loading.gif" class><p>在对象的统计中，可以看出对象的平均生成率：57.85m/s，平均的晋升率：610kb/s。</p><h4 id="调优建议"><a href="#调优建议" class="headerlink" title="调优建议"></a>调优建议</h4><ul><li><p>生产环境的JVM一定要进行参数设定，不能全部默认上生产。</p></li><li><p>对于参数的设定，不能拍脑袋，需要通过实际并发情况或压力测试得出结论。</p></li><li><p>对于内存中对象临时存在居多的情况，将年轻代调大一些。如果是G1或ZGC，不需要设定。</p></li><li><p>仔细分析gc easy给出的报告，从中分析原因，找出问题。</p></li><li><p>对于低延迟的应用建议使用G1或ZGC垃圾收集器。</p></li><li><p>不要将焦点全部聚焦jvm参数上，影响性能的因素有很多，比如：操作系统、tomcat本身的参数等。</p></li></ul><h3 id="PerfMa"><a href="#PerfMa" class="headerlink" title="PerfMa"></a>PerfMa</h3><p>PerfMa提供了JVM参数分析、线程分析、堆内存分析功能，界面美观，功能强大，我们在做jvm调优时，可以作为一个辅助工具。官网：<a href="https://www.perfma.com/" target="_blank" rel="noopener">https://www.perfma.com/</a></p><img src="/blog/2020/07/14/JVM-GC%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/pic16.png" srcset="/blog/img/loading.gif" class><h4 id="XXFox"><a href="#XXFox" class="headerlink" title="XXFox"></a>XXFox</h4><p>XXFox是Java虚拟机参数分析工具，可以对JVM参数进行查询、检查、优化等。</p><p>参数优化：</p><img src="/blog/2020/07/14/JVM-GC%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/pic17.png" srcset="/blog/img/loading.gif" class><p>参数生成：</p><img src="/blog/2020/07/14/JVM-GC%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/pic18.png" srcset="/blog/img/loading.gif" class><h4 id="XSheepdog"><a href="#XSheepdog" class="headerlink" title="XSheepdog"></a>XSheepdog</h4><p>XSheepdog是Java线程Dump分析工具，通过jstack生成线程的dump文件，进行分析。</p><img src="/blog/2020/07/14/JVM-GC%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/pic19.png" srcset="/blog/img/loading.gif" class><h4 id="XElephant"><a href="#XElephant" class="headerlink" title="XElephant"></a>XElephant</h4><p>XElephant是Java内存Dump分析工具。</p><p>获取内存 Dump 文件的命令：<code>jmap -dump:format=b,file=[生成的文件名] [进程号]</code></p><p>生成 Dump 文件后，就可以通过控制台 &gt; Java内存Dump分析 ，选择合适的途径上传到服务器进行分析。</p><img src="/blog/2020/07/14/JVM-GC%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/pic20.png" srcset="/blog/img/loading.gif" class><h3 id="高并发系统下的调优思路"><a href="#高并发系统下的调优思路" class="headerlink" title="高并发系统下的调优思路"></a>高并发系统下的调优思路</h3><img src="/blog/2020/07/14/JVM-GC%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/pic21.png" srcset="/blog/img/loading.gif" class><ul><li><p>百亿流量的电商网站，一般日活跃用户可能在1亿左右，大促期间的参与人较平常会增加很多，比如5亿左右。</p></li><li><p>电商系统的业务线非常多，大促期间压力最大的属订单、支付业务，我们聚焦到订单系统。</p></li><li><p>假设，部署了订单系统的微服务数量为100，每台机器4核8G内存。</p></li><li><p>一般情况下，电商网站的付费转化率为10%左右，所以，1亿的活跃用户会产生1000w订单。</p><ul><li>一天24小时，以12小时下单时间计算，每小时产生83w订单，每秒钟产生230左右个订单。</li><li>平均到100台机器，每台机器2~3个订单/秒，可以说毫无压力。</li></ul></li><li><p>大促期间，转化量会提升，假设提升到50%左右，所以，5亿活跃用户会产生2.5亿订单。</p><ul><li>大促期间的用户下单与平常的有所不同，这里我们假设，一天下单时间以20小时计算，前1小时，下单30%，其它时间段产生70%的订单。</li><li>前一小时产生30%订单，也就是7千500万订单，每秒钟将会产生20833个订单，分摊到100台服务器，每台服务器208个/秒订单的产生。</li><li>其它时间段产生70%的订单，也就是1亿7千5百万个订单，每小时产生920万订单，每秒产生2558个订单，分摊到100台机器，每天机器26个/秒订单的产生。</li></ul></li><li><p>通过上面的分析，一般情况和大促的非集中时间段，产生的订单量较少，每台机器的压力并不大，所以我们只需要关注大促开始的1小时的压力即可。</p></li><li><p>假设每个订单对象的大小为1KB，考虑到每个订单的产生会有复杂的业务流程，我们将订单对象大小扩大100倍，也就是，每产生一个订单对象，会占用100KB的内存空间。</p></li><li><p>也就是说，在大促期间，前一小时，每秒钟占用的内存空间为：100KB * 208 = 20800KB 也就是20M左右空间。</p></li><li><p>每台机器的内存是8G，除去操作系统、监控等内存开销，配置到jvm虚拟机的堆内存空间为6G。</p></li><li><p>考虑到订单对象在内存中创建后，会很快被持久化到数据库，随后就会GC回收，所以属于短暂性存活对象，尽可能的让其待在年轻代，避免过多的对象进入老年代，从而导致Full GC。 </p></li><li><p>在JDK8中，建议使用G1垃圾收集器，下面是给出的jvm主要参数建议：</p><ul><li><p><code>-XX:+UnlockExperimentalVMOptions -XX:+UseG1GC -Xmx6G - XX:MetaspaceSize=128m -XX:MaxGCPauseMillis=100 - XX:G1NewSizePercent=50 -XX:G1MaxNewSizePercent=80</code></p></li><li><p>-XX:G1NewSizePercent</p></li><li><p>设置要用作年轻代大小最小值的堆百分比。默认值是 Java 堆的 5%。（实验性质参数）</p></li><li><p>-XX:G1MaxNewSizePercent</p><ul><li>设置要用作年轻代大小最大值的堆大小百分比。默认值是 Java 堆的 60%。（实验性质参数）</li></ul></li><li><p>该参数仅供参考，需根据实际环境配置</p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>JVM虚拟机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GC分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM的垃圾收集</title>
    <link href="/blog/2020/07/13/JVM-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/"/>
    <url>/blog/2020/07/13/JVM-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h3 id="判断对象的存活"><a href="#判断对象的存活" class="headerlink" title="判断对象的存活"></a>判断对象的存活</h3><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>给对象添加一个引用计数器，任何一个对象对该对象引用时计数器加1，引用失效时计数器减1。引用计数为0的对象可被回收（Python在用，但主流虚拟机没有使用）。</p><p>优点：</p><ul><li><p>实时性高，运行时根据对象计数器为0就可以直接回收，无需等待内存不够时才回收。</p></li><li><p>得益于其实时性，在垃圾回收过程中，不需要停顿。且如果内存不足，则立刻报outofmember 错误。</p></li><li><p>区域性，更新对象计数器时，只是影响该对象，不会扫描全部对象。</p></li></ul><p>缺点：</p><ul><li>每次被引用时，都需要更新计数器，有时间开销。</li><li>即使内存够用，运行时仍要进行统计，浪费CPU资源。</li><li>无法解决循环依赖问题。</li></ul><h4 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h4><p>通过一系列的称为GC Roots的对象作为起始节点集，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。</p><p>作为GC Roots的对象包括下面几种：</p><ul><li>在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。</li><li>在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。</li><li>在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。</li><li>在本地方法栈中JNI（即通常所说的Native方法）引用的对象。</li><li>Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。</li><li>所有被同步锁（synchronized关键字）持有的对象。</li><li>反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li></ul><h3 id="对象的引用（Reference）"><a href="#对象的引用（Reference）" class="headerlink" title="对象的引用（Reference）"></a>对象的引用（Reference）</h3><p>java中的引用可分为：</p><ul><li><p>强引用（ Strongly Re-ference ）：代码中普遍存在的引用类型，Object obj = new Object() ，就属于强引用。只要引用关系还在，垃圾回收器就永远不会回收被引用的对象。</p></li><li><p>软引用（SoftReference）：用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列 进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。</p></li><li><p>弱引用（WeakReference）：用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能存活到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</p></li><li><p>虚引用（Phantom Reference）：最弱的一种引用关系，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。</p></li></ul><h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><h4 id="标记-清除算法（Mark-Sweep）"><a href="#标记-清除算法（Mark-Sweep）" class="headerlink" title="标记-清除算法（Mark-Sweep）"></a>标记-清除算法（Mark-Sweep）</h4><p>标记清除算法，是将垃圾回收分为2个阶段，分别是标记和清除。</p><ul><li><p>标记：从根节点开始标记引用的对象。</p></li><li><p>清除：未被标记引用的对象就是垃圾对象，可以被清理。</p></li></ul><p>标记清除法可以说是最基础的收集算法，因为后续的收集算法大多都是以标记-清除算法为基础，对其缺点进行改进而得到的。</p><p>缺点：</p><ul><li><p>执行效率较低，标记和清除两个动作都需要遍历所有的对象，并且在GC时，需要停止应用程序，对于交互性要求比较高的应用而言这个体验是非常差的。</p></li><li><p>通过标记清除算法清理出来的内存，碎片化较为严重，因为被回收的对象可能存在于内存的各个角落，所以清理出来的内存是不连贯的。</p></li></ul><h4 id="标记-整理算法（Mark-Compact）"><a href="#标记-整理算法（Mark-Compact）" class="headerlink" title="标记-整理算法（Mark-Compact）"></a>标记-整理算法（Mark-Compact）</h4><p>标记压缩算法是在标记清除算法的基础之上，做了优化改进的算法。和标记清除算法一样，也是从根节点开始，对对象的引用进行标记，在清理阶段，并不是简单的清理未标记的对象，而是将存活的对象压缩到内存的一端，然后清理边界以外的垃圾，从而解决了碎片化的问题。</p><p>标记压缩算法是在标记清除算法的基础之上，做了优化改进的算法。和标记清除算法一样，也是从根节点开始，对对象的引用进行标记，在清理阶段，并不是简单的清理未标记的对象，而是将存活的对象压缩到内存的一端，然后清理边界以外的垃圾，从而解决了碎片化的问题。</p><h4 id="复制算法（Copying）"><a href="#复制算法（Copying）" class="headerlink" title="复制算法（Copying）"></a>复制算法（Copying）</h4><p>复制算法的核心就是，将原有的内存空间一分为二，每次只用其中的一块，在垃圾回收时，将正在使用的对象复制到另一个内存空间中，然后将该内存空间清空，交换两个内存的角色，完成垃圾的回收。</p><p>如果内存中的垃圾对象较多，需要复制的对象就较少，这种情况下适合使用该方式并且效率比较高，反之，则不适合。</p><h5 id="JVM中年轻代内存空间"><a href="#JVM中年轻代内存空间" class="headerlink" title="JVM中年轻代内存空间"></a>JVM中年轻代内存空间</h5><img src="/blog/2020/07/13/JVM-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/pic1.png" srcset="/blog/img/loading.gif" class><ol><li><p>在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。</p></li><li><p>紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中， 仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。</p></li><li><p>经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。</p></li><li><p>GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。</p></li></ol><h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><p>优点：</p><ul><li>在垃圾对象多的情况下，效率较高。</li><li>清理后，内存无碎片。</li></ul><p>缺点：</p><ul><li><p>在垃圾对象少的情况下，不适用，如：老年代内存</p></li><li><p>分配的2块内存空间，在同一个时刻，只能使用一半，内存使用率较低。</p></li></ul><h4 id="分代算法"><a href="#分代算法" class="headerlink" title="分代算法"></a>分代算法</h4><p>在堆内存中，有些对象短暂存活有些则是长久存活，所以需要将堆内存进行分代，将短暂存活的对象放到一起，进行高频率的回收，长久存活的对象集中放到一起，进行低频率的回收，这样才能够更加合理的利系统资源。</p><p>分代算法其实就是这样的，根据回收对象的特点进行选择，在jvm中，年轻代适合使用复制算法，老年代适合使用标记清除或标记压缩算法。</p><p>垃圾回收的相关概念：</p><ul><li><p>部分收集（Partial GC）  </p><ul><li>新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集。</li><li>老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集。</li><li>混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。</li></ul></li><li><p>整堆收集（Full GC） </p></li></ul><h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p>HotSpot虚拟机中，常见的集中垃圾收集器组合方式：</p><img src="/blog/2020/07/13/JVM-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/pic2.png" srcset="/blog/img/loading.gif" class><h4 id="串行收集器"><a href="#串行收集器" class="headerlink" title="串行收集器"></a>串行收集器</h4><p>串行收集器是指使用单线程进行垃圾回收，垃圾回收时，只有一个线程在工作，并且java应用中的所有线程都要暂停，等待垃圾回收完成。这种现象称之为STW（Stop-The-World）。</p><h5 id="Serial-Serial-Old收集器"><a href="#Serial-Serial-Old收集器" class="headerlink" title="Serial/Serial Old收集器"></a>Serial/Serial Old收集器</h5><p>最古老、成熟的单线程（独占式）收集器，适用于单CPU 服务器。</p><p>Serial采用复制算法回收区域为新生代，Serial Old使用标记整理算法回收区域为老年代。</p><h5 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h5><p>在jvm参数中加入-XX:+PrintGCDetails</p><pre><code class="hljs scheme">[<span class="hljs-name">GC</span> (<span class="hljs-name">Allocation</span> Failure) [<span class="hljs-name">DefNew:</span> <span class="hljs-number">4416</span>K-&gt;512K(<span class="hljs-name">4928K</span>), <span class="hljs-number">0.0046102</span> secs] <span class="hljs-number">4416</span>K-&gt;1973K(<span class="hljs-name">15872K</span>), <span class="hljs-number">0.0046533</span> secs] [<span class="hljs-name">Times:</span> user=0.00 sys=0.00, real=0.00 secs] [<span class="hljs-name">Full</span> GC (<span class="hljs-name">Allocation</span> Failure) [<span class="hljs-name">Tenured:</span> <span class="hljs-number">10944</span>K-&gt;3107K(<span class="hljs-name">10944K</span>), <span class="hljs-number">0.0085637</span> secs] <span class="hljs-number">15871</span>K-&gt;3107K(<span class="hljs-name">15872K</span>), [<span class="hljs-name">Metaspace:</span> <span class="hljs-number">3496</span>K- &gt;3496K(<span class="hljs-name">1056768K</span>)], <span class="hljs-number">0.0085974</span> secs] [<span class="hljs-name">Times:</span> user=0.02 sys=0.00, real=0.01 secs]</code></pre><ul><li><p>DefNew：表示使用的是串行垃圾收集器。</p></li><li><p>4416K-&gt;512K(4928K)：表示，年轻代GC前，占有4416K内存，GC后，占有512K内存，总大小4928K</p></li><li><p>0.0046102 secs：表示，GC所用的时间，单位为毫秒。</p></li><li><p>4416K-&gt;1973K(15872K)：表示，GC前，堆内存占有4416K，GC后，占有1973K，总大小为15872K</p></li><li><p>Full GC：表示，内存空间全部进行GC</p></li></ul><h4 id="并行收集器"><a href="#并行收集器" class="headerlink" title="并行收集器"></a>并行收集器</h4><p>并行垃圾收集器在串行垃圾收集器的基础之上做了改进，将单线程改为了多线程进行垃圾回收，这样可以缩短垃圾回收的时间。（这里是指，并行能力较强的机器）</p><p>当然了，并行垃圾收集器在收集的过程中也会暂停应用程序，这个和串行垃圾回收器是一样的，只是并行执行，速度更快些，暂停的时间更短一些。</p><h5 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h5><p>ParNew垃圾收集器是工作在年轻代上的，只是将串行的垃圾收集器改为了并行。通过-XX:+UseParNewGC参数设置年轻代使用ParNew回收器，老年代使用的依然是串行收集器。</p><h5 id="日志分析-1"><a href="#日志分析-1" class="headerlink" title="日志分析"></a>日志分析</h5><pre><code class="hljs angelscript">#参数 -XX:+UseParNewGC -XX:+PrintGCDetails -Xms16m -Xmx16m #打印出的信息 [GC (Allocation Failure) [ParNew: <span class="hljs-number">4416</span>K-&gt;<span class="hljs-number">512</span>K(<span class="hljs-number">4928</span>K), <span class="hljs-number">0.0032106</span> secs] <span class="hljs-number">4416</span>K-&gt;<span class="hljs-number">1988</span>K(<span class="hljs-number">15872</span>K), <span class="hljs-number">0.0032697</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.00</span> secs]</code></pre><p>由以上信息可以看出，ParNew: 使用的是ParNew收集器。其他信息和串行收集器一致。</p><p>也可以通过jmap命令可以查看正在使用的收集器：</p><img src="/blog/2020/07/13/JVM-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/pic6.png" srcset="/blog/img/loading.gif" class><p>Mark Sweep Compact GC 是指串行GC（Serial Old GC）。</p><blockquote><p>其它老年代收集器：</p><ul><li><p>Serial Old (Mark Sweep Compact) 是一种stop-the-world, 使用单个线程进行</p></li><li><p>mark-sweep-compact(标志-清扫-压缩) 收集。</p></li><li><p>Parallel Old (PS Mark Sweep) 是一种使用多个GC线程压缩收集。</p></li><li><p>ConcurrentMarkSweep (CMS) 是最并行，低暂停的收集器。</p></li></ul></blockquote><h5 id="ParallerGC收集器"><a href="#ParallerGC收集器" class="headerlink" title="ParallerGC收集器"></a>ParallerGC收集器</h5><p>ParallelGC收集器工作机制和ParNewGC收集器一样，只是在此基础之上，新增了两个和系统吞吐量相关的参数，使得其使用起来更加的灵活和高效。</p><p>相关参数如下：</p><ul><li><p>-XX:+UseParallelGC：年轻代使用ParallelGC垃圾回收器，老年代使用串行回收器。</p></li><li><p>-XX:+UseParallelOldGC：年轻代使用ParallelGC垃圾回收器，老年代使用ParallelOldGC垃圾回收器。</p></li><li><p>-XX:MaxGCPauseMillis：</p><ul><li>设置最大的垃圾收集时的停顿时间，单位为毫秒</li><li>需要注意的时，ParallelGC为了达到设置的停顿时间，可能会调整堆大小或其他的参数，如果堆的大小设置的较小，就会导致GC工作变得很频繁，反而可能会影响到性能。</li><li>该参数使用需谨慎。</li></ul></li><li><p>-XX:GCTimeRatio：</p><ul><li>设置垃圾回收时间占程序运行时间的百分比，公式为1/(1+n)。</li><li>它的值为0~100之间的数字，默认值为99，也就是垃圾回收时间不能超过1%</li></ul></li><li><p>-XX:UseAdaptiveSizePolicy</p><ul><li>自适应GC模式，垃圾回收器将自动调整年轻代、老年代等参数，达到吞吐量、堆大小、停顿时间之间的平衡。</li><li>一般用于，手动调整参数比较困难的场景，让收集器自动进行调整。</li></ul></li></ul><h5 id="日志分析-2"><a href="#日志分析-2" class="headerlink" title="日志分析"></a>日志分析</h5><pre><code class="hljs angelscript">#参数 -XX:+UseParallelGC -XX:+UseParallelOldGC -XX:MaxGCPauseMillis=<span class="hljs-number">100</span> - XX:+PrintGCDetails -Xms16m -Xmx16m#打印的信息 [GC (Allocation Failure) [PSYoungGen: <span class="hljs-number">4096</span>K-&gt;<span class="hljs-number">480</span>K(<span class="hljs-number">4608</span>K)] <span class="hljs-number">4096</span>K- &gt;<span class="hljs-number">1840</span>K(<span class="hljs-number">15872</span>K), <span class="hljs-number">0.0034307</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.00</span> secs][Full GC (Ergonomics) [PSYoungGen: <span class="hljs-number">505</span>K-&gt;<span class="hljs-number">0</span>K(<span class="hljs-number">4608</span>K)] [ParOldGen: <span class="hljs-number">10332</span>K-&gt;<span class="hljs-number">10751</span>K(<span class="hljs-number">11264</span>K)] <span class="hljs-number">10837</span>K-&gt;<span class="hljs-number">10751</span>K(<span class="hljs-number">15872</span>K), [Metaspace: <span class="hljs-number">3491</span>K- &gt;<span class="hljs-number">3491</span>K(<span class="hljs-number">1056768</span>K)], <span class="hljs-number">0.0793622</span> secs] [Times: user=<span class="hljs-number">0.13</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.08</span> secs]</code></pre><p>有以上信息可以看出，年轻代和老年代都使用了ParallelGC垃圾回收器。</p><h4 id="CMS收集器（Concurrent-Mark-Sweep-）"><a href="#CMS收集器（Concurrent-Mark-Sweep-）" class="headerlink" title="CMS收集器（Concurrent Mark Sweep ）"></a>CMS收集器（Concurrent Mark Sweep ）</h4><p>CMS全称 Concurrent Mark Sweep，是一款并发的、使用标记-清除算法的垃圾回收器，该回收器是针对老年代垃圾回收的，通过参数-XX:+UseConcMarkSweepGC进行设置。</p><img src="/blog/2020/07/13/JVM-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/pic3.png" srcset="/blog/img/loading.gif" class><p>执行过程：</p><ol><li>初始化标记(CMS-initial-mark) ,标记root，会导致stw；</li><li>并发标记(CMS-concurrent-mark)，与用户线程同时运行；</li><li>预清理（CMS-concurrent-preclean），与用户线程同时运行；</li><li>重新标记(CMS-remark) ，会导致stw；</li><li>并发清除(CMS-concurrent-sweep)，与用户线程同时运行；</li><li>调整堆大小，设置CMS在清理之后进行内存压缩，目的是清理内存中的碎片；并发重置状态等待下次CMS的触发(CMS-concurrent-reset)，与用户线程同时运行；</li></ol><h5 id="日志分析-3"><a href="#日志分析-3" class="headerlink" title="日志分析"></a>日志分析</h5><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">设置启动参数</span>-XX:+UseConcMarkSweepGC -XX:+PrintGCDetails -Xms16m -Xmx16m <span class="hljs-meta">#</span><span class="bash">运行日志 </span>[GC (Allocation Failure) [ParNew: 4926K-&gt;512K(4928K), 0.0041843 secs] 9424K-&gt;6736K(15872K), 0.0042168 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] <span class="hljs-meta">#</span><span class="bash">第一步，初始标记 </span>[GC (CMS Initial Mark) [1 CMS-initial-mark: 6224K(10944K)] 6824K(15872K), 0.0004209 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] <span class="hljs-meta">#</span><span class="bash">第二步，并发标记 </span>[CMS-concurrent-mark-start] [CMS-concurrent-mark: 0.002/0.002 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] <span class="hljs-meta">#</span><span class="bash">第三步，预处理 </span>[CMS-concurrent-preclean-start] [CMS-concurrent-preclean: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] <span class="hljs-meta">#</span><span class="bash">第四步，重新标记 </span>[GC (CMS Final Remark) [YG occupancy: 1657 K (4928 K)][Rescan (parallel) , 0.0005811 secs][weak refs processing, 0.0000136 secs] [class unloading, 0.0003671 secs][scrub symbol table, 0.0006813 secs] [scrub string table, 0.0001216 secs][1 CMS-remark: 6224K(10944K)] 7881K(15872K), 0.0018324 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] <span class="hljs-meta">#</span><span class="bash">第五步，并发清理 </span>[CMS-concurrent-sweep-start] [CMS-concurrent-sweep: 0.004/0.004 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] <span class="hljs-meta">#</span><span class="bash">第六步，重置 </span>[CMS-concurrent-reset-start] [CMS-concurrent-reset: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</code></pre><p>由以上日志信息，可以看出CMS执行的过程。</p><p>在整个过程中耗时最长的并发标记、并发清除过程中，收集器线程可以与用户线程一起工作，所以总体上说CMS收集器的内存回收过程是与用户线程一起并发执行的。</p><p>缺点为由于采用标记 - 清除算法会导致产生不连续的空间碎片，在并发阶段多线程占据会占据比较多的CPU资源，如果CPU资源不足，效率会明显降低。</p><p>在CMS并发清理之前，标记过程之后用户线程继续运行产生的垃圾，CMS无法在当次收集中处理掉，只好留待下一次GC时再清理掉，这一部分垃圾就称为浮动垃圾。</p><p>由于浮动垃圾的存在，需要预留出一部分内存，这就意味着CMS收集不能像其它收集器那样等待老年代快满的时候再回收。在1.6的版本中老年代空间使用率阈值为92%。</p><p>如果预留的内存不够存放浮动垃圾，就会出现Concurrent Mode Failure，这时虚拟机将临时启用Serial Old来替代CMS。</p><h4 id="G1垃圾回收器（Garbage-First）"><a href="#G1垃圾回收器（Garbage-First）" class="headerlink" title="G1垃圾回收器（Garbage First）"></a>G1垃圾回收器（Garbage First）</h4><p>G1垃圾收集器是在jdk7中正式使用的全新的垃圾收集器，oracle官方计划在jdk9中将G1变成默认的垃圾收集器，以替代CMS。</p><p>JDK9默认G1为垃圾收集器的提案：<a href="https://openjdk.java.net/jeps/248" target="_blank" rel="noopener">https://openjdk.java.net/jeps/248</a></p><p>将CMS标记为丢弃的提案：<a href="https://openjdk.java.net/jeps/291" target="_blank" rel="noopener">https://openjdk.java.net/jeps/291</a></p><p>G1的设计原则就是简化JVM性能调优，开发人员只需要简单的三步即可完成调优：</p><ol><li><p>第一步，开启G1垃圾收集器</p></li><li><p>第二步，设置堆的最大内存</p></li><li><p>第三步，设置最大的停顿时间</p></li></ol><p>G1中提供了三种模式垃圾回收模式，Young GC、Mixed GC 和 Full GC，在不同的条件下被触发。</p><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>G1垃圾收集器相对比其他收集器而言，最大的区别在于它取消了年轻代、老年代的物理划分，取而代之的是将堆划分为若干个区域（Region），这些区域中包含了有逻辑上的年轻代、老年代区域。</p><p>这样做的好处就是，我们再也不用单独的空间对每个代进行设置了，不用担心每个代内存是否足够。</p><img src="/blog/2020/07/13/JVM-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/pic4.png" srcset="/blog/img/loading.gif" class><p>在G1划分的区域中，年轻代的垃圾收集依然采用暂停所有应用线程的方式，将存活对象拷贝到老年代或者Survivor空间，G1收集器通过将对象从一个区域复制到另外一个区域，完成了清理工作。</p><p>这就意味着，在正常的处理过程中，G1完成了堆的压缩（至少是部分堆的压缩），这样也就不会有cms内存碎片问题的存在了。</p><p>在G1中，有一种特殊的区域，叫Humongous区域。</p><ul><li><p>如果一个对象占用的空间超过了一个分区容量50%以上，G1收集器就认为这是一个巨型对象。</p></li><li><p>这些巨型对象，默认直接会被分配在老年代，但是如果它是一个短期存在的巨型对象，就会对垃圾收集器造成负面影响。</p></li><li><p>为了解决这个问题，G1划分了一个Humongous区，它用来专门存放巨型对象。如果一个H区装不下一个巨型对象，那么G1会寻找连续的H分区来存储。为了能找到连续的H区，有时候不得不启动Full GC。 </p></li><li><p>每个Region的大小可以通过参数-XX：G1HeapRegionSize设定，取值范围为1MB～32MB，且应为2的N次幂。</p></li></ul><h5 id="Young-GC"><a href="#Young-GC" class="headerlink" title="Young GC"></a>Young GC</h5><p>Young GC主要是对Eden区进行GC，它在Eden空间耗尽时会被触发。</p><ul><li><p>Eden空间的数据移动到Survivor空间中，如果Survivor空间不够，Eden空间的部分数据会直接晋升到年老代空间。</p></li><li><p>Survivor区的数据移动到新的Survivor区中，也有部分数据晋升到老年代空间中。</p></li><li><p>最终Eden空间的数据为空，GC停止工作，应用线程继续执行。</p></li></ul><img src="/blog/2020/07/13/JVM-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/pic7.png" srcset="/blog/img/loading.gif" class><img src="/blog/2020/07/13/JVM-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/pic8.png" srcset="/blog/img/loading.gif" class><h5 id="Remobered-Set（已记忆集合）"><a href="#Remobered-Set（已记忆集合）" class="headerlink" title="Remobered Set（已记忆集合）"></a>Remobered Set（已记忆集合）</h5><p>在对年轻代的对象进行GC时，年轻代中对象的根对象是在年轻代中，也可以在老年代中，如果全量扫描老年代，那么这样扫描下来会耗费大量的时间。</p><p>于是，G1引进了RSet的概念。它的全称是Remembered Set，其作用是跟踪指向某个堆内的对象引用。</p><img src="/blog/2020/07/13/JVM-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/pic9.png" srcset="/blog/img/loading.gif" class><p>每个Region初始化时，会初始化一个RSet，该集合用来记录并跟踪其它Region指向该Region中对象的引用，每个Region默认按照512Kb划分成多个Card，所以RSet需要记录的东西应该是 xx Region的 xx Card。 </p><h5 id="Mixed-GC"><a href="#Mixed-GC" class="headerlink" title="Mixed GC"></a>Mixed GC</h5><p>当越来越多的对象晋升到老年代old region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即Mixed GC，该算法并不是一个Old GC，除了回收整个Young Region，还会回收一部分的Old Region，这里需要注意：是一部分老年代，而不是全部老年代，可以选择哪些old region进行收集，从而可以对垃圾回收的耗时时</p><p>间进行控制。也要注意的是Mixed GC 并不是 Full GC。</p><p>MixedGC的触发由参数 -XX:InitiatingHeapOccupancyPercent=n 决定。该参数默认为45%，该参数的意思是：当老年代大小占整个堆大小百分比达到该阀值时触发。</p><p>它的GC步骤分2步：</p><ol><li><p>全局并发标记（global concurrent marking） </p></li><li><p>拷贝存活对象（evacuation） </p></li></ol><h5 id="全局并发标记（global-concurrent-marking）"><a href="#全局并发标记（global-concurrent-marking）" class="headerlink" title="全局并发标记（global concurrent marking）"></a>全局并发标记（global concurrent marking）</h5><ul><li><p>初始标记（initial mark，STW）：标记从根节点直接可达的对象，这个阶段会执行一次年轻代GC，会产生全局停顿。</p></li><li><p>根区域扫描（root region scan）：G1 GC 在初始标记的存活区扫描对老年代的引用，并标记被引用的对象。</p><p>该阶段与应用程序（非STW）同时运行，并且只有完成该阶段后，才能开始下一次STW年轻代垃圾回收。</p></li><li><p>并发标记（Concurrent Marking）：G1 GC 在整个堆中查找可访问的（存活的）对象。该阶段与应用程序同时运行，可以被 STW 年轻代垃圾回收中断。</p></li><li><p>重新标记（Remark，STW）：该阶段是STW回收，因为程序在运行，针对上一次的标记进行修正。</p></li><li><p>清除垃圾（Cleanup，STW）：清点和重置标记状态，该阶段会STW，这个阶段并不会实际上去做垃圾的收集，等待Evacuation阶段来回收。</p></li></ul><h5 id="拷贝存活对象"><a href="#拷贝存活对象" class="headerlink" title="拷贝存活对象"></a>拷贝存活对象</h5><p>Evacuation阶段是全暂停的。该阶段把一部分Region里的活对象拷贝到另一部分Region中，从而实现垃圾的回收清理。</p><h5 id="相关参数"><a href="#相关参数" class="headerlink" title="相关参数"></a>相关参数</h5><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>-XX:+UseG1GC</td><td>使用G1垃圾收集器</td></tr><tr><td>-XX:MaxGCPauseMillis</td><td>设置期望达到的最大GC停顿时间指标（会尽力实现，但不保证达到），默认值是 200 毫秒。</td></tr><tr><td>-XX:G1HeapRegionSize=n</td><td>设置的 G1 区域的大小。值是 2 的幂，范围是 1 MB 到 32 MB 之间。目标是根据最小的 Java 堆大小划分出约 2048 个区域。默认是堆内存的1/2000。</td></tr><tr><td>-XX:ParallelGCThreads=n</td><td>设置 STW 工作线程数的值。将 n 的值设置为逻辑处理器的数量。n 的值与逻辑处理器的数量相同，最多为 8。</td></tr><tr><td>-XX:ConcGCThreads=n</td><td>设置并行标记的线程数。将 n 设置为并行垃圾回收线程数(ParallelGCThreads)的 1/4 左右。</td></tr><tr><td>-XX:InitiatingHeapOccupancyPercent=n</td><td>设置触发Mixed GC 的Java 堆占用率阈值。默认占用率是整个Java 堆的 45%。</td></tr></tbody></table><h5 id="日志分析-4"><a href="#日志分析-4" class="headerlink" title="日志分析"></a>日志分析</h5><pre><code class="hljs yaml"><span class="hljs-comment">#参数</span><span class="hljs-string">-XX:+UseG1GC</span> <span class="hljs-string">-XX:MaxGCPauseMillis=100</span> <span class="hljs-string">-XX:+PrintGCDetails</span> <span class="hljs-string">-Xmx256m</span> <span class="hljs-comment">#日志</span><span class="hljs-string">[GC</span> <span class="hljs-string">pause</span> <span class="hljs-string">(G1</span> <span class="hljs-string">Evacuation</span> <span class="hljs-string">Pause)</span> <span class="hljs-string">(young),</span> <span class="hljs-number">0.0044882</span> <span class="hljs-string">secs]</span> <span class="hljs-string">[Parallel</span> <span class="hljs-attr">Time:</span> <span class="hljs-number">3.7</span> <span class="hljs-string">ms,</span> <span class="hljs-attr">GC Workers:</span> <span class="hljs-number">3</span><span class="hljs-string">]</span> <span class="hljs-string">[GC</span> <span class="hljs-string">Worker</span> <span class="hljs-string">Start</span> <span class="hljs-string">(ms):</span> <span class="hljs-attr">Min:</span> <span class="hljs-number">14763.7</span><span class="hljs-string">,</span> <span class="hljs-attr">Avg:</span> <span class="hljs-number">14763.8</span><span class="hljs-string">,</span> <span class="hljs-attr">Max:</span> <span class="hljs-number">14763.8</span><span class="hljs-string">,</span> <span class="hljs-attr">Diff:</span> <span class="hljs-number">0.1</span><span class="hljs-string">]</span> <span class="hljs-comment">#扫描根节点</span><span class="hljs-string">[Ext</span> <span class="hljs-string">Root</span> <span class="hljs-string">Scanning</span> <span class="hljs-string">(ms):</span> <span class="hljs-attr">Min:</span> <span class="hljs-number">0.2</span><span class="hljs-string">,</span> <span class="hljs-attr">Avg:</span> <span class="hljs-number">0.3</span><span class="hljs-string">,</span> <span class="hljs-attr">Max:</span> <span class="hljs-number">0.3</span><span class="hljs-string">,</span> <span class="hljs-attr">Diff:</span> <span class="hljs-number">0.1</span><span class="hljs-string">,</span> <span class="hljs-attr">Sum:</span> <span class="hljs-number">0.8</span><span class="hljs-string">]</span> <span class="hljs-comment">#更新RS区域所消耗的时间</span><span class="hljs-string">[Update</span> <span class="hljs-string">RS</span> <span class="hljs-string">(ms):</span> <span class="hljs-attr">Min:</span> <span class="hljs-number">1.8</span><span class="hljs-string">,</span> <span class="hljs-attr">Avg:</span> <span class="hljs-number">1.9</span><span class="hljs-string">,</span> <span class="hljs-attr">Max:</span> <span class="hljs-number">1.9</span><span class="hljs-string">,</span> <span class="hljs-attr">Diff:</span> <span class="hljs-number">0.2</span><span class="hljs-string">,</span> <span class="hljs-attr">Sum:</span> <span class="hljs-number">5.6</span><span class="hljs-string">]</span> <span class="hljs-string">[Processed</span> <span class="hljs-attr">Buffers: Min:</span> <span class="hljs-number">1</span><span class="hljs-string">,</span> <span class="hljs-attr">Avg:</span> <span class="hljs-number">1.7</span><span class="hljs-string">,</span> <span class="hljs-attr">Max:</span> <span class="hljs-number">3</span><span class="hljs-string">,</span> <span class="hljs-attr">Diff:</span> <span class="hljs-number">2</span><span class="hljs-string">,</span> <span class="hljs-attr">Sum:</span> <span class="hljs-number">5</span><span class="hljs-string">]</span> <span class="hljs-string">[Scan</span> <span class="hljs-string">RS</span> <span class="hljs-string">(ms):</span> <span class="hljs-attr">Min:</span> <span class="hljs-number">0.0</span><span class="hljs-string">,</span> <span class="hljs-attr">Avg:</span> <span class="hljs-number">0.0</span><span class="hljs-string">,</span> <span class="hljs-attr">Max:</span> <span class="hljs-number">0.0</span><span class="hljs-string">,</span> <span class="hljs-attr">Diff:</span> <span class="hljs-number">0.0</span><span class="hljs-string">,</span> <span class="hljs-attr">Sum:</span> <span class="hljs-number">0.0</span><span class="hljs-string">]</span><span class="hljs-string">[Code</span> <span class="hljs-string">Root</span> <span class="hljs-string">Scanning</span> <span class="hljs-string">(ms):</span> <span class="hljs-attr">Min:</span> <span class="hljs-number">0.0</span><span class="hljs-string">,</span> <span class="hljs-attr">Avg:</span> <span class="hljs-number">0.0</span><span class="hljs-string">,</span> <span class="hljs-attr">Max:</span> <span class="hljs-number">0.0</span><span class="hljs-string">,</span> <span class="hljs-attr">Diff:</span> <span class="hljs-number">0.0</span><span class="hljs-string">,</span> <span class="hljs-attr">Sum:</span> <span class="hljs-number">0.0</span><span class="hljs-string">]</span><span class="hljs-comment">#对象拷贝</span><span class="hljs-string">[Object</span> <span class="hljs-string">Copy</span> <span class="hljs-string">(ms):</span> <span class="hljs-attr">Min:</span> <span class="hljs-number">1.1</span><span class="hljs-string">,</span> <span class="hljs-attr">Avg:</span> <span class="hljs-number">1.2</span><span class="hljs-string">,</span> <span class="hljs-attr">Max:</span> <span class="hljs-number">1.3</span><span class="hljs-string">,</span> <span class="hljs-attr">Diff:</span> <span class="hljs-number">0.2</span><span class="hljs-string">,</span> <span class="hljs-attr">Sum:</span> <span class="hljs-number">3.6</span><span class="hljs-string">]</span> <span class="hljs-string">[Termination</span> <span class="hljs-string">(ms):</span> <span class="hljs-attr">Min:</span> <span class="hljs-number">0.0</span><span class="hljs-string">,</span> <span class="hljs-attr">Avg:</span> <span class="hljs-number">0.1</span><span class="hljs-string">,</span> <span class="hljs-attr">Max:</span> <span class="hljs-number">0.2</span><span class="hljs-string">,</span> <span class="hljs-attr">Diff:</span> <span class="hljs-number">0.2</span><span class="hljs-string">,</span> <span class="hljs-attr">Sum:</span> <span class="hljs-number">0.2</span><span class="hljs-string">][Termination</span> <span class="hljs-attr">Attempts: Min:</span> <span class="hljs-number">1</span><span class="hljs-string">,</span> <span class="hljs-attr">Avg:</span> <span class="hljs-number">1.0</span><span class="hljs-string">,</span> <span class="hljs-attr">Max:</span> <span class="hljs-number">1</span><span class="hljs-string">,</span> <span class="hljs-attr">Diff:</span> <span class="hljs-number">0</span><span class="hljs-string">,</span> <span class="hljs-attr">Sum:</span> <span class="hljs-number">3</span><span class="hljs-string">][GC</span> <span class="hljs-string">Worker</span> <span class="hljs-string">Other</span> <span class="hljs-string">(ms):</span> <span class="hljs-attr">Min:</span> <span class="hljs-number">0.0</span><span class="hljs-string">,</span> <span class="hljs-attr">Avg:</span> <span class="hljs-number">0.0</span><span class="hljs-string">,</span> <span class="hljs-attr">Max:</span> <span class="hljs-number">0.0</span><span class="hljs-string">,</span> <span class="hljs-attr">Diff:</span> <span class="hljs-number">0.0</span><span class="hljs-string">,</span> <span class="hljs-attr">Sum:</span> <span class="hljs-number">0.0</span><span class="hljs-string">]</span> <span class="hljs-string">[GC</span> <span class="hljs-string">Worker</span> <span class="hljs-string">Total</span> <span class="hljs-string">(ms):</span> <span class="hljs-attr">Min:</span> <span class="hljs-number">3.4</span><span class="hljs-string">,</span> <span class="hljs-attr">Avg:</span> <span class="hljs-number">3.4</span><span class="hljs-string">,</span> <span class="hljs-attr">Max:</span> <span class="hljs-number">3.5</span><span class="hljs-string">,</span> <span class="hljs-attr">Diff:</span> <span class="hljs-number">0.1</span><span class="hljs-string">,</span> <span class="hljs-attr">Sum:</span> <span class="hljs-number">10.3</span><span class="hljs-string">]</span> <span class="hljs-string">[GC</span> <span class="hljs-string">Worker</span> <span class="hljs-string">End</span> <span class="hljs-string">(ms):</span> <span class="hljs-attr">Min:</span> <span class="hljs-number">14767.2</span><span class="hljs-string">,</span> <span class="hljs-attr">Avg:</span> <span class="hljs-number">14767.2</span><span class="hljs-string">,</span> <span class="hljs-attr">Max:</span> <span class="hljs-number">14767.3</span><span class="hljs-string">,</span> <span class="hljs-attr">Diff:</span> <span class="hljs-number">0.1</span><span class="hljs-string">]</span> <span class="hljs-string">[Code</span> <span class="hljs-attr">Root Fixup:</span> <span class="hljs-number">0.0</span> <span class="hljs-string">ms]</span> <span class="hljs-string">[Code</span> <span class="hljs-attr">Root Purge:</span> <span class="hljs-number">0.0</span> <span class="hljs-string">ms]</span> <span class="hljs-string">[Clear</span> <span class="hljs-attr">CT:</span> <span class="hljs-number">0.0</span> <span class="hljs-string">ms]</span> <span class="hljs-comment">#清空CardTable</span><span class="hljs-string">[Other:</span> <span class="hljs-number">0.7</span> <span class="hljs-string">ms]</span> <span class="hljs-string">[Choose</span> <span class="hljs-attr">CSet:</span> <span class="hljs-number">0.0</span> <span class="hljs-string">ms]</span> <span class="hljs-comment">#选取CSet </span><span class="hljs-string">[Ref</span> <span class="hljs-attr">Proc:</span> <span class="hljs-number">0.5</span> <span class="hljs-string">ms]</span> <span class="hljs-comment">#弱引用、软引用的处理耗时 </span><span class="hljs-string">[Ref</span> <span class="hljs-attr">Enq:</span> <span class="hljs-number">0.0</span> <span class="hljs-string">ms]</span> <span class="hljs-comment">#弱引用、软引用的入队耗时 </span><span class="hljs-string">[Redirty</span> <span class="hljs-attr">Cards:</span> <span class="hljs-number">0.0</span> <span class="hljs-string">ms]</span> <span class="hljs-string">[Humongous</span> <span class="hljs-attr">Register:</span> <span class="hljs-number">0.0</span> <span class="hljs-string">ms]</span> <span class="hljs-comment">#大对象区域注册耗时 </span><span class="hljs-string">[Humongous</span> <span class="hljs-attr">Reclaim:</span> <span class="hljs-number">0.0</span> <span class="hljs-string">ms]</span> <span class="hljs-comment">#大对象区域回收耗时 </span><span class="hljs-string">[Free</span> <span class="hljs-attr">CSet:</span> <span class="hljs-number">0.0</span> <span class="hljs-string">ms]</span> <span class="hljs-string">[Eden:</span> <span class="hljs-number">7168.</span><span class="hljs-string">0K(7168.0K)-&gt;0.0B(13.0M)</span> <span class="hljs-attr">Survivors:</span> <span class="hljs-number">2048.</span><span class="hljs-string">0K-&gt;2048.0K</span> <span class="hljs-attr">Heap:</span> <span class="hljs-number">55.</span><span class="hljs-string">5M(192.0M)-&gt;48.5M(192.0M)]</span> <span class="hljs-comment">#年轻代的大小统计 </span><span class="hljs-string">[Times:</span> <span class="hljs-string">user=0.00</span> <span class="hljs-string">sys=0.00,</span> <span class="hljs-string">real=0.00</span> <span class="hljs-string">secs]</span></code></pre><h5 id="优化建议"><a href="#优化建议" class="headerlink" title="优化建议"></a>优化建议</h5><ul><li><p>年轻代大小</p><ul><li>避免使用 -Xmn 选项或 -XX:NewRatio 等其他相关选项显式设置年轻代大小。</li><li>固定年轻代的大小会覆盖暂停时间目标。</li></ul></li><li><p>暂停时间目标不要太过严苛</p><ul><li>G1 GC 的吞吐量目标是 90% 的应用程序时间和 10%的垃圾回收时间。</li><li>评估 G1 GC 的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示您愿意承受更多的垃圾回收开销，而这会直接影响到吞吐量。</li></ul></li></ul><h4 id="ZGC"><a href="#ZGC" class="headerlink" title="ZGC"></a>ZGC</h4><p>ZGC是一款在JDK 11中新加入的具有实验性质的低延迟垃圾收集器，是由Oracle公司研发的。ZGC的目标是希望在尽可能对吞吐量影响不太大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在10毫秒以内的低延迟。</p><h5 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h5><p>ZGC的内存布局与G1一样，也采用基于Region的堆内存布局，但不同的是，ZGC的Page（ZGC中称之为页面，道理和Region一样）具有动态性——动态创建和销毁，以及动态的区域容量大小。在x64硬件平台下，ZGC的Page可以具有大、中、小三类容量：</p><ul><li><p>小型页面（Small Page）：容量固定为2MB，用于放置小于256KB的小对象。</p></li><li><p>中型页面（Medium Page）：容量固定为32MB，用于放置大于等于256KB但小于4MB的对象。</p></li><li><p>大型页面（Large Page）：容量不固定，可以动态变化，但必须为2MB的整数倍，用于放置4MB或以上的大对象。</p><ul><li>每个大页面中只会存放一个大对象，这也预示着虽然名字叫作“大型Page”，但它的实际容量完全有可能小于中型Page，最小容量可低至4MB。</li><li>大型Page在ZGC的实现中是不会被重分配（重分配是ZGC的一种处理动作）的，因为复制一个大对象的代价非常高昂。</li></ul></li></ul><img src="/blog/2020/07/13/JVM-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/pic10.png" srcset="/blog/img/loading.gif" class><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p>在jdk11下，只能在linux 64位的平台上使用ZGC，如果想要在Windows下使用ZGC就需要升级jdk到14了。</p><pre><code class="hljs ldif"><span class="hljs-comment">#相关参数</span><span class="hljs-literal">-XX:+UnlockExperimentalVMOptions -XX:+UseZGC -Xmx256m - Xlog:gc*=info  </span><span class="hljs-comment">#参数说明 </span><span class="hljs-literal">-XX:+UnlockExperimentalVMOptions 解锁实验参数 </span><span class="hljs-literal">-XX:+UseZGC 启用ZGC垃圾收集器 </span><span class="hljs-literal">-Xmx256m 设置最大内存 </span><span class="hljs-literal">-Xlog:gc*=info 设置打印gc日志信息 </span><span class="hljs-comment">#设置并行的线程数，一般默认即可 </span><span class="hljs-literal">-XX:ConcGCThreads</span></code></pre><h5 id="染色指针"><a href="#染色指针" class="headerlink" title="染色指针"></a>染色指针</h5><img src="/blog/2020/07/13/JVM-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/pic11.png" srcset="/blog/img/loading.gif" class><p>染色指针是一种直接将少量额外的信息存储在指针上的技术，在64位系统中，理论可以访问的内存高达16EB（2的64次幂）字节。实际上，64位的Linux则分别支持47位（128TB）的进程虚拟地址空间和46位（64TB）的物理地址空间，64位的 Windows系统甚至只支持44位（16TB）的物理地址空间。</p><p>Linux下64位指针的高18位不能用来寻址，但剩余的46位指针所能支持的64TB内存在今天仍然能够充分满足大型服务器的需要。</p><p>ZGC的染色指针技术使用上了这剩下的46位指针宽度，将其高4位提取出来存储四个标志信息。</p><p>通过这些标志位，虚拟机可以直接从指针中看到其引用对象的三色标记状态、是否进入了重分配集（即被移动过）、是否只能通过finalize()方法才能被访问到。由于这些标志位进一步压缩了原本就只有46位的地址空间，也直接导致ZGC能够管理的内存不可以超过4TB（2的42次幂）。</p><h5 id="染色指针的好处"><a href="#染色指针的好处" class="headerlink" title="染色指针的好处"></a>染色指针的好处</h5><ul><li><p>染色指针可以使得一旦某个Region的存活对象被移走之后，这个Region立即就能够被释放和重用掉，而不必等待整个堆中所有指向该Region的引用都被修正后才能清理。</p></li><li><p>染色指针可以大幅减少在垃圾收集过程中内存屏障的使用数量。</p><ul><li>一般写屏障的目的通常是为了记录对象引用的变动情况，如果将这些信息直接维护在指针中，显然就可以省去一些专门的记录操作。</li><li>ZGC都并未使用任何写屏障，只使用了读屏障。</li></ul></li><li><p>染色指针可以作为一种可扩展的存储结构用来记录更多与对象标记、重定位过程相关的数据，以便日后进一步提高性能。</p></li></ul><h5 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h5><img src="/blog/2020/07/13/JVM-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/pic12.png" srcset="/blog/img/loading.gif" class><p>ZGC的运作过程大致可划分为四个大的阶段，这四个阶段都是可以并发执行的。仅在Mark Start、Initial Mark 阶段中会存在短暂的STW。</p><ul><li><p>并发标记（Concurrent Mark） </p><ul><li>与G1一样，并发标记是遍历对象图做可达性分析的阶段，前后也要经过初始标记、最终标记的短暂停顿。</li><li>ZGC的标记是在指针上而不是在对象上进行的，标记阶段会更新染色指针中的Marked 0、Marked 1标志位。</li></ul></li><li><p>并发预备重分配（Concurrent Prepare for Relocate） </p><ul><li>这个阶段需要根据特定的查询条件统计得出本次收集过程要清理哪些Region，将这些Region组成重分配集（Relocation Set）。</li><li>ZGC每次回收都会扫描所有的Region，用范围更大的扫描成本换取省去G1中记忆集的维护成本。</li><li>ZGC的重分配集只是决定了里面的存活对象会被重新复制到其他的Region中，里面的Region会被释放。</li></ul></li><li><p>并发重分配（Concurrent Relocate） </p><ul><li>重分配是ZGC执行过程中的核心阶段，这个过程要把重分配集中的存活对象复制到新的Region上，并为重分配集中的每个Region维护一个转发表（ForwardTable），记录从旧对象到新对象的转向关系。</li><li>由于使用了染色指针的支持，ZGC收集器能仅从引用上就明确得知一个对象是否处于重分配集之中，如果用户线程此时并发访问了位于重分配集中的对象， 这次访问将会被预置的内存屏障所截获，然后立即根据Region上的转发表记录将访问转发到新复制的对象上，并同时修正更新该引用的值，使其直接指向新对象，ZGC将这种行为称为指针的“自愈”（Self-Healing）能力。</li></ul></li><li><p>并发重映射（Concurrent Remap）</p><ul><li>重映射所做的就是修正整个堆中指向重分配集中旧对象的所有引用。</li><li>并发重映射并不是一个必须要“迫切”去完成的任务，但是当所有指针都被修正之后，原来记录新旧对象关系的转发表就可以释放掉了。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>JVM虚拟机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>垃圾收集器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>虚拟机性能相关工具</title>
    <link href="/blog/2020/07/09/JVM-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7/"/>
    <url>/blog/2020/07/09/JVM-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<h3 id="JVM的运行时参数"><a href="#JVM的运行时参数" class="headerlink" title="JVM的运行时参数"></a>JVM的运行时参数</h3><p>jvm的参数类型分为三类：</p><ul><li>标准参数：-help、-version</li><li>-X参数（非标准参数）：-Xint、-Xcomp</li><li>-XX参数（使用率较高）：-XX:newSize、-XX:+UseSerialGC</li></ul><h4 id="标准参数"><a href="#标准参数" class="headerlink" title="标准参数"></a>标准参数</h4><p>jvm的标准参数，一般都是很稳定的，在未来的JVM版本中不会改变，可以使用java -help检索出所有的标准参数。</p><p>通过-D设置系统属性参数</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestJVM</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    String str = System.getProperty(<span class="hljs-string">"str"</span>);    <span class="hljs-keyword">if</span> (str == <span class="hljs-keyword">null</span>) &#123;      System.out.println(<span class="hljs-string">"itcast"</span>);    &#125; <span class="hljs-keyword">else</span> &#123;      System.out.println(str);     &#125;   &#125; &#125;</code></pre><pre><code class="hljs shell">F:\t&gt;javac TestJVM.javaF:\t&gt;java TestJVM itcastF:\t&gt;java -Dstr=123 TestJVM 123</code></pre><h5 id="server与-client参数"><a href="#server与-client参数" class="headerlink" title="-server与-client参数"></a>-server与-client参数</h5><p>可以通过-server或-client设置jvm的运行参数。它们的区别是Server VM的初始堆空间会大一些，默认使用的是并行垃圾回收器，启动慢运行快。Client VM相对来讲会保守一些，初始堆空间会小一些，使用串行的垃圾回收器，它的目标是为了让JVM的启动速度更快，但运行速度会比Server模式慢些。</p><p>JVM在启动的时候会根据硬件和操作系统自动选择使用Server还是Client类型的JVM。</p><p>32位操作系统</p><ul><li><p>如果是Windows系统，不论硬件配置如何，都默认使用Client类型的JVM。</p></li><li><p>如果是其他操作系统上，机器配置有2GB以上的内存同时有2个以上CPU的话默认使用server模式，否则使用client模式。</p></li></ul><p>64位操作系统</p><ul><li>只有server类型，不支持client类型。</li></ul><h4 id="X参数"><a href="#X参数" class="headerlink" title="-X参数"></a>-X参数</h4><p>jvm的-X参数是非标准参数，在不同版本的jvm中，参数可能会有所不同，可以通过java -X查看非标准参数。</p><h5 id="Xint、-Xcomp、-Xmixed"><a href="#Xint、-Xcomp、-Xmixed" class="headerlink" title="-Xint、-Xcomp、-Xmixed"></a>-Xint、-Xcomp、-Xmixed</h5><ul><li><p>在解释模式(interpreted mode)下，-Xint标记会强制JVM执行所有的字节码，当然这会降低运行速度，通常低10倍或更多。</p></li><li><p>-Xcomp参数与它（-Xint）正好相反，JVM在第一次使用时会把所有的字节码编译成本地代码，从而带来最大程度的优化。</p><blockquote><p>然而，很多应用在使用-Xcomp也会有一些性能损失，当然这比使用-Xint损失的少，原因是- xcomp没有让JVM启用JIT编译器的全部功能。JIT编译器可以对是否需要编译做判断，如果所有代码都进行编译的话，对于一些只执行一次的代码就没有意义了。</p></blockquote></li><li><p>-Xmixed是混合模式，将解释模式与编译模式进行混合使用，由jvm自己决定，这是jvm默认的模</p><p>式，也是推荐使用的模式。</p></li></ul><h5 id="Xms与-Xmx参数"><a href="#Xms与-Xmx参数" class="headerlink" title="-Xms与-Xmx参数"></a>-Xms与-Xmx参数</h5><p>-Xms与-Xmx分别是设置jvm的堆内存的初始大小和最大大小。</p><p>-Xmx2048m：等价于-XX:MaxHeapSize，设置JVM最大堆内存为2048M。</p><p>-Xms512m：等价于-XX:InitialHeapSize，设置JVM初始堆内存为512M。</p><h4 id="XX参数"><a href="#XX参数" class="headerlink" title="-XX参数"></a>-XX参数</h4><p>-XX参数也是非标准参数，主要用于jvm的调优和debug操作。</p><p>-XX参数的使用有2种方式，一种是boolean类型，一种是非boolean类型：</p><ul><li><p>boolean类型</p><ul><li>格式：-XX:[+-]&lt;name&gt; 表示启用或禁用&lt;name&gt;属性</li><li>如：-XX:+DisableExplicitGC 表示禁用手动调用gc操作，也就是说调用System.gc()无效</li></ul></li><li><p>非boolean类型</p><ul><li>格式：-XX:&lt;name&gt;=&lt;value&gt; 表示&lt;name&gt;属性的值为&lt;value&gt;</li><li>如：-XX:NewRatio=4 表示新生代和老年代的比值为1:4</li></ul></li></ul><h4 id="查看正在运行的jvm参数"><a href="#查看正在运行的jvm参数" class="headerlink" title="查看正在运行的jvm参数"></a>查看正在运行的jvm参数</h4><pre><code class="hljs less"><span class="hljs-comment">//查找应用进程编号</span><span class="hljs-selector-tag">jps</span> <span class="hljs-selector-tag">-l</span><span class="hljs-comment">//查看运行参数</span><span class="hljs-selector-tag">jinfo</span> <span class="hljs-selector-tag">-flags</span> <span class="hljs-selector-attr">[进程编号]</span></code></pre><h4 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h4><p>jstat命令可以查看堆内存各部分的使用量，以及加载类的数量。命令的格式如下：</p><p>jstat -[命令选项] [vmid] [间隔时间/毫秒] [查询次数]</p><p>命名选项如下：</p><ul><li><p>Loaded：加载class的数量</p></li><li><p>Bytes：所占用空间大小</p></li><li><p>Unloaded：未加载数量</p></li><li><p>Bytes：未加载占用空间</p></li><li><p>Time：时间</p></li></ul><h5 id="class加载统计"><a href="#class加载统计" class="headerlink" title="class加载统计"></a>class加载统计</h5><pre><code class="hljs shell">MacBookPro:~ zhaoguocheng$ jstat -class 10730Loaded  Bytes  Unloaded  Bytes     Time    60210 125331.7      953   983.7      47.72</code></pre><h5 id="垃圾回收统计"><a href="#垃圾回收统计" class="headerlink" title="垃圾回收统计"></a>垃圾回收统计</h5><pre><code class="hljs shell">MacBookPro:~ zhaoguocheng$ jstat -gc 10730 S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT   17472.0 17472.0 14212.5  0.0   139776.0 101291.8  508884.0   274618.0  403292.0 385091.1 52184.0 45738.3    196    1.968   0      0.000    1.968<span class="hljs-meta">#</span><span class="bash">指定每秒钟打印一次，总共打印五次</span>MacBookPro:~ zhaoguocheng$ jstat -gc 10730<span class="hljs-meta">#</span><span class="bash">说明</span><span class="hljs-meta">#</span><span class="bash">S0C：第一个Survivor区的大小（KB）</span><span class="hljs-meta">#</span><span class="bash">S1C：第二个Survivor区的大小（KB）</span><span class="hljs-meta">#</span><span class="bash">S0U：第一个Survivor区的使用大小（KB）</span><span class="hljs-meta">#</span><span class="bash">S1U：第二个Survivor区的使用大小（KB）</span><span class="hljs-meta">#</span><span class="bash">EC：Eden区的大小（KB）</span><span class="hljs-meta">#</span><span class="bash">EU：Eden区的使用大小（KB）</span><span class="hljs-meta">#</span><span class="bash">OC：Old区大小（KB）</span><span class="hljs-meta">#</span><span class="bash">OU：Old使用大小（KB）</span><span class="hljs-meta">#</span><span class="bash">MC：方法区大小（KB）</span><span class="hljs-meta">#</span><span class="bash">MU：方法区使用大小（KB） CCSC：压缩类空间大小（KB） CCSU：压缩类空间使用大小（KB） YGC：年轻代垃圾回收次数</span><span class="hljs-meta">#</span><span class="bash">YGCT：年轻代垃圾回收消耗时间</span><span class="hljs-meta">#</span><span class="bash">FGC：老年代垃圾回收次数</span><span class="hljs-meta">#</span><span class="bash">FGCT：老年代垃圾回收消耗时</span></code></pre><h3 id="MAT工具"><a href="#MAT工具" class="headerlink" title="MAT工具"></a>MAT工具</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>MAT(Memory Analyzer Tool)，是基于Eclipse的内存分析工具，是一个快速、功能丰富的JAVA heap<br>分析工具，它可以帮助我们查找内存泄漏和减少内存消耗。使用内存分析工具从众多的对象中进行分<br>析，快速的计算出在内存中对象的占用大小，看看是谁阻止了垃圾收集器的回收工作，并可以通过报表<br>直观的查看到可能造成这种结果的对象。官网地址：<a href="https://www.eclipse.org/mat/。" target="_blank" rel="noopener">https://www.eclipse.org/mat/。</a></p><h4 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h4><p>下载地址：<a href="https://www.eclipse.org/mat/downloads.php" target="_blank" rel="noopener">https://www.eclipse.org/mat/downloads.php</a></p><p>将下载得到的MemoryAnalyzer-1.8.0.20180604-win32.win32.x86_64.zip进行解压后即可</p><p>增加JVM运行参数<code>-XX:+HeapDumpOnOutOfMemoryError</code>，当发生内存溢出时，会dump内存到后缀为.hprof的文件中，该文件在项目的根目录下。</p><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><img src="/blog/2020/07/09/JVM-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7/pic1.png" srcset="/blog/img/loading.gif" class><img src="/blog/2020/07/09/JVM-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7/pic2.png" srcset="/blog/img/loading.gif" class><img src="/blog/2020/07/09/JVM-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7/pic3.png" srcset="/blog/img/loading.gif" class><img src="/blog/2020/07/09/JVM-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7/pic4.png" srcset="/blog/img/loading.gif" class><p>查看对象及其依赖：</p><img src="/blog/2020/07/09/JVM-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7/pic5.png" srcset="/blog/img/loading.gif" class><p>查看可能存在内存泄漏的分析</p><img src="/blog/2020/07/09/JVM-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7/pic6.png" srcset="/blog/img/loading.gif" class><h3 id="查看线程状态"><a href="#查看线程状态" class="headerlink" title="查看线程状态"></a>查看线程状态</h3><pre><code class="hljs shell">jstack [pid]</code></pre><p>如果有死锁会显示</p><pre><code class="hljs mipsasm">Found one <span class="hljs-keyword">Java-level </span>deadlock: ============================= <span class="hljs-string">"Thread-1"</span>:  <span class="hljs-keyword">waiting </span>to lock monitor <span class="hljs-number">0x00000000026c3ee8</span> (object <span class="hljs-number">0x0000000780198bb0</span>, a <span class="hljs-keyword">java.lang.Object),</span><span class="hljs-keyword"> </span> which is held <span class="hljs-keyword">by </span><span class="hljs-string">"Thread-0"</span><span class="hljs-string">"Thread-0"</span>:  <span class="hljs-keyword">waiting </span>to lock monitor <span class="hljs-number">0x00000000026c40f8</span> (object <span class="hljs-number">0x0000000780198bc0</span>, a <span class="hljs-keyword">java.lang.Object),</span><span class="hljs-keyword"> </span> which is held <span class="hljs-keyword">by </span><span class="hljs-string">"Thread-1"</span><span class="hljs-keyword">Java </span>stack information for the threads listed above: =================================================== <span class="hljs-string">"Thread-1"</span>:    <span class="hljs-built_in">at</span> cn.itcast.<span class="hljs-keyword">jvm.TestDeadLock$Thread2.run(TestDeadLock.java:49)</span><span class="hljs-keyword"> </span>   - <span class="hljs-keyword">waiting </span>to lock &lt;<span class="hljs-number">0x0000000780198bb0</span>&gt; (a <span class="hljs-keyword">java.lang.Object)</span><span class="hljs-keyword"> </span>   - locked &lt;<span class="hljs-number">0x0000000780198bc0</span>&gt; (a <span class="hljs-keyword">java.lang.Object) </span>    <span class="hljs-built_in">at</span> <span class="hljs-keyword">java.lang.Thread.run(Thread.java:748) </span><span class="hljs-string">"Thread-0"</span>:     <span class="hljs-built_in">at</span> cn.itcast.<span class="hljs-keyword">jvm.TestDeadLock$Thread1.run(TestDeadLock.java:29)</span><span class="hljs-keyword"> </span>   - <span class="hljs-keyword">waiting </span>to lock &lt;<span class="hljs-number">0x0000000780198bc0</span>&gt; (a <span class="hljs-keyword">java.lang.Object) </span>    - locked &lt;<span class="hljs-number">0x0000000780198bb0</span>&gt; (a <span class="hljs-keyword">java.lang.Object) </span>    <span class="hljs-built_in">at</span> <span class="hljs-keyword">java.lang.Thread.run(Thread.java:748) </span>Found <span class="hljs-number">1</span> deadlock.</code></pre><p>可以清晰的看到：</p><ul><li><p>Thread2获取了 &lt;0x0000000780198bc0&gt; 的锁，等待获取 &lt;0x0000000780198bb0&gt; 这个锁</p></li><li><p>Thread1获取了 &lt;0x0000000780198bb0&gt; 的锁，等待获取 &lt;0x0000000780198bc0&gt; 这个锁</p></li></ul><p>由此可见，发生了死锁。</p><h3 id="VisualVM"><a href="#VisualVM" class="headerlink" title="VisualVM"></a>VisualVM</h3><p>VisualVM，能够监控线程，内存情况，查看方法的CPU时间和内存中的对 象，已被GC的对象，反向查</p><p>看分配的堆栈(如100个String对象分别由哪几个对象分配出来的)。</p><p>VisualVM使用简单，几乎0配置，功能还是比较丰富的，几乎囊括了其它JDK自带命令的所有功能。</p><ul><li><p>内存信息</p></li><li><p>线程信息</p></li><li><p>Dump堆（本地进程）</p></li><li><p>Dump线程（本地进程）</p></li><li><p>打开堆Dump。堆Dump可以用jmap来生成。</p></li><li><p>打开线程Dump</p></li><li><p>生成应用快照（包含内存信息、线程信息等等）</p></li><li><p>性能分析。CPU分析（各个方法调用时间，检查哪些方法耗时多），内存分析（各类对象占用的内</p></li></ul><p>存，检查哪些类占用内存多）</p><ul><li>……</li></ul><p>VisualVM在jdk的bin目录下，找到jvisualvm打开即可。</p><h4 id="jvm基本信息"><a href="#jvm基本信息" class="headerlink" title="jvm基本信息"></a>jvm基本信息</h4><img src="/blog/2020/07/09/JVM-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7/pic7.png" srcset="/blog/img/loading.gif" class><h4 id="CPU、内存、类线程运行信息"><a href="#CPU、内存、类线程运行信息" class="headerlink" title="CPU、内存、类线程运行信息"></a>CPU、内存、类线程运行信息</h4><img src="/blog/2020/07/09/JVM-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7/pic8.png" srcset="/blog/img/loading.gif" class><h4 id="线程详情"><a href="#线程详情" class="headerlink" title="线程详情"></a>线程详情</h4><img src="/blog/2020/07/09/JVM-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7/pic9.png" srcset="/blog/img/loading.gif" class><p>右上角的Dump按钮可以到处线程信息，与jstack相同</p><img src="/blog/2020/07/09/JVM-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7/pic10.png" srcset="/blog/img/loading.gif" class><h4 id="抽样器"><a href="#抽样器" class="headerlink" title="抽样器"></a>抽样器</h4><p>抽样器可以对CPU、内存在一段时间内进行抽样，以供分析。</p><img src="/blog/2020/07/09/JVM-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7/pic11.png" srcset="/blog/img/loading.gif" class><h4 id="监控远程jvm"><a href="#监控远程jvm" class="headerlink" title="监控远程jvm"></a>监控远程jvm</h4><p>VisualJVM可以借助于JMX技术监控远程的jvm进程。</p><p>JMX（Java Management Extensions，即Java管理扩展）是一个为应用程序、设备、系统等植入管理功能的框架。JMX可以跨越一系列异构操作系统平台、系统体系结构和网络传输协议，灵活的开发无缝集成的系统、网络和服务管理应用。</p><h5 id="监控远程tomcat"><a href="#监控远程tomcat" class="headerlink" title="监控远程tomcat"></a>监控远程tomcat</h5><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">在tomcat的bin目录下，修改catalina.sh，添加如下的参数 </span>JAVA_OPTS="-Dcom.sun.management.jmxremote - Dcom.sun.management.jmxremote.port=9999 - Dcom.sun.management.jmxremote.authenticate=false - Dcom.sun.management.jmxremote.ssl=false" <span class="hljs-meta">#</span><span class="bash">这几个参数的意思是： </span><span class="hljs-meta">#</span><span class="bash">-Dcom.sun.management.jmxremote ：允许使用JMX远程管理 </span><span class="hljs-meta">#</span><span class="bash">-Dcom.sun.management.jmxremote.port=9999 ：JMX远程连接端口 </span><span class="hljs-meta">#</span><span class="bash">-Dcom.sun.management.jmxremote.authenticate=<span class="hljs-literal">false</span> ：不进行身份认证，任何用户都可 以连接 </span><span class="hljs-meta">#</span><span class="bash">-Dcom.sun.management.jmxremote.ssl=<span class="hljs-literal">false</span> ：不使用ssl</span></code></pre><h5 id="连接远程tomcat"><a href="#连接远程tomcat" class="headerlink" title="连接远程tomcat"></a>连接远程tomcat</h5><p>添加远程主机：</p><img src="/blog/2020/07/09/JVM-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7/pic12.png" srcset="/blog/img/loading.gif" class><p>在一个主机下可能会有很多的jvm需要监控，所以接下来要在该主机上添加需要监控的jvm：</p><img src="/blog/2020/07/09/JVM-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7/pic13.png" srcset="/blog/img/loading.gif" class><img src="/blog/2020/07/09/JVM-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7/pic14.png" srcset="/blog/img/loading.gif" class><h4 id="检查死锁"><a href="#检查死锁" class="headerlink" title="检查死锁"></a>检查死锁</h4><img src="/blog/2020/07/09/JVM-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7/pic15.png" srcset="/blog/img/loading.gif" class><h4 id="检测堆内存"><a href="#检测堆内存" class="headerlink" title="检测堆内存"></a>检测堆内存</h4><p>检测堆内存的具体使用情况，需要安装插件Visual GC进行检测：</p><img src="/blog/2020/07/09/JVM-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7/pic16.png" srcset="/blog/img/loading.gif" class><p>可以看到，年轻代、老年代中的内存使用情况</p><img src="/blog/2020/07/09/JVM-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7/pic17.png" srcset="/blog/img/loading.gif" class>]]></content>
    
    
    <categories>
      
      <category>JVM虚拟机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>性能优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM虚拟机内存管理</title>
    <link href="/blog/2020/07/09/JVM-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <url>/blog/2020/07/09/JVM-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="JVM整体结构"><a href="#JVM整体结构" class="headerlink" title="JVM整体结构"></a>JVM整体结构</h3><img src="/blog/2020/07/09/JVM-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/pic1.png" srcset="/blog/img/loading.gif" class><p>JVM虚拟机中主要是由三部分构成，分别是类加载子系统、运行时数据区、执行引擎。</p><blockquote><p><strong>类加载子系统</strong></p></blockquote><p>Java虚拟机把描述类的数据从Class文件加载到内存（运行时数据区），并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。</p><blockquote><p><strong>运行时数据区</strong></p></blockquote><p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而一直存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。</p><p>垃圾回收器就是自动管理运行数据区的内存，将无用的内存占用进行清除，释放内存资源。</p><blockquote><p><strong>执行引擎</strong></p></blockquote><p>执行引擎用于执行JVM字节码指令，主要有两种方式，分别是解释执行和编译执行，区别在于，解释执行是在执行时翻译成虚拟机指令执行，而编译执行是在执行之前先进行编译再执行。</p><p>解释执行启动快，执行效率低。编译执行，启动慢，执行效率高。</p><blockquote><p><strong>本地方法库、本地库接口</strong></p></blockquote><p>在jdk的底层中，有一些实现是需要调用本地方法完成的（使用c或c++写的方法），就是通过本地库接口调用完成的。比如：System.currentTimeMillis()方法。</p><h3 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h3><img src="/blog/2020/07/09/JVM-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/pic1.png" srcset="/blog/img/loading.gif" class><p>根据《Java虚拟机规范》中的规定，在运行时数据区将内存分为方法区（Method Area）、Java堆区（Java Heap）、Java虚拟机栈（Java Virtual Machine Stack）、程序计数器（Program Counter Register）、本地方法栈（Native Method Stacks）。</p><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。</p><p>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><p>由于Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p><h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><p>与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期与线程相同。Java虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧，用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p><h5 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h5><ul><li><p>局部变量表是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量。</p></li><li><p>在Class文件中，方法的Code属性的max_locals数据项中确定了该方法所需分配的局部变量表的最</p><p>大容量。</p></li><li><p>该表以变量槽（Variable Slot）为最小单位，一个slot可以存放32位以内的数据，比如：boolean、byte、char、short、int、flfloat等数据，如果存储long、double类型数据，需要占用2 个solt。</p></li><li><p>虚拟机通过索引定位的方式使用局部变量表，索引值的范围是从0开始至局部变量表最大的变量槽数量。</p></li><li><p>如果访问的是32位数据类型的变量，索引N就代表了使用第N个变量槽，如果访问的是64位数据类型的变量，则说明会同时使用第N和N+1两个变量槽。</p></li><li><p>局部变量表中第0位索引的变量槽默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字“this”来访问到这个隐含的参数。其余参数则按照参数表顺序排列，占用从1开始的局部变量槽，参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域分配其余的变量槽。</p></li></ul><h5 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h5><ul><li><p>操作数栈的最大深度也在编译的时候被写入到Code属性的max_stacks数据项之中。</p></li><li><p>操作数栈的每一个元素都可以是包括long和double在内的任意Java数据类型。32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2。</p></li><li><p>方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈和入栈操作。</p></li><li><p>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，例如iadd指令，不能出现一个long和一个float使用iadd命令相加的情况。</p></li></ul><h5 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h5><ul><li><p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。</p></li><li><p>Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池里指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就被转化为直接引用，这种转化被称为静态解析。另外一部分将在每一次运行期间都转化为直接引用，这部分就称为动态连接。</p></li></ul><h5 id="方法出口"><a href="#方法出口" class="headerlink" title="方法出口"></a>方法出口</h5><ul><li><p>当一个方法开始执行后，只有两种方式退出这个方法。</p></li><li><p>第一种方式是执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者，方法是否有返回值以及返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为“正常调用完成”。</p></li><li><p>另外一种退出方式是在方法执行的过程中遇到了异常，并且这个异常没有在方法体内得到妥善处理。无论是Java虚拟机内部产生的异常，还是代码中使用athrow字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方法的方式称为“异常调用完成”。这种方法的返回是不会给它的上层调用者提供任何返回值的。</p></li><li><p>无论采用何种退出方式，在方法退出之后，都必须返回到最初方法被调用时的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层主调方法的执行状态。</p></li><li><p>方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令等。</p></li></ul><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。</p><h4 id="Java堆区"><a href="#Java堆区" class="headerlink" title="Java堆区"></a>Java堆区</h4><p>Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，Java世界里“几乎”所有的对象实例都在这里分配内存。Java堆是垃圾收集器管理的内存区域，是JVM调优的重点区域部分。</p><h5 id="jdk1-7堆内存模型"><a href="#jdk1-7堆内存模型" class="headerlink" title="jdk1.7堆内存模型"></a>jdk1.7堆内存模型</h5><img src="/blog/2020/07/09/JVM-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/pic2.png" srcset="/blog/img/loading.gif" class><ul><li><p>Young 年轻区（代）</p><p>Young区被划分为三部分，Eden区和两个大小严格相同的Survivor区，其中，Survivor区间中，某一时刻只有其中一个是被使用的，另外一个留做垃圾收集时复制对象用，在Eden区间变满的时候， GC就会将存活的对象移到空闲的Survivor区间中，根据JVM的策略，在经过几次垃圾收集后，任然存活于Survivor的对象将被移动到Tenured区间。</p></li><li><p>Tenured 年老区</p><p>Tenured区主要保存生命周期长的对象，一般是一些老的对象，当一些对象在Young复制转移一定的次数以后，对象就会被转移到Tenured区，一般如果系统中用了application级别的缓存，缓存中的对象往往会被转移到这一区间。</p></li><li><p>Perm 永久区</p><p>Perm代主要保存class,method,filed对象，这部份的空间一般不会溢出，除非一次性加载了很多的类，不过在涉及到热部署的应用服务器的时候，有时候会遇到java.lang.OutOfMemoryError :PermGen space 的错误，造成这个错误的很大原因就有可能是每次都重新部署，但是重新部署后，类的class没有被卸载掉，这样就造成了大量的class对象保存在了perm中，这种情况下，一般重新启动应用服务器可以解决问题。</p></li><li><p>Virtual区</p><p>最大内存和初始内存的差值，就是Virtual区。</p></li></ul><h5 id="jdk1-8堆内存模型"><a href="#jdk1-8堆内存模型" class="headerlink" title="jdk1.8堆内存模型"></a>jdk1.8堆内存模型</h5><p>jdk1.8的内存模型是由2部分组成，年轻代 + 年老代。年轻代：Eden + 2*Survivor，老年代：OldGen</p><p>与1.7不同的是，在1.8中，方法区用Metaspace(元数据空间)进行了替换。需要特别说明的是，Metaspace所占用的内存空间不是在虚拟机内部，而是在本地内存空间中，这也是 与1.7的永久代最大的区别所在。</p><img src="/blog/2020/07/09/JVM-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/pic3.png" srcset="/blog/img/loading.gif" class><p>上图是默认状态下的空间分配情况，如果在没有指定堆内存大小时，默认初始堆内存为物理机内存的1/64，最大堆内存为物理机内存的1/4 或 1G。（JDK8的情况下）</p><blockquote><p>关于元空间需要注意的是，元空间会自动扩容，默认情况下不受限制，在实际中，经常忽略掉直接内存，使得各个内存区域总和大于物理内存限制，从而导致动态扩展时出现OutOfMemoryError异常。</p></blockquote><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</p><p>《Java虚拟机规范》中把方法区描述为堆的一个逻辑部分，它却有一个别名叫作“非堆”（Non Heap），目的是与Java堆区分开来。</p><p>JDK8之前将HotSpot虚拟机把收集器的分代设计扩展至方法区，所以可以将永久代看做是方法区，JDK8之后废弃永久代，用元空间来代替。</p><h3 id="对象的访问"><a href="#对象的访问" class="headerlink" title="对象的访问"></a>对象的访问</h3><p>Java程序会通过栈上的reference数据来操作堆上的具体对象。主流的访问方式主要有使用句柄和直接指针两种：</p><ul><li>使用句柄访问：Java堆中将可能会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息</li><li>使用直接指针访问：Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销。</li></ul><p>使用句柄来访问的最大好处就是reference中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。</p><p>使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销。</p><p>HotSpot虚拟机采用的是指针访问方式实现。</p>]]></content>
    
    
    <categories>
      
      <category>JVM虚拟机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM内存管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>再次认识Java</title>
    <link href="/blog/2020/07/09/JVM-%E5%86%8D%E6%AC%A1%E8%AE%A4%E8%AF%86Java/"/>
    <url>/blog/2020/07/09/JVM-%E5%86%8D%E6%AC%A1%E8%AE%A4%E8%AF%86Java/</url>
    
    <content type="html"><![CDATA[<h3 id="Java技术体系"><a href="#Java技术体系" class="headerlink" title="Java技术体系"></a>Java技术体系</h3><p>Java技术体系也包括可以运行在Java平台的其他语言，比如：Kotlin、Clojure、JRuby、Groovy等语言。但对于Java程序员而言，指的是JCP官方定义的Java体系。</p><blockquote><p>JCP：Java Community Process，就是人们常说的“Java社区”，这是一个由业界多家技术巨头组成</p><p>的社区组织，用于定义和发展Java的技术规范。官网：<a href="https://jcp.org/en/home/index" target="_blank" rel="noopener">https://jcp.org/en/home/index</a></p></blockquote><h4 id="JDK-amp-JRE"><a href="#JDK-amp-JRE" class="headerlink" title="JDK &amp; JRE"></a>JDK &amp; JRE</h4><p>Java程序设计语言、Java虚拟机、Java类库这三部分统称为JDK（Java Development Kit），JDK是用于支持Java程序开发的最小环境。</p><p>Java类库API中的Java SE API子集和Java虚拟机这两部分统称为JRE（Java Runtime Environment），JRE是支持Java程序运行的标准环境。</p><img src="/blog/2020/07/09/JVM-%E5%86%8D%E6%AC%A1%E8%AE%A4%E8%AF%86Java/pic1.png" srcset="/blog/img/loading.gif" class><h3 id="Java发展历史"><a href="#Java发展历史" class="headerlink" title="Java发展历史"></a>Java发展历史</h3><ul><li><p>1995年5月23日，Oak语言改名为Java，并且在SunWorld大会上正式发布Java 1.0版本。Java语言第一次提出了“Write Once，Run Anywhere”的口号。</p></li><li><p>1999年4月27日，HotSpot虚拟机诞生。Hot-Spot虚拟机刚发布时是作为JDK 1.2的附加程序提供的，后来它成为JDK 1.3及之后所有JDK版本的默认Java虚拟机。</p></li><li><p>2004年9月30日，JDK 5发布，工程代号为Tiger（老虎），是Java语言的发展史上的又一里程碑事件。JDK的版本不再是“1.x”的命名方式，而采用“JDK x”方式进行命名。</p></li><li><p>JDK 8的第一个正式版本于2014年3月18日发布，从JDK 8开始，Oracle启用JEP（JDK Enhancement Proposals）来定义和管理纳入新版JDK发布范围的功能特性。</p><ul><li>JEP 126：对Lambda表达式的支持，这让Java语言拥有了流畅的函数式表达能力。</li><li>JEP 104：内置Nashorn JavaScript引擎的支持，成为Java的嵌入式JavaScript引擎。</li><li>JEP 150：新的时间、日期API。</li><li>JEP 122：彻底移除HotSpot的永久代。</li><li>……</li></ul></li><li><p>JDK9于2017年9月21日发布。JDK 9发布后，Oracle随即宣布Java将会以持续交付的形式和更加敏捷的研发节奏向前推进，以后JDK将会在每年的3月和9月各发布一个大版本。每六个JDK大版本中才会被划出一个长期支持（Long Term Support，LTS）版，只有LTS版的JDK能够获得为期三年的支持和更新，普通版的JDK就只有短短六个月的生命周期。JDK 8和JDK 11是LTS版，再下一个就到2021年发布的JDK 17了。</p></li><li><p>2018年3月20日，JDK 10如期发布，这版本的主要研发目标是内部重构，诸如统一源仓库、统一垃圾收集器接口、统一即时编译器接口等，这些都将会是对未来Java发展大有裨益的改进。</p></li><li><p>2018年9月25日，JDK 11发布，这是一个LTS版本的JDK，包含17个JEP，其中有ZGC这样的革命性的垃圾收集器出现，也有把JDK 10中的类型推断加入Lambda语法这种可见的改进。</p></li><li><p>2019年2月，在JDK 12发布前夕，Oracle果然如之前宣布那样在六个月之后就放弃了对上一个版本OpenJDK的维护，RedHat同时从Oracle手上接过OpenJDK 8和OpenJDK 11的管理权利和维护职责。</p></li><li><p>2019年3月20日，JDK 12发布，只包含8个JEP，其中主要有Switch表达式、Java微测试套件（JMH）等新功能，最引人注目的特性无疑是加入了由RedHat领导开发的Shenandoah垃圾收集器。Shenandoah作为首个由非Oracle开发的垃圾收集器，其目标又与Oracle在JDK 11中发布的ZGC几乎完全一致，两者天生就存在竞争。Oracle马上用实际行动抵制了这个新收集器，在JDK 11发布时才说应尽可能保证OracleJDK和OpenJDK的兼容一致，转眼就在OracleJDK 12里把Shenandoah的代码通过条件编译强行剔除掉，使其成为历史上唯一进入了OpenJDK发布清单，但在OracleJDK中无法使用的功能。</p></li><li><p>2020年 3 月 17 日，JDK14 正式 GA(General Available)，新增了Records、switch表达式（JDK 12和JDK 13中的预览特性，现在正式使用）、文本块等新特性。在JVM方面，弃用Parallel Scavenge和SerialOld GC组合、删除CMS垃圾回收器。</p></li></ul><h3 id="常见的几种虚拟机"><a href="#常见的几种虚拟机" class="headerlink" title="常见的几种虚拟机"></a>常见的几种虚拟机</h3><p>虚拟机的区别主要在于字节码的执行的方式，目前主要的执行方式有解释执行和编译执行（针对字节码的执行），解释执行就是边翻译为机器码边执行，编译执行（即时编译）就是先将一个方法中的所有字节码全部编译成机器码之后再执行。</p><p>常见的几种虚拟机有：</p><ul><li><p>HotSpot VM（SUN）：以前使用最广的Java虚拟机，采用的是先解释执行，到了一定时机后热点代码（多次执行、循环等）再翻译成机器码，具有热点代码探测技术（通过执行计数器找到最有编译价值的代码，如果代码用得非常频繁，就会把这些代码编译成本地代码）。</p></li><li><p>JRcokit VM（BEA）：号称“世界上最快的Java虚拟机 ”，JRockit采取的方法是在执行class时直接编译为机器码（Java程序启动速度会比较慢）。</p></li><li><p>J9 VM（IBM）J9和Hotspot比较接近，主要是用在IBM产品（IBM WebSphere和IBM的AIX平台上），华为有的项目用的J9。</p></li><li><p>Dalvik VM（Google）：Google Android Dalivk VM：谷歌移动端的虚拟机，使用的寄存器架构，执行dex（Dalvik Executable）通过class转化而来。</p></li><li><p>HotSpot VM（ORACLE）：目前使用范围最广的Java虚拟机，由ORACLE公司收购HotSpot VM(SUN)和JRcokit VM(BEA)之后合并而来。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>JVM虚拟机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java发展历史</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kubernetes集群搭建</title>
    <link href="/blog/2020/06/06/Kubernetes%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
    <url>/blog/2020/06/06/Kubernetes%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>本次使用三台centos虚拟机，docker 18.09.9和kubelet-1.16.4，要求 centos7.6以上版本</p><ol><li>关闭selinux </li></ol><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 查看是否关闭 Enforcing表示未关闭</span>getenforce<span class="hljs-meta">#</span><span class="bash"> 临时关闭</span>setenforce 0<span class="hljs-meta">#</span><span class="bash"> 永久关闭 将selinux文件中的SELINUX设置为disabled</span>vi /etc/sysconfig/selinux</code></pre><pre><code class="hljs sh"><span class="hljs-comment"># This file controls the state of SELinux on the system.</span><span class="hljs-comment"># SELINUX= can take one of these three values:</span><span class="hljs-comment">#     enforcing - SELinux security policy is enforced.</span><span class="hljs-comment">#     permissive - SELinux prints warnings instead of enforcing.</span><span class="hljs-comment">#     disabled - No SELinux policy is loaded.</span>SELINUX=disabled<span class="hljs-comment"># SELINUXTYPE= can take one of three values:</span><span class="hljs-comment">#     targeted - Targeted processes are protected,</span><span class="hljs-comment">#     minimum - Modification of targeted policy. Only selected processes are protected.</span><span class="hljs-comment">#     mls - Multi Level Security protection.</span>SELINUXTYPE=targeted</code></pre><ol start="2"><li>关闭swap</li></ol><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 临时禁用</span>swapoff -a<span class="hljs-meta">#</span><span class="bash"> 永久禁用 将fstab中的swap记录注释掉</span>vi /etc/fstab</code></pre><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="hljs-meta">#</span><span class="bash"> /etc/fstab</span><span class="hljs-meta">#</span><span class="bash"> Created by anaconda on Thu Jun  4 00:10:49 2020</span><span class="hljs-meta">#</span><span class="hljs-meta">#</span><span class="bash"> Accessible filesystems, by reference, are maintained under <span class="hljs-string">'/dev/disk'</span></span><span class="hljs-meta">#</span><span class="bash"> See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) <span class="hljs-keyword">for</span> more info</span><span class="hljs-meta">#</span>/dev/mapper/centos-root /                       xfs     defaults        0 0UUID=c7048475-1b55-4027-ac48-d7d1a62e2d2d /boot                   xfs     defaults        0 0/dev/mapper/centos-home /home                   xfs     defaults        0 0<span class="hljs-meta">#</span><span class="bash"> /dev/mapper/centos-swap swap                    swap    defaults        0 0</span></code></pre><ol start="3"><li>配置ip_forward转发</li></ol><pre><code class="hljs awk">echo <span class="hljs-string">"1"</span> &gt; <span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/net/i</span>pv4<span class="hljs-regexp">/ip_forward</span></code></pre><ol start="4"><li>更新yum源</li></ol><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 删除系统自带配置</span>cd /etc/yum.repos.d/rm -rf *<span class="hljs-meta">#</span><span class="bash"> 下载centos7的源和docker源</span>wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repowget -P /etc/yum.repos.d/ http://mirrors.aliyun.com/repo/epel-7.repowget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo<span class="hljs-meta">#</span><span class="bash"> 创建kubernetes.repo文件，内容如下</span>[kubernetes]name=Kubernetesbaseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64enabled=1gpgcheck=0<span class="hljs-meta">#</span><span class="bash"> 刷新yum缓存</span>yum clean all &amp;&amp; yum makecache fast</code></pre><h2 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h2><pre><code class="hljs sh"><span class="hljs-comment"># 安装docker</span>yum install docker-ce-18.09.9 docker-ce-cli-18.09.9 containerd.io -y<span class="hljs-comment"># 启动docker并设置开机启动</span>systemctl <span class="hljs-built_in">enable</span> docker &amp;&amp; systemctl start docker<span class="hljs-comment"># 创建/etc/docker/daemon.json文件 内容为</span>&#123;  <span class="hljs-string">"registry-mirrors"</span> : [    <span class="hljs-string">"https://jjc7lr0o.mirror.aliyuncs.com"</span>  ],  <span class="hljs-string">"exec-opts"</span>:[<span class="hljs-string">"native.cgroupdriver=systemd"</span>]&#125;</code></pre><h2 id="安装k8s组件"><a href="#安装k8s组件" class="headerlink" title="安装k8s组件"></a>安装k8s组件</h2><pre><code class="hljs shell">yum install -y kubelet-1.16.4 kubeadm-1.16.4 kubectl-1.16.4<span class="hljs-meta">#</span><span class="bash"> 设置开机启动</span>systemctl enable kubelet &amp;&amp; systemctl start kubelet<span class="hljs-meta">#</span><span class="bash"> 添加 kubectl上下文到环境中</span>echo "source &lt;(kubectl completion bash)" &gt;&gt; ~/.bash_profilesource .bash_profile<span class="hljs-meta">#</span><span class="bash"> 设置内核参数，创建/etc/sysctl.d/k8s.conf文件</span>vi /etc/sysctl.d/k8s.conf<span class="hljs-meta">#</span><span class="bash"> 生效</span>sysctl -p /etc/sysctl.d/k8s.conf</code></pre><pre><code class="hljs shell">net.bridge.bridge-nf-call-ip6tables = 1net.bridge.bridge-nf-call-iptables = 1</code></pre><h2 id="Master节点初始化"><a href="#Master节点初始化" class="headerlink" title="Master节点初始化"></a>Master节点初始化</h2><pre><code class="hljs shell">kubeadm init --image-repository registry.aliyuncs.com/google_containers --kubernetes-version v1.16.4 --pod-network-cidr=10.244.0.0/16</code></pre><p>执行成功之后会输出</p><pre><code class="hljs sql">Your Kubernetes control-plane has initialized successfully!To <span class="hljs-keyword">start</span> <span class="hljs-keyword">using</span> your cluster, you need <span class="hljs-keyword">to</span> run the <span class="hljs-keyword">following</span> <span class="hljs-keyword">as</span> a regular <span class="hljs-keyword">user</span>:  mkdir -p $HOME/.kube  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config  sudo chown $(<span class="hljs-keyword">id</span> -u):$(<span class="hljs-keyword">id</span> -g) $HOME/.kube/configYou should <span class="hljs-keyword">now</span> deploy a pod network <span class="hljs-keyword">to</span> the cluster.Run <span class="hljs-string">"kubectl apply -f [podnetwork].yaml"</span> <span class="hljs-keyword">with</span> one <span class="hljs-keyword">of</span> the options listed <span class="hljs-keyword">at</span>:  https://kubernetes.io/docs/concepts/cluster-administration/addons/<span class="hljs-keyword">Then</span> you can <span class="hljs-keyword">join</span> <span class="hljs-keyword">any</span> <span class="hljs-built_in">number</span> <span class="hljs-keyword">of</span> worker nodes <span class="hljs-keyword">by</span> running the <span class="hljs-keyword">following</span> <span class="hljs-keyword">on</span> <span class="hljs-keyword">each</span> <span class="hljs-keyword">as</span> root:kubeadm <span class="hljs-keyword">join</span> <span class="hljs-number">192.168</span><span class="hljs-number">.124</span><span class="hljs-number">.101</span>:<span class="hljs-number">6443</span> <span class="hljs-comment">--token vk47hg.vdgqgy0rbqha5aio \</span>    <span class="hljs-comment">--discovery-token-ca-cert-hash sha256:5032b6b7b51c8b375c6ec95eee87fe11dd5651cbf3053f58c3107dd1d3861895</span></code></pre><p>首先执行</p><pre><code class="hljs shell">mkdir -p $HOME/.kubesudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/configsudo chown $(id -u):$(id -g) $HOME/.kube/config</code></pre><p>然后将peter-flannel.yml上传到服务器并执行</p><pre><code class="hljs shell">kubectl apply -f peter-flannel.yml</code></pre><p>然后在其他节点</p><pre><code class="hljs shell">kubeadm join 192.168.124.101:6443 --token 8h1zf4.11fjnpz1qwbrqkz3 --discovery-token-ca-cert-hash sha256:5032b6b7b51c8b375c6ec95eee87fe11dd5651cbf3053f58c3107dd1d3861895</code></pre><p>如果忘记加入命令可以再次执行</p><pre><code class="hljs shell">kubeadm token create --print-join-command</code></pre><h2 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h2><h3 id="kubectl命令用法"><a href="#kubectl命令用法" class="headerlink" title="kubectl命令用法"></a>kubectl命令用法</h3><p>可以借助kubectl -h命令学习用法，下面介绍常用的一些命令使用：</p><ul><li><p>创建一个应用程序</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 测试创建一个应用程序，副本为2，端口为80，注意，该网段的所有80端口都会被绑定</span>kubectl run nginx-dep --image=nginx:1.7.9 --port=80 --replicas=2 --dry-run<span class="hljs-meta">#</span><span class="bash"> 正式创建</span>kubectl run nginx-dep --image=nginx:1.7.9 --port=80 --replicas=2<span class="hljs-meta">#</span><span class="bash"> 查看服务信息 -o wide表示获取更详细的信息</span>kubectl get pods -o wide</code></pre></li><li><p>查看服务信息</p><pre><code class="hljs angelscript">kubectl describe pod nginx-dep<span class="hljs-number">-5779</span>c9d6c9<span class="hljs-number">-7</span>k7mf</code></pre></li><li><p>进入pod内部</p><pre><code class="hljs llvm">kubectl exec -it nginx-dep<span class="hljs-number">-5779</span><span class="hljs-keyword">c</span><span class="hljs-number">9</span>d<span class="hljs-number">6</span><span class="hljs-keyword">c</span><span class="hljs-number">9</span><span class="hljs-number">-7</span>k<span class="hljs-number">7</span>mf -<span class="hljs-keyword">c</span> nginx-dep /bin/bash</code></pre></li><li><p>删除pod</p><pre><code class="hljs shell">kubectl delete pod nginx-dep-5779c9d6c9-7k7mf</code></pre></li><li><p>服务的伸缩</p><pre><code class="hljs routeros">kubectl scale <span class="hljs-attribute">--replicas</span>=3 deployment nginx-dep</code></pre></li><li><p>滚动更新</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 设置镜像版本</span>kubectl set image deployment nginx-dep nginx-dep=nginx:1.9.7<span class="hljs-meta">#</span><span class="bash"> 回滚镜像</span>kubectl rollout undo deployment ngxin-dep</code></pre></li><li><p>服务暴露</p><pre><code class="hljs shell">kubectl expose deployment nginx-dep --name=nginx-svc --port=81 --target-port=80<span class="hljs-meta">#</span><span class="bash"> 获取service信息</span>kubectl get service -o wide<span class="hljs-meta">#</span><span class="bash"> 暴露到外网</span>kubectl expose deployment nginx-dep --name=nginx-svc --port=81 --target-port=80 --type=NodePort</code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>K8s</category>
      
    </categories>
    
    
    <tags>
      
      <tag>K8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kubernetes概述</title>
    <link href="/blog/2020/06/03/Kubernetes%E6%A6%82%E8%BF%B0/"/>
    <url>/blog/2020/06/03/Kubernetes%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>kubernetes(以下简称k8s)是google基于Blog进行改进后，开源出来的一款“容器管理应用”。由于近几年来容器技术的火爆，许许多多的服务都不会直接部署在linux主机或各大云厂商的虚拟机上;利用Docker，将每个服务做成一个Image，把他们跑在各自的Container中。<br>这样做的好处有非常多，比如环境配置隔离、服务启动快、移植便捷等等。但是使用的Container多到一定程度，就会带来容器管理上的问题:使用dockerps命令之后有一大堆Container，如果标识的不清楚也很容易混淆;某些分布式服务，需要将Docker部署到许多不同的机器上，这也会增加我们运维的难度。因此，我们现在需要一款“专门管理容器”的平台，为我们提供可视化界面，方便我们对各个容器进行管理。<br>k8s就是这样一款辅助我们管理容器的平台，支持管理在分布式环境(即多台服务器上)启动的Container。</p><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>Master：Cluster的大脑，主要职责是调度，可以运行多个master来保证高可用。<br>Node：职责是运行容器应用，Node由Master管理，负责监控并汇报容器的状态，同时根据Master的要求管理容器的生命周期。<br>Pod：K8s的最小工作单元。每个Pod包含一个或多个容器。</p><ul><li>有些容器天生就是需要紧密联系，一起工作。Pod提供了比容器更高层次的抽象，K8s以Pod为最小单位进行调度、扩展、共享资源、管理生命周期。</li><li>Pod中的所有容器使用同一个网络的namespace，即相同的IP地址和Port空间。它们可以直接用localhost通信。同样的，这些容器可以共享存储，当K8s挂载Volume到Pod上，本质上是将volume挂载到Pod中的每一个容器。</li></ul><p>Pod控制器：K8s通常不直接创建Pod，而是通过Controller来管理Pod。Controller中定义了pod的部署属性，比如几个副本、在什么样的Node上运行等。K8s提供了多种Controller，包括Deployment、ReplicaSet、DaemonSet、StatefuleSet、Job等。</p><ul><li><p>ReplicationController(副本控制器)，确保Pod的数量始终保持设定的个数。也支持Pod的滚动更新。</p></li><li><p>ReplicaSet(副本集)，它不直接使用，有一个声明式更新的控制器叫Deployment来负责管理。但是Deployment只能负责管理那些无状态的应用。</p></li><li><p>StatefulSet(有状态副本集)，负责管理有状态的应用。</p></li><li><p>DaemonSet，如果需要在每一个Node上只运行一个副本，而不是随意运行，就需要DaemonSet。</p></li><li><p>Job，运行作业，对于时间不固定的操作，比如某个应用生成了一大堆数据集，现在需要临时启动一个Pod去清理这些数据集，清理完成后，这个Pod就可以结束了。这些不需要一直处于运行状态的应用，就用Job这个类型的控制器去控制。如果Pod运行过程中意外中止了，Job负责重启Pod。如果Pod任务执行完了，就不需要再启动了。</p></li><li><p>Cronjob：周期性作业。</p></li></ul><p>Service：Deployement可以部署多个副本，每个Pod都有自己的副IP，外界如何访问这些副本。Pod会被频繁的销毁和重启，IP实时变化，不能用IP，答案是通过service。K8sservice定义了外界访问一组特定Pod的方式。service有自己的IP和端口，service为Pod提供了负载均衡。</p><p>Namespace：Namespace将物理的Cluster逻辑上划分成多个虚拟Cluster，每个Cluster就是一个Namespace。不同的Namespace里的资源是完全隔离的。</p><ul><li>default:默认的namespace</li><li>kube-system:K8s自己创建的的系统资源放到这个namespace</li></ul><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>Kubernetes集群包含有节点代理Kubelet和Master组件(APIs，scheduler，etc.)，下面是K8S的架构图。</p><img src="/blog/2020/06/03/Kubernetes%E6%A6%82%E8%BF%B0/pic1.png" srcset="/blog/img/loading.gif" class><p>Master节点包含APIServer、Scheduler(调度器)、ControllerManager(控制器管理器)这三个核心的组件。<br>Node节点包含的核心组件有Kubelet、Docker容器引擎、Kube-proxy</p><p>APIServer(kube-apiserver)：提供了HTTP/HTTPS RESTful API，即Kubernetes API。API server是KubernetesCluster的前端接口。其他客户端工具(CLI或UI)以及K8S其它组件可以通过它管理Cluster资源。</p><p>Scheduler(kube-scheduler)：调度器，它负责决定将Pod放在那个Node上运行。调度时候考虑Cluster拓扑，各个节点的负载，以及应用对高可用、性能、数据亲和性的需求。</p><p>Controller-Manager：负责监控每一个Controller(控制器)的健康状态，并确保控制器是健康的。而控制器是确保Pod健康的组件。</p><p>etcd：负责保存K8sCluster的配置信息和各种资源的状态信息。当数据发生变化时，etcd可以快速的通知K8s组件。</p><p>Pod网络：Pod能通信，k8scluster必须部署Pod网络(比如flannel是其中一个方案)</p><p>Kubelet：是Node的agent，当scheduler确定在某个Node上运行Pod后，会将Pod的具体配置信息(image、volume等)发送给该节点的kubelet，kubelet根据这些信息创建和运行容器，并向Master报告运行状态。<br>Kube-proxy：service在逻辑上代表了后端的多个Pod，外界通过service访问Pod。kube-proxy负责将service接收到的请求转发到Pod。每个node都运行kube-proxy服务，它负责将访问service的TCP/UDP数据流转发到后端服务器。如果有多个副本，kube-proxy实现负载均衡。</p>]]></content>
    
    
    <categories>
      
      <category>K8s</category>
      
    </categories>
    
    
    <tags>
      
      <tag>K8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kafka的数据管道和流式处理</title>
    <link href="/blog/2020/05/15/Kafka%E7%9A%84%E6%95%B0%E6%8D%AE%E7%AE%A1%E9%81%93%E5%92%8C%E6%B5%81%E5%BC%8F%E5%A4%84%E7%90%86/"/>
    <url>/blog/2020/05/15/Kafka%E7%9A%84%E6%95%B0%E6%8D%AE%E7%AE%A1%E9%81%93%E5%92%8C%E6%B5%81%E5%BC%8F%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="数据管道"><a href="#数据管道" class="headerlink" title="数据管道"></a>数据管道</h2><h3 id="数据管道的基本概念"><a href="#数据管道的基本概念" class="headerlink" title="数据管道的基本概念"></a>数据管道的基本概念</h3><p>在使用Kafka构建数据管道时，通常有两种使用场景：第一种，把Kafka作为数据管道的两个端点之一，例如把Kafka里的数据移动到云上，或者把MongoDB里的数据移动到Kafka里；第二种，把Kafka作为数据管道两个端点的中间媒介，例如为了把DB的数据移动到ElasticSearch上，需要先把它们移动到Kafka里，再将它们从Kafka移动到ElasticSearch上。</p><p>Kafka为数据管道带来的主要价值在于，它可以作为数据管道各个数据段之间的大型缓冲区，有效地解耦管道数据的生产者和消费者。数据管道的重要作用之一是解耦数据源和数据池，Kafka在这方面的能力以及在安全和效率方面的可靠性，使它成为构建数据管道的最佳选择。</p><h3 id="数据管道需要考虑的问题"><a href="#数据管道需要考虑的问题" class="headerlink" title="数据管道需要考虑的问题"></a>数据管道需要考虑的问题</h3><h4 id="及时性"><a href="#及时性" class="headerlink" title="及时性"></a>及时性</h4><p>有些系统希望每天一次性地接收大量数据，而有些则希望在数据生成几毫秒之内就能拿到它们。大部分数据管道介于这两者之间。一个好的数据集成系统能够很好地支持数据管道的各种及时性需求，而且在业务需求发生变更时，具有不同及时性需求的数据表之间可以方便地进行迁移。</p><p>Kafka作为一个基于流的数据平台，提供了可靠且可伸缩的数据存储，可以支持几近实时的数据管道和基于小时的批处理。生产者可以频繁地向Kafka写入数据，也可以按需写入。消费者可以在数据到达的第一时间读取它们，也可以每隔一段时间读取一次积压的数据。</p><p>Kafka在这里扮演了一个大型缓冲区的角色，降低了生产者和消费者之间的时间敏感度。实时的生产者和基于批处理的消费者可以同时存在，也可以任意组合。实现回压策略也因此变得更加容易，Kafka本身就使用了回压策略（必要时可以延后向生产者发送确认），消费速率完全取决于消费者自己。</p><h4 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h4><p>我们要避免单点故障，并能够自动从各种故障中快速恢复。数据通过数据管道到达业务系统，哪怕出现几秒钟的故障，也会造成灾难性的影响，对于那些要求毫秒级的及时性系统来说尤为如此。数据传递保证是可靠性的另一个重要因素。有些系统允许数据丢失，不过在大多数情况下，它们要求至少一次传递。也就是说，源系统的每一个事件都必须到达目的地，不过有时候需要进行重试，而重试可能造成重复传递。有些系统甚至要求仅一次传递一一源系统的每一个事件都必须到达目的地，不允许丢失，也不允许重复。</p><h4 id="高吞吐量和动态吞吐量"><a href="#高吞吐量和动态吞吐量" class="headerlink" title="高吞吐量和动态吞吐量"></a>高吞吐量和动态吞吐量</h4><p>为了满足现代数据系统的要求，数据管道需要支持非常高的吞吐量。更重要的是，在某些情况下，数据管道还需要能够应对突发的吞吐量增长。</p><p>由于我们将Kafka作为生产者和消费者之间的缓冲区，消费者的吞吐量和生产者的吞吐量就不会耦合在一起了。如果生产者的吞吐量超过了消费者的吞吐量，可以把数据积压在Kafka里，等待消费者追赶上来。通过增加额外的消费者或生产者可以实现Kafka的伸缩，因此我们可以在数据管道的任何一边进行动态的伸缩，以便满足持续变化的需求。</p><p>因为Kafka是一个高吞吐量的分布式系统，一个适当规模的集群每秒钟可以处理数百兆的数据，所以根本无需担心数据管道无住满足伸缩性需求。另外，ConnectAPI不仅支持伸缩，而且擅长并行处理任务。</p><h4 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h4><p>数据管道需要协调各种数据格式和数据类型，这是数据管道的一个非常重要的因素。数据类型取决于不同的数据库和数据存储系统。你可能会通过Avro将XML或关系型数据加载到Kafka里，然后将它们转成JSON写入ElasticSearch，或者写入HDFS等等。</p><p>Kafka和与数据格式无关。生产者和消费者可以使用各种序列化器来表示任意格式的数据。</p><h2 id="流式处理"><a href="#流式处理" class="headerlink" title="流式处理"></a>流式处理</h2><p>Kafka早期版本一般被认为是一个强大的消息总线，可以传递事件流，但没有处理和转换事件的能力。Kafka可靠的传递能力让它成为流式处理系统完美的数据来源。很多基于Kafka构建的流式处理系统都将Kafka作为唯一可靠的数据来源，如ApacheStorm、ApacheSparkStreaming、ApacheFlink、ApacheSamza等。</p><p>从0.10.0版本开始，Kafka不仅为每一个流行的流式处理框架提供了可靠的数据来橱，还提供了一个强大的流式处理类库，并将其作为客户端类库的一部分。这样，开发人员就可以在应用程序里读取、处理和生成事件，而不需要再依赖外部的处理框架。</p><h3 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h3><p>先来看看什么是数据流（也被称为“事件流”或“流数据”）。首先，数据流是无边界数据集的抽象表示。无边界意味着无限和持续增长。无边界数据集之所以是无限的，是因为随着时间的推移，新的记录会不断加入进来。</p><p>这个简单的模型（事件流）可以表示很多业务活动，比如信用卡交易、股票交易、包裹递送、流经交换机的网络事件、制造商设备传感器发出的事件、发送出去的邮件、游戏里物体的移动，等等。这个清单是无穷无尽的，因为几乎每一件事情都可以被看成事件的序列。</p><p>除了没有边界外，事件流模型还有其他一些属性。</p><p><strong>事件流是有序的</strong></p><p>事件的发生总是有个先后顺序。以金融活动事件为例，先将钱存进账户后再花钱，这与先花钱再还钱的次序是完全不一样的。后者会出现透支，而前者不会。</p><p><strong>不可变的数据记录</strong></p><p>事件一旦发生，就不能被改变。一个金融交易被取消，并不是说它就消失了，相反，这需要往事件流里添加一个额外的事件，表示前一个交易的取消操作。顾客的一次退货并不意味着之前的销售记录被删除，相反，退货行为被当成一个额外的事件记录下来。这是数据流与数据表之间的另一个不同点一一可以删除和修改数据表里的记录，但这些操作只不过是发生在数据库里的事务，这些事务可以被看成事件流。假设你对数据库的二进制日志（binlog）、预写式日志（WAL）和重做日志（redolog）的概念都很熟悉，那么就会知道，如果往数据库表插入一条记录，然后将其删除，表里就不会再有这条记录。但重做日志里包含了两个事务：插入事务和删除事务。</p><p><strong>事件流是可重播的</strong></p><p>这是事件流非常有价值的一个属性。但对于大多数业务来说，重播发生在几个月前（甚至几年前）的原始事件流是一个很重要的需求。可能是为了尝试使用新的分析方法纠正过去的错误，或是为了进行审计。</p><h3 id="流式处理中的基本概念"><a href="#流式处理中的基本概念" class="headerlink" title="流式处理中的基本概念"></a>流式处理中的基本概念</h3><p>流式处理的很多方面与普通的数据处理是很相似的：写一些代码来接收数据，对数据进行处理，可能做一些转换、聚合和增强的操作，然后把生成的结果输出到某个地方。不过流式处理有一些特有的概念，我们可以适当了解一下。</p><p><strong>时间</strong></p><p>在流式处理里，时间是一个非常重要的概念，因为大部分流式应用的操作都是基于时间窗口的。例如，流式应用可能会计算股价的5分钟移动平均数。如果生产者因为网络问题离线了2小时，然后带着2小时的数据重新连线，我们需要知道该如何处理这些数据。这些数据大部分都已经超过了5分钟，而且没有参与之前的计算。流式处理系统一般包含如下几个时间概念。</p><ul><li>事件时间：事件时间是指所追踪事件的发生时间和记录的创建时间。例如，度量的获取时间、商店里商品的出售时间、网站用户访问网页的时间，等等。在处理数据流肘，事件时间是很重要的。</li><li>日志追加时间：日志追加时间是指事件保存到broker的时间。这个时间戳一般与流式处理没有太大关系，因为用户一般只对事件的发生时间感兴趣。例如，如果要计算每天生产了多少台设备，就需要计算在那一天实际生产的设备数量，尽管这些事件有可能因为网络问题到了第二天才进入Kafka。不过，如果真实的事件时间没有被记录下来，那么就可以使用日志追加时间，在记录创建之后，这个时间就不会发生改变。</li><li>处理时间：处理时间是指应用程序在收到事件之后要对其进行处理的时间。这个时间可以是在事件发生之后的几毫秒、几小时或几天。同一个事件可能会被分配不同的时间戳，这取决于应用程序何时读取这个事件。如果应用程序使用了两个线程来读取同一个事件，这个时间戳也会不一样。所以这个时间戳非常不可靠，应该避免使用它。</li></ul><p><strong>状态</strong></p><p>如果只是单独处理每一个事件，那么流式处理就很简单。例如，如果想从Kafka读取电商购物交易事件流，找出金额超过10000元的交易，并将结果通过邮件发送给销售人员，那么可以使用Kafka消费者客户端，几行代码就可以搞定。</p><p>如果操作里包含了多个事件，流式处理就会变得很有意思，比如根据类型计算事件的数量、移动平均数、合并两个流以便生成更丰富的信息流。在这些情况下，光处理单个事件是不够的，需要跟踪更多的信息，比如这个小时内看到的每种类型事件的个数、需要合并的事件、将每种类型的事件值相加等等。事件与事件之间的信息被称为状态。<br>这些状态一般被保存在应用程序的本地变量里。流式处理包含以下几种类型的状态。</p><ul><li>本地状态或内部状态：这种状态只能被单个应用程序实例访问，它们一般使用内嵌在应用程序里的数据库进行维护和管理。本地状态的优势在于它的速度，不足之处在于它受到内存大小的限制。所以，流式处理的很多设计模式都将数据拆分到多个子流，这样就可以使用有限的本地状态来处理它们。</li><li>外部状态：这种状态使用外部的数据存储来维护，一般使用NoSQL系统，比如HDFS。使用外部存储的优势在于，它没有大小的限制，而且可以被应用程序的多个实例访问，甚至被不同的应用程序访问。不足之处在于，引人额外的系统会造成更大的延迟和复杂性。大部分流式处理应用尽量避免使用外部存储，或者将信息缓存在本地，减少与外部存储发生交互，以此来降低延迟。</li></ul><h3 id="流和表区别"><a href="#流和表区别" class="headerlink" title="流和表区别"></a>流和表区别</h3><p>大家都熟悉数据库表，表就是记录的集合，每个表都有一个主键，并包含了一系列由schema定义的属性。表的记录是可变的（可以在表上面执行更新和删除操作）。我们可以通过查询表数据获知某一时刻的数据状态。例如，通过查询客户信息这个表，就可以获取所有客户的联系信息。如果表被设计成不包含历史信息，那么就找不到客户过去的联系信息了。</p><p>在将表与流进行对比时，可以这么想：流包含了变更一一流是一系列事件，每个事件就是一个变更。表包含了当前的状态，是多个变更所产生的结果。</p><p>为了将表转化成流，需要捕捉到在表上所发生的变更，将“insert”、“update”和“delete”事件保存到流里。大部分数据库提供了用于捕捉变更的“ChangeDataCapture”（CDC）解决方案，Kafka连接器将这些变更发送到Kafka，用于后续的流式处理。</p><p>假设有一个商店，某零售活动可以使用一个事件流来表示：</p><p>“红色、蓝色和绿色鞋子到货”</p><p>“蓝色鞋子卖出”</p><p>“红色鞋子卖出”</p><p>“蓝色鞋子退货”</p><p>“绿色鞋子卖出”</p><p>如果想知道现在仓库里还有哪些库存，或者到目前为止赚了多少钱，可以用表。如果想知道鞋店的繁忙程度，可以查看整个事件流，会发现总共发生了5个交易，还可以查出为什么蓝色鞋子被退货。</p><h3 id="流式处理的常见场景"><a href="#流式处理的常见场景" class="headerlink" title="流式处理的常见场景"></a>流式处理的常见场景</h3><p>现在很多公司每天都会产生数以TB级的大数据，如何对这些数据进行挖掘，分析成了很重要的课题。比如：</p><ul><li><p>电子商务：需要处理并且挖掘用户行为产生的数据，产生推荐，从而带来更多的流量和收益。最理想的推荐就是根据兴趣推荐给用户本来不需要的东西！而每天处理海量的用户数据，需要一个低延时高可靠的实时流式分布式计算系统。</p></li><li><p>在线订购：假设客户向一个大型的连锁酒店预订了一个房间，连锁酒店的每一个系统在预订结束之后的几秒钟或者几分钟之内都能发出通知，包括客服中心、酒店、发送确认邮件的系统、网站等。有的酒店可能还希望客服中心能够立即获知用户在这家连锁酒店的历史入住数据，前台能够知道他是一个忠实的客户，从而提供更高级别的服务。如果使用流式处理应用来构建这些系统，就可以实现几近实时的接收和处理这些事件，从而带来更好的用户体验。</p></li><li><p>新闻聚合：新闻时效性非常重要，如果在一个重大事情发生后能够实时的推荐给用户，那么肯定能增大用户粘性，带来可观的流量。</p></li><li><p>社交网站：大家每天都会去社交网站是为了看看现在发生了什么，周围人在做什么。流式计算可以把用户关注的热点聚合，实时反馈给用户，从而达到一个圈子的聚合效果。</p></li><li><p>交通监管：每个城市的交通监管部门每天都要产生海量的视频数据，这些视频数据也是以流的形式源源不断的输系统中。实时流式计算系统需要以最快的速度来处理这些数据。</p></li><li><p>数据挖掘和机器学习：它们实际上是互联网公司内部使用的系统，主要为线上服务提供数据支撑。它们可以说是互联网公司的最核心的平台之一。系统的效率是挖掘的关键，理想条件下就是每天产生的海量数据都能得到有效处理，对于原来的数据进行全量更新。</p></li><li><p>大型集群的监控：自动化运维很重要，集群监控的实时预警机制也非常重要，而流式系统对于日志的实时处理，往往是监控系统的关键。</p></li><li><p>物联网：物联网包含很多东西。流式处理在传感器和设备上应用，最为常见的是用于预测何时该进行设备维护。这个与应用监控有点相似，不过这次是应用在硬件上，而且应用在很多不同的行业一一制造业、通信（识别故障基站）、有线电视（在用户投诉之前识别出故障机顶盒）等。</p><p>每一种场景都有自己的特点，不过目标是一样的处理大量来自设备的事件，并识别出一些模式，这些模式预示着某些设备需要进行维护，比如交换机数据包的下降、生产过程中需要更大的力气来拧紧螺丝，或者用户频繁重启有线电视的机顶盒。</p></li></ul><h3 id="流处理的简单使用"><a href="#流处理的简单使用" class="headerlink" title="流处理的简单使用"></a>流处理的简单使用</h3><p>pom文件中</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.kafka<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>kafka-streams<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>生产者</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Producer</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> KafkaProducer&lt;String, String&gt; producer = <span class="hljs-keyword">null</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Properties properties = <span class="hljs-keyword">new</span> Properties();        properties.put(<span class="hljs-string">"bootstrap.servers"</span>, <span class="hljs-string">"127.0.0.1:9092"</span>);        properties.put(<span class="hljs-string">"key.serializer"</span>, StringSerializer<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        properties.put(<span class="hljs-string">"value.serializer"</span>, StringSerializer<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        producer = <span class="hljs-keyword">new</span> KafkaProducer&lt;&gt;(properties);        <span class="hljs-comment">//商品名称</span>        String[] goods = &#123;<span class="hljs-string">"iphone"</span>, <span class="hljs-string">"huawei"</span>, <span class="hljs-string">"mi"</span>, <span class="hljs-string">"oppo"</span>, <span class="hljs-string">"vivo"</span>&#125;;        Random r = <span class="hljs-keyword">new</span> Random();        Random r1 = <span class="hljs-keyword">new</span> Random();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//待发送的消息实例</span>            ProducerRecord&lt;String, String&gt; record;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;                <span class="hljs-comment">//随机生成一次购买商品的数量</span>                <span class="hljs-keyword">int</span> goodscount = r.nextInt(<span class="hljs-number">10</span>);                <span class="hljs-comment">//商品列表</span>                StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">""</span>);                <span class="hljs-comment">//避免生成value是空的</span>                <span class="hljs-keyword">if</span> (goodscount == <span class="hljs-number">0</span>) &#123;                    <span class="hljs-keyword">continue</span>;                &#125;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; goodscount; j++) &#123;                    <span class="hljs-comment">//根据商品的数量，生成随机的商品信息，每件商品使用 空格分隔，例如：3个iphone huawei mi</span>                    sb.append(goods[r1.nextInt(goods.length)]).append(<span class="hljs-string">" "</span>);                &#125;                <span class="hljs-keyword">try</span> &#123;                    record = <span class="hljs-keyword">new</span> ProducerRecord&lt;&gt;(<span class="hljs-string">"phone"</span>, <span class="hljs-string">"sell"</span>, sb.toString());                    producer.send(record);                    System.out.println(<span class="hljs-string">"用户请求的商品："</span> + sb.toString());                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125; <span class="hljs-keyword">finally</span> &#123;            producer.close();        &#125;    &#125;&#125;</code></pre><p>流处理消费者</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsumerStream</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        Properties props = <span class="hljs-keyword">new</span> Properties();        <span class="hljs-comment">//每个stream应用都必须有唯一的id</span>        props.put(StreamsConfig.APPLICATION_ID_CONFIG, <span class="hljs-string">"phone_counts"</span>);        props.put(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="hljs-string">"127.0.0.1:9092"</span>);        <span class="hljs-comment">//流处理的消息序列化机制</span>        props.put(StreamsConfig.DEFAULT_KEY_SERDE_CLASS_CONFIG, Serdes.String().getClass().getName());        props.put(StreamsConfig.DEFAULT_VALUE_SERDE_CLASS_CONFIG, Serdes.String().getClass().getName());        <span class="hljs-comment">//每次获取数据从头开始</span>        props.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, <span class="hljs-string">"earliest"</span>);        <span class="hljs-comment">//流的建造器</span>        StreamsBuilder builder = <span class="hljs-keyword">new</span> StreamsBuilder();        <span class="hljs-comment">//流的输入源，kafka中主题phone</span>        KStream&lt;String, String&gt; source = builder.stream(<span class="hljs-string">"phone"</span>);        <span class="hljs-comment">//使用流统计，类似于数据表</span>        KTable&lt;String, Long&gt; wordsCount = source.flatMapValues(value -&gt; Arrays.asList(value.toLowerCase().split(<span class="hljs-string">" "</span>)))                .groupBy((key, value) -&gt; value)                .count(Materialized.as(<span class="hljs-string">"counts"</span>));        <span class="hljs-comment">//将流处理结果写入另一个主题</span>        wordsCount.toStream().to(<span class="hljs-string">"phone_count"</span>, Produced.with(Serdes.String(), Serdes.Long()));        <span class="hljs-comment">//定义KafkaStream对象</span>        KafkaStreams kafkaStreams = <span class="hljs-keyword">new</span> KafkaStreams(builder.build(), props);        kafkaStreams.start();        TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);        builder.build();    &#125;&#125;</code></pre><p>接收流处理结果的消费者</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> KafkaConsumer&lt;String, String&gt; consumer = <span class="hljs-keyword">null</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">/*发送配置的实例*/</span>        Properties properties = <span class="hljs-keyword">new</span> Properties();        properties.put(<span class="hljs-string">"bootstrap.servers"</span>, <span class="hljs-string">"127.0.0.1:9092"</span>);        properties.put(<span class="hljs-string">"key.deserializer"</span>, StringDeserializer<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        properties.put(<span class="hljs-string">"value.deserializer"</span>, LongDeserializer<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        <span class="hljs-comment">/*每次获取数据从头开始*/</span>        properties.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, <span class="hljs-string">"earliest"</span>);        properties.put(<span class="hljs-string">"group.id"</span>, <span class="hljs-string">"phone_count_1"</span>);        consumer = <span class="hljs-keyword">new</span> KafkaConsumer&lt;&gt;(properties);        <span class="hljs-keyword">try</span> &#123;            consumer.subscribe(Collections.singletonList(<span class="hljs-string">"phone_count"</span>));            <span class="hljs-comment">//无限循环</span>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;                ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofSeconds(<span class="hljs-number">5</span>));                <span class="hljs-keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;                    System.out.println(String.format(<span class="hljs-string">"主题：%s，分区：%d，偏移量：%d，key：%s，value：%s"</span>,                            record.topic(), record.partition(), record.offset(), record.key(), record.value()));                &#125;            &#125;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            consumer.close();        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>消息中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>消息中间件</tag>
      
      <tag>Kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kafka的深入理解</title>
    <link href="/blog/2020/05/14/Kafka%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
    <url>/blog/2020/05/14/Kafka%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="集群成员间关系"><a href="#集群成员间关系" class="headerlink" title="集群成员间关系"></a>集群成员间关系</h2><img src="/blog/2020/05/14/Kafka%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/pic1.png" srcset="/blog/img/loading.gif" class><p>Kafka使用zookeeper来维护集群成员的信息。每个broker都有个唯一标识符，这个标识符可以在配置文件里指定，也可以自动生成。在broker启动的时候，它通过创建临时节点把自己的ID注册到zookeeper。Kafka组件订阅Zookeeper的/brokers/ids路径（broker在zookeeper上的注册路径），当有broker加入集群或退出集群时，这些组件就可以获得通知。</p><p>如果启动另一个具有相同ID的broker，会得到一个错误。新broker会试着进行注册，但不会成功，因为zookeeper里已经有一个具有相同ID的broker。</p><p>在broker停机、出现网络分区或长时间垃圾回收停顿时，broker会从Zookeeper上断开连接，此时broker在启动时创建的临时节点会自动从Zookeeper上移除。监听broker列表的Kafka组件会被告知该broker已移除。</p><p>在关闭broker时，它对应的节点也会消失，不过它的ID会继续存在于其他数据结构中。例如，主题的副本列表里就可能包含这些ID。在完全关闭一个broker之后，如果使用相同的ID启动另一个全新的broker，它会立刻加入集群,并拥有与旧broker相同的分区和主题。</p><h2 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h2><p>控制器其实就是一个broker，只不过它除了具有一般broker的功能之外，还负责分区首领的选举。集群里第一个启动的broker通过在Zookeeper里创建一个临时节点/controuer让自己成为控制器。其他broker在启动时也会尝试创建这个节点，不过它们会收到一个“节点已存在”的异常，然后“意识”到控制器节点已存在，也就是说集群里已经有一个控制器了。其他broker在控制器节点上创建Zookeeperwatch对象，这样它们就可以收到这个节点的变更通知。这种方式可以确保集群里一次只有一个控制器存在。</p><p>如果控制器被关闭或者与Zookeeper断开连接，zookeeper上的临时节点就会消失。集群里的其他broker通过watch对象得到控制器节点消失的通知，它们会尝试让自己成为新的控制器。第一个在Zookeeper里成功创建控制器节点的broker就会成为新的控制器，其他节点会收到“节点已存在”的异常,然后在新的控制器节点上再次创建watch对象。</p><p>当控制器发现一个broker已经离开集群，它就知道，那些失去首领的分区需要一个新首领（这些分区的首领刚好是这个broker）。控制器遍历这些分区，并确定谁应该成为新首领（简单来说就是分区副本列表里的下一个副本），然后向所有包含新首领或现有跟随者的broker发送请求。该请求消息包含了谁是新首领以及谁是分区跟随者的信息。随后，新首领开始处理来自生产者和消费者的请求，而跟随者开始从新首领那里复制消息。</p><p>当控制器发现一个broker加入集群时，它会使用brokerID来检査新加入的broker是否包含现有分区的副本。如果有，控制器就把变更通知发送给新加入的broker和其他broker，新broker上的副本开始从首领那里复制消息。</p><p>简而言之，Kafka使用Zookeeper的临时节点来选举控制器，并在节点加入集群或退出集群时通知控制器。控制器负责在节点加入或离开集群时进行分区首领选举。</p><h2 id="复制-Kafka的核心"><a href="#复制-Kafka的核心" class="headerlink" title="复制-Kafka的核心"></a>复制-Kafka的核心</h2><p>复制功能是Kafka架构的核心。在Kafka的文档里，Kafka把自己描述成“一个分布式的、可分区的、可复制的提交日志服务”。复制之所以这么关键，是因为它可以在个别节点失效时仍能保证Kafka的可用性和持久性。</p><p>Kafka使用主题来组织数据，每个主题被分为若干个分区，每个分区有多个副本。那些副本被保存在broker上，每个broker可以保存成百上千个属于不同主题和分区的副本。</p><h3 id="replication-factor"><a href="#replication-factor" class="headerlink" title="replication-factor"></a>replication-factor</h3><p>用来设置主题的副本数。每个主题可以有多个副本，副本位于集群中不同的broker上，也就是说副本的数量不能超过broker的数量，否则创建主题时会失败。</p><p>比如有两个Broker，replicationFactor设置为2，每个broker都会有所有分区的副本存在，如果设置为1，分区会被均匀分布在Broker。</p><pre><code class="hljs brainfuck"><span class="hljs-comment">kafka</span><span class="hljs-literal">-</span><span class="hljs-comment">topics</span><span class="hljs-string">.</span><span class="hljs-comment">bat</span>--<span class="hljs-comment">zookeeperlocalhost:2181/kafka</span>--<span class="hljs-comment">create</span>--<span class="hljs-comment">topictopicA</span>--<span class="hljs-comment">replication</span><span class="hljs-literal">-</span><span class="hljs-comment">factor2</span>--<span class="hljs-comment">partitions2</span></code></pre><h3 id="副本类型"><a href="#副本类型" class="headerlink" title="副本类型"></a>副本类型</h3><ul><li><strong>首领副本</strong>：每个分区都有一个首领副本。为了保证一致性,所有生产者请求和消费者请求都会经过这个副本 ；</li><li><strong>跟随者副本</strong>：首领以外的副本都是跟随者副本。跟随者副本不处理来自客户端的请求，它们唯一的任务就是从首领那里复制消息，保持与首领一致的状态 。如果首领发生崩溃,，其中的一个跟随者会被提升为新首领 。</li><li><strong>优先副本</strong>：如果一个分区有3个副本，且这3个副本的优先级别分别为0、1、2，根据优先副本的概念，0会作为首领副本 。当0节点挂掉时，会启动1节点的跟随者副本作为首领副本。当0节点再次启动后，会自动触发首领选举，让0节点的副本作为此分区的首领副本。不会导致负载不均衡和资源浪费，这就是leader的均衡机制。可以通过auto.leader.rebalance.enabl参数设置，默认为true开启状态。</li></ul><h3 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h3><p>首领的另一个任务是搞清楚哪个跟随者的状态与自己是一致的。跟随者为了保持与首领的状态一致，在有新消息到达时会尝试从首领那里复制消息，不过可能有各种原因会导致同步失败。例如，网络拥塞导致复制变慢，broker发生崩溃导致复制滞后，直到重启broker后复制才会继续。</p><p>为了与首领保持同步，跟随者会向首领发送获取数据的请求，这种请求与消费者为了读取消息而发送的请求是一样的。首领将响应消息发给跟随者。请求消息里包含了跟随者想要获取消息的偏移量，而且这些偏移量总是有序的。</p><p>一个跟随者副本先请求消息1，接着请求消息2，然后请求消息3，在收到这3个请求的响应之前，它是不会发送第4个请求消息的。如果跟随者发送了请求消息4，那么首领就知道它已经收到了前面3个请求的响应。通过査看每个跟随者请求的最新偏移量，首领就会知道每个跟随者复制的进度。如果跟随者在10s内没有请求任何消息，或者虽然在请求消息，但在10s内没有请求最新的数据，那么它就会被认为是不同步的。如果一个副本无法与首领保持一致，在首领发生失效时，它就不可能成为新首领，因为它没有包含全部的消息。</p><h2 id="处理请求的内部机制"><a href="#处理请求的内部机制" class="headerlink" title="处理请求的内部机制"></a>处理请求的内部机制</h2><p>broker的大部分工作是处理客户端、分区副本和控制器发送给分区首领的请求。Kafka提供了一个二进制协议（基于TCP），指定了请求消息的格式以及broker如何对请求作出响应——包括成功处理请求或在处理请求过程中遇到错误。</p><p>客户端发起连接并发送请求，broker处理请求并作出响应。broker按照请求到达的顺序来处理它们这种顺序保证让Kaka具有了消息队列的特性，同时保证保存的消息也是有序的。</p><p>所有的请求消息都包含一个标准消息头：RequestType也就是APIkey、RequestVersion用于broker处理不同版本的客户端请求，并根据客户端版本作出不同的响应。Correlationid具有唯一性的数字，用于标识请求消息，同时也会出现在响应消息和错误日志里，用于诊断问题，ClientId用于标识发送请求的客户端。</p><p>broker会在它所监听的每一个端口上运行一个Acceptor线程，这个线程会创建一个连接并把它交给Processor线程（也被叫作“网络线程”）去处理。Processor线程的数量是可配置的。网络线程负责从客户端获取请求消息，把它们放进请求队列，然后从响应队列获取响应消息，把它们发送给客户端。</p><p>请求消息被放到请求队列后，IO线程会负责处理它们，处理方式为为NIO。比较常见的请求类型有：</p><ul><li>生产请求：生产者发送的请求，它包含客户端要写入 broker 的消息。 </li><li>获取请求：在消费者和跟随者副本需要从broker读取消息时发送的请求。</li></ul><img src="/blog/2020/05/14/Kafka%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/pic2.png" srcset="/blog/img/loading.gif" class><p>生产请求和获取请求都必须发送给分区的首领副本。如果broker收到一个针对特定分区的请求，而该分区的首领在另一个broker上，那么发送请求的客户端会收到一个“非分区首领”的错误响应。当针对特定分区的获取请求被发送到一个不含有该分区首领的broker上，也会出现同样的错误。Kafka客户端要自己负责把生产请求和获取请求发送到正确的broker上。</p><p>所以客户端使用了另一种请求类型，也就是元数据请求。这种请求包含了客户端订阅的主题列表。服务器端的响应消息里指明了这些主题所包含的分区、每个分区都有哪些副本，以及哪个副本是首领。元数据请求可以发送给任意一个broker，因为所有broker都缓存了这些信息。</p><img src="/blog/2020/05/14/Kafka%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/pic3.png" srcset="/blog/img/loading.gif" class><p>一般情况下，客户端会把这些信息缓存起来，并直接往目标broker上发送生产请求和获取请求。它们需要时不时地通过发送元数据请求来刷新这些信息（刷新的时间间隔通过metadata.max.age.ms参数来配置，2.1.3的客户端默认参数30S），从而知道元数据是否发生了变更，比如在新broker加入集群时，部分副本会被移动到新的broker上。另外，如果客户端收到“非首领”错误，它会在尝试重发请求之前先刷新元数据，因为这个错误说明了客户端正在使用过期的元数据信息，之前的请求被发到了错误的broker上。</p><h3 id="生产请求"><a href="#生产请求" class="headerlink" title="生产请求"></a>生产请求</h3><p>acks这个配置参数指定了需要多少个broker确认才可以认为一个消息写入是成功的。不同的配置对“写入成功”的界定是不一样的，如果acks=1，那么只要首领收到消息就认为写入成功；如果acks=all，那么需要所有同步副本收到消息才算写入成功；如果acks=0，那么生产者在把消息发出去之后，完全不需要等待broker的响应。</p><p>包含首领副本的broker在收到生产请求时，会对请求做一些验证：</p><ul><li>发送数据的用户是否有主题写入权限</li><li>请求里包含的acks值是否有效（只允许出现0、1或all，ack=-1等同于ack=all）</li><li>如果acks=all是否有足够多的同步副本保证消息已经被安全写入</li></ul><p>之后，消息被写入本地磁盘。在Linux系统上，消息会被写到文件系统缓存里，并不保证它们何时会被刷新到磁盘上。Kafka不会一直等待数据被写到磁盘上，它依赖复制功能来保证消息的持久性。</p><p>在消息被写入分区的首领之后，broker开始检査acks配置参数。如果acks被设为0或1，那么broker立即返回响应；如果acks被设为all，那么请求会被保存在一个叫作炼狱的缓冲区里，直到首领发现所有跟随者副本都复制了消息，响应才会被返回给客户端。</p><h3 id="获取请求"><a href="#获取请求" class="headerlink" title="获取请求"></a>获取请求</h3><p>broker处理获取请求的方式与处理生产请求的方式很相似。客户端发送请求，向broker请求主题分区里具有特定偏移量的消息。类似于“请把主题Test分区0偏移量从53开始的消息，以及主题Test分区3偏移量从64开始的消息发给我。”</p><p>客户端还可以指定broker最多可以从一个分区里返回多少数据。这个限制是非常重要的，因为客户端需要为broker返回的数据分配足够的内存。如果没有这个限制，broker返回的大量数据有可能耗尽客户端的内存。</p><img src="/blog/2020/05/14/Kafka%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/pic4.png" srcset="/blog/img/loading.gif" class><p>请求需要先到达指定的分区首领上，然后客户端通过査询元数据来确保请求的路由是正确的。首领在收到请求时，它会先检査请求是否有效，比如指定的偏移量在分区上是否存在。如果客户端请求的是已经被删除的数据，或者请求的偏移量不存在，那么broker将返回一个错误。如果请求的偏移量存在，broker将按照客户端指定的数量上限从分区里读取消息，再把消息返回给客户端。</p><p>Kafka使用零复制技术向客户端发送消息一一也就是说，Kafka直接把消息从文件（或者更确切地说是Linux文件系统缓存）里发送到网络通道，而不需要经过任何中间缓冲区。这是Kafka与其他大部分数据库系统不一样的地方，其他数据库在将数据发送给客户端之前会先把它们保存在本地缓存里。这项技术避免了字节复制，也不需要管理内存缓冲区，从而获得更好的性能。</p><p>客户端除了可以设置broker返回数据的上限，也可以设置下限。例如把下限设置为10KB，就好像是在告诉broker：“等到有10KB数据的时候再把它们发送给我。”在主题消息流量不是很大的情况下，这样可以减少CPU和网络开销。客户端发送一个请求，broker等到有足够的数据时才把它们返回给客户端，然后客户端再发出请求，而不是让客户端每隔几毫秒就发送一次请求，每次只能得到很少的数据甚至没有数据。对比这两种情况，它们最终读取的数据总量是一样的，但前者的来回传送次数更少，因此开销也更小。当然，我们不会让客户端一直等待broker累积数据。在等待了一段时间之后，就可以把可用的数据拿回处理，而不是一直等待下去。所以，客户端可以定义一个超时时间，告诉broker：“如果你无法在K毫秒内累积满足要求的数据量,那么就把当前这些数据返回给我。”</p><h2 id="ISR"><a href="#ISR" class="headerlink" title="ISR"></a>ISR</h2><p>在客户端获取消息时，并不是所有保存在分区首领上的数据都可以被客户端读取。大部分客户端只能读取已经被写入所有同步副本的消息。分区首领知道每个消息会被复制到哪个副本上，在消息还没有被写入所有同步副本之前，是不会发送给消费者的，尝试获取这些消息的请求会得到空的响应而不是错误。</p><img src="/blog/2020/05/14/Kafka%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/pic5.png" srcset="/blog/img/loading.gif" class><p>因为还没有被足够多副本复制的消息被认为是“不安全”的，如果首领发生崩溃，另一个副本成为新首领，那么这些消息就丢失了。如果我们允许消费者读取这些消息，可能就会破坏一致性。可能会出现一个消费者读取并处理了这样的一个消息，而另一个消费者发现这个消息其实并不存在的情况。所以，我们会等到所有同步副本复制了这些消息，才允许消费者读取它们。这也意味着，如果broker间的消息复制因为某些原因变慢，那么消息到达消费者的时间也会随之变长（因为我们会先等待消息复制完毕）。延迟时间可以通过参数replica.lag.time.max.ms来配置，它指定了副本在复制消息时可被允许的最大延迟时间。</p><p>Kafka的数据复制是以Partition为单位的。而多个备份间的数据复制，通过Follower向Leader拉取数据完成。从一这点来讲，有点像Master-Slave方案。不同的是，Kafka既不是完全的同步复制，也不是完全的异步复制，而是基于ISR的动态复制方案，这个方案允许有适当的丢失。</p><p>ISR，即In-SyncReplica。每个Partition的Leader都会维护这样一个列表，该列表中，包含了所有与之同步的Replica（包含Leader自己）。每次数据写入时，只有ISR中的所有Replica都复制完，Leader才会将其置为Commit，它才能被Consumer所消费。</p><p>这种方案，与同步复制非常接近。但不同的是，这个ISR是由Leader动态维护的。如果Follower不能紧跟上Leader，它将被Leader从ISR中移除，待它又重新跟上Leader后，会被Leader再次加入ISR中。每次改变ISR后，Leader都会将最新的ISR持久化到Zookeeper中。</p><p>至于如何判断某个Follower是否跟上Leader，不同版本的Kafka的策略稍微有些区别。从0.9.0.0版本开始，replica.lag.max.messages被移除，故Leader不再考虑Follower落后的消息条数。另外，Leader不仅会判断Follower是否在replica.lag.time.max.ms时间内向其发送Fetch请求，同时还会考虑Follower是否在该时间内与之保持同步。</p><img src="/blog/2020/05/14/Kafka%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/pic6.png" srcset="/blog/img/loading.gif" class><p>在第一步中，LeaderA总共收到3条消息，但由于ISR中的Follower只同步了第1条消息m1，故只有m1被Commit，也就是说只有m1可被Consumer消费。此时FollowerB与LeaderA的差距是1，而FollowerC与LeaderA的差距是2，虽然有消息的差距，但是满足同步副本的要求保留在ISR中。</p><p>在第二步中，由于旧的LeaderA宕机，新的LeaderB在replica.lag.time.max.ms时间内未收到来自A的Fetch请求，故将A从ISR中移除，此时ISR={B，C}。同时，由于此时新的LeaderB中只有2条消息，并未包含m3（m3从未被任何Leader所Commit），所以m3无法被Consumer消费。上图中就是因为acks不为all或者-1,不全部复制，就会导致单台服务器宕机时的数据丢失m3丢失了。</p><h3 id="使用ISR方案的原因"><a href="#使用ISR方案的原因" class="headerlink" title="使用ISR方案的原因"></a>使用ISR方案的原因</h3><p>由于Leader可移除不能及时与之同步的Follower，故与同步复制相比可避免最慢的Follower拖慢整体速度，提高了系统可用性。ISR中的所有Follower都包含了所有Commit过的消息，而只有Commit过的消息才会被Consumer消费，故从Consumer的角度而言，ISR中的所有Replica都始终处于同步状态，从而与异步复制方案相比提高了数据一致性。</p><h3 id="ISR相关配置说明"><a href="#ISR相关配置说明" class="headerlink" title="ISR相关配置说明"></a>ISR相关配置说明</h3><p>Broker的min.insync.replicas参数指定了Broker所要求的ISR最小长度，默认值为1。也即极限情况下ISR可以只包含Leader。但此时如果Leader宕机，则该Partition不可用，可用性得不到保证。</p><p>只有被ISR中所有Replica同步的消息才被Commit，但Producer发布数据时，Leader并不需要ISR中的所有Replica同步该数据才确认收到数据。Producer可以通过acks参数指定最少需要多少个Replica确认收到该消息才视为该消息发送成功。acks的默认值是1，即Leader收到该消息后立即告诉Producer收到该消息，此时如果在ISR中的消息复制完该消息前Leader宕机，那该条消息会丢失。而如果将该值设置为0，则Producer发送完数据后，立即认为该数据发送成功，不作任何等待，而实际上该数据可能发送失败，并且Producer的Retry机制将不生效。更推荐的做法是，将acks设置为all或者-1，此时只有ISR中的所有Replica都收到该数据（也即该消息被Commit），Leader才会告诉Producer该消息发送成功，从而保证不会有未知的数据丢失。</p><h2 id="物理存储机制"><a href="#物理存储机制" class="headerlink" title="物理存储机制"></a>物理存储机制</h2><p>Kafka的基本存储单元是分区。分区无法在多个broker间进行再细分，也无法在同一个broker的多个磁盘上进行再细分。在配置Kafka的时候，管理员指定了一个用于存储分区的目录清单，也就是log.dirs参数的值（不要把它与存放错误日志的目录混淆了，日志目录是配置在1og4j.properties文件里的）。该参数一般会包含每个挂载点的目录。</p><h3 id="分区分配"><a href="#分区分配" class="headerlink" title="分区分配"></a>分区分配</h3><p>在创建主题时，Kafka首先会决定如何在broker间分配分区。假设你有6个broker，打算创建一个包含10个分区的主题，并且复制系数为3（确保至少有3台broker）。那么Kafka就会有30个分区副本，它们可以被分配给6个broker。在进行分区分配时，我们要达到如下的目标：</p><ul><li>在broker间平均地分布分区副本。对于我们的例子来说，就是要保证每个broker可以分到5个副本。</li><li>确保每个分区的每个副本分布在不同的broker上。假设分区0的首领副本在broker2上，那么可以把跟随者副本放在broker3和broker4上，但不能放在broker2上，也不能两个都放在broker3上。</li><li>如果为broker指定了机架信息，那么尽可能把每个分区的副本分配到不同机架的broker上。这样做是为了保证一个机架的不可用不会导致整体的分区不可用。</li></ul><p>为了实现这个目标，我们先随机选择一个broker（假设是4），然后使用轮询的方式给每个broker分配分区来确定首领分区的位置。于是，首领分区0会在broker4上，首领分区l会在broker5上，首领分区2会在broker0上（只有6个broker），并以此类推。然后，我们从分区首领开始，依次分配跟随者副本。如果分区0的首领在broker4上，那么它的第一个跟随者副本会在broker5上，第二个跟随者副本会在broker0上。分区1的首领在broker5上，那么它的第一个跟随者副本在broker0上，第二个跟随者副本在broker1上。</p><p>为分区和副本选好合适的broker之后，接下来要决定这些分区应该使用哪个目录。我们单独为每个分区分配目录，规则很简单计算每个目录里的分区数量，新的分区总是被添加到数量最小的那个目录里。也就是说，如果添加了一个新磁盘，所有新的分区都会被创建到这个磁盘上。因为在完成分配工作之前，新磁盘的分区数量总是最少的（最少使用原则）。</p><h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><p>数据持久化是Kafka的一个基本特性，Kafka不会一直保留数据，也不会等到所有消费者都读取了消息之后才删除消息。相反，Kafka管理员为每个主题配置了数据保留期限，规定数据被删除之前可以保留多长时间，或者清理数据之前可以保留的数据量大小。</p><p>因为在一个大文件里査找和删除消息是很费时的，也很容易出错，所以分区分成若干个片段。默认情况下，每个片段包含1GB或一周的数据，以较小的那个为准。在broker往分区写入数据时，如果达到片段上限，就关闭当前文件，并打开一个新文件。</p><p>当前正在写入数据的片段叫作活跃片段。活动片段永远不会被删除，所以如果你要保留数据1天，但片段里包含了5天的数据，那么这些数据会被保留5天，因为在片段被关闭之前这些数据无法被删除。如果你要保留数据一周，而且每天使用一个新片段，那么你就会看到，每天在使用一个新片段的同时会删除一个最老的片段，所以大部分时间该分区会有7个片段存在。</p><h3 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h3><p>Kafka的消息和偏移量保存在文件里。保存在磁盘上的数据格式与从生产者发送过来或者发送给消费者的消息格式是一样的。因为使用了相同的消息格式，在进行磁盘存储和网络传输，Kafka可以使用零复制技术给消费者发送消息，同时避免了对生产者已经压缩过的消息进行解压和再圧缩。</p><img src="/blog/2020/05/14/Kafka%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/pic7.png" srcset="/blog/img/loading.gif" class><p>除了键、值和偏移量外，消息里还包含了消息大小、校验、消息格式、版本号、压缩算法（snappy、Gzip或Lz4）和时间戳(在0.10.0版本里引入的)。时间戳可以是生产者发送消息的时间,也可以是消息到达broker的时间,这个是可配置的。</p><p>如果生产者发送的是圧缩过的消息，那么同一个批次的消息会被压缩在一起，被当作“包装消息”进行发送。broker收到这样的消息然后再把它发送给消费者。消费者在解压这个消息之后，会看到整个批次的消息，它们都有自己的时间戳和偏移量。</p><img src="/blog/2020/05/14/Kafka%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/pic8.png" srcset="/blog/img/loading.gif" class><p>如果在生产者端使用了压缩功能（极力推荐），那么发送的批次越大，就意味着在网络传输和磁盘存储方面会获得越好的压缩性能，同时意味着如果修改了消费者使用的消息格式（例如，在消息里增加了时间戳），那么网络传输和磁盘存储的格式也要随之修改，而且broker要知道如何处理包含了两种消息格式的文件。一种是普通消息，一种是包装消息。</p><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>消费者可以从Kafka的任意可用偏移量位置开始读取消息。假设消费者要读取从偏移量100开始的1MB消息，那么broker必须立即定位到偏移量100（可能是在分区的任意一个片段里），然后开始从这个位置读取消息。为了帮助broker更快地定位到指定的偏移量，Kafka为每个分区维护了一个索引。索引把偏移量映射到片段文件和偏移量在文件里的位置。</p><p>索引也被分成片段，所以在删除消息时，也可以删除相应的索引。Kafka不维护索引的校验和。如果索引出现损坏，Kafka会通过重新读取消息并录制偏移量和位置来重新生成索引。如果有必要，管理员可以删除索引，这样做是绝对安全的，Kafka会自动重新生成这些索引。</p><h3 id="超时数据的清理机制"><a href="#超时数据的清理机制" class="headerlink" title="超时数据的清理机制"></a>超时数据的清理机制</h3><p>注意， 超时数据的清理并不是过期文件的清理，一般情况下，Kafka会根据设置的时间保留数据，把超过时效的旧数据删除掉。比如一个应用程序使用Kafka保存它的状态，每次状态发生变化就把状态写入Kafka。在应用程序从崩演中恢复时，它从Kafka读取消息来恢复最近的状态。在这种情况下，应用程序只关心它在崩溃前的那个状态，而不关心运行过程中的那些状态。Kafka通过改变主题的保留策略来满足这些使用场景。早于保留时间的事件会被删除，为每个键保留最新的值，从而达到清理的效果。</p><p>每个日志片段可以分为以下两个部分：</p><ul><li>干净的部分，这些消息之前被清理过，每个键只有一个对应的，这个值是上一次清理时保留下来的。</li><li>污浊的部分，这些消息是在上一次清理之后写入的。</li></ul><p>为了清理分区，清理线程会读取分区的污浊部分，并在内存里创建一个map。map里的每个元素包含了消息键的散列值和消息的偏移量，键的散列值是16B，加上偏移量总共是24B。如果要清理一个1GB的日志片段，并假设每个消息大小为1KB，那么这个片段就包含一百万个消息，而我们只需要用24MB的map就可以清理这个片段。如果有重复的键,可以重用散列项,从而使用更少的内存。</p><p>清理线程在创建好偏移量map后，开始从干净的片段处读取消息，从最旧的消息开始，把它们的内容与map里的内容进行比对。它会检査消息的键是否存在于map中，如果不存在，那么说明消息的值是最新的，就把消息复制到替換片段上。如果键已存在，消息会被忽略，因为在分区的后部已经有一个具有相同键的消息存在。在复制完所有的消息之后，我们就将替換片段与原始片段进行交换，然后开始清理下一个片段。完成整个清理过程之后，每个键对应一个不同的消息一这些消息的值都是最新的。清理前后的分区片段如图所示。</p><img src="/blog/2020/05/14/Kafka%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/pic9.png" srcset="/blog/img/loading.gif" class><p>清理的思想就是根据Key的重复来进行整理，注意，它不是数据删除策略，而是类似于压缩策略，如果key送入了值，对于业务来说，key的值应该是最新的value才有意义，所以进行清理后只会保存key的最新value，这个适用于一些业务场景，比如说key代表用户ID，Value用户名称，如果使用清理功能就能够达到最新的用户的名称的消息（这个功能有限，请参考使用）。</p><h2 id="可靠的数据"><a href="#可靠的数据" class="headerlink" title="可靠的数据"></a>可靠的数据</h2><h3 id="Kafka提供的可靠性保证和架构上的权衡"><a href="#Kafka提供的可靠性保证和架构上的权衡" class="headerlink" title="Kafka提供的可靠性保证和架构上的权衡"></a>Kafka提供的可靠性保证和架构上的权衡</h3><p>可靠性时，我们一般会使用保证这个词，它是指确保系统在各种不同的环境下能够发生一致的行为。ACID大概是大家最熟悉的一个例子，它是关系型数据库普遍支持的标准可靠性保证。ACID指的是原子性、一致性、隔离性和持久性。如果一个供应商说他们的数据库遵循ACID规范，其实就是在说他们的数据库支持与事务相关的行为。有了这些保证，我们才能相信关系型数据库的事务特性可以确保应用程序的安全。我们知道系统承诺可以做到些什么，也知道在不同条件下它们会发生怎样的行为。我们了解这些保证机制，就可以基于这些保证机制开发安全的应用程序。</p><p>所以，了解系统的保证机制对于构建可靠的应用程序来说至关重要，这也是能够在不同条件下解释系统行为的前提。那么Kafka可以在哪些方面作出保证呢？</p><ul><li>Kafka可以保证分区消息的顺序。如果使用同一个生产者往同一个分区写入消息，而且消息B在消息A之后写入，那么Kafka可以保证消息B的偏移量比消息A的偏移量大，而且消费者会先读取消息A再读取消息B。</li><li>只有当消息被写入分区的所有同步副本时（但不一定要写入磁盘），它才被认为是“已提交”的。生产者可以选择接收不同类型的确认（acks），比如在消息被完全提交时的确认，或者在消息被写入首领副本时的确认，或者在消息被发送到网络时的确认。</li><li>只要还有一个副本是活跃的，那么已经提交的消息就不会丢失。消费者只能读取已经提交的消息。</li></ul><p>这些基本的保证机制可以用来构建可靠的系统，但仅仅依赖它们是无法保证系统完全可靠的。构建一个可靠的系统需要作出一些权衡，Kafka管理员和开发者可以在配置参数上作出权衡，从而得到他们想要达到的可靠性。这种权衡一般是指消息存储的可靠性和一致性的重要程度与可用性、高吞吐量、低延迟和硬件成本的重要程度之间的权衡。</p><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p>Kafka的复制机制和分区的多副本架构是Kafka可靠性保证的核心。把消息写入多个副本可以使Kafka在发生崩溃时仍能保证消息的持久性。</p><p>Kafka的主题被分为多个分区，分区是基本的数据块。分区存储在单个磁盘上，Kafka可以保证分区里的事件是有序的，分区可以在线（可用），也可以离线（不可用）。每个分区可以有多个副本，其中一个副本是首领。所有的事件都直接发送给首领副本，或者直接从首领副本读取事件。其他副本只需要与首领保持同步，并及时复制最新的事件。当首领副本不可用时，其中一个同步副本将成为新首领。</p><p>分区首领是同步副本，而对于跟随者副本来说，它需要满足以下条件才能被认为是同步的。</p><ul><li>与Zookeeper之间有一个活跃的会话，也就是说，它在过去的6秒（可配置）内向Zookeeper发送过心跳。</li><li>在过去的10s内（可配置）从首领那里获取过消息。</li><li>在过去的10s内从首领那里获取过最新的消息。但光从首领那里获取消息是不够的，它还必须是近乎零延迟的。</li></ul><p>如果跟随者副本不能满足以上任何一点，比如与Zookeeper断开连接，或者不再获取新消息，或者获取消息滞后了10s以上，那么它就被认为是不同步的。一个不同步的副本通过与Zookeeper重新建立连接，井从首领那里获取最新消息，可以重新变成同步的。这个过程在网络出现临时问题井很快得到修复的情况下会很快完成，但如果broker发生崩溃就需要较长的时间。</p><p>注意：如果一个或多个副本在同步和非同步状态之间快速切换，说明集群内部出现了问题，通常是Java不恰当的垃圾回收配置导致的。不恰当的垃圾回收配置会造成几秒钟的停顿，从而让broker与Zookeeper之间断开连接，最后变成不同步的，进而发生状态切换。</p><h3 id="Broker配置对可靠性的影响"><a href="#Broker配置对可靠性的影响" class="headerlink" title="Broker配置对可靠性的影响"></a>Broker配置对可靠性的影响</h3><h4 id="复制系数"><a href="#复制系数" class="headerlink" title="复制系数"></a>复制系数</h4><p>主题级别的配置参数是replication.factor，而在broker级别则可以通过default.replication.factor来配置自动创建的主题。Kafka的默认复制系数就是3，不过用户可以修改它。如果复制系数为N，那么在N-1个broker失效的情况下，仍然能够从主题读取数据或向主题写入数据。所以，更高的复制系数会带来更高的可用性、可靠性和更少的故障。另一方面，复制系数N需要至少N个broker，而且会有N个数据副本，也就是说它们会占用N倍的磁盘空间。我们一般会在可用性和存储硬件之间作出权衡。</p><p>一般主题需要的副本数跟主题的重要程度、以及可以付出多少成本有关来保证可靠性有关。</p><p>如果因broker重启导致的主题不可用是可接受的（这在集群里是很正常的行为），把复制系数设为1就可以了。在作出这个权衡的时候，要确保这样不会对你的组织和用户造成影响，因为你在节省了硬件成本的同时也降低了可用性。复制系数为2意味着可以容忍1个broker发生失效，看起来已经足够了。不过要记住，有时候1个broker发生失效会导致集群不稳定（通常是旧版的Kafka），迫使你重启另一个broker作为集群控制器。也就是说，如果将复制系数设为2，就有可能因为重启等问题导致集群不可用。基于以上几点原因，在要求可用性的场景里把复制系数设为3。在大多数情况下，这已经足够安全了，不过要求更可靠时，可以设为更高，比如5个副本，以防不测。</p><p>副本的分布也很重要。默认情况下，Kafka会确保分区的每个副本被放在不同的broker上。不过，有时候这样仍然不够安全。如果这些broker处于同一个机架上，一旦机架的交换机发生故障，分区就会不可用，这时候把复制系数设为多少都不管用。为了避免机架级别的故障，我们建议把broker分布在多个不同的机架上。</p><h4 id="不完全的首领选举"><a href="#不完全的首领选举" class="headerlink" title="不完全的首领选举"></a>不完全的首领选举</h4><p>unclean.leader.election只能在broker级别（实际上是在集群范围内）进行配置，它的默认值是true。</p><p>当分区首领不可用时，一个同步副本会被选为新首领。如果在选举过程中没有丢失数据，也就是说提交的数据同时存在于所有的同步副本上，那么这个选举就是“完全”的。<br>如果在首领不可用时其他副本都是不同步的，我们该怎么办呢?</p><p>这种情况会在以下两种场景里出现。</p><ul><li>分区有3个副本，其中的两个跟随者副本不可用（比如有两个broker发生崩溃）。这个时候，如果生产者继续往首领写入数据，所有消息都会得到确认井被提交（因为此时首领是唯一的同步副本）。现在我们假设首领也不可用了（又一个broker发生崩溃），这个时候，如果之前的一个跟随者重新启动，它就成为了分区的唯一不同步副本。</li><li>分区有3个副本，因为网络问题导致两个跟随者副本复制消息滞后，所以尽管它们还在复制消息，但已经不同步了。首领作为唯一的同步副本继续接收消息。这个时候，如果首领变为不可用，另外两个副本就再也无法变成同步的了。</li></ul><p>对于这两种场景，我们要作出一个两难的选择。</p><ul><li><p>如果不同步的副本不能被提升为新首领，那么分区在旧首领（最后一个同步副本）恢复之前是不可用的。有时候这种状态会持续数小时（比如更换内存芯片）。</p></li><li><p>如果不同步的副本可以被提升为新首领，那么在这个副本变为不同步之后写入旧首领的消息、会全部丢失，导致数据不一致。</p></li></ul><p>比如在副本0和副本1不可用时，偏移量100-200的消息被写入副本2（首领）。现在副本2变为不可用的，而副本0变为可用的。副本0只包含偏移量0<del>100的消息，不包含偏移量100</del>200的悄息。如果我们允许副本0成为新首领，生产者就可以继续写人数据，消费者可以继续读取数据。于是，新首领就有了偏移量100<del>200的新消息。这样，部分消费者会读取到偏移量100</del>200的旧消息，部分消费者会读取到偏移量100~200的新消息，还有部分消费者读取的是二者的混合。这样会导致非常不好的结果，比如生成不准确的报表。另外，副本2可能会重新变为可用，并成为新首领的跟随者。这个时候，它会把比当前首领旧的消息全部删除，而这些消息对于所有消费者来说都是不可用的。</p><p>简而言之，如果我们允许不同步的副本成为首领，那么就要承担丢失数据和出现数据不一致的风险。如果不允许它们成为首领，那么就要接受较低的可用性，因为我们必须等待原先的首领恢复到可用状态。</p><p>如果把unclean.leader.election设为true，就是允许不同步的副本成为首领（也就是“不完全的选举”），那么我们将面临丢失消息的风险。如果把这个参数设为false，就要等待原先的首领重新上线，从而降低了可用性。</p><p>我们经常看到一些对数据质量和数据一致性要求较高的系统会禁用这种不完全的首领选举（把这个参数设为false）。比如银行系统，大部分银行系统宁愿选择在几分钟甚至几个小时内不处理信用卡支付事务，也不会冒险处理错误的消息。不过在对可用性要求较高的系统里，比如实时点击流分析系统，一般会启用不完全的首领选举。</p><h4 id="最少同步副本"><a href="#最少同步副本" class="headerlink" title="最少同步副本"></a>最少同步副本</h4><p>在主题级别和broker级别上，这个参数都叫min.insync.replicas。</p><p>我们知道，尽管为一个主题配置了3个副本，还是会出现只有一个同步副本的情况（acks=0或1）。如果这个同步副本变为不可用，我们必须在可用性和一致性之间作出选择，这又是一个两难的选择。根据Kafka对可靠性保证的定义，消息只有在被写入到所有同步副本之后才被认为是已提交的。但如果这里的“所有副本”只包含一个同步副本，那么在这个副本变为不可用时，数据就会丢失。</p><p>如果要确保已提交的数据被写入不止一个副本，就需要把最少同步副本数量设置为大一点的值。对于一个包含3个副本的主题，如果min.insync.replicas被设为2，那么至少要存在两个同步副本才能向分区写入数据。如果3个副本都是同步的，或者其中一个副本变为不可用，都不会有什么问题。不过，如果有两个副本变为不可用，那么broker就会停止接受生产者的请求。尝试发送数据的生产者会收到NotEnoughReplicasException异常。消费者仍然可以继续读取已有的数据。实际上，如果使用这样的配置，那么当只剩下一个同步副本时，它就变成只读了，这是为了避免在发生不完全选举时数据的写入和读取出现非预期的行为。为了从只读状态中恢复，必须让两个不可用分区中的一个重新变为可用的（比如重启broker），并等待它变为同步的。</p><h2 id="可靠系统里的生产者"><a href="#可靠系统里的生产者" class="headerlink" title="可靠系统里的生产者"></a>可靠系统里的生产者</h2><p>即使我们尽可能把broker配置得很可靠，但如果没有对生产者进行可靠性方面的配置，整个系统仍然有可能出现突发性的数据丢失。</p><p>比如为broker配置了3个副本，井且禁用了不完全首领选举，这样应该可以保证万无一失。我们把生产者发送消息的acks设为1（只要首领接收到消息就可以认为消息写入成功）。生产者发送一个消息给首领，首领成功写入，但跟随者副本还没有接收到这个消息。首领向生产者发送了一个响应，告诉它“消息写入成功”，然后它崩溃了，而此时消息还没有被其他副本复制过去。另外两个副本此时仍然被认为是同步的（毕竟判断一个副本不同步需要一小段时间），而且其中的一个副本成了新的首领。因为消息还没有被写入这个副本，所以就丢失了，但发送消息的客户端却认为消息已成功写入。因为消费者看不到丢失的消息，所以此时的系统仍然是一致的（因为副本没有收到这个消息，所以消息不算已提交），但从生产者角度来看，它丢失了一个消息。</p><p>再比如为broker配置了3个副本，并且禁用了不完全首领选举。我们接受了之前的教训，把生产者的acks设为all。假设现在往Kafka发送消息，分区的首领刚好崩溃，新的首领正在选举当中，Kafka会向生产者返回“首领不可用”的响应。在这个时候，如果生产者没能正确处理这个错误，也没有重试发送消息直到发送成功，那么消息也有可能丢失。这算不上是broker的可靠性问题，因为broker并没有收到这个消息。这也不是一致性问题，因为消费者并没有读到这个消息。问题在于如果生产者没能正确处理这些错误。</p><h3 id="发送确认"><a href="#发送确认" class="headerlink" title="发送确认"></a>发送确认</h3><p>生产者可以选择以下3种不同的确认模式。</p><ul><li>acks=0意味着如果生产者能够通过网络把消息发送出去，那么就认为消息已成功写入Kafka。在这种情况下还是有可能发生错误，比如发送的对象无法被序列化或者网卡发生故障，但如果是分区离线或整个集群长时间不可用，那就不会收到任何错误。即使是在发生完全首领选举的情况下，这种模式仍然会丢失消息，因为在新首领选举过程中它并不知道首领已经不可用了。在acks=0模式下的运行速度是非常快的（这就是为什么很多基准测试都是基于这个模式），你可以得到惊人的吞吐量和带宽利用率，不过如果选择了这种模式，一定会丢失一些消息。</li><li>acks=1意味若首领在收到消息并把它写入到分区数据文件（不一定同步到磁盘上）时会返回确认或错误响应。在这个模式下，如果发生正常的首领选举，生产者会在选举时收到一个LeadeNotAvailableExcepti.on异常，如果生产者能恰当地处理这个错误，它会重试发送消息，最终消息会安全到达新的首领那里。不过在这个模式下仍然有可能丢失数据，比如消息已经成功写入首领，但在消息被复制到跟随者副本之前首领发生崩溃。</li><li>acks=all意味着首领在返回确认或错误响应之前，会等待所有同步副本都收到悄息。如果和min.insync.replicas参数结合起来，就可以决定在返回确认前至少有多少个副本能够收到消息。这是最保险的做法，生产者会一直重试直到消息被成功提交。不过这也是最慢的做法，生产者在继续发送其他消息之前需要等待所有副本都收到当前的消息。可以通过使用异步模式和更大的批次来加快速度，但这样做通常会降低吞吐量。</li></ul><h3 id="配置生产者的重试参数"><a href="#配置生产者的重试参数" class="headerlink" title="配置生产者的重试参数"></a>配置生产者的重试参数</h3><p>如果broker返回的错误可以通过重试来解决，那么生产者会自动处理这些错误。生产者向broker发送消息时，broker可以返回一个成功响应码或者一个错误响应码。错误响应码可以分为两种，一种是在重试之后可以解决的，还有一种是无法通过重试解决的。例如，如果broker返回的是LEADER_NOT_AVAILABLE错误，生产者可以尝试重新发送消息。也许在这个时候一个新的首领被选举出来了，那么这次发送就会成功。也就是说，LEADER_NOT_AVAILABLE是一个可重试错误。</p><p>另一方面，如果broker返回的是INVALID_CONFIG错误，即使通过重试也无能改变配置选项，所以这样的重试是没有意义的。这种错误是不可重试错误。</p><p>一般情况下，如果你的目标是不丢失任何消息，那么最好让生产者在遇到可重试错误时能够保持重试，因为像首领选举或网络连接这类问题都可以在几秒钟之内得到解决，如果让生产者保持重试，就不需要额外去处理这些问题了。</p><p>生产者配置多少重试次数要看在生产者放弃重试并抛出异常之后想做些什么。如果你想抓住异常并再多重试几次，那么就可以把重试次数设置得多一点，让生产者继续重试；如果你想直接丢弃消息，多次重试造成的延迟已经失去发送消息的意义；如果你想把消息保存到某个地方然后回过头来再继续处理，那就可以停止重试。</p><p>Kafka的跨数据中心复制工具（MirrorMaker）默认会进行无限制的重试。作为一个具有高可靠性的复制工具，它决不会丢失消息。</p><p>要注意，重试发送一个已经失败的消息会带来一些风险，如果两个消息都写入成功，会导致消息重复。例如，生产者因为网络问题没有收到broker的确认，但实际上消息已经写入成功，生产者会认为网络出现了临时故障，就重试发送该消息（因为它不知道消息已经写入成功）。在这种情况下，broker会收到两个相同的消息。重试和恰当的错误处理可以保证每个消息“至少被保存一次”，但无法保证每个消息“只被保存一次”。现实中的很多应用程序在消息里加入唯一标识符，用于检测重复消息，消费者在读取消息时可以对它们进行清理。还要一些应用程序可以做到消息的“幕等”，也就是说，即使出现了重复消息，也不会对处理结果的正确性造成负面影响。</p><h3 id="额外的错误处理"><a href="#额外的错误处理" class="headerlink" title="额外的错误处理"></a>额外的错误处理</h3><p>使用生产者内置的重试机制可以在不造成消息丢失的情况下轻松地处理大部分错误，不过对于开发人员来说，仍然需要处理其他类型的错误，包括:</p><ul><li><p>不可重试的 broker 错误，例如消息大小错误、认证错误等 . 在消息发送之前发生的错误，例如序列化错误；</p></li><li><p>在生产者达到重试次数上限时或者在消息占用的内存达到上限时发生的错误。</p></li></ul><p>错误处理器的代码逻辑与具体的应用程序及其目标有关。可以丢弃使用“不合理的消息”、把错误记录下来或者把这些消息保存在本地磁盘上等逻辑，具体使用哪一种逻辑要根据具体的架构来决定。如果错误处理只是为了重试发送消息，那么最好还是使用生产者内置的重试机制。</p><h2 id="可靠系统里的消费者"><a href="#可靠系统里的消费者" class="headerlink" title="可靠系统里的消费者"></a>可靠系统里的消费者</h2><p>可以看到，只有那些被提交到Kafka的数据，也就是那些已经被写入所有同步副本的数据，对消费者是可用的，这意味着消费者得到的消息已经具备了一致性。</p><p>消费者唯一要做的是跟踪哪些消息是已经读取过的，哪些是还没有读取过的。这是在读取消息时不丢失消息的关键。</p><p>在从分区读取数据时，消费者会获取一批消息，检查这批消息里最大的偏移量，然后从这个偏移量开始读取另外一批消息。这样可以保证消费者总能以正确的顺序获取新数据，不会错过任何消息。</p><p>如果一个消费者退出，另一个消费者需要知道从什么地方开始继续处理，它需要知道前一个消费者在退出前处理的最后一个偏移量是多少。所谓的“另一个”消费者，也可能就是它自己重启之后重新回来工作。这也就是为什么消费者要“提交”它们的偏移量。它们把当前读取的偏移量保存起来，在退出之后，同一个群组里的其他消费者就可以接手它们的工作。如果消费者提交了偏移量却未能处理完消息，那么就有可能造成消息丢失，这也是消费者丢失消息的主要原因。在这种情况下，如果其他消费者接手了工作，那些没有被处理完的消息就会被忽略，永远得不到处理。所以我们要重视偏移量提交的时间点和提交的方式。</p><h3 id="消费者的可靠性配置"><a href="#消费者的可靠性配置" class="headerlink" title="消费者的可靠性配置"></a>消费者的可靠性配置</h3><p>为了保证消费者行为的可靠性，需要注意以下4个非常重要的配置参数。</p><ul><li>group.id：如果两个消费者具有相同的group.id，并且订阅了同一个主题，那么每个消费者会分到这个主题下所有分区的中的一个，也就是说它们只能读到所有消息的一个子集。如果希望消费者可以看到主题的所有消息，那么需要为它们设置唯一的group.id。</li><li>auto.offset.reset：这个参数指定了在没有偏移量可提交时（比如消费者第1次启动时）或者请求的偏移量在broker上不存在时，消费者会做些什么。这个参数有两种配置。一种是earliest，如果选择了这种配置，消费者会从分区的开始位置读取数据，不管偏移量是否有效，这样会导致消费者读取大量的重复数据，但可以保证最少的数据丢失。一种是latest，如果选择了这种配置，消费者会从分区的末尾开始读取数据，这样可以减少重复处理消息，但很有可能会错过一些消息。</li><li>enable.auto.commit：这是一个非常重要的配置参数，你可以让消费者基于任务调度自动提交偏移量，也可以在代码里手动提交偏移量。自动提交的一个最大好处是，在实现消费者逻辑时可以少考虑一些问题。如果你在消费者轮询操作里处理所有的数据，那么自动提交可以保证只提交已经处理过的偏移量。自动提交的主要缺点是，无法控制重复处理消息（比如消费者在自动提交偏移量之前停止处理消息），而且如果把消息交给另外一个后台线程去处理，自动提交机制可能会在消息还没有处理完毕就提交偏移量。</li><li>auto.commit.interval.ms：与enable.auto.commit有直接的联系。如果选择了自动提交偏移量，可以通过该参数配置提交的频度，默认值是每5秒钟提交一次。一般来说，频繁提交会增加额外的开销，但也会降低重复处理消息的概率。</li></ul><h3 id="显式提交偏移量"><a href="#显式提交偏移量" class="headerlink" title="显式提交偏移量"></a>显式提交偏移量</h3><p>如果选择了自动提交偏移量，就不需要关心显式提交的问题。不过如果希望能够更多地控制偏移量提交的时间点，那么就要仔细想想该如何提交偏 移量了一一要么是为了减少重复处理消息，要么是因为把消息处理逻辑放在了轮询之外。</p><p>在开发具有可靠性的消费者应用程序时需要注意的事项。我们先从简单的开始，再逐步深入。</p><ol><li><p>总是在处理完事件后再提交偏移量</p><p>如果所有的处理都是在轮询里完成，而且消息处理总是幂等的，或者少量消息丢失无关紧要，那么可以使用自动提交，或者在轮询结束时进行手动提交。</p></li><li><p>提交频度是性能和重复消息数量之间的权衡</p><p>即使是在最简单的场景里，比如所有的处理都在轮询里完成，并且不需要在轮询之间维护状态，你仍然可以在一个循环里多次提交偏移量（甚至可以在每处理完一个事件之后），或者多个循环里只提交一次，这完全取决于你在性能和重复处理消息之间作出的权衡。</p></li><li><p>确认提交的偏移量</p><p>在轮询过程中提交偏移量有一个不好的地方，就是提交的偏移量有可能是读取到的最新偏移量，而不是处理过的最新偏移量。要记住，在处理完消息后再提交偏移量是非常关键的，否则会导致消费者错过消息。</p></li><li><p>再均衡</p><p>在设计应用程序时要注意处理消费者的再均衡问题。一般要在分区被撤销之前提交偏移量，井在分配到新分区时清理之前的状态。</p></li><li><p>消费者可能需要重试</p><p>有时候，在进行轮询之后，有些消息不会被完全处理，可能稍后再来处理。假设要把Kafka的数据写到数据库里，不过那个时候数据库不可用，于是你想稍后重试。要注意，你提交的是偏移量，而不是对消息的“确认”，这个与传统的发布和订阅消息系统不太一样。如果记录的#30处理失败，但记录的#31处理成功，那么你不应该提交#31，否则会导致的#31以内的偏移量都被提交，包括的#30在内。不过可以采用下面这种模式来解决这个问题。</p><p>在遇到可重试错误时，把错误写入一个独立的主题，然后继续。一个独立的消费者群组负责从该主题上读取错误消息，并进行重试，或者使用其中的一个消费者同时从该主题上读取错误消息并进行重试，不过在重试时需要暂停该主题。这种模式有点像其他消息系统里的死信队列。</p></li><li><p>消费者可能需要维护状态</p><p>有时候你希望在多个轮询之间维护状态，例如，你想计算消息的移动平均数，希望在首次轮询之后计算平均数，然后在后续的轮询中更新这个结果。如果进程重启，你不仅需要从上一个偏移量开始处理数据，还要恢复移动平均数。有一种办法是在提交偏移量的同时把最近计算的平均数写到一个“结果”主题上。消费者线程在重新启动之后，它就可以拿到最近的平均数并接着计算。不过这并不能完全地解决问题，因为Kafka并没有提供事务支持。消费者有可能在写入平均数之后来不及提交偏移量就崩溃了，或者反过来也一样。这是一个很复杂的问题，你不应该尝试自己去解决这个问题，建议尝试一下Kafka流计算，它为聚合、连接、时间窗和其他复杂的分析提供了高级的API。</p></li><li><p>长时间处理</p><p>有时候处理数据需要很长时间，你可能会从发生阻塞的外部系统获取信息，或者把数据写到外部系统，或者进行一个非常复杂的计算，但是我们要尽量保持轮询。在这种情况下，一种常见的做法是使用一个线程池来处理数据，因为使用多个线程可以进行并行处理，从而加快处理速度。在把数据移交给线程地去处理之后，你就可以暂停消费者，然后保持轮询，但不获取新数据，直到工作线程处理完成。在工作线程处理完成之后，可以让消费者继续获取新数据。</p></li><li><p>仅一次传递</p><p>有些应用程序不仅仅需要“至少一次”(意味着没有数据丢失)，还需要“仅一次”语义。Kafka 现在还不能完全支持仅一次语义，消费者还是有一些办法可以保证 Kafka 里的每个消息只被写到外部系统一次（但不会处理向 Kafka 写入数据时可能出现的重复数据）。</p><p>实现仅一次处理最简单且最常用的办能是把结果写到一个支持唯一键的系统里，比如键值存储引擎、关系型数据库、ElasticSearch 或其他数据存储引 擎。在这种情况下，要么消息本身包含一个唯一键（通常都是这样），要么使用主题、分区和偏移量的组合来创建唯一键，它们的组合可以唯一标识一条Kafka消息。如果你把消息和一个唯一键写入系统，然后碰巧又读到一个相同的消息，只要把原先的键值覆盖掉即可。数据存储引擎会覆盖已经存在的键值对，就像没有出现过重复数据一样。这个模式被叫作幂等性写入，它是一种很常见也很有用的模式。</p><p>如果写入消息的系统支持事务，那么就可以使用另一种方法。最简单的是使用关系型数据库。我们把消息和偏移量放在同一个事务里，这样它们就 能保持同步。在消费者启动时，它会获取最近处理过的消息偏移量，然后调用seek()方法也从该偏移量位置继续读取数据。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>消息中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>消息中间件</tag>
      
      <tag>Kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kafka的消费者</title>
    <link href="/blog/2020/05/14/Kafka%E7%9A%84%E6%B6%88%E8%B4%B9%E8%80%85/"/>
    <url>/blog/2020/05/14/Kafka%E7%9A%84%E6%B6%88%E8%B4%B9%E8%80%85/</url>
    
    <content type="html"><![CDATA[<h2 id="消费者的工作流程"><a href="#消费者的工作流程" class="headerlink" title="消费者的工作流程"></a>消费者的工作流程</h2><img src="/blog/2020/05/14/Kafka%E7%9A%84%E6%B6%88%E8%B4%B9%E8%80%85/pic3.png" srcset="/blog/img/loading.gif" class><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><p>消费者的含义，与一般消息中间件中消费者的概念相同。在高并发的情况下，生产者产生消息的速度是远大于消费者消费的速度，单个消费者很可能会 负担不起，此时有必要对消费者进行横向伸缩，于是我们可以使用多个消费者从同一个主题读取消息，对消息进行分流。</p><h3 id="消费者群组"><a href="#消费者群组" class="headerlink" title="消费者群组"></a>消费者群组</h3><p>Kafka里的消费者从属于消费者群组，一个群组里的消费者订阅的都是同一个主题，每个消费者接收主题一部分分区的消息。</p><img src="/blog/2020/05/14/Kafka%E7%9A%84%E6%B6%88%E8%B4%B9%E8%80%85/pic1.png" srcset="/blog/img/loading.gif" class><p>往消费者群组里增加消费者是进行横向伸缩能力的主要方式。所以我们有必要为主题设定合适规模的分区，在负载均衡的时候可以加入更多的消费者。但是要记住，如果群组里消费者数量超过了主题的分区数量，多出来的消费者是没有用处的。</p><img src="/blog/2020/05/14/Kafka%E7%9A%84%E6%B6%88%E8%B4%B9%E8%80%85/pic2.png" srcset="/blog/img/loading.gif" class><p>如果是多个应用程序，需要从同一个主题中读取数据，只要保证每个应用程序有自己的消费者群组就行了。</p><h2 id="消费者的消费方式"><a href="#消费者的消费方式" class="headerlink" title="消费者的消费方式"></a>消费者的消费方式</h2><p>kafka的消费者并不是线程安全的，所以在多线程的环境下，使用KafkaConsumer的实例时需要保证每个消费者线程拥有自己的KafkaConsumer实例。</p><p>创建消费者后，使用subscribe()方法订阅主题，这个方法接受一个主题列表为参数，也可以接受一个正则表达式为参数，正则表达式可以匹配多个主题。如果新创建了新主题，并且主题名字和正则表达式匹配，那么会立即触发一次再均衡，消费者就可以读取新添加的主题。比如，要订阅所有和test相关的主题，可以subscribe(“test.*”)。</p><p>然后使用poll()方法主动的从kafka中获取数据，为了不断的获取消息，需要在循环中不断的进行调用。poll()方法的参数为超时时间，控制poll()方法的阻塞时间，它会让消费者在指定的毫秒数内一直等待broker返回数据。poll()方法将会返回一个记录（消息）列表，每一条记录都包含了记录所属的主题信息，记录所在分区信息，记录在分区里的偏移量，以及记录的键值对。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GroupAConsumer1</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> KafkaConsumer&lt;String,String&gt; consumer = <span class="hljs-keyword">null</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">/*消费配置的实例*/</span>        Properties properties                = KafkaConst.consumerConfig(BusiConst.CONSUMER_GROUP_A,                StringDeserializer<span class="hljs-class">.<span class="hljs-keyword">class</span>,</span><span class="hljs-class">                <span class="hljs-title">StringDeserializer</span>.<span class="hljs-title">class</span>)</span>;        <span class="hljs-comment">/*消息消费者*/</span>        consumer = <span class="hljs-keyword">new</span> KafkaConsumer&lt;String, String&gt;(properties);        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//可以订阅多个主题</span>            consumer.subscribe(Collections.singletonList(BusiConst.CONSUMER_GROUP_TOPIC));            consumer.poll(<span class="hljs-number">0</span>);            <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;                <span class="hljs-comment">//kafka只能通过拉取获得消息</span>                ConsumerRecords&lt;String, String&gt; records                        = consumer.poll(<span class="hljs-number">500</span>);                <span class="hljs-keyword">for</span>(ConsumerRecord&lt;String, String&gt; record:records)&#123;                    System.out.println(String.format(                            <span class="hljs-string">"主题：%s，分区：%d，偏移量：%d，key：%s，value：%s"</span>,                            record.topic(),record.partition(),record.offset(),                            record.key(),record.value()));                    <span class="hljs-comment">//do our work</span>                &#125;            &#125;        &#125; <span class="hljs-keyword">finally</span> &#123;            consumer.close();        &#125;    &#125;&#125;</code></pre><h3 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h3><p>poll()方法不仅仅只是获取数据，在新消费者第一次调用时，它会负责查找群组，加入群组，接受分配的分区。如果发生了再均衡，整个过程也是在轮询期间进行的。</p><h2 id="消费者的配置"><a href="#消费者的配置" class="headerlink" title="消费者的配置"></a>消费者的配置</h2><p>消费者有很多属性可以设置，大部分都有合理的默认值，无需调整。有些参数可能对内存使用，性能和可靠性方面有较大影响，可以参考org.apache.kafka.clients.consumer包下ConsumerConfig类。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConfigKafkaConsumer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//TODO 消费者三个属性必须指定(broker地址清单、key和value的反序列化器)</span>        Properties properties = <span class="hljs-keyword">new</span> Properties();        properties.put(<span class="hljs-string">"bootstrap.servers"</span>,<span class="hljs-string">"127.0.0.1:9092"</span>);        properties.put(<span class="hljs-string">"key.deserializer"</span>, StringDeserializer<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        properties.put(<span class="hljs-string">"value.deserializer"</span>, StringDeserializer<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        <span class="hljs-comment">//TODO 群组并非完全必须</span>        properties.put(ConsumerConfig.GROUP_ID_CONFIG,<span class="hljs-string">"test1"</span>);        <span class="hljs-comment">//TODO 更多消费者配置（重要的）</span>        properties.put(<span class="hljs-string">"auto.offset.reset"</span>,<span class="hljs-string">"latest"</span>); <span class="hljs-comment">//消费者在读取一个没有偏移量的分区或者偏移量无效的情况下，如何处理</span>        properties.put(<span class="hljs-string">"enable.auto.commit"</span>,<span class="hljs-keyword">true</span>); <span class="hljs-comment">// 表明消费者是否自动提交偏移 默认值true</span>        properties.put(<span class="hljs-string">"max.poll.records"</span>,<span class="hljs-number">500</span>); <span class="hljs-comment">// 控制每次poll方法返回的的记录数量 默认值500</span>        <span class="hljs-comment">//分区分配给消费者的策略。系统提供两种策略。默认为Range</span>   properties.put(<span class="hljs-string">"partition.assignment.strategy"</span>,Collections.singletonList(RangeAssignor<span class="hljs-class">.<span class="hljs-keyword">class</span>))</span>;        KafkaConsumer&lt;String,String&gt; consumer = <span class="hljs-keyword">new</span> KafkaConsumer&lt;String, String&gt;(properties);        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//TODO 消费者订阅主题（可以多个）</span>            consumer.subscribe(Collections.singletonList(BusiConst.HELLO_TOPIC));            <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;                <span class="hljs-comment">//TODO 拉取（新版本）</span>                ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="hljs-number">500</span>));                <span class="hljs-keyword">for</span>(ConsumerRecord&lt;String, String&gt; record:records)&#123;                    System.out.println(String.format(<span class="hljs-string">"topic:%s,分区：%d,偏移量：%d,"</span> + <span class="hljs-string">"key:%s,value:%s"</span>,record.topic(),record.partition(),                            record.offset(),record.key(),record.value()));                    <span class="hljs-comment">//do my work</span>                    <span class="hljs-comment">//打包任务投入线程池</span>                    <span class="hljs-comment">// ex</span>                &#125;            &#125;        &#125; <span class="hljs-keyword">finally</span> &#123;            consumer.close();        &#125;    &#125;&#125;</code></pre><ul><li>auto.offset.reset：消费者在读取一个没有偏移量的分区或者偏移量无效的情况下，如何处理。默认值是latest，从最新的记录开始读取，另一个值是earliest，表示消费者从起始位置读取分区的记录。注意:如果是消费者在读取一个没有偏移量的分区或者偏移量无效的情况（因消费者长时间失效，包含的偏移量记录已经过时并被删除）下，默认值是latest的话，消费者将从最新的记录开始读取数据（在消费者启动之后生成的记录），所以一般先启动生产者，再启动消费者。</li><li>enable.auto.commit：默认值true，表明消费者是否自动提交偏移。为了尽量避免重复数据和数据丢失，可以改为false，自行控制何时提交。</li><li>partition.assignment.strategy：分区分配给消费者的策略。系统提供两种策略。默认为Range。可以通过继承AbstractPartitionAssigon来自定义策略。<ul><li>Range：把主题的连续分区分配给消费者。(如果分区数量无法被消费者整除、第一个消费者会分到更多分区)</li><li>RoundRobin：把主题的分区循环分配给消费者。</li></ul></li><li>max.poll.records：控制每次poll方法返回的的记录数量。</li><li>fetch.min.bytes：每次fetch请求时，server应该返回的最小字节数。如果没有足够的数据返回，请求会等待，直到足够的数据才会返回。缺省为1个字节。多消费者下，可以设大这个值，以降低broker的工作负载<br>fetch.wait.max.ms，如果没有足够的数据能够满足fetch.min.bytes，则此项配置是指在应答fetch请求之前，server会阻塞的最大时间。缺省为500个毫秒。和上面的fetch.min.bytes结合起来，要么满足数据的大小，要么满足时间，就看哪个条件先满足。</li><li>max.partition.fetch.bytes：指定了服务器从每个分区里返回给消费者的最大字节数，默认1MB。假设一个主题有20个分区和5个消费者，那么每个消费者至少要有4MB的可用内存来接收记录，而且一旦有消费者崩溃，这个内存还需更大。注意，这个参数要比服务器的message.max.bytes更大，否则消费者可能无法读取消息。</li><li>session.timeout.ms：如果consumer在这段时间内没有发送心跳信息，则它会被认为挂掉了。默认3秒。</li><li>client.id：当向server发出请求时，这个字符串会发送给server。目的是能够追踪请求源头，以此来允许ip/port许可列表之外的一些应用可以发送信息。这项应用可以设置任意字符串，因为没有任何功能性的目的，除了记录和跟踪。</li><li>receive.buffer.bytes和send.buffer.bytes：指定TCPsocket接受和发送数据包的缓存区大小。如果它们被设置为-1，则使用操作系统的默认值。如果生产者或消费者处在不同的数据中心，那么可以适当增大这些值，因为跨数据中心的网络一般都有比较高的延迟和比较低的带宽。</li></ul><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="多线程安全问题"><a href="#多线程安全问题" class="headerlink" title="多线程安全问题"></a>多线程安全问题</h3><p>KafkaConsumer的实现不是线程安全的，所以我们在多线程的环境下，使用KafkaConsumer的实例要小心，必须保证每个消费数据的线程拥有自己的KafkaConsumer实例。</p><h3 id="群组协调"><a href="#群组协调" class="headerlink" title="群组协调"></a>群组协调</h3><p>消费者要加入群组时，会向群组协调器发送一个JoinGroup请求，第一个加入群组的消费者成为群主，群主会获得群组的成员列表，并负责给每一个 消费者分配分区。分配完毕后，群组把分配情况发送给群组协调器，协调器再把这些信息发送给所有的消费者，每个消费者只能看到自己的分配信息， 只有群主知道群组里所有消费者的分配信息，这个过程在每次再均衡时都会发生。</p><h3 id="分区再均衡"><a href="#分区再均衡" class="headerlink" title="分区再均衡"></a>分区再均衡</h3><p>当消费者群组里的消费者发生变化，或者主题里的分区发生了变化，都会导致再均衡现象的发生。Kafka中存在着消费者对分区所有权的关系，这样无论是消费者变化，比如增加了消费者，新消费者会读取原本由其他消费者读取的分区，消费者减少，原本由它负责的分区要由其他消费者来读取，增加了分区，哪个消费者来读取这个新增的分区，这些行为，都会导致分区所有权的变化，这种变化就被称为再均衡。</p><img src="/blog/2020/05/14/Kafka%E7%9A%84%E6%B6%88%E8%B4%B9%E8%80%85/pic4.png" srcset="/blog/img/loading.gif" class><p>再均衡对Kafka很重要，这是消费者群组带来高可用性和伸缩性的关键所在。不过一般情况下，尽量减少再均衡，因为再均衡期间，消费者是无法读取消息的，会造成整个群组一小段时间的不可用（STW）。</p><p>消费者通过向称为群组协调器的broker（不同的群组有不同的协调器）发送心跳来维持它和群组的从属关系以及对分区的所有权关系。如果消费者长时间不发送心跳，群组协调器认为它已经死亡，就会触发一次再均衡。在0.10.1及以后的版本中，心跳由单独的线程负责，相关的控制参数为max.poll.interval.ms。</p><h3 id="提交和偏移量"><a href="#提交和偏移量" class="headerlink" title="提交和偏移量"></a>提交和偏移量</h3><p>当我们调用poll()方法的时候，broker返回的是生产者写入Kafka但是还没有被消费者读取过的记录，消费者可以使用Kafka来追踪消息在分区里的位置，我们称之为偏移量。消费者更新自己读取到哪个消息的操作，我们称之为提交。</p><p>消费者会往一个叫做_consumer_offset的特殊主题发送一个消息，里面会包括每个分区的偏移量。发生了再均衡之后，消费者可能会被分配新的分区，为了能够继续工作，消费者需要读取每个分区最后一次提交的偏移量，然后从指定的地方，继续做处理。这时可能会导致两个问题：</p><img src="/blog/2020/05/14/Kafka%E7%9A%84%E6%B6%88%E8%B4%B9%E8%80%85/pic5.png" srcset="/blog/img/loading.gif" class title=""><ul><li>如果提交的偏移量小于消费者实际处理的最后一个消息的偏移量，处于两个偏移量之间的消息会被重复处理。</li><li>如果提交的偏移量大于客户端处理的最后一个消息的偏移量，那么处于两个偏移量之间的消息将会丢失。</li></ul><h2 id="提交偏移量的方式"><a href="#提交偏移量的方式" class="headerlink" title="提交偏移量的方式"></a>提交偏移量的方式</h2><h3 id="自动提交"><a href="#自动提交" class="headerlink" title="自动提交"></a>自动提交</h3><p>自动提交是最简单的提交方式，也是默认提交方式。如果enable.auto.comnit被设为true，消费者会自动把从poll()方法接收到的最大偏移量提交上去。提交时间间隔由auto.commit.interval.ms控制，默认值是5s。自动提交是在轮询里进行的，消费者每次在进行轮询时会检査是否该提交偏移量了，如果是，那么就会提交从上一次轮询返回的偏移量。</p><p>假设我们仍然使用默认的5s提交时间间隔,在最近一次提交之后的3s发生了再均衡，再均衡之后，消费者从最后一次提交的偏移量位置开始读取消息。这个时候偏移量已经落后了3s，所以在这3s内到达的消息会被重复处理。可以通过修改提交时间间隔来更频繁地提交偏移量，减小可能出现重复消息的时间窗，不过这种情况是无法完全避免的。</p><p>在使用自动提交时，每次调用轮询方法都会把上一次调用返回的最大偏移量提交上去，它并不知道具体哪些消息已经被处理了，所以在再次调用之前最好确保所有当前调用返回的消息都已经处理完毕（enable.auto.comnit被设为true时，在调用close()方法之前也会进行自动提交）。一般情况下不会有什么问题，不过在处理异常或提前退出轮询时要格外小心。</p><p>自动提交虽然方便，但是很明显是一种基于时间提交的方式,不过并没有为我们留有余地来避免重复处理消息。</p><h3 id="手动提交（同步）"><a href="#手动提交（同步）" class="headerlink" title="手动提交（同步）"></a>手动提交（同步）</h3><p>我们通过控制偏移量提交时间来消除丢失消息的可能性，并在发生再均衡时减少重复消息的数量。消费者API提供了另一种提交偏移量的方式，开发者可以在必要的时候提交当前偏移量，而不是基于时间间隔。</p><p>auto.commit.offset设为false后，使用commitSync()提交偏移量最简单也最可靠。这个方法会提交由poll()方法返回的最新偏移量，提交成功后马上返回，如果提交失败就抛出异常。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommitSync</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Properties properties = KafkaConst.consumerConfig(<span class="hljs-string">"CommitSync"</span>,                StringDeserializer<span class="hljs-class">.<span class="hljs-keyword">class</span>,</span><span class="hljs-class">                <span class="hljs-title">StringDeserializer</span>.<span class="hljs-title">class</span>)</span>;        <span class="hljs-comment">//取消自动提交</span>        properties.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG,<span class="hljs-keyword">false</span>);        KafkaConsumer&lt;String,String&gt; consumer                = <span class="hljs-keyword">new</span> KafkaConsumer&lt;String, String&gt;(properties);        <span class="hljs-keyword">try</span> &#123;            consumer.subscribe(Collections.singletonList(                    BusiConst.CONSUMER_COMMIT_TOPIC));            <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;                ConsumerRecords&lt;String, String&gt; records                        = consumer.poll(<span class="hljs-number">500</span>);                <span class="hljs-keyword">for</span>(ConsumerRecord&lt;String, String&gt; record:records)&#123;                    System.out.println(String.format(                            <span class="hljs-string">"主题：%s，分区：%d，偏移量：%d，key：%s，value：%s"</span>,                            record.topic(),record.partition(),record.offset(),                            record.key(),record.value()));                &#125;                <span class="hljs-comment">//手动提交</span>                consumer.commitSync();            &#125;        &#125; <span class="hljs-keyword">finally</span> &#123;            consumer.close();        &#125;    &#125;&#125;</code></pre><p>注意：commitSync()将会提交由poll()返回的最新偏移量，所以在处理完所有记录后要确保调用了commitSync()，否则还是会有丢失消息的风险。如果发生了再均衡，从最近批消息到发生再均衡之间的所有消息都将被重复处理。</p><h3 id="异步提交"><a href="#异步提交" class="headerlink" title="异步提交"></a>异步提交</h3><p>手动提交时，在broker对提交请求作出回应之前，应用程序会一直阻塞。这时我们可以使用commitAsync()方法异步提交，我们只管发送提交请求，无需等待broker的响应。在成功提交或碰到无法恢复的错误之前，commitSync()会一直重试，但是commitAsync不会。它之所以不进行重试，是因为在它收到服务器响应的时候,<br>可能有一个更大的偏移量已经提交成功。</p><p>假设我们发出一个请求用于提交偏移量2000，这个时候发生了短暂的通信问题，服务器收不到请求，自然也不会作出任何响应。与此同时，我们处理了另外一批消息，并成功提交了偏移量3000。如果commitAsync()重新尝试提交偏移量2000，它有可能在偏移量3000之后提交成功。这个时候如果发生再均衡，就会出现重复消息。<br>commitAsync()也支持回调，在broker作出响应时会执行回调。回调经常被用于记录提交错误或生成度量指标。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommitAsync</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Properties properties = KafkaConst.consumerConfig(                <span class="hljs-string">"CommitAsync"</span>,                StringDeserializer<span class="hljs-class">.<span class="hljs-keyword">class</span>,</span><span class="hljs-class">                <span class="hljs-title">StringDeserializer</span>.<span class="hljs-title">class</span>)</span>;        <span class="hljs-comment">/*取消自动提交*/</span>        properties.put(<span class="hljs-string">"enable.auto.commit"</span>, <span class="hljs-keyword">false</span>);        KafkaConsumer&lt;String, String&gt; consumer                = <span class="hljs-keyword">new</span> KafkaConsumer&lt;String, String&gt;(properties);        <span class="hljs-keyword">try</span> &#123;            consumer.subscribe(Collections.singletonList(                    BusiConst.CONSUMER_COMMIT_TOPIC));            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;                ConsumerRecords&lt;String, String&gt; records                        = consumer.poll(<span class="hljs-number">500</span>);                <span class="hljs-keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;                    System.out.println(String.format(                            <span class="hljs-string">"主题：%s，分区：%d，偏移量：%d，key：%s，value：%s"</span>,                            record.topic(), record.partition(), record.offset(),                            record.key(), record.value()));                &#125;                <span class="hljs-comment">//异步提交回调方法</span>                consumer.commitAsync(<span class="hljs-keyword">new</span> OffsetCommitCallback() &#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onComplete</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">                            Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets,</span></span><span class="hljs-function"><span class="hljs-params">                            Exception exception)</span> </span>&#123;                        <span class="hljs-keyword">if</span>(exception!=<span class="hljs-keyword">null</span>)&#123;                            System.out.print(<span class="hljs-string">"Commmit failed for offsets "</span>);                            System.out.println(offsets);                            exception.printStackTrace();                        &#125;                    &#125;                &#125;);            &#125;        &#125; <span class="hljs-keyword">finally</span> &#123;            consumer.close();        &#125;    &#125;&#125;</code></pre><h3 id="同步和异步组合"><a href="#同步和异步组合" class="headerlink" title="同步和异步组合"></a>同步和异步组合</h3><p>因为同步提交一定会成功、异步可能会失败，所以一般的场景是同步和异步一起来做。一般情况下，针对偶尔出现的提交失败，不进行重试不会有太大问题，因为如果提交失败是因为临时问题导致的，那么后续的提交总会有成功的。但如果这是发生在关闭消费者或再均衡前的最后一次提交，就要确保能够提交成功。</p><p>因此，在消费者关闭前一般会组合使用commitAsync()和commitsync()。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SyncAndAsync</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">/*消息消费者*/</span>        Properties properties = KafkaConst.consumerConfig(<span class="hljs-string">"SyncAndAsync"</span>,                StringDeserializer<span class="hljs-class">.<span class="hljs-keyword">class</span>,</span><span class="hljs-class">                <span class="hljs-title">StringDeserializer</span>.<span class="hljs-title">class</span>)</span>;        <span class="hljs-comment">/*取消自动提交*/</span>        properties.put(<span class="hljs-string">"enable.auto.commit"</span>,<span class="hljs-keyword">false</span>);        KafkaConsumer&lt;String,String&gt; consumer                = <span class="hljs-keyword">new</span> KafkaConsumer&lt;String, String&gt;(properties);        <span class="hljs-keyword">try</span> &#123;            consumer.subscribe(Collections.singletonList(                    BusiConst.CONSUMER_COMMIT_TOPIC));            <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;                ConsumerRecords&lt;String, String&gt; records                        = consumer.poll(<span class="hljs-number">500</span>);                <span class="hljs-keyword">for</span>(ConsumerRecord&lt;String, String&gt; record:records)&#123;                    System.out.println(String.format(                            <span class="hljs-string">"主题：%s，分区：%d，偏移量：%d，key：%s，value：%s"</span>,                            record.topic(),record.partition(),record.offset(),                            record.key(),record.value()));                &#125;                <span class="hljs-comment">//异步提交</span>                consumer.commitAsync();            &#125;        &#125; <span class="hljs-keyword">catch</span> (CommitFailedException e) &#123;            System.out.println(<span class="hljs-string">"Commit failed:"</span>);            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">//同步提交</span>                consumer.commitSync();            &#125; <span class="hljs-keyword">finally</span> &#123;                consumer.close();            &#125;        &#125;    &#125;&#125;</code></pre><h3 id="特定提交"><a href="#特定提交" class="headerlink" title="特定提交"></a>特定提交</h3><p>在我们前面的提交中，提交偏移量的频率与处理消息批次的频率是一样的。但如果想要更频繁地提交，比如<br>poll()方法返回一大批数据，为了避免因再均衡引起的重复处理整批消息，想要在批次中间提交偏移量，这时无法通过调用commitSync()或commitAsync()来实现，因为它们只会提交最后一个偏移量，而此时该批次里的消息还没有处理完。</p><p>消费者API允许在调用commitSync()和commitAsync()方法时传进去希望提交的分区和偏移量的Map。假设我们处理了半个批次的消息，最后一个来自主题“customers”，分区3的消息的偏移量是5000，你可以调用commitSync()方法来提交它。不过，因为消费者可能不只读取一个分区，因为我们需要跟踪所有分区的偏移量，所以在这个层面上控制偏移量的提交会让代码变复杂。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommitSpecial</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">/*消息消费者*/</span>        Properties properties = KafkaConst.consumerConfig(                <span class="hljs-string">"CommitSpecial"</span>,                StringDeserializer<span class="hljs-class">.<span class="hljs-keyword">class</span>,</span><span class="hljs-class">                <span class="hljs-title">StringDeserializer</span>.<span class="hljs-title">class</span>)</span>;        <span class="hljs-comment">/*取消自动提交*/</span>        properties.put(<span class="hljs-string">"enable.auto.commit"</span>,<span class="hljs-keyword">false</span>);        KafkaConsumer&lt;String,String&gt; consumer                = <span class="hljs-keyword">new</span> KafkaConsumer&lt;String, String&gt;(properties);        <span class="hljs-comment">//创建特定提交所需要的Map</span>        Map&lt;TopicPartition, OffsetAndMetadata&gt; currOffsets                = <span class="hljs-keyword">new</span> HashMap&lt;TopicPartition, OffsetAndMetadata&gt;();        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">try</span> &#123;            consumer.subscribe(Collections.singletonList(                    BusiConst.CONSUMER_COMMIT_TOPIC));            <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;                ConsumerRecords&lt;String, String&gt; records                        = consumer.poll(<span class="hljs-number">500</span>);                <span class="hljs-keyword">for</span>(ConsumerRecord&lt;String, String&gt; record:records)&#123;                    System.out.println(String.format(                            <span class="hljs-string">"主题：%s，分区：%d，偏移量：%d，key：%s，value：%s"</span>,                            record.topic(),record.partition(),record.offset(),                            record.key(),record.value()));                    <span class="hljs-comment">//创建并放入对象</span>                    currOffsets.put(<span class="hljs-keyword">new</span> TopicPartition(record.topic(),record.partition()),                            <span class="hljs-keyword">new</span> OffsetAndMetadata(record.offset()+<span class="hljs-number">1</span>,<span class="hljs-string">"no meta"</span>));                    <span class="hljs-keyword">if</span>(count%<span class="hljs-number">11</span>==<span class="hljs-number">0</span>)&#123;                        <span class="hljs-comment">//提交</span>                        consumer.commitAsync(currOffsets,<span class="hljs-keyword">null</span>);                    &#125;                    count++;                &#125;            &#125;        &#125; <span class="hljs-keyword">finally</span> &#123;            consumer.close();        &#125;    &#125;&#125;</code></pre><h2 id="再均衡监听器"><a href="#再均衡监听器" class="headerlink" title="再均衡监听器"></a>再均衡监听器</h2><p>消费者在退出和进行分区再均衡之前会做一些清理工作比如提交偏移量、关闭文件句柄、数据库连接等。 在为消费者分配新分区或移除旧分区时，可以通过消费者API执行一些应用程序代码来实现一些功能，然后在调用subscribe()方法时传进去一个 ConsumerRebalancelistener实例就可以了。比如实现从特定偏移量处开始获取记录。</p><p>到目前为止，我们知道了如何使用poll()方法从各个分区的最新偏移量处开始处理消息。不过，有时候我们也需要从特定的偏移量处开始读取消息。如果想从分区的起始位置开始读取消息，或者直接跳到分区的末尾开始读取消息，可以使seekToBeginning(Collection&lt;TopicPartition&gt;tp)和seekToEnd(Collection&lt;TopicPartition&gt;tp)这两个方法。不过，Kaka也为我们提供了用于查找特定偏移量的API。它有很多用途，比如向后回退几个消息或者向前跳过几个消息（对时间比较敏感的应用程序在处理滞后的情况下希望能够向前跳过若干个消息）。在使用Kafka以外的系统来存储偏移量时，它将给我们带来更大的惊喜–让消息的业务处理和偏移量的提交变得一致。</p><p>试想一下这样的场景：应用程序从Kaka读取事件对它们进行处理后把结果保存到数据库。如果不想丢失任何数据，也不想在数据库里多次保存相同的结果。可以毎处理一条记录就提交一次偏移量。尽管如此，在记录被保存到数据库之后以及偏移量被提交之前，应用程序仍然有可能发生崩溃，导致重复处理数据，数据库里就会出现重复记录。</p><p>如果保存记录和偏移量可以在一个原子操作里完成，就可以避免出现上述情况。记录和偏移量要么都被成功提交,要么都不提交。如果记录是保存在数据库里而偏移量是提交到Kafka上，那么就无法实现原子操作不过，如果在同一个事务里把记录和偏移量都写到数据库里就可以保证操作的原子性。</p><p>在消费者启动或分配到新分区时，可以使用seck()方法查找保存在数据库里的偏移量。可以使用ConsumerRebalancelistener和seek()方法确保我们是从数据库里保存的偏移量所指定的位置开始处理消息的。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HandlerRebalance</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ConsumerRebalanceListener</span> </span>&#123;    <span class="hljs-comment">/*模拟一个保存分区偏移量的数据库表*/</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> ConcurrentHashMap&lt;TopicPartition, Long&gt;            PARTITION_OFFSET_MAP = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;TopicPartition, Long&gt;();    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;TopicPartition, OffsetAndMetadata&gt; currOffsets;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> KafkaConsumer&lt;String, String&gt; consumer;    <span class="hljs-comment">//private final Transaction  tr事务类的实例</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HandlerRebalance</span><span class="hljs-params">(Map&lt;TopicPartition, OffsetAndMetadata&gt; currOffsets,</span></span><span class="hljs-function"><span class="hljs-params">                            KafkaConsumer&lt;String, String&gt; consumer)</span> </span>&#123;        <span class="hljs-keyword">this</span>.currOffsets = currOffsets;        <span class="hljs-keyword">this</span>.consumer = consumer;    &#125;    <span class="hljs-comment">//分区再均衡之前</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onPartitionsRevoked</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">            Collection&lt;TopicPartition&gt; partitions)</span> </span>&#123;        <span class="hljs-keyword">final</span> String id = Thread.currentThread().getId() + <span class="hljs-string">""</span>;        System.out.println(id + <span class="hljs-string">"-onPartitionsRevoked参数值为："</span> + partitions);        System.out.println(id + <span class="hljs-string">"-服务器准备分区再均衡，提交偏移量。当前偏移量为："</span>                + currOffsets);        <span class="hljs-comment">//我们可以不使用consumer.commitSync(currOffsets);</span>        <span class="hljs-comment">//提交偏移量到kafka,由我们自己维护*/</span>        <span class="hljs-comment">//开始事务</span>        <span class="hljs-comment">//偏移量写入数据库</span>        System.out.println(<span class="hljs-string">"分区偏移量表中："</span> + PARTITION_OFFSET_MAP);        <span class="hljs-keyword">for</span> (TopicPartition topicPartition : partitions) &#123;            PARTITION_OFFSET_MAP.put(topicPartition,                    currOffsets.get(topicPartition).offset());        &#125;        consumer.commitSync(currOffsets);        <span class="hljs-comment">//提交业务数和偏移量入库  tr.commit</span>    &#125;    <span class="hljs-comment">//分区再均衡完成以后</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onPartitionsAssigned</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">            Collection&lt;TopicPartition&gt; partitions)</span> </span>&#123;        <span class="hljs-keyword">final</span> String id = Thread.currentThread().getId() + <span class="hljs-string">""</span>;        System.out.println(id + <span class="hljs-string">"-再均衡完成，onPartitionsAssigned参数值为："</span> + partitions);        System.out.println(<span class="hljs-string">"分区偏移量表中："</span> + PARTITION_OFFSET_MAP);        <span class="hljs-keyword">for</span> (TopicPartition topicPartition : partitions) &#123;            System.out.println(id + <span class="hljs-string">"-topicPartition"</span> + topicPartition);            <span class="hljs-comment">//模拟从数据库中取得上次的偏移量</span>            Long offset = PARTITION_OFFSET_MAP.get(topicPartition);            <span class="hljs-keyword">if</span> (offset == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">continue</span>;            consumer.seek(topicPartition, PARTITION_OFFSET_MAP.get(topicPartition));        &#125;    &#125;&#125;</code></pre><p>消费者中</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsumerWorker</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> KafkaConsumer&lt;String, String&gt; consumer;    <span class="hljs-comment">/*用来保存每个消费者当前读取分区的偏移量*/</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;TopicPartition, OffsetAndMetadata&gt; currOffsets;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> isStop;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConsumerWorker</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> isStop)</span> </span>&#123;        <span class="hljs-comment">/*消息消费者配置*/</span>        Properties properties = KafkaConst.consumerConfig(                RebalanceConsumer.GROUP_ID,                StringDeserializer<span class="hljs-class">.<span class="hljs-keyword">class</span>,</span><span class="hljs-class">                <span class="hljs-title">StringDeserializer</span>.<span class="hljs-title">class</span>)</span>;        <span class="hljs-comment">/*取消自动提交*/</span>        properties.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG                , <span class="hljs-keyword">false</span>);        <span class="hljs-keyword">this</span>.isStop = isStop;        <span class="hljs-keyword">this</span>.consumer                = <span class="hljs-keyword">new</span> KafkaConsumer&lt;String, String&gt;(properties);        <span class="hljs-keyword">this</span>.currOffsets                = <span class="hljs-keyword">new</span> HashMap&lt;TopicPartition, OffsetAndMetadata&gt;();        <span class="hljs-comment">//设置ConsumerRebalancelistener</span>        consumer.subscribe(Collections.singletonList(BusiConst.REBALANCE_TOPIC),                <span class="hljs-keyword">new</span> HandlerRebalance(currOffsets, consumer));    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">final</span> String id = Thread.currentThread().getId() + <span class="hljs-string">""</span>;        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        TopicPartition topicPartition = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">long</span> offset = <span class="hljs-number">0</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;                ConsumerRecords&lt;String, String&gt; records                        = consumer.poll(<span class="hljs-number">500</span>);                <span class="hljs-comment">//业务处理</span>                <span class="hljs-comment">//开始事务</span>                <span class="hljs-keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;                    System.out.println(id + <span class="hljs-string">"|"</span> + String.format(                            <span class="hljs-string">"处理主题：%s，分区：%d，偏移量：%d，"</span> +                                    <span class="hljs-string">"key：%s，value：%s"</span>,                            record.topic(), record.partition(),                            record.offset(), record.key(), record.value()));                    topicPartition = <span class="hljs-keyword">new</span> TopicPartition(record.topic(),                            record.partition());                    offset = record.offset() + <span class="hljs-number">1</span>;                    currOffsets.put(topicPartition, <span class="hljs-keyword">new</span> OffsetAndMetadata(offset,                            <span class="hljs-string">"no"</span>));                    count++;                    <span class="hljs-comment">//执行业务sql</span>                &#125;                <span class="hljs-keyword">if</span> (currOffsets.size() &gt; <span class="hljs-number">0</span>) &#123;                    <span class="hljs-comment">//提交事务,同时将业务和偏移量放入HandlerRebalance</span>                    <span class="hljs-keyword">for</span> (TopicPartition topicPartitionkey : currOffsets.keySet()) &#123;                        HandlerRebalance.PARTITION_OFFSET_MAP.put(topicPartitionkey,                                currOffsets.get(topicPartitionkey).offset());                    &#125;                &#125;                <span class="hljs-keyword">if</span> (isStop &amp;&amp; count &gt;= <span class="hljs-number">5</span>) &#123;                    System.out.println(id + <span class="hljs-string">"-将关闭，当前偏移量为："</span> + currOffsets);                    consumer.commitSync();                    <span class="hljs-keyword">break</span>;                &#125;                consumer.commitSync();            &#125;        &#125; <span class="hljs-keyword">finally</span> &#123;            consumer.close();        &#125;    &#125;&#125;</code></pre><h2 id="优雅的退出"><a href="#优雅的退出" class="headerlink" title="优雅的退出"></a>优雅的退出</h2><p>如果确定要退出循环，可以通过另一个线程调用consumer.wakeup()方法。如果循环运行在主线程里，可以在ShutdownHook里调用该方法。要记住，consumer.wakeup()是消费者唯一一个可以从其他线程里安全调用的方法。调用consumer.wakeup()可以退出poll()，并抛出WakeupException异常。我们不需要处理WakeupException，因为它只是用于跳出循环的一种方式。不过，在退出consumer之前仍需要调用consumer.close()方法，它会提交任何还没有提交的东西，并向群组协调器发送消息，告知自己要离开群组，接下来就会触发再均衡，而不需要等待会话超时。</p><h2 id="独立消费者"><a href="#独立消费者" class="headerlink" title="独立消费者"></a>独立消费者</h2><p>到目前为止，我们讨论了消费者群组，分区被自动分配给群组里的消费者，在群组里新增或移除消费者时自动触发再均衡。不过有时候可能只需要一个消费者从一个主题的所有分区或者某个特定的分区读取数据。这个时候就不需要消费者群组和再均衡了，只需要把主题或者分区分配给消费者，然后开始读取消息并提交偏移量。</p><p>如果是这样的话，就不需要订阅主题，取而代之的是为自己分配分区。一个独立消费者可以订阅主题，并加入消费者群组，或者为自己分配分区，但不能同时做这两件事情。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndependConsumer</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> KafkaConsumer&lt;String,String&gt; consumer = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String SINGLE_CONSUMER_TOPIC = <span class="hljs-string">"single-consumer"</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Properties properties = <span class="hljs-keyword">new</span> Properties();        properties.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG,                KafkaConst.LOCAL_BROKER);        properties.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG,                StringDeserializer<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getName</span>())</span>;        properties.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG,                StringDeserializer<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getName</span>())</span>;        <span class="hljs-comment">/*独立消息消费者*/</span>        consumer= <span class="hljs-keyword">new</span> KafkaConsumer&lt;String, String&gt;(properties);        List&lt;TopicPartition&gt; topicPartitionList = <span class="hljs-keyword">new</span> ArrayList&lt;TopicPartition&gt;();        <span class="hljs-comment">//独立消费者不需要订阅主题，只需要分配主题中的分区即可</span>        List&lt;PartitionInfo&gt; partitionInfos                = consumer.partitionsFor(SINGLE_CONSUMER_TOPIC);        <span class="hljs-comment">//构造分区list（这里全部消费）</span>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span>!=partitionInfos)&#123;            <span class="hljs-keyword">for</span>(PartitionInfo partitionInfo:partitionInfos)&#123;                topicPartitionList.add(<span class="hljs-keyword">new</span> TopicPartition(partitionInfo.topic(),                        partitionInfo.partition()));            &#125;        &#125;        <span class="hljs-comment">//订阅分区消息</span>        consumer.assign(topicPartitionList);        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;                ConsumerRecords&lt;String, String&gt; records                        = consumer.poll(<span class="hljs-number">1000</span>);                <span class="hljs-keyword">for</span>(ConsumerRecord&lt;String, String&gt; record:records)&#123;                    System.out.println(String.format(                            <span class="hljs-string">"主题：%s，分区：%d，偏移量：%d，key：%s，value：%s"</span>,                            record.topic(),record.partition(),record.offset(),                            record.key(),record.value()));                    <span class="hljs-comment">//do our work</span>                &#125;            &#125;        &#125; <span class="hljs-keyword">finally</span> &#123;            consumer.close();        &#125;    &#125;&#125;</code></pre><p>注意：独立消费者相当于自己来分配分区，但是这样做的好处是自己控制，但是就没有动态的支持了，包括加入消费者(分区再均衡之类的)，新增分区， 这些都需要代码中去解决，所以一般情况下不推荐使用。</p>]]></content>
    
    
    <categories>
      
      <category>消息中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>消息中间件</tag>
      
      <tag>Kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kafka的生产者</title>
    <link href="/blog/2020/05/13/Kafka%E7%9A%84%E7%94%9F%E4%BA%A7%E8%80%85/"/>
    <url>/blog/2020/05/13/Kafka%E7%9A%84%E7%94%9F%E4%BA%A7%E8%80%85/</url>
    
    <content type="html"><![CDATA[<h2 id="Kafka整体的工作流程"><a href="#Kafka整体的工作流程" class="headerlink" title="Kafka整体的工作流程"></a>Kafka整体的工作流程</h2><img src="/blog/2020/05/13/Kafka%E7%9A%84%E7%94%9F%E4%BA%A7%E8%80%85/pic4.png" srcset="/blog/img/loading.gif" class><h2 id="生产者的工作流程"><a href="#生产者的工作流程" class="headerlink" title="生产者的工作流程"></a>生产者的工作流程</h2><img src="/blog/2020/05/13/Kafka%E7%9A%84%E7%94%9F%E4%BA%A7%E8%80%85/pic1.png" srcset="/blog/img/loading.gif" class><p>首先需要创建一个ProducerRecord对象，ProducerRecord对象包含目标主题和要发送的内容，还可以指定键或分区。在发送ProducerRecord对象时，生产者要先把键和值对象通过序列化器转换为字节数组，然后发送到分区器。</p><p>如果在ProducerRecord对象里指定了分区，分区器会直接返回指定的分区。如果没有指定分区，分区器会根据ProducerRecord对象的键来选择一个分区。选择好分区后，这条记录被添加到一个记录批次中（双端队列，尾部写入），这个批次的所有消息会被发送到相同的主题和分区上。有一个独立的线程负责把这些记录批次发送到相应的broker上。</p><p>注意：序列化器和分区器不属于Kafka服务，是依赖包中提供的功能。</p><p>服务器在收到这些消息时会返回一个响应。如果消息成功写入Kafka，就返回一个RecordMetaData对象，它包含了主题和分区信息，以及记录在分区里的偏移量。如果写入失败，则会返回一个错误。生产者在收到错误之后会尝试重新发送消息，几次之后如果还是失败，就返回错误信息。</p><p>生产者发送消息一般会发生两类错误:一类是可重试错误，比如连接错误（可通过再次建立连接解决）、noleader（无主，可通过分区重新选举首领解决）。另一类是无法通过重试解决，比如消息大小超过了message.max.bytes的限制，这类消息不会进行任何重试直接抛出异常。</p><h2 id="生产者的发送方式"><a href="#生产者的发送方式" class="headerlink" title="生产者的发送方式"></a>生产者的发送方式</h2><p>kafka的生产者是线程安全的，不需要额外的机制来保证线程安全，使用之前需要在pom中引入依赖</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.kafka<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>kafka-clients<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>发送并忘记</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloKafkaProducer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//生产者三个属性必须指定(broker地址清单、key和value的序列化器)</span>        Properties properties = <span class="hljs-keyword">new</span> Properties();        properties.put(<span class="hljs-string">"bootstrap.servers"</span>, <span class="hljs-string">"127.0.0.1:9092"</span>);        properties.put(<span class="hljs-string">"key.serializer"</span>, <span class="hljs-string">"org.apache.kafka.common.serialization.StringSerializer"</span>);        properties.put(<span class="hljs-string">"value.serializer"</span>, <span class="hljs-string">"org.apache.kafka.common.serialization.StringSerializer"</span>);        KafkaProducer&lt;String, String&gt; producer = <span class="hljs-keyword">new</span> KafkaProducer&lt;String, String&gt;(properties);        <span class="hljs-keyword">try</span> &#123;            ProducerRecord&lt;String, String&gt; record;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">//发送4条消息</span>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;                    record = <span class="hljs-keyword">new</span> ProducerRecord&lt;String, String&gt;(BusiConst.HELLO_TOPIC, String.valueOf(<span class="hljs-number">180</span>), <span class="hljs-string">"lison"</span>);                    <span class="hljs-comment">//发送并发忘记，会有同步机制</span>                    producer.send(record);                    System.out.println(i + <span class="hljs-string">"，message is sent"</span>);                &#125;            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125; <span class="hljs-keyword">finally</span> &#123;            producer.close();        &#125;    &#125;&#125;</code></pre><p>同步发送</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KafkaFutureProducer</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> KafkaProducer&lt;String,String&gt; producer = <span class="hljs-keyword">null</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//消息生产者</span>        producer = <span class="hljs-keyword">new</span> KafkaProducer&lt;String, String&gt;(KafkaConst.producerConfig(StringSerializer<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">StringSerializer</span>.<span class="hljs-title">class</span>))</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//待发送的消息实例</span>            ProducerRecord&lt;String,String&gt; record;            <span class="hljs-keyword">try</span> &#123;                record =  <span class="hljs-keyword">new</span> ProducerRecord&lt;String,String&gt;(                        BusiConst.HELLO_TOPIC,<span class="hljs-string">"teacher10"</span>,<span class="hljs-string">"james"</span>);                Future&lt;RecordMetadata&gt; future = producer.send(record);                System.out.println(<span class="hljs-string">"do other sth"</span>);                <span class="hljs-comment">//阻塞在这个位置</span>                RecordMetadata recordMetadata = future.get();                <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span>!=recordMetadata)&#123;                    System.out.println(<span class="hljs-string">"offset:"</span>+recordMetadata.offset()+<span class="hljs-string">"-"</span> +<span class="hljs-string">"partition:"</span>+recordMetadata.partition());                &#125;            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125; <span class="hljs-keyword">finally</span> &#123;            producer.close();        &#125;    &#125;&#125;</code></pre><p>异步发送</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KafkaAsynProducer</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> KafkaProducer&lt;String, String&gt; producer = <span class="hljs-keyword">null</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">/*消息生产者*/</span>        producer = <span class="hljs-keyword">new</span> KafkaProducer&lt;String, String&gt;(                KafkaConst.producerConfig(StringSerializer<span class="hljs-class">.<span class="hljs-keyword">class</span>,</span><span class="hljs-class">                        <span class="hljs-title">StringSerializer</span>.<span class="hljs-title">class</span>))</span>;        <span class="hljs-comment">/*待发送的消息实例*/</span>        ProducerRecord&lt;String, String&gt; record;        <span class="hljs-keyword">try</span> &#123;            record = <span class="hljs-keyword">new</span> ProducerRecord&lt;String, String&gt;(                    BusiConst.HELLO_TOPIC, <span class="hljs-string">"teacher14"</span>, <span class="hljs-string">"deer"</span>);            producer.send(record, <span class="hljs-keyword">new</span> Callback() &#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCompletion</span><span class="hljs-params">(RecordMetadata metadata,</span></span><span class="hljs-function"><span class="hljs-params">                                         Exception exception)</span> </span>&#123;                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != exception) &#123;                        exception.printStackTrace();                    &#125;                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != metadata) &#123;                        System.out.println(<span class="hljs-string">"offset:"</span> + metadata.offset() + <span class="hljs-string">"-"</span>                                + <span class="hljs-string">"partition:"</span> + metadata.partition());                    &#125;                &#125;            &#125;);        &#125; <span class="hljs-keyword">finally</span> &#123;            producer.close();        &#125;    &#125;&#125;</code></pre><h2 id="生产者的配置"><a href="#生产者的配置" class="headerlink" title="生产者的配置"></a>生产者的配置</h2><p>生产者有很多属性可以设置，大部分都有合理的默认值，无需调整。有些参数可能对内存使用，性能和可靠性方面有较大影响，可以参考org.apache.kafka.clients.producer包下ProducerConfig类。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConfigKafkaProducer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//TODO 生产者三个属性必须指定(broker地址清单、key和value的序列化器)</span>        Properties properties = <span class="hljs-keyword">new</span> Properties();        properties.put(<span class="hljs-string">"bootstrap.servers"</span>,<span class="hljs-string">"127.0.0.1:9092"</span>);        properties.put(<span class="hljs-string">"key.serializer"</span>, <span class="hljs-string">"org.apache.kafka.common.serialization.StringSerializer"</span>);        properties.put(<span class="hljs-string">"value.serializer"</span>, <span class="hljs-string">"org.apache.kafka.common.serialization.StringSerializer"</span>);        <span class="hljs-comment">//TODO 更多发送配置（重要的）</span>        properties.put(<span class="hljs-string">"acks"</span>,<span class="hljs-string">"1"</span>); <span class="hljs-comment">//ack 0,1,all</span>        properties.put(<span class="hljs-string">"batch.size"</span>,<span class="hljs-number">16384</span>); <span class="hljs-comment">// 一个批次可以使用的内存大小 缺省16384(16k)</span>        properties.put(<span class="hljs-string">"linger.ms"</span>,<span class="hljs-number">0L</span>); <span class="hljs-comment">// 指定了生产者在发送批次前等待更多消息加入批次的时间,  缺省0  50ms</span>        properties.put(<span class="hljs-string">"max.request.size"</span>,<span class="hljs-number">1</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>); <span class="hljs-comment">// 控制生产者发送请求最大大小,默认1M （这个参数和Kafka主机的message.max.bytes 参数有关系）</span>        <span class="hljs-comment">//TODO 更多发送配置（非重要的）</span>        properties.put(<span class="hljs-string">"buffer.memory"</span>,<span class="hljs-number">32</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024L</span>);<span class="hljs-comment">//生产者内存缓冲区大小</span>        properties.put(<span class="hljs-string">"retries"</span>,<span class="hljs-number">0</span>); <span class="hljs-comment">//重发消息次数</span>        properties.put(<span class="hljs-string">"request.timeout.ms"</span>,<span class="hljs-number">30</span> * <span class="hljs-number">1000</span>);<span class="hljs-comment">//客户端将等待请求的响应的最大时间 默认30秒</span>        properties.put(<span class="hljs-string">"max.block.ms"</span>,<span class="hljs-number">60</span>*<span class="hljs-number">1000</span>);<span class="hljs-comment">//最大阻塞时间，超过则抛出异常 缺省60000ms</span>        properties.put(<span class="hljs-string">"compression.type"</span>,<span class="hljs-string">"none"</span>); <span class="hljs-comment">// 于压缩数据的压缩类型。默认是无压缩 ,none、gzip、snappy</span>        KafkaProducer&lt;String,String&gt; producer = <span class="hljs-keyword">new</span> KafkaProducer&lt;String, String&gt;(properties);        <span class="hljs-keyword">try</span> &#123;            ProducerRecord&lt;String,String&gt; record;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">//TODO发送4条消息</span>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;                    record = <span class="hljs-keyword">new</span> ProducerRecord&lt;String,String&gt;(BusiConst.HELLO_TOPIC, String.valueOf(i),<span class="hljs-string">"lison"</span>);                    producer.send(record);                    System.out.println(i+<span class="hljs-string">"，message is sent"</span>);                &#125;            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125; <span class="hljs-keyword">finally</span> &#123;            producer.close();        &#125;    &#125;&#125;</code></pre><ul><li><p>ack：指定了必须要有多少个分区副本收到消息，生产者才会认为写入消息是成功的，这个参数对消息丢失的可能性有重大影响。</p><ul><li>acks=0：生产者在写入消息之前不会等待任何来自服务器的响应，容易丢消息，但是吞吐量高。</li><li>acks=1：默认配置，只要集群的首领节点收到消息，生产者会收到来自服务器的成功响应。如果消息无法到达首领节点（比如首领节点崩溃，新首领没有选举出来），生产者会收到一个错误响应，为了避免数据丢失，生产者会重发消息。不过，如果一个没有收到消息的节点成为新首领，消息还是会丢失。</li><li>acks=all：只有当所有参与复制的节点都收到消息，生产者才会收到一个来自服务器的成功响应。延迟高。很多高可用场景一般不是设置2个副本，比如金融业务经常会使用主备外加异地灾备，有可能达到5个副本，不同机架上部署不同的副本，异地上也部署一套副本。</li></ul></li><li><p>batch.size：当多个消息被发送同一个分区时，生产者会把它们放在同一个批次里。该参数指定了一个批次可以使用的内存大小，按照字节数计算，缺省16384(16k)。如果一条消息超过了批次的大小，会写不进去。当批次内存被填满后，批次里的所有消息会被发送出去。但是生产者不一定都会等到批次被填满才发送，半满甚至只包含一个消息的批次也有可能被发送。</p></li><li><p>linger.ms：指定了生产者在发送批次前等待更多消息加入批次的时间。它和batch.size以先到者为先。也就是说，一旦我们获得消息的数量够batch.size的数量了，他将会立即发送而不顾这项设置，然而如果我们获得消息字节数比batch.size设置要小的多，就需要等待特定的时间以获取更多的消息。默认为0，即没有延迟。如果设定linger.ms=5会增加5ms的延迟，将会减少Kafka的请求数目，提升消息的吞吐量。</p></li><li><p>max.request.size：控制生产者发送请求最大大小。默认值为1M，如果一个请求里只有一个消息，那这个消息不能大于1M，如果一次请求是一个批次，该批次包含了1000条消息，那么每个消息不能大于1KB。注意：这个参数和broker中的message.max.bytes参数有关系。如果生产者发送的消息超过message.max.bytes设置的大小，就会被Kafka服务器拒绝。</p></li><li><p>buffer.memory：设置生产者内存缓冲区的大小(结合生产者发送消息的基本流程)，生产者用它缓冲要发送到服务器的消息。如果数据产生速度大于向broker发送的速度，导致生产者空间不足，producer会阻塞或者抛出异常。缺省33554432（32M）</p></li><li><p>max.block.ms：指定了在调用send()方法或者使用partitionsFor()方法获取元数据时生产者的阻塞时间。当生产者的发送缓冲区已满，或者没有可用的元数据时，这些方法就会阻塞。在阻塞时间达到max.block.ms时，生产者会抛出超时异常。缺省60000ms</p></li><li><p>retries：发送失败时，指定生产者可以重发消息的次数（缺省Integer.MAX_VALUE）。默认情况下，生产者在每次重试之间等待100ms，可以通过参数retry.backoff.ms参数来改变这个时间间隔。</p></li><li><p>receive.buffer.bytes和send.buffer.bytes：指定TCPsocket接受和发送数据包的缓存区大小。如果它们被设置为-1，则使用操作系统的默认值。如果生产者或消费者处在不同的数据中心，那么可以适当增大这些值，因为跨数据中心的网络一般都有比较高的延迟和比较低的带宽。缺省102400</p></li><li><p>compression.type：producer用于压缩数据的压缩类型。默认是无压缩。正确的选项值是none、gzip、snappy。压缩最好用于批量处理，批量处理消息越多，压缩性能越好。snappy占用cpu少，提供较好的性能和可观的压缩比，如果比较关注性能和网络带宽，用这个。如果带宽紧张，用gzip，会占用较多的cpu，但提供更高的压缩比。</p></li><li><p>client.id：当向server发出请求时，这个字符串会发送给server。目的是能够追踪请求源头，以此来允许ip/port许可列表之外的一些应用可以发送信息。这项应用可以设置任意字符串，因为没有任何功能性的目的，除了记录和跟踪。</p></li><li><p>max.in.flight.requests.per.connection：指定了生产者在接收到服务器响应之前可以发送多批消息，值越高，占用的内存越大，当然也可以提升吞吐量。发生错误时，可能会造成数据的发送顺序改变，默认是5。如果需要保证消息在一个分区上的严格顺序，这个值应该设为1，不过这样会严重影响生产者的吞吐量。</p></li><li><p>request.timeout.ms：客户端将等待请求的响应的最大时间,如果在这个时间内没有收到响应，客户端将重发请求;超过重试次数将抛异常，默认30秒。</p></li><li><p>metadata.fetch.timeout.ms：是指我们所获取的一些元数据的第一个时间数据。元数据包含:topic，host，partitions。此项配置是指当等待元数据fetch成功完成所需要的时间，否则会跑出异常给客户端</p></li></ul><p>一般来说，就记住acks、batch.size、linger.ms、max.request.size就行了，因为这4个参数重要些，其他参数一般没有太大必要调整。</p><h2 id="消息的顺序保证"><a href="#消息的顺序保证" class="headerlink" title="消息的顺序保证"></a>消息的顺序保证</h2><p>Kafka可以保证同一个分区里的消息是有序的。也就是说，发送消息时，主题只有且只有一个分区，同时生产者按照一定的顺序发送消息，broker就会按照这个顺序把它们写入分区，消费者也会按照同样的顺序读取它们。在某些情况下，顺序是非常重要的。例如，往一个账户存入100元再取出来，这个与先取钱再存钱是截然不同的，不过，有些场景对顺序不是很敏感。</p><img src="/blog/2020/05/13/Kafka%E7%9A%84%E7%94%9F%E4%BA%A7%E8%80%85/pic2.png" srcset="/blog/img/loading.gif" class><p>如果把retires设为非零整数，同时把max.in.flight.requests.per.connection设为比1大的数，那么，如果第一个批次消息写入失败，而第二个批次写入成功，broker会重试写入第一个批次。如果此时第一个批次也写入成功，那么两个批次的顺序就反过来了。</p><p>一般来说，如果某些场景要求消息是有序的，那么消息是否写入成功也是很关键的，所以不建议把retires设为0，因为不重试的话消息可能会因为连接关闭等原因导致丢失。可以将max.in.flight.request.per.connection设为1，这样在生产者尝试发送第一批消息时，就不会有其他的消息发送给broker。不过这样会严重影响生产者的吞吐量，所以只有在对消息的顺序有严格要求的情况下才能这么做。</p><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>Kafka官方推荐的序列化器为Apache Avro。Avro会使用一个JSON文件作为schema来描述数据，Avro在读写时会用到这个schema，可以把这个schema内嵌在数据文件中。这样，不管数据格式如何变动，消费者都知道如何处理数据。但是内嵌的消息，自带格式，会导致消息的大小不必要的增大，消耗了资源。我们可以使用schema注册表机制，将所有写入的数据用到的schema保存在注册表中，然后在消息中引用schema的标识符，而读取的数据的消费者程序使用这个标识符从注册表中拉取schema来反序列化记录。注意：Kafka本身并不提供schema注册表，需要借助第三方，现在已经有很多的开源实现，比如ConfluentSchemaRegistry，可以从GitHub上获取。如何使用参考如下网址：<a href="https://cloud.tencent.com/developer/article/1336568" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1336568</a></p><img src="/blog/2020/05/13/Kafka%E7%9A%84%E7%94%9F%E4%BA%A7%E8%80%85/pic3.png" srcset="/blog/img/loading.gif" class><p>不过一般除非使用Kafka需要关联的团队比较大，敏捷开发团队才会使用，一般的团队用不上。对于一般的情况使用JSON足够了。</p><h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><p>在ProducerRecord对象中包含了目标主题，键和值，Kafka的消息都是一个个的键值对。键可以设置为默认的null。键主要用来决定消息被写往主题的哪个分区，或者作为消息的附加消息。如果键值为null，并且使用默认的分区器，分区器使用轮询算法将消息均衡地分布到各个分区上。如果键不为空，并且使用默认的分区器，Kafka对键进行散列（Kafka自定义的散列算法，具体算法原理不知），然后根据散列值把消息映射到特定的分区上。很明显，同一个键总是被映射到同一个分区。但是只有不改变主题分区数量的情况下，键和分区之间的映射才能保持不变，一旦增加了新的分区，就无法保证了，所以如果要使用键来映射分区，那就要在创建主题的时候把分区规划好，而且永远不要增加新分区。</p>]]></content>
    
    
    <categories>
      
      <category>消息中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>消息中间件</tag>
      
      <tag>Kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kafka的安装、管理和配置</title>
    <link href="/blog/2020/05/12/Kafka%E7%9A%84%E5%AE%89%E8%A3%85%E3%80%81%E7%AE%A1%E7%90%86%E5%92%8C%E9%85%8D%E7%BD%AE/"/>
    <url>/blog/2020/05/12/Kafka%E7%9A%84%E5%AE%89%E8%A3%85%E3%80%81%E7%AE%A1%E7%90%86%E5%92%8C%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="预备环境"><a href="#预备环境" class="headerlink" title="预备环境"></a>预备环境</h3><p>Kafka 是 Java 生态圈下的一员，用 Scala 编写，运行在 Java 虚拟机上，所以安装运行和普通的 Java 程序并没有什么区别。</p><p>安装 Kafka 官方说法，Java 环境推荐 Java8。</p><p>Kafka 需要 Zookeeper 保存集群的元数据信息和消费者信息。Kafka 一般会自带 Zookeeper，但是从稳定性考虑，应该使用单独的 Zookeeper，而且构建 Zookeeper 集群。</p><h3 id="windows安装"><a href="#windows安装" class="headerlink" title="windows安装"></a>windows安装</h3><p>在 <a href="http://kafka.apache.org/downloads" target="_blank" rel="noopener">http://kafka.apache.org/downloads</a> 上寻找合适的版本下载，我们这里选用的是 kafka_2.11-2.3.0，下载完成后解压到本地目录。</p><p>启动 Zookeeper后进入 Kafka 目录下的 bin\windows执行 <code>kafka-server-start.bat ../../config/server.properties</code>，Linux 下与此类似，进入 bin 后，执行对应的 sh 文件即可。</p><h3 id="docker安装"><a href="#docker安装" class="headerlink" title="docker安装"></a>docker安装</h3><p>方式1，该命令会安装并启动kafka</p><pre><code class="hljs angelscript">docker run --rm -it -p <span class="hljs-number">2181</span>:<span class="hljs-number">2181</span> -p <span class="hljs-number">3030</span>:<span class="hljs-number">3030</span> -p <span class="hljs-number">8081</span>:<span class="hljs-number">8081</span> -p <span class="hljs-number">8082</span>:<span class="hljs-number">8082</span> -p <span class="hljs-number">8083</span>:<span class="hljs-number">8083</span> -p <span class="hljs-number">9092</span>:<span class="hljs-number">9092</span> -e ADV_HOST=<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> -e RUNNING_SAMPLEDATA=<span class="hljs-number">1</span>  landoop/fast-data-dev</code></pre><p>方式2</p><pre><code class="hljs angelscript">我操作的linux 地址：<span class="hljs-number">172.20</span><span class="hljs-number">.10</span><span class="hljs-number">.10</span>kafka需要zookeeper管理，所以需要先安装zookeeper。 <span class="hljs-number">1</span>、下载zookeeper镜像$ docker pull wurstmeister/zookeeper <span class="hljs-number">2</span>、启动镜像生成容器$ docker run --name:zookeeper -p <span class="hljs-number">2181</span>:<span class="hljs-number">2181</span> -d wurstmeister/zookeeper <span class="hljs-number">3</span>、下载kafka镜像$ docker pull wurstmeister/kafka <span class="hljs-number">4</span>、启动kafka镜像生成容器$ docker run -d --name kafka \-p <span class="hljs-number">9092</span>:<span class="hljs-number">9092</span> \-e KAFKA_BROKER_ID=<span class="hljs-number">0</span> \-e KAFKA_ZOOKEEPER_CONNECT=[ip]:<span class="hljs-number">2181</span> \-e KAFKA_ADVERTISED_LISTENERS=PLAINTEXT:<span class="hljs-comment">//[ip]:9092 \</span>-e KAFKA_LISTENERS=PLAINTEXT:<span class="hljs-comment">//0.0.0.0:9092 -t wurstmeister/kafka</span> 参数说明：-e KAFKA_BROKER_ID=<span class="hljs-number">0</span>  在kafka集群中，每个kafka都有一个BROKER_ID来区分自己-e KAFKA_ZOOKEEPER_CONNECT=[ip]:<span class="hljs-number">2181</span>/kafka 配置zookeeper管理kafka的路径-e KAFKA_ADVERTISED_LISTENERS=PLAINTEXT:<span class="hljs-comment">//[ip]:9092  把kafka的地址端口注册给zookeeper，如果是远程访问要改成外网IP,类如Java程序访问出现无法连接。</span>-e KAFKA_LISTENERS=PLAINTEXT:<span class="hljs-comment">//0.0.0.0:9092 配置kafka的监听端口</span>-v /etc/localtime:/etc/localtime 容器时间同步虚拟机的时间 <span class="hljs-number">5</span>、验证kafka是否可以使用<span class="hljs-number">5.1</span>、进入容器$ docker exec -it kafka bash <span class="hljs-number">5.2</span>、进入 /opt/kafka_2<span class="hljs-number">.12</span><span class="hljs-number">-2.3</span><span class="hljs-number">.0</span>/bin/ 目录下$ cd /opt/kafka_2<span class="hljs-number">.12</span><span class="hljs-number">-2.3</span><span class="hljs-number">.0</span>/bin/ <span class="hljs-number">5.3</span>、运行kafka生产者发送消息$ ./kafka-console-producer.sh --broker-list localhost:<span class="hljs-number">9092</span> --topic sun 发送消息&gt; hello word!  <span class="hljs-number">5.4</span>、运行kafka消费者接收消息$ ./kafka-console-consumer.sh --bootstrap-server localhost:<span class="hljs-number">9092</span> --topic sun --<span class="hljs-keyword">from</span>-beginning</code></pre><h3 id="基本的操作和管理"><a href="#基本的操作和管理" class="headerlink" title="基本的操作和管理"></a>基本的操作和管理</h3><pre><code class="hljs sh"><span class="hljs-comment">##列出所有主题</span>kafka-topics --zookeeper localhost:2181 --list<span class="hljs-comment">##列出所有主题的详细信息</span>kafka-topics --zookeeper localhost:2181 --describe<span class="hljs-comment">##创建主题 主题名 my-topic，1 副本，8 分区</span>kafka-topics --zookeeper localhost:2181 --create --topic my-topic --replication-factor 1 --partitions 8 <span class="hljs-comment">##增加分区，注意:分区无法被删除</span>kafka-topics --zookeeper localhost:2181 --alter --topic my-topic --partitions 16<span class="hljs-comment">##删除主题</span>kafka-topics --zookeeper localhost:2181 --delete --topic my-topic<span class="hljs-comment">##创建生产者(控制台)</span>kafka-console-producer --broker-list localhost:9092 --topic my-topic <span class="hljs-comment">##创建消费者(控制台)</span>kafka-console-consumer --bootstrap-server localhost:9092 --topic my-topic --from-beginning <span class="hljs-comment">##列出消费者群组(仅 Linux)</span>kafka-topics --new-consumer --bootstrap-server localhost:9092 --list <span class="hljs-comment">##列出消费者群组详细信息(仅 Linux)</span>kafka-topics --new-consumer --bootstrap-server localhost:9092 --describe --group [群组名]</code></pre><h2 id="Broker配置"><a href="#Broker配置" class="headerlink" title="Broker配置"></a>Broker配置</h2><p>配置文件放在Kafka目录下的config目录中，主要是server.properties文件</p><h3 id="常规配置"><a href="#常规配置" class="headerlink" title="常规配置"></a>常规配置</h3><p><strong>broker.id</strong></p><p>在单机时无需修改，但在集群下部署时往往需要修改。它是每一个 broker 在集群中的唯一表示，要求是正数。当该服务器的 IP 地址发生改变时， broker.id 没有变化，则不会影响 consumers 的消息情况</p><p><strong>listeners</strong></p><p>一般情况下不需要配置，表示监听列表（以逗号分隔，不同的协议如 plaintext、trace、ssl、不同的 IP 和端口），hostname 如果设置为 0.0.0.0 则绑定所有的网卡地址；如果 hostname 为空 则绑定默认的网卡。如果没有配置则默认为 java.net.InetAddress.getCanonicalHostName()。</p><p>如:PLAINTEXT://myhost:9092,TRACE://:9091 或 PLAINTEXT://0.0.0.0:9092。</p><p><strong>zookeeper.connect</strong></p><p>zookeeper 集群的地址，可以是多个，之间用逗号分割。通常为一组 hostname:port/path 列表，hostname 是 zk 的机器名或 IP，port 是 zk 的端口，/path 是可选 zk 的路径，如果不指定，默认使用根路径。</p><p><strong>log.dirs</strong></p><p>Kafka 把所有的消息都保存在磁盘上，存放这些数据的目录通过 log.dirs 指定。可以使用多路径，使用逗号分隔。如果是多路径，Kafka 会根据“最少使用”原则，把同一个分区的日志片段保存到同一路径下。会往拥有最少数据分区的路径新增分区。</p><p><strong>num.recovery.threads.per.data.dir</strong></p><p>每个数据目录用于日志恢复启动和关闭时的线程数量。因为这些线程只是服务器启动（正常启动和崩溃后重启）和关闭时会用到。所以完全可以设置大量的线程来达到并行操作的目的。注意，这个参数指的是每个日志目录的线程数，如果设置为 8，log.dirs 设置为了三个路径，则总共会启动 24 个线程。</p><p><strong>auto.create.topics.enable</strong></p><p>是否允许自动创建主题。如果设为 true，那么 produce（生产者往主题写消息），consume（消费者从主题读消息）或者 fetch metadata（任意客户端 向主题发送元数据请求时）一个不存在的主题时，就会自动创建。缺省为 true。</p><h3 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h3><p><strong>num.partitions</strong></p><p>每个新建主题的分区个数（分区个数只能增加，不能减少）。这个参数一般要评估，比如，每秒钟要写入和读取 1000M 数据，如果现在每个消费者每秒钟可以处理 50MB 的数据，那么需要20个分区，这样就可以让 20 个消费者同时读取这些分区，从而达到设计目标。</p><p><strong>log.retention.hours</strong></p><p>日志保存时间，默认为 7 天（168 小时）。超过这个时间会清理数据。bytes 和 minutes 无论哪个先达到都会触发。与此类似还有 log.retention.minutes 和 log.retention.ms，都设置的话，优先使用具有最小值的那个。</p><p>过期清理是通过检查磁盘上日志片段文件的最后修改时间来实现的。最后修改时间是日志片段关闭的时间，也就是文件里最后一个消息的时间戳，如果日志文件一直被写入就不会删除，但日志文件有大小限制，达到限制之后会写入新建的日志文件中，之前的日志文件过期后就会被删除。</p><p><strong>log.retention.bytes</strong></p><p>topic 每个分区的最大文件大小，一个 topic 的大小限制 = 分区数*log.retention.bytes。-1 没有大小限制。log.retention.bytes 和 log.retention.minutes 任意一个达到要求，都会执行删除。</p><p>如果达到了log.retention.bytes的限制，超过这个限制的数据就会被删除，所以一般不做限制。</p><p><strong>log.segment.bytes</strong></p><p>分区的日志存放在某个目录下诸多文件中，这些文件将分区的日志切分成一段一段的，我们称为日志片段。这个属性就是每个日志片段的最大尺寸，当尺寸达到这个数值时，就会关闭当前文件，并创建新文件。被关闭的文件就开始等待过期，默认为 1G。</p><p>如果一个主题每天只接受 100MB 的消息，那么根据默认设置，需要 10 天才能填满一个文件。而且因为日志片段在关闭之前，消息是不会过期的，所以如果 log.retention.hours 保持默认值的话，那么这个日志片段需要 17 天才过期。因为关闭日志片段需要 10 天，等待过期又需要 7 天。</p><p><strong>log.segment.ms</strong></p><p>作用和 log.segment.bytes 类似，只不过判断依据是时间。同样的，两个参数，以先到的为准。这个参数默认是不开启的。</p><p><strong>log.retention.check.interval.ms</strong></p><p>检查时间间隔，默认为5分钟</p><p><strong>message.max.bytes</strong></p><p>表示一个服务器能够接收处理的消息的最大字节数，注意这个值 producer 和 consumer 必须设置一致，且不要大于 fetch.message.max.bytes 属性的值（消费者能读取的最大消息,这个值应该大于或等于 message.max.bytes）。该值默认是 1000000 字节，大概 900KB~1MB。如果启动压缩，判断压缩后的值。 这个值的大小对性能影响很大，值越大，网络和 IO 的时间越长，还会增加磁盘写入的大小。</p><p>Kafka 设计的初衷是迅速处理短小的消息，一般 10K 大小的消息吞吐性能最好（LinkedIn 的 kafka 性能测试）。</p><h2 id="硬件配置对Kafka性能的影响"><a href="#硬件配置对Kafka性能的影响" class="headerlink" title="硬件配置对Kafka性能的影响"></a>硬件配置对Kafka性能的影响</h2><p>为 Kafka 选择合适的硬件更像是一门艺术，就跟它的名字一样，我们分别从磁盘、内存、网络和 CPU 上来分析，确定了这些关注点，就可以在预算范 围之内选择最优的硬件配置。</p><h3 id="磁盘吞吐量-磁盘容量"><a href="#磁盘吞吐量-磁盘容量" class="headerlink" title="磁盘吞吐量/磁盘容量"></a>磁盘吞吐量/磁盘容量</h3><p>磁盘吞吐量（IOPS 每秒的读写次数）会影响生产者的性能。因为生产者的消息必须被提交到服务器保存，大多数的客户端都会一直等待，直到至少有一个服务器确认消息已经成功提交为止。也就是说，磁盘写入速度越快，生成消息的延迟就越低。（SSD 固态速度比较快，但价格比较高，也可以使用多个HDD机械，设置多个分区加快速度，具体情况具体分析）。</p><p>磁盘容量的大小，则主要看需要保存的消息数量。如果每天收到 1TB 的数据，并保留 7 天，那么磁盘就需要 7TB 的数据。 </p><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>Kafka 本身并不需要太大内存，内存主要是影响消费者性能。在大多数业务情况下，消费者消费的数据一般会从内存中获取，这比在磁盘上读取肯定要快的多。一般来说运行 Kafka 的 JVM 不需要太多的内存，剩余的系统内存可以作为页面缓存，或者用来缓存正在使用的日志片段，所以我们一般 Kafka 不会同其他的重要应用系统部署在一台服务器上，因为他们需要共享页面缓存，这个会降低 Kafka 消费者的性能。</p><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p>网络吞吐量决定了 Kafka 能够处理的最大数据流量。它和磁盘是制约 Kafka 拓展规模的主要因素。对于生产者、消费者写入数据和读取数据都要瓜分网络流量。同时做集群复制也非常消耗网络。</p><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>Kafka 对 cpu 的要求不高，主要是用在对消息解压和压缩上。所以 cpu 的性能不是在使用 Kafka 的首要考虑因素。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们要为 Kafka 选择合适的硬件时，优先考虑存储存储的大小，然后考虑生产者的性能（也就是磁盘的吞吐量），选好存储以后，再来选择 CPU 和内存就容易得多。网络的选择要根据业务上的情况来定，也是非常重要的一环。</p><h2 id="Kafka的集群"><a href="#Kafka的集群" class="headerlink" title="Kafka的集群"></a>Kafka的集群</h2><h3 id="为何需要Kafka集群"><a href="#为何需要Kafka集群" class="headerlink" title="为何需要Kafka集群"></a>为何需要Kafka集群</h3><p>本地开发，一台Kafka足够使用。在实际生产中，集群可以跨服务器进行负载均衡，再则可以使用复制功能来避免单独故障造成的数据丢失。同时集群可以提供高可用性。</p><h3 id="如何估算Kafka集群中Broker的数量"><a href="#如何估算Kafka集群中Broker的数量" class="headerlink" title="如何估算Kafka集群中Broker的数量"></a>如何估算Kafka集群中Broker的数量</h3><p>要估量需要多少磁盘空间保留数据，和每个broker上有多少空间可以用。比如，如果一个集群有10TB的数据需要保留，而每个broker可以存储2TB，那么至少需要5个broker。如果启用了数据复制，则还需要一倍的空间，那么这个集群需要10个broker。<br>集群处理请求的能力。如果因为磁盘吞吐量和内存不足造成性能问题，可以通过扩展broker来解决。</p><h3 id="Broker如何加入Kafka集群"><a href="#Broker如何加入Kafka集群" class="headerlink" title="Broker如何加入Kafka集群"></a>Broker如何加入Kafka集群</h3><p>非常简单，只需要两个参数。第一，配置zookeeper.connect，第二，为新增的broker设置一个集群内的唯一性id。Kafka中的集群是可以动态扩容的。</p>]]></content>
    
    
    <categories>
      
      <category>消息中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>消息中间件</tag>
      
      <tag>Kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kafka入门</title>
    <link href="/blog/2020/05/12/Kafka%E5%85%A5%E9%97%A8/"/>
    <url>/blog/2020/05/12/Kafka%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="Kafka介绍"><a href="#Kafka介绍" class="headerlink" title="Kafka介绍"></a>Kafka介绍</h2><p>kafka最初是LinkedIn的一个内部基础设施系统。最初开发的起因是，LinkedIn虽然有了数据库和其他系统可以用来存储数据，但是缺乏一个可以帮助处理持续数据流的组件。所以在设计理念上，开发者不想只是开发一个能够存储数据的系统，如关系数据库、Nosql数据库、搜索引擎等等，更希望把数据看成一个持续变化和不断增长的流，并基于这样的想法构建出一个数据系统，一个数据架构。</p><p>Kafka外在表现很像消息系统，允许发布和订阅消息流，但是它和传统的消息系统有很大的差异，首先，Kafka是个现代分布式系统，以集群的方式运行，可以自由伸缩。其次，Kafka可以按照要求存储数据，保存多久都可以，<br>第三，流式处理将数据处理的层次提示到了新高度，消息系统只会传递数据，Kafka的流式处理能力可以让我们用很少的代码就能动态地处理派生流和数据集。</p><p>Kafka不仅仅是一个消息中间件，同时它是一个流平台，这个平台上可以发布和订阅数据流（Kafka的流，有一个单独的包Stream的处理），并把他们保存起来，进行处理，这个是Kafka作者的设计理念。</p><p>在大数据领域，Kafka还可以看成实时版的Hadoop，但是还是有些区别，Hadoop可以存储和定期处理大量的数据文件，往往以TB计数，而Kafka可以存储和持续处理大型的数据流。Hadoop主要用在数据分析上，而Kafka因为低延迟，更适合于核心的业务应用上。所以国内的大公司一般会结合使用，比如京东在实时数据计算架构中就使用了到了Kafka，具体见《张开涛-海量数据下的应用系统架构实践》。常见的大数据处理框架：storm、spark、Flink、(Blink阿里)。</p><h2 id="Kafka中的基本概念"><a href="#Kafka中的基本概念" class="headerlink" title="Kafka中的基本概念"></a>Kafka中的基本概念</h2><h3 id="消息和批次"><a href="#消息和批次" class="headerlink" title="消息和批次"></a>消息和批次</h3><p>消息，Kafka 里的数据单元，也就是我们一般消息中间件里的消息的概念（可以比作数据库中一条记录）。消息由字节数组组成。消息还可以包含键 （可选元数据，也是字节数组），主要用于对消息选取分区。</p><p>作为一个高效的消息系统，为了提高效率，消息可以被分批写入Kafka。批次就是一组消息，这些消息属于同一个主题和分区。如果只传递单个消息， 会导致大量的网络开销，把消息分成批次传输可以减少这开销。但是，这个需要权衡（时间延迟和吞吐量之间），批次里包含的消息越多，单位时间内处理的消息就越多，单个消息的传输时间就越长（吞吐量高延时也高）。如果进行压缩，可以提升数据的传输和存储能力，但需要更多的计算处理。</p><p>对于 Kafka 来说，消息是晦涩难懂的字节数组，一般我们使用序列化和反序列化技术，格式常用的有JSON和XML，还有Avro（Hadoop开发的一款序列化框架），具体怎么使用依据自身的业务来定。</p><h3 id="主题和分区"><a href="#主题和分区" class="headerlink" title="主题和分区"></a>主题和分区</h3><p>Kafka里的消息用主题进行分类（主题好比数据库中的表），主题下有可以被分为若干个分区（分表技术）。分区本质上是个提交日志文件，有新消息，这个消息就会以追加的方式写入分区（写文件的形式），然后用先入先出的顺序读取。</p><img src="/blog/2020/05/12/Kafka%E5%85%A5%E9%97%A8/pic1.png" srcset="/blog/img/loading.gif" class><p>由于主题会有多个分区，所以在整个主题的范围内，是无法保证消息的顺序的，单个分区则可以保证。</p><p>Kafka 通过分区来实现数据冗余和伸缩性，因为分区可以分布在不同的服务器上，那就是说一个主题可以跨越多个服务器（这是 Kafka 高性能的一个原因，多台服务器的磁盘读写性能比单台更高）。</p><p>前面我们说Kafka可以看成一个流平台，很多时候，我们会把一个主题的数据看成一个流，不管有多少个分区。</p><h3 id="生产者和消费者、偏移量、消费者群组"><a href="#生产者和消费者、偏移量、消费者群组" class="headerlink" title="生产者和消费者、偏移量、消费者群组"></a>生产者和消费者、偏移量、消费者群组</h3><p>生产者消费者就是一般消息中间件里生产者和消费者的概念。Kafka的一些其他的高级客户端API，像数据管道API和流式处理的KafkaStream，都是使用了最基本的生产者和消费者作为内部组件，然后提供了高级功能。</p><p>生产者默认情况下把消息均衡分布到主题的所有分区上，如果需要指定分区，则需要使用消息里的消息键和分区器。</p><p>消费者可以订阅一个或者多个主题，并按照消息的生成顺序读取。消费者通过检查偏移量来区分消息是否读取过。偏移量是一种元数据，一个不断递增的整数值，创建消息的时候，Kafka会把他加入消息。在一个主题中一个分区里，每个消息的偏移量是唯一的。每个分区最后读取的消息偏移量会保存到Zookeeper或者Kafka上，这样分区的消费者关闭或者重启，读取状态都不会丢失。</p><p>共同读取一个主题的多个消费者可以构成一个消费者群组，群组可以保证每个分区只被一个消费者使用。</p><img src="/blog/2020/05/12/Kafka%E5%85%A5%E9%97%A8/pic2.png" srcset="/blog/img/loading.gif" class><p>消费者和分区之间的这种映射关系叫做消费者对分区的所有权关系，很明显，一个分区只有一个消费者，而一个消费者可以有多个分区。一个分区只能被消费者群组中的一个消费者消费（不能重复消费），如果有一个消费者挂掉了，另外的消费者接上。</p><h3 id="Broker和集群"><a href="#Broker和集群" class="headerlink" title="Broker和集群"></a>Broker和集群</h3><p>一个独立的Kafka服务器叫Broker。broker的主要工作是接收生产者的消息、设置偏移量、提交消息到磁盘保存、为消费者提供服务、响应请求、返回消息。在合适的硬件上，单个broker可以处理上千个分区和每秒百万级的消息量（要达到这个目的需要做操作系统调优和JVM调优）。</p><p>多个broker可以组成一个集群，每个集群中broker会选举出一个集群控制器。控制器会进行管理，包括将分区分配给broker和监控broker。在集群中，一个分区可以被分配给多个broler，其中会有一个首领，首领负责接收消息并通过管道的方式与其他broker进行分区复制。</p><img src="/blog/2020/05/12/Kafka%E5%85%A5%E9%97%A8/pic3.png" srcset="/blog/img/loading.gif" class><p>分区复制提供了消息冗余。一旦首领broker失效，其他broker可以接管领导权。当然相关的消费者和生产者都要重新连接到新的首领上。</p><h3 id="保留消息"><a href="#保留消息" class="headerlink" title="保留消息"></a>保留消息</h3><p>在一定期限内保留消息是Kafka的一个重要特性，Kafkabroker默认的保留策略是：保留一段时间（默认7天）或者保留一定大小（比如1个G）。到达限制后会进行旧消息的过期删除。但是每个主题可以根据业务需求配置自己的保留策略（开发时要注意，Kafka不像Mysql之类的永久存储）。 </p><h2 id="Kafka的优势"><a href="#Kafka的优势" class="headerlink" title="Kafka的优势"></a>Kafka的优势</h2><ul><li><p>多生产者和多消费者。</p></li><li><p>基于磁盘的数据存储，换句话说，Kafka 的数据天生就是持久化的。</p></li><li><p>高伸缩性，Kafka 一开始就被设计成一个具有灵活伸缩性的系统，对在线集群的伸缩丝毫不影响整体系统的可用性。</p></li><li><p>高性能，结合横向扩展生产者、消费者和broker，Kafka 可以轻松处理巨大的信息流（LinkedIn 公司每天处理万亿级数据），同时保证亚秒级的消息延迟。</p></li></ul><h2 id="常见场景"><a href="#常见场景" class="headerlink" title="常见场景"></a>常见场景</h2><h3 id="活动跟踪"><a href="#活动跟踪" class="headerlink" title="活动跟踪"></a>活动跟踪</h3><p>跟踪网站用户和前端应用发生的交互，比如页面访问次数和点击，将这些信息作为消息发布到一个或者多个主题上，这样就可以根据这些数据为机器学习提供数据，更新搜素结果等等（头条、淘宝等总会推送你感兴趣的内容，其实在数据分析之前就已经做了活动跟踪）。</p><h3 id="传递消息"><a href="#传递消息" class="headerlink" title="传递消息"></a>传递消息</h3><p>标准消息中间件的功能</p><h3 id="收集指标和日志"><a href="#收集指标和日志" class="headerlink" title="收集指标和日志"></a>收集指标和日志</h3><p>收集应用程序和系统的度量监控指标，或者收集应用日志信息，通过 Kafka 路由到专门的日志搜索系统，比如 ES（国内用得较多）。</p><h3 id="提交日志"><a href="#提交日志" class="headerlink" title="提交日志"></a>提交日志</h3><p>收集其他系统的变动日志，比如数据库。可以把数据库的更新发布到Kafka上，应用通过监控事件流来接收数据库的实时更新，或者通过事件流将数 据库的更新复制到远程系统。</p><p>还可以当其他系统发生了崩溃，通过重放日志来恢复系统的状态（异地灾备）。</p><h3 id="流处理"><a href="#流处理" class="headerlink" title="流处理"></a>流处理</h3><p>操作实时数据流，进行统计、转换、复杂计算等等。随着大数据技术的不断发展和成熟，无论是传统企业还是互联网公司都已经不再满足于离线批处理，实时流处理的需求和重要性日益增长。</p><p>近年来业界一直在探索实时流计算引擎和API，比如这几年火爆的SparkStreaming、KafkaStreaming、Beam和Flink，其中阿里双11会场展示的实时销售金额，就用的是流计算，是基于Flink，然后阿里在其上定制化的Blink。</p>]]></content>
    
    
    <categories>
      
      <category>消息中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>消息中间件</tag>
      
      <tag>Kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ的管理</title>
    <link href="/blog/2020/05/11/RabbitMQ%E7%9A%84%E7%AE%A1%E7%90%86/"/>
    <url>/blog/2020/05/11/RabbitMQ%E7%9A%84%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="RabbitMQ日志"><a href="#RabbitMQ日志" class="headerlink" title="RabbitMQ日志"></a>RabbitMQ日志</h2><p>一般放在：<code>/var/log/rabbitmq/rabbit@centosvm.log</code>跟<code>/var/log/rabbitmq/rabbit@centosvm-sasl.log</code>中</p><h2 id="RabbitMQ命令"><a href="#RabbitMQ命令" class="headerlink" title="RabbitMQ命令"></a>RabbitMQ命令</h2><h4 id="管理虚拟主机"><a href="#管理虚拟主机" class="headerlink" title="管理虚拟主机"></a>管理虚拟主机</h4><pre><code class="hljs sh"><span class="hljs-comment">#添加虚拟主机</span>rabbitmqctl add_vhost [vhost_name] <span class="hljs-comment">#删除虚拟主机</span>rabbitmqctl delete_vhost [vhost_name] <span class="hljs-comment">#查看虚拟主机</span>rabbitmqctl list_vhosts</code></pre><h4 id="启动和关闭rabbitmq"><a href="#启动和关闭rabbitmq" class="headerlink" title="启动和关闭rabbitmq"></a>启动和关闭rabbitmq</h4><ul><li><p><code>rabbitmq-server</code>：启动Erlang节点和Rabbitmq应用</p></li><li><p><code>rabbitmqctl stop</code>：关闭Erlang节点和Rabbitmq应用</p></li><li><p><code>rabbitmqctl stop_app</code>：关闭Rabbitmq应用</p></li><li><p><code>rabbitmqctl start_app</code>：启动Rabbitmq应用</p></li><li><p><code>rabbitmqctl status</code>：检查消息节点是否正常</p></li></ul><p>Rabbitmq配置文件放在 /etc/rabbitmq 下，名为rabbitmq.config，没有且需要使用则可以自己新建一个。</p><h4 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h4><pre><code class="hljs shell">rabbitmqctl add_user [username] [pwd]rabbitmqctl delete_user [username]rabbitmqctl change_password [username] [pwd]</code></pre><h4 id="用户权限"><a href="#用户权限" class="headerlink" title="用户权限"></a>用户权限</h4><p>这个virtual host中所有资源的配置、写、读权限以便管理其中的资源</p><pre><code class="hljs sh">rabbitmqctl set_permissions [-p &lt;vhostpath&gt;] &lt;user&gt; &lt;conf&gt; &lt;write&gt; &lt;<span class="hljs-built_in">read</span>&gt;</code></pre><p>注意在win上，字符全部使用双引号，linux上使用单引号</p><pre><code class="hljs sh"><span class="hljs-comment">#windows中 .*是正则表达式，表示全部</span>rabbitmqctl set_permissions -p / king <span class="hljs-string">".*"</span> <span class="hljs-string">".*"</span> <span class="hljs-string">".*"</span><span class="hljs-comment">#linux中</span>rabbitmqctl set_permissions -p / king <span class="hljs-string">'.*'</span> <span class="hljs-string">'.*'</span> <span class="hljs-string">'.*'</span></code></pre><h4 id="用户的角色"><a href="#用户的角色" class="headerlink" title="用户的角色"></a>用户的角色</h4><pre><code class="hljs css"><span class="hljs-selector-tag">rabbitmqctl</span>  <span class="hljs-selector-tag">set_user_tags</span> <span class="hljs-selector-attr">[username]</span> <span class="hljs-selector-attr">[tag]</span></code></pre><p>username为用户名， tag为角色名共有administrator、monitoring、policymaker、management、none五种。<br>赋予其administrator角色</p><pre><code class="hljs sh">rabbitmqctl set_user_tags testuser administrator</code></pre><h4 id="查看队列"><a href="#查看队列" class="headerlink" title="查看队列"></a>查看队列</h4><pre><code class="hljs sh">rabbitmqctl list_queues</code></pre><h4 id="查看交换器"><a href="#查看交换器" class="headerlink" title="查看交换器"></a>查看交换器</h4><pre><code class="hljs sh">rabbitmqctl list_exchanges</code></pre><h4 id="查看绑定"><a href="#查看绑定" class="headerlink" title="查看绑定"></a>查看绑定</h4><pre><code class="hljs sh">rabbitmqctl list_bindings</code></pre><h2 id="RabbitMQ集群"><a href="#RabbitMQ集群" class="headerlink" title="RabbitMQ集群"></a>RabbitMQ集群</h2><h3 id="内建集群"><a href="#内建集群" class="headerlink" title="内建集群"></a>内建集群</h3><p>RabbitMQ内建集群的设计目的：</p><ul><li>保证生产者和消费者在单个节点崩溃的情况下，能够继续运行。</li><li>通过拓展节点提高吞吐量。</li><li>节点间的元数据、交换器信息会进行复制。元数据信息包括队列名称，属性（是否持久化，是否自动删除等），交换器信息包括交换器类型、属性、绑定关系。</li></ul><p>注意，RabbitMQ节点之间不会复制队列中的消息，如果某个节点宕机，其中保存的消息就会丢失。</p><h3 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h3><ol><li><p>修改/etc/hosts </p><pre><code class="hljs accesslog"><span class="hljs-number">192.168.1.1</span> node1<span class="hljs-number">192.168.1.2</span> node2</code></pre></li><li><p>修改机器名/etc/hostname</p><pre><code class="hljs accesslog"><span class="hljs-number">192.168.1.1</span>的机器  node1<span class="hljs-number">192.168.1.2</span>的机器  node2</code></pre></li><li><p>修改Erlang Cookie文件，不同服务器上的文件内容应该一致，同时权限和所属用户组</p><pre><code class="hljs crystal">vim /var/<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">rabbitmq</span>/.<span class="hljs-title">erlang</span>.<span class="hljs-title">cookie</span></span></code></pre></li><li><p>node1和node2均要关闭防火墙</p><pre><code class="hljs dockerfile">firewall-<span class="hljs-keyword">cmd</span><span class="bash"> --permanent --add-port=15672/tcp</span>firewall-<span class="hljs-keyword">cmd</span><span class="bash"> --permanent --add-port=5672/tcp</span>firewall-<span class="hljs-keyword">cmd</span><span class="bash"> --permanent --add-port=25672/tcp</span>firewall-<span class="hljs-keyword">cmd</span><span class="bash"> --permanent --add-port=4369/tcp</span>firewall-<span class="hljs-keyword">cmd</span><span class="bash"> --reload</span>======如果怀疑有端口未打开，使用以下rab命令检查，返回yes表示成功firewall-<span class="hljs-keyword">cmd</span><span class="bash"> --query-port=4369/tcp</span></code></pre></li><li><p>在node2上运行，将node2添加到node1中</p><pre><code class="hljs shell">rabbitmqctl stop_apprabbitmqctl reset<span class="hljs-meta">#</span><span class="bash">node2中</span>rabbitmqctl join_cluster rabbit@node1rabbitmqctl start_app<span class="hljs-meta">#</span><span class="bash">检查集群状态（node1和node2均可）</span>rabbitmqctl cluster_status</code></pre></li><li><p>加入内存节点</p><pre><code class="hljs moonscript">rabbitmqctl join_cluster rabbit@node1 <span class="hljs-comment">--ram</span></code></pre></li><li><p>移除集群中的node2</p><pre><code class="hljs properties"><span class="hljs-attr">rabbitmqctl</span> <span class="hljs-string">stop_app</span><span class="hljs-attr">rabbitmqctl</span> <span class="hljs-string">reset</span><span class="hljs-attr">rabbitmqctl</span> <span class="hljs-string">start_app</span></code></pre></li></ol><h2 id="RabbitMQ集群高可用"><a href="#RabbitMQ集群高可用" class="headerlink" title="RabbitMQ集群高可用"></a>RabbitMQ集群高可用</h2><h3 id="镜像队列"><a href="#镜像队列" class="headerlink" title="镜像队列"></a>镜像队列</h3><p>如果RabbitMQ集群是由多个broker节点构成的，那么从服务的整体可用性上来讲，该集群对于单点失效是有弹性的，但是同时也需要注意，尽管exchange和binding能够在单点失效问题上幸免于难，但是queue和其上持有的message却不行。queue及其内容仅仅存储于单个节点之上，所以一个节点的失效表现为其对应的queue及其内容不可用。</p><p>RabbitMQ的镜像队列机制，可以将queue镜像到cluster中其他的节点之上。在该实现下，如果集群中的一个节点失效了，queue能自动地切换到镜像中的另一个节点以保证服务的可用性。在通常的用法中，针对每一个镜像队列都包含一个master和多个slave，分别对应于不同的节点。slave会准确地按照master执行命令的顺序进行命令执行，故slave与master上维护的状态应该是相同的。除了publish外所有动作都只会向master发送，然后由master将命令执行的结果广播给所有的slave，故看似从镜像队列中的消费操作实际上是在master上执行的。</p><h3 id="镜像队列的配置"><a href="#镜像队列的配置" class="headerlink" title="镜像队列的配置"></a>镜像队列的配置</h3><ol><li>在代码中进行配置</li></ol><pre><code class="hljs java">Map&lt;String, Object&gt; args = <span class="hljs-keyword">new</span> HashMap&lt;String, Object&gt;();<span class="hljs-comment">//镜像到所有节点</span>args.put(<span class="hljs-string">"x-ha-policy"</span>, <span class="hljs-string">"all"</span>);<span class="hljs-comment">//镜像到指定节点</span><span class="hljs-comment">//args.put("x-ha-policy","nodes");</span><span class="hljs-comment">//args.put("x-ha-nodes","[rabbit@node1,rabbit2@node2]");</span>channel.queueDeclare(queueName,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, args);</code></pre><ol start="2"><li>通过命令行配置</li></ol><p>镜像队列的配置通过添加policy完成，policy添加的命令为：</p><pre><code class="hljs css"><span class="hljs-selector-tag">rabbitmqctl</span> <span class="hljs-selector-tag">set_policy</span> <span class="hljs-selector-attr">[-p Vhost]</span> <span class="hljs-selector-tag">Name</span> <span class="hljs-selector-tag">Pattern</span> <span class="hljs-selector-tag">Definition</span> <span class="hljs-selector-attr">[Priority]</span></code></pre><ul><li><p>-p Vhost：可选参数，针对指定vhost下的queue进行设置</p></li><li><p>Name：policy的名称</p></li><li><p>Pattern：queue的匹配模式(正则表达式)</p></li><li><p>Definition：镜像定义，包括三个部分ha-mode, ha-params, ha-sync-mode</p><ul><li>ha-mode：指明镜像队列的模式，有效值为 all/exactly/nodes</li><li>all：表示在集群中所有的节点上进行镜像</li><li>exactly：表示在指定个数的节点上进行镜像，节点的个数由ha-params指定</li><li>nodes：表示在指定的节点上进行镜像，节点名称通过ha-params指定</li><li>ha-params：ha-mode模式需要用到的参数</li><li>ha-sync-mode：进行队列中消息的同步方式，有效值为automatic和manual</li></ul></li><li><p>priority：可选参数，policy的优先级</p></li></ul><p>例如，对队列名称以“queue_”开头的所有队列进行镜像，并在集群的两个节点上完成进行，policy的设置命令为：</p><pre><code class="hljs scilab">rabbitmqctl set_policy ha-queue-two <span class="hljs-string">'^queue_'</span> <span class="hljs-string">'&#123;"</span>ha-mode<span class="hljs-string">":"</span>exactly<span class="hljs-string">","</span>ha-params<span class="hljs-string">":2,"</span>ha-sync-mode<span class="hljs-string">":"</span>automatic<span class="hljs-string">"&#125;'</span></code></pre><h2 id="RabbitMQ负载均衡"><a href="#RabbitMQ负载均衡" class="headerlink" title="RabbitMQ负载均衡"></a>RabbitMQ负载均衡</h2><p>对于RabbitMQ集群来说，主要有两类负载均衡，客户端内部的和服务端的，客户端内部主要是采用负载均衡算法，服务端主要是采用代理服务器，这里采用尝试HAProxy实现RabbitMQ负载均衡的操作。</p><pre><code class="hljs angelscript">============下载并解压============cd /usr/local/src/wget http:<span class="hljs-comment">//pkgs.fedoraproject.org/repo/pkgs/haproxy/haproxy-1.7.9.tar.gz/sha512/d1ed791bc9607dbeabcfc6a1853cf258e28b3a079923b63d3bf97504dd59e64a5f5f44f9da968c23c12b4279e8d45ff3bd39418942ca6f00d9d548c9a0ccfd73/haproxy-1.7.9.tar.gz</span>tar zxvf haproxy<span class="hljs-number">-1.7</span><span class="hljs-number">.9</span>.tar.gz============安装============cd haproxy<span class="hljs-number">-1.7</span><span class="hljs-number">.9</span>uname -r<span class="hljs-number">3.10</span><span class="hljs-number">.0</span><span class="hljs-number">-514.</span>el7.x86_64make TARGET=linux310 ARCH=x86_64 PREFIX=/usr/local/haproxymake install PREFIX=/usr/local/haproxy==参数说明：==TARGET=linux310，内核版本，使用uname -r查看内核，如：<span class="hljs-number">3.10</span><span class="hljs-number">.0</span><span class="hljs-number">-514.</span>el7，此时该参数就为linux310；kernel ==大于<span class="hljs-number">2.6</span><span class="hljs-number">.28</span>的可以用：TARGET=linux2628；==ARCH=x86_64，系统位数；==PREFIX=/usr/local/haprpxy #/usr/local/haprpxy，为haprpxy安装路径。============添加配置文件============cd /usr/local/haproxymkdir confcd conf/vim haproxy.cfg global        log <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>   local0        maxconn <span class="hljs-number">1000</span>        daemon defaults        log     global        mode    http        option  httplog        option  dontlognull        retries <span class="hljs-number">3</span>        timeout connect <span class="hljs-number">5000</span>        timeout client  <span class="hljs-number">50000</span>        timeout server <span class="hljs-number">50000</span> listen admin_stats        bind <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>:<span class="hljs-number">1080</span>        mode http        option httplog        maxconn <span class="hljs-number">10</span>        stats <span class="hljs-built_in">ref</span>resh <span class="hljs-number">30</span>s        stats uri /stats        stats realm XingCloud\ Haproxy        stats auth admin:admin        stats auth  Frank:Frank        stats hide-version        stats  admin <span class="hljs-keyword">if</span> TRUElisten rabbitmq_cluster        bind <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>:<span class="hljs-number">5670</span>        mode tcp        balance roundrobinserver rabbit01 <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">5672</span> check <span class="hljs-built_in">int</span>er <span class="hljs-number">5000</span> rise <span class="hljs-number">2</span> fall <span class="hljs-number">3</span>server rabbit02 node2:<span class="hljs-number">5672</span> check <span class="hljs-built_in">int</span>er <span class="hljs-number">5000</span> rise <span class="hljs-number">2</span> fall <span class="hljs-number">3</span>        ============启动haproxy============/usr/local/haproxy/sbin/haproxy -f /usr/local/haproxy/conf/haproxy.cfg============验证============lsof -i :<span class="hljs-number">1080</span>============访问统计页面============http:<span class="hljs-comment">//127.0.0.1:1080/stats</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>消息中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>消息中间件</tag>
      
      <tag>RabbitMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ与spring的集成</title>
    <link href="/blog/2020/05/10/RabbitMQ%E4%B8%8Espring%E7%9A%84%E9%9B%86%E6%88%90/"/>
    <url>/blog/2020/05/10/RabbitMQ%E4%B8%8Espring%E7%9A%84%E9%9B%86%E6%88%90/</url>
    
    <content type="html"><![CDATA[<h2 id="与spring的集成"><a href="#与spring的集成" class="headerlink" title="与spring的集成"></a>与spring的集成</h2><h3 id="pom文件"><a href="#pom文件" class="headerlink" title="pom文件"></a>pom文件</h3><p>项目中使用的spring版本为4.3.11，所以引入的是2.0.0，兼容性可以在spring官网中查到。</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.amqp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-rabbit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h3 id="消息的发送"><a href="#消息的发送" class="headerlink" title="消息的发送"></a>消息的发送</h3><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-comment">&lt;!-- 查找最新的schemaLocation 访问 http://www.springframework.org/schema/ --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span><span class="hljs-tag">      <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">      <span class="hljs-attr">xmlns:rabbit</span>=<span class="hljs-string">"http://www.springframework.org/schema/rabbit"</span></span><span class="hljs-tag">      <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">"http://www.springframework.org/schema/context"</span></span><span class="hljs-tag">      <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans</span></span><span class="hljs-tag"><span class="hljs-string">          http://www.springframework.org/schema/beans/spring-beans-4.0.xsd</span></span><span class="hljs-tag"><span class="hljs-string">      http://www.springframework.org/schema/rabbit</span></span><span class="hljs-tag"><span class="hljs-string">      http://www.springframework.org/schema/rabbit/spring-rabbit-2.0.xsd</span></span><span class="hljs-tag"><span class="hljs-string">      http://www.springframework.org/schema/context</span></span><span class="hljs-tag"><span class="hljs-string">      http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span>     <span class="hljs-comment">&lt;!-- 配置扫描路径 --&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">"cn.enjoyedu"</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">context:exclude-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"annotation"</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">"org.springframework.stereotype.Controller"</span>/&gt;</span>     <span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span>   <span class="hljs-comment">&lt;!-- rabbitMQ配置 --&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"rabbitConnectionFactory"</span></span><span class="hljs-tag">        <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.amqp.rabbit.connection.CachingConnectionFactory"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"127.0.0.1"</span>/&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"guest"</span>/&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"guest"</span>/&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"channelCacheSize"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"8"</span>/&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"port"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"5672"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>   <span class="hljs-comment">&lt;!--Spring的rabbitmq admin--&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">rabbit:admin</span> <span class="hljs-attr">connection-factory</span>=<span class="hljs-string">"rabbitConnectionFactory"</span>/&gt;</span>    <span class="hljs-comment">&lt;!-- 创建rabbitTemplate 消息模板类 --&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">rabbit:template</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"rabbitTemplate"</span> <span class="hljs-attr">connection-factory</span>=<span class="hljs-string">"rabbitConnectionFactory"</span>/&gt;</span>      <span class="hljs-comment">&lt;!--生产者创建队列--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">rabbit:queue</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"h4_queue"</span> <span class="hljs-attr">durable</span>=<span class="hljs-string">"false"</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">rabbit:queue</span>&gt;</span>   <span class="hljs-comment">&lt;!--fanout交换器--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">rabbit:fanout-exchange</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"fanout-exchange"</span></span><span class="hljs-tag">          <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/rabbit"</span> <span class="hljs-attr">durable</span>=<span class="hljs-string">"false"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">bindings</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">binding</span> <span class="hljs-attr">queue</span>=<span class="hljs-string">"h4_queue"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">binding</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">bindings</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">rabbit:fanout-exchange</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>注意：生产者和消费者中都可以完成交换器、队列的申明，以及绑定关系的建立，但建议在生产者和消费者中都进行设置，这样可以保证在其中一方没有启动的情况下，另一方可以完成自己的功能，不会受影响。</p><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/rabbitmq"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitMqController</span> </span>&#123;    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(RabbitMqController<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-meta">@Autowired</span>    RabbitTemplate rabbitTemplate;    <span class="hljs-meta">@ResponseBody</span>    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/fanoutSender"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">fanoutSender</span><span class="hljs-params">(@RequestParam(<span class="hljs-string">"message"</span>)</span>String message)</span>&#123;        String opt=<span class="hljs-string">""</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++)&#123;                String str = <span class="hljs-string">"Fanout,the message_"</span>+i+<span class="hljs-string">" is : "</span>+message;                logger.info(<span class="hljs-string">"**************************Send Message:["</span>+str+<span class="hljs-string">"]"</span>);                rabbitTemplate.send(<span class="hljs-string">"fanout-exchange"</span>,<span class="hljs-string">""</span>,                        <span class="hljs-keyword">new</span> Message(str.getBytes(),<span class="hljs-keyword">new</span> MessageProperties()));            &#125;            opt = <span class="hljs-string">"suc"</span>;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            opt = e.getCause().toString();        &#125;        <span class="hljs-keyword">return</span> opt;    &#125;    <span class="hljs-meta">@ResponseBody</span>    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/topicSender"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">topicSender</span><span class="hljs-params">(@RequestParam(<span class="hljs-string">"message"</span>)</span>String message)</span>&#123;        String opt=<span class="hljs-string">""</span>;        <span class="hljs-keyword">try</span> &#123;            String[] routekeys=&#123;<span class="hljs-string">"king"</span>,<span class="hljs-string">"mark"</span>,<span class="hljs-string">"james"</span>&#125;;            String[] modules=&#123;<span class="hljs-string">"kafka"</span>,<span class="hljs-string">"jvm"</span>,<span class="hljs-string">"redis"</span>&#125;;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;routekeys.length;i++)&#123;                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;modules.length;j++)&#123;                    String routeKey = routekeys[i]+<span class="hljs-string">"."</span>+modules[j];                    String str = <span class="hljs-string">"Topic,the message_["</span>+i+<span class="hljs-string">","</span>+j+<span class="hljs-string">"] is [rk:"</span>+routeKey+<span class="hljs-string">"][msg:"</span>+message+<span class="hljs-string">"]"</span>;                    logger.info(<span class="hljs-string">"**************************Send Message:["</span>+str+<span class="hljs-string">"]"</span>);                    MessageProperties messageProperties = <span class="hljs-keyword">new</span> MessageProperties();                    rabbitTemplate.send(<span class="hljs-string">"topic-exchange"</span>,                            routeKey,                            <span class="hljs-keyword">new</span> Message(str.getBytes(), messageProperties));                &#125;            &#125;            opt = <span class="hljs-string">"suc"</span>;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            opt = e.getCause().toString();        &#125;        <span class="hljs-keyword">return</span> opt;    &#125;&#125;</code></pre><h3 id="消息的接收"><a href="#消息的接收" class="headerlink" title="消息的接收"></a>消息的接收</h3><h4 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h4><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-comment">&lt;!-- 查找最新的schemaLocation 访问 http://www.springframework.org/schema/ --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span><span class="hljs-tag">      <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">      <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">"http://www.springframework.org/schema/context"</span></span><span class="hljs-tag">      <span class="hljs-attr">xmlns:rabbit</span>=<span class="hljs-string">"http://www.springframework.org/schema/rabbit"</span></span><span class="hljs-tag">      <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"</span></span><span class="hljs-tag"><span class="hljs-string">           http://www.springframework.org/schema/beans</span></span><span class="hljs-tag"><span class="hljs-string">           http://www.springframework.org/schema/beans/spring-beans-4.0.xsd</span></span><span class="hljs-tag"><span class="hljs-string">           http://www.springframework.org/schema/context</span></span><span class="hljs-tag"><span class="hljs-string">           http://www.springframework.org/schema/context/spring-context-4.0.xsd</span></span><span class="hljs-tag"><span class="hljs-string">           http://www.springframework.org/schema/rabbit</span></span><span class="hljs-tag"><span class="hljs-string">           http://www.springframework.org/schema/rabbit/spring-rabbit-2.0.xsd"</span>&gt;</span>     <span class="hljs-comment">&lt;!-- 配置扫描路径 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">"cn.enjoyedu"</span>&gt;</span>       <span class="hljs-comment">&lt;!-- 只扫描Service，也可以添加Repostory，但是要把Controller排除在外，Controller由spring-mvc.xml去加载 --&gt;</span>       <span class="hljs-comment">&lt;!-- &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Service" /&gt; --&gt;</span>       <span class="hljs-comment">&lt;!-- &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Repository" /&gt; --&gt;</span>        <span class="hljs-comment">&lt;!--&lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Component" /&gt;--&gt;</span>         <span class="hljs-tag">&lt;<span class="hljs-name">context:exclude-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"annotation"</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">"org.springframework.stereotype.Controller"</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><span class="hljs-comment">&lt;!-- rabbitMQ配置 --&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"rabbitConnectionFactory"</span></span><span class="hljs-tag">        <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.amqp.rabbit.connection.CachingConnectionFactory"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"127.0.0.1"</span>/&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"guest"</span>/&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"guest"</span>/&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"channelCacheSize"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"8"</span>/&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"port"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"5672"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">rabbit:admin</span> <span class="hljs-attr">connection-factory</span>=<span class="hljs-string">"rabbitConnectionFactory"</span>/&gt;</span>    <span class="hljs-comment">&lt;!-- fanout交换器 begin--&gt;</span>    <span class="hljs-comment">&lt;!-- 定义队列 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">rabbit:queue</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"h1_queue"</span> <span class="hljs-attr">durable</span>=<span class="hljs-string">"false"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">rabbit:queue</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"h2_queue"</span> <span class="hljs-attr">durable</span>=<span class="hljs-string">"false"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">rabbit:queue</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"h3_queue"</span> <span class="hljs-attr">durable</span>=<span class="hljs-string">"false"</span>/&gt;</span>    <span class="hljs-comment">&lt;!-- 把需要数据的队列与交换器绑定一起 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">rabbit:fanout-exchange</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"fanout-exchange"</span></span><span class="hljs-tag">        <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/rabbit"</span> <span class="hljs-attr">durable</span>=<span class="hljs-string">"false"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">rabbit:bindings</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">rabbit:binding</span> <span class="hljs-attr">queue</span>=<span class="hljs-string">"h1_queue"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">rabbit:binding</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">rabbit:binding</span> <span class="hljs-attr">queue</span>=<span class="hljs-string">"h2_queue"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">rabbit:binding</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">rabbit:binding</span> <span class="hljs-attr">queue</span>=<span class="hljs-string">"h3_queue"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">rabbit:binding</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">rabbit:bindings</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">rabbit:fanout-exchange</span>&gt;</span>    <span class="hljs-comment">&lt;!-- fanout交换器 end--&gt;</span>    <span class="hljs-comment">&lt;!-- topic交换器 begin--&gt;</span>    <span class="hljs-comment">&lt;!-- 定义队列 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">rabbit:queue</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"all_queue"</span> <span class="hljs-attr">durable</span>=<span class="hljs-string">"false"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">rabbit:queue</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"all_kafka_queue"</span> <span class="hljs-attr">durable</span>=<span class="hljs-string">"false"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">rabbit:queue</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"king_kafka_queue"</span> <span class="hljs-attr">durable</span>=<span class="hljs-string">"false"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">rabbit:queue</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"king_all_queue"</span> <span class="hljs-attr">durable</span>=<span class="hljs-string">"false"</span>/&gt;</span>    <span class="hljs-comment">&lt;!-- 把需要数据的队列通过路由键与topic交换器绑定一起 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">rabbit:topic-exchange</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"topic-exchange"</span></span><span class="hljs-tag">           <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/rabbit"</span> <span class="hljs-attr">durable</span>=<span class="hljs-string">"false"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">rabbit:bindings</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">binding</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">"#"</span> <span class="hljs-attr">queue</span>=<span class="hljs-string">"all_queue"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">binding</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">binding</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">"*.kafka"</span> <span class="hljs-attr">queue</span>=<span class="hljs-string">"all_kafka_queue"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">binding</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">binding</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">"king.kafka"</span> <span class="hljs-attr">queue</span>=<span class="hljs-string">"king_kafka_queue"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">binding</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">binding</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">"king.*"</span> <span class="hljs-attr">queue</span>=<span class="hljs-string">"king_all_queue"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">binding</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">rabbit:bindings</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">rabbit:topic-exchange</span>&gt;</span>    <span class="hljs-comment">&lt;!-- topic交换器 end--&gt;</span>    <span class="hljs-comment">&lt;!--消费者定义--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"h1_Service"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"cn.enjoyedu.service.fanout.H1_Service"</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"h2_Service"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"cn.enjoyedu.service.fanout.H2_Service"</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"h3_Service"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"cn.enjoyedu.service.fanout.H3_Service"</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>    <span class="hljs-comment">&lt;!--监听容器--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">rabbit:listener-container</span> <span class="hljs-attr">connection-factory</span>=<span class="hljs-string">"rabbitConnectionFactory"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">rabbit:listener</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"h1_Service"</span> <span class="hljs-attr">queues</span>=<span class="hljs-string">"h1_queue"</span></span><span class="hljs-tag">                         <span class="hljs-attr">method</span>=<span class="hljs-string">"onMessage"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">rabbit:listener</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"h2_Service"</span> <span class="hljs-attr">queues</span>=<span class="hljs-string">"h2_queue"</span></span><span class="hljs-tag">                         <span class="hljs-attr">method</span>=<span class="hljs-string">"onMessage"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">rabbit:listener</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"h3_Service"</span> <span class="hljs-attr">queues</span>=<span class="hljs-string">"h3_queue"</span></span><span class="hljs-tag">                         <span class="hljs-attr">method</span>=<span class="hljs-string">"onMessage"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">rabbit:listener</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"allTopicService"</span> <span class="hljs-attr">queues</span>=<span class="hljs-string">"all_queue"</span></span><span class="hljs-tag">                         <span class="hljs-attr">method</span>=<span class="hljs-string">"onMessage"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">rabbit:listener</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"allKafkaTopicService"</span> <span class="hljs-attr">queues</span>=<span class="hljs-string">"all_kafka_queue"</span></span><span class="hljs-tag">                         <span class="hljs-attr">method</span>=<span class="hljs-string">"onMessage"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">rabbit:listener</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"kingKafkaTopicService"</span> <span class="hljs-attr">queues</span>=<span class="hljs-string">"king_kafka_queue"</span></span><span class="hljs-tag">                         <span class="hljs-attr">method</span>=<span class="hljs-string">"onMessage"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">rabbit:listener</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"kingAllTopicService"</span> <span class="hljs-attr">queues</span>=<span class="hljs-string">"king_all_queue"</span></span><span class="hljs-tag">                         <span class="hljs-attr">method</span>=<span class="hljs-string">"onMessage"</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">rabbit:listener-container</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><p>其他消费者代码与此相同，不再赘述。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">H2_Service</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MessageListener</span></span>&#123;    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(H2_Service<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMessage</span><span class="hljs-params">(Message message)</span> </span>&#123;        logger.info(<span class="hljs-string">"Get message: "</span>+<span class="hljs-keyword">new</span> String( message.getBody()));    &#125;&#125;</code></pre><h3 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h3><h4 id="生产者的失败通知及发送者确认"><a href="#生产者的失败通知及发送者确认" class="headerlink" title="生产者的失败通知及发送者确认"></a>生产者的失败通知及发送者确认</h4><p>配置文件</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">rabbit:template</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"rabbitTemplate"</span> </span><span class="hljs-tag">   <span class="hljs-attr">connection-factory</span>=<span class="hljs-string">"rabbitConnectionFactory"</span></span><span class="hljs-tag">   <span class="hljs-attr">mandatory</span>=<span class="hljs-string">"true"</span></span><span class="hljs-tag">   <span class="hljs-attr">return-callback</span>=<span class="hljs-string">"sendReturnCallback"</span></span><span class="hljs-tag">   <span class="hljs-attr">confirm-callback</span>=<span class="hljs-string">"confirmCallback"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">rabbit:template</span>&gt;</span></code></pre><p>失败通知的回调</p><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SendReturnCallback</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RabbitTemplate</span>.<span class="hljs-title">ReturnCallback</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">returnedMessage</span><span class="hljs-params">(Message message, <span class="hljs-keyword">int</span> replyCode,</span></span><span class="hljs-function"><span class="hljs-params">                                String replyText, String exchange,</span></span><span class="hljs-function"><span class="hljs-params">                                String routingKey)</span> </span>&#123;        String msg = <span class="hljs-keyword">new</span> String(message.getBody());        System.out.println(<span class="hljs-string">"返回的replyText ："</span>+replyText);        System.out.println(<span class="hljs-string">"返回的exchange ："</span>+exchange);        System.out.println(<span class="hljs-string">"返回的routingKey ："</span>+routingKey);        System.out.println(<span class="hljs-string">"返回的message ："</span>+message);    &#125;&#125;</code></pre><p>发送者确认的回调</p><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConfirmCallback</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RabbitTemplate</span>.<span class="hljs-title">ConfirmCallback</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">confirm</span><span class="hljs-params">(CorrelationData correlationData,</span></span><span class="hljs-function"><span class="hljs-params">                        <span class="hljs-keyword">boolean</span> ack, String cause)</span> </span>&#123;        <span class="hljs-keyword">if</span>(ack)&#123;            System.out.println(<span class="hljs-string">"消息发送给mq成功"</span>);        &#125;<span class="hljs-keyword">else</span>&#123;            System.out.println(<span class="hljs-string">"消息发送给mq失败，原因："</span>+cause);        &#125;    &#125;&#125;</code></pre><h4 id="消费者手动确认"><a href="#消费者手动确认" class="headerlink" title="消费者手动确认"></a>消费者手动确认</h4><p>配置文件</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 设置acknowledge属性 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">rabbit:listener-container</span> <span class="hljs-attr">connection-factory</span>=<span class="hljs-string">"rabbitConnectionFactory"</span></span><span class="hljs-tag">        <span class="hljs-attr">acknowledge</span>=<span class="hljs-string">"manual"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">rabbit:listener</span> <span class="hljs-attr">queues</span>=<span class="hljs-string">"depot_queue"</span></span><span class="hljs-tag">            <span class="hljs-attr">ref</span>=<span class="hljs-string">"processDepot"</span></span><span class="hljs-tag">            <span class="hljs-attr">method</span>=<span class="hljs-string">"onMessage"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">rabbit:listener-container</span>&gt;</span></code></pre><p>代码，注意此时的接口为ChannelAwareMessageListener</p><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProcessDepot</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ChannelAwareMessageListener</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Logger logger = LoggerFactory.getLogger(ProcessDepot<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> DepotManager depotManager;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Gson gson = <span class="hljs-keyword">new</span> Gson();    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMessage</span><span class="hljs-params">(Message message, Channel channel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">try</span> &#123;            String msg = <span class="hljs-keyword">new</span> String(message.getBody());            logger.info(<span class="hljs-string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;接收到消息:"</span>+msg);            GoodTransferVo goodTransferVo = gson.fromJson(msg,GoodTransferVo<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;            <span class="hljs-keyword">try</span> &#123;                depotManager.operDepot(goodTransferVo);                channel.basicAck(message.getMessageProperties().getDeliveryTag(),                        <span class="hljs-keyword">false</span>);                logger.info(<span class="hljs-string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;库存处理完成，应答Mq服务"</span>);            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                logger.error(e.getMessage());                channel.basicNack(message.getMessageProperties().getDeliveryTag(),                        <span class="hljs-keyword">false</span>,<span class="hljs-keyword">true</span>);                logger.info(<span class="hljs-string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;库存处理失败，拒绝消息，要求Mq重新派发"</span>);                <span class="hljs-keyword">throw</span> e;            &#125;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            logger.error(e.getMessage());        &#125;    &#125;&#125;</code></pre><h4 id="消费者预取模式"><a href="#消费者预取模式" class="headerlink" title="消费者预取模式"></a>消费者预取模式</h4><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- prefetch表示预取的数量 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">rabbit:listener-container</span> <span class="hljs-attr">connection-factory</span>=<span class="hljs-string">"rabbitConnectionFactory"</span></span><span class="hljs-tag">        <span class="hljs-attr">acknowledge</span>=<span class="hljs-string">"manual"</span> <span class="hljs-attr">prefetch</span>=<span class="hljs-string">"150"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">rabbit:listener</span> <span class="hljs-attr">queues</span>=<span class="hljs-string">"depot_queue"</span></span><span class="hljs-tag">            <span class="hljs-attr">ref</span>=<span class="hljs-string">"processDepot"</span></span><span class="hljs-tag">            <span class="hljs-attr">method</span>=<span class="hljs-string">"onMessage"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">rabbit:listener-container</span>&gt;</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>消息中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>消息中间件</tag>
      
      <tag>RabbitMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ的高级特性</title>
    <link href="/blog/2020/05/09/RabbitMQ%E7%9A%84%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"/>
    <url>/blog/2020/05/09/RabbitMQ%E7%9A%84%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="消息的拒绝"><a href="#消息的拒绝" class="headerlink" title="消息的拒绝"></a>消息的拒绝</h2><h3 id="Reject和Nack"><a href="#Reject和Nack" class="headerlink" title="Reject和Nack"></a>Reject和Nack</h3><img src="/blog/2020/05/09/RabbitMQ%E7%9A%84%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/pic1.png" srcset="/blog/img/loading.gif" class><p>RabbitMQ也提供了消息拒绝的机制，用于当本消费者无法进行消息的处理时，丢弃消息或让其他的消费者进行处理。消息的拒绝共有两种机制：</p><ul><li>Reject：Reject一次只能拒绝一条消息，在拒绝消息时可以使用requeue标识告诉RabbitMQ是否需要重新发送给别的消费者。如果是false则不重新发送，这个消息就会被RabbitMQ丢弃，如果是true则进行重新投递。</li><li>Nack：跟Reject类似，但可以一次性拒绝多个消息。也可以使用requeue标识，这是RabbitMQ对AMQP规范的一个扩展。</li></ul><h3 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RejectRequeuConsumer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] argv)</span></span><span class="hljs-function">            <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;        ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();        factory.setHost(<span class="hljs-string">"127.0.0.1"</span>);        Connection connection = factory.newConnection();        <span class="hljs-keyword">final</span> Channel channel = connection.createChannel();        channel.exchangeDeclare(DirectProducer.EXCHANGE_NAME,                <span class="hljs-string">"direct"</span>);        String queueName = <span class="hljs-string">"rejectrequeue"</span>;        channel.queueDeclare(queueName, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>,                <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);        String routekey = <span class="hljs-string">"error"</span>;        channel.queueBind(queueName, DirectProducer.EXCHANGE_NAME, routekey);        System.out.println(<span class="hljs-string">"waiting for message........"</span>);        <span class="hljs-keyword">final</span> Consumer consumer = <span class="hljs-keyword">new</span> DefaultConsumer(channel) &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag,</span></span><span class="hljs-function"><span class="hljs-params">                                       Envelope envelope,</span></span><span class="hljs-function"><span class="hljs-params">                                       AMQP.BasicProperties properties,</span></span><span class="hljs-function"><span class="hljs-params">                                       <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;                <span class="hljs-keyword">try</span> &#123;                    String message = <span class="hljs-keyword">new</span> String(body, <span class="hljs-string">"UTF-8"</span>);                    System.out.println(<span class="hljs-string">"Received["</span>                            + envelope.getRoutingKey()                            + <span class="hljs-string">"]"</span> + message);                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"处理异常"</span> + message);                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                    e.printStackTrace();                    <span class="hljs-comment">//Reject方式拒绝(第2个参数决定是否重新投递)</span>                    channel.basicReject(envelope.getDeliveryTag(),<span class="hljs-keyword">true</span>);                    <span class="hljs-comment">//Nack方式的拒绝（第2个参数决定是否批量，第3个参数决定是否重新投递）</span>                    <span class="hljs-comment">//channel.basicNack(envelope.getDeliveryTag(), false, false);</span>                &#125;            &#125;        &#125;;        channel.basicConsume(queueName, <span class="hljs-keyword">false</span>, consumer);    &#125;&#125;</code></pre><h2 id="死信交换器DLX"><a href="#死信交换器DLX" class="headerlink" title="死信交换器DLX"></a>死信交换器DLX</h2><p>前面我们看到，如果使用消息拒绝机制，同时requeue参数设置为false时，消息就会丢失。RabbitMQ作为一个高级消息中间件，提出了死信交换器的概念来应对这种情况，这种交换器专门处理被丢弃的信息（被拒绝后进行重新投递的信息不属于私信）。死信交换器是RabbitMQ对AMQP规范的一个扩展，通常用在对问题消息的诊断上（主要针对消费者），还有延时队列的功能。消息变成死信一般是以下三种情况:</p><ul><li>消息被拒绝，并且设置requeue参数为false</li><li>消息过期（默认情况下Rabbit中的消息不过期，但是可以设置队列的过期时间和消息的过期时间以达到消息过期的效果）</li><li>队列达到最大长度（一般当设置了最大队列长度或大小并达到最大值时）</li></ul><p>死信交换器仍然只是一个普通的交换器，创建时并没有特别要求和操作。在创建队列的时候，声明该交换器将用作保存被拒绝的消息即可，相关的参数是x-dead-letter-exchange。</p><img src="/blog/2020/05/09/RabbitMQ%E7%9A%84%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/pic2.png" srcset="/blog/img/loading.gif" class><h3 id="和备用交换器的区别"><a href="#和备用交换器的区别" class="headerlink" title="和备用交换器的区别"></a>和备用交换器的区别</h3><ol><li><p>备用交换器是主交换器无法路由消息，那么消息将被路由到这个新的备用交换器，而死信交换器则是接收过期或者被拒绝的消息。</p></li><li><p>备用交换器是在声明主交换器时绑定至交换器，而死信交换器则声明队列时绑定至队列。</p></li></ol><p>场景分析：备用交换器一般是用于生产者生产消息时，确保消息可以尽量进入RabbitMQ，而死信交换器主要是用于消费消息时确保消息尽量被消费（比如消息过期，队列满了，消息拒绝且不重新投递）。</p><h3 id="具体使用-1"><a href="#具体使用-1" class="headerlink" title="具体使用"></a>具体使用</h3><p>普通消费者</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WillMakeDlxConsumer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] argv)</span></span><span class="hljs-function">            <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;        ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();        factory.setHost(<span class="hljs-string">"127.0.0.1"</span>);        Connection connection = factory.newConnection();        <span class="hljs-keyword">final</span> Channel channel = connection.createChannel();        channel.exchangeDeclare(DlxProducer.EXCHANGE_NAME,                BuiltinExchangeType.TOPIC);        <span class="hljs-comment">//将队列绑定死信交换器</span>        String queueName = <span class="hljs-string">"dlx_make"</span>;        Map&lt;String,Object&gt; args = <span class="hljs-keyword">new</span> HashMap&lt;String,Object&gt;();        args.put(<span class="hljs-string">"x-dead-letter-exchange"</span>, DlxProcessConsumer.DLX_EXCHANGE_NAME);        channel.queueDeclare(queueName,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">true</span>,                <span class="hljs-keyword">false</span>,                args);        channel.queueBind(queueName,                DlxProducer.EXCHANGE_NAME,<span class="hljs-string">"#"</span>);        System.out.println(<span class="hljs-string">"waiting for message........"</span>);        <span class="hljs-keyword">final</span> Consumer consumer = <span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag,</span></span><span class="hljs-function"><span class="hljs-params">                                       Envelope envelope,</span></span><span class="hljs-function"><span class="hljs-params">                                       AMQP.BasicProperties properties,</span></span><span class="hljs-function"><span class="hljs-params">                                       <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;                String message = <span class="hljs-keyword">new</span> String(body, <span class="hljs-string">"UTF-8"</span>);                <span class="hljs-comment">//TODO</span>                <span class="hljs-comment">//如果是test1的消息确认</span>                <span class="hljs-keyword">if</span>(envelope.getRoutingKey().equals(<span class="hljs-string">"test1"</span>))&#123;                    System.out.println(<span class="hljs-string">"Received["</span>                            +envelope.getRoutingKey()                            +<span class="hljs-string">"]"</span>+message);                    channel.basicAck(envelope.getDeliveryTag(),                            <span class="hljs-keyword">false</span>);                &#125;<span class="hljs-keyword">else</span>&#123;                    <span class="hljs-comment">//如果是其他的消息拒绝（queue=false），成为死信消息</span>                    System.out.println(<span class="hljs-string">"Will reject["</span>                            +envelope.getRoutingKey()                            +<span class="hljs-string">"]"</span>+message);                    channel.basicReject(envelope.getDeliveryTag(),                            <span class="hljs-keyword">false</span>);                &#125;            &#125;        &#125;;        channel.basicConsume(queueName,<span class="hljs-keyword">false</span>,consumer);    &#125;&#125;</code></pre><p>死信消费者</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DlxProcessConsumer</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String DLX_EXCHANGE_NAME = <span class="hljs-string">"dlx_accept"</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] argv)</span></span><span class="hljs-function">            <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;        ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();        factory.setHost(<span class="hljs-string">"127.0.0.1"</span>);        Connection connection = factory.newConnection();        <span class="hljs-keyword">final</span> Channel channel = connection.createChannel();        <span class="hljs-comment">//声明死信交换器</span>        channel.exchangeDeclare(DLX_EXCHANGE_NAME,                BuiltinExchangeType.TOPIC);        String queueName = <span class="hljs-string">"dlx_accept"</span>;        channel.queueDeclare(queueName,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>,                <span class="hljs-keyword">false</span>,<span class="hljs-keyword">null</span>);        channel.queueBind(queueName,                DLX_EXCHANGE_NAME,<span class="hljs-string">"#"</span>);        System.out.println(<span class="hljs-string">"waiting for message........"</span>);        <span class="hljs-keyword">final</span> Consumer consumer = <span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag,</span></span><span class="hljs-function"><span class="hljs-params">                                       Envelope envelope,</span></span><span class="hljs-function"><span class="hljs-params">                                       AMQP.BasicProperties properties,</span></span><span class="hljs-function"><span class="hljs-params">                                       <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;                String message = <span class="hljs-keyword">new</span> String(body, <span class="hljs-string">"UTF-8"</span>);                System.out.println(<span class="hljs-string">"Received dead letter["</span>                        +envelope.getRoutingKey()                        +<span class="hljs-string">"]"</span>+message);            &#125;        &#125;;        channel.basicConsume(queueName,<span class="hljs-keyword">true</span>,consumer);    &#125;&#125;</code></pre><h2 id="队列的类型"><a href="#队列的类型" class="headerlink" title="队列的类型"></a>队列的类型</h2><p>在使用queueDeclare()方法声明队列时，可以通过设置相应的参数，来控制声明的队列类型。</p><pre><code class="hljs java">Queue.<span class="hljs-function">DeclareOk <span class="hljs-title">queueDeclare</span><span class="hljs-params">(String queue, <span class="hljs-keyword">boolean</span> durable, <span class="hljs-keyword">boolean</span> exclusive, <span class="hljs-keyword">boolean</span> autoDelete,Map&lt;String, Object&gt; arguments)</span></span>;</code></pre><ul><li>queue：队列名</li><li>durable：是否为持久化队列</li><li>exclusive：是否为单消费者队列</li><li>autoDelete：是否为自动删除队列</li></ul><h3 id="持久化队列"><a href="#持久化队列" class="headerlink" title="持久化队列"></a>持久化队列</h3><p>持久化队列和非持久化队列的区别是，持久化队列会被保存在磁盘中，固定并持久的存储，当Rabbit服务重启后，该队列会保持原来的状态在RabbitMQ中被管理，而非持久化队列不会被保存在磁盘中，Rabbit服务重启后队列就会消失。</p><p>由于非持久化不需要保存在磁盘中，所以使用速度就比持久化队列快。而持久化的优点就是会一直存在，不会随服务的重启或服务器的宕机而消失。</p><p>在声明队列时，将属性durable设置为“false”，则该队列为非持久化队列，设置成“true”时，该队列就为持久化队列</p><h3 id="自动删除队列"><a href="#自动删除队列" class="headerlink" title="自动删除队列"></a>自动删除队列</h3><p>自动删除队列和普通队列在使用上没有什么区别，唯一的区别是当消费者断开连接时队列将会被删除。自动删除队列允许的消费者没有限制， 也就是说当这个队列上最后一个消费者断开连接才会执行删除。</p><p>自动删除队列只需要在声明队列时，设置属性auto-delete标识为true即可。系统声明的随机队列，就是自动删除队列。</p><h3 id="单消费者队列"><a href="#单消费者队列" class="headerlink" title="单消费者队列"></a>单消费者队列</h3><p>普通队列允许的消费者没有限制，当队列绑定多个消费者时，RabbitMQ会采用轮询的方式进行投递。如果需要消费者独占队列，可以在队列创建的时候设定属性exclusive为true。</p><h3 id="队列的保留参数"><a href="#队列的保留参数" class="headerlink" title="队列的保留参数"></a>队列的保留参数</h3><table><thead><tr><th>参数名</th><th>作用</th></tr></thead><tbody><tr><td>x-dead-letter-exchange</td><td>死信交换器</td></tr><tr><td>x-dead-letter-routing-key</td><td>死信消息的可选路由键</td></tr><tr><td>x-expires</td><td>队列在指定毫秒数后被删除</td></tr><tr><td>x-ha-policy</td><td>创建HA队列</td></tr><tr><td>x-ha-nodes</td><td>HA队列的分布节点</td></tr><tr><td>x-max-length</td><td>队列的最大消息数</td></tr><tr><td>x-message-ttl</td><td>毫秒为单位的消息过期时间，队列级别</td></tr><tr><td>x-max-priority</td><td>最大优先值为255的队列优先排序功能</td></tr></tbody></table><h2 id="消息的属性"><a href="#消息的属性" class="headerlink" title="消息的属性"></a>消息的属性</h2><p>消息的构成：</p>{% asset_img pic6.png %}<p>消息头中的属性：</p><table><thead><tr><th><strong>属性名</strong></th><th><strong>用处</strong></th></tr></thead><tbody><tr><td>content-type</td><td>消息体的MIME类型，如application/json</td></tr><tr><td>content-encoding</td><td>消息的编码类型，如是否压缩</td></tr><tr><td>message-id</td><td>消息的唯一性标识，由应用进行设置</td></tr><tr><td>correlation-id</td><td>一般用做关联消息的message-id，常用于消息的响应</td></tr><tr><td>timestamp</td><td>消息的创建时刻，整形，精确到秒</td></tr><tr><td>expiration</td><td>消息的过期时刻， 字符串，但是呈现格式为整型，精确到秒</td></tr><tr><td>delivery-mode</td><td>消息的持久化类型，1为非持久化，2为持久化，性能影响巨大</td></tr><tr><td>app-id</td><td>应用程序的类型和版本号</td></tr><tr><td>user-id</td><td>标识已登录用户，极少使用</td></tr><tr><td>type</td><td>消息类型名称，完全由应用决定如何使用该字段</td></tr><tr><td>reply-to</td><td>构建回复消息的私有响应队列</td></tr><tr><td>headers</td><td>键/值对表，用户自定义任意的键和值</td></tr><tr><td>priority</td><td>指定队列中消息的优先级</td></tr></tbody></table><p>在发送消息时，我们还可以对消息的属性做更细微的控制，比如构建 Request-Response 模式，</p><p>使用方式</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReplyToProducer</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String EXCHANGE_NAME = <span class="hljs-string">"replyto"</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><span class="hljs-function">            <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;        ConnectionFactory connectionFactory = <span class="hljs-keyword">new</span> ConnectionFactory();        connectionFactory.setHost(<span class="hljs-string">"127.0.0.1"</span>);        Connection connection = connectionFactory.newConnection();        Channel channel = connection.createChannel();        channel.exchangeDeclare(EXCHANGE_NAME,<span class="hljs-string">"direct"</span>,<span class="hljs-keyword">false</span>);        String msgId = UUID.randomUUID().toString();        AMQP.BasicProperties properties = <span class="hljs-keyword">new</span> AMQP.BasicProperties.Builder()                .messageId(msgId)                .build();        <span class="hljs-keyword">final</span> Consumer consumer = <span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag,</span></span><span class="hljs-function"><span class="hljs-params">                                       Envelope envelope,</span></span><span class="hljs-function"><span class="hljs-params">                                       AMQP.BasicProperties properties,</span></span><span class="hljs-function"><span class="hljs-params">                                       <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;                String message = <span class="hljs-keyword">new</span> String(body, <span class="hljs-string">"UTF-8"</span>);                System.out.println(<span class="hljs-string">"Received["</span>+envelope.getRoutingKey()                        +<span class="hljs-string">"]"</span>+message);            &#125;        &#125;;        channel.basicConsume(responseQueue,<span class="hljs-keyword">true</span>,consumer);        String msg = <span class="hljs-string">"Hellol,RabbitMq"</span>;        <span class="hljs-comment">//添加创建的properties</span>        channel.basicPublish(EXCHANGE_NAME,<span class="hljs-string">"error"</span>,                properties,                msg.getBytes());        System.out.println(<span class="hljs-string">"Sent error:"</span>+msg);    &#125;&#125;</code></pre><h3 id="消息存活时间"><a href="#消息存活时间" class="headerlink" title="消息存活时间"></a>消息存活时间</h3><p>当队列消息的TTL和消息TTL都被设置，时间短的TTL设置生效。如果将一个过期消息发送给 RabbitMQ，该消息不会路由到任何队列，而是直接丢弃。</p><p>RabbitMQ只判断处于队头的消息是否过期，不会扫描队列，所以很可能队列中已存在过期消息，但是队列并不知情。这会影响队列统计数据的正确性，妨碍队列及时释放资源。</p><h3 id="消息的持久化"><a href="#消息的持久化" class="headerlink" title="消息的持久化"></a>消息的持久化</h3><p>默认情况下，队列和交换器在服务器重启后都会消失，消息当然也是。如果要使消息持久化，需要将将队列和交换器的durable属性设为true，还需要在消息发布前，将投递模式设置为2。</p><h3 id="应用程序的类型和版本号"><a href="#应用程序的类型和版本号" class="headerlink" title="应用程序的类型和版本号"></a>应用程序的类型和版本号</h3><img src="/blog/2020/05/09/RabbitMQ%E7%9A%84%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/pic4.png" srcset="/blog/img/loading.gif" class><p>如果生产者进行了迭代，消息内容、处理方式都发生了变化，而且之前的生产者跟消费者的处理逻辑还要继续使用，这时就可以通过设置消息的版本号来区分这两种消息。</p><h3 id="Request-Response模式"><a href="#Request-Response模式" class="headerlink" title="Request-Response模式"></a>Request-Response模式</h3><p>前面的例子中都是一方负责发送消息而另外一方负责处理，实际应用中上也需要请求-应答的这种通信方式，即双方都能给对方发送消息，也能接收到对方的消息。</p><img src="/blog/2020/05/09/RabbitMQ%E7%9A%84%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/pic5.png" srcset="/blog/img/loading.gif" class><p>生产者</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReplyToProducer</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String EXCHANGE_NAME = <span class="hljs-string">"replyto"</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><span class="hljs-function">            <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;        ConnectionFactory connectionFactory = <span class="hljs-keyword">new</span> ConnectionFactory();        connectionFactory.setHost(<span class="hljs-string">"127.0.0.1"</span>);        Connection connection = connectionFactory.newConnection();        Channel channel = connection.createChannel();        channel.exchangeDeclare(EXCHANGE_NAME,<span class="hljs-string">"direct"</span>,<span class="hljs-keyword">false</span>);        <span class="hljs-comment">//声明响应队列，消费者将会把要返回的信息发送到该队列</span>        String responseQueue = channel.queueDeclare().getQueue();        <span class="hljs-comment">//设置消息的唯一id</span>        String msgId = UUID.randomUUID().toString();        <span class="hljs-comment">//设置消息的响应队列</span>        AMQP.BasicProperties properties = <span class="hljs-keyword">new</span> AMQP.BasicProperties.Builder()                .replyTo(responseQueue)                .messageId(msgId)                .build();        <span class="hljs-comment">//绑定响应队列消费者</span>        <span class="hljs-keyword">final</span> Consumer consumer = <span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag,</span></span><span class="hljs-function"><span class="hljs-params">                                       Envelope envelope,</span></span><span class="hljs-function"><span class="hljs-params">                                       AMQP.BasicProperties properties,</span></span><span class="hljs-function"><span class="hljs-params">                                       <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;                String message = <span class="hljs-keyword">new</span> String(body, <span class="hljs-string">"UTF-8"</span>);                System.out.println(<span class="hljs-string">"Received["</span>+envelope.getRoutingKey()                        +<span class="hljs-string">"]"</span>+message);            &#125;        &#125;;        channel.basicConsume(responseQueue,<span class="hljs-keyword">true</span>,consumer);        String msg = <span class="hljs-string">"Hellol,RabbitMq"</span>;        channel.basicPublish(EXCHANGE_NAME,<span class="hljs-string">"test"</span>,                properties,                msg.getBytes());        System.out.println(<span class="hljs-string">"Sent error:"</span>+msg);    &#125;&#125;</code></pre><p>消费者</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReplyToConsumer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] argv)</span></span><span class="hljs-function">            <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;        ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();        factory.setHost(<span class="hljs-string">"127.0.0.1"</span>);        Connection connection = factory.newConnection();        <span class="hljs-keyword">final</span> Channel channel = connection.createChannel();        channel.exchangeDeclare(ReplyToProducer.EXCHANGE_NAME,                <span class="hljs-string">"direct"</span>, <span class="hljs-keyword">false</span>);        String queueName = <span class="hljs-string">"queue"</span>;        channel.queueDeclare(queueName, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>,                <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);        String routekey = <span class="hljs-string">"test"</span>;        channel.queueBind(queueName, ReplyToProducer.EXCHANGE_NAME, routekey);        System.out.println(<span class="hljs-string">"waiting for message........"</span>);        <span class="hljs-keyword">final</span> Consumer consumer = <span class="hljs-keyword">new</span> DefaultConsumer(channel) &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag,</span></span><span class="hljs-function"><span class="hljs-params">                                       Envelope envelope,</span></span><span class="hljs-function"><span class="hljs-params">                                       AMQP.BasicProperties properties,</span></span><span class="hljs-function"><span class="hljs-params">                                       <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;                String message = <span class="hljs-keyword">new</span> String(body, <span class="hljs-string">"UTF-8"</span>);                System.out.println(<span class="hljs-string">"Received["</span> + envelope.getRoutingKey()                        + <span class="hljs-string">"]"</span> + message);                <span class="hljs-comment">//设置响应队列及绑定的messageId</span>                AMQP.BasicProperties respProp                        = <span class="hljs-keyword">new</span> AMQP.BasicProperties.Builder()                        .replyTo(properties.getReplyTo())                        .correlationId(properties.getMessageId())                        .build();                System.out.println(<span class="hljs-string">"Sent["</span> + properties.getReplyTo() + <span class="hljs-string">"]"</span>);                channel.basicPublish(<span class="hljs-string">""</span>, respProp.getReplyTo(),                        respProp,                        (<span class="hljs-string">"Hi,"</span> + message).getBytes(<span class="hljs-string">"UTF-8"</span>));            &#125;        &#125;;        channel.basicConsume(queueName, <span class="hljs-keyword">true</span>, consumer);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>消息中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>消息中间件</tag>
      
      <tag>RabbitMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ中消息发布与权衡</title>
    <link href="/blog/2020/05/08/RabbitMQ%E4%B8%AD%E6%B6%88%E6%81%AF%E5%8F%91%E5%B8%83%E4%B8%8E%E6%9D%83%E8%A1%A1/"/>
    <url>/blog/2020/05/08/RabbitMQ%E4%B8%AD%E6%B6%88%E6%81%AF%E5%8F%91%E5%B8%83%E4%B8%8E%E6%9D%83%E8%A1%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="使用Java客户端进行消息通信"><a href="#使用Java客户端进行消息通信" class="headerlink" title="使用Java客户端进行消息通信"></a>使用Java客户端进行消息通信</h2><p>客户端需要amqp-client-5.0.0.jar和slf4j-api-1.6.1.jar</p><p>建议使用Maven：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.rabbitmq<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>amqp-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>注意：5系列的版本最好使用JDK8及以上， 低于JDK8可以使用4.x(具体的版本号到Maven的中央仓库查)的版本。</p><h3 id="Direct交换器"><a href="#Direct交换器" class="headerlink" title="Direct交换器"></a>Direct交换器</h3><img src="/blog/2020/05/08/RabbitMQ%E4%B8%AD%E6%B6%88%E6%81%AF%E5%8F%91%E5%B8%83%E4%B8%8E%E6%9D%83%E8%A1%A1/pic3.png" srcset="/blog/img/loading.gif" class><h4 id="生产者和消费者的一般用法"><a href="#生产者和消费者的一般用法" class="headerlink" title="生产者和消费者的一般用法"></a>生产者和消费者的一般用法</h4><p>创建消息生产者</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DirectProducer</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 交换器名称</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String EXCHANGE_NAME = <span class="hljs-string">"direct_logs"</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 路由键</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String[] ROUTE_KEYS =&#123;<span class="hljs-string">"route_key_1"</span>,<span class="hljs-string">"route_key_2"</span>,<span class="hljs-string">"route_key_3"</span>&#125;;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><span class="hljs-function">            <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;        <span class="hljs-comment">//创建连接、连接到RabbitMQ</span>        ConnectionFactory connectionFactory= <span class="hljs-keyword">new</span> ConnectionFactory();        <span class="hljs-comment">//设置下连接工厂的连接地址(使用默认端口5672)</span>        connectionFactory.setHost(<span class="hljs-string">"localhost"</span>);        <span class="hljs-comment">//创建连接</span>        Connection connection =connectionFactory.newConnection();        <span class="hljs-comment">//创建信道</span>        Channel channel =connection.createChannel();        <span class="hljs-comment">//在信道中设置交换器</span>        channel.exchangeDeclare(EXCHANGE_NAME,BuiltinExchangeType.DIRECT);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">6</span>;i++)&#123;            String routeKey = ROUTE_KEYS[i%<span class="hljs-number">3</span>];            String msg = <span class="hljs-string">"Hello,RabbitMQ"</span>+(i+<span class="hljs-number">1</span>);            <span class="hljs-comment">//发布消息</span>            channel.basicPublish(EXCHANGE_NAME,routeKey,<span class="hljs-keyword">null</span>,msg.getBytes());            System.out.println(<span class="hljs-string">"Sent:"</span>+routeKey+<span class="hljs-string">":"</span>+msg);        &#125;        channel.close();        connection.close();    &#125;&#125;</code></pre><p>创建消费者</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NormalConsumer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] argv)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;        <span class="hljs-comment">//创建连接、连接到RabbitMQ</span>        ConnectionFactory connectionFactory = <span class="hljs-keyword">new</span> ConnectionFactory();        <span class="hljs-comment">//设置下连接工厂的连接地址(使用默认端口5672)</span>        connectionFactory.setHost(<span class="hljs-string">"localhost"</span>);        <span class="hljs-comment">//创建连接</span>        Connection connection = connectionFactory.newConnection();        <span class="hljs-comment">//创建信道</span>        Channel channel = connection.createChannel();        <span class="hljs-comment">//在信道中设置交换器</span>        channel.exchangeDeclare(DirectProducer.EXCHANGE_NAME, BuiltinExchangeType.DIRECT);        <span class="hljs-comment">//申明队列</span>        String queueName = <span class="hljs-string">"queue_1"</span>;        channel.queueDeclare(queueName, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);        <span class="hljs-comment">//绑定：将队列与交换器通过路由键绑定</span>        String routeKey = DirectProducer.ROUTE_KEYS[<span class="hljs-number">0</span>];        channel.queueBind(queueName, DirectProducer.EXCHANGE_NAME, routeKey);        System.out.println(<span class="hljs-string">"waiting for message ......"</span>);        <span class="hljs-comment">//申明一个消费者</span>        <span class="hljs-keyword">final</span> Consumer consumer = <span class="hljs-keyword">new</span> DefaultConsumer(channel) &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String s, Envelope envelope, AMQP.BasicProperties basicProperties, <span class="hljs-keyword">byte</span>[] bytes)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;                String message = <span class="hljs-keyword">new</span> String(bytes, <span class="hljs-string">"UTF-8"</span>);                System.out.println(<span class="hljs-string">"Received["</span> + envelope.getRoutingKey() + <span class="hljs-string">"]"</span> + message);            &#125;        &#125;;        <span class="hljs-comment">//消息者正式开始在指定队列上消费。</span>        <span class="hljs-comment">//第二个参数是自动确认参数，如果是true则是自动确认</span>        channel.basicConsume(queueName, <span class="hljs-keyword">true</span>, consumer);    &#125;&#125;</code></pre><p>通过测试发现，使用DirectProducer作为生产者，NormalConsumer作为消费者，消费者绑定一个队列，时只接收该队列绑定的路由键的消息。</p><h4 id="队列和交换器的多重绑定"><a href="#队列和交换器的多重绑定" class="headerlink" title="队列和交换器的多重绑定"></a>队列和交换器的多重绑定</h4><h5 id="一个队列绑定多个路由键"><a href="#一个队列绑定多个路由键" class="headerlink" title="一个队列绑定多个路由键"></a>一个队列绑定多个路由键</h5><p>这时队列可以接收到绑定的所有路由键的消息。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MultiBindConsumer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] argv)</span> <span class="hljs-keyword">throws</span> IOException,</span><span class="hljs-function">            InterruptedException, TimeoutException </span>&#123;        <span class="hljs-comment">//连接工厂</span>        ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();        <span class="hljs-comment">//连接rabbitMq的地址</span>        factory.setHost(<span class="hljs-string">"127.0.0.1"</span>);        <span class="hljs-comment">// 打开连接和创建频道，与发送端一样</span>        Connection connection = factory.newConnection();        <span class="hljs-comment">//创建一个信道</span>        <span class="hljs-keyword">final</span> Channel channel = connection.createChannel();        <span class="hljs-comment">//在信道中设置交换器</span>        channel.exchangeDeclare(DirectProducer.EXCHANGE_NAME, BuiltinExchangeType.DIRECT);        <span class="hljs-comment">//声明一个随机队列</span>        String queueName = channel.queueDeclare().getQueue();        <span class="hljs-comment">//队列绑定到交换器上时，是允许绑定多个路由键的，也就是多重绑定</span>        <span class="hljs-keyword">for</span> (String routekey : DirectProducer.ROUTE_KEYS) &#123;            channel.queueBind(queueName, DirectProducer.EXCHANGE_NAME, routekey);        &#125;        System.out.println(<span class="hljs-string">" [*] Waiting for messages:"</span>);        <span class="hljs-comment">// 创建队列消费者</span>        <span class="hljs-keyword">final</span> Consumer consumerA = <span class="hljs-keyword">new</span> DefaultConsumer(channel) &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag,</span></span><span class="hljs-function"><span class="hljs-params">                                       Envelope envelope,</span></span><span class="hljs-function"><span class="hljs-params">                                       AMQP.BasicProperties</span></span><span class="hljs-function"><span class="hljs-params">                                               properties,</span></span><span class="hljs-function"><span class="hljs-params">                                       <span class="hljs-keyword">byte</span>[] body)</span></span><span class="hljs-function">                    <span class="hljs-keyword">throws</span> IOException </span>&#123;                String message = <span class="hljs-keyword">new</span> String(body, <span class="hljs-string">"UTF-8"</span>);                System.out.println(<span class="hljs-string">" Received "</span>                        + envelope.getRoutingKey() + <span class="hljs-string">":'"</span> + message                        + <span class="hljs-string">"'"</span>);            &#125;        &#125;;        channel.basicConsume(queueName, <span class="hljs-keyword">true</span>, consumerA);    &#125;&#125;</code></pre><h5 id="一个连接多个信道"><a href="#一个连接多个信道" class="headerlink" title="一个连接多个信道"></a>一个连接多个信道</h5><p>实现方法为使用多线程创建信道，然后生成随机的队列并绑定到信道。这时所有队列都可以接收到全部的消息。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MultiChannelConsumer</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsumerWorker</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;        <span class="hljs-keyword">final</span> Connection connection;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConsumerWorker</span><span class="hljs-params">(Connection connection)</span> </span>&#123;            <span class="hljs-keyword">this</span>.connection = connection;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">//创建一个信道，意味着每个线程单独一个信道</span>                Channel channel = connection.createChannel();                channel.exchangeDeclare(DirectProducer.EXCHANGE_NAME, BuiltinExchangeType.DIRECT);                <span class="hljs-comment">// 声明一个随机队列</span>                String queueName = channel.queueDeclare().getQueue();                <span class="hljs-comment">//消费者名字，打印输出用</span>                <span class="hljs-keyword">final</span> String consumerName = Thread.currentThread().getName() + <span class="hljs-string">"-all"</span>;                <span class="hljs-keyword">for</span> (String routekey : DirectProducer.ROUTE_KEYS) &#123;                    channel.queueBind(queueName, DirectProducer.EXCHANGE_NAME,                            routekey);                &#125;                System.out.println(<span class="hljs-string">"["</span> + consumerName + <span class="hljs-string">"] Waiting for messages:"</span>);                <span class="hljs-keyword">final</span> Consumer consumerA = <span class="hljs-keyword">new</span> DefaultConsumer(channel) &#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag,</span></span><span class="hljs-function"><span class="hljs-params">                                               Envelope envelope,</span></span><span class="hljs-function"><span class="hljs-params">                                               AMQP.BasicProperties</span></span><span class="hljs-function"><span class="hljs-params">                                                       properties,</span></span><span class="hljs-function"><span class="hljs-params">                                               <span class="hljs-keyword">byte</span>[] body)</span></span><span class="hljs-function">                            <span class="hljs-keyword">throws</span> IOException </span>&#123;                        String message =                                <span class="hljs-keyword">new</span> String(body, <span class="hljs-string">"UTF-8"</span>);                        System.out.println(consumerName                                + <span class="hljs-string">" Received "</span> + envelope.getRoutingKey()                                + <span class="hljs-string">":'"</span> + message + <span class="hljs-string">"'"</span>);                    &#125;                &#125;;                channel.basicConsume(queueName, <span class="hljs-keyword">true</span>, consumerA);            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] argv)</span> <span class="hljs-keyword">throws</span> TimeoutException, IOException </span>&#123;        ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();        factory.setHost(<span class="hljs-string">"localhost"</span>);        Connection connection = factory.newConnection();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;            <span class="hljs-comment">//将连接作为参数，传递给每个线程</span>            Thread worker = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> ConsumerWorker(connection));            worker.start();        &#125;    &#125;&#125;</code></pre><h5 id="一个队列多个消费者"><a href="#一个队列多个消费者" class="headerlink" title="一个队列多个消费者"></a>一个队列多个消费者</h5><p>也是利用多线程，只不过这是创建指定名称的队列，如果队列已存在不会重复绑定。这时会轮询将队列中的消息分发给消费者，所有消费者共享这个队列中的消息。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MultiConsumerOneQueue</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsumerWorker</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;        <span class="hljs-keyword">final</span> Connection connection;        <span class="hljs-keyword">final</span> String queueName;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConsumerWorker</span><span class="hljs-params">(Connection connection, String queueName)</span> </span>&#123;            <span class="hljs-keyword">this</span>.connection = connection;            <span class="hljs-keyword">this</span>.queueName = queueName;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-keyword">final</span> Channel channel = connection.createChannel();                channel.exchangeDeclare(DirectProducer.EXCHANGE_NAME, BuiltinExchangeType.DIRECT);                <span class="hljs-comment">//声明一个队列,rabbitmq，如果队列已存在，不会重复创建</span>                channel.queueDeclare(queueName, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);                <span class="hljs-keyword">final</span> String consumerName = Thread.currentThread().getName();                <span class="hljs-keyword">for</span> (String routekey : DirectProducer.ROUTE_KEYS) &#123;                    channel.queueBind(queueName, DirectProducer.EXCHANGE_NAME,                            routekey);                &#125;                System.out.println(<span class="hljs-string">" ["</span> + consumerName + <span class="hljs-string">"] Waiting for messages:"</span>);                <span class="hljs-keyword">final</span> Consumer consumerA = <span class="hljs-keyword">new</span> DefaultConsumer(channel) &#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag,</span></span><span class="hljs-function"><span class="hljs-params">                                               Envelope envelope,</span></span><span class="hljs-function"><span class="hljs-params">                                               AMQP.BasicProperties</span></span><span class="hljs-function"><span class="hljs-params">                                                       properties,</span></span><span class="hljs-function"><span class="hljs-params">                                               <span class="hljs-keyword">byte</span>[] body)</span></span><span class="hljs-function">                            <span class="hljs-keyword">throws</span> IOException </span>&#123;                        String message =                                <span class="hljs-keyword">new</span> String(body, <span class="hljs-string">"UTF-8"</span>);                        System.out.println(consumerName                                + <span class="hljs-string">" Received "</span> + envelope.getRoutingKey()                                + <span class="hljs-string">":'"</span> + message + <span class="hljs-string">"'"</span>);                    &#125;                &#125;;                channel.basicConsume(queueName, <span class="hljs-keyword">true</span>, consumerA);            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] argv)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;        ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();        factory.setHost(<span class="hljs-string">"127.0.0.1"</span>);        Connection connection = factory.newConnection();        String queueName = <span class="hljs-string">"focusAll"</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;            <span class="hljs-comment">//将连接及队列名作为参数，传递给每个线程</span>            Thread worker = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> ConsumerWorker(connection, queueName));            worker.start();        &#125;    &#125;&#125;</code></pre><h3 id="Fanout交换器"><a href="#Fanout交换器" class="headerlink" title="Fanout交换器"></a>Fanout交换器</h3><img src="/blog/2020/05/08/RabbitMQ%E4%B8%AD%E6%B6%88%E6%81%AF%E5%8F%91%E5%B8%83%E4%B8%8E%E6%9D%83%E8%A1%A1/pic2.png" srcset="/blog/img/loading.gif" class><p>创建生产者</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FanoutProducer</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String EXCHANGE_NAME = <span class="hljs-string">"fanout_logs"</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String[] ROUTE_KEYS = &#123;<span class="hljs-string">"route_key_1"</span>, <span class="hljs-string">"route_key_2"</span>, <span class="hljs-string">"route_key_3"</span>&#125;;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;        ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();        factory.setHost(<span class="hljs-string">"127.0.0.1"</span>);        Connection connection = factory.newConnection();        Channel channel = connection.createChannel();        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;            String routekey = ROUTE_KEYS[i % <span class="hljs-number">3</span>];            String message = <span class="hljs-string">"Hello World_"</span> + (i + <span class="hljs-number">1</span>);            channel.basicPublish(EXCHANGE_NAME, routekey,                    <span class="hljs-keyword">null</span>, message.getBytes());            System.out.println(<span class="hljs-string">" [x] Sent '"</span> + routekey + <span class="hljs-string">"':'"</span>                    + message + <span class="hljs-string">"'"</span>);        &#125;        channel.close();        connection.close();    &#125;&#125;</code></pre><p>创建消费者1，注意，此时消费者不受路由键的影响，就算不绑定生产者的路由键仍然可以接收到消息。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer1</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] argv)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;        ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();        factory.setHost(<span class="hljs-string">"127.0.0.1"</span>);        Connection connection = factory.newConnection();        <span class="hljs-keyword">final</span> Channel channel = connection.createChannel();        channel.exchangeDeclare(FanoutProducer.EXCHANGE_NAME,                BuiltinExchangeType.FANOUT);        String queueName = channel.queueDeclare().getQueue();        <span class="hljs-keyword">for</span> (String routekey : FanoutProducer.ROUTE_KEYS) &#123;            channel.queueBind(queueName, FanoutProducer.EXCHANGE_NAME,                    routekey);        &#125;        System.out.println(<span class="hljs-string">" ["</span> + queueName + <span class="hljs-string">"] Waiting for messages:"</span>);        <span class="hljs-keyword">final</span> Consumer consumerA = <span class="hljs-keyword">new</span> DefaultConsumer(channel) &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope,</span></span><span class="hljs-function"><span class="hljs-params">                                       AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span></span><span class="hljs-function">                    <span class="hljs-keyword">throws</span> IOException </span>&#123;                String message = <span class="hljs-keyword">new</span> String(body, <span class="hljs-string">"UTF-8"</span>);                System.out.println(<span class="hljs-string">"Received "</span> + envelope.getRoutingKey() + <span class="hljs-string">"':'"</span> + message + <span class="hljs-string">"'"</span>);            &#125;        &#125;;        channel.basicConsume(queueName, <span class="hljs-keyword">true</span>, consumerA);    &#125;&#125;</code></pre><p>消费者2，注意这时绑定的是一个不存在的路由键，广播交换器不会受路由键影响，此时消费者2仍然可以接收到所有消息。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer2</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] argv)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;        ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();        factory.setHost(<span class="hljs-string">"127.0.0.1"</span>);        Connection connection = factory.newConnection();        <span class="hljs-keyword">final</span> Channel channel = connection.createChannel();        channel.exchangeDeclare(FanoutProducer.EXCHANGE_NAME,                BuiltinExchangeType.FANOUT);        String queueName = channel.queueDeclare().getQueue();        <span class="hljs-comment">//设置一个不存在的路由键</span>        String routekey=<span class="hljs-string">"xxx"</span>;        channel.queueBind(queueName, FanoutProducer.EXCHANGE_NAME, routekey);        System.out.println(<span class="hljs-string">" [*] Waiting for messages......"</span>);        <span class="hljs-keyword">final</span> Consumer consumerB = <span class="hljs-keyword">new</span> DefaultConsumer(channel) &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag,</span></span><span class="hljs-function"><span class="hljs-params">                                       Envelope envelope,</span></span><span class="hljs-function"><span class="hljs-params">                                       AMQP.BasicProperties properties,</span></span><span class="hljs-function"><span class="hljs-params">                                       <span class="hljs-keyword">byte</span>[] body)</span></span><span class="hljs-function">                    <span class="hljs-keyword">throws</span> IOException </span>&#123;                String message = <span class="hljs-keyword">new</span> String(body, <span class="hljs-string">"UTF-8"</span>);                System.out.println( <span class="hljs-string">"Received ["</span>+ envelope.getRoutingKey()                        + <span class="hljs-string">"] "</span>+message);            &#125;        &#125;;        channel.basicConsume(queueName, <span class="hljs-keyword">true</span>, consumerB);    &#125;&#125;</code></pre><h3 id="Topic交换器"><a href="#Topic交换器" class="headerlink" title="Topic交换器"></a>Topic交换器</h3><img src="/blog/2020/05/08/RabbitMQ%E4%B8%AD%E6%B6%88%E6%81%AF%E5%8F%91%E5%B8%83%E4%B8%8E%E6%9D%83%E8%A1%A1/pic4.png" srcset="/blog/img/loading.gif" class><p>创建生产者</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TopicProducer</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String EXCHANGE_NAME = <span class="hljs-string">"topic_course"</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><span class="hljs-function">            <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;        ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();        factory.setHost(<span class="hljs-string">"127.0.0.1"</span>);        Connection connection = factory.newConnection();        Channel channel = connection.createChannel();        <span class="hljs-comment">//创建主题</span>        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);        String[] types = &#123;<span class="hljs-string">"TYPE_A"</span>, <span class="hljs-string">"TYPE_B"</span>, <span class="hljs-string">"TYPE_C"</span>&#125;;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;            String[] modules = &#123;<span class="hljs-string">"moduleA"</span>, <span class="hljs-string">"moduleB"</span>, <span class="hljs-string">"moduleC"</span>&#125;;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++) &#123;                String[] status = &#123;<span class="hljs-string">"0"</span>, <span class="hljs-string">"1"</span>, <span class="hljs-string">"2"</span>&#125;;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">3</span>; k++) &#123;                    <span class="hljs-comment">// 发送的消息</span>                    String message = <span class="hljs-string">"Hello Topic_["</span> + i + <span class="hljs-string">","</span> + j + <span class="hljs-string">","</span> + k + <span class="hljs-string">"]"</span>;                    String routeKey = types[i % <span class="hljs-number">3</span>] + <span class="hljs-string">"."</span> + modules[j % <span class="hljs-number">3</span>]                            + <span class="hljs-string">"."</span> + status[k % <span class="hljs-number">3</span>];                    channel.basicPublish(EXCHANGE_NAME, routeKey,                            <span class="hljs-keyword">null</span>, message.getBytes());                    System.out.println(<span class="hljs-string">" [x] Sent '"</span> + routeKey + <span class="hljs-string">":'"</span>                            + message + <span class="hljs-string">"'"</span>);                &#125;            &#125;        &#125;        channel.close();        connection.close();    &#125;&#125;</code></pre><p>创建<code>#</code>类型的消费者，该消费者将订阅所有消息</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AllConsumer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] argv)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;        ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();        factory.setHost(<span class="hljs-string">"127.0.0.1"</span>);        Connection connection = factory.newConnection();        <span class="hljs-keyword">final</span> Channel channel = connection.createChannel();        channel.exchangeDeclare(TopicProducer.EXCHANGE_NAME,                BuiltinExchangeType.TOPIC);        String queueName = channel.queueDeclare().getQueue();        <span class="hljs-comment">//绑定</span>        channel.queueBind(queueName,TopicProducer.EXCHANGE_NAME, <span class="hljs-string">"#"</span>);        System.out.println(<span class="hljs-string">" [*] Waiting for messages:"</span>);        <span class="hljs-keyword">final</span> Consumer consumerA = <span class="hljs-keyword">new</span> DefaultConsumer(channel) &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag,</span></span><span class="hljs-function"><span class="hljs-params">                                       Envelope envelope,</span></span><span class="hljs-function"><span class="hljs-params">                                       AMQP.BasicProperties properties,</span></span><span class="hljs-function"><span class="hljs-params">                                       <span class="hljs-keyword">byte</span>[] body)</span></span><span class="hljs-function">                    <span class="hljs-keyword">throws</span> IOException </span>&#123;                String message = <span class="hljs-keyword">new</span> String(body, <span class="hljs-string">"UTF-8"</span>);                System.out.println(<span class="hljs-string">" AllConsumer Received "</span>                        + envelope.getRoutingKey()                        + <span class="hljs-string">"':'"</span> + message + <span class="hljs-string">"'"</span>);            &#125;        &#125;;        channel.basicConsume(queueName, <span class="hljs-keyword">true</span>, consumerA);    &#125;&#125;</code></pre><p>创建<code>TYPE_A.#</code>类型的消费者，该消费者将接收所有第一位为<code>TYPE_A</code>的消息。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TypeConsumer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] argv)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;        ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();        factory.setHost(<span class="hljs-string">"127.0.0.1"</span>);        Connection connection = factory.newConnection();        <span class="hljs-keyword">final</span> Channel channel = connection.createChannel();        channel.exchangeDeclare(TopicProducer.EXCHANGE_NAME,                BuiltinExchangeType.TOPIC);        String queueName = channel.queueDeclare().getQueue();        channel.queueBind(queueName, TopicProducer.EXCHANGE_NAME,                <span class="hljs-string">"TYPE_A.#"</span>);        System.out.println(<span class="hljs-string">" [*] Waiting for messages:"</span>);        <span class="hljs-keyword">final</span> Consumer consumerA = <span class="hljs-keyword">new</span> DefaultConsumer(channel) &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag,</span></span><span class="hljs-function"><span class="hljs-params">                                       Envelope envelope,</span></span><span class="hljs-function"><span class="hljs-params">                                       AMQP.BasicProperties properties,</span></span><span class="hljs-function"><span class="hljs-params">                                       <span class="hljs-keyword">byte</span>[] body)</span></span><span class="hljs-function">                    <span class="hljs-keyword">throws</span> IOException </span>&#123;                String message = <span class="hljs-keyword">new</span> String(body, <span class="hljs-string">"UTF-8"</span>);                System.out.println(<span class="hljs-string">" AllConsumer Received "</span>                        + envelope.getRoutingKey()                        + <span class="hljs-string">"':'"</span> + message + <span class="hljs-string">"'"</span>);            &#125;        &#125;;        channel.basicConsume(queueName, <span class="hljs-keyword">true</span>, consumerA);    &#125;&#125;</code></pre><p>创建<code>*.moduleA.*</code>类型的消费者，该消费者将接收所有第二位为<code>moduleA</code>的消息</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ModuleConsumer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] argv)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;        ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();        factory.setHost(<span class="hljs-string">"127.0.0.1"</span>);        Connection connection = factory.newConnection();        <span class="hljs-keyword">final</span> Channel channel = connection.createChannel();        channel.exchangeDeclare(TopicProducer.EXCHANGE_NAME,                BuiltinExchangeType.TOPIC);        String queueName = channel.queueDeclare().getQueue();        channel.queueBind(queueName, TopicProducer.EXCHANGE_NAME, <span class="hljs-string">"*.moduleA.*"</span>);        System.out.println(<span class="hljs-string">" [*] Waiting for messages:"</span>);        <span class="hljs-keyword">final</span> Consumer consumerA = <span class="hljs-keyword">new</span> DefaultConsumer(channel) &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag,</span></span><span class="hljs-function"><span class="hljs-params">                                       Envelope envelope,</span></span><span class="hljs-function"><span class="hljs-params">                                       AMQP.BasicProperties properties,</span></span><span class="hljs-function"><span class="hljs-params">                                       <span class="hljs-keyword">byte</span>[] body)</span></span><span class="hljs-function">                    <span class="hljs-keyword">throws</span> IOException </span>&#123;                String message = <span class="hljs-keyword">new</span> String(body, <span class="hljs-string">"UTF-8"</span>);                System.out.println(<span class="hljs-string">" AllConsumer Received "</span>                        + envelope.getRoutingKey()                        + <span class="hljs-string">"':'"</span> + message + <span class="hljs-string">"'"</span>);            &#125;        &#125;;        channel.basicConsume(queueName, <span class="hljs-keyword">true</span>, consumerA);    &#125;&#125;</code></pre><p>同样，还可以创建<code>#.0</code>、<code>*.moduleA.1</code>、<code>TYPE_B.moduleC.2</code>等类型的消费者，来匹配对应的消息。</p><h2 id="消息发布时的权衡"><a href="#消息发布时的权衡" class="headerlink" title="消息发布时的权衡"></a>消息发布时的权衡</h2><p>不做任何配置的情况下，生产者是不知道消息是否真正到达了RabbitMQ，也就是说消息发布操作不返回任何信息给生产者，通常有以下几种方式来保证消息的可靠性。</p><img src="/blog/2020/05/08/RabbitMQ%E4%B8%AD%E6%B6%88%E6%81%AF%E5%8F%91%E5%B8%83%E4%B8%8E%E6%9D%83%E8%A1%A1/pic1.png" srcset="/blog/img/loading.gif" class><p>在RabbitMQ中，有不同的投递机制（生产者），但是每一种机制都对性能有一定的影响。一般来讲速度快的可靠性低，可靠性好的性能差，具体怎么使用需要根据应用程序来定，所以说没有最好的方式，只有最合适的方式。</p><p>在RabbitMQ中实际项目中，生产者和消费者都是客户端，它们都可以完成交换器、队列和绑定关系的申明，但是在使用过程中，通常在生产者代码中申明交换器，在消费者代码中申明队列和绑定关系。但生产者发布消息时不一定非得需要消费者，对于RabbitMQ来说，如果是单纯的生产者就只需要生产者客户端申明交换器、队列、确定绑定关系，就可以将消息发送至RabbitMQ。</p><h3 id="无保障"><a href="#无保障" class="headerlink" title="无保障"></a>无保障</h3><p>在演示各种交换器中使用的就是无保障的方式，通过basicPublish发布你的消息并使用正确的交换器和路由信息，你的消息会被接收并发送到合适的队列中。但是如果有网络问题，或者消息不可路由，或者RabbitMQ自身有问题的话，这种方式就有风险。所以无保证的消息发送一般情况下不推荐。</p><h3 id="失败确认"><a href="#失败确认" class="headerlink" title="失败确认"></a>失败确认</h3><p>在发送消息时设置mandatory标志，告诉RabbitMQ，如果消息不可路由，应该将消息返回给发送者，并通知失败。可以这样认为，开启mandatory是开启故障检测模式。<br>但是它只会让RabbitMQ向你通知失败，而不会通知成功。如果消息正确路由到队列，则发布者不会收到任何通知。带来的问题是无法确保发布消息一定是成功的，因为通知失败的消息可能会丢失。</p><p>具体使用：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DirectProducer</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String EXCHANGE_NAME = <span class="hljs-string">"direct_logs"</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String[] ROUTE_KEYS = &#123;<span class="hljs-string">"route_key_1"</span>, <span class="hljs-string">"route_key_2"</span>, <span class="hljs-string">"route_key_3"</span>&#125;;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><span class="hljs-function">            <span class="hljs-keyword">throws</span> IOException, TimeoutException, InterruptedException </span>&#123;        ConnectionFactory connectionFactory = <span class="hljs-keyword">new</span> ConnectionFactory();        connectionFactory.setHost(<span class="hljs-string">"localhost"</span>);        Connection connection = connectionFactory.newConnection();        Channel channel = connection.createChannel();        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);              <span class="hljs-comment">//消息发送失败时回调</span>        channel.addReturnListener(<span class="hljs-keyword">new</span> ReturnListener() &#123;            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleReturn</span><span class="hljs-params">(<span class="hljs-keyword">int</span> replyCode, String replyText, String exchange, String routeKey, AMQP.BasicProperties basicProperties, <span class="hljs-keyword">byte</span>[] bytes)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;                String string = <span class="hljs-keyword">new</span> String(bytes);                System.out.println(<span class="hljs-string">"回调内容：replyCode："</span> + replyCode);                System.out.println(<span class="hljs-string">"回调内容：replyText："</span> + replyText);                System.out.println(<span class="hljs-string">"回调内容：exchange："</span> + exchange);                System.out.println(<span class="hljs-string">"回调内容：routeKey："</span> + routeKey);                System.out.println(<span class="hljs-string">"回调内容：content："</span> + string);            &#125;        &#125;);              <span class="hljs-comment">//连接关闭时的回调</span>        connection.addShutdownListener(<span class="hljs-keyword">new</span> ShutdownListener() &#123;            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shutdownCompleted</span><span class="hljs-params">(ShutdownSignalException e)</span> </span>&#123;            &#125;        &#125;);                <span class="hljs-comment">//信道关闭时的回掉</span>        channel.addShutdownListener(<span class="hljs-keyword">new</span> ShutdownListener() &#123;            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shutdownCompleted</span><span class="hljs-params">(ShutdownSignalException e)</span> </span>&#123;            &#125;        &#125;);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123;            String routeKey = ROUTE_KEYS[i % <span class="hljs-number">3</span>];            String msg = <span class="hljs-string">"Hello,RabbitMQ"</span> + (i + <span class="hljs-number">1</span>);            <span class="hljs-comment">//发布消息 第三个参数为true表示开启失败通知</span>            channel.basicPublish(EXCHANGE_NAME, routeKey, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">null</span>, msg.getBytes());            System.out.println(<span class="hljs-string">"Sent:"</span> + routeKey + <span class="hljs-string">":"</span> + msg);            TimeUnit.MICROSECONDS.sleep(<span class="hljs-number">200</span>);        &#125;        channel.close();        connection.close();    &#125;&#125;</code></pre><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>事务的实现主要是对信道（Channel）的设置，主要的方法有三个:</p><ol><li>channel.txSelect()声明启动事务模式;</li><li>channel.txComment()提交事务;</li><li>channel.txRollback()回滚事务;</li></ol><p>在发送消息之前，需要声明channel为事务模式，提交或者回滚事务即可。 开启事务后，客户端和RabbitMQ之间的通讯交互流程:</p><ul><li>客户端发送给服务器 Tx.Select(开启事务模式)</li><li>服务器端返回 Tx.Select-Ok(开启事务模式 ok)  推送消息</li><li>客户端发送给事务提交 Tx.Commit</li></ul><p>服务器端返回 Tx.Commit-Ok<br>以上就完成了事务的交互流程，如果其中任意一个环节出现问题，就会抛出 IoException，这样用户就可以拦截异常进行事务回滚，或决定要不要重复消息。</p><p>但是事务机制本身也会带来问题：</p><ol><li><p>严重的性能问题，加入事务后将会导致2-10倍的性能下降。</p></li><li><p>使应用程序产生同步。</p></li></ol><p>具体使用：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProducerTransaction</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String EXCHANGE_NAME = <span class="hljs-string">"producer_transaction"</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><span class="hljs-function">            <span class="hljs-keyword">throws</span> IOException, TimeoutException, InterruptedException </span>&#123;        ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();        factory.setHost(<span class="hljs-string">"127.0.0.1"</span>);        Connection connection = factory.newConnection();        Channel channel = connection.createChannel();        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);        String[] routekeys=&#123;<span class="hljs-string">"keys1"</span>,<span class="hljs-string">"keys2"</span>,<span class="hljs-string">"keys3"</span>&#125;;        <span class="hljs-comment">//开启事务</span>        channel.txSelect();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++)&#123;                String routekey = routekeys[i%<span class="hljs-number">3</span>];                String message = <span class="hljs-string">"Hello World_"</span>+(i+<span class="hljs-number">1</span>)                        +(<span class="hljs-string">"_"</span>+System.currentTimeMillis());                channel.basicPublish(EXCHANGE_NAME, routekey, <span class="hljs-keyword">true</span>,                        <span class="hljs-keyword">null</span>, message.getBytes());                System.out.println(<span class="hljs-string">"----------------------------------"</span>);                System.out.println(<span class="hljs-string">" Sent Message: ["</span> + routekey +<span class="hljs-string">"]:'"</span>                        + message + <span class="hljs-string">"'"</span>);                Thread.sleep(<span class="hljs-number">200</span>);            &#125;            <span class="hljs-comment">//事务提交</span>            channel.txCommit();        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();            <span class="hljs-comment">//事务回滚</span>            channel.txRollback();        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        channel.close();        connection.close();    &#125;&#125;</code></pre><h3 id="发布者确认"><a href="#发布者确认" class="headerlink" title="发布者确认"></a>发布者确认</h3><p>基于事务的性能问题，RabbitMQ团队为我们拿出了更好的方案，即采用发送方确认模式，该模式比事务更轻量，性能影响几乎可以忽略不计。</p><p>原理：生产者将信道设置成confirm模式，一旦信道进入confirm模式，所有在该信道上面发布的消息都将会被指派一个唯一的ID（从1开始），由这个id在生产者和RabbitMQ之间进行消息的确认。</p><p>不可路由的消息，当交换器发现消息不能路由到任何队列，会进行失败确认操作，表示收到了消息。如果发送方设置了mandatory模式，则会调用addReturnListener()方法设置的监听器。</p><p>可路由的消息，要等到消息被投递到所有匹配的队列之后，broker会发送一个确认给生产者（包含消息的唯一ID），如果消息和队列是可持久化的，那么确认消息会在将消息写入磁盘之后发出，broker回传给生产者的确认消息中的delivery-tag域包含了确认消息的序列号。</p><img src="/blog/2020/05/08/RabbitMQ%E4%B8%AD%E6%B6%88%E6%81%AF%E5%8F%91%E5%B8%83%E4%B8%8E%E6%9D%83%E8%A1%A1/pic5.png" srcset="/blog/img/loading.gif" class><p>confirm模式最大的好处在于他可以是异步的，消息发送完成后生产者可以在等信道返回时，继续发送下一条消息，当消息最终得到确认之后，生产者可以通过回调方法来处理该确认消息，如果RabbitMQ因为自身内部错误导致消息丢失，就会发送一条nack消息，生产者应用程序同样可以在回调方法中处理该nack消息决定下一步的操作。 </p><p>Confirm的三种实现方式：</p><ul><li><p>channel.waitForConfirms()普通发送方确认模式，消息到达交换器就会返回true。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProducerConfirm</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String EXCHANGE_NAME = <span class="hljs-string">"producer_confirm"</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String ROUTE_KEY = <span class="hljs-string">"test"</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException, InterruptedException </span>&#123;        ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();        factory.setHost(<span class="hljs-string">"127.0.0.1"</span>);        Connection connection = factory.newConnection();        Channel channel = connection.createChannel();        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);        channel.addReturnListener(<span class="hljs-keyword">new</span> ReturnListener() &#123;            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleReturn</span><span class="hljs-params">(<span class="hljs-keyword">int</span> replyCode, String replyText,</span></span><span class="hljs-function"><span class="hljs-params">                                     String exchange, String routingKey,</span></span><span class="hljs-function"><span class="hljs-params">                                     AMQP.BasicProperties properties,</span></span><span class="hljs-function"><span class="hljs-params">                                     <span class="hljs-keyword">byte</span>[] body)</span></span><span class="hljs-function">                    <span class="hljs-keyword">throws</span> IOException </span>&#123;                String message = <span class="hljs-keyword">new</span> String(body);                System.out.println(<span class="hljs-string">"RabbitMq返回的replyCode:  "</span> + replyCode);                System.out.println(<span class="hljs-string">"RabbitMq返回的replyText:  "</span> + replyText);                System.out.println(<span class="hljs-string">"RabbitMq返回的exchange:  "</span> + exchange);                System.out.println(<span class="hljs-string">"RabbitMq返回的routingKey:  "</span> + routingKey);                System.out.println(<span class="hljs-string">"RabbitMq返回的message:  "</span> + message);            &#125;        &#125;);        <span class="hljs-comment">// 启用发送者确认模式</span>        channel.confirmSelect();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;            String message = <span class="hljs-string">"Hello World_"</span> + (i + <span class="hljs-number">1</span>);            channel.basicPublish(EXCHANGE_NAME, ROUTE_KEY, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">null</span>, message.getBytes());            System.out.println(<span class="hljs-string">" Sent Message: ["</span> + ROUTE_KEY + <span class="hljs-string">"]:'"</span> + message + <span class="hljs-string">"'"</span>);            <span class="hljs-comment">//确认是否成功(true成功)</span>            <span class="hljs-keyword">if</span> (channel.waitForConfirms()) &#123;                System.out.println(<span class="hljs-string">"send success"</span>);            &#125; <span class="hljs-keyword">else</span> &#123;                System.out.println(<span class="hljs-string">"send failure"</span>);            &#125;        &#125;        channel.close();        connection.close();    &#125;&#125;</code></pre></li><li><p>channel.waitForConfirmsOrDie()批量确认模式，使用同步方式等所有的消息发送之后才会执行后面代码，只要有一个消息未到达交换器就会 抛出IOException异常。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProducerBatchConfirm</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String EXCHANGE_NAME = <span class="hljs-string">"producer_wait_confirm"</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String ROUTE_KEY = <span class="hljs-string">"test"</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException, InterruptedException </span>&#123;        ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();        factory.setHost(<span class="hljs-string">"127.0.0.1"</span>);        Connection connection = factory.newConnection();        Channel channel = connection.createChannel();        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);        channel.addReturnListener(<span class="hljs-keyword">new</span> ReturnListener() &#123;            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleReturn</span><span class="hljs-params">(<span class="hljs-keyword">int</span> replyCode, String replyText,</span></span><span class="hljs-function"><span class="hljs-params">                                     String exchange, String routingKey,</span></span><span class="hljs-function"><span class="hljs-params">                                     AMQP.BasicProperties properties,</span></span><span class="hljs-function"><span class="hljs-params">                                     <span class="hljs-keyword">byte</span>[] body)</span></span><span class="hljs-function">                    <span class="hljs-keyword">throws</span> IOException </span>&#123;                String message = <span class="hljs-keyword">new</span> String(body);                System.out.println(<span class="hljs-string">"RabbitMq返回的replyCode:  "</span> + replyCode);                System.out.println(<span class="hljs-string">"RabbitMq返回的replyText:  "</span> + replyText);                System.out.println(<span class="hljs-string">"RabbitMq返回的exchange:  "</span> + exchange);                System.out.println(<span class="hljs-string">"RabbitMq返回的routingKey:  "</span> + routingKey);                System.out.println(<span class="hljs-string">"RabbitMq返回的message:  "</span> + message);            &#125;        &#125;);        <span class="hljs-comment">// 启用发送者确认模式</span>        channel.confirmSelect();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            String message = <span class="hljs-string">"Hello World_"</span> + (i + <span class="hljs-number">1</span>);            channel.basicPublish(EXCHANGE_NAME, ROUTE_KEY, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">null</span>, message.getBytes());            System.out.println(<span class="hljs-string">" Sent Message: ["</span> + ROUTE_KEY + <span class="hljs-string">"]:'"</span> + message + <span class="hljs-string">"'"</span>);        &#125;        <span class="hljs-comment">// 批量确认，如果失败会抛出异常</span>        channel.waitForConfirmsOrDie();        channel.close();        connection.close();    &#125;&#125;</code></pre></li><li><p>channel.addConfirmListener()异步监听发送方确认模式。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProducerConfirmAsync</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String EXCHANGE_NAME = <span class="hljs-string">"producer_async_confirm"</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException, InterruptedException </span>&#123;        ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();        factory.setHost(<span class="hljs-string">"127.0.0.1"</span>);        Connection connection = factory.newConnection();        Channel channel = connection.createChannel();        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);        <span class="hljs-comment">// 启用发送者确认模式</span>        channel.confirmSelect();        <span class="hljs-comment">// 添加发送者确认监听器</span>        channel.addConfirmListener(<span class="hljs-keyword">new</span> ConfirmListener() &#123;            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleAck</span><span class="hljs-params">(<span class="hljs-keyword">long</span> deliveryTag, <span class="hljs-keyword">boolean</span> multiple)</span></span><span class="hljs-function">                    <span class="hljs-keyword">throws</span> IOException </span>&#123;                System.out.println(<span class="hljs-string">"send_ACK:"</span>+deliveryTag+<span class="hljs-string">",multiple:"</span>+multiple);            &#125;            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleNack</span><span class="hljs-params">(<span class="hljs-keyword">long</span> deliveryTag, <span class="hljs-keyword">boolean</span> multiple)</span></span><span class="hljs-function">                    <span class="hljs-keyword">throws</span> IOException </span>&#123;                System.out.println(<span class="hljs-string">"Error----send_NACK:"</span>+deliveryTag+<span class="hljs-string">",multiple:"</span>+multiple);            &#125;        &#125;);              channel.addReturnListener(<span class="hljs-keyword">new</span> ReturnListener() &#123;            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleReturn</span><span class="hljs-params">(<span class="hljs-keyword">int</span> replyCode, String replyText,</span></span><span class="hljs-function"><span class="hljs-params">                                     String exchange, String routingKey,</span></span><span class="hljs-function"><span class="hljs-params">                                     AMQP.BasicProperties properties,</span></span><span class="hljs-function"><span class="hljs-params">                                     <span class="hljs-keyword">byte</span>[] body)</span></span><span class="hljs-function">                    <span class="hljs-keyword">throws</span> IOException </span>&#123;                String message = <span class="hljs-keyword">new</span> String(body);                System.out.println(<span class="hljs-string">"RabbitMQ路由失败:  "</span>+routingKey+<span class="hljs-string">"."</span>+message);            &#125;        &#125;);        String[] routekeys=&#123;<span class="hljs-string">"test"</span>,<span class="hljs-string">"test2"</span>&#125;;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">20</span>;i++)&#123;            String routekey = routekeys[i%<span class="hljs-number">2</span>];            String message = <span class="hljs-string">"Hello World_"</span>+(i+<span class="hljs-number">1</span>)+(<span class="hljs-string">"_"</span>+System.currentTimeMillis());            channel.basicPublish(EXCHANGE_NAME, routekey, <span class="hljs-keyword">true</span>,                    MessageProperties.PERSISTENT_BASIC, message.getBytes());        &#125;    &#125;&#125;</code></pre></li></ul><h3 id="备用交换器"><a href="#备用交换器" class="headerlink" title="备用交换器"></a>备用交换器</h3><p>在第一次声明交换器时被指定，用来提供一种预先存在的交换器，如果主交换器无法路由消息，那么消息将被路由到这个新的备用交换器。这时RabbitMQ也不会向发布者发送失败通知，因为消息已经发送至备用交换器，表示消息已经被路由了。注意，备用交换器就是普通的交换器，没有任何特殊的地方。</p><p>使用备用交换器，向往常一样，声明Queue和备用交换器，把Queue绑定到备用交换器上。然后在声明主交换器时，通过交换器的参数，alternate-exchange，将备用交换器设置给主交换器。建议备用交换器设置为faout类型，Queue绑定时的路由键设置为“#”。</p><img src="/blog/2020/05/08/RabbitMQ%E4%B8%AD%E6%B6%88%E6%81%AF%E5%8F%91%E5%B8%83%E4%B8%8E%E6%9D%83%E8%A1%A1/pic6.png" srcset="/blog/img/loading.gif" class><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BackupExProducer</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String EXCHANGE_NAME = <span class="hljs-string">"main-exchange"</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String BAK_EXCHANGE_NAME = <span class="hljs-string">"ae"</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><span class="hljs-function">            <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;        ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();        factory.setHost(<span class="hljs-string">"127.0.0.1"</span>);        Connection connection = factory.newConnection();        Channel channel = connection.createChannel();        Map&lt;String,Object&gt; argsMap = <span class="hljs-keyword">new</span> HashMap&lt;String,Object&gt;();        argsMap.put(<span class="hljs-string">"alternate-exchange"</span>,BAK_EXCHANGE_NAME);        <span class="hljs-comment">//主交换器</span>        channel.exchangeDeclare(EXCHANGE_NAME,<span class="hljs-string">"direct"</span>,                <span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>,argsMap);        <span class="hljs-comment">//备用交换器</span>        channel.exchangeDeclare(BAK_EXCHANGE_NAME,BuiltinExchangeType.FANOUT,                <span class="hljs-keyword">true</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">null</span>);        String[] routekeys=&#123;<span class="hljs-string">"test1"</span>,<span class="hljs-string">"test2"</span>,<span class="hljs-string">"test3"</span>&#125;;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++)&#123;            String routekey = routekeys[i%<span class="hljs-number">3</span>];            String message = <span class="hljs-string">"Hello World_"</span>+(i+<span class="hljs-number">1</span>);            channel.basicPublish(EXCHANGE_NAME, routekey,                    <span class="hljs-keyword">null</span>, message.getBytes());            System.out.println(<span class="hljs-string">" [x] Sent '"</span> + routekey +<span class="hljs-string">"':'"</span>                    + message + <span class="hljs-string">"'"</span>);        &#125;        channel.close();        connection.close();    &#125;&#125;</code></pre><p>主交换器绑定消费者</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainConsumer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] argv)</span></span><span class="hljs-function">            <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;        ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();        factory.setHost(<span class="hljs-string">"127.0.0.1"</span>);        Connection connection = factory.newConnection();        <span class="hljs-keyword">final</span> Channel channel = connection.createChannel();        String queueName = <span class="hljs-string">"backupexchange"</span>;        channel.queueDeclare(queueName,                <span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>,                <span class="hljs-keyword">false</span>,<span class="hljs-keyword">null</span>);        <span class="hljs-comment">//只绑定test1路由键</span>        String routekey=<span class="hljs-string">"test1"</span>;        channel.queueBind(queueName,                BackupExProducer.EXCHANGE_NAME, routekey);        System.out.println(<span class="hljs-string">" [*] Waiting for messages......"</span>);        <span class="hljs-keyword">final</span> Consumer consumerB = <span class="hljs-keyword">new</span> DefaultConsumer(channel) &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag,</span></span><span class="hljs-function"><span class="hljs-params">                                       Envelope envelope,</span></span><span class="hljs-function"><span class="hljs-params">                                       AMQP.BasicProperties properties,</span></span><span class="hljs-function"><span class="hljs-params">                                       <span class="hljs-keyword">byte</span>[] body)</span></span><span class="hljs-function">                    <span class="hljs-keyword">throws</span> IOException </span>&#123;                String message = <span class="hljs-keyword">new</span> String(body, <span class="hljs-string">"UTF-8"</span>);                System.out.println( <span class="hljs-string">"Received ["</span>                        + envelope.getRoutingKey() + <span class="hljs-string">"] "</span>+message);            &#125;        &#125;;        channel.basicConsume(queueName, <span class="hljs-keyword">true</span>, consumerB);    &#125;&#125;</code></pre><p>副交换器绑定消费者</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BackupExConsumer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] argv)</span></span><span class="hljs-function">            <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;        ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();        factory.setHost(<span class="hljs-string">"127.0.0.1"</span>);        Connection connection = factory.newConnection();        <span class="hljs-keyword">final</span> Channel channel = connection.createChannel();        channel.exchangeDeclare(BackupExProducer.BAK_EXCHANGE_NAME,                BuiltinExchangeType.FANOUT,                <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);        String queueName = <span class="hljs-string">"fetchother"</span>;        channel.queueDeclare(queueName,                <span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>,                <span class="hljs-keyword">false</span>,<span class="hljs-keyword">null</span>);        channel.queueBind(queueName,                BackupExProducer.BAK_EXCHANGE_NAME, <span class="hljs-string">"#"</span>);        System.out.println(<span class="hljs-string">" [*] Waiting for messages......"</span>);        <span class="hljs-keyword">final</span> Consumer consumerB = <span class="hljs-keyword">new</span> DefaultConsumer(channel) &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag,</span></span><span class="hljs-function"><span class="hljs-params">                                       Envelope envelope,</span></span><span class="hljs-function"><span class="hljs-params">                                       AMQP.BasicProperties properties,</span></span><span class="hljs-function"><span class="hljs-params">                                       <span class="hljs-keyword">byte</span>[] body)</span></span><span class="hljs-function">                    <span class="hljs-keyword">throws</span> IOException </span>&#123;                String message = <span class="hljs-keyword">new</span> String(body, <span class="hljs-string">"UTF-8"</span>);                System.out.println( <span class="hljs-string">"Received ["</span>                        + envelope.getRoutingKey() + <span class="hljs-string">"] "</span>+message);            &#125;        &#125;;        channel.basicConsume(queueName, <span class="hljs-keyword">true</span>, consumerB);    &#125;&#125;</code></pre><h2 id="消息消费时的权衡"><a href="#消息消费时的权衡" class="headerlink" title="消息消费时的权衡"></a>消息消费时的权衡</h2><h3 id="消费的获取方式"><a href="#消费的获取方式" class="headerlink" title="消费的获取方式"></a>消费的获取方式</h3><ul><li><p>拉取Get，消费者主动从队列中拉取消息。</p><img src="/blog/2020/05/08/RabbitMQ%E4%B8%AD%E6%B6%88%E6%81%AF%E5%8F%91%E5%B8%83%E4%B8%8E%E6%9D%83%E8%A1%A1/pic7.png" srcset="/blog/img/loading.gif" class><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GetMessageConsumer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] argv)</span></span><span class="hljs-function">            <span class="hljs-keyword">throws</span> IOException, TimeoutException, InterruptedException </span>&#123;        ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();        factory.setHost(<span class="hljs-string">"127.0.0.1"</span>);        Connection connection = factory.newConnection();        <span class="hljs-keyword">final</span> Channel channel = connection.createChannel();        channel.exchangeDeclare(GetMessageProducer.EXCHANGE_NAME,                <span class="hljs-string">"direct"</span>);        String queueName = <span class="hljs-string">"focuserror"</span>;        channel.queueDeclare(queueName,                <span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>,                <span class="hljs-keyword">false</span>,<span class="hljs-keyword">null</span>);        String routekey=<span class="hljs-string">"test"</span>;        channel.queueBind(queueName,                GetMessageProducer.EXCHANGE_NAME, routekey);        System.out.println(<span class="hljs-string">" [*] Waiting for messages......"</span>);        <span class="hljs-comment">//无限循环拉取</span>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;            <span class="hljs-comment">//从指定队列中拉取一条消息，第二个参数为是否自动确认</span>            GetResponse getResponse = channel.basicGet(queueName, <span class="hljs-keyword">false</span>);            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span>!=getResponse)&#123;                System.out.println(<span class="hljs-string">"received["</span>                        +getResponse.getEnvelope().getRoutingKey()+<span class="hljs-string">"]"</span>                        +<span class="hljs-keyword">new</span> String(getResponse.getBody()));            &#125;            <span class="hljs-comment">//消息手动确认，确认后消息会从队列中移除</span>            channel.basicAck(<span class="hljs-number">0</span>,<span class="hljs-keyword">true</span>);            Thread.sleep(<span class="hljs-number">1000</span>);        &#125;    &#125;&#125;</code></pre></li><li><p>推送Consume，rabbitMQ将队列中的消息主动推送给消费者，之前的消费者示例都是使用这种方式。</p><img src="/blog/2020/05/08/RabbitMQ%E4%B8%AD%E6%B6%88%E6%81%AF%E5%8F%91%E5%B8%83%E4%B8%8E%E6%9D%83%E8%A1%A1/pic7.png" srcset="/blog/img/loading.gif" class></li></ul><h3 id="消息的确认"><a href="#消息的确认" class="headerlink" title="消息的确认"></a>消息的确认</h3><ul><li><p>自动确认：在使用<code>channel.basicConsume(queueName,false,consumer);</code>声明队列时，第二个参数为autoAck，当autoAck=true时，一旦消费者接收到了消息，就视为自动确认了消息。如果之后的处理过程中出现错误，也不会影响消息的确认。所以很多时候，需要在消息处理成功后再确认消息，这时就需要手动确认。</p></li><li><p>手动确认：当autoAck=false时，RabbitMQ会等待消费者显式发回ack信号后才从内存和磁盘中（如果是持久化消息的话，消息会被保存到磁盘中）中移去消息。采用消息确认机制后，只要令autoAck=false，消费者就有足够的时间处理消息，不用担心处理消息过程中消费者进程挂掉后消息丢失的问题，因为RabbitMQ会一直持有消息直到消费者显式调用basicAck为止。</p><p>当autoAck=false时，对于RabbitMQ服务器端而言，队列中的消息分成了两部分：一部分是等待投递给消费者的消息，一部分是已经投递给消费者但是还没有收到消费者ack信号的消息。如果服务器端一直没有收到消费者的ack信号，并且消费此消息的消费者已经断开连接，则服务器端会安排该消息重新进入队列，等待投递给下一个消费者（也可能还是原来的那个消费者）。</p></li></ul><h3 id="Qos预取模式"><a href="#Qos预取模式" class="headerlink" title="Qos预取模式"></a>Qos预取模式</h3><p>在确认消息被接收之前，消费者可以预先要求接收一定数量的消息，在处理完一定数量的消息后，可以进行批量确认。如果消费者应用程序在确认消息之前崩溃，则所有未确认的消息将被重新发送给其他消费者。这种机制一方面可以实现限速（将消息暂存到RabbitMQ内存中）的作用，一方面可以保证消息确认质量。</p><p>注意：消费确认模式必须是非自动确认机制，这个是使用baseQos的前提条件，否则会Qos不生效，然后设置basicQos的值。另外，还可以基于consume和channel的粒度进行设置（global）。</p><h4 id="批量确认"><a href="#批量确认" class="headerlink" title="批量确认"></a>批量确认</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BatchQosConsumer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] argv)</span></span><span class="hljs-function">            <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;        ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();        factory.setHost(<span class="hljs-string">"127.0.0.1"</span>);        Connection connection = factory.newConnection();        <span class="hljs-keyword">final</span> Channel channel = connection.createChannel();        channel.exchangeDeclare(DirectProducer.EXCHANGE_NAME,                <span class="hljs-string">"direct"</span>);        String queueName = <span class="hljs-string">"focuserror"</span>;        channel.queueDeclare(queueName, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>,                <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);        String routekey = <span class="hljs-string">"error"</span>;        channel.queueBind(queueName, DirectProducer.EXCHANGE_NAME, routekey);        System.out.println(<span class="hljs-string">"waiting for message........"</span>);        <span class="hljs-keyword">final</span> Consumer consumer = <span class="hljs-keyword">new</span> DefaultConsumer(channel) &#123;            <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> meesageCount = <span class="hljs-number">0</span>;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag,</span></span><span class="hljs-function"><span class="hljs-params">                                       Envelope envelope,</span></span><span class="hljs-function"><span class="hljs-params">                                       AMQP.BasicProperties properties,</span></span><span class="hljs-function"><span class="hljs-params">                                       <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;                String message = <span class="hljs-keyword">new</span> String(body, <span class="hljs-string">"UTF-8"</span>);                System.out.println(<span class="hljs-string">"批量消费者---Received["</span> + envelope.getRoutingKey()                        + <span class="hljs-string">"]"</span> + message);                meesageCount++;                <span class="hljs-comment">//批量确认50一批</span>                <span class="hljs-keyword">if</span> (meesageCount % <span class="hljs-number">50</span> == <span class="hljs-number">0</span>) &#123;                    <span class="hljs-keyword">this</span>.getChannel().basicAck(envelope.getDeliveryTag(), <span class="hljs-keyword">true</span>);                    System.out.println(<span class="hljs-string">"批量消息费进行消息的确认------------"</span>);                &#125;                <span class="hljs-comment">//如果是最后一条消息，则把剩余的消息都进行确认</span>                <span class="hljs-keyword">if</span> (message.equals(<span class="hljs-string">"stop"</span>)) &#123;                     <span class="hljs-keyword">this</span>.getChannel().basicAck(envelope.getDeliveryTag(), <span class="hljs-keyword">true</span>);                    System.out.println(<span class="hljs-string">"批量消费者进行最后业务消息的确认---------"</span>);                &#125;            &#125;        &#125;;        <span class="hljs-comment">//150条预取</span>        channel.basicQos(<span class="hljs-number">500</span>, <span class="hljs-keyword">true</span>);        channel.basicConsume(queueName, <span class="hljs-keyword">false</span>, consumer);    &#125;&#125;</code></pre><h4 id="单条确认"><a href="#单条确认" class="headerlink" title="单条确认"></a>单条确认</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QosConsumerMain</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] argv)</span></span><span class="hljs-function">            <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;        ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();        factory.setHost(<span class="hljs-string">"127.0.0.1"</span>);        Connection connection = factory.newConnection();        <span class="hljs-keyword">final</span> Channel channel = connection.createChannel();        channel.exchangeDeclare(DirectProducer.EXCHANGE_NAME,                <span class="hljs-string">"direct"</span>);        String queueName = <span class="hljs-string">"focuserror"</span>;        channel.queueDeclare(queueName,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>,                <span class="hljs-keyword">false</span>,<span class="hljs-keyword">null</span>);        String routekey = <span class="hljs-string">"test"</span>;        channel.queueBind(queueName,DirectProducer.EXCHANGE_NAME,routekey);        System.out.println(<span class="hljs-string">"waiting for message........"</span>);        <span class="hljs-keyword">final</span> Consumer consumer = <span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag,</span></span><span class="hljs-function"><span class="hljs-params">                                       Envelope envelope,</span></span><span class="hljs-function"><span class="hljs-params">                                       AMQP.BasicProperties properties,</span></span><span class="hljs-function"><span class="hljs-params">                                       <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;                String message = <span class="hljs-keyword">new</span> String(body, <span class="hljs-string">"UTF-8"</span>);                System.out.println(<span class="hljs-string">"Received["</span>+envelope.getRoutingKey()                        +<span class="hljs-string">"]"</span>+message);                <span class="hljs-comment">//TODO 单条确认</span>                channel.basicAck(envelope.getDeliveryTag(),<span class="hljs-keyword">false</span>);            &#125;        &#125;;        <span class="hljs-comment">//150条预取</span>        channel.basicQos(<span class="hljs-number">500</span>,<span class="hljs-keyword">true</span>);        channel.basicConsume(queueName,<span class="hljs-keyword">false</span>,consumer);    &#125;&#125;</code></pre><h4 id="basicQos-方法参数详细解释"><a href="#basicQos-方法参数详细解释" class="headerlink" title="basicQos()方法参数详细解释"></a>basicQos()方法参数详细解释</h4><ul><li>prefetchSize：最多传输内容的大小限制，0为不限制，但据说prefetchSize参数，rabbitmq没有实现。</li><li>prefetchCount：表示不要同时给一个消费者推送多于N个消息，即一旦有N个消息还没有ack，则该consumer将阻塞掉，直到有消息ack。</li><li>global：boolean类型表示是否将上面设置应用于channel，即上面的限制是channel级别的还是consumer级别。</li></ul><p>如果同时对channel和消费者进行设置，如</p><pre><code class="hljs java">channel.basicQos(<span class="hljs-number">10</span>,<span class="hljs-keyword">false</span>);channel.basicQos(<span class="hljs-number">15</span>,<span class="hljs-keyword">true</span>);</code></pre><p>AMQP规范中没有解释如果使用不同的全局值，多次调用basic.qos会发生什么。RabbitMQ认为两个预取限制应该彼此独立地强制执行。也就是说，整个通道加起来最多允许15条未确认的消息，每个消费者则最多有10条消息。消费者只有在未达到未确认消息限制时才会收到新消息。</p><h3 id="消费者中的事务"><a href="#消费者中的事务" class="headerlink" title="消费者中的事务"></a>消费者中的事务</h3><p>使用方法和生产者一致。假设消费者模式中使用了事务，并且在消息确认之后进行了事务回滚，结果会分为两种情况：</p><ol><li><p>autoAck=false手动应对的时候是支持事务的，也就是说即使你已经手动确认了消息已经收到了，但 RabbitMQ对消息的确认会等事务的返回结果，最终决定是移除消息还是重新放回队列。如果你手动确认之后又回滚了事务，那么此条消息会重新放回队列。</p></li><li><p>autoAck=true如果自动确认为true的情况是不支持事务的，也就是说你即使在收到消息之后在回滚事务也是于事无补的，队列已经把消息移除了。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>消息中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>消息中间件</tag>
      
      <tag>RabbitMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ与AMQP</title>
    <link href="/blog/2020/05/07/RabbitMQ%E4%B8%8EAMQP%E5%8D%8F%E8%AE%AE/"/>
    <url>/blog/2020/05/07/RabbitMQ%E4%B8%8EAMQP%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h2><p>AMQP是应用层协议的一个开放标准,为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。目标是实现一种在全行业广泛使用的标准消息中间件技术，以便降低企业和系统集成的开销，并且向大众提供工业级的集成服务，主要实现有 RabbitMQ。</p><h3 id="客户端与RabbitMQ的通信"><a href="#客户端与RabbitMQ的通信" class="headerlink" title="客户端与RabbitMQ的通信"></a>客户端与RabbitMQ的通信</h3><p><strong>连接</strong></p><p>首先作为客户端(无论是生产者还是消费者)，如果要与RabbitMQ通讯的话，必须创建一条TCP连接，创建连接后还需要确认机制来验证双方都是AMQP规范的，确认之后就可以创建一条AMQP的信道。</p><p>连接在RabbitMQ原生客户端(5.0.0)版本中默认使用java的原生socket，但是也支持NIO，需要手动设置修改。</p><p><strong>信道</strong></p><p>道是生产者/消费者与RabbitMQ通信的渠道。信道是建立在TCP连接上的虚拟连接，RabbitMQ在一条TCP上可能会建立成百上千个信道来进行多个线程处理，这个TCP被多个线程共享，每个线程对应一个信道，信道在RabbitMQ都有唯一的ID，保证了信道私有性，及被唯一的线程使用。</p><p>系统为每个线程开辟一个TCP是非常消耗性能，每秒成百上千的建立销毁TCP会严重消耗系统。所以RabbitMQ选择建立多个信道（建立在tcp的虚拟连接）来连接。从技术上讲，这被称之为“多路复用”，对于执行多个任务的多线程或者异步应用程序来说，它非常有用。</p><h3 id="AMQP在RabbitMQ中的实现"><a href="#AMQP在RabbitMQ中的实现" class="headerlink" title="AMQP在RabbitMQ中的实现"></a>AMQP在RabbitMQ中的实现</h3><img src="/blog/2020/05/07/RabbitMQ%E4%B8%8EAMQP%E5%8D%8F%E8%AE%AE/pic1.png" srcset="/blog/img/loading.gif" class><p>包括的要素：</p><ul><li><p>生产者：消息的创建者，发送消息到RabbitMQ；</p></li><li><p>消费者：连接到RabbitMQ，订阅并消费队列上的消息，订阅分为持续订阅（basicConsumer）和单条订阅（basicGet）；</p></li><li><p>消息：包含有效载荷和标签，有效载荷指要传输的数据，标签描述了有效载荷，并且RabbitMQ用它来决定谁获得消息，消费者只能拿到有效载荷，并不知道生产者是谁；</p></li></ul><p>队列通过路由键（routing key，某种确定的规则）绑定到交换器，生产者将消息发布到交换器，交换器根据绑定的路由键将消息路由到特定队列， 然后由订阅这个队列的消费者进行接收。(路由键routing key和绑定键binding key的最大长度是 255 个字节)。</p><h3 id="消息的确认"><a href="#消息的确认" class="headerlink" title="消息的确认"></a>消息的确认</h3><p>消费者收到的每一条消息都必须进行确认(自动确认和自行确认)。</p><p>消费者在声明队列时，可以指定autoAck参数，当autoAck=false时，RabbitMQ会等待消费者显式发回ack信号后才从内存（磁盘，如果是持久化消息的话）中移去消息。否则，RabbitMQ会在队列中消息被消费后立即删除它。<br>采用消息确认机制后，只要令autoAck=false，消费者就有足够的时间处理消息（任务），不用担心处理消息过程中消费者进程挂掉后消息丢失的问题，因为RabbitMQ会一直持有消息直到消费者显式调用basicAck为止。</p><p>当autoAck=false时，对于RabbitMQ服务器端而言，队列中的消息分成了两部分：一部分是等待投递给消费者的消息，一部分是已经投递给消费者，但是还没有收到消费者ack信号的消息。如果服务器端一直没有收到消费者的ack信号，并且消费此消息的消费者已经断开连接，则服务器端会安排该消息重新进入队列，等待投递给下一个消费者（也可能还是原来的那个消费者）。RabbitMQ不会为未ack的消息设置超时时间，它判断此消息是否需要重新投递给消费者的唯一依据是消费该消息的消费者连接是否已经断开。这么设计的原因是RabbitMQ允许消费者消费一条消息的时间可以很久很久。</p><p><strong>常见问题</strong></p><ul><li><p>如果消息达到无人订阅的队列会怎么办?</p><p>消息会一直在队列中等待，RabbitMq 默认队列是无限长度的。 </p></li><li><p>多个消费者订阅到同一队列怎么办?</p><p>消息以轮询的方式发送给消费者，每个消息只会发送给一个消费者。 </p></li><li><p>消息路由到了不存在的队列怎么办?</p><p>一般情况下，RabbitMq会忽略，当这个消息不存在，也就是丢弃掉这条消息。</p></li></ul><h2 id="RabbitMQ中的概念"><a href="#RabbitMQ中的概念" class="headerlink" title="RabbitMQ中的概念"></a>RabbitMQ中的概念</h2><h3 id="虚拟主机"><a href="#虚拟主机" class="headerlink" title="虚拟主机"></a>虚拟主机</h3><p>虚拟消息服务器（vhost）本质上就是一个mini版的mq服务器，有自己的队列、交换器和绑定以及自己的权限机制。Vhost提供了逻辑上的分离，可以将众多客户端进行区分，避免队列和交换器的命名冲突。Vhost必须在连接时指定，rabbitmq包含缺省vhost：“/”，通过缺省用户和口令guest进行访问。</p><img src="/blog/2020/05/07/RabbitMQ%E4%B8%8EAMQP%E5%8D%8F%E8%AE%AE/pic2.png" srcset="/blog/img/loading.gif" class><p>如上图中的others交换器，连接时的地址为：<code>localhost:8888/other</code></p><p>rabbitmq里创建用户，必须要被指派给至少一个vhost，并且只能访问被指派内的队列、交换器和绑定。Vhost必须通过rabbitmq的管理控制工具创建。</p><h4 id="交换器类型"><a href="#交换器类型" class="headerlink" title="交换器类型"></a>交换器类型</h4><p>共有四种： <strong>direct</strong>、<strong>fanout</strong>、<strong>topic</strong>、<strong>headers</strong>，其中<strong>headers</strong>（几乎和 <strong>direct</strong> 一样）不实用，可以忽略。</p><h4 id="Direct"><a href="#Direct" class="headerlink" title="Direct"></a>Direct</h4><p>路由键完全匹配消息被投递到的队列，direct交换器是默认交换器。声明一个队列时，会自动绑定到默认交换器，并且以队列名称作为路由键。</p><img src="/blog/2020/05/07/RabbitMQ%E4%B8%8EAMQP%E5%8D%8F%E8%AE%AE/pic3.png" srcset="/blog/img/loading.gif" class><h4 id="Fanout"><a href="#Fanout" class="headerlink" title="Fanout"></a>Fanout</h4><p>消息广播到绑定的队列，不管队列绑定了什么路由键，消息经过交换器时会投递到每个队列。</p><img src="/blog/2020/05/07/RabbitMQ%E4%B8%8EAMQP%E5%8D%8F%E8%AE%AE/pic4.png" srcset="/blog/img/loading.gif" class><h4 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h4><p>通过使用“*”和“#”通配符进行处理，使来自不同源头的消息到达同一个队列，”.”将路由键分为了几个标识符，“*”匹配1个，“#”匹配一个或多个。</p><img src="/blog/2020/05/07/RabbitMQ%E4%B8%8EAMQP%E5%8D%8F%E8%AE%AE/pic5.png" srcset="/blog/img/loading.gif" class>]]></content>
    
    
    <categories>
      
      <category>消息中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>消息中间件</tag>
      
      <tag>RabbitMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>消息中间件</title>
    <link href="/blog/2020/05/07/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <url>/blog/2020/05/07/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h2><h3 id="消息中间件（MQ）的定义"><a href="#消息中间件（MQ）的定义" class="headerlink" title="消息中间件（MQ）的定义"></a>消息中间件（MQ）的定义</h3><img src="/blog/2020/05/07/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/pic1.png" srcset="/blog/img/loading.gif" class><p>没有标准定义。一般认为，消息中间件属于分布式系统中一个子系统，关注于数据的发送和接收，利用高效可靠的异步消息传递机制对分布式系统中的其余各个子系统进行集成。</p><ul><li>高效：对于消息的处理处理速度快。 </li><li>可靠：一般消息中间件都会有消息持久化机制和其他的机制确保消息不丢失。 </li><li>异步：指发送完一个请求，不需要等待返回，随时可以再发送下一个请求，既不需要等待。 </li></ul><p>消息中间件和RPC都是分布式的通信机制，与RPC场景的差异很大程度上在于“依赖性”和“同步性”。</p><ul><li><p>依赖性：比如短信通知服务并不是事交易环节必须的，并不影响下单流程，不是强依赖，所以交易系统不应该依赖短信服务。如果是RPC调用，短信通知服务挂了，整个业务就挂了，这个就是依赖性导致的，而消息中间件则没有这个依赖性。</p><p>消息中间件出现以后对于交易场景可能是调用库存中心等强依赖系统执行业务，之后发布一条消息(这条消息存储于消息中间件中)。像是短信通 知服务、数据统计服务等等都是依赖于消息中间件去消费这条消息来完成自己的业务逻辑。</p></li><li><p>同步性：RPC 方式是典型的同步方式，让远程调用像本地调用。消息中间件方式属于异步方式。</p></li></ul><h3 id="为什么要用消息中间件"><a href="#为什么要用消息中间件" class="headerlink" title="为什么要用消息中间件"></a>为什么要用消息中间件</h3><p>假设一个电商交易的场景，用户下单之后调用库存系统减库存，然后需要调用物流系统进行发货，如果交易、库存、物流是属于一个系统的，就必须通过接口调用。但是随着系统的发展，各个模块越来越庞大、业务逻辑越来越复杂，必然是要做服务化和业务拆分的。这个时候就需要考虑这些系统之间如何交互，一般的处理方式就是RPC（Remote Procedure Call 具体实现 dubbo,SpringCloud）。系统继续发展，可能一笔交易后续需要调用 几十个接口来执行业务，比如还有风控系统、短信服务等等。这时候就需要消息中间件来解决问题了。</p><p>所以消息中间件主要解决分布式系统之间消息的传递，同时为分布式系统中其他子系统提供了松耦合的架构，同时还有以下好处:</p><ul><li><p><strong>低耦合</strong>：不管是程序还是模块之间，使用消息中间件进行间接通信。</p></li><li><p><strong>异步通信能力</strong>：使得子系统之间得以充分执行自己的逻辑而无需等待。</p></li><li><p><strong>缓冲能力</strong>：消息中间件像是一个巨大的蓄水池，将高峰期大量的请求存储下来慢慢交给后台进行处理，对于秒杀业务来说尤为重要。</p></li><li><p><strong>伸缩性</strong>：是指通过不断向集群中加入服务器的手段来缓解不断上升的用户并发访问压力和不断增长的数据存储需求。衡量架构是否高伸缩性的主要标准就是是否可以使用多台服务器构建集群、是否容易向集群中添加新的服务器、加入新的服务器后是否可以提供和原来服务器无差别的服务、集群中可容纳的总的服务器数量是否有限制。</p></li><li><p><strong>扩展性</strong>：主要标准就是在网站增加新的业务产品时，是否可以实现对现有产品透明无影响，不需要任何改动或者很少改动既有业务功能就可以上线新产品。比如用户购买电影票的应用，现在我们要增加一个功能，用户买票后，随机抽取用户送限量周边。这时可以扩展消息的处理逻辑，这样也符合设计模式中的开闭原则（对扩展开放，对修改关闭）。</p></li></ul><h3 id="消息中间件使用的场景"><a href="#消息中间件使用的场景" class="headerlink" title="消息中间件使用的场景"></a>消息中间件使用的场景</h3><h4 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h4><p>场景说明:用户注册后，需要发注册邮件和注册短信。传统的做法有两种 1.串行的方式;2.并行方式。</p><ul><li><p>串行方式：将注册信息写入数据库成功后，发送注册邮件，再发送注册短信。以上三个任务全部完成后，返回给客户端。</p><img src="/blog/2020/05/07/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/pic2.png" srcset="/blog/img/loading.gif" class></li><li><p>并行方式：将注册信息写入数据库成功后，发送注册邮件的同时，发送注册短信。以上三个任务完成后，返回给客户端。与串行的差别是，并 行的方式可以提高处理的时间。</p><p>假设三个业务节点每个使用 50 毫秒钟，不考虑网络等其他开销，则串行方式的时间是 150 毫秒，并行的时间可能是 100 毫秒。</p><img src="/blog/2020/05/07/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/pic3.png" srcset="/blog/img/loading.gif" class></li><li><p>引入消息中间件：按照以上约定，用户的响应时间相当于是注册信息写入数据库的时间，也就是 50 毫秒。注册邮件，发送短信写入消息队列后，直接返回，因此写入消息队列的速度很快，基本可以忽略，因此用户的响应时间可能是 50 毫秒。因此架构改变后，系统的吞吐量提高到每秒 20 QPS。比串行提高了 3 倍， 比并行提高了两倍。</p><img src="/blog/2020/05/07/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/pic4.png" srcset="/blog/img/loading.gif" class></li></ul><h4 id="应用解耦"><a href="#应用解耦" class="headerlink" title="应用解耦"></a>应用解耦</h4><p>场景说明:用户下单后，订单系统需要通知库存系统。传统的做法是，订单系统调用库存系统的接口。 传统模式的缺点：</p><ol><li>假如库存系统无法访问，则订单减库存将失败，从而导致订单失败。</li><li>订单系统与库存系统耦合。</li></ol><p>这时可以使用消息中间件用户下单后，订单系统完成持久化处理，将消息写入消息队列，返回用户订单下单成功。 库存系统:订阅下单的消息，采用拉/推的方式，获取下单信息，库存系统根据下单信息，进行库存操作。这时在下单时库存系统不能正常使用。也不影响正常下单，因为下单后，订单系统写入消息队列就不再关心其他的后续操作了。实现订单系统与库存系统的应用解耦。</p><h4 id="流量削峰"><a href="#流量削峰" class="headerlink" title="流量削峰"></a>流量削峰</h4><p>流量削峰也是消息队列中的常用场景，一般在秒杀或团抢活动中使用广泛。</p><p>秒杀活动中一般会因为流量过大，导致流量暴增压垮应用。为解决这个问题，一般需要在应用前端加入消息队列控制活动的人数，缓解短时间内高流量防止应用被压垮。</p><img src="/blog/2020/05/07/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/pic6.png" srcset="/blog/img/loading.gif" class><h3 id="消息中间件编年史"><a href="#消息中间件编年史" class="headerlink" title="消息中间件编年史"></a>消息中间件编年史</h3><img src="/blog/2020/05/07/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/pic7.png" srcset="/blog/img/loading.gif" class><h3 id="消息中间件的选择"><a href="#消息中间件的选择" class="headerlink" title="消息中间件的选择"></a>消息中间件的选择</h3><table><thead><tr><th></th><th><strong>ActiveMQ</strong></th><th><strong>RabbitMQ</strong></th><th><strong>RocketMQ</strong></th><th><strong>Kafka</strong></th></tr></thead><tbody><tr><td>性能（单台）</td><td>6000+</td><td>万级(12000+)</td><td>十万级</td><td>百万级</td></tr><tr><td>消息持久化</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>多语言支持</td><td>支持</td><td>支持</td><td>很少</td><td>支持</td></tr><tr><td>社区活跃度</td><td>高</td><td>高</td><td>中</td><td>高</td></tr><tr><td>支持协议</td><td>多（JMS，AMQP….. ）</td><td>多（AMQP，STOMP，MQTT….. ）</td><td>自定义协议</td><td>自定义协议</td></tr><tr><td>综合评价</td><td>优点： 成熟，已经在很多公司得到应用。较多的文档。各种协议支持较好，有多个语言的成熟客户端。 缺点： 性能较弱。缺乏大规模吞吐的场景的应用，有江河日下之感。</td><td>优点：性能较好，管理界面较丰富，在互联网公司也有较大规模的应用，有多个语言的成熟客户端。 缺点： 内部机制很难了解，也意味很难定制和掌控。集群不支持动态扩展。</td><td>优点：模型简单，接口易用。在阿里有大规模应用。分布式系统，性能很好，版本更新很快。 缺点：文档少，支持的语言较少。</td><td>优点：天生分布式，性能最好，所以常见用于大数据领域。 缺点：运维难度大，偶尔有数据混乱的情况，对ZooKeeeper强依赖。多副本机制下对带宽有一定的要求。</td></tr></tbody></table><p>如果用户访问量在ActiveMQ的可承受范围内，而且确实主要是基于解耦和异步来用的，可以考虑ActiveMQ，也比较贴近Java工程师的使用习惯，但是 ActiveMQ 现在停止维护了，同时ActiveMQ并发不高，所以业务量一定的情况下可以考虑使用。RabbitMQ作为一个纯正血统的消息中间件，有着高级消息协议 AMQP 的完美结合，在消息中间件中地位无可取代，但是 erlang 语言阻止了我们去深入研究和掌控，对公司而言，底层技术无法控制，但是确实是开源的，有比较稳定的支持，活跃度也高。对自己公司技术实力有绝对自信的，可以用RocketMQ，但是RocketMQ诞生比较晚，并且更新迭代很快，这个意味着在使用过程中有可能会遇到 很多坑，所以如果你们公司Java技术不是很强，不推荐使用 。所以中小型公司，技术实力较为一般，技术挑战不是特别高，用 ActiveMQ、RabbitMQ是不错的选择;大型公司，基础架构研发实力较强，用RocketMQ是很好的选择。如果是大数据领域的实时计算、日志采集等场景，用Kafka是业内标准的，绝对没问题，社区活跃度很高。从性能上来看，使用文件系统的消息中间件（kafka、rokcetMq）性能是最好的，所以基于文件系统存储的消息中间件是发展趋势。(从存储方式和效率来看 文件系统&gt;KV 存储&gt;关系型数据库)</p>]]></content>
    
    
    <categories>
      
      <category>消息中间件</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>tomcat的简单实现</title>
    <link href="/blog/2020/05/06/tomcat%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/"/>
    <url>/blog/2020/05/06/tomcat%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="tomcat本质"><a href="#tomcat本质" class="headerlink" title="tomcat本质"></a>tomcat本质</h2><p>Tomcat本质上是一款开源轻量级Web应用服务器,是一款优秀的Servlet容器实现。</p><img src="/blog/2020/05/06/tomcat%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/pic3.png" srcset="/blog/img/loading.gif" class><p>阿里中间件团队：<a href="http://jm.taobao.org/about/" target="_blank" rel="noopener">http://jm.taobao.org/about/</a></p><p>很多公司都实现过自己的tomcat如aliTomcat :  <a href="https://help.aliyun.com/document_detail/90754.html" target="_blank" rel="noopener">https://help.aliyun.com/document_detail/90754.html</a></p><h3 id="网络基础知识"><a href="#网络基础知识" class="headerlink" title="网络基础知识"></a>网络基础知识</h3><img src="/blog/2020/05/06/tomcat%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/pic1.png" srcset="/blog/img/loading.gif" class><p>客户端的上层应用会通过Socket发送请求。Socket是应用层与TCP/IP协议族通信的中间软件抽象层，是一组接口。Socket会根据TCP/IP协议将数据发送到服务器，服务器再通过协议将内容封装，传递给上层应用处理。</p><h3 id="tomcat的基础结构"><a href="#tomcat的基础结构" class="headerlink" title="tomcat的基础结构"></a>tomcat的基础结构</h3><img src="/blog/2020/05/06/tomcat%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/pic2.png" srcset="/blog/img/loading.gif" class><p><strong>所需要的技术点</strong></p><ul><li>BIO模型</li><li>HTTP协议</li><li>Servlet</li><li>类加载</li></ul><h2 id="tomcat的简单实现"><a href="#tomcat的简单实现" class="headerlink" title="tomcat的简单实现"></a>tomcat的简单实现</h2><h3 id="建立连接池并获取请求内容"><a href="#建立连接池并获取请求内容" class="headerlink" title="建立连接池并获取请求内容"></a>建立连接池并获取请求内容</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServer</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ExecutorService executorService = Executors.newCachedThreadPool();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;        ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">8081</span>);        System.out.println(<span class="hljs-string">"socket服务器已启动"</span>);        <span class="hljs-keyword">while</span>(!serverSocket.isClosed())&#123;            Socket socket = serverSocket.accept();            executorService.execute(()-&gt;&#123;                <span class="hljs-keyword">try</span> &#123;                    InputStream inputStream = socket.getInputStream();                    System.out.println(<span class="hljs-string">"接收到请求"</span>);                    BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(inputStream, <span class="hljs-string">"utf-8"</span>));                    String msg = <span class="hljs-keyword">null</span>;                    StringBuffer requestInfo = <span class="hljs-keyword">new</span> StringBuffer();                    <span class="hljs-keyword">while</span> ((msg = reader.readLine()) != <span class="hljs-keyword">null</span>&amp;&amp;msg.length()!=<span class="hljs-number">0</span>) &#123;                        requestInfo.append(msg).append(<span class="hljs-string">"\r\n"</span>);                    &#125;                    System.out.println(requestInfo);                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;);        &#125;    &#125;&#125;</code></pre><p>使用浏览器请求接口，接收到的请求内容为</p><pre><code class="hljs groovy">GET <span class="hljs-regexp">/SerAreaSys HTTP/</span><span class="hljs-number">1.1</span><span class="hljs-string">Host:</span> <span class="hljs-string">localhost:</span><span class="hljs-number">8081</span><span class="hljs-string">Connection:</span> keep-aliveUpgrade-Insecure-<span class="hljs-string">Requests:</span> <span class="hljs-number">1</span>User-<span class="hljs-string">Agent:</span> Mozilla<span class="hljs-regexp">/5.0 (Macintosh; Intel Mac OS X 10_15_3) AppleWebKit/</span><span class="hljs-number">537.36</span> (KHTML, like Gecko) Chrome<span class="hljs-regexp">/81.0.4044.138 Safari/</span><span class="hljs-number">537.36</span><span class="hljs-string">Accept:</span> text<span class="hljs-regexp">/html,application/</span>xhtml+xml,application<span class="hljs-regexp">/xml;q=0.9,image/</span>webp,image<span class="hljs-regexp">/apng,*/</span>*;q=<span class="hljs-number">0.8</span>,application/signed-exchange;v=b3;q=<span class="hljs-number">0.9</span>Sec-Fetch-<span class="hljs-string">Site:</span> noneSec-Fetch-<span class="hljs-string">Mode:</span> navigateSec-Fetch-<span class="hljs-string">User:</span> ?1Sec-Fetch-Dest: documentAccept-<span class="hljs-string">Encoding:</span> gzip, deflate, brAccept-<span class="hljs-string">Language:</span> zh-CN,zh;q=<span class="hljs-number">0.9</span></code></pre><h3 id="解析请求内容"><a href="#解析请求内容" class="headerlink" title="解析请求内容"></a>解析请求内容</h3><img src="/blog/2020/05/06/tomcat%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/pic3.png" srcset="/blog/img/loading.gif" class><p><strong>请求</strong>：第一行一般包含请求方式、请求路径、协议类型中间以空格分隔，第二行为cookie信息，这些都属于请求头，如果为post请求，请求头隔一行后为requestBody请求体的内容。</p><p><strong>响应</strong>：第一行为协议版本、响应码、状态中间也是以空格分隔，第二行为响应内容的类型及字符编码，第三行为响应内容的长度这些内容为响应头，第四行为responseBody响应体。</p><h3 id="构造响应内容"><a href="#构造响应内容" class="headerlink" title="构造响应内容"></a>构造响应内容</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServer</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number">10</span>);    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">8081</span>);        System.out.println(<span class="hljs-string">"socket服务器已启动"</span>);        <span class="hljs-keyword">while</span> (!serverSocket.isClosed()) &#123;            Socket socket = serverSocket.accept();            executorService.execute(() -&gt; &#123;                <span class="hljs-keyword">try</span> &#123;                    InputStream inputStream = socket.getInputStream();                    System.out.println(<span class="hljs-string">"接收到请求"</span>);                    BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(inputStream, StandardCharsets.UTF_8));                    String msg = <span class="hljs-keyword">null</span>;                    StringBuffer requestInfo = <span class="hljs-keyword">new</span> StringBuffer();                    <span class="hljs-keyword">while</span> ((msg = reader.readLine()) != <span class="hljs-keyword">null</span>&amp;&amp;msg.length()!=<span class="hljs-number">0</span>) &#123;                        requestInfo.append(msg).append(<span class="hljs-string">"\r\n"</span>);                    &#125;                    System.out.println(requestInfo);                    String responseMsg = <span class="hljs-string">"处理成功"</span>;                    OutputStream outputStream = socket.getOutputStream();                    String responseInfo = <span class="hljs-string">"HTTP/1.1 200 OK"</span> +                            <span class="hljs-string">"\r\n"</span> +                            <span class="hljs-string">"Content-Type:text/html;charset=utf-8"</span> +                            <span class="hljs-string">"\r\n"</span> +                            <span class="hljs-string">"Content-Length:"</span> + responseMsg.length() +                            <span class="hljs-string">"\r\n"</span> +                            <span class="hljs-string">"\r\n"</span> +                            responseMsg;                    outputStream.write(responseInfo.getBytes(StandardCharsets.UTF_8));                    outputStream.flush();                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;);        &#125;    &#125;&#125;</code></pre><h3 id="部署项目"><a href="#部署项目" class="headerlink" title="部署项目"></a>部署项目</h3><p>servlet加载类</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProjectLoader</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Map <span class="hljs-title">load</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;        <span class="hljs-comment">//定义一个Map,存储项目信息</span>        Map&lt;String,Object&gt; webapp = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-comment">//servlet</span>        Map&lt;String, Servlet&gt; servletInstances = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-comment">//servlet-mapping</span>        Map&lt;String, String&gt; servletMapping = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-comment">//项目路径</span>        String webappPath =<span class="hljs-string">"D:\\work_public\\servletdemo\\out\\artifacts\\servletdemo_war_exploded\\WEB-INF"</span>;        <span class="hljs-comment">//JDK提供类加载器 URL</span>        URL classFile = <span class="hljs-keyword">new</span> URL(<span class="hljs-string">"file:"</span>+webappPath+<span class="hljs-string">"\\classes\\"</span>);        URLClassLoader urlClassLoader = <span class="hljs-keyword">new</span> URLClassLoader(<span class="hljs-keyword">new</span> URL[]&#123;classFile&#125;);        <span class="hljs-comment">//解析xml文件</span>        <span class="hljs-comment">//1.获取解析器</span>        SAXReader reader = <span class="hljs-keyword">new</span> SAXReader();        <span class="hljs-comment">//2.获取文档对象(xml)</span>        Document document = reader.read(<span class="hljs-keyword">new</span> File(webappPath+<span class="hljs-string">"\\web.xml"</span>));        <span class="hljs-comment">//3.获取根元素</span>        Element root = document.getRootElement();        <span class="hljs-comment">//4.获取根元素下的子元素</span>        List&lt;Element&gt; childElements = root.elements();        <span class="hljs-comment">//5.遍历子元素</span>        <span class="hljs-keyword">for</span> (Element element:childElements) &#123;            <span class="hljs-comment">//6.判断元素名称为servlet的元素</span>            <span class="hljs-keyword">if</span> (<span class="hljs-string">"servlet"</span>.equals(element.getName())) &#123;                <span class="hljs-comment">//获取servlet-name元素</span>                Element servletName = element.element(<span class="hljs-string">"servlet-name"</span>);                <span class="hljs-comment">//获取servlet-class元素</span>                Element servletClass = element.element(<span class="hljs-string">"servlet-class"</span>);                String strServletName = servletName.getText();                String strServletClass = servletClass.getText();                System.out.println(<span class="hljs-string">"servlet:"</span>+strServletName+<span class="hljs-string">"="</span>+strServletClass);                <span class="hljs-comment">//1.加载到JVM</span>                Class&lt;?&gt; classzz= urlClassLoader.loadClass(strServletClass);                <span class="hljs-comment">//2 创建对象实例(反射) -servlet;</span>                Servlet servlet  = (Servlet)classzz.newInstance();                <span class="hljs-comment">//web.xml的servlet实例化放入hashmap</span>                servletInstances.put(strServletName, servlet);            &#125;            <span class="hljs-comment">//7.判断元素名称为servlet-mapping的元素</span>            <span class="hljs-keyword">if</span> (<span class="hljs-string">"servlet-mapping"</span>.equals(element.getName())) &#123;                <span class="hljs-comment">//获取servlet-name元素</span>                Element servletName = element.element(<span class="hljs-string">"servlet-name"</span>);                <span class="hljs-comment">//获取url-pattern元素</span>                Element urlPattern = element.element(<span class="hljs-string">"url-pattern"</span>);                String strServletName = servletName.getText();                String strUrlPattern = urlPattern.getText();                <span class="hljs-comment">//web.xml的servlet的Mapping放入hashmap</span>                System.out.println(<span class="hljs-string">"servlet-mapping:"</span>+strUrlPattern+<span class="hljs-string">"="</span>+strServletName);                servletMapping.put(strUrlPattern,strServletName);            &#125;        &#125;        webapp.put(<span class="hljs-string">"servlet"</span>,servletInstances);        webapp.put(<span class="hljs-string">"servlet-mapping"</span>,servletMapping);        <span class="hljs-keyword">return</span>  webapp;    &#125;&#125;</code></pre><p>创建request对象</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> HttpServletRequest <span class="hljs-title">createRequest</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HttpServletRequest() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAuthType</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> Cookie[] getCookies() &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Cookie[<span class="hljs-number">0</span>];        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getDateHeader</span><span class="hljs-params">(String s)</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getHeader</span><span class="hljs-params">(String s)</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> Enumeration&lt;String&gt; <span class="hljs-title">getHeaders</span><span class="hljs-params">(String s)</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> Enumeration&lt;String&gt; <span class="hljs-title">getHeaderNames</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getIntHeader</span><span class="hljs-params">(String s)</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getMethod</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">"GET"</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPathInfo</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPathTranslated</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getContextPath</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getQueryString</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getRemoteUser</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isUserInRole</span><span class="hljs-params">(String s)</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> Principal <span class="hljs-title">getUserPrincipal</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getRequestedSessionId</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getRequestURI</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> StringBuffer <span class="hljs-title">getRequestURL</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getServletPath</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> HttpSession <span class="hljs-title">getSession</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> b)</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> HttpSession <span class="hljs-title">getSession</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">changeSessionId</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isRequestedSessionIdValid</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isRequestedSessionIdFromCookie</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isRequestedSessionIdFromURL</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isRequestedSessionIdFromUrl</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">authenticate</span><span class="hljs-params">(HttpServletResponse httpServletResponse)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">login</span><span class="hljs-params">(String s, String s1)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">logout</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> Collection&lt;Part&gt; <span class="hljs-title">getParts</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> Part <span class="hljs-title">getPart</span><span class="hljs-params">(String s)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> &lt;T extends HttpUpgradeHandler&gt; <span class="hljs-function">T <span class="hljs-title">upgrade</span><span class="hljs-params">(Class&lt;T&gt; aClass)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getAttribute</span><span class="hljs-params">(String s)</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> Enumeration&lt;String&gt; <span class="hljs-title">getAttributeNames</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getCharacterEncoding</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCharacterEncoding</span><span class="hljs-params">(String s)</span> <span class="hljs-keyword">throws</span> UnsupportedEncodingException </span>&#123;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getContentLength</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getContentLengthLong</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getContentType</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> ServletInputStream <span class="hljs-title">getInputStream</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getParameter</span><span class="hljs-params">(String s)</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> Enumeration&lt;String&gt; <span class="hljs-title">getParameterNames</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> String[] getParameterValues(String s) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String[<span class="hljs-number">0</span>];        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> Map&lt;String, String[]&gt; getParameterMap() &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getProtocol</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getScheme</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getServerName</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getServerPort</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> BufferedReader <span class="hljs-title">getReader</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getRemoteAddr</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getRemoteHost</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAttribute</span><span class="hljs-params">(String s, Object o)</span> </span>&#123;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeAttribute</span><span class="hljs-params">(String s)</span> </span>&#123;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> Locale <span class="hljs-title">getLocale</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> Enumeration&lt;Locale&gt; <span class="hljs-title">getLocales</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSecure</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> RequestDispatcher <span class="hljs-title">getRequestDispatcher</span><span class="hljs-params">(String s)</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getRealPath</span><span class="hljs-params">(String s)</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getRemotePort</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getLocalName</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getLocalAddr</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getLocalPort</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> ServletContext <span class="hljs-title">getServletContext</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> AsyncContext <span class="hljs-title">startAsync</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IllegalStateException </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> AsyncContext <span class="hljs-title">startAsync</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="hljs-keyword">throws</span> IllegalStateException </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAsyncStarted</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAsyncSupported</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> AsyncContext <span class="hljs-title">getAsyncContext</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> DispatcherType <span class="hljs-title">getDispatcherType</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;    &#125;;&#125;</code></pre><p>创建response对象</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> HttpServletResponse <span class="hljs-title">createResponse</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HttpServletResponse() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addCookie</span><span class="hljs-params">(Cookie cookie)</span> </span>&#123;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">containsHeader</span><span class="hljs-params">(String s)</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">encodeURL</span><span class="hljs-params">(String s)</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">encodeRedirectURL</span><span class="hljs-params">(String s)</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">encodeUrl</span><span class="hljs-params">(String s)</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">encodeRedirectUrl</span><span class="hljs-params">(String s)</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendError</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, String s)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendError</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendRedirect</span><span class="hljs-params">(String s)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDateHeader</span><span class="hljs-params">(String s, <span class="hljs-keyword">long</span> l)</span> </span>&#123;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addDateHeader</span><span class="hljs-params">(String s, <span class="hljs-keyword">long</span> l)</span> </span>&#123;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHeader</span><span class="hljs-params">(String s, String s1)</span> </span>&#123;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addHeader</span><span class="hljs-params">(String s, String s1)</span> </span>&#123;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setIntHeader</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> i)</span> </span>&#123;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addIntHeader</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> i)</span> </span>&#123;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setStatus</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setStatus</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, String s)</span> </span>&#123;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getStatus</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getHeader</span><span class="hljs-params">(String s)</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> Collection&lt;String&gt; <span class="hljs-title">getHeaders</span><span class="hljs-params">(String s)</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> Collection&lt;String&gt; <span class="hljs-title">getHeaderNames</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getCharacterEncoding</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getContentType</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> ServletOutputStream <span class="hljs-title">getOutputStream</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> PrintWriter <span class="hljs-title">getWriter</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCharacterEncoding</span><span class="hljs-params">(String s)</span> </span>&#123;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setContentLength</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setContentLengthLong</span><span class="hljs-params">(<span class="hljs-keyword">long</span> l)</span> </span>&#123;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setContentType</span><span class="hljs-params">(String s)</span> </span>&#123;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBufferSize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getBufferSize</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">flushBuffer</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">resetBuffer</span><span class="hljs-params">()</span> </span>&#123;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isCommitted</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reset</span><span class="hljs-params">()</span> </span>&#123;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLocale</span><span class="hljs-params">(Locale locale)</span> </span>&#123;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> Locale <span class="hljs-title">getLocale</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;    &#125;;&#125;</code></pre><p>最终的主方法</p><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//0、加载项目（类加载）、容器、HashMap</span>        Map&lt;String, Object&gt; webAppMap = ProjectLoader.load();<span class="hljs-comment">//        Map&lt;String, Object&gt; webAppMap = Collections.emptyMap();</span>        <span class="hljs-comment">//1、绑定端口，JDK提供的网络操作的API</span>        ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">8080</span>);        System.out.println(<span class="hljs-string">"服务器启动成功!"</span>);        <span class="hljs-comment">//在等待请求</span>        <span class="hljs-keyword">while</span> (!serverSocket.isClosed()) &#123;            <span class="hljs-comment">//2、等待请求，当有请求时将建立socket连接（建立客户端、服务端的连接（</span>            Socket socket = serverSocket.accept();            <span class="hljs-comment">//3、使用线程来处理请求</span>            executorService.execute(() -&gt; &#123;                        <span class="hljs-keyword">try</span> &#123;                            InputStream inputStream = socket.getInputStream();                            System.out.println(<span class="hljs-string">"收到请求："</span>);                            BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(inputStream, <span class="hljs-string">"utf-8"</span>));                            <span class="hljs-comment">//字符串</span>                            String msg = <span class="hljs-keyword">null</span>;                            StringBuilder requestInfo = <span class="hljs-keyword">new</span> StringBuilder();                            <span class="hljs-keyword">while</span> ((msg = reader.readLine()) != <span class="hljs-keyword">null</span>) &#123;                                <span class="hljs-keyword">if</span> (msg.length() == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;                                requestInfo.append(msg).append(<span class="hljs-string">"\r\n"</span>);                            &#125;                            System.out.println(requestInfo);                            <span class="hljs-comment">//对请求的头进行解析</span>                            <span class="hljs-comment">//获取请求的第一行</span>                            String firstLine = requestInfo.toString().split(<span class="hljs-string">"\r\n"</span>)[<span class="hljs-number">0</span>];                            System.out.println(firstLine);                            <span class="hljs-comment">//防止浏览器发空过的请求过来</span>                            <span class="hljs-keyword">if</span> (firstLine.length() &lt; <span class="hljs-number">1</span>) &#123;                                <span class="hljs-keyword">return</span>;                            &#125;                            String servletPath = firstLine.split(<span class="hljs-string">" "</span>)[<span class="hljs-number">1</span>];                            <span class="hljs-comment">//servlet映射</span>                            Map&lt;String, String&gt; servletMapping = (Map&lt;String, String&gt;) webAppMap.get(<span class="hljs-string">"servlet-mapping"</span>);                            <span class="hljs-comment">//Servlet实例</span>                            Map&lt;String, Object&gt; servletInstances = (Map&lt;String, Object&gt;) webAppMap.get(<span class="hljs-string">"servlet"</span>);                            <span class="hljs-comment">//是否有正确的url对应的Servlet</span>                            <span class="hljs-keyword">if</span> (servletMapping.containsKey(servletPath)) &#123;                                String servletName = servletMapping.get(servletPath);                                HttpServlet httpServlet = (HttpServlet) servletInstances.get(servletName);                                HttpServletRequest httpServletRequest = createRequest();                                HttpServletResponse httpServletResponse = createResponse();                                httpServlet.service(httpServletRequest, httpServletResponse);                                OutputStream outputStream = socket.getOutputStream();                                <span class="hljs-keyword">byte</span>[] response = <span class="hljs-string">"请求成功!"</span>.getBytes();                                outputStream.write(<span class="hljs-string">"HTTP/1.1 200 OK \r\n"</span>.getBytes());                                outputStream.write(<span class="hljs-string">"Content-Type:text/html;charset=utf-8 \r\n"</span>.getBytes());                                outputStream.write((<span class="hljs-string">"Content-Length:"</span> + response.length + <span class="hljs-string">"\r\n"</span>).getBytes());                                outputStream.write(<span class="hljs-string">"\r\n"</span>.getBytes());                                outputStream.write(response);                                outputStream.flush();                                System.out.println(<span class="hljs-string">"----END"</span>);                            &#125; <span class="hljs-keyword">else</span> &#123;                                <span class="hljs-comment">//要与浏览器进行“互动” ,HTTP 协议</span>                                OutputStream outputStream = socket.getOutputStream();                                <span class="hljs-keyword">byte</span>[] response = <span class="hljs-string">"对不起，没有对应的Servlet请求信息!"</span>.getBytes();                                outputStream.write(<span class="hljs-string">"HTTP/1.1 200 OK \r\n"</span>.getBytes());                                outputStream.write(<span class="hljs-string">"Content-Type:text/html;charset=utf-8 \r\n"</span>.getBytes());                                outputStream.write((<span class="hljs-string">"Content-Length:"</span> + response.length + <span class="hljs-string">"\r\n"</span>).getBytes());                                outputStream.write(<span class="hljs-string">"\r\n"</span>.getBytes());                                outputStream.write(response);                                outputStream.flush();                                System.out.println(<span class="hljs-string">"----END"</span>);                            &#125;                        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                            e.printStackTrace();                        &#125; <span class="hljs-keyword">catch</span> (ServletException e1) &#123;                            e1.printStackTrace();                        &#125;                    &#125;            );        &#125;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>tomcat</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tomcat</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tomcat嵌入式与性能优化</title>
    <link href="/blog/2020/05/06/tomcat%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <url>/blog/2020/05/06/tomcat%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="嵌入式tomcat"><a href="#嵌入式tomcat" class="headerlink" title="嵌入式tomcat"></a>嵌入式tomcat</h2><p>一般的tomcat启动中的组件非常多，启动流程步骤比较复杂，但是往往我们一般就只需要简单快速的部署一个Web项目，所以简单实用的嵌入式Tomcat就诞生而来。</p><p><strong>部署复杂度</strong></p><p>如果按照传统部署，我们需要下载Tomcat,同时需要配置服务器，同时还需要修改端口，同时也要避免应用系统的jar包与服务器中存在的lib包的冲突，所有的这些都会增加部署的复杂度，并且这种配置大部分还是一次性的，不可重用。如果你遇到大规模的服务器集群环境（部署N多个应用）时，会增加我们的运维成本，如果按照嵌入式启动，这种方式几乎是一键式的，可以把以上问题轻松的解决。</p><p><strong>架构约束</strong></p><p>Tomcat启动的时候默认不单单只启动了HTTP协议，还有AJP协议等等，如果我们就只想简简单单的启动一个HTTP服务，同时不想启动那些多组件，可以使用嵌入式Tomcat，避免在部署启动时的架构约束。</p><p><strong>微服务架构</strong></p><p>现在微服务已经是主流的架构，其中微服务中每项服务都拥有自己的进程并利用轻量化机制实现通讯。这些服务都是围绕业务功能建立，可以自动化部署或独立部署。将微服务架构与Tomcat技术相结合，可以轻松将系统部署到云服务器上。当前SpringBoot支持的嵌入式服务器组件就是Tomcat。</p><h2 id="嵌入式启动实战"><a href="#嵌入式启动实战" class="headerlink" title="嵌入式启动实战"></a>嵌入式启动实战</h2><p>pom文件中</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--嵌入式Tomcat --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>tomcat-embed-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.5.34<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!--嵌入式Tomcat的JSP 支持--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>tomcat-embed-jasper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.5.34<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p> 启动类</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 手动的创建一个servlet，然后加入到tomcat中</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServletDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//自定义的一个Servlet(专门处理http请求)</span>        HttpServlet httpServlet = <span class="hljs-keyword">new</span> HttpServlet() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">(ServletRequest req, ServletResponse res)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;                res.getWriter().write(<span class="hljs-string">"hello world!"</span>);            &#125;        &#125;;        <span class="hljs-comment">//引入嵌入式Tomcat</span>        Tomcat tomcat = <span class="hljs-keyword">new</span> Tomcat();        <span class="hljs-comment">//部署应用的context</span>        Context context = tomcat.addContext(<span class="hljs-string">"/demo"</span>,<span class="hljs-keyword">null</span>);        <span class="hljs-comment">//相当于往应用中添加Servlet</span>        tomcat.addServlet(context,<span class="hljs-string">"hello"</span>,httpServlet);        <span class="hljs-comment">//相当于添加了servletMapping 映射信息</span>        context.addServletMappingDecoded(<span class="hljs-string">"/hello"</span>,<span class="hljs-string">"hello"</span>);        <span class="hljs-comment">//启动Tomcat  ---生命周期</span>        tomcat.init();        tomcat.start();        <span class="hljs-comment">//用于阻塞Tomcat,等待请求过来</span>        tomcat.getServer().await();        <span class="hljs-comment">//http://localhost:8080/demo/hello</span>    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 要用嵌入式启动的方式启动一个SpringMVc的项目</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebAppDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span>  Exception</span>&#123;        Tomcat tomcat = <span class="hljs-keyword">new</span> Tomcat();        tomcat.addWebapp(<span class="hljs-string">"/ref"</span>,<span class="hljs-string">"D:\\work_tomcat\\ref-comet"</span>);        tomcat.getConnector().setPort(<span class="hljs-number">80</span>);        tomcat.init();        tomcat.start();        tomcat.getServer().await();    &#125;&#125;</code></pre><h2 id="tomcat性能优化"><a href="#tomcat性能优化" class="headerlink" title="tomcat性能优化"></a>tomcat性能优化</h2><h3 id="server-xml优化"><a href="#server-xml优化" class="headerlink" title="server.xml优化"></a>server.xml优化</h3><p>tomcat其实自带了参数说明文档</p><img src="/blog/2020/05/06/tomcat%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/pic1.png" srcset="/blog/img/loading.gif" class><p>这时会出现一个英文的tomcat配置参数文档界面，这个界面中包含了所有tomcat配置信息。</p><img src="/blog/2020/05/06/tomcat%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/pic2.png" srcset="/blog/img/loading.gif" class><h4 id="Connector连接器优化"><a href="#Connector连接器优化" class="headerlink" title="Connector连接器优化"></a>Connector连接器优化</h4><ul><li><p>IO模型优化策略：连接器模式改为NIO模式,NIO模式最大化压榨了CPU，把时间片更好利用起来，NIO适合大量长连接。</p></li><li><p>最大线程优化策略：maxThreads属性默认设置为200，可以根据生产计算机上的处理器数量线性增加。在具有四个处理器的计算机上，将此值设置为800到1000之间的任何值都不会导致问题。如果配置的数量最终远远超过所需的线程数，则当服务器负载较低时，线程池将自然缩减线程数。</p></li><li><p>压缩gzip连接器传输：客户端和服务器之间的任何主要是文本的通信，无论是HTML，XML还是简单的Unicode，都可以使用简单的标准GZIP算法定期压缩高达90％。这可以对减少网络流量产生巨大影响，允许响应更快地发送回客户端，同时允许更多网络带宽可用于其他网络繁重的应用程序。设置方式为：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">port</span>=<span class="hljs-string">"80"</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">"HTTP/1.1"</span></span><span class="hljs-tag">      <span class="hljs-attr">connectionTimeout</span>=<span class="hljs-string">"20000"</span></span><span class="hljs-tag">      <span class="hljs-attr">redirectPort</span>=<span class="hljs-string">"8443"</span> <span class="hljs-attr">executor</span>=<span class="hljs-string">"tomcatThreadPool"</span> <span class="hljs-attr">URIEncoding</span>=<span class="hljs-string">"utf-8"</span></span><span class="hljs-tag">            <span class="hljs-attr">compression</span>=<span class="hljs-string">"on"</span></span><span class="hljs-tag">            <span class="hljs-attr">compressionMinSize</span>=<span class="hljs-string">"50"</span> <span class="hljs-attr">noCompressionUserAgents</span>=<span class="hljs-string">"gozilla, traviata"</span></span><span class="hljs-tag">            <span class="hljs-attr">compressableMimeType</span>=<span class="hljs-string">"text/html,text/xml,text/javascript,text/css,text/plain"</span> /&gt;</span></code></pre></li></ul><h4 id="配置Executor线程池"><a href="#配置Executor线程池" class="headerlink" title="配置Executor线程池"></a>配置Executor线程池</h4><p>Executor必须出现在Connector之前。配置方式如下：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Executor</span> </span>    name="tomcatThreadPool"&lt;!--线程名称--&gt;    namePrefix="catalina-exec-"    maxThreads="150"<span class="hljs-comment">&lt;!--最大处理连接数线程--&gt;</span>    minSpareThreads="4" /&gt;<span class="hljs-comment">&lt;!--保留最少线程数--&gt;</span><span class="hljs-comment">&lt;!-- 将原有的Connector 替换为带有线程池的Connector如下,其实servlet.xml已经有了,只要打开就可以了,将原来的去掉   --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> </span><span class="hljs-tag">    <span class="hljs-attr">executor</span>=<span class="hljs-string">"tomcatThreadPool"</span></span><span class="hljs-tag">    <span class="hljs-attr">port</span>=<span class="hljs-string">"8080"</span></span><span class="hljs-tag">    <span class="hljs-attr">protocol</span>=<span class="hljs-string">"HTTP/1.1"</span></span><span class="hljs-tag">    <span class="hljs-attr">connectionTimeout</span>=<span class="hljs-string">"20000"</span></span><span class="hljs-tag">    <span class="hljs-attr">redirectPort</span>=<span class="hljs-string">"8443"</span></span>    minProcessors="5"&lt;!-- 同时处理请求的最小数 --&gt;    maxProcessors="75"<span class="hljs-comment">&lt;!-- 同时处理请求的最大数 --&gt;</span>    acceptCount="1000" /&gt;<span class="hljs-comment">&lt;!-- 接受最大并发数量 ,超过这个数量就会返回连接被拒绝 --&gt;</span></code></pre><p>详细的配置可以在tomcat配置信息的Executor页面中查看。</p><h4 id="去掉value访问tomcat记录"><a href="#去掉value访问tomcat记录" class="headerlink" title="去掉value访问tomcat记录"></a>去掉value访问tomcat记录</h4><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Valve</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"org.apache.catalina.valves.AccessLogValve"</span> <span class="hljs-attr">directory</span>=<span class="hljs-string">"logs"</span></span><span class="hljs-tag">               <span class="hljs-attr">prefix</span>=<span class="hljs-string">"localhost_access_log"</span> <span class="hljs-attr">suffix</span>=<span class="hljs-string">".txt"</span></span><span class="hljs-tag">               <span class="hljs-attr">pattern</span>=<span class="hljs-string">"%h %l %u %t "</span>%<span class="hljs-attr">r</span>" %<span class="hljs-attr">s</span> %<span class="hljs-attr">b</span>" /&gt;</span></code></pre><p>可以删除servler.xml中的value节点，来删除日志访问记录以提高性能。</p><h4 id="关闭自动重载，热部署方式"><a href="#关闭自动重载，热部署方式" class="headerlink" title="关闭自动重载，热部署方式"></a>关闭自动重载，热部署方式</h4><p>关闭自动重载，默认为true（不同版本中有差异），自动加载会增加运行是 开销并且很容易内存溢出。</p><h3 id="web-xml优化"><a href="#web-xml优化" class="headerlink" title="web.xml优化"></a>web.xml优化</h3><h4 id="去掉不必要的servlet"><a href="#去掉不必要的servlet" class="headerlink" title="去掉不必要的servlet"></a>去掉不必要的servlet</h4><p>如果当前应用是REST应用（微服务），可以去掉不必要的资源如JspServlet和seesion。</p><h4 id="JspServlet优化"><a href="#JspServlet优化" class="headerlink" title="JspServlet优化"></a>JspServlet优化</h4><ol><li>checkInterval - 如果“development”属性为false且“checkInterval”大于0，则使用后台编译。“checkInterval”是查看JSP页面(包括其附属文件)是否需要重新编译的两次检查时间间隔（单位：秒）。缺省值为0秒。</li><li>classdebuginfo - 类文件在编译时是否显示调试(debugging)信息？ true 或false，缺省为true。</li><li>classpath - 编译servlet时要使用的类路径，当ServletContext 属性org.apache.jasper.Constants.SERVLET_CLASSPATH未设置的情况下，该参数才有效。在Tomcat中使用到Jasper时，该属性总被设置。缺省情况下，该路径基于你当前的web应用动态生成。</li><li>compiler – Ant将要使用的JSP页面编译器，请查阅Ant文档获取更多信息。如果该参数未设置，那么默认的Eclipse JDT Java编译器将被用来代替Ant。没有缺省值。</li><li>compilerSourceVM - 编译源文件时采用哪一个JDK版本？(缺省为 JDK 1.4)</li><li>compilerTargetVM - 运行类文件时采用哪一个JDK版本？(缺省为 JDK 1.4)</li><li>development - 是否让Jasper用于开发模式？如果是，检查JSPs修改的频率，将通过设置modificationTestInterval 参数来完成。true 或false，缺省为true。</li><li>displaySourceFragment - 异常信息中是否包含出错的源代码片段？true 或false，缺省为true。</li><li>dumpSmap - JSR45调试的SMAP信息是否转存到文件？true 或false，缺省为false。当suppressSmap 为true时，该参数为false。</li><li>enablePooling - 确定是否共享标签处理器，true或false，缺省为true。</li><li>engineOptionsClass - 允许指定的类来配置Jasper。如果没有指定，则使用默认的Servlet内置参数(EmbeddedServletOptions)。</li><li>errorOnUseBeanInvalidClassAttribute - 在一个useBean action中，当类属性的值不是一个合法的bean class时，Jasper是否抛出异常？true或false，缺省为true。</li><li>fork - 是否让Ant派生出JSP页面多个编译，它们将运行在一个独立于Tomcat的JVM上。true 或者false, 缺省为true。</li><li>enStringAsCharArray - 是否把字符串转换为字符数组？在某些情况下会改善性能。缺省为false.</li><li>eClassId - 当使用标签时，发送给Internet Explorer的class-id的值。缺省为：8AD9C840-044E-11D1-B3E9-00805F499D93。</li><li>javaEncoding - 生成java源文件时采用的Java文件编码。缺省为UTF-8。</li><li>keepgenerated - 是否保存每个页面生成的java源代码，而不删除。true 或 false，缺省为true。</li><li>mappedfile - 是否对每个输入行都用一条print语句来生成静态内容，以方便调试。true 或 false，缺省为true。</li><li>modificationTestInterval - 检查JSP页面修改的间隔时间（单位：秒），在间隔时间内，JSP及其包含的页面将不会检查。当间隔时间为0时，JSP每一次访问都会被检查。仅仅适用于开发模式（参数development为true）。缺省为4秒。从JSP每次开始访问开始计时，N秒以后检查，变化就编译，每次访问都刷新开始时间，默认4秒</li><li>scratchdir - 当编译JSP页面时使用的scratch 目录。缺省为当前WEB应用的工作目录。</li><li>suppressSmap - 是否禁止JSR45调试时生成SMAP信息？true 或 false，缺省为false。</li><li>trimSpaces - 是否去掉模板文本中行为和指令之间的空格。缺省为false。 · xpoweredBy - 确定生成的Servlet是否加上X-Powered-By 响应头？true 或 false，缺省为false。</li></ol><h2 id="tomcat常见问题解决"><a href="#tomcat常见问题解决" class="headerlink" title="tomcat常见问题解决"></a>tomcat常见问题解决</h2><h3 id="迁移指南"><a href="#迁移指南" class="headerlink" title="迁移指南"></a>迁移指南</h3><img src="/blog/2020/05/06/tomcat%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/pic3.png" srcset="/blog/img/loading.gif" class><h3 id="安全通告"><a href="#安全通告" class="headerlink" title="安全通告"></a>安全通告</h3><img src="/blog/2020/05/06/tomcat%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/pic4.png" srcset="/blog/img/loading.gif" class><h2 id="tomcat常见的面试题"><a href="#tomcat常见的面试题" class="headerlink" title="tomcat常见的面试题"></a>tomcat常见的面试题</h2><h3 id="tomcat有哪几种部署方式？"><a href="#tomcat有哪几种部署方式？" class="headerlink" title="tomcat有哪几种部署方式？"></a>tomcat有哪几种部署方式？</h3><p><strong>隐式部署</strong></p><p>直接丢文件夹、war、jar到webapps目录，tomcat会根据文件夹名称自动生成虚拟路径，简单，但是需要重启Tomcat服务器，包括要修改端口和访问路径的也需要重启。</p><p><strong>显式部署</strong></p><p>添加context元素</p><p>server.xml中的Host加入一个Context（指定路径和文件地址），例如：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Host</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"localhost"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Context</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/comet"</span> <span class="hljs-attr">docBase</span>=<span class="hljs-string">"D:\work_tomcat\ref-comet.war"</span> /&gt;</span></code></pre><p>即/comet 这个虚拟路径映射到了D:\work_tomcat\ref-comet目录下(war会解压成文件)，修改完servler.xml需要重启tomcat 服务器。</p><p>创建xml文件</p><p>在conf/Catalina/localhost中创建xml文件，访问路径为文件名，例如：</p><p>在localhost目录下新建demo.xml，内容为：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Context</span> <span class="hljs-attr">docBase</span>=<span class="hljs-string">"D:\work_tomcat\ref-comet"</span> /&gt;</span></code></pre><p>不需要写path，虚拟目录就是文件名demo，path默认为/demo，添加demo.xml不需要重启 tomcat服务器。</p><p><strong>三种方式比较：</strong></p><ul><li><p>隐式部署：可以很快部署,需要人手动移动Web应用到webapps下，在实际操作中不是很人性化</p></li><li><p>添加context元素 : 配置速度快,需要配置两个路径，如果path为空字符串，则为缺省配置,每次修改server.xml文件后都要重新启动Tomcat服务器，重新部署.</p></li><li><p>创建xml文件:服务器后台会自动部署，修改一次后台部署一次，不用重复启动Tomcat服务器,该方式显得更为智能化。</p></li></ul><h3 id="tomcat核心组件是哪些？"><a href="#tomcat核心组件是哪些？" class="headerlink" title="tomcat核心组件是哪些？"></a>tomcat核心组件是哪些？</h3><p>Tomcat的核心组件是链接器(connector)和容器(Container)，链接器(connector)封装了底层的网络请求(Socket请求及相应处理)，提供了统一的接口。容器(Container)则专注处理Servlet，Tomcat本质上就是Servlet容器。</p><h3 id="tomcat的Valve"><a href="#tomcat的Valve" class="headerlink" title="tomcat的Valve"></a>tomcat的Valve</h3><p>在一个大的组件中直接处理这些繁杂的逻辑处理,使用管道（pipeline）可以把把多个对象连接起来，而Valve(阀门)整体看起来就像若干个阀门嵌套在管道中，而处理逻辑放在阀门上。 </p><p>管道(Pipeline)就像一个工厂中的生产线，负责调配工人（valve）的位置，valve则是生产线上负责不同操作的工人。</p><h3 id="tomcat-有哪几种Connector-运行模式-优化-？"><a href="#tomcat-有哪几种Connector-运行模式-优化-？" class="headerlink" title="tomcat 有哪几种Connector 运行模式(优化)？"></a>tomcat 有哪几种Connector 运行模式(优化)？</h3><ol><li>bio(blocking I/O) 同步阻塞I/O （tomcat8.5版本已经移除）</li><li>nio(non-blocking I/O) 同步非阻塞I/O</li><li>Nio2/AIO  异步非阻塞I/0</li><li>apr(Apache Portable Runtime/Apache可移植运行库)</li></ol><p>对于I/0选择，要根据业务场景来定，一般高并发场景下，APR和NIO2的性能要优于NIO和BIO，（linux操作系统支持的NIO2由于是一个假的，并没有真正实现AIO，所以一般linux上推荐使用NIO，如果是APR的话，需要安装APR库，而Windows上默认安装了），所以在8.5的版本中默认是NIO。</p><h3 id="tomcat容器是如何创建servlet类实例？用到了什么原理？"><a href="#tomcat容器是如何创建servlet类实例？用到了什么原理？" class="headerlink" title="tomcat容器是如何创建servlet类实例？用到了什么原理？"></a>tomcat容器是如何创建servlet类实例？用到了什么原理？</h3><p>当容器启动时，会读取在webapps目录下所有的web应用中的web.xml文件，然后对xml文件进行解析，并读取servlet注册信息。然后，将每个应用中注册的servlet类都进行加载，并通过反射的方式实例化（也有可能是在第一次请求时实例化）。</p><h3 id="tomcat中JVM如何调优"><a href="#tomcat中JVM如何调优" class="headerlink" title="tomcat中JVM如何调优"></a>tomcat中JVM如何调优</h3><p>一般我们优化启动时的堆内存设置,Windows下,在文件{tomcat_home}/bin/catalina.bat，Unix下，在文件$CATALINA_HOME/bin/catalina.sh的前面，增加如下设置：</p><pre><code class="hljs ini"><span class="hljs-attr">JAVA_OPTS</span>=”‘<span class="hljs-variable">$JAVA_OPTS</span>” -Xms[初始化内存大小] -Xmx[可以使用的最大内存]</code></pre><p>一般说来，你应该使用物理内存的 80% 作为堆大小。建议设置为70％；建议设置[[初始化内存大小]等于[可以使用的最大内存]，这样可以减少平凡分配堆而降低性能。</p><h3 id="tomcat中类加载的顺序"><a href="#tomcat中类加载的顺序" class="headerlink" title="tomcat中类加载的顺序"></a>tomcat中类加载的顺序</h3><p>当应用需要到某个类时，则会按照下面的顺序进行类加载：</p><ol><li><p>使用bootstrap引导类加载器加载</p></li><li><p>使用system系统类加载器加载</p></li><li><p>使用应用类加载器在WEB-INF/classes中加载</p></li><li><p>使用应用类加载器在WEB-INF/lib中加载</p></li><li><p>使用common类加载器在CATALINA_HOME/lib中加载</p></li></ol><h3 id="什么是双亲委派模型？"><a href="#什么是双亲委派模型？" class="headerlink" title="什么是双亲委派模型？"></a>什么是双亲委派模型？</h3><p><strong>定义：</strong>双亲委派模型的工作过程为：如果一个类加载器收到了类请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父加载器去完成，每一层都是如此，因此所有类加载的请求都会传到启动类加载器，只有当父加载器无法完成该请求时，子加载器才去自己加载。</p><p><strong>实现方式：</strong>该模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。子类加载器不是以继承的关系来实现，而是通过组合关系来复用父加载器的代码。</p><p><strong>意义：</strong>好处双亲委派模型的好处就是java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如：Object,无论那个类加载器去加载该类，最终都是由启动类加载器进行加载的，因此Object类在程序的各种类加载环境中都是一个类。如果不用改模型，那么java.lang.Object类存放在classpath中，那么系统中就会出现多个Object类，程序变得很混乱。</p><h3 id="既然tomcat不遵循双亲委派机制，那么如果我自己定义一个恶意的HashMap，会不会有风险呢？"><a href="#既然tomcat不遵循双亲委派机制，那么如果我自己定义一个恶意的HashMap，会不会有风险呢？" class="headerlink" title="既然tomcat不遵循双亲委派机制，那么如果我自己定义一个恶意的HashMap，会不会有风险呢？"></a>既然tomcat不遵循双亲委派机制，那么如果我自己定义一个恶意的HashMap，会不会有风险呢？</h3><p>不会有风险，如果有，Tomcat都运行这么多年了，tomcat不遵循双亲委派机制，只是自定义的webAppclassLoader不遵循，但上层的类加载器还是遵守双亲委派的，</p>]]></content>
    
    
    <categories>
      
      <category>tomcat</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tomcat</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tomcat源码解析</title>
    <link href="/blog/2020/04/30/tomcat%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/blog/2020/04/30/tomcat%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="tomcat源码目录"><a href="#tomcat源码目录" class="headerlink" title="tomcat源码目录"></a>tomcat源码目录</h2><ul><li><p>catalina目录：catalina包含所有的Servlet容器实现，以及涉及到安全、会话、集群、部署管理Servlet容器的各个方面，同时，它还包含了启动入口。</p></li><li><p>coyote目录：coyote是Tomcat链接器框架的名称，是Tomcat服务器提供的客户端访问的外部接口，客户端通过Coyote与服务器建立链接、发送请求并接收响应。</p></li><li><p>El目录，提供java表达式语言</p></li><li><p>Jasper模块提供JSP引擎</p></li><li><p>Naming模块提供JNDI的服务</p></li><li><p>Juli提供服务器日志的服务</p></li><li><p>tomcat提供外部调用的接口api</p></li></ul><h2 id="tomcat组件的生命周期管理"><a href="#tomcat组件的生命周期管理" class="headerlink" title="tomcat组件的生命周期管理"></a>tomcat组件的生命周期管理</h2><p>tomcat的架构设计是清晰的、模块化、它拥有很多组件，加入在启动Tomcat时一个一个组件启动，很容易遗漏组件，同时还会对后面的动态组件拓展带来麻烦。如果采用我们传统的方式的话，组件在启动过程中如果发生异常，会很难管理，比如你的下一个组件调用了start()方法，但是如果它的上级组件还没有start()甚至还没有init()的话，Tomcat的启动会非常难管理，因此，Tomcat的设计者提出一个解决方案：使用生命周期统一接口Lifecycle定义一些状态常量，然后将启动、停止、关闭及所有与生命周期相关的方法都组织到一起，这样就可以很方便管理tomcat各个容器组件的生命周期。</p><p>LifecycleBase实现了Lifecycle接口，在init()方法中初始化之前会进行状态检查：</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> LifecycleException </span>&#123;    <span class="hljs-comment">//防止组件启动时状态不对</span>    <span class="hljs-keyword">if</span> (!state.equals(LifecycleState.NEW)) &#123;        invalidTransition(Lifecycle.BEFORE_INIT_EVENT);    &#125;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">//设置初始化状态</span>        setStateInternal(LifecycleState.INITIALIZING, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);        initInternal();        <span class="hljs-comment">//设置初始化完成</span>        setStateInternal(LifecycleState.INITIALIZED, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;        handleSubClassException(t, <span class="hljs-string">"lifecycleBase.initFail"</span>, toString());    &#125;&#125;</code></pre><p>init()方法中会调用子类的initInternal()方法，这里使用了模版方法设计模式，LifecycleBase为骨架类，initInternal()的具体实现在子类中，spring中也使用了这种设计模式。</p><p>start()方法中同样会进行相应的判断。</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> LifecycleException </span>&#123;    <span class="hljs-comment">// 统一进行生命周期的管理</span>    <span class="hljs-keyword">if</span> (LifecycleState.STARTING_PREP.equals(state) || LifecycleState.STARTING.equals(state) ||            LifecycleState.STARTED.equals(state)) &#123;        <span class="hljs-keyword">if</span> (log.isDebugEnabled()) &#123;            Exception e = <span class="hljs-keyword">new</span> LifecycleException();            log.debug(sm.getString(<span class="hljs-string">"lifecycleBase.alreadyStarted"</span>, toString()), e);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (log.isInfoEnabled()) &#123;            log.info(sm.getString(<span class="hljs-string">"lifecycleBase.alreadyStarted"</span>, toString()));        &#125;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-comment">// 检查组件生命周期状态</span>    <span class="hljs-keyword">if</span> (state.equals(LifecycleState.NEW)) &#123;        init();    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state.equals(LifecycleState.FAILED)) &#123;        stop();    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!state.equals(LifecycleState.INITIALIZED) &amp;&amp;            !state.equals(LifecycleState.STOPPED)) &#123;        invalidTransition(Lifecycle.BEFORE_START_EVENT);    &#125;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// 设置组件状态</span>        setStateInternal(LifecycleState.STARTING_PREP, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);        <span class="hljs-comment">// 调用具体实现类的方法</span>        startInternal();        <span class="hljs-comment">// 统一进行生命周期的管理</span>        <span class="hljs-keyword">if</span> (state.equals(LifecycleState.FAILED)) &#123;            <span class="hljs-comment">// 失败，调用stop()方法完成清理</span>            stop();        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!state.equals(LifecycleState.STARTING)) &#123;            <span class="hljs-comment">// 不是已经在启动的状态</span>            invalidTransition(Lifecycle.AFTER_START_EVENT);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 设置组件状态</span>            setStateInternal(LifecycleState.STARTED, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);        &#125;    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;        <span class="hljs-comment">// This is an 'uncontrolled' failure so put the component into the</span>        <span class="hljs-comment">// FAILED state and throw an exception.</span>        handleSubClassException(t, <span class="hljs-string">"lifecycleBase.startFail"</span>, toString());    &#125;&#125;</code></pre><p>tomcat内部架构中各个核心组件有包含与被包含关系，例如：Server包含了Service，Service又包含了Container和Connector，这个结构有一点像数据结构中的树，树的根结点没有父节点，其他节点有且仅有一个父节点，每一个父节点有0至多个子节点。所以，我们可以通过父容器启动它的子容器，这样只要启动根容器，就可以把其他所有的容器都启动，从而达到了统一的启动，停止、关闭的效果。</p><h2 id="tomcat组件分析"><a href="#tomcat组件分析" class="headerlink" title="tomcat组件分析"></a>tomcat组件分析</h2><h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><p>继承结构：</p><img src="/blog/2020/04/30/tomcat%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/pic6.png" srcset="/blog/img/loading.gif" class><p>Server是tomcat最顶层的容器，代表整个服务器，Tomcat中的标准实现为StandardServer类。</p><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>继承结构：</p><img src="/blog/2020/04/30/tomcat%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/pic7.png" srcset="/blog/img/loading.gif" class><p>其中LifecycleMBeanBase用于监督对象状态。</p><p>Service中请求监听和请求处理分开为两个模块：</p><img src="/blog/2020/04/30/tomcat%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/pic8.png" srcset="/blog/img/loading.gif" class><p>Connector负责请求监听，Container负责请求处理，一个Service可以有多个Connector，但只能有一个Container。</p><h3 id="Connector"><a href="#Connector" class="headerlink" title="Connector"></a>Connector</h3><img src="/blog/2020/04/30/tomcat%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/pic8.png" srcset="/blog/img/loading.gif" class><p>Connector使用ProtocolHandler来处理请求，ProtocolHandler包含三个部件：</p><ul><li>Endpoint：用来处理底层的Scoket的网络连接。</li><li>Processor：用于将Endpoint接收到的Socket封装为Request</li><li>Adapter：作为适配器将Reqeust将为ServletRequest交给Container进行具体的处理。</li></ul><h3 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h3><img src="/blog/2020/04/30/tomcat%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/pic9.png" srcset="/blog/img/loading.gif" class><ul><li>Engine：引擎，在servler.xml中定义了一个名为Catalina的Engline，只能有一个。</li><li>Host：站点、虚拟主机，一个Engline包含多个Host的设计，使得一个服务器实例可以承担多个域名的服务，是很灵活的设计</li><li>Context：应用，默认配置下webapps下的每个目录都是一个应用。</li><li>Wrapper：一个Servlet。</li></ul><h2 id="tomcat启动流程"><a href="#tomcat启动流程" class="headerlink" title="tomcat启动流程"></a>tomcat启动流程</h2><p>tomcat组件的启动流程：</p><img src="/blog/2020/04/30/tomcat%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/pic1.png" srcset="/blog/img/loading.gif" class><h3 id="入口类Bootstrap"><a href="#入口类Bootstrap" class="headerlink" title="入口类Bootstrap"></a>入口类Bootstrap</h3><p>start.sh会执行catalina.sh，catalina.sh会调用Bootstrap类中的main()方法。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>&#123;    <span class="hljs-comment">//初始化阶段 init()方法</span>    <span class="hljs-keyword">synchronized</span> (daemonLock) &#123;        <span class="hljs-keyword">if</span> (daemon == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">// Don't set daemon until init() has completed</span>            Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();            <span class="hljs-keyword">try</span> &#123;                bootstrap.init();            &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;                handleThrowable(t);                t.printStackTrace();                <span class="hljs-keyword">return</span>;            &#125;            daemon = bootstrap;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// When running as a service the call to stop will be on a new</span>            <span class="hljs-comment">// thread so make sure the correct class loader is used to</span>            <span class="hljs-comment">// prevent a range of class not found exceptions.</span>            Thread.currentThread().setContextClassLoader(daemon.catalinaLoader);        &#125;    &#125;    <span class="hljs-comment">//运行阶段 start()</span>    <span class="hljs-keyword">try</span> &#123;        String command = <span class="hljs-string">"start"</span>;        <span class="hljs-keyword">if</span> (args.length &gt; <span class="hljs-number">0</span>) &#123;            command = args[args.length - <span class="hljs-number">1</span>];        &#125;        <span class="hljs-keyword">if</span> (command.equals(<span class="hljs-string">"startd"</span>)) &#123;            args[args.length - <span class="hljs-number">1</span>] = <span class="hljs-string">"start"</span>;            daemon.load(args);            daemon.start();        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (command.equals(<span class="hljs-string">"stopd"</span>)) &#123;            args[args.length - <span class="hljs-number">1</span>] = <span class="hljs-string">"stop"</span>;            daemon.stop();        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (command.equals(<span class="hljs-string">"start"</span>)) &#123;            daemon.setAwait(<span class="hljs-keyword">true</span>);            daemon.load(args);            daemon.start();            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == daemon.getServer()) &#123;                System.exit(<span class="hljs-number">1</span>);            &#125;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (command.equals(<span class="hljs-string">"stop"</span>)) &#123;            daemon.stopServer(args);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (command.equals(<span class="hljs-string">"configtest"</span>)) &#123;            daemon.load(args);            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == daemon.getServer()) &#123;                System.exit(<span class="hljs-number">1</span>);            &#125;            System.exit(<span class="hljs-number">0</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            log.warn(<span class="hljs-string">"Bootstrap: command \""</span> + command + <span class="hljs-string">"\" does not exist."</span>);        &#125;    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;        <span class="hljs-comment">// Unwrap the Exception for clearer error reporting</span>        <span class="hljs-keyword">if</span> (t <span class="hljs-keyword">instanceof</span> InvocationTargetException &amp;&amp;                t.getCause() != <span class="hljs-keyword">null</span>) &#123;            t = t.getCause();        &#125;        handleThrowable(t);        t.printStackTrace();        System.exit(<span class="hljs-number">1</span>);    &#125;&#125;</code></pre><p>main()方法首先会调用init()方法及start()方法，init()方法中会通过反射加载Catalina。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    <span class="hljs-comment">//类加载器初始化</span>    initClassLoaders();    <span class="hljs-comment">//设置线程上下文类加载器，来解决有可能的ClassNotFoundException问题</span>    Thread.currentThread().setContextClassLoader(catalinaLoader);    SecurityClassLoad.securityClassLoad(catalinaLoader);    <span class="hljs-comment">// 加载启动类Catalina并调用其process()方法</span>    <span class="hljs-keyword">if</span> (log.isDebugEnabled())        log.debug(<span class="hljs-string">"Loading startup class"</span>);    Class&lt;?&gt; startupClass = catalinaLoader.loadClass(<span class="hljs-string">"org.apache.catalina.startup.Catalina"</span>);    Object startupInstance = startupClass.getConstructor().newInstance();    <span class="hljs-comment">// 设置共享类加载器sharedLoader</span>    <span class="hljs-keyword">if</span> (log.isDebugEnabled())        log.debug(<span class="hljs-string">"Setting startup class properties"</span>);    String methodName = <span class="hljs-string">"setParentClassLoader"</span>;    Class&lt;?&gt; paramTypes[] = <span class="hljs-keyword">new</span> Class[<span class="hljs-number">1</span>];    paramTypes[<span class="hljs-number">0</span>] = Class.forName(<span class="hljs-string">"java.lang.ClassLoader"</span>);    Object paramValues[] = <span class="hljs-keyword">new</span> Object[<span class="hljs-number">1</span>];    <span class="hljs-comment">// 把shared加载器传递给catalina</span>    paramValues[<span class="hljs-number">0</span>] = sharedLoader;    Method method =        startupInstance.getClass().getMethod(methodName, paramTypes);    method.invoke(startupInstance, paramValues);    catalinaDaemon = startupInstance;&#125;</code></pre><p>start()方法中会通过反射调用Catalina的start方法。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    <span class="hljs-keyword">if</span> (catalinaDaemon == <span class="hljs-keyword">null</span>) &#123;        init();    &#125;    Method method = catalinaDaemon.getClass().getMethod(<span class="hljs-string">"start"</span>, (Class [])<span class="hljs-keyword">null</span>);    method.invoke(catalinaDaemon, (Object [])<span class="hljs-keyword">null</span>);&#125;</code></pre><h3 id="Catalina"><a href="#Catalina" class="headerlink" title="Catalina"></a>Catalina</h3><p>Bootstrap的init()方法会调用到Catalina的load()方法，load()方法中会通过文件流的方式加载各种文件及配置信息，最后调用Server的init()方法，同样的，start()方法中会调用Servler的start()方法，这里不在进行详细分析。</p><h3 id="Server-1"><a href="#Server-1" class="headerlink" title="Server"></a>Server</h3><p>这里使用了模版方法设计模式，start()方法将调用子类中的startInternal()方法。StandardServer中的startInternal()方法会循环调用所有的Service的start()方法，同样的initInternal()方法中也会调用所有Service的init()方法。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startInternal</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> LifecycleException </span>&#123;    fireLifecycleEvent(CONFIGURE_START_EVENT, <span class="hljs-keyword">null</span>);    setState(LifecycleState.STARTING);    globalNamingResources.start();    <span class="hljs-comment">// Start our defined Services</span>    <span class="hljs-keyword">synchronized</span> (servicesLock) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; services.length; i++) &#123;            services[i].start();        &#125;    &#125;&#125;</code></pre><h3 id="Service-1"><a href="#Service-1" class="headerlink" title="Service"></a>Service</h3><p>StandardService中的startInternal()方法，该方法首先会启动容器，然后启动线程执行器，自定义连接器。</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startInternal</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> LifecycleException </span>&#123;    <span class="hljs-keyword">if</span>(log.isInfoEnabled())        log.info(sm.getString(<span class="hljs-string">"standardService.start.name"</span>, <span class="hljs-keyword">this</span>.name));    setState(LifecycleState.STARTING);    <span class="hljs-comment">// 首先启动的是容器</span>    <span class="hljs-keyword">if</span> (engine != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">synchronized</span> (engine) &#123;            engine.start();        &#125;    &#125;    <span class="hljs-comment">// 线程执行器</span>    <span class="hljs-keyword">synchronized</span> (executors) &#123;        <span class="hljs-keyword">for</span> (Executor executor: executors) &#123;            executor.start();        &#125;    &#125;    mapperListener.start();    <span class="hljs-comment">// 启动自定义的连接器</span>    <span class="hljs-keyword">synchronized</span> (connectorsLock) &#123;        <span class="hljs-keyword">for</span> (Connector connector: connectors) &#123;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">// If it has already failed, don't try and start it</span>                <span class="hljs-keyword">if</span> (connector.getState() != LifecycleState.FAILED) &#123;                    connector.start();                &#125;            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                log.error(sm.getString(                        <span class="hljs-string">"standardService.connector.startFailed"</span>,                        connector), e);            &#125;        &#125;    &#125;&#125;</code></pre><h2 id="tomcat的请求处理过程"><a href="#tomcat的请求处理过程" class="headerlink" title="tomcat的请求处理过程"></a>tomcat的请求处理过程</h2><ol><li>用户点击网页内容，请求被发送到本机端口8080，被在那里监听的Coyote HTTP/1.1 Connector获得。</li><li>Connector把该请求交给它所在的Service的Engine来处理，并等待Engine的回应。</li><li>Engine获得请求localhost/test/index.jsp，匹配所有的虚拟主机Host。</li><li>Engine匹配到名为localhost的Host（即使匹配不到也把请求交给该Host处理，因为该Host被定义为该Engine的默认主机），名为localhost的Host获得请求/test/index.jsp，匹配它所拥有的所有的Context。Host匹配到路径为/test的Context（如果匹配不到就把该请求交给路径名为“ ”的Context去处理）。</li><li>path=“/test”的Context获得请求/index.jsp，在它的mapping table中寻找出对应的Servlet。Context匹配到URL PATTERN为*.jsp的Servlet,对应于JspServlet类。</li><li>构造HttpServletRequest对象和HttpServletResponse对象，作为参数调用JspServlet的doGet()或doPost()。执行业务逻辑、数据存储等程序。</li><li>Context把执行完之后的HttpServletResponse对象返回给Host。</li><li>Host把HttpServletResponse对象返回给Engine。</li><li>Engine把HttpServletResponse对象返回Connector。</li><li>Connector把HttpServletResponse对象返回给客户Browser。</li></ol><h2 id="管道模式"><a href="#管道模式" class="headerlink" title="管道模式"></a>管道模式</h2><h3 id="管道与阀门"><a href="#管道与阀门" class="headerlink" title="管道与阀门"></a>管道与阀门</h3><p>在一个比较复杂的大型系统中，如果一个对象或数据流需要进行繁杂的逻辑处理，我们可以选择在一个大的组件中直接处理这些繁杂的逻辑处理，这个方式虽然达到目的，但是拓展性和可重用性差。因为牵一发而动全身。</p><p>管道是就像一条管道把多个对象连接起来，整体看起来就像若干个阀门嵌套在管道中，而处理逻辑放在阀门上。它的结构和实现是非常值得我们学习和借鉴的。</p><h3 id="管道的实现"><a href="#管道的实现" class="headerlink" title="管道的实现"></a>管道的实现</h3><p>首先需要定义阀门接口，阀门接口中包含下一个阀门的引用，每个阀门完成自己的逻辑后将调用下一个阀门的方法，直到基础阀门，基础阀门的方法中不再对下一个阀门进行调用。管道接口中保存有第一个阀门及基础阀门的引用，基础阀门的将作为阀门添加时的顺序比较，第一个阀门将用于管道调用的开始，管道调用开始于第一个管道，终止于基础管道。</p><p>管道接口：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Pipeline</span> </span>&#123;    <span class="hljs-comment">//获取第一个阀门</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Valve <span class="hljs-title">getFirst</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> Valve <span class="hljs-title">getBasic</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">//设置阀门</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBasic</span><span class="hljs-params">(Valve valve)</span></span>;    <span class="hljs-comment">//添加阀门</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addVave</span><span class="hljs-params">(Valve valve)</span></span>;&#125;</code></pre><p>阀门接口</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Valve</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> Valve <span class="hljs-title">getNext</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setNext</span><span class="hljs-params">(Valve valve)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invoke</span><span class="hljs-params">(String handing)</span></span>;&#125;</code></pre><p>管道接口的实现：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StandardPipeline</span> <span class="hljs-keyword">implements</span>  <span class="hljs-title">Pipeline</span> </span>&#123;    <span class="hljs-comment">//阀门（非基础，定义一个first）</span>    <span class="hljs-keyword">protected</span> Valve first = <span class="hljs-keyword">null</span>;    <span class="hljs-comment">//基础阀门</span>    <span class="hljs-keyword">protected</span> Valve basic = <span class="hljs-keyword">null</span>;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Valve <span class="hljs-title">getBasic</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> basic;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBasic</span><span class="hljs-params">(Valve valve)</span> </span>&#123;        <span class="hljs-keyword">this</span>.basic=valve;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Valve <span class="hljs-title">getFirst</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> first;    &#125;    <span class="hljs-comment">//添加阀门，链式构建阀门的执行顺序（先定制、最后基础阀门）</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addVave</span><span class="hljs-params">(Valve valve)</span> </span>&#123;        <span class="hljs-keyword">if</span>(first == <span class="hljs-keyword">null</span>)&#123;            first = valve;            valve.setNext(basic);        &#125;<span class="hljs-keyword">else</span>&#123;            Valve current =first;            <span class="hljs-keyword">while</span>(current !=<span class="hljs-keyword">null</span>)&#123;                <span class="hljs-keyword">if</span>(current.getNext() == basic)&#123;                    current.setNext(valve);                    valve.setNext(basic);                &#125;                current = current.getNext();            &#125;        &#125;    &#125;&#125;</code></pre><p>基础阀门</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StandardValve</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Valve</span> </span>&#123;    <span class="hljs-keyword">protected</span>  Valve next =<span class="hljs-keyword">null</span>;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Valve <span class="hljs-title">getNext</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> next;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setNext</span><span class="hljs-params">(Valve valve)</span> </span>&#123;        <span class="hljs-keyword">this</span>.next =valve;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invoke</span><span class="hljs-params">(String request)</span> </span>&#123;        System.out.println(<span class="hljs-string">"基础阀门处理"</span>);    &#125;&#125;</code></pre><p>第一个阀门</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FirstValve</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Valve</span> </span>&#123;    <span class="hljs-keyword">protected</span>  Valve next =<span class="hljs-keyword">null</span>;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Valve <span class="hljs-title">getNext</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> next;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setNext</span><span class="hljs-params">(Valve valve)</span> </span>&#123;        <span class="hljs-keyword">this</span>.next =valve;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invoke</span><span class="hljs-params">(String request)</span> </span>&#123;        System.out.println(<span class="hljs-string">"阀门1处理"</span>);        getNext().invoke(request);    &#125;&#125;</code></pre><p>第二个阀门</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecondValve</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Valve</span> </span>&#123;    <span class="hljs-keyword">protected</span>  Valve next =<span class="hljs-keyword">null</span>;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Valve <span class="hljs-title">getNext</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> next;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setNext</span><span class="hljs-params">(Valve valve)</span> </span>&#123;        <span class="hljs-keyword">this</span>.next =valve;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invoke</span><span class="hljs-params">(String request)</span> </span>&#123;        System.out.println(<span class="hljs-string">"阀门2处理"</span>);        getNext().invoke(request);    &#125;&#125;</code></pre><p>测试类</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        String request =<span class="hljs-string">"这个是一个Servlet请求"</span>;        <span class="hljs-comment">//new出一个管道</span>        StandardPipeline pipeline = <span class="hljs-keyword">new</span> StandardPipeline();        <span class="hljs-comment">//三个阀门(一个基础、2个定制)</span>        StandardValve standardValve = <span class="hljs-keyword">new</span> StandardValve();        FirstValve firstValve = <span class="hljs-keyword">new</span> FirstValve();        SecondValve secondValve = <span class="hljs-keyword">new</span> SecondValve();        <span class="hljs-comment">//设置基础阀门(定制阀门)</span>        pipeline.setBasic(standardValve);        <span class="hljs-comment">//设置非基础阀门</span>        pipeline.addVave(firstValve);        pipeline.addVave(secondValve);        <span class="hljs-comment">//调用对象管道中的第一个阀门</span>        pipeline.getFirst().invoke(request);    &#125;&#125;</code></pre><h2 id="tomcat中的管道"><a href="#tomcat中的管道" class="headerlink" title="tomcat中的管道"></a>tomcat中的管道</h2><img src="/blog/2020/04/30/tomcat%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/pic3.png" srcset="/blog/img/loading.gif" class><p>其中的Engine、Host、Context、warpper分别对应StandardEngineValve、StandardHostValve、StandardContextValve、StandardWrapperValve四种阀门。</p><h3 id="管道处理流程"><a href="#管道处理流程" class="headerlink" title="管道处理流程"></a>管道处理流程</h3><img src="/blog/2020/04/30/tomcat%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/pic4.png" srcset="/blog/img/loading.gif" class><p>接收到请求后在CoyoteAdapter的service()方法中的<code>connector.getContainer().getPipeline().getFirst().invoke(request, response);</code>将获取管道并开始阀门的调用过程对reqeust、response进行处理。</p><p>StandardEngineValue类中的invoke()方法。</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invoke</span><span class="hljs-params">(Request request, Response response)</span></span><span class="hljs-function">    <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;    <span class="hljs-comment">// 拿到Engline中包含的host</span>    Host host = request.getHost();    <span class="hljs-keyword">if</span> (host == <span class="hljs-keyword">null</span>) &#123;        response.sendError            (HttpServletResponse.SC_BAD_REQUEST,             sm.getString(<span class="hljs-string">"standardEngine.noHost"</span>,                          request.getServerName()));        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">if</span> (request.isAsyncSupported()) &#123;        request.setAsyncSupported(host.getPipeline().isAsyncSupported());    &#125;    <span class="hljs-comment">// 将request，response交给下一个阀门</span>    host.getPipeline().getFirst().invoke(request, response);&#125;</code></pre><p>tomcat的Pipeline处理是这样的：</p><ol><li><p>在生产线上的第一个工人拿到生产原料后，二话不说就人给下一个工人，下一个工人也是一样直接扔给下一个工人，直到最后一个工人，而最后一个工人被安排为上面提过的StandardValve，他要完成的是把生产资料运给自己所在包含的container的Pipeline上去。 </p></li><li><p>四个container就相当于有四个生产线（Pipeline），当StandardWrapperValve拿到资源开始调用servlet，返回后，再一步一步按照刚才丢生产原料是的顺序的倒序一次执行。</p></li></ol><h3 id="自定义tomcat阀门"><a href="#自定义tomcat阀门" class="headerlink" title="自定义tomcat阀门"></a>自定义tomcat阀门</h3><p>管道机制给我们带来了更好的拓展性，例如，你要添加一个额外的逻辑处理阀门是很容易的。自定义个阀门PrintIPValve，只要继承ValveBase并重写invoke方法即可。注意在invoke方法中一定要执行调用下一个阀门的操作，否则会出现异常。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrintIPValve</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ValveBase</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invoke</span><span class="hljs-params">(Request request, Response response)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;        System.out.println(<span class="hljs-string">"------自定义阀门PrintIPValve:"</span>+request.getRemoteAddr());        getNext().invoke(request,response);    &#125;&#125;</code></pre><p>配置Tomcat的核心配置文件server.xml,这里把阀门配置到Engine容器下，作用范围就是整个引擎，也可以根据作用范围配置在Host或者是Context下</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Valve</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"org.apache.catalina.valves.PrintIPValve"</span> /&gt;</span></code></pre><p>源码中可以直接生效，但是如果是运行版本，可以将这个类导出成一个Jar包放入Tomcat/lib目录下，也可以直接将.class文件打包进catalina.jar包中。</p><h3 id="tomcat中提供常用的阀门"><a href="#tomcat中提供常用的阀门" class="headerlink" title="tomcat中提供常用的阀门"></a>tomcat中提供常用的阀门</h3><p>AccessLogValve：请求访问日志阀门，通过此阀门可以记录所有客户端的访问日志，包括远程主机IP，远程主机名，请求方法，请求协议，会话ID，请求时间，处理时长，数据包大小等。它提供任意参数化的配置，可以通过任意组合来定制访问日志的格式。</p><p>JDBCAccessLogValve：同样是记录访问日志的阀门，但是它有助于将访问日志通过JDBC持久化到数据库中。</p><p>ErrorReportValve：这是一个讲错误以HTML格式输出的阀门。</p><p>PersistentValve：这是对每一个请求的会话实现持久化的阀门。</p><p>RemoteAddrValve：访问控制阀门。可以通过配置决定哪些IP可以访问WEB应用。</p><p>RemoteHostValve：访问控制阀门，通过配置觉得哪些主机名可以访问WEB应用。</p><p>RemoteIpValve：针对代理或者负载均衡处理的一个阀门，一般经过代理或者负载均衡转发的请求都将自己的IP添加到请求头”X-Forwarded-For”中，此时，通过阀门可以获取访问者真实的IP。</p><p>SemaphoreValve：这个是一个控制容器并发访问的阀门，可以作用在不同容器上。</p><h2 id="JVM中的类加载机制"><a href="#JVM中的类加载机制" class="headerlink" title="JVM中的类加载机制"></a>JVM中的类加载机制</h2><p><strong>类加载：</strong>主要是将.class文件中的二进制字节读入到JVM中</p><p>我们可以看到因为这个定义，所以并没有规定一定是要磁盘加载文件，可以通过网络，内存什么的加载。只要是二进制流字节数据，JVM就可以加载。</p><p><strong>类加载过程：</strong></p><ol><li><p>通过类的全限定名获取该类的二进制字节流；</p></li><li><p>将字节流所代表的静态结构转化为方法区的运行时数据结构</p></li><li><p>在内存中生成一个该类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</p></li></ol><p><strong>类加载器</strong>：</p><p>JVM设计者把“类加载”这个动作放到java虚拟机外部去实现，以便让应用程序决定如何获取所需要的类。实现这个动作的代码模块成为“类加载器”</p><p><strong>类的唯一性：</strong></p><p>对于任何一个类，都需要由加载它的类加载器和这个类来确定其在JVM中的唯一性。也就是说，两个类来源于同一个Class文件，并且被同一个类加载器加载，这两个类才相等。</p><p>注意：这里所谓的“相等”，一般使用instanceof关键字做判断。</p><p><strong>双亲委派模型：</strong></p><ul><li><p><strong>定义：</strong>双亲委派模型的工作过程为：如果一个类加载器收到了类请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父加载器去完成，每一层都是如此，因此所有类加载的请求都会传到启动类加载器，只有当父加载器无法完成该请求时，子加载器才去自己加载。</p></li><li><p><strong>实现方式：</strong>该模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。子类加载器不是以继承的关系来实现，而是通过组合关系来复用父加载器的代码。</p></li><li><p><strong>意义：</strong>好处双亲委派模型的好处就是java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如：Object,无论那个类加载器去加载该类，最终都是由启动类加载器进行加载的，因此Object类在程序的各种类加载环境中都是一个类。如果不用改模型，那么java.lang.Object类存放在classpath中，那么系统中就会出现多个Object类，程序变得很混乱。</p></li></ul><h5 id="类加载器的分类："><a href="#类加载器的分类：" class="headerlink" title="类加载器的分类："></a>类加载器的分类：</h5><p>从虚拟机的角度来说，有两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader）,该加载器使用C++语言实现，属于虚拟机自身的一部分。另一部分就是所有其它的类加载器，这些类加载器是由Java语言实现，独立于JVM外部，并且全部继承抽象类java.lang.ClassLoader.</p><p>  从java开发人员的角度看，大部分java程序会用到以下三种系统提供的类加载器：</p><ol><li><p>启动类加载器（Bootstrap ClassLoader）:负责加载JAVA_HOME\lib目录中并且能被虚拟机识别的类库加载到JVM内存中，如果名称不符合的类库即使在lib目录中也不会被加载。该类加载器无法被java程序直接引用。</p></li><li><p>扩展类加载器(Extension ClassLoader):该加载器主要负责加载JAVA_HOME\lib\ext目录中的类库，开发者可以使用扩展加载器。 </p></li><li><p>应用程序类加载器（Application ClassLoader）:该列加载器也称为系统加载器，它负责加载用户类路径(Classpath)上所指定的类库，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p></li></ol><h2 id="tomcat类加载的特性"><a href="#tomcat类加载的特性" class="headerlink" title="tomcat类加载的特性"></a>tomcat类加载的特性</h2><p><strong>隔离性</strong>：Web应用类库相互隔离，避免依赖库或者应用包相互影响，比如有两个Web应用，一个采用了Spring 4，一个采用了Spring 5，如果采用同一个类加载器，Web应用将会由于jar包覆盖而无法启动成功。</p><p><strong>灵活性</strong>：Web应用之间的类加载器相互独立，如果一个Web应用重新部署时，该应用的类加载器重新加载，不能影响其他web应用。</p><p><strong>性能</strong>：如果在一个Tomcat部署多个应用，多个应用中都有相同的类库依赖。那么可以把这相同的类库让Common类加载器进行加载。</p><h2 id="tomcat中的类加载器"><a href="#tomcat中的类加载器" class="headerlink" title="tomcat中的类加载器"></a>tomcat中的类加载器</h2>{% asset_img pic5.png %}<p>Tomcat提供3个基础类加载器（common、catalina、shared）和Web应用类加载器。</p><ul><li><strong>Common Loader</strong>：Tomcat最基本的类加载器，加载<code>/common/*</code>路径中的class可以被Tomcat容器本身以及各个Webapp访问；</li><li><strong>Catalina Loader</strong>：Tomcat容器私有的类加载器，加载<code>/server/*</code>路径中的class对于Webapp不可见；</li><li><strong>Shared Loader</strong>：各个Webapp共享的类加载器，加载<code>/WebApp/WEB-INF/*</code>路径中的class对于所有Webapp可见，但是对于Tomcat容器不可见；</li><li><strong>WebappClass Loader</strong>：各个Webapp私有的类加载器，加载路径中的class只对当前Webapp可见；</li></ul><p>Tomcat通过Common类加载器实现了Jar包在应用服务器与Web应用之间的共享，通过Shared类加载器实现了Jar包在Web应用之间的共享，再过Catalina类加载器加载服务器依赖的类。</p><p>当应用需要到某个类时，则会按照下面的顺序进行类加载</p><ol><li>使用BootStrap ClassLoader加载</li><li>使用system系统类加载器加载</li><li>使用Webapp ClassLoader在WEB-INF/classes中加载</li><li>使用Webapp ClassLoader在WEB-INF/lib中加载</li><li>使用Common ClassLoader在CATALINA_HOME/lib中加载</li></ol><h3 id="类加载器的创建"><a href="#类加载器的创建" class="headerlink" title="类加载器的创建"></a>类加载器的创建</h3><p>3个基础类加载器的加载路径在catalina.properties配置，默认情况下，3个基础类加载器的实例都是一个。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    <span class="hljs-comment">//类加载器初始化</span>    initClassLoaders();    <span class="hljs-comment">//设置线程上下文类加载器，来解决有可能的ClassNotFoundException问题</span>    Thread.currentThread().setContextClassLoader(catalinaLoader);    SecurityClassLoad.securityClassLoad(catalinaLoader);    <span class="hljs-comment">// 加载启动类Catalina并调用其process()方法</span>    <span class="hljs-keyword">if</span> (log.isDebugEnabled())        log.debug(<span class="hljs-string">"Loading startup class"</span>);    Class&lt;?&gt; startupClass = catalinaLoader.loadClass(<span class="hljs-string">"org.apache.catalina.startup.Catalina"</span>);    Object startupInstance = startupClass.getConstructor().newInstance();    <span class="hljs-comment">// 设置共享类加载器sharedLoader</span>    <span class="hljs-keyword">if</span> (log.isDebugEnabled())        log.debug(<span class="hljs-string">"Setting startup class properties"</span>);    String methodName = <span class="hljs-string">"setParentClassLoader"</span>;    Class&lt;?&gt; paramTypes[] = <span class="hljs-keyword">new</span> Class[<span class="hljs-number">1</span>];    paramTypes[<span class="hljs-number">0</span>] = Class.forName(<span class="hljs-string">"java.lang.ClassLoader"</span>);    Object paramValues[] = <span class="hljs-keyword">new</span> Object[<span class="hljs-number">1</span>];    <span class="hljs-comment">// 把shared加载器传递给catalina</span>    paramValues[<span class="hljs-number">0</span>] = sharedLoader;    Method method =        startupInstance.getClass().getMethod(methodName, paramTypes);    method.invoke(startupInstance, paramValues);    catalinaDaemon = startupInstance;&#125;</code></pre><h3 id="类加载器初始化"><a href="#类加载器初始化" class="headerlink" title="类加载器初始化"></a>类加载器初始化</h3><p>Bootstartp的initClassLoaders()方法会在Boostrap的init()方法中调用，初始化三个类加载器以及确定父子关系。</p><pre><code class="hljs java"><span class="hljs-comment">//初始化三个类加载器以及确定父子关系</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initClassLoaders</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// commonLoader的加载路径为common.loader</span>        commonLoader = createClassLoader(<span class="hljs-string">"common"</span>, <span class="hljs-keyword">null</span>);        <span class="hljs-keyword">if</span> (commonLoader == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">// no config file, default to this loader - we might be in a 'single' env.</span>            commonLoader = <span class="hljs-keyword">this</span>.getClass().getClassLoader();        &#125;        <span class="hljs-comment">// 加载路径为server.loader，默认为空，父类加载器为commonLoader</span>        catalinaLoader = createClassLoader(<span class="hljs-string">"server"</span>, commonLoader);        <span class="hljs-comment">// 加载路径为shared.loader，默认为空，父类加载器为commonLoader</span>        sharedLoader = createClassLoader(<span class="hljs-string">"shared"</span>, commonLoader);    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;        handleThrowable(t);        log.error(<span class="hljs-string">"Class loader creation threw exception"</span>, t);        System.exit(<span class="hljs-number">1</span>);    &#125;&#125;</code></pre><p>initClassLoaders()方法会调用createClassLoader()方法会根据catalina.properties中的内容创建对应的类加载器，如果为空则返回传入的父加载器。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> ClassLoader <span class="hljs-title">createClassLoader</span><span class="hljs-params">(String name, ClassLoader parent)</span></span><span class="hljs-function">    <span class="hljs-keyword">throws</span> Exception </span>&#123;    String value = CatalinaProperties.getProperty(name + <span class="hljs-string">".loader"</span>);    <span class="hljs-keyword">if</span> ((value == <span class="hljs-keyword">null</span>) || (value.equals(<span class="hljs-string">""</span>)))        <span class="hljs-keyword">return</span> parent;    value = replace(value);    List&lt;Repository&gt; repositories = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    String[] repositoryPaths = getPaths(value);    <span class="hljs-keyword">for</span> (String repository : repositoryPaths) &#123;        <span class="hljs-comment">// Check for a JAR URL repository</span>        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unused"</span>)            URL url = <span class="hljs-keyword">new</span> URL(repository);            repositories.add(<span class="hljs-keyword">new</span> Repository(repository, RepositoryType.URL));            <span class="hljs-keyword">continue</span>;        &#125; <span class="hljs-keyword">catch</span> (MalformedURLException e) &#123;            <span class="hljs-comment">// Ignore</span>        &#125;        <span class="hljs-comment">// Local repository</span>        <span class="hljs-keyword">if</span> (repository.endsWith(<span class="hljs-string">"*.jar"</span>)) &#123;            repository = repository.substring                (<span class="hljs-number">0</span>, repository.length() - <span class="hljs-string">"*.jar"</span>.length());            repositories.add(<span class="hljs-keyword">new</span> Repository(repository, RepositoryType.GLOB));        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (repository.endsWith(<span class="hljs-string">".jar"</span>)) &#123;            repositories.add(<span class="hljs-keyword">new</span> Repository(repository, RepositoryType.JAR));        &#125; <span class="hljs-keyword">else</span> &#123;            repositories.add(<span class="hljs-keyword">new</span> Repository(repository, RepositoryType.DIR));        &#125;    &#125;    <span class="hljs-keyword">return</span> ClassLoaderFactory.createClassLoader(repositories, parent);&#125;</code></pre><p>catalina.properties中的内容</p><pre><code class="hljs properties"><span class="hljs-meta">common.loader</span>=<span class="hljs-string">"$&#123;catalina.base&#125;/lib","$&#123;catalina.base&#125;/lib/*.jar","$&#123;catalina.home&#125;/lib","$&#123;catalina.home&#125;/lib/*.jar"</span><span class="hljs-meta">server.loader</span>=<span class="hljs-string"></span><span class="hljs-meta">shared.loader</span>=<span class="hljs-string"></span></code></pre><p>所以默认情况这三个类加载器是同一个实例，可以通过修改配置创建3个不同的类加载机制，使它们各司其职，如果不希望这些包对Web应用可见，因此我们可以配置server.loader，创建独立的Catalina类加载器。</p><h3 id="类加载工厂"><a href="#类加载工厂" class="headerlink" title="类加载工厂"></a>类加载工厂</h3><p>因为类加载需要做很多事情，比如读取字节数组、验证、解析、初始化等。Java提供的URLClassLoader类能够方便的将Jar、Class或者网络资源加载到内存中。Tomcat中使用一个工厂类，ClassLoaderFactory把创建类加载器的细节进行封装，可以通过它方便的创建自定义类加载器。</p><p>上述createClassLoader()方法中的<code>return ClassLoaderFactory.createClassLoader(repositories, parent);</code>方法就是使用类加载工厂来创建类加载器。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ClassLoader <span class="hljs-title">createClassLoader</span><span class="hljs-params">(List&lt;Repository&gt; repositories,</span></span><span class="hljs-function"><span class="hljs-params">                                            <span class="hljs-keyword">final</span> ClassLoader parent)</span></span><span class="hljs-function">    <span class="hljs-keyword">throws</span> Exception </span>&#123;    <span class="hljs-keyword">if</span> (log.isDebugEnabled())        log.debug(<span class="hljs-string">"Creating new class loader"</span>);    <span class="hljs-comment">// Construct the "class path" for this class loader</span>    Set&lt;URL&gt; set = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;();    <span class="hljs-keyword">if</span> (repositories != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">for</span> (Repository repository : repositories)  &#123;            <span class="hljs-keyword">if</span> (repository.getType() == RepositoryType.URL) &#123;                URL url = buildClassLoaderUrl(repository.getLocation());                <span class="hljs-keyword">if</span> (log.isDebugEnabled())                    log.debug(<span class="hljs-string">"  Including URL "</span> + url);                set.add(url);            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (repository.getType() == RepositoryType.DIR) &#123;                File directory = <span class="hljs-keyword">new</span> File(repository.getLocation());                directory = directory.getCanonicalFile();                <span class="hljs-keyword">if</span> (!validateFile(directory, RepositoryType.DIR)) &#123;                    <span class="hljs-keyword">continue</span>;                &#125;                URL url = buildClassLoaderUrl(directory);                <span class="hljs-keyword">if</span> (log.isDebugEnabled())                    log.debug(<span class="hljs-string">"  Including directory "</span> + url);                set.add(url);            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (repository.getType() == RepositoryType.JAR) &#123;                File file=<span class="hljs-keyword">new</span> File(repository.getLocation());                file = file.getCanonicalFile();                <span class="hljs-keyword">if</span> (!validateFile(file, RepositoryType.JAR)) &#123;                    <span class="hljs-keyword">continue</span>;                &#125;                URL url = buildClassLoaderUrl(file);                <span class="hljs-keyword">if</span> (log.isDebugEnabled())                    log.debug(<span class="hljs-string">"  Including jar file "</span> + url);                set.add(url);            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (repository.getType() == RepositoryType.GLOB) &#123;                File directory=<span class="hljs-keyword">new</span> File(repository.getLocation());                directory = directory.getCanonicalFile();                <span class="hljs-keyword">if</span> (!validateFile(directory, RepositoryType.GLOB)) &#123;                    <span class="hljs-keyword">continue</span>;                &#125;                <span class="hljs-keyword">if</span> (log.isDebugEnabled())                    log.debug(<span class="hljs-string">"  Including directory glob "</span>                        + directory.getAbsolutePath());                String filenames[] = directory.list();                <span class="hljs-keyword">if</span> (filenames == <span class="hljs-keyword">null</span>) &#123;                    <span class="hljs-keyword">continue</span>;                &#125;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; filenames.length; j++) &#123;                    String filename = filenames[j].toLowerCase(Locale.ENGLISH);                    <span class="hljs-keyword">if</span> (!filename.endsWith(<span class="hljs-string">".jar"</span>))                        <span class="hljs-keyword">continue</span>;                    File file = <span class="hljs-keyword">new</span> File(directory, filenames[j]);                    file = file.getCanonicalFile();                    <span class="hljs-keyword">if</span> (!validateFile(file, RepositoryType.JAR)) &#123;                        <span class="hljs-keyword">continue</span>;                    &#125;                    <span class="hljs-keyword">if</span> (log.isDebugEnabled())                        log.debug(<span class="hljs-string">"    Including glob jar file "</span>                            + file.getAbsolutePath());                    URL url = buildClassLoaderUrl(file);                    set.add(url);                &#125;            &#125;        &#125;    &#125;    <span class="hljs-comment">// Construct the class loader itself</span>    <span class="hljs-keyword">final</span> URL[] array = set.toArray(<span class="hljs-keyword">new</span> URL[set.size()]);    <span class="hljs-keyword">if</span> (log.isDebugEnabled())        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; array.length; i++) &#123;            log.debug(<span class="hljs-string">"  location "</span> + i + <span class="hljs-string">" is "</span> + array[i]);        &#125;    <span class="hljs-keyword">return</span> AccessController.doPrivileged(            <span class="hljs-keyword">new</span> PrivilegedAction&lt;URLClassLoader&gt;() &#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">public</span> URLClassLoader <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                    <span class="hljs-keyword">if</span> (parent == <span class="hljs-keyword">null</span>)                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> URLClassLoader(array);                    <span class="hljs-keyword">else</span>                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> URLClassLoader(array, parent);                &#125;            &#125;);&#125;</code></pre><p>createClassLoader()方法会依据RepositoryType来执行不同的创建方法。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> RepositoryType &#123;    DIR, <span class="hljs-comment">//表示整个目录下的资源，包括所有Class、jar包以及其他类型资源</span>    GLOB, <span class="hljs-comment">//表示整个目录下的所有jar包资源</span>    JAR, <span class="hljs-comment">//表示单个jar包资源</span>    URL <span class="hljs-comment">//表示从URL上获取jar包资源</span>&#125;</code></pre><p>使用加载器工厂的好处</p><ol><li>ClassLoadFactory有一个内部Repository，它就是表示资源的类，资源的类型用一个RepositoryType的枚举表示。</li><li>在检查jar包的时候，如果检查的URL地址有异常就忽略掉，可以确保部分类加载正确。</li></ol><h3 id="类加载器绑定到线程"><a href="#类加载器绑定到线程" class="headerlink" title="类加载器绑定到线程"></a>类加载器绑定到线程</h3><p>JVM提供了java.lang.Thread类的setContextClassLoader方法来绑定一个线程上下文类加载器（Thread Context ClassLoader），用于在运行时动态载入其他类，如果创建线程时未设置，将会从父线程中继承一个，所以大部分情况下，都是系统默认的ContextClassLoad。</p><p>一般在实际的系统上，使用线程上下文类加载器，可以设置不同的加载方式，这个也是Java灵活的类加载方式的体现，也可以很轻松的打破双亲委派模式，同时也会避免类加载的异常。</p><p>tomcat也使用了这种方式，来解决Commons ClassLoader需要Webapp ClassLoader中的类的情况。WebappLoader只会加载自己目录下的class文件，不会传递给父容器，所以tomcat将Webapp ClassLoader与线程绑定，使用线程上下文加载器，可以让父类加载器请求子类加载器去完成类加载的动作，不得不说，这是个巧妙的设计。</p><h3 id="tomcat的热加载"><a href="#tomcat的热加载" class="headerlink" title="tomcat的热加载"></a>tomcat的热加载</h3><p>StandardContext.startInternal()方法中还会调用threadStart()方法，threadStart()方法将创建一个线程，这个线程的while循环中，不断的调用方法，然后进行睡眠，以这种类似于定时器的方式，来执行任务，如重新加载等。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">threadStart</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">if</span> (thread != <span class="hljs-keyword">null</span>)        <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">if</span> (backgroundProcessorDelay &lt;= <span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span>;    threadDone = <span class="hljs-keyword">false</span>;    String threadName = <span class="hljs-string">"ContainerBackgroundProcessor["</span> + toString() + <span class="hljs-string">"]"</span>;    thread = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> ContainerBackgroundProcessor(), threadName);    thread.setDaemon(<span class="hljs-keyword">true</span>);    thread.start();&#125;</code></pre><p>threadStart()方法调用链比较长，这里只分析WebappLoader的backgroudProcess()方法，该方法将完成类的重新加载。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backgroundProcess</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">if</span> (reloadable &amp;&amp; modified()) &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//设置线程类加载器的类加载器WebappClassLoader</span>            Thread.currentThread().setContextClassLoader                (WebappLoader<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getClassLoader</span>())</span>;            <span class="hljs-keyword">if</span> (context != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-comment">//重新加载的方法</span>                context.reload();            &#125;        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-keyword">if</span> (context != <span class="hljs-keyword">null</span> &amp;&amp; context.getLoader() != <span class="hljs-keyword">null</span>) &#123;                Thread.currentThread().setContextClassLoader                    (context.getLoader().getClassLoader());            &#125;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>tomcat</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tomcat</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tomcat体系架构</title>
    <link href="/blog/2020/04/30/tomcat%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/"/>
    <url>/blog/2020/04/30/tomcat%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h2 id="web容器"><a href="#web容器" class="headerlink" title="web容器"></a>web容器</h2><p>Web服务器一般指网站服务器，是指驻留于因特网上某种类型计算机的程序，可以向浏览器等Web客户端提供文档，也可以放置网站文件，提供给用户浏览或下载。</p><img src="/blog/2020/04/30/tomcat%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/pic1.png" srcset="/blog/img/loading.gif" class><p>Web服务器的特点：</p><ul><li><p>服务器是一种被动程序：只有当Internet上运行其他计算机中的浏览器发出的请求时，服务器才会响应。</p></li><li><p>服务器一般使用HTTP（超文本传输协议）与客户机浏览器进行信息交流，这就是人们常把它们称为HTTP服务器的原因。</p></li><li><p>Web服务器不仅能够存储信息，还能在用户通过Web浏览器提供的信息的基础上运行脚本和程序。</p></li></ul><h2 id="tomcat介绍"><a href="#tomcat介绍" class="headerlink" title="tomcat介绍"></a>tomcat介绍</h2><p>tomcat是一款开源轻量级Web应用服务器,是一款优秀的Servlet容器实现。</p><p>Servlet（Server Applet）是Java Servlet的简称，称为小服务程序或服务连接器，用Java编写的服务器端程序，具有独立于平台和协议的特性，主要功能在于交互式地浏览和生成数据，生成动态Web内容。</p><p>Servlet严格来讲是指Java语言实现的一个接口，一般情况下我们说的Servlet是指任何实现了这个Servlet接口的类。</p><ul><li>实例化并调用init()方法初始化该Servlet，一般Servlet只初始化一次(只有一个对象)</li><li>service()（根据请求方法不同调用doGet() 或者 doPost()，此外还有doHead()、doPut()、doTrace()、doDelete()、doOptions()、destroy())。</li><li>当 Server 不再需要 Servlet 时（一般当 Server 关闭时），Server调用Servlet的destroy()方法。</li></ul><h3 id="tomcat版本对照"><a href="#tomcat版本对照" class="headerlink" title="tomcat版本对照"></a>tomcat版本对照</h3><table><thead><tr><th></th><th><strong>6.X</strong></th><th><strong>7.X</strong></th><th><strong>8.X</strong></th><th><strong>8.5X</strong></th><th><strong>9.X</strong></th></tr></thead><tbody><tr><td>JDK</td><td>&gt;=1.5</td><td>&gt;=1.6</td><td>&gt;=1.7</td><td>&gt;=1.7</td><td>&gt;=1.8</td></tr><tr><td>Servlet</td><td>2.5</td><td>3.0</td><td>3.1</td><td>3.1</td><td>4.0</td></tr><tr><td>JSP</td><td>2.1</td><td>2.2</td><td>2.3</td><td>2.3</td><td>2.3</td></tr><tr><td>WebSocket</td><td>N</td><td>1.1</td><td>1.1</td><td>1.1</td><td>1.1</td></tr></tbody></table><p>8.5版本特点：</p><ul><li>支持Servlet3.1</li><li>默认采用NIO，移除BIO</li><li>支持NIO2(AIO)</li><li>支持HTTP/2协议</li><li>默认采用异步日志处理</li></ul><h2 id="tomcat部署方式"><a href="#tomcat部署方式" class="headerlink" title="tomcat部署方式"></a>tomcat部署方式</h2><h3 id="隐式部署"><a href="#隐式部署" class="headerlink" title="隐式部署"></a>隐式部署</h3><p>直接丢文件夹、war、jar到webapps目录，tomcat会根据文件夹名称自动生成虚拟路径，简单，但是需要重启Tomcat服务器，包括要修改端口和访问路径的也需要重启。</p><h3 id="显式部署"><a href="#显式部署" class="headerlink" title="显式部署"></a>显式部署</h3><p>添加context元素</p><p>server.xml中的Host加入一个Context（指定路径和文件地址），例如：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Context</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/comet"</span> <span class="hljs-attr">docBase</span>=<span class="hljs-string">"D:\work_tomcat\ref-comet.war"</span> /&gt;</span></code></pre><p>即/comet 这个虚拟路径映射到了D:\work_tomcat\ref-comet目录下(war会解压成文件)，修改完servler.xml需要重启tomcat 服务器。</p><p>创建xml文件</p><p>在conf/Catalina/localhost中创建xml文件，访问路径为文件名，例如：</p><p>在localhost目录下新建demo.xml，内容为：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Context</span> <span class="hljs-attr">docBase</span>=<span class="hljs-string">"D:\work_tomcat\ref-comet"</span> /&gt;</span></code></pre><p>这时不需要指定路径，虚拟目录就是文件名demo，path默认为/demo，添加demo.xml不需要重启 tomcat服务器。</p><p>三种方式比较：</p><ul><li><p>隐式部署：部署速度比较快，需要手动移动Web应用到webapps下，在实际操作中不是很人性化。</p></li><li><p>添加context元素：需要配置两个路径，如果path为空字符串，则为缺省配置，每次修改server.xml文件后都要重新启动Tomcat服务器，重新部署。</p></li><li><p>创建xml文件：服务器后台会自动部署，修改一次后台部署一次，不用重复启动Tomcat服务器，该方式显得更为智能化。</p></li></ul><h2 id="tomcat目录结构"><a href="#tomcat目录结构" class="headerlink" title="tomcat目录结构"></a>tomcat目录结构</h2><h3 id="bin目录"><a href="#bin目录" class="headerlink" title="bin目录"></a>bin目录</h3><ul><li><p>startup文件，主要是检查catalina.bat/sh 执行所需环境，并调用catalina.bat 批处理文件。启动tomcat。</p></li><li><p>catalina文件，真正启动Tomcat文件，可以在里面设置jvm参数。后面性能调优会重点讲</p></li><li><p>shutdown文件，关闭Tomcat</p></li><li><p>version文件：查看当前tomcat的版本号，</p></li><li><p>configtest文件：校验tomcat配置文件server.xml的格式、内容等是否合法、正确。</p></li><li><p>service文件：安装tomcat服务，可用net start tomcat 启动</p></li></ul><p>脚本version.sh、startup.sh、shutdown.sh、configtest.sh都是对catalina.sh的包装，内容大同小异，差异在于功能介绍和调用catalina.sh时的参数不同。</p><h3 id="config目录"><a href="#config目录" class="headerlink" title="config目录"></a>config目录</h3><ul><li><p>web.xml</p><p>Tomcat中所有应用默认的部署描述文件，主要定义了基础的Servlet和MIME映射(mime-mapping 文件类型，其实就是Tomcat处理的文件类型),如果部署的应用中不包含Web.xml，那么Tomcat将使用此文件初始化部署描述，反之，Tomcat会在启动时将默认描述与定义描述配置进行合并。常用于：</p><ul><li><p>加载一些tomcat内置的servlet</p></li><li><p>DefaultServlet默认的,加载静态文件 html,js,jpg等静态文件。</p></li><li><p>JspServlet专门处理jsp。</p></li></ul></li><li><p>context.xml</p><p>用于自定义所有Web应用均需要加载的Context配置，如果Web应用指定了自己的context.xml，那么该文件的配置将被覆盖。</p><p>context.xml与server.xml中配置context的区别：server.xml是不可动态重加载的资源，服务器一旦启动了以后，要修改这个文件，就得重启服务器才能重新加载。而context.xml文件则不然，tomcat服务器会定时去扫描这个文件。一旦发现文件被修改（时间戳改变了），就会自动重新加载这个文件，而不需要重启服务器。</p></li><li><p>catalina.policy</p><p>权限相关Permission ，Tomcat是跑在jvm上的，所以有些默认的权限。</p></li><li><p>tomcat-users.xml</p><p>配置Tomcat的server的manager信息。</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">tomcat-users</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://tomcat.apache.org/xml"</span></span><span class="hljs-tag">              <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">              <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://tomcat.apache.org/xml tomcat-users.xsd"</span></span><span class="hljs-tag">              <span class="hljs-attr">version</span>=<span class="hljs-string">"1.0"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">role</span> <span class="hljs-attr">rolename</span>=<span class="hljs-string">"manager-gui"</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">user</span> <span class="hljs-attr">username</span>=<span class="hljs-string">"manager"</span> <span class="hljs-attr">password</span>=<span class="hljs-string">"manager"</span> <span class="hljs-attr">roles</span>=<span class="hljs-string">"manager-gui"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tomcat-users</span>&gt;</span></code></pre></li><li><p>logging.properties</p><p>设置tomcat日志，控制输出或者不输出内容到文件，但不能阻止生成文件，阻止生成文件可以注释掉。</p></li></ul><h3 id="webapps目录"><a href="#webapps目录" class="headerlink" title="webapps目录"></a>webapps目录</h3><p>存放web项目的目录，其中每个文件夹都是一个项目；如果这个目录下已经存在了目录，那么都是tomcat自带的。项目。其中ROOT是一个特殊的项目，在地址栏中没有给出项目目录时，对应的就是ROOT项目。<a href="http://localhost:8080/examples，进入示例项目。其中examples就是项目名，即文件夹的名字。" target="_blank" rel="noopener">http://localhost:8080/examples，进入示例项目。其中examples就是项目名，即文件夹的名字。</a></p><h3 id="lib目录"><a href="#lib目录" class="headerlink" title="lib目录"></a>lib目录</h3><p>Tomcat的类库，里面是一大堆jar文件。如果需要添加Tomcat依赖的jar文件，可以把它放到这个目录中，当然也可以把应用依赖的jar文件放到这个目录中，这个目录中的jar所有项目都可以共享，但这样你的应用放到其他Tomcat下时就不能再共享这个目录下的Jar包了，所以建议只把Tomcat需要的Jar包放到这个目录下；</p><h3 id="work目录"><a href="#work目录" class="headerlink" title="work目录"></a>work目录</h3><p>运行时生成的文件，最终运行的文件都在这里。通过webapps中的项目生成的！可以把这个目录下的内容删除，再次运行时会生再次生成work目录。当客户端用户访问一个JSP文件时，Tomcat会通过JSP生成Java文件，然后再编译Java文件生成class文件，生成的java和class文件都会存放到这个目录下。</p><h3 id="temp目录"><a href="#temp目录" class="headerlink" title="temp目录"></a>temp目录</h3><p>存放Tomcat的临时文件，这个目录下的东西在停止Tomcat后会删除！</p><h3 id="logs目录"><a href="#logs目录" class="headerlink" title="logs目录"></a>logs目录</h3><p>这个目录中都是日志文件，记录了Tomcat启动和关闭的信息，如果启动Tomcat时有错误，异常也会记录在日志文件中</p><p>localhost-xxx.log    Web应用的内部程序日志，建议保留</p><p>catalina-xxx.log    控制台日志</p><p>host-manager.xxx.log    Tomcat管理页面中的host-manager的操作日志，建议关闭</p><p>localhost_access_log_xxx.log    用户请求Tomcat的访问日志（这个文件在conf/server.xml里配置），建议关闭</p><h3 id="server-xml文件"><a href="#server-xml文件" class="headerlink" title="server.xml文件"></a>server.xml文件</h3><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-comment">&lt;!-- Server代表一个 Tomcat 实例。可以包含一个或多个 Services，其中每个Service都有自己的Engines和Connectors。</span><span class="hljs-comment">       port="8005"指定一个端口，这个端口负责监听关闭tomcat的请求</span><span class="hljs-comment">  --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Server</span> <span class="hljs-attr">port</span>=<span class="hljs-string">"8005"</span> <span class="hljs-attr">shutdown</span>=<span class="hljs-string">"SHUTDOWN"</span>&gt;</span><span class="hljs-comment">&lt;!-- 监听器 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Listener</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"org.apache.catalina.startup.VersionLoggerListener"</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Listener</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"org.apache.catalina.core.AprLifecycleListener"</span> <span class="hljs-attr">SSLEngine</span>=<span class="hljs-string">"on"</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Listener</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"org.apache.catalina.core.JreMemoryLeakPreventionListener"</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Listener</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"org.apache.catalina.mbeans.GlobalResourcesLifecycleListener"</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Listener</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"org.apache.catalina.core.ThreadLocalLeakPreventionListener"</span> /&gt;</span><span class="hljs-comment">&lt;!-- 全局命名资源，定义了UserDatabase的一个JNDI(java命名和目录接口)，通过pathname的文件得到一个用户授权的内存数据库 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">GlobalNamingResources</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Resource</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"UserDatabase"</span> <span class="hljs-attr">auth</span>=<span class="hljs-string">"Container"</span></span><span class="hljs-tag">               <span class="hljs-attr">type</span>=<span class="hljs-string">"org.apache.catalina.UserDatabase"</span></span><span class="hljs-tag">               <span class="hljs-attr">description</span>=<span class="hljs-string">"User database that can be updated and saved"</span></span><span class="hljs-tag">               <span class="hljs-attr">factory</span>=<span class="hljs-string">"org.apache.catalina.users.MemoryUserDatabaseFactory"</span></span><span class="hljs-tag">               <span class="hljs-attr">pathname</span>=<span class="hljs-string">"conf/tomcat-users.xml"</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">GlobalNamingResources</span>&gt;</span><span class="hljs-comment">&lt;!-- Service它包含一个&lt;Engine&gt;元素,以及一个或多个&lt;Connector&gt;,这些Connector元素共享用同一个Engine元素 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Service</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"Catalina"</span>&gt;</span><span class="hljs-comment">&lt;!-- </span><span class="hljs-comment">         每个Service可以有一个或多个连接器&lt;Connector&gt;元素，</span><span class="hljs-comment">         第一个Connector元素定义了一个HTTP Connector,它通过8080端口接收HTTP请求;第二个Connector元素定</span><span class="hljs-comment">         义了一个JD Connector,它通过8009端口接收由其它服务器转发过来的请求.</span><span class="hljs-comment">     --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">port</span>=<span class="hljs-string">"8080"</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">"HTTP/1.1"</span></span><span class="hljs-tag">                <span class="hljs-attr">connectionTimeout</span>=<span class="hljs-string">"20000"</span></span><span class="hljs-tag">                <span class="hljs-attr">redirectPort</span>=<span class="hljs-string">"8443"</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">port</span>=<span class="hljs-string">"8009"</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">"AJP/1.3"</span> <span class="hljs-attr">redirectPort</span>=<span class="hljs-string">"8443"</span> /&gt;</span><span class="hljs-comment">&lt;!-- 每个Service只能有一个&lt;Engine&gt;元素 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Engine</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"Catalina"</span> <span class="hljs-attr">defaultHost</span>=<span class="hljs-string">"localhost"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Realm</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"org.apache.catalina.realm.LockOutRealm"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Realm</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"org.apache.catalina.realm.UserDatabaseRealm"</span></span><span class="hljs-tag">                <span class="hljs-attr">resourceName</span>=<span class="hljs-string">"UserDatabase"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Realm</span>&gt;</span><span class="hljs-comment">&lt;!-- 默认host配置，有几个域名就配置几个Host，但是这种只能是同一个端口号 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Host</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"localhost"</span>  <span class="hljs-attr">appBase</span>=<span class="hljs-string">"webapps"</span></span><span class="hljs-tag">             <span class="hljs-attr">unpackWARs</span>=<span class="hljs-string">"true"</span> <span class="hljs-attr">autoDeploy</span>=<span class="hljs-string">"true"</span>&gt;</span>     　　<span class="hljs-comment">&lt;!-- Tomcat的访问日志，默认可以关闭掉它，它会在logs文件里生成localhost_access_log的访问日志 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Valve</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"org.apache.catalina.valves.AccessLogValve"</span> <span class="hljs-attr">directory</span>=<span class="hljs-string">"logs"</span></span><span class="hljs-tag">                <span class="hljs-attr">prefix</span>=<span class="hljs-string">"localhost_access_log"</span> <span class="hljs-attr">suffix</span>=<span class="hljs-string">".txt"</span></span><span class="hljs-tag">                <span class="hljs-attr">pattern</span>=<span class="hljs-string">"%h %l %u %t "</span>%<span class="hljs-attr">r</span>" %<span class="hljs-attr">s</span> %<span class="hljs-attr">b</span>" /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Host</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Host</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"www.hzg.com"</span>  <span class="hljs-attr">appBase</span>=<span class="hljs-string">"webapps"</span></span><span class="hljs-tag">             <span class="hljs-attr">unpackWARs</span>=<span class="hljs-string">"true"</span> <span class="hljs-attr">autoDeploy</span>=<span class="hljs-string">"true"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Context</span> <span class="hljs-attr">path</span>=<span class="hljs-string">""</span> <span class="hljs-attr">docBase</span>=<span class="hljs-string">"/myweb1"</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Valve</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"org.apache.catalina.valves.AccessLogValve"</span> <span class="hljs-attr">directory</span>=<span class="hljs-string">"logs"</span></span><span class="hljs-tag">                <span class="hljs-attr">prefix</span>=<span class="hljs-string">"hzg_access_log"</span> <span class="hljs-attr">suffix</span>=<span class="hljs-string">".txt"</span></span><span class="hljs-tag">                <span class="hljs-attr">pattern</span>=<span class="hljs-string">"%h %l %u %t "</span>%<span class="hljs-attr">r</span>" %<span class="hljs-attr">s</span> %<span class="hljs-attr">b</span>" /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Host</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Engine</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Service</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Server</span>&gt;</span></code></pre><h4 id="server-xml中日志的patter解释"><a href="#server-xml中日志的patter解释" class="headerlink" title="server.xml中日志的patter解释"></a>server.xml中日志的patter解释</h4><p>有效的日志格式模式可以参见下面内容，如下字符串，其对应的信息由指定的响应内容取代：</p><ul><li><p>％a - 远程IP地址</p></li><li><p>％A - 本地IP地址</p></li><li><p>％b - 发送的字节数，不包括HTTP头，或“ - ”如果没有发送字节</p></li><li><p>％B - 发送的字节数，不包括HTTP头</p></li><li><p>％h - 远程主机名</p></li><li><p>％H - 请求协议</p></li><li><p>％l (小写的L)- 远程逻辑从identd的用户名（总是返回’ - ‘）</p></li><li><p>％m - 请求方法</p></li><li><p>％p - 本地端口</p></li><li><p>％q - 查询字符串（在前面加上一个“？”如果它存在，否则是一个空字符串</p></li><li><p>％r - 第一行的要求</p></li><li><p>％s - 响应的HTTP状态代码</p></li><li><p>％S - 用户会话ID</p></li><li><p>％t - 日期和时间，在通用日志格式</p></li><li><p>％u - 远程用户身份验证</p></li><li><p>％U - 请求的URL路径</p></li><li><p>％v - 本地服务器名</p></li><li><p>％D - 处理请求的时间（以毫秒为单位）</p></li><li><p>％T - 处理请求的时间（以秒为单位）</p></li><li><p>％I （大写的i） - 当前请求的线程名称</p></li></ul><h2 id="tomcat组件及架构"><a href="#tomcat组件及架构" class="headerlink" title="tomcat组件及架构"></a>tomcat组件及架构</h2><img src="/blog/2020/04/30/tomcat%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/pic2.png" srcset="/blog/img/loading.gif" class><table><thead><tr><th><strong>组件名称</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>Server</td><td>代表整个tomcat服务器，一个Tomcat只有一个Servcer。</td></tr><tr><td>Service</td><td>Server中的一个逻辑功能层，维护多个Connector和一个Container，一个Server可以包含多个Service。</td></tr><tr><td>Connector</td><td>连接器，监听转换Socket请求，将请求交给Container处理，支持不同协议以及不同的I/O方式，是Service的核心组件之一，一个Service可以有多个Connector。</td></tr><tr><td>Container</td><td>Service的另一个核心组件，按照层级有Engine、Host、Context、Wrapper四种，一个Service只有一个Engine，主要作用是执行业务逻辑。</td></tr><tr><td>Engine</td><td>Servler中层级最高的容器对象</td></tr><tr><td>Host</td><td>Servlet引擎中的虚拟机，主要与域名有关，一个服务器有多个域名是可以使用多个Host</td></tr><tr><td>Context</td><td>用于表示ServletContext,一个ServletContext表示一个独立的Web应用</td></tr><tr><td>Wrapper</td><td>用于表示Web应用中定义的Servlet</td></tr><tr><td>Executor</td><td>Tomcat组件间可以共享的线程池</td></tr></tbody></table><h3 id="请求的运行过程"><a href="#请求的运行过程" class="headerlink" title="请求的运行过程"></a>请求的运行过程</h3><img src="/blog/2020/04/30/tomcat%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/pic3.png" srcset="/blog/img/loading.gif" class><h3 id="connector连接器"><a href="#connector连接器" class="headerlink" title="connector连接器"></a>connector连接器</h3><p>Connector链接器封装了底层的网络请求(Socket请求及相应处理),提供了统一的接口，使Container容器与具体的请求协议以及I/O方式解耦。Connector将Socket输入转换成Request对象，交给Container容器进行处理，处理请求后，Container通过Connector提供的Response对象将结果写入输出流。因为无论是Request对象还是Response对象都没有实现Servlet规范对应的接口，Container会将它们进一步分装成ServletRequest和ServletResponse.</p><img src="/blog/2020/04/30/tomcat%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/pic4.png" srcset="/blog/img/loading.gif" class><p>三种传输协议</p><ul><li>HTTP：HTTP/1.1协议</li><li>AJP协议：主要与Apache HTTP Server集成，主要用于处理静态资源，AJP采用二进制传输可读性文本，使用保持持久性的TCP链接，使得AJP占用更少的带宽，并且链接开销要小得多，但是由于AJP采用持久化链接，因此有效的连接数较HTTP要更多。</li><li>HTTP2：HTTP/2.0协议，下一代HTTP协议，目前市场不成熟。</li></ul><p>三种I/O方式</p><ul><li>NIO：采用JDK的NIO类库实现</li><li>NIO2(AIO)：采用JDK1.7的NIO2类库实现</li><li>APR：采用APR(Apache可移植运行库)</li></ul><table><thead><tr><th><strong>protocol</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>HTTP/1.1</td><td>默认值</td></tr><tr><td>org.apache.coyote.http11.Http11NioProtocol</td><td>http+Nio的方式</td></tr><tr><td>org.apache.coyote.http11.Http11Nio2Protocol</td><td>http+Nio2的方式（AIO）</td></tr><tr><td>org.apache.coyote.http11.Http11AprProtocol</td><td>http+Apr的方式</td></tr></tbody></table><p>对于I/0选择，要根据业务场景来定，一般高并发场景下，APR和NIO2的性能要优于NIO和BIO，（linux操作系统支持的NIO2由于是一个假的，并没有真正实现AIO，所以一般linux上推荐使用NIO，如果是APR的话，需要安装APR库，而Windows上默认安装了），所以在8.5的版本中默认是NIO。</p>]]></content>
    
    
    <categories>
      
      <category>tomcat</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tomcat</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis的弱事务</title>
    <link href="/blog/2020/04/29/redis%E7%9A%84%E5%BC%B1%E4%BA%8B%E5%8A%A1/"/>
    <url>/blog/2020/04/29/redis%E7%9A%84%E5%BC%B1%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="RESP协议"><a href="#RESP协议" class="headerlink" title="RESP协议"></a>RESP协议</h2><p>Redis服务器与客户端通过RESP(REdisSerializationProtocol)协议通信。主要以下特点：实现简单、解析快、人类可读。RESP底层采用的是TCP的连接方式，通过tcp进行数据传输，然后根据解析规则解析相应信息，完成交互。</p><p>我们可以测试下，首先运行一个serverSocket监听6379，来接收redis客户端的请求信息，实现如下：</p><p>服务端程序如下：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerRedis</span></span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;    <span class="hljs-keyword">try</span> &#123;      ServerSocket server = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">6379</span>);      Socket rec = server.accept();      <span class="hljs-keyword">byte</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">2048</span>];      rec.getInputStream().read(result);      System.out.println(<span class="hljs-keyword">new</span> String(result))    &#125; <span class="hljs-keyword">catch</span> (IOException e)&#123;      e.printStackTrace();    &#125;  &#125;&#125;</code></pre><p>客户端程序如下：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JedisTest</span></span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;    Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">"127.0.0.1"</span>,<span class="hljs-number">6379</span>);    jedis.set(<span class="hljs-string">"key"</span>,<span class="hljs-string">"value"</span>);    jedis.close();  &#125;&#125;</code></pre><p>服务端打印的信息如下：</p><pre><code class="hljs routeros"><span class="hljs-number">*3</span><span class="hljs-variable">$3</span>SET<span class="hljs-variable">$3</span>key<span class="hljs-variable">$5</span>value</code></pre><p>其中*表示后面有几组数据，set key value共三组，所以为*3</p><p>$表示本组数据的长度，所以SET、key为3，value为5</p><h2 id="数据库表数据存储到redis"><a href="#数据库表数据存储到redis" class="headerlink" title="数据库表数据存储到redis"></a>数据库表数据存储到redis</h2><p>原理就是将数据库中查询出的数据按照RESP协议处理，然后使用PIPE管道导入到redis。</p><p>流程如下:</p><ul><li>使用用户名和密码登陆连接数据库</li><li>登陆成功后执行order.sql的select语句得到查询结果集result</li><li>使用密码登陆Redis</li><li>Redis登陆成功后，使用PIPE管道将result导入redis。</li></ul><p>操作指令如下:<br><code>mysql -utest -ptest stress --default-character-set=utf8 --skip-column-names --raw &lt; order.sql | redis-cli -h 192.168.42.111 -p 6379 -a 12345678 --pipe</code></p><p>–raw是指将order.sql中的文件按行执行。</p><p>order.sql文件</p><pre><code class="hljs mysql">SELECT CONCAT( &#39;*10\r\n&#39;,   &#39;$&#39;, LENGTH(redis_cmd), &#39;\r\n&#39;, redis_cmd, &#39;\r\n&#39;,   &#39;$&#39;, LENGTH(redis_key), &#39;\r\n&#39;, redis_key, &#39;\r\n&#39;,   &#39;$&#39;, LENGTH(hkey1),&#39;\r\n&#39;,hkey1,&#39;\r\n&#39;,   &#39;$&#39;, LENGTH(hval1),&#39;\r\n&#39;,hval1,&#39;\r\n&#39;,   &#39;$&#39;, LENGTH(hkey2),&#39;\r\n&#39;,hkey2,&#39;\r\n&#39;,   &#39;$&#39;, LENGTH(hval2),&#39;\r\n&#39;,hval2,&#39;\r\n&#39;,   &#39;$&#39;, LENGTH(hkey3),&#39;\r\n&#39;,hkey3,&#39;\r\n&#39;,   &#39;$&#39;, LENGTH(hval3),&#39;\r\n&#39;,hval3,&#39;\r\n&#39;,   &#39;$&#39;, LENGTH(hkey4),&#39;\r\n&#39;,hkey4,&#39;\r\n&#39;,   &#39;$&#39;, LENGTH(hval4),&#39;\r\n&#39;,hval4,&#39;\r&#39;)FROM ( SELECT &#39;HSET&#39; AS redis_cmd, CONCAT(&#39;order:info:&#39;,orderid) AS redis_key, &#39;ordertime&#39; AS hkey1, ordertime AS hval1, &#39;ordermoney&#39; AS hkey2, ordermoney AS hval2, &#39;orderstatus&#39; AS hkey3, orderstatus AS hval3, &#39;version&#39; AS hkey4, &#96;version&#96; AS hval4 FROM &#96;order&#96;) AS t</code></pre><h2 id="socket连接redis"><a href="#socket连接redis" class="headerlink" title="socket连接redis"></a>socket连接redis</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SocketRedis</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">set</span><span class="hljs-params">(Socket socket,String key, String value)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        StringBuffer str = <span class="hljs-keyword">new</span> StringBuffer();        str.append(<span class="hljs-string">"*3"</span>).append(<span class="hljs-string">"\r\n"</span>);        str.append(<span class="hljs-string">"$3"</span>).append(<span class="hljs-string">"\r\n"</span>);        str.append(<span class="hljs-string">"SET"</span>).append(<span class="hljs-string">"\r\n"</span>);        str.append(<span class="hljs-string">"$"</span>).append(key.getBytes().length).append(<span class="hljs-string">"\r\n"</span>);        str.append(key).append(<span class="hljs-string">"\r\n"</span>);        str.append(<span class="hljs-string">"$"</span>).append(value.getBytes().length).append(<span class="hljs-string">"\r\n"</span>);        str.append(value).append(<span class="hljs-string">"\r\n"</span>);        socket.getOutputStream().write(str.toString().getBytes());        <span class="hljs-keyword">byte</span>[] response = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">2048</span>];        socket.getInputStream().read(response);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(response);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">get</span><span class="hljs-params">(Socket socket,String key)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        StringBuffer str = <span class="hljs-keyword">new</span> StringBuffer();        str.append(<span class="hljs-string">"*2"</span>).append(<span class="hljs-string">"\r\n"</span>);        str.append(<span class="hljs-string">"$3"</span>).append(<span class="hljs-string">"\r\n"</span>);        str.append(<span class="hljs-string">"GET"</span>).append(<span class="hljs-string">"\r\n"</span>);        str.append(<span class="hljs-string">"$"</span>).append(key.getBytes().length).append(<span class="hljs-string">"\r\n"</span>);        str.append(key).append(<span class="hljs-string">"\r\n"</span>);        socket.getOutputStream().write(str.toString().getBytes());        <span class="hljs-keyword">byte</span>[] response = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">2048</span>];        socket.getInputStream().read(response);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(response);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        Socket socket = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">"127.0.0.1"</span>,<span class="hljs-number">6379</span>);        set(socket,<span class="hljs-string">"test"</span>,<span class="hljs-string">"value"</span>);        System.out.println(get(socket,<span class="hljs-string">"test"</span>));    &#125;&#125;</code></pre><h2 id="PIPELINE操作"><a href="#PIPELINE操作" class="headerlink" title="PIPELINE操作"></a>PIPELINE操作</h2><p>单指令批量操作执行过程</p><p>每次执行命令前都需要通过网络发送命令、获取结果，网络开销大，对执行时间有比较大的影响。</p><p>pipeline可以将多个指令封装，然后请求到redis，返回结果，这样只需要通过网络发送、返回一次，减少了网络开销。</p><p>使用方法</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServiceTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delNoPipe</span><span class="hljs-params">(String...keys)</span></span>&#123;        Jedis jedis = <span class="hljs-keyword">new</span> Jedis(RedisTools.ip,RedisTools.port);        Pipeline pipelined = jedis.pipelined();        <span class="hljs-keyword">for</span>(String key:keys)&#123;            pipelined.del(key);<span class="hljs-comment">//redis?</span>        &#125;        pipelined.sync();<span class="hljs-comment">//</span>        jedis.close();    &#125;&#125;</code></pre><h2 id="redis事务"><a href="#redis事务" class="headerlink" title="redis事务"></a>redis事务</h2><p>pipeline其实是对多条命令的组合，为了保证它的原子性，redis提供了简单的事务。使用方法为将一组需要一起执行的命令放到multi和exec两个命令之间，其中multi代表事务开始，exec代表事务结束，discard取消事务，watch命令用于监视key，如果事务执行之前key被改动，事务将被打断（取消），对应的有unwatch命令，用于取消watch操作。</p><p>如果事务执行中，出现命令错误，导致事务不能正常结束，就会发生回滚。但如果出现类型错误，事务可以正常结束，就不会在进行回滚。</p><h2 id="redis发布与订阅"><a href="#redis发布与订阅" class="headerlink" title="redis发布与订阅"></a>redis发布与订阅</h2><p>redis提供了“发布、订阅”模式的消息机制，其中消息订阅者与发布者不直接通信，发布者向指定的频道（channel）发布消息，订阅该频道的每个客户端都可以接收到消息。</p><p>redis主要提供发布消息、订阅频道、取消订阅以及按照模式订阅和取消订阅，和很多专业的消息队列kafka rabbitmq相比比较简单，比如无法实现消息规程和回溯，可以使用在简单的应用。</p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul><li>发布消息：<code>publish {channel} {message}</code></li><li>订阅消息：<code>subscrible {channel}</code></li><li>查看订阅数：<code>pubsub numsub {channel}</code></li><li>取消订阅：<code>unsubscribe {channel}</code></li><li>按模式（模糊匹配）订阅和取消订阅：<code>psubscribe ch*</code> <code>punsubscribe ch*</code></li></ul><h2 id="键的迁移"><a href="#键的迁移" class="headerlink" title="键的迁移"></a>键的迁移</h2><p>把部分数据迁移到另一台redis服务器，</p><ul><li><code>move {key} {db}</code> ：db为数据库编号，reids共有16个库， 编号为0－15，这种模式不建议在生产环境使用。数据库切换可以使用<code>select {db}</code>。</li><li><code>dump {key}</code>：在迁出的数据库上使用<code>dum {key}</code>，然后将获取到的值value复制到迁入的数据库，使用<code>restore {key} {time} {value}</code>。</li><li><code>migrate {迁入的目标ip} {端口} {key} {db} {timeout} copy|replace</code>：migrate命令是将dump、restore、del三个命令进行组合，从而简化了操作流程。migrate命令具有原子性，从Redis 3.0.6版本后已经支持迁移多个键的功能。migrate命令的数据传输直接在源Redis和目标Redis上完成，目标Redis完成restore后会发送OK给源Redis。</li></ul><h2 id="key的遍历"><a href="#key的遍历" class="headerlink" title="key的遍历"></a>key的遍历</h2><h3 id="全量遍历"><a href="#全量遍历" class="headerlink" title="全量遍历"></a>全量遍历</h3><p><code>keys  *</code>：返回所有的键, *匹配任意字符多个字符，全局匹配 ，可以使用正则表达式</p><p><code>keys n?me</code>：?问号代表只匹配一个字符 </p><p><code>keys [j,l]*</code>：返回以j、l开头的所有键</p><h3 id="渐进式遍历"><a href="#渐进式遍历" class="headerlink" title="渐进式遍历"></a>渐进式遍历</h3><p><code>scan 0 match n* count 5</code>：匹配以n开头的键，最大是取5条，第一次0开始，相当于一页一页的取，第二次取时将0改为返回的游标，当最后游标返回0时，键被取完。</p><p>scan相比keys具备有以下特点:</p><ol><li>通过游标分布进行的，不会阻塞线程;</li><li>提供limit参数，可以控制每次返回结果的最大条数，limit不准，返回的结果可多可少;</li><li>同keys一样，Scan也提供模式匹配功能;</li><li>服务器不需要为游标保存状态，游标的唯一状态就是scan返回给客户端的游标整数;</li><li>scan返回的结果可能会有重复，需要客户端去重复;</li><li>scan遍历的过程中如果有数据修改，改动后的数据能不能遍历到是不确定的;</li><li>单次返回的结果是空的并不意味着遍历结束，而要看返回的游标值是否为零;</li></ol><h3 id="其他数据结构的遍历"><a href="#其他数据结构的遍历" class="headerlink" title="其他数据结构的遍历"></a>其他数据结构的遍历</h3><p>除scan字符串外：还有以下命令，用法和scan一样。</p><ul><li>SCAN 命令用于迭代当前数据库中的数据库键。</li><li>SSCAN 命令用于迭代集合键中的元素。</li><li>HSCAN 命令用于迭代哈希键中的键值对。</li><li>ZSCAN 命令用于迭代有序集合中的元素（包括元素成员和元素分值）。</li></ul>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis性能测试</title>
    <link href="/blog/2020/04/29/redis%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    <url>/blog/2020/04/29/redis%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h2 id="redis慢查询"><a href="#redis慢查询" class="headerlink" title="redis慢查询"></a>redis慢查询</h2><p>与mysql一样，当执行时间超过极大值时，会将发生时间耗时命令记录。</p><img src="/blog/2020/04/29/redis%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/pic1.png" srcset="/blog/img/loading.gif" class><p>redis命令生命周期为发送、排队、执行、返回，慢查询只统计执行步骤的时间。</p><h3 id="慢查询的设置"><a href="#慢查询的设置" class="headerlink" title="慢查询的设置"></a>慢查询的设置</h3><p>慢查询极值的设置有两种方式</p><ul><li><p>使用<code>config set slowlog-log-slower-than 10000</code>命令修改，单位为微妙，redis重启后会失效。</p></li><li><p>修改redis.conf文件中的<code>slowlog-log-slower-than 10000</code>修改保存即可，设置为0时记录所有命令，-1时命令都不记录。</p></li></ul><p><code>slowlog-log-slower-than</code>默认为10毫秒，根据redis并发量来调整，对于高并发比建议为1毫秒。</p><p>慢查询记录是存在队列中的，可以通过<code>slow-max-len</code>设置存放记录的最大条数，比如设置的<code>slow-max-len＝10</code>，当有第11条慢查询命令插入时，队列的第一条命令就会出列，第11条入列， 可以设置方式与极值设置相同，可以<code>config set</code>动态设置，也可以修改redis.conf完成配置。线上可加大<code>slow-max-len</code>的值，记录慢查询存长命令时redis会做截断，不会占用大量内存，线上可设置1000以上。</p><p>慢查询是先进先出的队列，访问日志记录出列丢失，需定期执行slowlog get,将结果存储到其它设备中（如mysql）。</p><h3 id="慢查询命令"><a href="#慢查询命令" class="headerlink" title="慢查询命令"></a>慢查询命令</h3><ul><li>获取队列里慢查询的命令：<code>slowlog get</code></li><li>获取慢查询列表当前的长度：<code>slowlog len</code></li><li>对慢查询列表清理（重置）：<code>slowlog reset</code></li></ul><h2 id="redis性能测试"><a href="#redis性能测试" class="headerlink" title="redis性能测试"></a>redis性能测试</h2><p>可以使用redis的bin目录中的redis-benchmark命令进行测试</p><ul><li><code>redis-benchmark -h 192.168.42.111 -p 6379 -c 100 -n 10000</code>：100个并发连接，10000个请求，检测服务器性能 </li><li><code>redis-benchmark -h 192.168.42.111 -p 6379 -q -d 100</code>：测试存取大小为100字节的数据包的性能</li><li><code>redis-benchmark -h 192.168.42.111 -p 6379 -t set,get -n 100000 -q</code>：只测试 set,lpush操作的性能</li><li><code>redis-benchmark -h 192.168.42.111 -p 6379 -n 100000 -q script load &quot;redis.call(&#39;set&#39;,&#39;foo&#39;,&#39;bar&#39;)&quot;</code>：只测试某些数值存取的性能</li></ul>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis+lua实现抢红包</title>
    <link href="/blog/2020/04/29/redis-lua%E5%AE%9E%E7%8E%B0%E6%8A%A2%E7%BA%A2%E5%8C%85/"/>
    <url>/blog/2020/04/29/redis-lua%E5%AE%9E%E7%8E%B0%E6%8A%A2%E7%BA%A2%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h2 id="业务需求"><a href="#业务需求" class="headerlink" title="业务需求"></a>业务需求</h2><ol><li>将所有红包全部存储到Redis。</li><li>记录红包被抢的详情信息。</li><li>用户只能抢一次红包，不能重复抢红包。</li></ol><h2 id="结构设计"><a href="#结构设计" class="headerlink" title="结构设计"></a>结构设计</h2><img src="/blog/2020/04/29/redis-lua%E5%AE%9E%E7%8E%B0%E6%8A%A2%E7%BA%A2%E5%8C%85/pic1.png" srcset="/blog/img/loading.gif" class><img src="/blog/2020/04/29/redis-lua%E5%AE%9E%E7%8E%B0%E6%8A%A2%E7%BA%A2%E5%8C%85/pic2.png" srcset="/blog/img/loading.gif" class><img src="/blog/2020/04/29/redis-lua%E5%AE%9E%E7%8E%B0%E6%8A%A2%E7%BA%A2%E5%8C%85/pic3.png" srcset="/blog/img/loading.gif" class><h2 id="业务流程"><a href="#业务流程" class="headerlink" title="业务流程"></a>业务流程</h2><img src="/blog/2020/04/29/redis-lua%E5%AE%9E%E7%8E%B0%E6%8A%A2%E7%BA%A2%E5%8C%85/pic4.png" srcset="/blog/img/loading.gif" class><p><code>Object object=jedis.eval(getHongBaoScript,4,hongBaoPoolKey,hongBaoDetailListKey,userIdRecordKey,userid);</code></p><pre><code class="hljs lua"><span class="hljs-keyword">if</span> redis.call(<span class="hljs-string">'hexists'</span>,KEYS[<span class="hljs-number">3</span>],KEYS[<span class="hljs-number">4</span>]) ~=<span class="hljs-number">0</span> <span class="hljs-keyword">then</span>  <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><span class="hljs-keyword">else</span>  <span class="hljs-keyword">local</span> hongBao = redis.call(<span class="hljs-string">'rpop'</span>,KEYS[<span class="hljs-number">1</span>]);  <span class="hljs-keyword">if</span> hongBao <span class="hljs-keyword">then</span>    <span class="hljs-keyword">local</span> x = cjson.decode(hongBao);    x[<span class="hljs-string">'userId'</span>] = KEYS[<span class="hljs-number">4</span>];    <span class="hljs-keyword">local</span> re = cjson.encode(x);    redis.call(<span class="hljs-string">'hset'</span>,KEYS[<span class="hljs-number">3</span>],KEYS[<span class="hljs-number">4</span>],<span class="hljs-string">'1'</span>);    redis.call(<span class="hljs-string">'lpush'</span>,KEYS[<span class="hljs-number">2</span>],re);    <span class="hljs-keyword">return</span> re;  <span class="hljs-keyword">end</span><span class="hljs-keyword">end</span><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis+lua实现限流</title>
    <link href="/blog/2020/04/29/redis-lua%E5%AE%9E%E7%8E%B0%E9%99%90%E6%B5%81/"/>
    <url>/blog/2020/04/29/redis-lua%E5%AE%9E%E7%8E%B0%E9%99%90%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h2 id="lua语言介绍"><a href="#lua语言介绍" class="headerlink" title="lua语言介绍"></a>lua语言介绍</h2><p>LUA脚本语言是C开发的，类似存储过程，使用LUA脚本的好处：</p><ul><li>减少网络开销，在Lua脚本中可以把多个命令放在同一个脚本中运行。</li><li>原子操作，redis会将整个脚本作为一个整体执行，中间不会被其他命令插入。换句话说，编写脚本的过程中无需担心会出现竞态条件。</li><li>复用性，客户端发送的脚本会永远存储在redis中，这意味着其他客户端可以复用这一脚本来完成同样的逻辑。</li></ul><h2 id="Lua在linux中的安装"><a href="#Lua在linux中的安装" class="headerlink" title="Lua在linux中的安装"></a>Lua在linux中的安装</h2><p>到官网下载lua的tar.gz的源码包</p><pre><code class="hljs sh">wget http://www.lua.org/ftp/lua-5.3.5.tar.gztar -zxvf lua-5.3.0.tar.gz<span class="hljs-built_in">cd</span> lua-5.2.0make linuxmake install</code></pre><p>如果报错，说找不到readline/readline.h, 可以通过yum命令安装</p><pre><code class="hljs sh">yum -y install libtermcap-devel ncurses-devel libevent-devel readline-develmake linux  / make install</code></pre><p>最后，直接输入 lua命令即可进入lua的控制台</p><h2 id="lua基本语法"><a href="#lua基本语法" class="headerlink" title="lua基本语法"></a>lua基本语法</h2><ul><li>单行注释  –</li><li>多行注释–[[ –]]</li><li>Lua关键字</li></ul><table><thead><tr><th>and</th><th>break</th><th>do</th><th>else</th></tr></thead><tbody><tr><td>elseif</td><td>end</td><td>false</td><td>for</td></tr><tr><td>function</td><td>if</td><td>in</td><td>local</td></tr><tr><td>nil</td><td>not</td><td>or</td><td>repeat</td></tr><tr><td>return</td><td>then</td><td>true</td><td>until</td></tr><tr><td>while</td><td></td><td></td><td></td></tr></tbody></table><h2 id="lua数据类型"><a href="#lua数据类型" class="headerlink" title="lua数据类型"></a>lua数据类型</h2><p>Lua是动态类型语言，变量不要类型定义只需要为变量赋值。 值可以存储在变量中，作为参数传递或结果返回。</p><p>Lua中有8个基本类型分别为：nil、boolean、number、string、userdata、function、thread和table。</p><table><thead><tr><th>数据类型</th><th>描述</th></tr></thead><tbody><tr><td>nil</td><td>这个最简单，只有值nil属于该类，表示一个无效值（在条件表达式中相当于false）。</td></tr><tr><td>boolean</td><td>包含两个值：false和true。</td></tr><tr><td>number</td><td>表示双精度类型的实浮点数</td></tr><tr><td>string</td><td>字符串由一对双引号或单引号来表示</td></tr><tr><td>function</td><td>由 C 或 Lua 编写的函数</td></tr><tr><td>userdata</td><td>表示任意存储在变量中的C数据结构</td></tr><tr><td>thread</td><td>表示执行的独立线路，用于执行协同程序</td></tr><tr><td>table</td><td>Lua 中的表（table）其实是一个”关联数组”（associative arrays），数组的索引可以是数字或者是字符串。在 Lua 里，table 的创建是通过”构造表达式”来完成，最简单构造表达式是{}，用来创建一个空表。</td></tr></tbody></table><h2 id="lua执行流程"><a href="#lua执行流程" class="headerlink" title="lua执行流程"></a>lua执行流程</h2><h2 id="lua脚本的使用"><a href="#lua脚本的使用" class="headerlink" title="lua脚本的使用"></a>lua脚本的使用</h2><p>redis客户端连接成功后：</p><ul><li><p><code>script load &quot;$(cat xxxx.lua)&quot;</code>：将LUA脚本内容加载到redis， 返回的sha1值。</p></li><li><p><code>evalsha &quot;{sha1}&quot; {key} {arg}</code>：执行sha1值对应的脚本</p></li><li><p><code>script exists {sha1}</code>：检查sha1值的LUA脚本是否加载到redis中， 返回1为已加载成功。</p></li><li><p><code>script flush</code>：清空加载的lua脚本内容。</p></li><li><p><code>script kill</code>：杀掉正在执行的LUA脚本，比如LUA比较耗时阻塞，杀掉。</p></li></ul><h2 id="限流的方式"><a href="#限流的方式" class="headerlink" title="限流的方式"></a>限流的方式</h2><p>限制总并发数：比如数据库连接池、线程池</p><p>限制瞬时并发数：如nginx的limit_conn模块，用来限制瞬时并发连接数</p><p>限制时间窗口内的平均速率：如Guava的RateLimiter、nginx的limit_req模块，限制每秒平均速率</p><p>其它限制：如限制远程接口调用速率、限制MQ的消费速率</p><h2 id="java-redis实现限流"><a href="#java-redis实现限流" class="headerlink" title="java+redis实现限流"></a>java+redis实现限流</h2><p>实现某个ip在一定时间之内在time之内，只能访问limit次</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">accessLimit</span><span class="hljs-params">(String ip,<span class="hljs-keyword">int</span> limit,Jedis jedis)</span></span>&#123;  <span class="hljs-keyword">boolean</span> result=<span class="hljs-keyword">true</span>;  String key=<span class="hljs-string">"rate.limit"</span> + ip;  <span class="hljs-keyword">if</span>(jedis.exist(key))&#123;    <span class="hljs-keyword">long</span> afterValue = jedis.incr(key);    <span class="hljs-keyword">if</span>(afterValue &gt; limit)&#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;  &#125;eles&#123;    Transaction transaction = jedis.multi();    transaction.incr(key);    transaction.expire(key,time);    transaction.exec();  &#125;  <span class="hljs-keyword">return</span> result;&#125;</code></pre><p>但这种实现方式使用的redis的事务是弱事务不支持回滚，并不能完全保证操作的原子性，当多线程操作同一个key时可能会出现竞态问题。</p><h2 id="redis-lua实现限流"><a href="#redis-lua实现限流" class="headerlink" title="redis+lua实现限流"></a>redis+lua实现限流</h2><p>lua脚本</p><pre><code class="hljs lua"><span class="hljs-keyword">local</span> key =  KEYS[<span class="hljs-number">1</span>]<span class="hljs-keyword">local</span> limit = <span class="hljs-built_in">tonumber</span>(ARGV[<span class="hljs-number">1</span>])<span class="hljs-keyword">local</span> expire_time = ARGV[<span class="hljs-number">2</span>]<span class="hljs-keyword">local</span> is_exists = redis.call(<span class="hljs-string">"EXISTS"</span>, key)<span class="hljs-keyword">if</span> is_exists == <span class="hljs-number">1</span> <span class="hljs-keyword">then</span>    <span class="hljs-keyword">if</span> redis.call(<span class="hljs-string">"INCR"</span>, key) &gt; limit <span class="hljs-keyword">then</span>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    <span class="hljs-keyword">else</span>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>    <span class="hljs-keyword">end</span><span class="hljs-keyword">else</span>    redis.call(<span class="hljs-string">"SET"</span>, key, <span class="hljs-number">1</span>)    redis.call(<span class="hljs-string">"EXPIRE"</span>, key, expire_time)    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><span class="hljs-keyword">end</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis常见场景设计</title>
    <link href="/blog/2020/04/29/redis%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1/"/>
    <url>/blog/2020/04/29/redis%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="key设计的注意事项"><a href="#key设计的注意事项" class="headerlink" title="key设计的注意事项"></a>key设计的注意事项</h2><p>一般以业务功能模块或者表名为前缀，再加上唯一主键，中间以冒号分隔，比如购物车cart:001，表示1号用户的购物车。设计以简短、明了以主， 节约内存。</p><h2 id="redis分布式锁"><a href="#redis分布式锁" class="headerlink" title="redis分布式锁"></a>redis分布式锁</h2><h4 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h4><p><code>SETNX {key} {value} ex|px {time}</code>指令可以将key的值设为value并指定一个失效时间，SETNX是SET if Not eXists(如果不存在，则 SET)的简写，如果key已经存在，则SETNX不会成功。</p><p>在加锁时通过setnx向特定的key写入一个随机值，并同时设置失效时间，写值成功既加锁成功。</p><p>注意：</p><ul><li>必须给锁设置一个失效时间， 避免死锁问题。</li><li>加锁时必须写入一个随机字符串，用于解锁时避免锁的误删。</li><li>整个过程必须是原子的。</li></ul><h4 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h4><p>解锁步骤为：</p><ol><li>获取key上的值</li><li>判断value中的随机字符串是否一致</li><li>删除数据</li></ol><p>这三个步骤必须要保证原子性，所以要借助lua脚本执行。</p><p>lua脚本：</p><pre><code class="hljs java"><span class="hljs-keyword">if</span> redis.call(<span class="hljs-string">"get"</span>,KEYS[<span class="hljs-number">1</span>]) == ARGV[<span class="hljs-number">1</span>] then    <span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">"del"</span>,KEYS[<span class="hljs-number">1</span>])<span class="hljs-keyword">else</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>end</code></pre><p>具体实现：</p><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Lock</span> </span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String  KEY = <span class="hljs-string">"LOCK_KEY"</span>;<span class="hljs-meta">@Resource</span><span class="hljs-keyword">private</span> JedisConnectionFactory factory;<span class="hljs-keyword">private</span> ThreadLocal&lt;String&gt; local = <span class="hljs-keyword">new</span> ThreadLocal&lt;&gt;();<span class="hljs-meta">@Override</span><span class="hljs-comment">//阻塞式的加锁</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//1.尝试加锁</span><span class="hljs-keyword">if</span>(tryLock())&#123;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-comment">//2.加锁失败，当前任务休眠一段时间</span><span class="hljs-keyword">try</span> &#123;Thread.sleep(<span class="hljs-number">10</span>);<span class="hljs-comment">//性能浪费</span>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;<span class="hljs-comment">//3.递归调用，再次去抢锁</span>lock();&#125;<span class="hljs-meta">@Override</span><span class="hljs-comment">//阻塞式加锁,使用setNx命令返回OK的加锁成功，并生产随机值</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//产生随机值，标识本次锁编号</span>String uuid = UUID.randomUUID().toString();Jedis jedis = (Jedis) factory.getConnection().getNativeConnection();<span class="hljs-comment">/**</span><span class="hljs-comment"> * key:我们使用key来当锁</span><span class="hljs-comment"> * uuid:唯一标识，这个锁是我加的，属于我</span><span class="hljs-comment"> * NX：设入模式【SET_IF_NOT_EXIST】--仅当key不存在时，本语句的值才设入</span><span class="hljs-comment"> * PX：给key加有效期</span><span class="hljs-comment"> * 1000：有效时间为 1 秒</span><span class="hljs-comment"> */</span>String ret = jedis.set(KEY, uuid,<span class="hljs-string">"NX"</span>,<span class="hljs-string">"PX"</span>,<span class="hljs-number">1000</span>);<span class="hljs-comment">//设值成功--抢到了锁</span><span class="hljs-keyword">if</span>(<span class="hljs-string">"OK"</span>.equals(ret))&#123;local.set(uuid);<span class="hljs-comment">//抢锁成功，把锁标识号记录入本线程--- Threadlocal</span><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;<span class="hljs-comment">//key值里面有了，我的uuid未能设入进去，抢锁失败</span><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;<span class="hljs-comment">//正确解锁方式</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//读取lua脚本</span>String script = FileUtils.getScript(<span class="hljs-string">"unlock.lua"</span>);<span class="hljs-comment">//获取redis的原始连接</span>Jedis jedis = (Jedis) factory.getConnection().getNativeConnection();<span class="hljs-comment">//通过原始连接连接redis执行lua脚本</span>jedis.eval(script, Arrays.asList(KEY), Arrays.asList(local.get()));&#125;<span class="hljs-comment">//-----------------------------------------------</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Condition <span class="hljs-title">newCondition</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">(<span class="hljs-keyword">long</span> time, TimeUnit unit)</span></span><span class="hljs-function"><span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;&#125;&#125;</code></pre><h2 id="购物车"><a href="#购物车" class="headerlink" title="购物车"></a>购物车</h2><p>所需要的功能：</p><ul><li><p>全选功能：获取该用户的所有购物车商品</p></li><li><p>商品数量：购物车里商品的总数</p></li><li><p>删除：要能移除购物车里某个商品</p></li><li><p>增加或减少某个商品的数量</p></li></ul><p>设计实现：以当前登录用户ID号做为key，商品ID号为field, 加入购物车数量为value。如<code>hmset cart:001 prod:01 1 prod:02 1</code>。</p><h2 id="堆栈功能"><a href="#堆栈功能" class="headerlink" title="堆栈功能"></a>堆栈功能</h2><p>可以利用List实现堆、栈的先进后出，先进先出功能</p><ul><li>先进后出：存取操作都在队列左端或右端即可，如LPUSH+LPOP</li><li>先进先出：存取操作的两端必须相反，如LPUSH + RPOP</li></ul><h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><img src="/blog/2020/04/29/redis%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1/pic1.png" srcset="/blog/img/loading.gif" class><p>阻塞队列可以使用BRPOP指令来实现，当队列中没有元素是会一直阻塞。</p><h2 id="生成数据库主键标识"><a href="#生成数据库主键标识" class="headerlink" title="生成数据库主键标识"></a>生成数据库主键标识</h2><p>可以使用incr指令在入库前将对应的主键加1，但redis每秒支持的并发量是有上限的，这么做会对redis的性能有比较大的影响，这时可以通过incry指令一次获取多个主键标识，如<code>incrby serialNo 1000</code>获取1000个标识，放到系统中使用，使用完后再去获取。</p><h2 id="文章列表"><a href="#文章列表" class="headerlink" title="文章列表"></a>文章列表</h2><p>发表文章时将文章ID加入list中，然后通过lrange指令获取，如</p><ul><li><p>XX发布一篇文章ID为999：<code>lpush mes:004 999</code></p></li><li><p>XXX也发布了一条消息ID为1000：<code>lpush mes:004 1000</code></p></li><li><p>获取文章列表实现如下：<code>lrange mes:004 0 5</code></p></li></ul><h2 id="抽奖"><a href="#抽奖" class="headerlink" title="抽奖"></a>抽奖</h2><p>可以使用set实现，将所有参与者加入set中，然后用srandmember或者spop命令随机抽取，如：</p><p>活动id为001，用户id为004</p><ul><li>当004参与抽奖时放入set集合：<code>sadd act:001 004</code></li><li>抽取2名中奖者：<code>srandmember act:001 2</code>或<code>spop act:001 2</code>，spop会移除用户。</li><li>查看有多少用户参加了本次抽奖：<code>smembers act:001</code></li></ul><h2 id="点赞"><a href="#点赞" class="headerlink" title="点赞"></a>点赞</h2><p>点赞的实现也可以借助set，如果有顺序要求可以使用zset</p><p>如张三用户id为01</p><ul><li><p>张三对消息008点赞<code>sadd zan:008  userId:01</code></p></li><li><p>张三取消了对消息008的点赞<code>srem zan:008  userId:01</code></p></li><li><p>检查用户是否点过赞<code>sismember zan:008  userId:01</code></p></li><li><p>获取消息008所有的点赞用户列表<code>smembers zan:008</code></p></li><li><p>消息008的点赞数计算<code>scard zan:008</code></p></li></ul><h2 id="关注"><a href="#关注" class="headerlink" title="关注"></a>关注</h2><ul><li>user1关注的人：<code>sadd user1:care user2,user4,user5,user3</code></li><li>user2关注的人：<code>sadd user2:care user1,user3,user6,user5</code></li><li>user3关注的人：<code>sadd user3:care deer,user6,user5</code></li><li>user1和user2共同关注的人，求交集：<code>sinter user1:care user2:care</code>, 计算结果为 {user3, user5}</li><li>user1关注的人也关注user5，判断user5是否在关注的人的集合中存在：<code>sismember user2:care user5</code>，<code>sismember user3:care user5</code></li><li>user1可能认识的人，也可以先并集后差集：<code>SDIFF user2:care user1:care</code>，结果为{user1.user6}</li></ul><h2 id="每日热搜"><a href="#每日热搜" class="headerlink" title="每日热搜"></a>每日热搜</h2><p>热搜功能可以使用zset来实现，以日期做为Key ：</p><ul><li>点击id为1的话题： <code>zincrby topic:20191022 1 topic:1</code></li><li>展示今日前20排名：<code>zrevrange topic:20191022 0 20 withscores</code></li><li>统计近3日点击数据：<code>zunionstore topic:20191022-20191020 3 topic:20191022 topic:20191021 topic:20191020</code></li><li>展示近3日的排行前9名：<code>zrevrange topic:20191022-20191020 0 9 withscores</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis的指令</title>
    <link href="/blog/2020/04/28/redis%E7%9A%84%E6%8C%87%E4%BB%A4/"/>
    <url>/blog/2020/04/28/redis%E7%9A%84%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="指令使用"><a href="#指令使用" class="headerlink" title="指令使用"></a>指令使用</h2><h3 id="通用指令"><a href="#通用指令" class="headerlink" title="通用指令"></a>通用指令</h3><ol><li>查看所有键：keys * </li><li>键总数：dbsize //如果存在大量键，线上禁止使用此指令</li><li>检查键是否存在：exists {key} //存在返回1，不存在返回0</li><li>删除键：del {key} //返回删除键个数，删除不存在键返回0</li><li>键过期：expire {key} {seconds}</li><li>查看剩余过期时间：ttl {key}</li><li>键的数据结构类型：type {key}</li><li>切换数据库：select {0-15} //默认为0</li></ol><h3 id="字符串指令"><a href="#字符串指令" class="headerlink" title="字符串指令"></a>字符串指令</h3><ul><li><p>设值指令：</p><ul><li><code>set {key} {value} ex|px {time}</code>：ex秒，px毫秒，设置键并指定过期时间</li><li><code>setnx {key} {value}</code>：不存在key时，返回1设置成功，存在的话失败0，可做分布式锁。</li><li><code>set {key} {value}</code> ：存在key时，返回1成功</li><li><code>mset {key1} {value1} {key2} {value2}</code> ：批量设值</li></ul></li><li><p>获值指令：</p><ul><li><code>get {key}</code>：存在则返回 value, 不存在返回 nil</li><li><code>mget {key1} {key2} {key3}</code>：</li></ul></li><li><p>计数指令：</p><ul><li><code>incr {key}</code>：key必须为整数，非整数返回错误，无 key键从将创建key加1，有key将加1</li><li><code>decr {key}</code>：整数key减1</li><li><code>incrby {key} {num}</code>：整数key+num</li><li><code>decrby {key} {num}</code>：整数key-num</li><li><code>incrbyfloat {key} {score}</code>：浮点型 key+score</li></ul></li><li><p>追加指令：append {key} {value}：</p></li><li><p>获取长度：strlen {key}</p></li><li><p>截取字符串：getrange {key} {start} {end}</p></li><li><p>获取编码格式：object encodeing {key} \embstr小于等于39字符，raw大于39字符，int数字类型且字长小于8</p></li></ul><h3 id="hash指令"><a href="#hash指令" class="headerlink" title="hash指令"></a>hash指令</h3><ul><li>设值指令：<code>hset {key} {hkey} {hvalue}</code></li><li>取值指令：<code>hget {key} {hkey}</code></li><li>删值指令：<code>hdel {key} {hkey}</code></li><li>计算个数：<code>hdel {key} {hkey}</code></li><li>判断hkey是否存在：<code>hexists {key} {hkey}</code></li><li>获取所有hkey：<code>hkeys {key}</code></li><li>获取所有hvalue：<code>hvals {key}</code></li><li>获取所有hkey跟hvalue：<code>hgetall {key}</code></li><li>整型hvalue增加num：<code>hincrby {key} {hkey} {num}</code></li><li>浮点型hvalue增加num：<code>hincrbyfloat {key} {hkey} {num}</code></li><li>内部编码：<code>object encoding {key}</code> //当hkey个数少且没有大的hvalue时，内部编码为ziplist，当hvalue大于64字节，内部编码由ziplist变成hashtable。</li></ul><h3 id="列表指令"><a href="#列表指令" class="headerlink" title="列表指令"></a>列表指令</h3><ul><li>添加命令<ul><li><code>rpush {key} {value1} {value2} {value3}</code>：从右向左插入value，返回值为插入个数</li><li><code>lpush {key} {value1} {value2} {value3}</code>：从左向右插入value</li><li><code>linsert {key} before {value1} {value2}</code> ：在value1之前插入value2</li></ul></li><li>查找指令<ul><li><code>lrange {key} {start} {end}</code> ：从左到右获取列中的元素</li><li><code>llen {key}</code>：返回当前列表长度</li><li><code>lpop {key}</code>：删除最左边的元素</li><li><code>rpop {key}</code>：删除最右边的元素</li><li><code>lrem key {count} {value}</code>：删除指定元素</li></ul></li><li>内部编码：在3.2版本以后，redis提供了quicklist内部编码，它结合了ziplist和linkedlist两者的优势，之前的ziplist是存在BUG的，使用quicklist内部编码效率更高。</li></ul><h3 id="集合指令"><a href="#集合指令" class="headerlink" title="集合指令"></a>集合指令</h3><ul><li><p><code>exists {key}</code>：检查键值是否存在</p></li><li><p><code>sadd {key} {value1} {value2} {value3}</code>：插入元素，返回值为插入个数，若加入相同的元素，则不会加入插入个数。</p></li><li><p><code>smembers {key}</code>：获取key的所有元素，返回结果无序</p></li><li><p><code>srem {key} {value}</code>：返回 1，删除value</p></li><li><p><code>scard {key}</code>：计算元素个数</p></li><li><p><code>sismember {key} {value}</code>：判断元素是否在集合存在，存在返回 1，不存在 0</p></li><li><p><code>srandmember {key} {num}</code>：随机返回num个元素</p></li><li><p><code>spop {key} {num}</code>：随机返回num个元素并将元素从集合中删除</p></li><li><p><code>sinter {key1} {key2} {key3}</code>：求集合交集</p></li><li><p><code>sunion {key1} {key2} {key3}</code>：求集合并集</p></li><li><p><code>sdiff {key1} {key2}</code>：求key1和key2差集</p></li><li><p><code>sinterstore {key3} {key1} {key2}</code>：将key1、key2的交集保存到key3</p></li><li><p><code>sunionstore {key3} {key1} {key2}</code>：将key1、key2的并合集保存key3</p></li><li><p><code>sdiffstore {key3} {key1} {key2}</code>：将key1、key2的差集保存key3</p></li></ul><p>内部编码：当元素个数少（小于512个）且都为整数，使用intset减少内存的使用，当超过512个或不为整数（比如ab）时，编码为hashtable。</p><h3 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h3><ul><li><code>zadd {key} {score1} {skey1} {score2} {skey2}</code>：添加到集合</li><li><code>zadd {key} nx {score} {skey}</code>：键skey须不存在，主要用于添加</li><li><code>zadd {key} xx incr {score} {skey}</code>：键skey必须存在，主要用于修改</li><li><code>zadd {key} xx ch incr {score} {skey}</code>：返回score的和，此时的score可以为负</li><li><code>zrange {key} 0 -1 withscores</code>：正序查看所有成员</li><li><code>zrevrange {key} 0 -1 withscores</code>：倒序查看所有成员</li><li><code>zcard {key}</code>：计算成员个数</li><li><code>zrangebyscore {key} {score1} {score2} withscores</code>：正序返回指定分数范围的成员</li><li><code>zrevrangebyscore {key} {score2} {score1} withscores</code>：倒序返回指定分数范围的成员</li><li><code>zrangebyscore {key} {score1} +inf withscores</code>：正序返回score1到无限大</li><li><code>zrevrangebyscore {key} {score1} -inf withscores</code>：倒序返回无限小到score1</li><li><code>zcount {key} {score1} {score2}</code>：返回指定分数范围的成员个数</li><li><code>zremrangebyrank {key} {index1} {index2}</code>：分数升序排列，删除第index1跟index2的数据</li><li><code>zremrangebyscore {key} {score1} {score2}</code>：删除分数在score1到score2范围的成员</li><li><code>zremrangebyscore {key} {score1} +inf</code>：删除分数大于score1的成员</li><li><code>zinterstore destination numkeys key ... [WEIGHTS weight] [AGGREGATE SUM|MIN|MAX]</code>：有序集合交集，destination：交集产生新的元素存储键名称，numkeys：要做交集计算的键个数，key：元素键值，weights：每个被选中的键对应值乘weight,默认为1。</li><li><code>zunionstore destination numkeys key ... [WEIGHTS weight] [AGGREGATE SUM|MIN|MAX]</code>：有序集合并集，destination:交集产生新的元素存储键名称，numkeys:要做交集计算的键个数，key:元素键值，weights：每个被选中的键对应值乘weight,默认为1。</li></ul>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>actuator源码解读</title>
    <link href="/blog/2020/04/28/springcloud-actuator%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <url>/blog/2020/04/28/springcloud-actuator%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="actuator源码解读"><a href="#actuator源码解读" class="headerlink" title="actuator源码解读"></a>actuator源码解读</h2><p>actuator的spring.factories中会注册很多带有@Endpoin注解的类。</p><p>通过spring.factories引入的ManagementContextAutoConfiguration中有一个EnableSameManagementContextConfiguration类。</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>(proxyBeanMethods = <span class="hljs-keyword">false</span>)<span class="hljs-meta">@EnableManagementContext</span>(ManagementContextType.SAME)<span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EnableSameManagementContextConfiguration</span> </span>&#123;&#125;</code></pre><p>这个类的@EnableManagementContext会引入ManagementContextConfigurationImportSelector类</p><pre><code class="hljs java"><span class="hljs-meta">@Target</span>(ElementType.TYPE)<span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-meta">@Documented</span><span class="hljs-meta">@Import</span>(ManagementContextConfigurationImportSelector<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">@<span class="hljs-title">interface</span> <span class="hljs-title">EnableManagementContext</span> </span>&#123;</code></pre><p>ManagementContextConfigurationImportSelector类会引入spring.factories中ManagementContextConfiguration类型的所有类</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> List&lt;String&gt; <span class="hljs-title">loadFactoryNames</span><span class="hljs-params">()</span> </span>&#123;   <span class="hljs-keyword">return</span> SpringFactoriesLoader.loadFactoryNames(ManagementContextConfiguration<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">this</span>.<span class="hljs-title">classLoader</span>)</span>;&#125;</code></pre><p>这里我们只关注WebMvcEndpointManagementContextConfiguration</p><p>WebMvcEndpointManagementContextConfiguration类中会调用getEndpoints()方法获取到带有@Endpoint注解的对象，然后创建WebMvcEndpointHandlerMapping映射关系对象。</p><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-meta">@ConditionalOnMissingBean</span><span class="hljs-function"><span class="hljs-keyword">public</span> WebMvcEndpointHandlerMapping <span class="hljs-title">webEndpointServletHandlerMapping</span><span class="hljs-params">(WebEndpointsSupplier webEndpointsSupplier,</span></span><span class="hljs-function"><span class="hljs-params">      ServletEndpointsSupplier servletEndpointsSupplier, ControllerEndpointsSupplier controllerEndpointsSupplier,</span></span><span class="hljs-function"><span class="hljs-params">      EndpointMediaTypes endpointMediaTypes, CorsEndpointProperties corsProperties,</span></span><span class="hljs-function"><span class="hljs-params">      WebEndpointProperties webEndpointProperties, Environment environment)</span> </span>&#123;   List&lt;ExposableEndpoint&lt;?&gt;&gt; allEndpoints = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();   Collection&lt;ExposableWebEndpoint&gt; webEndpoints = webEndpointsSupplier.getEndpoints();   allEndpoints.addAll(webEndpoints);   allEndpoints.addAll(servletEndpointsSupplier.getEndpoints());   allEndpoints.addAll(controllerEndpointsSupplier.getEndpoints());   String basePath = webEndpointProperties.getBasePath();   EndpointMapping endpointMapping = <span class="hljs-keyword">new</span> EndpointMapping(basePath);   <span class="hljs-keyword">boolean</span> shouldRegisterLinksMapping = StringUtils.hasText(basePath)         || ManagementPortType.get(environment).equals(ManagementPortType.DIFFERENT);   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> WebMvcEndpointHandlerMapping(endpointMapping, webEndpoints, endpointMediaTypes,         corsProperties.toCorsConfiguration(), <span class="hljs-keyword">new</span> EndpointLinksResolver(allEndpoints, basePath),         shouldRegisterLinksMapping);&#125;</code></pre><p>getEndpoints()最终回调用到EndpointDiscoverer的createEndpointBeans()方法，该方法会拿到有@Endpoint注解的所有的类，然后返回对应的Endpoint。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Collection&lt;EndpointBean&gt; <span class="hljs-title">createEndpointBeans</span><span class="hljs-params">()</span> </span>&#123;   Map&lt;EndpointId, EndpointBean&gt; byId = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;();   String[] beanNames = BeanFactoryUtils.beanNamesForAnnotationIncludingAncestors(<span class="hljs-keyword">this</span>.applicationContext,         Endpoint<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;   <span class="hljs-keyword">for</span> (String beanName : beanNames) &#123;      <span class="hljs-keyword">if</span> (!ScopedProxyUtils.isScopedTarget(beanName)) &#123;         EndpointBean endpointBean = createEndpointBean(beanName);         EndpointBean previous = byId.putIfAbsent(endpointBean.getId(), endpointBean);         Assert.state(previous == <span class="hljs-keyword">null</span>, () -&gt; <span class="hljs-string">"Found two endpoints with the id '"</span> + endpointBean.getId() + <span class="hljs-string">"': '"</span>               + endpointBean.getBeanName() + <span class="hljs-string">"' and '"</span> + previous.getBeanName() + <span class="hljs-string">"'"</span>);      &#125;   &#125;   <span class="hljs-keyword">return</span> byId.values();&#125;</code></pre><p>WebMvcEndpointHandlerMapping的父类AbstractHandlerMethodMapping实现了InitializingBean接口，spring会在实例化完成后调用其afterPropertiesSet()方法</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterPropertiesSet</span><span class="hljs-params">()</span> </span>&#123;   initHandlerMethods();&#125;</code></pre><p>afterPropertiesSet()方法回到用到子类AbstractWebMvcEndpointHandlerMapping中的initHandlerMethods()方法。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initHandlerMethods</span><span class="hljs-params">()</span> </span>&#123;   <span class="hljs-keyword">for</span> (ExposableWebEndpoint endpoint : <span class="hljs-keyword">this</span>.endpoints) &#123;      <span class="hljs-keyword">for</span> (WebOperation operation : endpoint.getOperations()) &#123;         registerMappingForOperation(endpoint, operation);      &#125;   &#125;   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.shouldRegisterLinksMapping) &#123;      registerLinksMapping();   &#125;&#125;</code></pre><p>initHandlerMethods()方法会调用到registerMappingForOperation()方法，将所有的endpoint绑定到OperationHandler类</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerMappingForOperation</span><span class="hljs-params">(ExposableWebEndpoint endpoint, WebOperation operation)</span> </span>&#123;   WebOperationRequestPredicate predicate = operation.getRequestPredicate();   String path = predicate.getPath();   String matchAllRemainingPathSegmentsVariable = predicate.getMatchAllRemainingPathSegmentsVariable();   <span class="hljs-keyword">if</span> (matchAllRemainingPathSegmentsVariable != <span class="hljs-keyword">null</span>) &#123;      path = path.replace(<span class="hljs-string">"&#123;*"</span> + matchAllRemainingPathSegmentsVariable + <span class="hljs-string">"&#125;"</span>, <span class="hljs-string">"**"</span>);   &#125;   ServletWebOperation servletWebOperation = wrapServletWebOperation(endpoint, operation,         <span class="hljs-keyword">new</span> ServletWebOperationAdapter(operation));   registerMapping(createRequestMappingInfo(predicate, path), <span class="hljs-keyword">new</span> OperationHandler(servletWebOperation),         <span class="hljs-keyword">this</span>.handleMethod);&#125;</code></pre><p>OperationHandler类，所有的请求都会进入其handle()方法，handle()方法最终会调用到通过spring.factories中的创建的带有@Endpoint注解的实例。</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OperationHandler</span> </span>&#123;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ServletWebOperation operation;   OperationHandler(ServletWebOperation operation) &#123;      <span class="hljs-keyword">this</span>.operation = operation;   &#125;   <span class="hljs-meta">@ResponseBody</span>   <span class="hljs-function">Object <span class="hljs-title">handle</span><span class="hljs-params">(HttpServletRequest request, @RequestBody(required = <span class="hljs-keyword">false</span>)</span> Map&lt;String, String&gt; body) </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.operation.handle(request, body);   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.operation.toString();   &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>SpringCloud源码解读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>actuator</tag>
      
      <tag>源码解读</tag>
      
      <tag>springcloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>config源码解读</title>
    <link href="/blog/2020/04/28/springcloud-config%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <url>/blog/2020/04/28/springcloud-config%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><p>ConfigServerAutoConfiguration类会通过SPI加载</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>(proxyBeanMethods = <span class="hljs-keyword">false</span>)<span class="hljs-meta">@ConditionalOnBean</span>(ConfigServerConfiguration.Marker<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">@<span class="hljs-title">EnableConfigurationProperties</span>(<span class="hljs-title">ConfigServerProperties</span>.<span class="hljs-title">class</span>)</span><span class="hljs-class">@<span class="hljs-title">Import</span>(</span>&#123; EnvironmentRepositoryConfiguration<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">CompositeConfiguration</span>.<span class="hljs-title">class</span>,</span><span class="hljs-class">      <span class="hljs-title">ResourceRepositoryConfiguration</span>.<span class="hljs-title">class</span>, <span class="hljs-title">ConfigServerEncryptionConfiguration</span>.<span class="hljs-title">class</span>,</span><span class="hljs-class">      <span class="hljs-title">ConfigServerMvcConfiguration</span>.<span class="hljs-title">class</span>, <span class="hljs-title">ResourceEncryptorConfiguration</span>.<span class="hljs-title">class</span> &#125;)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">ConfigServerAutoConfiguration</span> </span>&#123;&#125;</code></pre><h3 id="配置信息的获取"><a href="#配置信息的获取" class="headerlink" title="配置信息的获取"></a>配置信息的获取</h3><p>ConfigServerMvcConfiguration会被引入，并创建一个EnvironmentController</p><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-meta">@RefreshScope</span><span class="hljs-function"><span class="hljs-keyword">public</span> EnvironmentController <span class="hljs-title">environmentController</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">      EnvironmentRepository envRepository, ConfigServerProperties server)</span> </span>&#123;   EnvironmentController controller = <span class="hljs-keyword">new</span> EnvironmentController(         encrypted(envRepository, server), <span class="hljs-keyword">this</span>.objectMapper);   controller.setStripDocumentFromYaml(server.isStripDocumentFromYaml());   controller.setAcceptEmpty(server.isAcceptEmpty());   <span class="hljs-keyword">return</span> controller;&#125;</code></pre><p>EnvironmentController主要用于接收获取配置信息请求，如接收<code>http://localhost:8085/api-gatewary.proeprties</code>请求的properties()方法，该方法会调用labelledProperties()方法获取配置信息。</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/&#123;name&#125;-&#123;profiles&#125;.properties"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity&lt;String&gt; <span class="hljs-title">properties</span><span class="hljs-params">(@PathVariable String name,</span></span><span class="hljs-function"><span class="hljs-params">      @PathVariable String profiles,</span></span><span class="hljs-function"><span class="hljs-params">      @RequestParam(defaultValue = <span class="hljs-string">"true"</span>)</span> <span class="hljs-keyword">boolean</span> resolvePlaceholders)</span><span class="hljs-function">      <span class="hljs-keyword">throws</span> IOException </span>&#123;   <span class="hljs-keyword">return</span> labelledProperties(name, profiles, <span class="hljs-keyword">null</span>, resolvePlaceholders);&#125;</code></pre><p>labelledProperties()方法最终会调用到getEnvironment()方法。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Environment <span class="hljs-title">getEnvironment</span><span class="hljs-params">(String name, String profiles, String label,</span></span><span class="hljs-function"><span class="hljs-params">      <span class="hljs-keyword">boolean</span> includeOrigin)</span> </span>&#123;   name = Environment.normalize(name);   label = Environment.normalize(label);   Environment environment = <span class="hljs-keyword">this</span>.repository.findOne(name, profiles, label,         includeOrigin);   <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.acceptEmpty         &amp;&amp; (environment == <span class="hljs-keyword">null</span> || environment.getPropertySources().isEmpty())) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> EnvironmentNotFoundException(<span class="hljs-string">"Profile Not found"</span>);   &#125;   <span class="hljs-keyword">return</span> environment;&#125;</code></pre><p>AbstractScmEnvironmentRepository的findOne()方法会由getEnvironment()方法调用，在这里就从github上clone，和更新配置信息并且保存到了本地。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> Environment <span class="hljs-title">findOne</span><span class="hljs-params">(String application, String profile,</span></span><span class="hljs-function"><span class="hljs-params">      String label, <span class="hljs-keyword">boolean</span> includeOrigin)</span> </span>&#123;   NativeEnvironmentRepository delegate = <span class="hljs-keyword">new</span> NativeEnvironmentRepository(         getEnvironment(), <span class="hljs-keyword">new</span> NativeEnvironmentProperties());   Locations locations = getLocations(application, profile, label);   delegate.setSearchLocations(locations.getLocations());   Environment result = delegate.findOne(application, profile, <span class="hljs-string">""</span>, includeOrigin);   result.setVersion(locations.getVersion());   result.setLabel(label);   <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.cleaner.clean(result, getWorkingDirectory().toURI().toString(),         getUri());&#125;</code></pre><p>JGitEnvironmentRepository的getLocations()方法，该方法是getEnvironment()方法的核心方法，如果本地已经存在对应的配置文件，就会从本地获取，如果本地没有就会从github上获取。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> Locations <span class="hljs-title">getLocations</span><span class="hljs-params">(String application, String profile,</span></span><span class="hljs-function"><span class="hljs-params">      String label)</span> </span>&#123;   <span class="hljs-keyword">if</span> (label == <span class="hljs-keyword">null</span>) &#123;      label = <span class="hljs-keyword">this</span>.defaultLabel;   &#125;   String version = refresh(label);   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Locations(application, profile, label, version,         getSearchLocations(getWorkingDirectory(), application, profile, label));&#125;</code></pre><p>refresh()会获取到git仓库的文件并进行检查。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">refresh</span><span class="hljs-params">(String label)</span> </span>&#123;   Git git = <span class="hljs-keyword">null</span>;   <span class="hljs-keyword">try</span> &#123;      git = createGitClient();      <span class="hljs-keyword">if</span> (shouldPull(git)) &#123;         FetchResult fetchStatus = fetch(git, label);         <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.deleteUntrackedBranches &amp;&amp; fetchStatus != <span class="hljs-keyword">null</span>) &#123;            deleteUntrackedLocalBranches(fetchStatus.getTrackingRefUpdates(),                  git);         &#125;         <span class="hljs-comment">// checkout after fetch so we can get any new branches, tags, ect.</span>         checkout(git, label);         tryMerge(git, label);      &#125;      <span class="hljs-keyword">else</span> &#123;         <span class="hljs-comment">// nothing to update so just checkout and merge.</span>         <span class="hljs-comment">// Merge because remote branch could have been updated before</span>         checkout(git, label);         tryMerge(git, label);      &#125;      <span class="hljs-comment">// always return what is currently HEAD as the version</span>      <span class="hljs-keyword">return</span> git.getRepository().findRef(<span class="hljs-string">"HEAD"</span>).getObjectId().getName();   &#125;   <span class="hljs-keyword">catch</span> (RefNotFoundException e) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchLabelException(<span class="hljs-string">"No such label: "</span> + label, e);   &#125;   <span class="hljs-keyword">catch</span> (NoRemoteRepositoryException e) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchRepositoryException(<span class="hljs-string">"No such repository: "</span> + getUri(), e);   &#125;   <span class="hljs-keyword">catch</span> (GitAPIException e) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchRepositoryException(            <span class="hljs-string">"Cannot clone or checkout repository: "</span> + getUri(), e);   &#125;   <span class="hljs-keyword">catch</span> (Exception e) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Cannot load environment"</span>, e);   &#125;   <span class="hljs-keyword">finally</span> &#123;      <span class="hljs-keyword">try</span> &#123;         <span class="hljs-keyword">if</span> (git != <span class="hljs-keyword">null</span>) &#123;            git.close();         &#125;      &#125;      <span class="hljs-keyword">catch</span> (Exception e) &#123;         <span class="hljs-keyword">this</span>.logger.warn(<span class="hljs-string">"Could not close git repository"</span>, e);      &#125;   &#125;&#125;</code></pre><p>createGitClient()，该方法会获取到本地的仓库。如果不存在就会调用copyRepository()方法创建。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Git <span class="hljs-title">createGitClient</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, GitAPIException </span>&#123;   File lock = <span class="hljs-keyword">new</span> File(getWorkingDirectory(), <span class="hljs-string">".git/index.lock"</span>);   <span class="hljs-keyword">if</span> (lock.exists()) &#123;      <span class="hljs-comment">// The only way this can happen is if another JVM (e.g. one that</span>      <span class="hljs-comment">// crashed earlier) created the lock. We can attempt to recover by</span>      <span class="hljs-comment">// wiping the slate clean.</span>      <span class="hljs-keyword">this</span>.logger.info(<span class="hljs-string">"Deleting stale JGit lock file at "</span> + lock);      lock.delete();   &#125;   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span> File(getWorkingDirectory(), <span class="hljs-string">".git"</span>).exists()) &#123;      <span class="hljs-keyword">return</span> openGitRepository();   &#125;   <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">return</span> copyRepository();   &#125;&#125;</code></pre><p>copyRepository()会调用cloneToBasedir()方法。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> Git <span class="hljs-title">copyRepository</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, GitAPIException </span>&#123;   deleteBaseDirIfExists();   getBasedir().mkdirs();   Assert.state(getBasedir().exists(), <span class="hljs-string">"Could not create basedir: "</span> + getBasedir());   <span class="hljs-keyword">if</span> (getUri().startsWith(FILE_URI_PREFIX)) &#123;      <span class="hljs-keyword">return</span> copyFromLocalRepository();   &#125;   <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">return</span> cloneToBasedir();   &#125;&#125;</code></pre><p>cloneToBasedir()，向git发送clone指令。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Git <span class="hljs-title">cloneToBasedir</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> GitAPIException </span>&#123;   CloneCommand clone = <span class="hljs-keyword">this</span>.gitFactory.getCloneCommandByCloneRepository()         .setURI(getUri()).setDirectory(getBasedir());   configureCommand(clone);   <span class="hljs-keyword">try</span> &#123;      <span class="hljs-keyword">return</span> clone.call();   &#125;   <span class="hljs-keyword">catch</span> (GitAPIException e) &#123;      <span class="hljs-keyword">this</span>.logger.warn(<span class="hljs-string">"Error occured cloning to base directory."</span>, e);      deleteBaseDirIfExists();      <span class="hljs-keyword">throw</span> e;   &#125;&#125;</code></pre><h3 id="加密解密"><a href="#加密解密" class="headerlink" title="加密解密"></a>加密解密</h3><p>ConfigServerAutoConfiguration类中还会引入ConfigServerEncryptionConfiguration类，该类会注册服务端加密的controller</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>(proxyBeanMethods = <span class="hljs-keyword">false</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConfigServerEncryptionConfiguration</span> </span>&#123;   <span class="hljs-meta">@Autowired</span>(required = <span class="hljs-keyword">false</span>)   <span class="hljs-keyword">private</span> TextEncryptorLocator encryptor;   <span class="hljs-meta">@Autowired</span>   <span class="hljs-keyword">private</span> ConfigServerProperties properties;   <span class="hljs-meta">@Bean</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> EncryptionController <span class="hljs-title">encryptionController</span><span class="hljs-params">()</span> </span>&#123;      EncryptionController controller = <span class="hljs-keyword">new</span> EncryptionController(<span class="hljs-keyword">this</span>.encryptor);      controller.setDefaultApplicationName(<span class="hljs-keyword">this</span>.properties.getDefaultApplicationName());      controller.setDefaultProfile(<span class="hljs-keyword">this</span>.properties.getDefaultProfile());      <span class="hljs-keyword">return</span> controller;   &#125;&#125;</code></pre><p>EncryptionController类</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span>(value = <span class="hljs-string">"encrypt"</span>, method = RequestMethod.POST)<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">encrypt</span><span class="hljs-params">(@RequestBody String data,</span></span><span class="hljs-function"><span class="hljs-params">      @RequestHeader(<span class="hljs-string">"Content-Type"</span>)</span> MediaType type) </span>&#123;   <span class="hljs-keyword">return</span> encrypt(defaultApplicationName, defaultProfile, data, type);&#125;</code></pre><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span>(value = <span class="hljs-string">"decrypt"</span>, method = RequestMethod.POST)<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">decrypt</span><span class="hljs-params">(@RequestBody String data,</span></span><span class="hljs-function"><span class="hljs-params">      @RequestHeader(<span class="hljs-string">"Content-Type"</span>)</span> MediaType type) </span>&#123;   <span class="hljs-keyword">return</span> decrypt(defaultApplicationName, defaultProfile, data, type);&#125;</code></pre><h2 id="config客户端"><a href="#config客户端" class="headerlink" title="config客户端"></a>config客户端</h2><h3 id="配置信息的获取-1"><a href="#配置信息的获取-1" class="headerlink" title="配置信息的获取"></a>配置信息的获取</h3><p>spi中会引入ConfigServiceBootstrapConfiguration类，该类中会创建ConfigServicePropertySourceLocator对象。</p><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-meta">@ConditionalOnMissingBean</span>(ConfigServicePropertySourceLocator<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">@<span class="hljs-title">ConditionalOnProperty</span>(<span class="hljs-title">value</span> </span>= <span class="hljs-string">"spring.cloud.config.enabled"</span>, matchIfMissing = <span class="hljs-keyword">true</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> ConfigServicePropertySourceLocator <span class="hljs-title">configServicePropertySource</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">      ConfigClientProperties properties)</span> </span>&#123;   ConfigServicePropertySourceLocator locator = <span class="hljs-keyword">new</span> ConfigServicePropertySourceLocator(         properties);   <span class="hljs-keyword">return</span> locator;&#125;</code></pre><p>locate()方法是ConfigServicePropertySourceLocator类中比较重要的一个方法。该方法会通过getRemoteEnvironment()方法获取到Environment对象。</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-meta">@Retryable</span>(interceptor = <span class="hljs-string">"configServerRetryInterceptor"</span>)<span class="hljs-keyword">public</span> org.springframework.core.env.PropertySource&lt;?&gt; locate(      org.springframework.core.env.Environment environment) &#123;   ConfigClientProperties properties = <span class="hljs-keyword">this</span>.defaultProperties.override(environment);   CompositePropertySource composite = <span class="hljs-keyword">new</span> OriginTrackedCompositePropertySource(         <span class="hljs-string">"configService"</span>);   RestTemplate restTemplate = <span class="hljs-keyword">this</span>.restTemplate == <span class="hljs-keyword">null</span>         ? getSecureRestTemplate(properties) : <span class="hljs-keyword">this</span>.restTemplate;   Exception error = <span class="hljs-keyword">null</span>;   String errorBody = <span class="hljs-keyword">null</span>;   <span class="hljs-keyword">try</span> &#123;      String[] labels = <span class="hljs-keyword">new</span> String[] &#123; <span class="hljs-string">""</span> &#125;;      <span class="hljs-keyword">if</span> (StringUtils.hasText(properties.getLabel())) &#123;         labels = StringUtils               .commaDelimitedListToStringArray(properties.getLabel());      &#125;      String state = ConfigClientStateHolder.getState();      <span class="hljs-comment">// Try all the labels until one works</span>      <span class="hljs-keyword">for</span> (String label : labels) &#123;         Environment result = getRemoteEnvironment(restTemplate, properties,               label.trim(), state);         <span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) &#123;            log(result);            <span class="hljs-comment">// result.getPropertySources() can be null if using xml</span>            <span class="hljs-keyword">if</span> (result.getPropertySources() != <span class="hljs-keyword">null</span>) &#123;               <span class="hljs-keyword">for</span> (PropertySource source : result.getPropertySources()) &#123;                  <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)                  Map&lt;String, Object&gt; map = translateOrigins(source.getName(),                        (Map&lt;String, Object&gt;) source.getSource());                  composite.addPropertySource(                        <span class="hljs-keyword">new</span> OriginTrackedMapPropertySource(source.getName(),                              map));               &#125;            &#125;            <span class="hljs-keyword">if</span> (StringUtils.hasText(result.getState())                  || StringUtils.hasText(result.getVersion())) &#123;               HashMap&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();               putValue(map, <span class="hljs-string">"config.client.state"</span>, result.getState());               putValue(map, <span class="hljs-string">"config.client.version"</span>, result.getVersion());               composite.addFirstPropertySource(                     <span class="hljs-keyword">new</span> MapPropertySource(<span class="hljs-string">"configClient"</span>, map));            &#125;            <span class="hljs-keyword">return</span> composite;         &#125;      &#125;      errorBody = String.format(<span class="hljs-string">"None of labels %s found"</span>, Arrays.toString(labels));   &#125;   <span class="hljs-keyword">catch</span> (HttpServerErrorException e) &#123;      error = e;      <span class="hljs-keyword">if</span> (MediaType.APPLICATION_JSON            .includes(e.getResponseHeaders().getContentType())) &#123;         errorBody = e.getResponseBodyAsString();      &#125;   &#125;   <span class="hljs-keyword">catch</span> (Exception e) &#123;      error = e;   &#125;   <span class="hljs-keyword">if</span> (properties.isFailFast()) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(            <span class="hljs-string">"Could not locate PropertySource and the fail fast property is set, failing"</span>                  + (errorBody == <span class="hljs-keyword">null</span> ? <span class="hljs-string">""</span> : <span class="hljs-string">": "</span> + errorBody),            error);   &#125;   logger.warn(<span class="hljs-string">"Could not locate PropertySource: "</span>         + (error != <span class="hljs-keyword">null</span> ? error.getMessage() : errorBody));   <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre><p>getRemoteEnvironment()会在locate()方法中调用，会请求配置中心获取到Environment对象。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Environment <span class="hljs-title">getRemoteEnvironment</span><span class="hljs-params">(RestTemplate restTemplate,</span></span><span class="hljs-function"><span class="hljs-params">      ConfigClientProperties properties, String label, String state)</span> </span>&#123;   String path = <span class="hljs-string">"/&#123;name&#125;/&#123;profile&#125;"</span>;   String name = properties.getName();   String profile = properties.getProfile();   String token = properties.getToken();   <span class="hljs-keyword">int</span> noOfUrls = properties.getUri().length;   <span class="hljs-keyword">if</span> (noOfUrls &gt; <span class="hljs-number">1</span>) &#123;      logger.info(<span class="hljs-string">"Multiple Config Server Urls found listed."</span>);   &#125;   Object[] args = <span class="hljs-keyword">new</span> String[] &#123; name, profile &#125;;   <span class="hljs-keyword">if</span> (StringUtils.hasText(label)) &#123;      <span class="hljs-comment">// workaround for Spring MVC matching / in paths</span>      label = Environment.denormalize(label);      args = <span class="hljs-keyword">new</span> String[] &#123; name, profile, label &#125;;      path = path + <span class="hljs-string">"/&#123;label&#125;"</span>;   &#125;   ResponseEntity&lt;Environment&gt; response = <span class="hljs-keyword">null</span>;   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; noOfUrls; i++) &#123;      Credentials credentials = properties.getCredentials(i);      String uri = credentials.getUri();      String username = credentials.getUsername();      String password = credentials.getPassword();      logger.info(<span class="hljs-string">"Fetching config from server at : "</span> + uri);      <span class="hljs-keyword">try</span> &#123;         HttpHeaders headers = <span class="hljs-keyword">new</span> HttpHeaders();         headers.setAccept(               Collections.singletonList(MediaType.parseMediaType(V2_JSON)));         addAuthorizationToken(properties, headers, username, password);         <span class="hljs-keyword">if</span> (StringUtils.hasText(token)) &#123;            headers.add(TOKEN_HEADER, token);         &#125;         <span class="hljs-keyword">if</span> (StringUtils.hasText(state) &amp;&amp; properties.isSendState()) &#123;            headers.add(STATE_HEADER, state);         &#125;         <span class="hljs-keyword">final</span> HttpEntity&lt;Void&gt; entity = <span class="hljs-keyword">new</span> HttpEntity&lt;&gt;((Void) <span class="hljs-keyword">null</span>, headers);         response = restTemplate.exchange(uri + path, HttpMethod.GET, entity,               Environment<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;      &#125;      <span class="hljs-keyword">catch</span> (HttpClientErrorException e) &#123;         <span class="hljs-keyword">if</span> (e.getStatusCode() != HttpStatus.NOT_FOUND) &#123;            <span class="hljs-keyword">throw</span> e;         &#125;      &#125;      <span class="hljs-keyword">catch</span> (ResourceAccessException e) &#123;         logger.info(<span class="hljs-string">"Connect Timeout Exception on Url - "</span> + uri               + <span class="hljs-string">". Will be trying the next url if available"</span>);         <span class="hljs-keyword">if</span> (i == noOfUrls - <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">throw</span> e;         &#125;         <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">continue</span>;         &#125;      &#125;      <span class="hljs-keyword">if</span> (response == <span class="hljs-keyword">null</span> || response.getStatusCode() != HttpStatus.OK) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;      &#125;      Environment result = response.getBody();      <span class="hljs-keyword">return</span> result;   &#125;   <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre><h3 id="配置信息的更新"><a href="#配置信息的更新" class="headerlink" title="配置信息的更新"></a>配置信息的更新</h3><p>更新接口会调用到RefreshEndpoint的refresh()方法中。</p><pre><code class="hljs java"><span class="hljs-meta">@Endpoint</span>(id = <span class="hljs-string">"refresh"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RefreshEndpoint</span> </span>&#123;   <span class="hljs-keyword">private</span> ContextRefresher contextRefresher;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RefreshEndpoint</span><span class="hljs-params">(ContextRefresher contextRefresher)</span> </span>&#123;      <span class="hljs-keyword">this</span>.contextRefresher = contextRefresher;   &#125;   <span class="hljs-meta">@WriteOperation</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> Collection&lt;String&gt; <span class="hljs-title">refresh</span><span class="hljs-params">()</span> </span>&#123;      Set&lt;String&gt; keys = <span class="hljs-keyword">this</span>.contextRefresher.refresh();      <span class="hljs-keyword">return</span> keys;   &#125;</code></pre><p>resresh()会调用到ContextRefresher中的refresh()方法，该方法首先调用refreshEnvironment()方法刷新Environment对象，然后调用refreshAll()方法刷新scope对象。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> Set&lt;String&gt; <span class="hljs-title">refresh</span><span class="hljs-params">()</span> </span>&#123;   Set&lt;String&gt; keys = refreshEnvironment();   <span class="hljs-keyword">this</span>.scope.refreshAll();   <span class="hljs-keyword">return</span> keys;&#125;</code></pre><p>refreshEnvironment()方法，该方法会重新从配置中心拉取属性，然后做新旧对比。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> Set&lt;String&gt; <span class="hljs-title">refreshEnvironment</span><span class="hljs-params">()</span> </span>&#123;   Map&lt;String, Object&gt; before = extract(         <span class="hljs-keyword">this</span>.context.getEnvironment().getPropertySources());   addConfigFilesToEnvironment();   Set&lt;String&gt; keys = changes(before,         extract(<span class="hljs-keyword">this</span>.context.getEnvironment().getPropertySources())).keySet();   <span class="hljs-keyword">this</span>.context.publishEvent(<span class="hljs-keyword">new</span> EnvironmentChangeEvent(<span class="hljs-keyword">this</span>.context, keys));   <span class="hljs-keyword">return</span> keys;&#125;</code></pre><p>refreshAll()方法会调用destroy()方法销毁实例，destory()的过程跟之前的自定义分布中心中的类似，就是从缓存中移除实例。然后调用publishEvent()方法重新发布对象。</p><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">refreshAll</span><span class="hljs-params">()</span> </span>&#123;   <span class="hljs-keyword">super</span>.destroy();   <span class="hljs-keyword">this</span>.context.publishEvent(<span class="hljs-keyword">new</span> RefreshScopeRefreshedEvent());&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>SpringCloud源码解读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>源码解读</tag>
      
      <tag>springcloud</tag>
      
      <tag>分布式配置中心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zuul源码解读</title>
    <link href="/blog/2020/04/28/springcloud-zuul%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <url>/blog/2020/04/28/springcloud-zuul%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="接口调用过程"><a href="#接口调用过程" class="headerlink" title="接口调用过程"></a>接口调用过程</h2><p>ZuulServerAutoConfiguration类也是由spi引入的，该类中会创建ZuulController、ZuulHandlerMapping以及ZuullServlet对象。</p><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> ZuulController <span class="hljs-title">zuulController</span><span class="hljs-params">()</span> </span>&#123;   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ZuulController();&#125;</code></pre><p>ZuulController实现了controller，所有的请求都会走handleRequest()方法。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">handleRequest</span><span class="hljs-params">(HttpServletRequest request,</span></span><span class="hljs-function"><span class="hljs-params">      HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;   <span class="hljs-keyword">try</span> &#123;      <span class="hljs-comment">// We don't care about the other features of the base class, just want to</span>      <span class="hljs-comment">// handle the request</span>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.handleRequestInternal(request, response);   &#125;   <span class="hljs-keyword">finally</span> &#123;      <span class="hljs-comment">// @see com.netflix.zuul.context.ContextLifecycleFilter.doFilter</span>      RequestContext.getCurrentContext().unset();   &#125;&#125;</code></pre><p>handleRequest()方法会调用handleRequestInternal()方法，handleRequestInternal()方法会调用到ZuullServlet中的service()方法。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> ModelAndView <span class="hljs-title">handleRequestInternal</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    Assert.state(<span class="hljs-keyword">this</span>.servletInstance != <span class="hljs-keyword">null</span>, <span class="hljs-string">"No Servlet instance"</span>);    <span class="hljs-keyword">this</span>.servletInstance.service(request, response);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre><p>ZuulServlet中的service()方法，service()方法中涉及到pre、route、post、error过滤器的调用。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">this</span>.init((HttpServletRequest)servletRequest, (HttpServletResponse)servletResponse);        RequestContext context = RequestContext.getCurrentContext();        context.setZuulEngineRan();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">this</span>.preRoute();        &#125; <span class="hljs-keyword">catch</span> (ZuulException var13) &#123;            <span class="hljs-keyword">this</span>.error(var13);            <span class="hljs-keyword">this</span>.postRoute();            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">this</span>.route();        &#125; <span class="hljs-keyword">catch</span> (ZuulException var12) &#123;            <span class="hljs-keyword">this</span>.error(var12);            <span class="hljs-keyword">this</span>.postRoute();            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">this</span>.postRoute();        &#125; <span class="hljs-keyword">catch</span> (ZuulException var11) &#123;            <span class="hljs-keyword">this</span>.error(var11);        &#125;    &#125; <span class="hljs-keyword">catch</span> (Throwable var14) &#123;        <span class="hljs-keyword">this</span>.error(<span class="hljs-keyword">new</span> ZuulException(var14, <span class="hljs-number">500</span>, <span class="hljs-string">"UNHANDLED_EXCEPTION_"</span> + var14.getClass().getName()));    &#125; <span class="hljs-keyword">finally</span> &#123;        RequestContext.getCurrentContext().unset();    &#125;&#125;</code></pre><p>preRoute()方法，该方法最终会调用到FilterProcessor的runFilters()方法。该方法会获取到所有对应的过滤器，然后排序，再通过processZuulFilter()方法调用。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">runFilters</span><span class="hljs-params">(String sType)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;    <span class="hljs-keyword">if</span> (RequestContext.getCurrentContext().debugRouting()) &#123;        Debug.addRoutingDebug(<span class="hljs-string">"Invoking &#123;"</span> + sType + <span class="hljs-string">"&#125; type filters"</span>);    &#125;    <span class="hljs-keyword">boolean</span> bResult = <span class="hljs-keyword">false</span>;    List&lt;ZuulFilter&gt; list = FilterLoader.getInstance().getFiltersByType(sType);    <span class="hljs-keyword">if</span> (list != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;            ZuulFilter zuulFilter = list.get(i);            Object result = processZuulFilter(zuulFilter);            <span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span> &amp;&amp; result <span class="hljs-keyword">instanceof</span> Boolean) &#123;                bResult |= ((Boolean) result);            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> bResult;&#125;</code></pre><p>processZuulFilter()方法</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">processZuulFilter</span><span class="hljs-params">(ZuulFilter filter)</span> <span class="hljs-keyword">throws</span> ZuulException </span>&#123;    RequestContext ctx = RequestContext.getCurrentContext();    <span class="hljs-keyword">boolean</span> bDebug = ctx.debugRouting();    <span class="hljs-keyword">final</span> String metricPrefix = <span class="hljs-string">"zuul.filter-"</span>;    <span class="hljs-keyword">long</span> execTime = <span class="hljs-number">0</span>;    String filterName = <span class="hljs-string">""</span>;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">long</span> ltime = System.currentTimeMillis();        filterName = filter.getClass().getSimpleName();                RequestContext copy = <span class="hljs-keyword">null</span>;        Object o = <span class="hljs-keyword">null</span>;        Throwable t = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">if</span> (bDebug) &#123;            Debug.addRoutingDebug(<span class="hljs-string">"Filter "</span> + filter.filterType() + <span class="hljs-string">" "</span> + filter.filterOrder() + <span class="hljs-string">" "</span> + filterName);            copy = ctx.copy();        &#125;                ZuulFilterResult result = filter.runFilter();        ExecutionStatus s = result.getStatus();        execTime = System.currentTimeMillis() - ltime;        <span class="hljs-keyword">switch</span> (s) &#123;            <span class="hljs-keyword">case</span> FAILED:                t = result.getException();                ctx.addFilterExecutionSummary(filterName, ExecutionStatus.FAILED.name(), execTime);                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> SUCCESS:                o = result.getResult();                ctx.addFilterExecutionSummary(filterName, ExecutionStatus.SUCCESS.name(), execTime);                <span class="hljs-keyword">if</span> (bDebug) &#123;                    Debug.addRoutingDebug(<span class="hljs-string">"Filter &#123;"</span> + filterName + <span class="hljs-string">" TYPE:"</span> + filter.filterType() + <span class="hljs-string">" ORDER:"</span> + filter.filterOrder() + <span class="hljs-string">"&#125; Execution time = "</span> + execTime + <span class="hljs-string">"ms"</span>);                    Debug.compareContextState(filterName, copy);                &#125;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">default</span>:                <span class="hljs-keyword">break</span>;        &#125;                <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> t;        usageNotifier.notify(filter, s);        <span class="hljs-keyword">return</span> o;    &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;        <span class="hljs-keyword">if</span> (bDebug) &#123;            Debug.addRoutingDebug(<span class="hljs-string">"Running Filter failed "</span> + filterName + <span class="hljs-string">" type:"</span> + filter.filterType() + <span class="hljs-string">" order:"</span> + filter.filterOrder() + <span class="hljs-string">" "</span> + e.getMessage());        &#125;        usageNotifier.notify(filter, ExecutionStatus.FAILED);        <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> ZuulException) &#123;            <span class="hljs-keyword">throw</span> (ZuulException) e;        &#125; <span class="hljs-keyword">else</span> &#123;            ZuulException ex = <span class="hljs-keyword">new</span> ZuulException(e, <span class="hljs-string">"Filter threw Exception"</span>, <span class="hljs-number">500</span>, filter.filterType() + <span class="hljs-string">":"</span> + filterName);            ctx.addFilterExecutionSummary(filterName, ExecutionStatus.FAILED.name(), execTime);            <span class="hljs-keyword">throw</span> ex;        &#125;    &#125;&#125;</code></pre><h2 id="过滤器解析"><a href="#过滤器解析" class="headerlink" title="过滤器解析"></a>过滤器解析</h2><p>spring.factories中还会引入ZuulProxyAutoConfiguration类，该类中会完成路由过滤器的注册</p><pre><code class="hljs java"><span class="hljs-comment">// route filters</span><span class="hljs-meta">@Bean</span><span class="hljs-meta">@ConditionalOnMissingBean</span>(RibbonRoutingFilter<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">RibbonRoutingFilter</span> <span class="hljs-title">ribbonRoutingFilter</span>(<span class="hljs-title">ProxyRequestHelper</span> <span class="hljs-title">helper</span>,</span><span class="hljs-class">      <span class="hljs-title">RibbonCommandFactory</span>&lt;?&gt; <span class="hljs-title">ribbonCommandFactory</span>) </span>&#123;   RibbonRoutingFilter filter = <span class="hljs-keyword">new</span> RibbonRoutingFilter(helper, ribbonCommandFactory,         <span class="hljs-keyword">this</span>.requestCustomizers);   <span class="hljs-keyword">return</span> filter;&#125;</code></pre><p>RibbonRoutingFilter中的run()方法</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;   RequestContext context = RequestContext.getCurrentContext();   <span class="hljs-keyword">this</span>.helper.addIgnoredHeaders();   <span class="hljs-keyword">try</span> &#123;      RibbonCommandContext commandContext = buildCommandContext(context);      ClientHttpResponse response = forward(commandContext);      setResponse(response);      <span class="hljs-keyword">return</span> response;   &#125;   <span class="hljs-keyword">catch</span> (ZuulException ex) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ZuulRuntimeException(ex);   &#125;   <span class="hljs-keyword">catch</span> (Exception ex) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ZuulRuntimeException(ex);   &#125;&#125;</code></pre><p>forward()方法会被run()方法调用。该方法会通过ribbonCommandFactory.create()方法获取到RibbonCommand对象，然后调用hystrix中的execute()方法。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> ClientHttpResponse <span class="hljs-title">forward</span><span class="hljs-params">(RibbonCommandContext context)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;   Map&lt;String, Object&gt; info = <span class="hljs-keyword">this</span>.helper.debug(context.getMethod(),         context.getUri(), context.getHeaders(), context.getParams(),         context.getRequestEntity());   RibbonCommand command = <span class="hljs-keyword">this</span>.ribbonCommandFactory.create(context);   <span class="hljs-keyword">try</span> &#123;      ClientHttpResponse response = command.execute();      <span class="hljs-keyword">this</span>.helper.appendDebug(info, response.getRawStatusCode(),            response.getHeaders());      <span class="hljs-keyword">return</span> response;   &#125;   <span class="hljs-keyword">catch</span> (HystrixRuntimeException ex) &#123;      <span class="hljs-keyword">return</span> handleException(info, ex);   &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>SpringCloud源码解析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>源码解读</tag>
      
      <tag>springcloud</tag>
      
      <tag>feign</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Feign源码解读</title>
    <link href="/blog/2020/04/28/springcloud-feign%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <url>/blog/2020/04/28/springcloud-feign%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="代理对象的生成"><a href="#代理对象的生成" class="headerlink" title="代理对象的生成"></a>代理对象的生成</h2><p>EnableFeignClients注解</p><pre><code class="hljs java"><span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-meta">@Target</span>(&#123;ElementType.TYPE&#125;)<span class="hljs-meta">@Documented</span><span class="hljs-meta">@Import</span>(&#123;FeignClientsRegistrar<span class="hljs-class">.<span class="hljs-keyword">class</span>&#125;)</span><span class="hljs-class"><span class="hljs-title">public</span> @<span class="hljs-title">interface</span> <span class="hljs-title">EnableFeignClients</span> </span>&#123;</code></pre><p>FeignClientsRegistrar中registerFeignClients()会扫描@FeignClient注解的类，然后调用registerFeignClient()进行注册。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerFeignClients</span><span class="hljs-params">(AnnotationMetadata metadata,</span></span><span class="hljs-function"><span class="hljs-params">      BeanDefinitionRegistry registry)</span> </span>&#123;   ClassPathScanningCandidateComponentProvider scanner = getScanner();   scanner.setResourceLoader(<span class="hljs-keyword">this</span>.resourceLoader);   Set&lt;String&gt; basePackages;   Map&lt;String, Object&gt; attrs = metadata         .getAnnotationAttributes(EnableFeignClients<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getName</span>())</span>;   AnnotationTypeFilter annotationTypeFilter = <span class="hljs-keyword">new</span> AnnotationTypeFilter(         FeignClient<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;   <span class="hljs-keyword">final</span> Class&lt;?&gt;[] clients = attrs == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span>         : (Class&lt;?&gt;[]) attrs.get(<span class="hljs-string">"clients"</span>);   <span class="hljs-keyword">if</span> (clients == <span class="hljs-keyword">null</span> || clients.length == <span class="hljs-number">0</span>) &#123;      scanner.addIncludeFilter(annotationTypeFilter);      basePackages = getBasePackages(metadata);   &#125;   <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">final</span> Set&lt;String&gt; clientClasses = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();      basePackages = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();      <span class="hljs-keyword">for</span> (Class&lt;?&gt; clazz : clients) &#123;         basePackages.add(ClassUtils.getPackageName(clazz));         clientClasses.add(clazz.getCanonicalName());      &#125;      AbstractClassTestingTypeFilter filter = <span class="hljs-keyword">new</span> AbstractClassTestingTypeFilter() &#123;         <span class="hljs-meta">@Override</span>         <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">match</span><span class="hljs-params">(ClassMetadata metadata)</span> </span>&#123;            String cleaned = metadata.getClassName().replaceAll(<span class="hljs-string">"\\$"</span>, <span class="hljs-string">"."</span>);            <span class="hljs-keyword">return</span> clientClasses.contains(cleaned);         &#125;      &#125;;      scanner.addIncludeFilter(            <span class="hljs-keyword">new</span> AllTypeFilter(Arrays.asList(filter, annotationTypeFilter)));   &#125;   <span class="hljs-keyword">for</span> (String basePackage : basePackages) &#123;      Set&lt;BeanDefinition&gt; candidateComponents = scanner            .findCandidateComponents(basePackage);      <span class="hljs-keyword">for</span> (BeanDefinition candidateComponent : candidateComponents) &#123;         <span class="hljs-keyword">if</span> (candidateComponent <span class="hljs-keyword">instanceof</span> AnnotatedBeanDefinition) &#123;            <span class="hljs-comment">// verify annotated class is an interface</span>            AnnotatedBeanDefinition beanDefinition = (AnnotatedBeanDefinition) candidateComponent;            AnnotationMetadata annotationMetadata = beanDefinition.getMetadata();            Assert.isTrue(annotationMetadata.isInterface(),                  <span class="hljs-string">"@FeignClient can only be specified on an interface"</span>);            Map&lt;String, Object&gt; attributes = annotationMetadata                  .getAnnotationAttributes(                        FeignClient<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getCanonicalName</span>())</span>;            String name = getClientName(attributes);            registerClientConfiguration(registry, name,                  attributes.get(<span class="hljs-string">"configuration"</span>));            registerFeignClient(registry, annotationMetadata, attributes);         &#125;      &#125;   &#125;&#125;</code></pre><p>registerFeignClient会引入FeignClientFactoryBean类，</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerFeignClient</span><span class="hljs-params">(BeanDefinitionRegistry registry,</span></span><span class="hljs-function"><span class="hljs-params">      AnnotationMetadata annotationMetadata, Map&lt;String, Object&gt; attributes)</span> </span>&#123;   String className = annotationMetadata.getClassName();   BeanDefinitionBuilder definition = BeanDefinitionBuilder         .genericBeanDefinition(FeignClientFactoryBean<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;   validate(attributes);   definition.addPropertyValue(<span class="hljs-string">"url"</span>, getUrl(attributes));   definition.addPropertyValue(<span class="hljs-string">"path"</span>, getPath(attributes));   String name = getName(attributes);   definition.addPropertyValue(<span class="hljs-string">"name"</span>, name);   String contextId = getContextId(attributes);   definition.addPropertyValue(<span class="hljs-string">"contextId"</span>, contextId);   definition.addPropertyValue(<span class="hljs-string">"type"</span>, className);   definition.addPropertyValue(<span class="hljs-string">"decode404"</span>, attributes.get(<span class="hljs-string">"decode404"</span>));   definition.addPropertyValue(<span class="hljs-string">"fallback"</span>, attributes.get(<span class="hljs-string">"fallback"</span>));   definition.addPropertyValue(<span class="hljs-string">"fallbackFactory"</span>, attributes.get(<span class="hljs-string">"fallbackFactory"</span>));   definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);   String alias = contextId + <span class="hljs-string">"FeignClient"</span>;   AbstractBeanDefinition beanDefinition = definition.getBeanDefinition();   <span class="hljs-keyword">boolean</span> primary = (Boolean) attributes.get(<span class="hljs-string">"primary"</span>); <span class="hljs-comment">// has a default, won't be</span>                                             <span class="hljs-comment">// null</span>   beanDefinition.setPrimary(primary);   String qualifier = getQualifier(attributes);   <span class="hljs-keyword">if</span> (StringUtils.hasText(qualifier)) &#123;      alias = qualifier;   &#125;   BeanDefinitionHolder holder = <span class="hljs-keyword">new</span> BeanDefinitionHolder(beanDefinition, className,         <span class="hljs-keyword">new</span> String[] &#123; alias &#125;);   BeanDefinitionReaderUtils.registerBeanDefinition(holder, registry);&#125;</code></pre><p>feign的切面实现跟mybatis差不多，在FeignClientFactoryBean对有@FeignClient注解的接口生成接口的代理FeignClientFactoryBean实现了factoryBean接口，里面有getObject方法</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;   <span class="hljs-keyword">return</span> getTarget();&#125;</code></pre><p>该方法会获取调用地址，bean的名称，类型后调用loadBalance()方法创建实例。</p><pre><code class="hljs java">&lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getTarget</span><span class="hljs-params">()</span> </span>&#123;   FeignContext context = <span class="hljs-keyword">this</span>.applicationContext.getBean(FeignContext<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;   Feign.Builder builder = feign(context);   <span class="hljs-keyword">if</span> (!StringUtils.hasText(<span class="hljs-keyword">this</span>.url)) &#123;      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.name.startsWith(<span class="hljs-string">"http"</span>)) &#123;         <span class="hljs-keyword">this</span>.url = <span class="hljs-string">"http://"</span> + <span class="hljs-keyword">this</span>.name;      &#125;      <span class="hljs-keyword">else</span> &#123;         <span class="hljs-keyword">this</span>.url = <span class="hljs-keyword">this</span>.name;      &#125;      <span class="hljs-keyword">this</span>.url += cleanPath();      <span class="hljs-keyword">return</span> (T) loadBalance(builder, context,            <span class="hljs-keyword">new</span> HardCodedTarget&lt;&gt;(<span class="hljs-keyword">this</span>.type, <span class="hljs-keyword">this</span>.name, <span class="hljs-keyword">this</span>.url));   &#125;   <span class="hljs-keyword">if</span> (StringUtils.hasText(<span class="hljs-keyword">this</span>.url) &amp;&amp; !<span class="hljs-keyword">this</span>.url.startsWith(<span class="hljs-string">"http"</span>)) &#123;      <span class="hljs-keyword">this</span>.url = <span class="hljs-string">"http://"</span> + <span class="hljs-keyword">this</span>.url;   &#125;   String url = <span class="hljs-keyword">this</span>.url + cleanPath();   Client client = getOptional(context, Client<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;   <span class="hljs-keyword">if</span> (client != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">if</span> (client <span class="hljs-keyword">instanceof</span> LoadBalancerFeignClient) &#123;         <span class="hljs-comment">// not load balancing because we have a url,</span>         <span class="hljs-comment">// but ribbon is on the classpath, so unwrap</span>         client = ((LoadBalancerFeignClient) client).getDelegate();      &#125;      <span class="hljs-keyword">if</span> (client <span class="hljs-keyword">instanceof</span> FeignBlockingLoadBalancerClient) &#123;         <span class="hljs-comment">// not load balancing because we have a url,</span>         <span class="hljs-comment">// but Spring Cloud LoadBalancer is on the classpath, so unwrap</span>         client = ((FeignBlockingLoadBalancerClient) client).getDelegate();      &#125;      builder.client(client);   &#125;   Targeter targeter = get(context, Targeter<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;   <span class="hljs-keyword">return</span> (T) targeter.target(<span class="hljs-keyword">this</span>, builder, context,         <span class="hljs-keyword">new</span> HardCodedTarget&lt;&gt;(<span class="hljs-keyword">this</span>.type, <span class="hljs-keyword">this</span>.name, url));&#125;</code></pre><p>loadBalance()方法调用到Feign类的target()方法</p><pre><code class="hljs java"><span class="hljs-keyword">protected</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">loadBalance</span><span class="hljs-params">(Feign.Builder builder, FeignContext context,</span></span><span class="hljs-function"><span class="hljs-params">      HardCodedTarget&lt;T&gt; target)</span> </span>&#123;   Client client = getOptional(context, Client<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;   <span class="hljs-keyword">if</span> (client != <span class="hljs-keyword">null</span>) &#123;      builder.client(client);      Targeter targeter = get(context, Targeter<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;      <span class="hljs-keyword">return</span> targeter.target(<span class="hljs-keyword">this</span>, builder, context, target);   &#125;   <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(         <span class="hljs-string">"No Feign Client for loadBalancing defined. Did you forget to include spring-cloud-starter-netflix-ribbon?"</span>);&#125;</code></pre><p>target()方法会调用newInstance()方法生成代理对象。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">target</span><span class="hljs-params">(Target&lt;T&gt; target)</span> </span>&#123;  <span class="hljs-keyword">return</span> build().newInstance(target);&#125;</code></pre><p>newInstance()方法会调用create()方法生成JDK的代理对象，最终会生成有@FeignClient注解的接口的代理</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">newInstance</span><span class="hljs-params">(Target&lt;T&gt; target)</span> </span>&#123;  Map&lt;String, MethodHandler&gt; nameToHandler = targetToHandlersByName.apply(target);  Map&lt;Method, MethodHandler&gt; methodToHandler = <span class="hljs-keyword">new</span> LinkedHashMap&lt;Method, MethodHandler&gt;();  List&lt;DefaultMethodHandler&gt; defaultMethodHandlers = <span class="hljs-keyword">new</span> LinkedList&lt;DefaultMethodHandler&gt;();  <span class="hljs-keyword">for</span> (Method method : target.type().getMethods()) &#123;    <span class="hljs-keyword">if</span> (method.getDeclaringClass() == Object<span class="hljs-class">.<span class="hljs-keyword">class</span>) </span>&#123;      <span class="hljs-keyword">continue</span>;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Util.isDefault(method)) &#123;      DefaultMethodHandler handler = <span class="hljs-keyword">new</span> DefaultMethodHandler(method);      defaultMethodHandlers.add(handler);      methodToHandler.put(method, handler);    &#125; <span class="hljs-keyword">else</span> &#123;      methodToHandler.put(method, nameToHandler.get(Feign.configKey(target.type(), method)));    &#125;  &#125;  InvocationHandler handler = factory.create(target, methodToHandler);  T proxy = (T) Proxy.newProxyInstance(target.type().getClassLoader(),      <span class="hljs-keyword">new</span> Class&lt;?&gt;[] &#123;target.type()&#125;, handler);  <span class="hljs-keyword">for</span> (DefaultMethodHandler defaultMethodHandler : defaultMethodHandlers) &#123;    defaultMethodHandler.bindTo(proxy);  &#125;  <span class="hljs-keyword">return</span> proxy;&#125;</code></pre><h2 id="代理对象的调用"><a href="#代理对象的调用" class="headerlink" title="代理对象的调用"></a>代理对象的调用</h2><p>Controller中获取到代理实例后，则会调用到HystrixInvocationHandler的invoke()方法，这里跟hystrix基本类似，最后会走到run()方法的钩子方法中</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, <span class="hljs-keyword">final</span> Method method, <span class="hljs-keyword">final</span> Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;    <span class="hljs-keyword">if</span> (!<span class="hljs-string">"equals"</span>.equals(method.getName())) &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-string">"hashCode"</span>.equals(method.getName())) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.hashCode();        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">"toString"</span>.equals(method.getName())) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.toString();        &#125; <span class="hljs-keyword">else</span> &#123;            HystrixCommand&lt;Object&gt; hystrixCommand = <span class="hljs-keyword">new</span> HystrixCommand&lt;Object&gt;((Setter)<span class="hljs-keyword">this</span>.setterMethodMap.get(method)) &#123;                <span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                    <span class="hljs-keyword">try</span> &#123;                        <span class="hljs-keyword">return</span> ((MethodHandler)HystrixInvocationHandler.<span class="hljs-keyword">this</span>.dispatch.get(method)).invoke(args);                    &#125; <span class="hljs-keyword">catch</span> (Exception var2) &#123;                        <span class="hljs-keyword">throw</span> var2;                    &#125; <span class="hljs-keyword">catch</span> (Throwable var3) &#123;                        <span class="hljs-keyword">throw</span> (Error)var3;                    &#125;                &#125;                <span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">getFallback</span><span class="hljs-params">()</span> </span>&#123;                    <span class="hljs-keyword">if</span> (HystrixInvocationHandler.<span class="hljs-keyword">this</span>.fallbackFactory == <span class="hljs-keyword">null</span>) &#123;                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.getFallback();                    &#125; <span class="hljs-keyword">else</span> &#123;                        <span class="hljs-keyword">try</span> &#123;                            Object fallback = HystrixInvocationHandler.<span class="hljs-keyword">this</span>.fallbackFactory.create(<span class="hljs-keyword">this</span>.getExecutionException());                            Object result = ((Method)HystrixInvocationHandler.<span class="hljs-keyword">this</span>.fallbackMethodMap.get(method)).invoke(fallback, args);                            <span class="hljs-keyword">if</span> (HystrixInvocationHandler.<span class="hljs-keyword">this</span>.isReturnsHystrixCommand(method)) &#123;                                <span class="hljs-keyword">return</span> ((HystrixCommand)result).execute();                            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (HystrixInvocationHandler.<span class="hljs-keyword">this</span>.isReturnsObservable(method)) &#123;                                <span class="hljs-keyword">return</span> ((Observable)result).toBlocking().first();                            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (HystrixInvocationHandler.<span class="hljs-keyword">this</span>.isReturnsSingle(method)) &#123;                                <span class="hljs-keyword">return</span> ((Single)result).toObservable().toBlocking().first();                            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (HystrixInvocationHandler.<span class="hljs-keyword">this</span>.isReturnsCompletable(method)) &#123;                                ((Completable)result).await();                                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;                            &#125; <span class="hljs-keyword">else</span> &#123;                                <span class="hljs-keyword">return</span> HystrixInvocationHandler.<span class="hljs-keyword">this</span>.isReturnsCompletableFuture(method) ? ((Future)result).get() : result;                            &#125;                        &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException var3) &#123;                            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AssertionError(var3);                        &#125; <span class="hljs-keyword">catch</span> (ExecutionException | InvocationTargetException var4) &#123;                            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AssertionError(var4.getCause());                        &#125; <span class="hljs-keyword">catch</span> (InterruptedException var5) &#123;                            Thread.currentThread().interrupt();                            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AssertionError(var5.getCause());                        &#125;                    &#125;                &#125;            &#125;;            <span class="hljs-keyword">if</span> (Util.isDefault(method)) &#123;                <span class="hljs-keyword">return</span> hystrixCommand.execute();            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isReturnsHystrixCommand(method)) &#123;                <span class="hljs-keyword">return</span> hystrixCommand;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isReturnsObservable(method)) &#123;                <span class="hljs-keyword">return</span> hystrixCommand.toObservable();            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isReturnsSingle(method)) &#123;                <span class="hljs-keyword">return</span> hystrixCommand.toObservable().toSingle();            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isReturnsCompletable(method)) &#123;                <span class="hljs-keyword">return</span> hystrixCommand.toObservable().toCompletable();            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.isReturnsCompletableFuture(method) ? <span class="hljs-keyword">new</span> ObservableCompletableFuture(hystrixCommand) : hystrixCommand.execute();            &#125;        &#125;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">try</span> &#123;            Object otherHandler = args.length &gt; <span class="hljs-number">0</span> &amp;&amp; args[<span class="hljs-number">0</span>] != <span class="hljs-keyword">null</span> ? Proxy.getInvocationHandler(args[<span class="hljs-number">0</span>]) : <span class="hljs-keyword">null</span>;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.equals(otherHandler);        &#125; <span class="hljs-keyword">catch</span> (IllegalArgumentException var5) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;    &#125;&#125;</code></pre><p>SynchronousMethodHandler的invoke()方法</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object[] argv)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;  RequestTemplate template = buildTemplateFromArgs.create(argv);  Options options = findOptions(argv);  Retryer retryer = <span class="hljs-keyword">this</span>.retryer.clone();  <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-keyword">return</span> executeAndDecode(template, options);    &#125; <span class="hljs-keyword">catch</span> (RetryableException e) &#123;      <span class="hljs-keyword">try</span> &#123;        retryer.continueOrPropagate(e);      &#125; <span class="hljs-keyword">catch</span> (RetryableException th) &#123;        Throwable cause = th.getCause();        <span class="hljs-keyword">if</span> (propagationPolicy == UNWRAP &amp;&amp; cause != <span class="hljs-keyword">null</span>) &#123;          <span class="hljs-keyword">throw</span> cause;        &#125; <span class="hljs-keyword">else</span> &#123;          <span class="hljs-keyword">throw</span> th;        &#125;      &#125;      <span class="hljs-keyword">if</span> (logLevel != Logger.Level.NONE) &#123;        logger.logRetry(metadata.configKey(), logLevel);      &#125;      <span class="hljs-keyword">continue</span>;    &#125;  &#125;&#125;</code></pre><p>executeAndDecode()方法会执行execute()方法，该方法会调用到ribbon功能。</p><pre><code class="hljs java"><span class="hljs-function">Object <span class="hljs-title">executeAndDecode</span><span class="hljs-params">(RequestTemplate template, Options options)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;  Request request = targetRequest(template);  <span class="hljs-keyword">if</span> (logLevel != Logger.Level.NONE) &#123;    logger.logRequest(metadata.configKey(), logLevel, request);  &#125;  Response response;  <span class="hljs-keyword">long</span> start = System.nanoTime();  <span class="hljs-keyword">try</span> &#123;    response = client.execute(request, options);    <span class="hljs-comment">// ensure the request is set. <span class="hljs-doctag">TODO:</span> remove in Feign 12</span>    response = response.toBuilder()        .request(request)        .requestTemplate(template)        .build();  &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;    <span class="hljs-keyword">if</span> (logLevel != Logger.Level.NONE) &#123;      logger.logIOException(metadata.configKey(), logLevel, e, elapsedTime(start));    &#125;    <span class="hljs-keyword">throw</span> errorExecuting(request, e);  &#125;  <span class="hljs-keyword">long</span> elapsedTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);  <span class="hljs-keyword">boolean</span> shouldClose = <span class="hljs-keyword">true</span>;  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-keyword">if</span> (logLevel != Logger.Level.NONE) &#123;      response =          logger.logAndRebufferResponse(metadata.configKey(), logLevel, response, elapsedTime);    &#125;    <span class="hljs-keyword">if</span> (Response<span class="hljs-class">.<span class="hljs-keyword">class</span> </span>== metadata.returnType()) &#123;      <span class="hljs-keyword">if</span> (response.body() == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> response;      &#125;      <span class="hljs-keyword">if</span> (response.body().length() == <span class="hljs-keyword">null</span> ||          response.body().length() &gt; MAX_RESPONSE_BUFFER_SIZE) &#123;        shouldClose = <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">return</span> response;      &#125;      <span class="hljs-comment">// Ensure the response body is disconnected</span>      <span class="hljs-keyword">byte</span>[] bodyData = Util.toByteArray(response.body().asInputStream());      <span class="hljs-keyword">return</span> response.toBuilder().body(bodyData).build();    &#125;    <span class="hljs-keyword">if</span> (response.status() &gt;= <span class="hljs-number">200</span> &amp;&amp; response.status() &lt; <span class="hljs-number">300</span>) &#123;      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">void</span><span class="hljs-class">.<span class="hljs-keyword">class</span> </span>== metadata.returnType()) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;      &#125; <span class="hljs-keyword">else</span> &#123;        Object result = decode(response);        shouldClose = closeAfterDecode;        <span class="hljs-keyword">return</span> result;      &#125;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (decode404 &amp;&amp; response.status() == <span class="hljs-number">404</span> &amp;&amp; <span class="hljs-keyword">void</span><span class="hljs-class">.<span class="hljs-keyword">class</span> !</span>= metadata.returnType()) &#123;      Object result = decode(response);      shouldClose = closeAfterDecode;      <span class="hljs-keyword">return</span> result;    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">throw</span> errorDecoder.decode(metadata.configKey(), response);    &#125;  &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;    <span class="hljs-keyword">if</span> (logLevel != Logger.Level.NONE) &#123;      logger.logIOException(metadata.configKey(), logLevel, e, elapsedTime);    &#125;    <span class="hljs-keyword">throw</span> errorReading(request, response, e);  &#125; <span class="hljs-keyword">finally</span> &#123;    <span class="hljs-keyword">if</span> (shouldClose) &#123;      ensureClosed(response.body());    &#125;  &#125;&#125;</code></pre><p>LoadBalancerFeignClient的execute()方法</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Response <span class="hljs-title">execute</span><span class="hljs-params">(Request request, Request.Options options)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;   <span class="hljs-keyword">try</span> &#123;      URI asUri = URI.create(request.url());      String clientName = asUri.getHost();      URI uriWithoutHost = cleanUrl(request.url(), clientName);      FeignLoadBalancer.RibbonRequest ribbonRequest = <span class="hljs-keyword">new</span> FeignLoadBalancer.RibbonRequest(            <span class="hljs-keyword">this</span>.delegate, request, uriWithoutHost);      IClientConfig requestConfig = getClientConfig(options, clientName);      <span class="hljs-keyword">return</span> lbClient(clientName)            .executeWithLoadBalancer(ribbonRequest, requestConfig).toResponse();   &#125;   <span class="hljs-keyword">catch</span> (ClientException e) &#123;      IOException io = findIOException(e);      <span class="hljs-keyword">if</span> (io != <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">throw</span> io;      &#125;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);   &#125;&#125;</code></pre><p>lbClient()方法会调用到CachingSpringLoadBalancerFactory的create()方法，在这个方法里面获取服务列表类进行调用。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> FeignLoadBalancer <span class="hljs-title">create</span><span class="hljs-params">(String clientName)</span> </span>&#123;   FeignLoadBalancer client = <span class="hljs-keyword">this</span>.cache.get(clientName);   <span class="hljs-keyword">if</span> (client != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> client;   &#125;   IClientConfig config = <span class="hljs-keyword">this</span>.factory.getClientConfig(clientName);   ILoadBalancer lb = <span class="hljs-keyword">this</span>.factory.getLoadBalancer(clientName);   ServerIntrospector serverIntrospector = <span class="hljs-keyword">this</span>.factory.getInstance(clientName,         ServerIntrospector<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;   client = <span class="hljs-keyword">this</span>.loadBalancedRetryFactory != <span class="hljs-keyword">null</span>         ? <span class="hljs-keyword">new</span> RetryableFeignLoadBalancer(lb, config, serverIntrospector,               <span class="hljs-keyword">this</span>.loadBalancedRetryFactory)         : <span class="hljs-keyword">new</span> FeignLoadBalancer(lb, config, serverIntrospector);   <span class="hljs-keyword">this</span>.cache.put(clientName, client);   <span class="hljs-keyword">return</span> client;&#125;</code></pre><p>executeWithLoadBalancer()方法会调用到FeignLoadBalancer的execute()方法完成服务调用。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">executeWithLoadBalancer</span><span class="hljs-params">(<span class="hljs-keyword">final</span> S request, <span class="hljs-keyword">final</span> IClientConfig requestConfig)</span> <span class="hljs-keyword">throws</span> ClientException </span>&#123;    LoadBalancerCommand&lt;T&gt; command = buildLoadBalancerCommand(request, requestConfig);    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">return</span> command.submit(            <span class="hljs-keyword">new</span> ServerOperation&lt;T&gt;() &#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">public</span> Observable&lt;T&gt; <span class="hljs-title">call</span><span class="hljs-params">(Server server)</span> </span>&#123;                    URI finalUri = reconstructURIWithServer(server, request.getUri());                    S requestForServer = (S) request.replaceUri(finalUri);                    <span class="hljs-keyword">try</span> &#123;                        <span class="hljs-keyword">return</span> Observable.just(AbstractLoadBalancerAwareClient.<span class="hljs-keyword">this</span>.execute(requestForServer, requestConfig));                    &#125;                     <span class="hljs-keyword">catch</span> (Exception e) &#123;                        <span class="hljs-keyword">return</span> Observable.error(e);                    &#125;                &#125;            &#125;)            .toBlocking()            .single();    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        Throwable t = e.getCause();        <span class="hljs-keyword">if</span> (t <span class="hljs-keyword">instanceof</span> ClientException) &#123;            <span class="hljs-keyword">throw</span> (ClientException) t;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ClientException(e);        &#125;    &#125;    &#125;</code></pre><p>FeignLoadBalancer的execute()方法。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> RibbonResponse <span class="hljs-title">execute</span><span class="hljs-params">(RibbonRequest request, IClientConfig configOverride)</span></span><span class="hljs-function">      <span class="hljs-keyword">throws</span> IOException </span>&#123;   Request.Options options;   <span class="hljs-keyword">if</span> (configOverride != <span class="hljs-keyword">null</span>) &#123;      RibbonProperties override = RibbonProperties.from(configOverride);      options = <span class="hljs-keyword">new</span> Request.Options(override.connectTimeout(<span class="hljs-keyword">this</span>.connectTimeout),            override.readTimeout(<span class="hljs-keyword">this</span>.readTimeout));   &#125;   <span class="hljs-keyword">else</span> &#123;      options = <span class="hljs-keyword">new</span> Request.Options(<span class="hljs-keyword">this</span>.connectTimeout, <span class="hljs-keyword">this</span>.readTimeout);   &#125;   Response response = request.client().execute(request.toRequest(), options);   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RibbonResponse(request.getUri(), response);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>SpringCloud源码解析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>源码解读</tag>
      
      <tag>springcloud</tag>
      
      <tag>feign</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hystrix源码解读</title>
    <link href="/blog/2020/04/27/springcloud-hystrix%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <url>/blog/2020/04/27/springcloud-hystrix%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="Hystrix源码"><a href="#Hystrix源码" class="headerlink" title="Hystrix源码"></a>Hystrix源码</h2><p>首先分析下开启Hystrix的注解@EnableCircuitBreaker</p><pre><code class="hljs java"><span class="hljs-meta">@Target</span>(ElementType.TYPE)<span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-meta">@Documented</span><span class="hljs-meta">@Inherited</span><span class="hljs-meta">@Import</span>(EnableCircuitBreakerImportSelector<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> @<span class="hljs-title">interface</span> <span class="hljs-title">EnableCircuitBreaker</span> </span>&#123;&#125;</code></pre><p>该注解会引入EnableCircuitBreakerImportSelector类，SpringFactoryImportSelector是它的的父类，该类selectImports()方法通过springboot的SPI机制引入spring.factories中以@EnableCircuitBreaker为key的所有类。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> String[] selectImports(AnnotationMetadata metadata) &#123;   <span class="hljs-keyword">if</span> (!isEnabled()) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String[<span class="hljs-number">0</span>];   &#125;   AnnotationAttributes attributes = AnnotationAttributes.fromMap(         metadata.getAnnotationAttributes(<span class="hljs-keyword">this</span>.annotationClass.getName(), <span class="hljs-keyword">true</span>));   Assert.notNull(attributes, <span class="hljs-string">"No "</span> + getSimpleName() + <span class="hljs-string">" attributes found. Is "</span>         + metadata.getClassName() + <span class="hljs-string">" annotated with @"</span> + getSimpleName() + <span class="hljs-string">"?"</span>);   <span class="hljs-comment">// Find all possible auto configuration classes, filtering duplicates</span>   List&lt;String&gt; factories = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(SpringFactoriesLoader         .loadFactoryNames(<span class="hljs-keyword">this</span>.annotationClass, <span class="hljs-keyword">this</span>.beanClassLoader)));   <span class="hljs-keyword">if</span> (factories.isEmpty() &amp;&amp; !hasDefaultFactory()) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Annotation @"</span> + getSimpleName()            + <span class="hljs-string">" found, but there are no implementations. Did you forget to include a starter?"</span>);   &#125;   <span class="hljs-keyword">if</span> (factories.size() &gt; <span class="hljs-number">1</span>) &#123;      <span class="hljs-comment">// there should only ever be one DiscoveryClient, but there might be more than</span>      <span class="hljs-comment">// one factory</span>      <span class="hljs-keyword">this</span>.log.warn(<span class="hljs-string">"More than one implementation "</span> + <span class="hljs-string">"of @"</span> + getSimpleName()            + <span class="hljs-string">" (now relying on @Conditionals to pick one): "</span> + factories);   &#125;   <span class="hljs-keyword">return</span> factories.toArray(<span class="hljs-keyword">new</span> String[factories.size()]);&#125;</code></pre><p>HystrixCircuitBreakerConfiguration类再上一步中被引入，该类会创建hystrixCommand注解的切面类HystrixCommandAspect。</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>(proxyBeanMethods = <span class="hljs-keyword">false</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HystrixCircuitBreakerConfiguration</span> </span>&#123;   <span class="hljs-meta">@Bean</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> HystrixCommandAspect <span class="hljs-title">hystrixCommandAspect</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HystrixCommandAspect();   &#125;   &#123;...&#125;&#125;</code></pre><p>HystrixCommandAspect类，会判断类上是否有@HystrixCommand或者@HystrixCollapser注解，如果有就会进入methodsAnnotatedWithHystrixCommand()环绕增强方法。</p><pre><code class="hljs java"><span class="hljs-meta">@Around</span>(<span class="hljs-string">"hystrixCommandAnnotationPointcut() || hystrixCollapserAnnotationPointcut()"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">methodsAnnotatedWithHystrixCommand</span><span class="hljs-params">(<span class="hljs-keyword">final</span> ProceedingJoinPoint joinPoint)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;    Method method = getMethodFromTarget(joinPoint);    Validate.notNull(method, <span class="hljs-string">"failed to get method from joinPoint: %s"</span>, joinPoint);    <span class="hljs-keyword">if</span> (method.isAnnotationPresent(HystrixCommand<span class="hljs-class">.<span class="hljs-keyword">class</span>) &amp;&amp; <span class="hljs-title">method</span>.<span class="hljs-title">isAnnotationPresent</span>(<span class="hljs-title">HystrixCollapser</span>.<span class="hljs-title">class</span>)) </span>&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"method cannot be annotated with HystrixCommand and HystrixCollapser "</span> +                <span class="hljs-string">"annotations at the same time"</span>);    &#125;    MetaHolderFactory metaHolderFactory = META_HOLDER_FACTORY_MAP.get(HystrixPointcutType.of(method));    MetaHolder metaHolder = metaHolderFactory.create(joinPoint);    HystrixInvokable invokable = HystrixCommandFactory.getInstance().create(metaHolder);    ExecutionType executionType = metaHolder.isCollapserAnnotationPresent() ?            metaHolder.getCollapserExecutionType() : metaHolder.getExecutionType();    Object result;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">if</span> (!metaHolder.isObservable()) &#123;            result = CommandExecutor.execute(invokable, executionType, metaHolder);        &#125; <span class="hljs-keyword">else</span> &#123;            result = executeObservable(invokable, executionType, metaHolder);        &#125;    &#125; <span class="hljs-keyword">catch</span> (HystrixBadRequestException e) &#123;        <span class="hljs-keyword">throw</span> e.getCause();    &#125; <span class="hljs-keyword">catch</span> (HystrixRuntimeException e) &#123;        <span class="hljs-keyword">throw</span> hystrixRuntimeExceptionToThrowable(metaHolder, e);    &#125;    <span class="hljs-keyword">return</span> result;&#125;</code></pre><p>methodsAnnotatedWithHystrixCommand()方法会调用execute()方法，这里涉及到同步及异步调用。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">execute</span><span class="hljs-params">(HystrixInvokable invokable, ExecutionType executionType, MetaHolder metaHolder)</span> <span class="hljs-keyword">throws</span> RuntimeException </span>&#123;    Validate.notNull(invokable);    Validate.notNull(metaHolder);    <span class="hljs-keyword">switch</span> (executionType) &#123;        <span class="hljs-keyword">case</span> SYNCHRONOUS: &#123;            <span class="hljs-keyword">return</span> castToExecutable(invokable, executionType).execute();        &#125;        <span class="hljs-keyword">case</span> ASYNCHRONOUS: &#123;            HystrixExecutable executable = castToExecutable(invokable, executionType);            <span class="hljs-keyword">if</span> (metaHolder.hasFallbackMethodCommand()                    &amp;&amp; ExecutionType.ASYNCHRONOUS == metaHolder.getFallbackExecutionType()) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FutureDecorator(executable.queue());            &#125;            <span class="hljs-keyword">return</span> executable.queue();        &#125;        <span class="hljs-keyword">case</span> OBSERVABLE: &#123;            HystrixObservable observable = castToObservable(invokable);            <span class="hljs-keyword">return</span> ObservableExecutionMode.EAGER == metaHolder.getObservableExecutionMode() ? observable.observe() : observable.toObservable();        &#125;        <span class="hljs-keyword">default</span>:            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"unsupported execution type: "</span> + executionType);    &#125;&#125;</code></pre><h3 id="同步调用"><a href="#同步调用" class="headerlink" title="同步调用"></a>同步调用</h3><p>HystrixCommand类中的execute()方法，HystrixCommand类是实现了Hystrix功能的类。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> R <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">return</span> queue().get();    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        <span class="hljs-keyword">throw</span> Exceptions.sneakyThrow(decomposeException(e));    &#125;&#125;</code></pre><p>queue()</p><pre><code class="hljs java"> <span class="hljs-function"><span class="hljs-keyword">public</span> Future&lt;R&gt; <span class="hljs-title">queue</span><span class="hljs-params">()</span> </span>&#123;     <span class="hljs-comment">/*</span><span class="hljs-comment">      * The Future returned by Observable.toBlocking().toFuture() does not implement the</span><span class="hljs-comment">      * interruption of the execution thread when the "mayInterrupt" flag of Future.cancel(boolean) is set to true;</span><span class="hljs-comment">      * thus, to comply with the contract of Future, we must wrap around it.</span><span class="hljs-comment">      */</span>     <span class="hljs-keyword">final</span> Future&lt;R&gt; delegate = toObservable().toBlocking().toFuture();        <span class="hljs-keyword">final</span> Future&lt;R&gt; f = <span class="hljs-keyword">new</span> Future&lt;R&gt;() &#123;         <span class="hljs-meta">@Override</span>         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">cancel</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> mayInterruptIfRunning)</span> </span>&#123;             <span class="hljs-keyword">if</span> (delegate.isCancelled()) &#123;                 <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;             &#125;             <span class="hljs-keyword">if</span> (HystrixCommand.<span class="hljs-keyword">this</span>.getProperties().executionIsolationThreadInterruptOnFutureCancel().get()) &#123;                 <span class="hljs-comment">/*</span><span class="hljs-comment">                  * The only valid transition here is false -&gt; true. If there are two futures, say f1 and f2, created by this command</span><span class="hljs-comment">                  * (which is super-weird, but has never been prohibited), and calls to f1.cancel(true) and to f2.cancel(false) are</span><span class="hljs-comment">                  * issued by different threads, it's unclear about what value would be used by the time mayInterruptOnCancel is checked.</span><span class="hljs-comment">                  * The most consistent way to deal with this scenario is to say that if *any* cancellation is invoked with interruption,</span><span class="hljs-comment">                  * than that interruption request cannot be taken back.</span><span class="hljs-comment">                  */</span>                 interruptOnFutureCancel.compareAndSet(<span class="hljs-keyword">false</span>, mayInterruptIfRunning);          &#125;             <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> res = delegate.cancel(interruptOnFutureCancel.get());             <span class="hljs-keyword">if</span> (!isExecutionComplete() &amp;&amp; interruptOnFutureCancel.get()) &#123;                 <span class="hljs-keyword">final</span> Thread t = executionThread.get();                 <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span> &amp;&amp; !t.equals(Thread.currentThread())) &#123;                     t.interrupt();                 &#125;             &#125;             <span class="hljs-keyword">return</span> res;&#125;         <span class="hljs-meta">@Override</span>         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isCancelled</span><span class="hljs-params">()</span> </span>&#123;             <span class="hljs-keyword">return</span> delegate.isCancelled();&#125;         <span class="hljs-meta">@Override</span>         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isDone</span><span class="hljs-params">()</span> </span>&#123;             <span class="hljs-keyword">return</span> delegate.isDone();&#125;         <span class="hljs-meta">@Override</span>         <span class="hljs-function"><span class="hljs-keyword">public</span> R <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException </span>&#123;             <span class="hljs-keyword">return</span> delegate.get();         &#125;         <span class="hljs-meta">@Override</span>         <span class="hljs-function"><span class="hljs-keyword">public</span> R <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;             <span class="hljs-keyword">return</span> delegate.get(timeout, unit);         &#125;            &#125;;     <span class="hljs-comment">/* special handling of error states that throw immediately */</span>     <span class="hljs-keyword">if</span> (f.isDone()) &#123;         <span class="hljs-keyword">try</span> &#123;             f.get();             <span class="hljs-keyword">return</span> f;         &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;             Throwable t = decomposeException(e);             <span class="hljs-keyword">if</span> (t <span class="hljs-keyword">instanceof</span> HystrixBadRequestException) &#123;                 <span class="hljs-keyword">return</span> f;             &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t <span class="hljs-keyword">instanceof</span> HystrixRuntimeException) &#123;                 HystrixRuntimeException hre = (HystrixRuntimeException) t;                 <span class="hljs-keyword">switch</span> (hre.getFailureType()) &#123;      <span class="hljs-keyword">case</span> COMMAND_EXCEPTION:      <span class="hljs-keyword">case</span> TIMEOUT:         <span class="hljs-comment">// we don't throw these types from queue() only from queue().get() as they are execution errors</span>         <span class="hljs-keyword">return</span> f;      <span class="hljs-keyword">default</span>:         <span class="hljs-comment">// these are errors we throw from queue() as they as rejection type errors</span>         <span class="hljs-keyword">throw</span> hre;      &#125;             &#125; <span class="hljs-keyword">else</span> &#123;                 <span class="hljs-keyword">throw</span> Exceptions.sneakyThrow(t);             &#125;         &#125;     &#125;     <span class="hljs-keyword">return</span> f; &#125;</code></pre><p>toObservable()方法中使用了RxJava的写法，会定义多个action然后使用defer()方法调用action中的call()方法。这里重点关注applyHystrixSemantics的call()方法。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Observable&lt;R&gt; <span class="hljs-title">toObservable</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">final</span> AbstractCommand&lt;R&gt; _cmd = <span class="hljs-keyword">this</span>;    <span class="hljs-comment">//doOnCompleted handler already did all of the SUCCESS work</span>    <span class="hljs-comment">//doOnError handler already did all of the FAILURE/TIMEOUT/REJECTION/BAD_REQUEST work</span>    <span class="hljs-keyword">final</span> Action0 terminateCommandCleanup = <span class="hljs-keyword">new</span> Action0() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">if</span> (_cmd.commandState.compareAndSet(CommandState.OBSERVABLE_CHAIN_CREATED, CommandState.TERMINAL)) &#123;                handleCommandEnd(<span class="hljs-keyword">false</span>); <span class="hljs-comment">//user code never ran</span>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_cmd.commandState.compareAndSet(CommandState.USER_CODE_EXECUTED, CommandState.TERMINAL)) &#123;                handleCommandEnd(<span class="hljs-keyword">true</span>); <span class="hljs-comment">//user code did run</span>            &#125;        &#125;    &#125;;    <span class="hljs-comment">//mark the command as CANCELLED and store the latency (in addition to standard cleanup)</span>    <span class="hljs-keyword">final</span> Action0 unsubscribeCommandCleanup = <span class="hljs-keyword">new</span> Action0() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">if</span> (_cmd.commandState.compareAndSet(CommandState.OBSERVABLE_CHAIN_CREATED, CommandState.UNSUBSCRIBED)) &#123;                <span class="hljs-keyword">if</span> (!_cmd.executionResult.containsTerminalEvent()) &#123;                    _cmd.eventNotifier.markEvent(HystrixEventType.CANCELLED, _cmd.commandKey);                    <span class="hljs-keyword">try</span> &#123;                        executionHook.onUnsubscribe(_cmd);                    &#125; <span class="hljs-keyword">catch</span> (Throwable hookEx) &#123;                        logger.warn(<span class="hljs-string">"Error calling HystrixCommandExecutionHook.onUnsubscribe"</span>, hookEx);                    &#125;                    _cmd.executionResultAtTimeOfCancellation = _cmd.executionResult                            .addEvent((<span class="hljs-keyword">int</span>) (System.currentTimeMillis() - _cmd.commandStartTimestamp), HystrixEventType.CANCELLED);                &#125;                handleCommandEnd(<span class="hljs-keyword">false</span>); <span class="hljs-comment">//user code never ran</span>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_cmd.commandState.compareAndSet(CommandState.USER_CODE_EXECUTED, CommandState.UNSUBSCRIBED)) &#123;                <span class="hljs-keyword">if</span> (!_cmd.executionResult.containsTerminalEvent()) &#123;                    _cmd.eventNotifier.markEvent(HystrixEventType.CANCELLED, _cmd.commandKey);                    <span class="hljs-keyword">try</span> &#123;                        executionHook.onUnsubscribe(_cmd);                    &#125; <span class="hljs-keyword">catch</span> (Throwable hookEx) &#123;                        logger.warn(<span class="hljs-string">"Error calling HystrixCommandExecutionHook.onUnsubscribe"</span>, hookEx);                    &#125;                    _cmd.executionResultAtTimeOfCancellation = _cmd.executionResult                            .addEvent((<span class="hljs-keyword">int</span>) (System.currentTimeMillis() - _cmd.commandStartTimestamp), HystrixEventType.CANCELLED);                &#125;                handleCommandEnd(<span class="hljs-keyword">true</span>); <span class="hljs-comment">//user code did run</span>            &#125;        &#125;    &#125;;    <span class="hljs-keyword">final</span> Func0&lt;Observable&lt;R&gt;&gt; applyHystrixSemantics = <span class="hljs-keyword">new</span> Func0&lt;Observable&lt;R&gt;&gt;() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> Observable&lt;R&gt; <span class="hljs-title">call</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">if</span> (commandState.get().equals(CommandState.UNSUBSCRIBED)) &#123;                <span class="hljs-keyword">return</span> Observable.never();            &#125;            <span class="hljs-keyword">return</span> applyHystrixSemantics(_cmd);        &#125;    &#125;;    <span class="hljs-keyword">final</span> Func1&lt;R, R&gt; wrapWithAllOnNextHooks = <span class="hljs-keyword">new</span> Func1&lt;R, R&gt;() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> R <span class="hljs-title">call</span><span class="hljs-params">(R r)</span> </span>&#123;            R afterFirstApplication = r;            <span class="hljs-keyword">try</span> &#123;                afterFirstApplication = executionHook.onComplete(_cmd, r);            &#125; <span class="hljs-keyword">catch</span> (Throwable hookEx) &#123;                logger.warn(<span class="hljs-string">"Error calling HystrixCommandExecutionHook.onComplete"</span>, hookEx);            &#125;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-keyword">return</span> executionHook.onEmit(_cmd, afterFirstApplication);            &#125; <span class="hljs-keyword">catch</span> (Throwable hookEx) &#123;                logger.warn(<span class="hljs-string">"Error calling HystrixCommandExecutionHook.onEmit"</span>, hookEx);                <span class="hljs-keyword">return</span> afterFirstApplication;            &#125;        &#125;    &#125;;    <span class="hljs-keyword">final</span> Action0 fireOnCompletedHook = <span class="hljs-keyword">new</span> Action0() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">try</span> &#123;                executionHook.onSuccess(_cmd);            &#125; <span class="hljs-keyword">catch</span> (Throwable hookEx) &#123;                logger.warn(<span class="hljs-string">"Error calling HystrixCommandExecutionHook.onSuccess"</span>, hookEx);            &#125;        &#125;    &#125;;    <span class="hljs-keyword">return</span> Observable.defer(<span class="hljs-keyword">new</span> Func0&lt;Observable&lt;R&gt;&gt;() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> Observable&lt;R&gt; <span class="hljs-title">call</span><span class="hljs-params">()</span> </span>&#123;             <span class="hljs-comment">/* this is a stateful object so can only be used once */</span>            <span class="hljs-keyword">if</span> (!commandState.compareAndSet(CommandState.NOT_STARTED, CommandState.OBSERVABLE_CHAIN_CREATED)) &#123;                IllegalStateException ex = <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"This instance can only be executed once. Please instantiate a new instance."</span>);                <span class="hljs-comment">//TODO make a new error type for this</span>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> HystrixRuntimeException(FailureType.BAD_REQUEST_EXCEPTION, _cmd.getClass(), getLogMessagePrefix() + <span class="hljs-string">" command executed multiple times - this is not permitted."</span>, ex, <span class="hljs-keyword">null</span>);            &#125;            commandStartTimestamp = System.currentTimeMillis();            <span class="hljs-keyword">if</span> (properties.requestLogEnabled().get()) &#123;                <span class="hljs-comment">// log this command execution regardless of what happened</span>                <span class="hljs-keyword">if</span> (currentRequestLog != <span class="hljs-keyword">null</span>) &#123;                    currentRequestLog.addExecutedCommand(_cmd);                &#125;            &#125;            <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> requestCacheEnabled = isRequestCachingEnabled();            <span class="hljs-keyword">final</span> String cacheKey = getCacheKey();            <span class="hljs-comment">/* try from cache first */</span>            <span class="hljs-keyword">if</span> (requestCacheEnabled) &#123;                HystrixCommandResponseFromCache&lt;R&gt; fromCache = (HystrixCommandResponseFromCache&lt;R&gt;) requestCache.get(cacheKey);                <span class="hljs-keyword">if</span> (fromCache != <span class="hljs-keyword">null</span>) &#123;                    isResponseFromCache = <span class="hljs-keyword">true</span>;                    <span class="hljs-keyword">return</span> handleRequestCacheHitAndEmitValues(fromCache, _cmd);                &#125;            &#125;            Observable&lt;R&gt; hystrixObservable =                    Observable.defer(applyHystrixSemantics)                            .map(wrapWithAllOnNextHooks);            Observable&lt;R&gt; afterCache;            <span class="hljs-comment">// put in cache</span>            <span class="hljs-keyword">if</span> (requestCacheEnabled &amp;&amp; cacheKey != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-comment">// wrap it for caching</span>                HystrixCachedObservable&lt;R&gt; toCache = HystrixCachedObservable.from(hystrixObservable, _cmd);                HystrixCommandResponseFromCache&lt;R&gt; fromCache = (HystrixCommandResponseFromCache&lt;R&gt;) requestCache.putIfAbsent(cacheKey, toCache);                <span class="hljs-keyword">if</span> (fromCache != <span class="hljs-keyword">null</span>) &#123;                    <span class="hljs-comment">// another thread beat us so we'll use the cached value instead</span>                    toCache.unsubscribe();                    isResponseFromCache = <span class="hljs-keyword">true</span>;                    <span class="hljs-keyword">return</span> handleRequestCacheHitAndEmitValues(fromCache, _cmd);                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-comment">// we just created an ObservableCommand so we cast and return it</span>                    afterCache = toCache.toObservable();                &#125;            &#125; <span class="hljs-keyword">else</span> &#123;                afterCache = hystrixObservable;            &#125;            <span class="hljs-keyword">return</span> afterCache                    .doOnTerminate(terminateCommandCleanup)     <span class="hljs-comment">// perform cleanup once (either on normal terminal state (this line), or unsubscribe (next line))</span>                    .doOnUnsubscribe(unsubscribeCommandCleanup) <span class="hljs-comment">// perform cleanup once</span>                    .doOnCompleted(fireOnCompletedHook);        &#125;    &#125;);&#125;</code></pre><p>call()方法中会调用applyHystrixSemantics()方法，会通过allowRequest()方法来判断是否允许请求，如果是信号量策略，会调用getExecutionSemaphore()方法拿到信号量，再调用tryAcquire()判断是否超过最大请求数，然后执行executeCommandAndObserve()方法。如果不是信号量策略tryAcquire()方法会直接返回true，然后在executeCommandAndObserve()方法进行判断。不允许或者已超过最大请求数都会走到handleShortCircuitViaFallback()降级方法。降级方法的逻辑与正常方法基本一致，此处不在赘述，唯一不同的是，如果降级方法超过了设置的最大请求数，会直接拒绝请求抛出异常，所以hystrix能够接收的请求数为二倍的最大请求数，超过就会直接拒绝。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Observable&lt;R&gt; <span class="hljs-title">applyHystrixSemantics</span><span class="hljs-params">(<span class="hljs-keyword">final</span> AbstractCommand&lt;R&gt; _cmd)</span> </span>&#123;    <span class="hljs-comment">// mark that we're starting execution on the ExecutionHook</span>    <span class="hljs-comment">// if this hook throws an exception, then a fast-fail occurs with no fallback.  No state is left inconsistent</span>    executionHook.onStart(_cmd);    <span class="hljs-comment">/* determine if we're allowed to execute */</span>    <span class="hljs-keyword">if</span> (circuitBreaker.allowRequest()) &#123;        <span class="hljs-keyword">final</span> TryableSemaphore executionSemaphore = getExecutionSemaphore();        <span class="hljs-keyword">final</span> AtomicBoolean semaphoreHasBeenReleased = <span class="hljs-keyword">new</span> AtomicBoolean(<span class="hljs-keyword">false</span>);        <span class="hljs-keyword">final</span> Action0 singleSemaphoreRelease = <span class="hljs-keyword">new</span> Action0() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-keyword">if</span> (semaphoreHasBeenReleased.compareAndSet(<span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>)) &#123;                    executionSemaphore.release();                &#125;            &#125;        &#125;;        <span class="hljs-keyword">final</span> Action1&lt;Throwable&gt; markExceptionThrown = <span class="hljs-keyword">new</span> Action1&lt;Throwable&gt;() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">(Throwable t)</span> </span>&#123;                eventNotifier.markEvent(HystrixEventType.EXCEPTION_THROWN, commandKey);            &#125;        &#125;;        <span class="hljs-keyword">if</span> (executionSemaphore.tryAcquire()) &#123;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">/* used to track userThreadExecutionTime */</span>                executionResult = executionResult.setInvocationStartTime(System.currentTimeMillis());                <span class="hljs-keyword">return</span> executeCommandAndObserve(_cmd)                        .doOnError(markExceptionThrown)                        .doOnTerminate(singleSemaphoreRelease)                        .doOnUnsubscribe(singleSemaphoreRelease);            &#125; <span class="hljs-keyword">catch</span> (RuntimeException e) &#123;                <span class="hljs-keyword">return</span> Observable.error(e);            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> handleSemaphoreRejectionViaFallback();        &#125;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> handleShortCircuitViaFallback();    &#125;&#125;</code></pre><h3 id="判断是否允许请求"><a href="#判断是否允许请求" class="headerlink" title="判断是否允许请求"></a>判断是否允许请求</h3><p>allowRequest()方法，刚方法首先会判断熔断器是否开启，如果开启就会返回false，如果关闭会调用isOpen()方法判断是否要开启熔断器，最后根据isOpen()方法及allowSingleTest()方法的返回值决定是否允许请求。allowSingleTest()方法用于判断本次请求是否允许，即熔断器半开状态。</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">allowRequest</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 判断熔断器是否开启</span>    <span class="hljs-keyword">if</span> (properties.circuitBreakerForceOpen().get()) &#123;        <span class="hljs-comment">// properties have asked us to force the circuit open so we will allow NO requests</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-comment">// 熔断器关闭，继续判断</span>    <span class="hljs-keyword">if</span> (properties.circuitBreakerForceClosed().get()) &#123;        <span class="hljs-comment">// we still want to allow isOpen() to perform it's calculations so we simulate normal behavior</span>        isOpen();        <span class="hljs-comment">// properties have asked us to ignore errors so we will ignore the results of isOpen and just allow all traffic through</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-keyword">return</span> !isOpen() || allowSingleTest();&#125;</code></pre><h4 id="判断是否开启熔断器"><a href="#判断是否开启熔断器" class="headerlink" title="判断是否开启熔断器"></a>判断是否开启熔断器</h4><p>isOpen()方法首先会根据请求数及错误率决定是否开启熔断器，设置熔断器的状态时使用了cas保证线程安全。</p><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isOpen</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (circuitOpen.get()) &#123;            <span class="hljs-comment">// if we're open we immediately return true and don't bother attempting to 'close' ourself as that is left to allowSingleTest and a subsequent successful test to close</span>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-comment">// we're closed, so let's see if errors have made us so we should trip the circuit open</span>        HealthCounts health = metrics.getHealthCounts();        <span class="hljs-comment">// check if we are past the statisticalWindowVolumeThreshold</span>        <span class="hljs-comment">// 判断请求数</span>        <span class="hljs-keyword">if</span> (health.getTotalRequests() &lt; properties.circuitBreakerRequestVolumeThreshold().get()) &#123;            <span class="hljs-comment">// we are not past the minimum volume threshold for the statisticalWindow so we'll return false immediately and not calculate anything</span>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-comment">// 判断错误率</span>        <span class="hljs-keyword">if</span> (health.getErrorPercentage() &lt; properties.circuitBreakerErrorThresholdPercentage().get()) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// our failure rate is too high, trip the circuit</span>            <span class="hljs-keyword">if</span> (circuitOpen.compareAndSet(<span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>)) &#123;                <span class="hljs-comment">// if the previousValue was false then we want to set the currentTime</span>                circuitOpenedOrLastTestedTime.set(System.currentTimeMillis());                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// How could previousValue be true? If another thread was going through this code at the same time a race-condition could have</span>                <span class="hljs-comment">// caused another thread to set it to true already even though we were in the process of doing the same</span>                <span class="hljs-comment">// In this case, we know the circuit is open, so let the other thread set the currentTime and report back that the circuit is open</span>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;        &#125;    &#125;&#125;</code></pre><h4 id="是否允许本次请求（半开状态）"><a href="#是否允许本次请求（半开状态）" class="headerlink" title="是否允许本次请求（半开状态）"></a>是否允许本次请求（半开状态）</h4><p>allowSingleTest()方法用于判断是否允许本次请求，即熔断器半开状态的判断。该方法首先会判断熔断器的状态，即当前时间是否大于熔断器开启时间+熔断器转为半开状态时间。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">allowSingleTest</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">long</span> timeCircuitOpenedOrWasLastTested = circuitOpenedOrLastTestedTime.get();    <span class="hljs-comment">// 1) if the circuit is open</span>    <span class="hljs-comment">// 2) and it's been longer than 'sleepWindow' since we opened the circuit</span>    <span class="hljs-keyword">if</span> (circuitOpen.get() &amp;&amp; System.currentTimeMillis() &gt; timeCircuitOpenedOrWasLastTested + properties.circuitBreakerSleepWindowInMilliseconds().get()) &#123;        <span class="hljs-comment">// We push the 'circuitOpenedTime' ahead by 'sleepWindow' since we have allowed one request to try.</span>        <span class="hljs-comment">// If it succeeds the circuit will be closed, otherwise another singleTest will be allowed at the end of the 'sleepWindow'.</span>        <span class="hljs-keyword">if</span> (circuitOpenedOrLastTestedTime.compareAndSet(timeCircuitOpenedOrWasLastTested, System.currentTimeMillis())) &#123;            <span class="hljs-comment">// if this returns true that means we set the time so we'll return true to allow the singleTest</span>            <span class="hljs-comment">// if it returned false it means another thread raced us and allowed the singleTest before we did</span>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;</code></pre><h3 id="判断最大请求数"><a href="#判断最大请求数" class="headerlink" title="判断最大请求数"></a>判断最大请求数</h3><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> currentCount = count.incrementAndGet();    <span class="hljs-keyword">if</span> (currentCount &gt; numberOfPermits.get()) &#123;        count.decrementAndGet();        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;&#125;</code></pre><h3 id="业务方法的执行"><a href="#业务方法的执行" class="headerlink" title="业务方法的执行"></a>业务方法的执行</h3><p>主要是通过executeCommandAndObserve()方法中注册的匿名内部类完成的，包括超时时间的判断，线程数的判断，还有具体的业务方法执行。</p><h4 id="超时时间及线程数的判断"><a href="#超时时间及线程数的判断" class="headerlink" title="超时时间及线程数的判断"></a>超时时间及线程数的判断</h4><p>executeCommandAndObserve()中创建HystrixObservableTimeoutOperator类，并调用其call()方法，该方法会创建一个TimeListener并设置超时时间，然后调用addTimerListener()方法创建线程。</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> Subscriber&lt;? <span class="hljs-keyword">super</span> R&gt; call(<span class="hljs-keyword">final</span> Subscriber&lt;? <span class="hljs-keyword">super</span> R&gt; child) &#123;    <span class="hljs-keyword">final</span> CompositeSubscription s = <span class="hljs-keyword">new</span> CompositeSubscription();    <span class="hljs-comment">// if the child unsubscribes we unsubscribe our parent as well</span>    child.add(s);    <span class="hljs-comment">/*</span><span class="hljs-comment">     * Define the action to perform on timeout outside of the TimerListener to it can capture the HystrixRequestContext</span><span class="hljs-comment">     * of the calling thread which doesn't exist on the Timer thread.</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">final</span> HystrixContextRunnable timeoutRunnable = <span class="hljs-keyword">new</span> HystrixContextRunnable(originalCommand.concurrencyStrategy, <span class="hljs-keyword">new</span> Runnable() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            child.onError(<span class="hljs-keyword">new</span> HystrixTimeoutException());        &#125;    &#125;);    TimerListener listener = <span class="hljs-keyword">new</span> TimerListener() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tick</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-comment">// if we can go from NOT_EXECUTED to TIMED_OUT then we do the timeout codepath</span>            <span class="hljs-comment">// otherwise it means we lost a race and the run() execution completed or did not start</span>            <span class="hljs-keyword">if</span> (originalCommand.isCommandTimedOut.compareAndSet(TimedOutStatus.NOT_EXECUTED, TimedOutStatus.TIMED_OUT)) &#123;                <span class="hljs-comment">// report timeout failure</span>                originalCommand.eventNotifier.markEvent(HystrixEventType.TIMEOUT, originalCommand.commandKey);                <span class="hljs-comment">// shut down the original request</span>                s.unsubscribe();                timeoutRunnable.run();                <span class="hljs-comment">//if it did not start, then we need to mark a command start for concurrency metrics, and then issue the timeout</span>            &#125;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getIntervalTimeInMilliseconds</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> originalCommand.properties.executionTimeoutInMilliseconds().get();        &#125;    &#125;;    <span class="hljs-keyword">final</span> Reference&lt;TimerListener&gt; tl = HystrixTimer.getInstance().addTimerListener(listener);    <span class="hljs-comment">// set externally so execute/queue can see this</span>    originalCommand.timeoutTimer.set(tl);    <span class="hljs-comment">/**</span><span class="hljs-comment">     * If this subscriber receives values it means the parent succeeded/completed</span><span class="hljs-comment">     */</span>    Subscriber&lt;R&gt; parent = <span class="hljs-keyword">new</span> Subscriber&lt;R&gt;() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCompleted</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">if</span> (isNotTimedOut()) &#123;                <span class="hljs-comment">// stop timer and pass notification through</span>                tl.clear();                child.onCompleted();            &#125;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable e)</span> </span>&#123;            <span class="hljs-keyword">if</span> (isNotTimedOut()) &#123;                <span class="hljs-comment">// stop timer and pass notification through</span>                tl.clear();                child.onError(e);            &#125;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(R v)</span> </span>&#123;            <span class="hljs-keyword">if</span> (isNotTimedOut()) &#123;                child.onNext(v);            &#125;        &#125;        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isNotTimedOut</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-comment">// if already marked COMPLETED (by onNext) or succeeds in setting to COMPLETED</span>            <span class="hljs-keyword">return</span> originalCommand.isCommandTimedOut.get() == TimedOutStatus.COMPLETED ||                    originalCommand.isCommandTimedOut.compareAndSet(TimedOutStatus.NOT_EXECUTED, TimedOutStatus.COMPLETED);        &#125;    &#125;;    <span class="hljs-comment">// if s is unsubscribed we want to unsubscribe the parent</span>    s.add(parent);    <span class="hljs-keyword">return</span> parent;&#125;</code></pre><p>addTimerListener()方法主要是获取到配置的线程池然后创建线程。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Reference&lt;TimerListener&gt; <span class="hljs-title">addTimerListener</span><span class="hljs-params">(<span class="hljs-keyword">final</span> TimerListener listener)</span> </span>&#123;    startThreadIfNeeded();    <span class="hljs-comment">// add the listener</span>    Runnable r = <span class="hljs-keyword">new</span> Runnable() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">try</span> &#123;                listener.tick();            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                logger.error(<span class="hljs-string">"Failed while ticking TimerListener"</span>, e);            &#125;        &#125;    &#125;;    ScheduledFuture&lt;?&gt; f = executor.get().getThreadPool().scheduleAtFixedRate(r, listener.getIntervalTimeInMilliseconds(), listener.getIntervalTimeInMilliseconds(), TimeUnit.MILLISECONDS);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TimerReference(listener, f);&#125;</code></pre><h4 id="业务方法的执行-1"><a href="#业务方法的执行-1" class="headerlink" title="业务方法的执行"></a>业务方法的执行</h4><p>executeCommandWithSpecifiedIsolation()方法</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Observable&lt;R&gt; <span class="hljs-title">executeCommandWithSpecifiedIsolation</span><span class="hljs-params">(<span class="hljs-keyword">final</span> AbstractCommand&lt;R&gt; _cmd)</span> </span>&#123;    <span class="hljs-keyword">if</span> (properties.executionIsolationStrategy().get() == ExecutionIsolationStrategy.THREAD) &#123;        <span class="hljs-comment">// mark that we are executing in a thread (even if we end up being rejected we still were a THREAD execution and not SEMAPHORE)</span>        <span class="hljs-keyword">return</span> Observable.defer(<span class="hljs-keyword">new</span> Func0&lt;Observable&lt;R&gt;&gt;() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> Observable&lt;R&gt; <span class="hljs-title">call</span><span class="hljs-params">()</span> </span>&#123;                executionResult = executionResult.setExecutionOccurred();                <span class="hljs-keyword">if</span> (!commandState.compareAndSet(CommandState.OBSERVABLE_CHAIN_CREATED, CommandState.USER_CODE_EXECUTED)) &#123;                    <span class="hljs-keyword">return</span> Observable.error(<span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"execution attempted while in state : "</span> + commandState.get().name()));                &#125;                metrics.markCommandStart(commandKey, threadPoolKey, ExecutionIsolationStrategy.THREAD);                <span class="hljs-keyword">if</span> (isCommandTimedOut.get() == TimedOutStatus.TIMED_OUT) &#123;                    <span class="hljs-comment">// the command timed out in the wrapping thread so we will return immediately</span>                    <span class="hljs-comment">// and not increment any of the counters below or other such logic</span>                    <span class="hljs-keyword">return</span> Observable.error(<span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"timed out before executing run()"</span>));                &#125;                <span class="hljs-keyword">if</span> (threadState.compareAndSet(ThreadState.NOT_USING_THREAD, ThreadState.STARTED)) &#123;                    <span class="hljs-comment">//we have not been unsubscribed, so should proceed</span>                    HystrixCounters.incrementGlobalConcurrentThreads();                    threadPool.markThreadExecution();                    <span class="hljs-comment">// store the command that is being run</span>                    endCurrentThreadExecutingCommand = Hystrix.startCurrentThreadExecutingCommand(getCommandKey());                    executionResult = executionResult.setExecutedInThread();                    <span class="hljs-comment">/**</span><span class="hljs-comment">                     * If any of these hooks throw an exception, then it appears as if the actual execution threw an error</span><span class="hljs-comment">                     */</span>                    <span class="hljs-keyword">try</span> &#123;                        executionHook.onThreadStart(_cmd);                        executionHook.onRunStart(_cmd);                        executionHook.onExecutionStart(_cmd);                        <span class="hljs-keyword">return</span> getUserExecutionObservable(_cmd);                    &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;                        <span class="hljs-keyword">return</span> Observable.error(ex);                    &#125;                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-comment">//command has already been unsubscribed, so return immediately</span>                    <span class="hljs-keyword">return</span> Observable.error(<span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"unsubscribed before executing run()"</span>));                &#125;            &#125;        &#125;).doOnTerminate(<span class="hljs-keyword">new</span> Action0() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-keyword">if</span> (threadState.compareAndSet(ThreadState.STARTED, ThreadState.TERMINAL)) &#123;                    handleThreadEnd(_cmd);                &#125;                <span class="hljs-keyword">if</span> (threadState.compareAndSet(ThreadState.NOT_USING_THREAD, ThreadState.TERMINAL)) &#123;                    <span class="hljs-comment">//if it was never started and received terminal, then no need to clean up (I don't think this is possible)</span>                &#125;                <span class="hljs-comment">//if it was unsubscribed, then other cleanup handled it</span>            &#125;        &#125;).doOnUnsubscribe(<span class="hljs-keyword">new</span> Action0() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-keyword">if</span> (threadState.compareAndSet(ThreadState.STARTED, ThreadState.UNSUBSCRIBED)) &#123;                    handleThreadEnd(_cmd);                &#125;                <span class="hljs-keyword">if</span> (threadState.compareAndSet(ThreadState.NOT_USING_THREAD, ThreadState.UNSUBSCRIBED)) &#123;                    <span class="hljs-comment">//if it was never started and was cancelled, then no need to clean up</span>                &#125;                <span class="hljs-comment">//if it was terminal, then other cleanup handled it</span>            &#125;        &#125;).subscribeOn(threadPool.getScheduler(<span class="hljs-keyword">new</span> Func0&lt;Boolean&gt;() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">call</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-keyword">return</span> properties.executionIsolationThreadInterruptOnTimeout().get() &amp;&amp; _cmd.isCommandTimedOut.get() == TimedOutStatus.TIMED_OUT;            &#125;        &#125;));    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> Observable.defer(<span class="hljs-keyword">new</span> Func0&lt;Observable&lt;R&gt;&gt;() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> Observable&lt;R&gt; <span class="hljs-title">call</span><span class="hljs-params">()</span> </span>&#123;                executionResult = executionResult.setExecutionOccurred();                <span class="hljs-keyword">if</span> (!commandState.compareAndSet(CommandState.OBSERVABLE_CHAIN_CREATED, CommandState.USER_CODE_EXECUTED)) &#123;                    <span class="hljs-keyword">return</span> Observable.error(<span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"execution attempted while in state : "</span> + commandState.get().name()));                &#125;                metrics.markCommandStart(commandKey, threadPoolKey, ExecutionIsolationStrategy.SEMAPHORE);                <span class="hljs-comment">// semaphore isolated</span>                <span class="hljs-comment">// store the command that is being run</span>                endCurrentThreadExecutingCommand = Hystrix.startCurrentThreadExecutingCommand(getCommandKey());                <span class="hljs-keyword">try</span> &#123;                    executionHook.onRunStart(_cmd);                    executionHook.onExecutionStart(_cmd);                    <span class="hljs-keyword">return</span> getUserExecutionObservable(_cmd);  <span class="hljs-comment">//the getUserExecutionObservable method already wraps sync exceptions, so this shouldn't throw</span>                &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;                    <span class="hljs-comment">//If the above hooks throw, then use that as the result of the run method</span>                    <span class="hljs-keyword">return</span> Observable.error(ex);                &#125;            &#125;        &#125;);    &#125;&#125;</code></pre><p>getUserExecutionObservable()</p><p>该方法最终会调用到HystrixCommand的getExecutionObservable()方法，该方法会调用到HystrixCommand中run()方法，该方法是比较重要的一个钩子方法。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">protected</span> Observable&lt;R&gt; <span class="hljs-title">getExecutionObservable</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> Observable.defer(<span class="hljs-keyword">new</span> Func0&lt;Observable&lt;R&gt;&gt;() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> Observable&lt;R&gt; <span class="hljs-title">call</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-keyword">return</span> Observable.just(run());            &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;                <span class="hljs-keyword">return</span> Observable.error(ex);            &#125;        &#125;    &#125;).doOnSubscribe(<span class="hljs-keyword">new</span> Action0() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-comment">// Save thread on which we get subscribed so that we can interrupt it later if needed</span>            executionThread.set(Thread.currentThread());        &#125;    &#125;);&#125;</code></pre><p>run()方法会调用到GenericCommand的run()方法，该方法最终会通过反射调用到业务方法。</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    LOGGER.debug(<span class="hljs-string">"execute command: &#123;&#125;"</span>, getCommandKey().name());    <span class="hljs-keyword">return</span> process(<span class="hljs-keyword">new</span> Action() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function">Object <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> getCommandAction().execute(getExecutionType());        &#125;    &#125;);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>SpringCloud源码解析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>源码解读</tag>
      
      <tag>springcloud</tag>
      
      <tag>hystrix</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ribbon源码解读</title>
    <link href="/blog/2020/04/27/springcloud-ribbon%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <url>/blog/2020/04/27/springcloud-ribbon%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="ribbon基础类的注册"><a href="#ribbon基础类的注册" class="headerlink" title="ribbon基础类的注册"></a>ribbon基础类的注册</h2><p>spring-cloud-netflix-ribbon-2.2.2.RELEASE.jar类的spring.factories会引入RibbonAutoConfiguration类，该类会创建两个比较重要的点：LoadBanlancerClient跟SpringClientFactory，configurations属性也需要注意下。</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@Conditional</span>(RibbonAutoConfiguration.RibbonClassesConditions<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">@<span class="hljs-title">RibbonClients</span></span><span class="hljs-class">@<span class="hljs-title">AutoConfigureAfter</span>(</span><span class="hljs-class"><span class="hljs-title">name</span> </span>= <span class="hljs-string">"org.springframework.cloud.netflix.eureka.EurekaClientAutoConfiguration"</span>)<span class="hljs-meta">@AutoConfigureBefore</span>(&#123; LoadBalancerAutoConfiguration<span class="hljs-class">.<span class="hljs-keyword">class</span>,</span><span class="hljs-class"><span class="hljs-title">AsyncLoadBalancerAutoConfiguration</span>.<span class="hljs-title">class</span> &#125;)</span><span class="hljs-class">@<span class="hljs-title">EnableConfigurationProperties</span>(</span>&#123; RibbonEagerLoadProperties<span class="hljs-class">.<span class="hljs-keyword">class</span>,</span><span class="hljs-class"><span class="hljs-title">ServerIntrospectorProperties</span>.<span class="hljs-title">class</span> &#125;)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">RibbonAutoConfiguration</span> </span>&#123;<span class="hljs-meta">@Autowired</span>(required = <span class="hljs-keyword">false</span>)<span class="hljs-keyword">private</span> List&lt;RibbonClientSpecification&gt; configurations = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<span class="hljs-meta">@Autowired</span><span class="hljs-keyword">private</span> RibbonEagerLoadProperties ribbonEagerLoadProperties;<span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> HasFeatures <span class="hljs-title">ribbonFeature</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> HasFeatures.namedFeature(<span class="hljs-string">"Ribbon"</span>, Ribbon<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;&#125;<span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> SpringClientFactory <span class="hljs-title">springClientFactory</span><span class="hljs-params">()</span> </span>&#123;SpringClientFactory factory = <span class="hljs-keyword">new</span> SpringClientFactory();factory.setConfigurations(<span class="hljs-keyword">this</span>.configurations);<span class="hljs-keyword">return</span> factory;&#125;<span class="hljs-meta">@Bean</span><span class="hljs-meta">@ConditionalOnMissingBean</span>(LoadBalancerClient<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">LoadBalancerClient</span> <span class="hljs-title">loadBalancerClient</span>() </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RibbonLoadBalancerClient(springClientFactory());&#125;  &#123;...&#125;&#125;</code></pre><p>spring-cloud-commons-2.2.2.RELEASE.jar的spring.factores会引入一个比较重要的类：LoadBalancerAutoConfiguration，LoadBalancerAutoConfiguration类的restTemplateCustomizer()方法会设置拦截器到restTemplate中。</p><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-meta">@ConditionalOnMissingBean</span><span class="hljs-function"><span class="hljs-keyword">public</span> RestTemplateCustomizer <span class="hljs-title">restTemplateCustomizer</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">      <span class="hljs-keyword">final</span> LoadBalancerInterceptor loadBalancerInterceptor)</span> </span>&#123;   <span class="hljs-keyword">return</span> restTemplate -&gt; &#123;      List&lt;ClientHttpRequestInterceptor&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(            restTemplate.getInterceptors());      list.add(loadBalancerInterceptor);      restTemplate.setInterceptors(list);   &#125;;&#125;</code></pre><h2 id="RestTemplate的主流程"><a href="#RestTemplate的主流程" class="headerlink" title="RestTemplate的主流程"></a>RestTemplate的主流程</h2><p>RestTemplate中的execute方法首先会调用到InterceptingClientHttpRequest类中的execute()方法，该方法首先会调用restTemplate中的拦截器的intercept()方法。</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> ClientHttpResponse <span class="hljs-title">execute</span><span class="hljs-params">(HttpRequest request, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.iterator.hasNext()) &#123;      ClientHttpRequestInterceptor nextInterceptor = <span class="hljs-keyword">this</span>.iterator.next();      <span class="hljs-keyword">return</span> nextInterceptor.intercept(request, body, <span class="hljs-keyword">this</span>);   &#125;   <span class="hljs-keyword">else</span> &#123;      HttpMethod method = request.getMethod();      Assert.state(method != <span class="hljs-keyword">null</span>, <span class="hljs-string">"No standard HTTP method"</span>);      ClientHttpRequest delegate = requestFactory.createRequest(request.getURI(), method);      request.getHeaders().forEach((key, value) -&gt; delegate.getHeaders().addAll(key, value));      <span class="hljs-keyword">if</span> (body.length &gt; <span class="hljs-number">0</span>) &#123;         <span class="hljs-keyword">if</span> (delegate <span class="hljs-keyword">instanceof</span> StreamingHttpOutputMessage) &#123;            StreamingHttpOutputMessage streamingOutputMessage = (StreamingHttpOutputMessage) delegate;            streamingOutputMessage.setBody(outputStream -&gt; StreamUtils.copy(body, outputStream));         &#125;         <span class="hljs-keyword">else</span> &#123;            StreamUtils.copy(body, delegate.getBody());         &#125;      &#125;      <span class="hljs-keyword">return</span> delegate.execute();   &#125;&#125;</code></pre><p>intercept()方法会调用createRequest()方法创建获取到服务之后的调用的request对象。</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> ClientHttpResponse <span class="hljs-title">intercept</span><span class="hljs-params">(<span class="hljs-keyword">final</span> HttpRequest request, <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span>[] body,</span></span><span class="hljs-function"><span class="hljs-params">      <span class="hljs-keyword">final</span> ClientHttpRequestExecution execution)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;   <span class="hljs-keyword">final</span> URI originalUri = request.getURI();   String serviceName = originalUri.getHost();   Assert.state(serviceName != <span class="hljs-keyword">null</span>,         <span class="hljs-string">"Request URI does not contain a valid hostname: "</span> + originalUri);   <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.loadBalancer.execute(serviceName,         <span class="hljs-keyword">this</span>.requestFactory.createRequest(request, body, execution));&#125;</code></pre><p>intercept()方法会调用到RibbonLoadBalancerClient的execute()方法，RibbonLoadBalancerClient已经在RibbonAutoConfiguration中已经通过@Bean的方式注入。该方法会调用getLoadBalancer()方法获取到服务列表，然后调用getServer()方法获取到要调用的服务。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">execute</span><span class="hljs-params">(String serviceId, LoadBalancerRequest&lt;T&gt; request, Object hint)</span></span><span class="hljs-function">      <span class="hljs-keyword">throws</span> IOException </span>&#123;   ILoadBalancer loadBalancer = getLoadBalancer(serviceId);   Server server = getServer(loadBalancer, hint);   <span class="hljs-keyword">if</span> (server == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"No instances available for "</span> + serviceId);   &#125;   RibbonServer ribbonServer = <span class="hljs-keyword">new</span> RibbonServer(serviceId, server,         isSecure(server, serviceId),         serverIntrospector(serviceId).getMetadata(server));   <span class="hljs-keyword">return</span> execute(serviceId, ribbonServer, request);&#125;</code></pre><p>该方法会由execute()方法调用，用于获取到服务之后会进行reqeust的回调。</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">execute</span><span class="hljs-params">(String serviceId, ServiceInstance serviceInstance,</span></span><span class="hljs-function"><span class="hljs-params">      LoadBalancerRequest&lt;T&gt; request)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;   Server server = <span class="hljs-keyword">null</span>;   <span class="hljs-keyword">if</span> (serviceInstance <span class="hljs-keyword">instanceof</span> RibbonServer) &#123;      server = ((RibbonServer) serviceInstance).getServer();   &#125;   <span class="hljs-keyword">if</span> (server == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"No instances available for "</span> + serviceId);   &#125;   RibbonLoadBalancerContext context = <span class="hljs-keyword">this</span>.clientFactory         .getLoadBalancerContext(serviceId);   RibbonStatsRecorder statsRecorder = <span class="hljs-keyword">new</span> RibbonStatsRecorder(context, server);   <span class="hljs-keyword">try</span> &#123;      T returnVal = request.apply(serviceInstance);      statsRecorder.recordStats(returnVal);      <span class="hljs-keyword">return</span> returnVal;   &#125;   <span class="hljs-comment">// catch IOException and rethrow so RestTemplate behaves correctly</span>   <span class="hljs-keyword">catch</span> (IOException ex) &#123;      statsRecorder.recordStats(ex);      <span class="hljs-keyword">throw</span> ex;   &#125;   <span class="hljs-keyword">catch</span> (Exception ex) &#123;      statsRecorder.recordStats(ex);      ReflectionUtils.rethrowRuntimeException(ex);   &#125;   <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre><h3 id="获取服务列表"><a href="#获取服务列表" class="headerlink" title="获取服务列表"></a>获取服务列表</h3><p>intercept()方法会调用getLoadBalancer()方法获取ILoadBalancer类型的实例，getLoadBalancer()方法会调用clientFactory的getLoadBalancer()方法，clientFactory已经在RibbonAutoConfiguration中已经通过@Bean的方式注入。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> ILoadBalancer <span class="hljs-title">getLoadBalancer</span><span class="hljs-params">(String serviceId)</span> </span>&#123;   <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.clientFactory.getLoadBalancer(serviceId);&#125;</code></pre><p>getLoadBalancer()会调用getInstance()方法，该方法根据服务名称创建一个容器，然后把容器跟服务名称放入缓存，所以ribbon在第一次服务名称调用的时候是比较慢的，涉及到创建容器过程，第二次就直接从缓存里面拿容器对象了。这里在调用的时候获取容器的目的是为了拿到最新的服务列表。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getInstance</span><span class="hljs-params">(String name, Class&lt;T&gt; type)</span> </span>&#123;   AnnotationConfigApplicationContext context = getContext(name);   <span class="hljs-keyword">if</span> (BeanFactoryUtils.beanNamesForTypeIncludingAncestors(context,         type).length &gt; <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">return</span> context.getBean(type);   &#125;   <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre><p>getInstance()方法会调用getContext()方法。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> AnnotationConfigApplicationContext <span class="hljs-title">getContext</span><span class="hljs-params">(String name)</span> </span>&#123;   <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.contexts.containsKey(name)) &#123;      <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.contexts) &#123;         <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.contexts.containsKey(name)) &#123;            <span class="hljs-keyword">this</span>.contexts.put(name, createContext(name));         &#125;      &#125;   &#125;   <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.contexts.get(name);&#125;</code></pre><p>如果不存在context就会调用createContext()方法创建容器，并加载两个比较重要的类EurekaRibbonClientConfiguration跟RibbonClientConfiguration到容器中，然后触发这两个类重新获取服务列表。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> AnnotationConfigApplicationContext <span class="hljs-title">createContext</span><span class="hljs-params">(String name)</span> </span>&#123;   AnnotationConfigApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext();   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.configurations.containsKey(name)) &#123;      <span class="hljs-keyword">for</span> (Class&lt;?&gt; configuration : <span class="hljs-keyword">this</span>.configurations.get(name)            .getConfiguration()) &#123;         context.register(configuration);      &#125;   &#125;   <span class="hljs-keyword">for</span> (Map.Entry&lt;String, C&gt; entry : <span class="hljs-keyword">this</span>.configurations.entrySet()) &#123;      <span class="hljs-keyword">if</span> (entry.getKey().startsWith(<span class="hljs-string">"default."</span>)) &#123;         <span class="hljs-keyword">for</span> (Class&lt;?&gt; configuration : entry.getValue().getConfiguration()) &#123;            context.register(configuration);         &#125;      &#125;   &#125;   context.register(PropertyPlaceholderAutoConfiguration<span class="hljs-class">.<span class="hljs-keyword">class</span>,</span><span class="hljs-class">         <span class="hljs-title">this</span>.<span class="hljs-title">defaultConfigType</span>)</span>;   context.getEnvironment().getPropertySources().addFirst(<span class="hljs-keyword">new</span> MapPropertySource(         <span class="hljs-keyword">this</span>.propertySourceName,         Collections.&lt;String, Object&gt;singletonMap(<span class="hljs-keyword">this</span>.propertyName, name)));   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.parent != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-comment">// Uses Environment from parent as well as beans</span>      context.setParent(<span class="hljs-keyword">this</span>.parent);      <span class="hljs-comment">// jdk11 issue</span>      <span class="hljs-comment">// https://github.com/spring-cloud/spring-cloud-netflix/issues/3101</span>      context.setClassLoader(<span class="hljs-keyword">this</span>.parent.getClassLoader());   &#125;   context.setDisplayName(generateDisplayName(name));   context.refresh();   <span class="hljs-keyword">return</span> context;&#125;</code></pre><h4 id="EurekaRibbonClientConfiguration类"><a href="#EurekaRibbonClientConfiguration类" class="headerlink" title="EurekaRibbonClientConfiguration类"></a>EurekaRibbonClientConfiguration类</h4><p>EurekaRibbonClientConfiguration的ribbonServerList()方法会创建服务列表</p><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-meta">@ConditionalOnMissingBean</span><span class="hljs-keyword">public</span> ServerList&lt;?&gt; ribbonServerList(IClientConfig config,      Provider&lt;EurekaClient&gt; eurekaClientProvider) &#123;   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.propertiesFactory.isSet(ServerList<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">serviceId</span>)) </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.propertiesFactory.get(ServerList<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">config</span>, <span class="hljs-title">serviceId</span>)</span>;   &#125;   DiscoveryEnabledNIWSServerList discoveryServerList = <span class="hljs-keyword">new</span> DiscoveryEnabledNIWSServerList(         config, eurekaClientProvider);   DomainExtractingServerList serverList = <span class="hljs-keyword">new</span> DomainExtractingServerList(         discoveryServerList, config, <span class="hljs-keyword">this</span>.approximateZoneFromHostname);   <span class="hljs-keyword">return</span> serverList;&#125;</code></pre><p>DiscoveryEnabledNIWSServerList类会在ribbonServerList()方法中创建，该类中有一个特别重要的方法getInitialListOfServers()。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;DiscoveryEnabledServer&gt; <span class="hljs-title">getInitialListOfServers</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.obtainServersViaDiscovery();&#125;</code></pre><p>getInitialListOfServers()方法会调用obtainServersViaDiscovery()方法</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;DiscoveryEnabledServer&gt; <span class="hljs-title">obtainServersViaDiscovery</span><span class="hljs-params">()</span> </span>&#123;    List&lt;DiscoveryEnabledServer&gt; serverList = <span class="hljs-keyword">new</span> ArrayList();    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.eurekaClientProvider != <span class="hljs-keyword">null</span> &amp;&amp; <span class="hljs-keyword">this</span>.eurekaClientProvider.get() != <span class="hljs-keyword">null</span>) &#123;        EurekaClient eurekaClient = (EurekaClient)<span class="hljs-keyword">this</span>.eurekaClientProvider.get();        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.vipAddresses != <span class="hljs-keyword">null</span>) &#123;            String[] var3 = <span class="hljs-keyword">this</span>.vipAddresses.split(<span class="hljs-string">","</span>);            <span class="hljs-keyword">int</span> var4 = var3.length;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> var5 = <span class="hljs-number">0</span>; var5 &lt; var4; ++var5) &#123;                String vipAddress = var3[var5];                List&lt;InstanceInfo&gt; listOfInstanceInfo = eurekaClient.getInstancesByVipAddress(vipAddress, <span class="hljs-keyword">this</span>.isSecure, <span class="hljs-keyword">this</span>.targetRegion);                Iterator var8 = listOfInstanceInfo.iterator();                <span class="hljs-keyword">while</span>(var8.hasNext()) &#123;                    InstanceInfo ii = (InstanceInfo)var8.next();                    <span class="hljs-keyword">if</span> (ii.getStatus().equals(InstanceStatus.UP)) &#123;                        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.shouldUseOverridePort) &#123;                            <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;                                logger.debug(<span class="hljs-string">"Overriding port on client name: "</span> + <span class="hljs-keyword">this</span>.clientName + <span class="hljs-string">" to "</span> + <span class="hljs-keyword">this</span>.overridePort);                            &#125;                            InstanceInfo copy = <span class="hljs-keyword">new</span> InstanceInfo(ii);                            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isSecure) &#123;                                ii = (<span class="hljs-keyword">new</span> Builder(copy)).setSecurePort(<span class="hljs-keyword">this</span>.overridePort).build();                            &#125; <span class="hljs-keyword">else</span> &#123;                                ii = (<span class="hljs-keyword">new</span> Builder(copy)).setPort(<span class="hljs-keyword">this</span>.overridePort).build();                            &#125;                        &#125;                        DiscoveryEnabledServer des = <span class="hljs-keyword">this</span>.createServer(ii, <span class="hljs-keyword">this</span>.isSecure, <span class="hljs-keyword">this</span>.shouldUseIpAddr);                        serverList.add(des);                    &#125;                &#125;                <span class="hljs-keyword">if</span> (serverList.size() &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-keyword">this</span>.prioritizeVipAddressBasedServers) &#123;                    <span class="hljs-keyword">break</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> serverList;    &#125; <span class="hljs-keyword">else</span> &#123;        logger.warn(<span class="hljs-string">"EurekaClient has not been initialized yet, returning an empty list"</span>);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList();    &#125;&#125;</code></pre><p>obtainServersViaDiscovery()方法会调用getInstancesByVipAddress()方法，该方法会从localRegionApps中或eureka服务端拉取到的服务列表的变量中获取到服务列表。localRegionApps中的服务列表来源于eureka客户端源码中的服务拉取部分。</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;InstanceInfo&gt; <span class="hljs-title">getInstancesByVipAddress</span><span class="hljs-params">(String vipAddress, <span class="hljs-keyword">boolean</span> secure,</span></span><span class="hljs-function"><span class="hljs-params">                                                   @Nullable String region)</span> </span>&#123;    <span class="hljs-keyword">if</span> (vipAddress == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(                <span class="hljs-string">"Supplied VIP Address cannot be null"</span>);    &#125;    Applications applications;    <span class="hljs-keyword">if</span> (instanceRegionChecker.isLocalRegion(region)) &#123;        applications = <span class="hljs-keyword">this</span>.localRegionApps.get();    &#125; <span class="hljs-keyword">else</span> &#123;        applications = remoteRegionVsApps.get(region);        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == applications) &#123;            logger.debug(<span class="hljs-string">"No applications are defined for region &#123;&#125;, so returning an empty instance list for vip "</span>                    + <span class="hljs-string">"address &#123;&#125;."</span>, region, vipAddress);            <span class="hljs-keyword">return</span> Collections.emptyList();        &#125;    &#125;    <span class="hljs-keyword">if</span> (!secure) &#123;        <span class="hljs-keyword">return</span> applications.getInstancesByVirtualHostName(vipAddress);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> applications.getInstancesBySecureVirtualHostName(vipAddress);    &#125;&#125;</code></pre><h4 id="RibbonClientConfiguration类"><a href="#RibbonClientConfiguration类" class="headerlink" title="RibbonClientConfiguration类"></a>RibbonClientConfiguration类</h4><p>这个类中有一个非常重要的方法ribbonLoadBalancer()，该方法会将serverList注入，serverList是从EurekaRibbonClientConfiguration中获取的。</p><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-meta">@ConditionalOnMissingBean</span><span class="hljs-function"><span class="hljs-keyword">public</span> ILoadBalancer <span class="hljs-title">ribbonLoadBalancer</span><span class="hljs-params">(IClientConfig config,</span></span><span class="hljs-function"><span class="hljs-params">      ServerList&lt;Server&gt; serverList, ServerListFilter&lt;Server&gt; serverListFilter,</span></span><span class="hljs-function"><span class="hljs-params">      IRule rule, IPing ping, ServerListUpdater serverListUpdater)</span> </span>&#123;   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.propertiesFactory.isSet(ILoadBalancer<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">name</span>)) </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.propertiesFactory.get(ILoadBalancer<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">config</span>, <span class="hljs-title">name</span>)</span>;   &#125;   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ZoneAwareLoadBalancer&lt;&gt;(config, rule, ping, serverList,         serverListFilter, serverListUpdater);&#125;</code></pre><p>ribbonLoadBalancer()方法获取到的实例就是ZoneAwareLoadBalancer实例。在该类实例化的构造函数中，最终会调到其父类的构造函数。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DynamicServerListLoadBalancer</span><span class="hljs-params">(IClientConfig clientConfig, IRule rule, IPing ping,</span></span><span class="hljs-function"><span class="hljs-params">                                     ServerList&lt;T&gt; serverList, ServerListFilter&lt;T&gt; filter,</span></span><span class="hljs-function"><span class="hljs-params">                                     ServerListUpdater serverListUpdater)</span> </span>&#123;    <span class="hljs-keyword">super</span>(clientConfig, rule, ping);    <span class="hljs-keyword">this</span>.serverListImpl = serverList;    <span class="hljs-keyword">this</span>.filter = filter;    <span class="hljs-keyword">this</span>.serverListUpdater = serverListUpdater;    <span class="hljs-keyword">if</span> (filter <span class="hljs-keyword">instanceof</span> AbstractServerListFilter) &#123;        ((AbstractServerListFilter) filter).setLoadBalancerStats(getLoadBalancerStats());    &#125;    restOfInit(clientConfig);&#125;</code></pre><p>restOfInit()方法会在构造函数中被调用。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">restOfInit</span><span class="hljs-params">(IClientConfig clientConfig)</span> </span>&#123;    <span class="hljs-keyword">boolean</span> primeConnection = <span class="hljs-keyword">this</span>.isEnablePrimingConnections();    <span class="hljs-comment">// turn this off to avoid duplicated asynchronous priming done in BaseLoadBalancer.setServerList()</span>    <span class="hljs-keyword">this</span>.setEnablePrimingConnections(<span class="hljs-keyword">false</span>);    enableAndInitLearnNewServersFeature();    updateListOfServers();    <span class="hljs-keyword">if</span> (primeConnection &amp;&amp; <span class="hljs-keyword">this</span>.getPrimeConnections() != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">this</span>.getPrimeConnections()                .primeConnections(getReachableServers());    &#125;    <span class="hljs-keyword">this</span>.setEnablePrimingConnections(primeConnection);    LOGGER.info(<span class="hljs-string">"DynamicServerListLoadBalancer for client &#123;&#125; initialized: &#123;&#125;"</span>, clientConfig.getClientName(), <span class="hljs-keyword">this</span>.toString());&#125;</code></pre><p>restOfInit()方法会调用updateListOfServers()方法。</p><pre><code class="hljs java"><span class="hljs-meta">@VisibleForTesting</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateListOfServers</span><span class="hljs-params">()</span> </span>&#123;    List&lt;T&gt; servers = <span class="hljs-keyword">new</span> ArrayList&lt;T&gt;();    <span class="hljs-keyword">if</span> (serverListImpl != <span class="hljs-keyword">null</span>) &#123;        servers = serverListImpl.getUpdatedListOfServers();        LOGGER.debug(<span class="hljs-string">"List of Servers for &#123;&#125; obtained from Discovery client: &#123;&#125;"</span>,                getIdentifier(), servers);        <span class="hljs-keyword">if</span> (filter != <span class="hljs-keyword">null</span>) &#123;            servers = filter.getFilteredListOfServers(servers);            LOGGER.debug(<span class="hljs-string">"Filtered List of Servers for &#123;&#125; obtained from Discovery client: &#123;&#125;"</span>,                    getIdentifier(), servers);        &#125;    &#125;    updateAllServerList(servers);&#125;</code></pre><p>updateListOfServers()调用getUpdatedListOfServers()方法，从本地服务列表中获取到了服务列表信息</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;DiscoveryEnabledServer&gt; <span class="hljs-title">getUpdatedListOfServers</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.obtainServersViaDiscovery();&#125;</code></pre><h3 id="服务选择"><a href="#服务选择" class="headerlink" title="服务选择"></a>服务选择</h3><p>intercept()方法会调用getServer()方法，getServer()方法最终会调用到BaseLoadBalancer中的chooseServer()方法，会根据具体策略中的choose()方法，选择一个服务返回。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Server <span class="hljs-title">chooseServer</span><span class="hljs-params">(Object key)</span> </span>&#123;    <span class="hljs-keyword">if</span> (counter == <span class="hljs-keyword">null</span>) &#123;        counter = createCounter();    &#125;    counter.increment();    <span class="hljs-keyword">if</span> (rule == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">return</span> rule.choose(key);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            logger.warn(<span class="hljs-string">"LoadBalancer [&#123;&#125;]:  Error choosing server for key &#123;&#125;"</span>, name, key, e);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>SpringCloud源码解析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>源码解读</tag>
      
      <tag>springcloud</tag>
      
      <tag>ribbon</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>eureka源码解读</title>
    <link href="/blog/2020/04/27/springcloud-eureka%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <url>/blog/2020/04/27/springcloud-eureka%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="eureka客户端源码解析"><a href="#eureka客户端源码解析" class="headerlink" title="eureka客户端源码解析"></a>eureka客户端源码解析</h2><p>springboot在启动时会通过SPI加载spring.factors</p><pre><code class="hljs properties"><span class="hljs-meta">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="hljs-string">\</span>org.springframework.cloud.netflix.eureka.config.EurekaClientConfigServerAutoConfiguration,\org.springframework.cloud.netflix.eureka.config.EurekaDiscoveryClientConfigServiceAutoConfiguration,\org.springframework.cloud.netflix.eureka.EurekaClientAutoConfiguration,\org.springframework.cloud.netflix.ribbon.eureka.RibbonEurekaAutoConfiguration,\org.springframework.cloud.netflix.eureka.EurekaDiscoveryClientConfiguration,\org.springframework.cloud.netflix.eureka.reactive.EurekaReactiveDiscoveryClientConfiguration,\<span class="hljs-attr">org.springframework.cloud.netflix.eureka.loadbalancer.LoadBalancerEurekaAutoConfiguration</span><span class="hljs-meta">org.springframework.cloud.bootstrap.BootstrapConfiguration</span>=<span class="hljs-string">\</span><span class="hljs-attr">org.springframework.cloud.netflix.eureka.config.EurekaDiscoveryClientConfigServiceBootstrapConfiguration</span></code></pre><p>其中的EurekaClientAutoConfiguration类有一个静态内部类EurekaClientConfiguration，EurekaClientConfiguration中的eurekaClient方法会创建一个CloudEurekaClient类。其构造方法如下：</p><pre><code class="hljs java"><span class="hljs-meta">@Bean</span>(destroyMethod = <span class="hljs-string">"shutdown"</span>)<span class="hljs-meta">@ConditionalOnMissingBean</span>(value = EurekaClient<span class="hljs-class">.<span class="hljs-keyword">class</span>,</span><span class="hljs-class">      <span class="hljs-title">search</span> </span>= SearchStrategy.CURRENT)<span class="hljs-function"><span class="hljs-keyword">public</span> EurekaClient <span class="hljs-title">eurekaClient</span><span class="hljs-params">(ApplicationInfoManager manager,</span></span><span class="hljs-function"><span class="hljs-params">      EurekaClientConfig config)</span> </span>&#123;   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CloudEurekaClient(manager, config, <span class="hljs-keyword">this</span>.optionalArgs,         <span class="hljs-keyword">this</span>.context);&#125;</code></pre><p>CloudEurekaClient类继承了DiscoveryClient，这个类是eureka最重要的类，构造方法中会设置三个比较重要的定时器，负责服务注册、续约、拉取，然后调用initScheduledTasks()方法</p><pre><code class="hljs java"><span class="hljs-meta">@Inject</span>DiscoveryClient(ApplicationInfoManager applicationInfoManager, EurekaClientConfig config, AbstractDiscoveryClientOptionalArgs args,                Provider&lt;BackupRegistry&gt; backupRegistryProvider, EndpointRandomizer endpointRandomizer) &#123;    <span class="hljs-keyword">if</span> (args != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">this</span>.healthCheckHandlerProvider = args.healthCheckHandlerProvider;        <span class="hljs-keyword">this</span>.healthCheckCallbackProvider = args.healthCheckCallbackProvider;        <span class="hljs-keyword">this</span>.eventListeners.addAll(args.getEventListeners());        <span class="hljs-keyword">this</span>.preRegistrationHandler = args.preRegistrationHandler;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">this</span>.healthCheckCallbackProvider = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">this</span>.healthCheckHandlerProvider = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">this</span>.preRegistrationHandler = <span class="hljs-keyword">null</span>;    &#125;        <span class="hljs-keyword">this</span>.applicationInfoManager = applicationInfoManager;    InstanceInfo myInfo = applicationInfoManager.getInfo();    clientConfig = config;    staticClientConfig = clientConfig;    transportConfig = config.getTransportConfig();    instanceInfo = myInfo;    <span class="hljs-keyword">if</span> (myInfo != <span class="hljs-keyword">null</span>) &#123;        appPathIdentifier = instanceInfo.getAppName() + <span class="hljs-string">"/"</span> + instanceInfo.getId();    &#125; <span class="hljs-keyword">else</span> &#123;        logger.warn(<span class="hljs-string">"Setting instanceInfo to a passed in null value"</span>);    &#125;    <span class="hljs-keyword">this</span>.backupRegistryProvider = backupRegistryProvider;    <span class="hljs-keyword">this</span>.endpointRandomizer = endpointRandomizer;    <span class="hljs-keyword">this</span>.urlRandomizer = <span class="hljs-keyword">new</span> EndpointUtils.InstanceInfoBasedUrlRandomizer(instanceInfo);    localRegionApps.set(<span class="hljs-keyword">new</span> Applications());    fetchRegistryGeneration = <span class="hljs-keyword">new</span> AtomicLong(<span class="hljs-number">0</span>);    remoteRegionsToFetch = <span class="hljs-keyword">new</span> AtomicReference&lt;String&gt;(clientConfig.fetchRegistryForRemoteRegions());    remoteRegionsRef = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;(remoteRegionsToFetch.get() == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : remoteRegionsToFetch.get().split(<span class="hljs-string">","</span>));    <span class="hljs-keyword">if</span> (config.shouldFetchRegistry()) &#123;        <span class="hljs-keyword">this</span>.registryStalenessMonitor = <span class="hljs-keyword">new</span> ThresholdLevelsMetric(<span class="hljs-keyword">this</span>, METRIC_REGISTRY_PREFIX + <span class="hljs-string">"lastUpdateSec_"</span>, <span class="hljs-keyword">new</span> <span class="hljs-keyword">long</span>[]&#123;<span class="hljs-number">15L</span>, <span class="hljs-number">30L</span>, <span class="hljs-number">60L</span>, <span class="hljs-number">120L</span>, <span class="hljs-number">240L</span>, <span class="hljs-number">480L</span>&#125;);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">this</span>.registryStalenessMonitor = ThresholdLevelsMetric.NO_OP_METRIC;    &#125;    <span class="hljs-keyword">if</span> (config.shouldRegisterWithEureka()) &#123;        <span class="hljs-keyword">this</span>.heartbeatStalenessMonitor = <span class="hljs-keyword">new</span> ThresholdLevelsMetric(<span class="hljs-keyword">this</span>, METRIC_REGISTRATION_PREFIX + <span class="hljs-string">"lastHeartbeatSec_"</span>, <span class="hljs-keyword">new</span> <span class="hljs-keyword">long</span>[]&#123;<span class="hljs-number">15L</span>, <span class="hljs-number">30L</span>, <span class="hljs-number">60L</span>, <span class="hljs-number">120L</span>, <span class="hljs-number">240L</span>, <span class="hljs-number">480L</span>&#125;);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">this</span>.heartbeatStalenessMonitor = ThresholdLevelsMetric.NO_OP_METRIC;    &#125;    logger.info(<span class="hljs-string">"Initializing Eureka in region &#123;&#125;"</span>, clientConfig.getRegion());    <span class="hljs-keyword">if</span> (!config.shouldRegisterWithEureka() &amp;&amp; !config.shouldFetchRegistry()) &#123;        logger.info(<span class="hljs-string">"Client configured to neither register nor query for data."</span>);        scheduler = <span class="hljs-keyword">null</span>;        heartbeatExecutor = <span class="hljs-keyword">null</span>;        cacheRefreshExecutor = <span class="hljs-keyword">null</span>;        eurekaTransport = <span class="hljs-keyword">null</span>;        instanceRegionChecker = <span class="hljs-keyword">new</span> InstanceRegionChecker(<span class="hljs-keyword">new</span> PropertyBasedAzToRegionMapper(config), clientConfig.getRegion());        <span class="hljs-comment">// This is a bit of hack to allow for existing code using DiscoveryManager.getInstance()</span>        <span class="hljs-comment">// to work with DI'd DiscoveryClient</span>        DiscoveryManager.getInstance().setDiscoveryClient(<span class="hljs-keyword">this</span>);        DiscoveryManager.getInstance().setEurekaClientConfig(config);        initTimestampMs = System.currentTimeMillis();        logger.info(<span class="hljs-string">"Discovery Client initialized at timestamp &#123;&#125; with initial instances count: &#123;&#125;"</span>,                initTimestampMs, <span class="hljs-keyword">this</span>.getApplications().size());        <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// no need to setup up an network tasks and we are done</span>    &#125;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// 这里注册了三个比较重要的定时器，负责服务注册、续约和服务拉取</span>        <span class="hljs-comment">// default size of 2 - 1 each for heartbeat and cacheRefresh</span>        scheduler = Executors.newScheduledThreadPool(<span class="hljs-number">2</span>,                <span class="hljs-keyword">new</span> ThreadFactoryBuilder()                        .setNameFormat(<span class="hljs-string">"DiscoveryClient-%d"</span>)                        .setDaemon(<span class="hljs-keyword">true</span>)                        .build());        heartbeatExecutor = <span class="hljs-keyword">new</span> ThreadPoolExecutor(                <span class="hljs-number">1</span>, clientConfig.getHeartbeatExecutorThreadPoolSize(), <span class="hljs-number">0</span>, TimeUnit.SECONDS,                <span class="hljs-keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),                <span class="hljs-keyword">new</span> ThreadFactoryBuilder()                        .setNameFormat(<span class="hljs-string">"DiscoveryClient-HeartbeatExecutor-%d"</span>)                        .setDaemon(<span class="hljs-keyword">true</span>)                        .build()        );  <span class="hljs-comment">// use direct handoff</span>        cacheRefreshExecutor = <span class="hljs-keyword">new</span> ThreadPoolExecutor(                <span class="hljs-number">1</span>, clientConfig.getCacheRefreshExecutorThreadPoolSize(), <span class="hljs-number">0</span>, TimeUnit.SECONDS,                <span class="hljs-keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),                <span class="hljs-keyword">new</span> ThreadFactoryBuilder()                        .setNameFormat(<span class="hljs-string">"DiscoveryClient-CacheRefreshExecutor-%d"</span>)                        .setDaemon(<span class="hljs-keyword">true</span>)                        .build()        );  <span class="hljs-comment">// use direct handoff</span>        eurekaTransport = <span class="hljs-keyword">new</span> EurekaTransport();        scheduleServerEndpointTask(eurekaTransport, args);        AzToRegionMapper azToRegionMapper;        <span class="hljs-keyword">if</span> (clientConfig.shouldUseDnsForFetchingServiceUrls()) &#123;            azToRegionMapper = <span class="hljs-keyword">new</span> DNSBasedAzToRegionMapper(clientConfig);        &#125; <span class="hljs-keyword">else</span> &#123;            azToRegionMapper = <span class="hljs-keyword">new</span> PropertyBasedAzToRegionMapper(clientConfig);        &#125;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != remoteRegionsToFetch.get()) &#123;            azToRegionMapper.setRegionsToFetch(remoteRegionsToFetch.get().split(<span class="hljs-string">","</span>));        &#125;        instanceRegionChecker = <span class="hljs-keyword">new</span> InstanceRegionChecker(azToRegionMapper, clientConfig.getRegion());    &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"Failed to initialize DiscoveryClient!"</span>, e);    &#125;    <span class="hljs-keyword">if</span> (clientConfig.shouldFetchRegistry() &amp;&amp; !fetchRegistry(<span class="hljs-keyword">false</span>)) &#123;        fetchRegistryFromBackup();    &#125;    <span class="hljs-comment">// call and execute the pre registration handler before all background tasks (inc registration) is started</span>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.preRegistrationHandler != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">this</span>.preRegistrationHandler.beforeRegistration();    &#125;    <span class="hljs-keyword">if</span> (clientConfig.shouldRegisterWithEureka() &amp;&amp; clientConfig.shouldEnforceRegistrationAtInit()) &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">if</span> (!register() ) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Registration error at startup. Invalid server response."</span>);            &#125;        &#125; <span class="hljs-keyword">catch</span> (Throwable th) &#123;            logger.error(<span class="hljs-string">"Registration error at startup: &#123;&#125;"</span>, th.getMessage());            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(th);        &#125;    &#125;    <span class="hljs-comment">// finally, init the schedule tasks (e.g. cluster resolvers, heartbeat, instanceInfo replicator, fetch</span>    initScheduledTasks();    <span class="hljs-keyword">try</span> &#123;        Monitors.registerObject(<span class="hljs-keyword">this</span>);    &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;        logger.warn(<span class="hljs-string">"Cannot register timers"</span>, e);    &#125;    <span class="hljs-comment">// This is a bit of hack to allow for existing code using DiscoveryManager.getInstance()</span>    <span class="hljs-comment">// to work with DI'd DiscoveryClient</span>    DiscoveryManager.getInstance().setDiscoveryClient(<span class="hljs-keyword">this</span>);    DiscoveryManager.getInstance().setEurekaClientConfig(config);    initTimestampMs = System.currentTimeMillis();    logger.info(<span class="hljs-string">"Discovery Client initialized at timestamp &#123;&#125; with initial instances count: &#123;&#125;"</span>,            initTimestampMs, <span class="hljs-keyword">this</span>.getApplications().size());&#125;</code></pre><p>initScheduledTasks()，该方法根据配置文件中的属性设置定时器，如心跳间隔等，然后将CacheRefreshThread类设置到定时器中进行服务信息拉取，将HeartbeatThread类设置到定时器中进行服务的注册和续约。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initScheduledTasks</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">if</span> (clientConfig.shouldFetchRegistry()) &#123;        <span class="hljs-comment">// registry cache refresh timer</span>        <span class="hljs-keyword">int</span> registryFetchIntervalSeconds = clientConfig.getRegistryFetchIntervalSeconds();        <span class="hljs-keyword">int</span> expBackOffBound = clientConfig.getCacheRefreshExecutorExponentialBackOffBound();        cacheRefreshTask = <span class="hljs-keyword">new</span> TimedSupervisorTask(                <span class="hljs-string">"cacheRefresh"</span>,                scheduler,                cacheRefreshExecutor,                registryFetchIntervalSeconds,                TimeUnit.SECONDS,                expBackOffBound,                <span class="hljs-keyword">new</span> CacheRefreshThread()        );        scheduler.schedule(                cacheRefreshTask,                registryFetchIntervalSeconds, TimeUnit.SECONDS);    &#125;    <span class="hljs-keyword">if</span> (clientConfig.shouldRegisterWithEureka()) &#123;        <span class="hljs-keyword">int</span> renewalIntervalInSecs = instanceInfo.getLeaseInfo().getRenewalIntervalInSecs();        <span class="hljs-keyword">int</span> expBackOffBound = clientConfig.getHeartbeatExecutorExponentialBackOffBound();        logger.info(<span class="hljs-string">"Starting heartbeat executor: "</span> + <span class="hljs-string">"renew interval is: &#123;&#125;"</span>, renewalIntervalInSecs);        <span class="hljs-comment">// Heartbeat timer</span>        heartbeatTask = <span class="hljs-keyword">new</span> TimedSupervisorTask(                <span class="hljs-string">"heartbeat"</span>,                scheduler,                heartbeatExecutor,                renewalIntervalInSecs,                TimeUnit.SECONDS,                expBackOffBound,                <span class="hljs-keyword">new</span> HeartbeatThread()        );        scheduler.schedule(                heartbeatTask,                renewalIntervalInSecs, TimeUnit.SECONDS);        <span class="hljs-comment">// InstanceInfo replicator</span>        instanceInfoReplicator = <span class="hljs-keyword">new</span> InstanceInfoReplicator(                <span class="hljs-keyword">this</span>,                instanceInfo,                clientConfig.getInstanceInfoReplicationIntervalSeconds(),                <span class="hljs-number">2</span>); <span class="hljs-comment">// burstSize</span>        statusChangeListener = <span class="hljs-keyword">new</span> ApplicationInfoManager.StatusChangeListener() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-keyword">return</span> <span class="hljs-string">"statusChangeListener"</span>;            &#125;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notify</span><span class="hljs-params">(StatusChangeEvent statusChangeEvent)</span> </span>&#123;                <span class="hljs-keyword">if</span> (InstanceStatus.DOWN == statusChangeEvent.getStatus() ||                        InstanceStatus.DOWN == statusChangeEvent.getPreviousStatus()) &#123;                    <span class="hljs-comment">// log at warn level if DOWN was involved</span>                    logger.warn(<span class="hljs-string">"Saw local status change event &#123;&#125;"</span>, statusChangeEvent);                &#125; <span class="hljs-keyword">else</span> &#123;                    logger.info(<span class="hljs-string">"Saw local status change event &#123;&#125;"</span>, statusChangeEvent);                &#125;                instanceInfoReplicator.onDemandUpdate();            &#125;        &#125;;        <span class="hljs-keyword">if</span> (clientConfig.shouldOnDemandUpdateStatusChange()) &#123;            applicationInfoManager.registerStatusChangeListener(statusChangeListener);        &#125;        instanceInfoReplicator.start(clientConfig.getInitialInstanceInfoReplicationIntervalSeconds());    &#125; <span class="hljs-keyword">else</span> &#123;        logger.info(<span class="hljs-string">"Not registering with Eureka server per configuration"</span>);    &#125;&#125;</code></pre><h3 id="服务拉取"><a href="#服务拉取" class="headerlink" title="服务拉取"></a>服务拉取</h3><p>CacheRefreshThread类实现了Runnable接口，在run()方法中会调用refreshRegistry()方法</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">refreshRegistry</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">boolean</span> isFetchingRemoteRegionRegistries = isFetchingRemoteRegionRegistries();        <span class="hljs-keyword">boolean</span> remoteRegionsModified = <span class="hljs-keyword">false</span>;        <span class="hljs-comment">// This makes sure that a dynamic change to remote regions to fetch is honored.</span>        String latestRemoteRegions = clientConfig.fetchRegistryForRemoteRegions();        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != latestRemoteRegions) &#123;            String currentRemoteRegions = remoteRegionsToFetch.get();            <span class="hljs-keyword">if</span> (!latestRemoteRegions.equals(currentRemoteRegions)) &#123;                <span class="hljs-comment">// Both remoteRegionsToFetch and AzToRegionMapper.regionsToFetch need to be in sync</span>                <span class="hljs-keyword">synchronized</span> (instanceRegionChecker.getAzToRegionMapper()) &#123;                    <span class="hljs-keyword">if</span> (remoteRegionsToFetch.compareAndSet(currentRemoteRegions, latestRemoteRegions)) &#123;                        String[] remoteRegions = latestRemoteRegions.split(<span class="hljs-string">","</span>);                        remoteRegionsRef.set(remoteRegions);                        instanceRegionChecker.getAzToRegionMapper().setRegionsToFetch(remoteRegions);                        remoteRegionsModified = <span class="hljs-keyword">true</span>;                    &#125; <span class="hljs-keyword">else</span> &#123;                        logger.info(<span class="hljs-string">"Remote regions to fetch modified concurrently,"</span> +                                <span class="hljs-string">" ignoring change from &#123;&#125; to &#123;&#125;"</span>, currentRemoteRegions, latestRemoteRegions);                    &#125;                &#125;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// Just refresh mapping to reflect any DNS/Property change</span>                instanceRegionChecker.getAzToRegionMapper().refreshMapping();            &#125;        &#125;        <span class="hljs-keyword">boolean</span> success = fetchRegistry(remoteRegionsModified);        <span class="hljs-keyword">if</span> (success) &#123;            registrySize = localRegionApps.get().size();            lastSuccessfulRegistryFetchTimestamp = System.currentTimeMillis();        &#125;        <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;            StringBuilder allAppsHashCodes = <span class="hljs-keyword">new</span> StringBuilder();            allAppsHashCodes.append(<span class="hljs-string">"Local region apps hashcode: "</span>);            allAppsHashCodes.append(localRegionApps.get().getAppsHashCode());            allAppsHashCodes.append(<span class="hljs-string">", is fetching remote regions? "</span>);            allAppsHashCodes.append(isFetchingRemoteRegionRegistries);            <span class="hljs-keyword">for</span> (Map.Entry&lt;String, Applications&gt; entry : remoteRegionVsApps.entrySet()) &#123;                allAppsHashCodes.append(<span class="hljs-string">", Remote region: "</span>);                allAppsHashCodes.append(entry.getKey());                allAppsHashCodes.append(<span class="hljs-string">" , apps hashcode: "</span>);                allAppsHashCodes.append(entry.getValue().getAppsHashCode());            &#125;            logger.debug(<span class="hljs-string">"Completed cache refresh task for discovery. All Apps hash code is &#123;&#125; "</span>,                    allAppsHashCodes);        &#125;    &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;        logger.error(<span class="hljs-string">"Cannot fetch registry from server"</span>, e);    &#125;&#125;</code></pre><p>refreshRegistry()方法会调用fetchRegistry()方法进行服务信息的拉取</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">fetchRegistry</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> forceFullRegistryFetch)</span> </span>&#123;    Stopwatch tracer = FETCH_REGISTRY_TIMER.start();    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// If the delta is disabled or if it is the first time, get all</span>        <span class="hljs-comment">// applications</span>        Applications applications = getApplications();        <span class="hljs-keyword">if</span> (clientConfig.shouldDisableDelta()                || (!Strings.isNullOrEmpty(clientConfig.getRegistryRefreshSingleVipAddress()))                || forceFullRegistryFetch                || (applications == <span class="hljs-keyword">null</span>)                || (applications.getRegisteredApplications().size() == <span class="hljs-number">0</span>)                || (applications.getVersion() == -<span class="hljs-number">1</span>)) <span class="hljs-comment">//Client application does not have latest library supporting delta</span>        &#123;            logger.info(<span class="hljs-string">"Disable delta property : &#123;&#125;"</span>, clientConfig.shouldDisableDelta());            logger.info(<span class="hljs-string">"Single vip registry refresh property : &#123;&#125;"</span>, clientConfig.getRegistryRefreshSingleVipAddress());            logger.info(<span class="hljs-string">"Force full registry fetch : &#123;&#125;"</span>, forceFullRegistryFetch);            logger.info(<span class="hljs-string">"Application is null : &#123;&#125;"</span>, (applications == <span class="hljs-keyword">null</span>));            logger.info(<span class="hljs-string">"Registered Applications size is zero : &#123;&#125;"</span>,                    (applications.getRegisteredApplications().size() == <span class="hljs-number">0</span>));            logger.info(<span class="hljs-string">"Application version is -1: &#123;&#125;"</span>, (applications.getVersion() == -<span class="hljs-number">1</span>));            getAndStoreFullRegistry();        &#125; <span class="hljs-keyword">else</span> &#123;            getAndUpdateDelta(applications);        &#125;        applications.setAppsHashCode(applications.getReconcileHashCode());        logTotalInstances();    &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;        logger.error(PREFIX + <span class="hljs-string">"&#123;&#125; - was unable to refresh its cache! status = &#123;&#125;"</span>, appPathIdentifier, e.getMessage(), e);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-keyword">if</span> (tracer != <span class="hljs-keyword">null</span>) &#123;            tracer.stop();        &#125;    &#125;    <span class="hljs-comment">// Notify about cache refresh before updating the instance remote status</span>    onCacheRefreshed();    <span class="hljs-comment">// Update remote status based on refreshed data held in the cache</span>    updateInstanceRemoteStatus();    <span class="hljs-comment">// registry was fetched successfully, so return true</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre><p>fetchRegistry()方法会调用getAndStoreFullRegistry()方法和getAndUpdateDelta()方法进行全量拉取和增量拉取。</p><p>getAndStoreFullRegistry()全量拉取，通过getApplications()方法从服务器获取服务列表后存储到localRegionApps中，后面ribbon、feign、config、zuul都会用到localRegionApps。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getAndStoreFullRegistry</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;    <span class="hljs-keyword">long</span> currentUpdateGeneration = fetchRegistryGeneration.get();    logger.info(<span class="hljs-string">"Getting all instance registry info from the eureka server"</span>);    Applications apps = <span class="hljs-keyword">null</span>;    EurekaHttpResponse&lt;Applications&gt; httpResponse = clientConfig.getRegistryRefreshSingleVipAddress() == <span class="hljs-keyword">null</span>            ? eurekaTransport.queryClient.getApplications(remoteRegionsRef.get())            : eurekaTransport.queryClient.getVip(clientConfig.getRegistryRefreshSingleVipAddress(), remoteRegionsRef.get());    <span class="hljs-keyword">if</span> (httpResponse.getStatusCode() == Status.OK.getStatusCode()) &#123;        apps = httpResponse.getEntity();    &#125;    logger.info(<span class="hljs-string">"The response status is &#123;&#125;"</span>, httpResponse.getStatusCode());    <span class="hljs-keyword">if</span> (apps == <span class="hljs-keyword">null</span>) &#123;        logger.error(<span class="hljs-string">"The application is null for some reason. Not storing this information"</span>);    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fetchRegistryGeneration.compareAndSet(currentUpdateGeneration, currentUpdateGeneration + <span class="hljs-number">1</span>)) &#123;        localRegionApps.set(<span class="hljs-keyword">this</span>.filterAndShuffle(apps));        logger.debug(<span class="hljs-string">"Got full registry with apps hashcode &#123;&#125;"</span>, apps.getAppsHashCode());    &#125; <span class="hljs-keyword">else</span> &#123;        logger.warn(<span class="hljs-string">"Not updating applications as another thread is updating it already"</span>);    &#125;&#125;</code></pre><p>getApplications()方法会调用到getApplicationsInternal()方法，用get请求获取eureka服务端的配置信息。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> EurekaHttpResponse&lt;Applications&gt; <span class="hljs-title">getApplicationsInternal</span><span class="hljs-params">(String urlPath, String[] regions)</span> </span>&#123;    ClientResponse response = <span class="hljs-keyword">null</span>;    String regionsParamValue = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">try</span> &#123;        WebResource webResource = jerseyClient.resource(serviceUrl).path(urlPath);        <span class="hljs-keyword">if</span> (regions != <span class="hljs-keyword">null</span> &amp;&amp; regions.length &gt; <span class="hljs-number">0</span>) &#123;            regionsParamValue = StringUtil.join(regions);            webResource = webResource.queryParam(<span class="hljs-string">"regions"</span>, regionsParamValue);        &#125;        Builder requestBuilder = webResource.getRequestBuilder();        addExtraHeaders(requestBuilder);        response = requestBuilder.accept(MediaType.APPLICATION_JSON_TYPE).get(ClientResponse<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        Applications applications = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">if</span> (response.getStatus() == Status.OK.getStatusCode() &amp;&amp; response.hasEntity()) &#123;            applications = response.getEntity(Applications<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        &#125;        <span class="hljs-keyword">return</span> anEurekaHttpResponse(response.getStatus(), Applications<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">                .<span class="hljs-title">headers</span>(<span class="hljs-title">headersOf</span>(<span class="hljs-title">response</span>))</span><span class="hljs-class">                .<span class="hljs-title">entity</span>(<span class="hljs-title">applications</span>)</span><span class="hljs-class">                .<span class="hljs-title">build</span>()</span>;    &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;            logger.debug(<span class="hljs-string">"Jersey HTTP GET &#123;&#125;/&#123;&#125;?&#123;&#125;; statusCode=&#123;&#125;"</span>,                    serviceUrl, urlPath,                    regionsParamValue == <span class="hljs-keyword">null</span> ? <span class="hljs-string">""</span> : <span class="hljs-string">"regions="</span> + regionsParamValue,                    response == <span class="hljs-keyword">null</span> ? <span class="hljs-string">"N/A"</span> : response.getStatus()            );        &#125;        <span class="hljs-keyword">if</span> (response != <span class="hljs-keyword">null</span>) &#123;            response.close();        &#125;    &#125;</code></pre><h3 id="注册和续约"><a href="#注册和续约" class="headerlink" title="注册和续约"></a>注册和续约</h3><p>HeartbeatThread同样实现了Runnable接口，在run()方法中会调用renew()方法。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">renew</span><span class="hljs-params">()</span> </span>&#123;    EurekaHttpResponse&lt;InstanceInfo&gt; httpResponse;    <span class="hljs-keyword">try</span> &#123;        httpResponse = eurekaTransport.registrationClient.sendHeartBeat(instanceInfo.getAppName(), instanceInfo.getId(), instanceInfo, <span class="hljs-keyword">null</span>);        logger.debug(PREFIX + <span class="hljs-string">"&#123;&#125; - Heartbeat status: &#123;&#125;"</span>, appPathIdentifier, httpResponse.getStatusCode());        <span class="hljs-keyword">if</span> (httpResponse.getStatusCode() == Status.NOT_FOUND.getStatusCode()) &#123;            REREGISTER_COUNTER.increment();            logger.info(PREFIX + <span class="hljs-string">"&#123;&#125; - Re-registering apps/&#123;&#125;"</span>, appPathIdentifier, instanceInfo.getAppName());            <span class="hljs-keyword">long</span> timestamp = instanceInfo.setIsDirtyWithTime();            <span class="hljs-keyword">boolean</span> success = register();            <span class="hljs-keyword">if</span> (success) &#123;                instanceInfo.unsetIsDirty(timestamp);            &#125;            <span class="hljs-keyword">return</span> success;        &#125;        <span class="hljs-keyword">return</span> httpResponse.getStatusCode() == Status.OK.getStatusCode();    &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;        logger.error(PREFIX + <span class="hljs-string">"&#123;&#125; - was unable to send heartbeat!"</span>, appPathIdentifier, e);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre><h4 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h4><p>renew()方法中会调用register()方法，register()方法最终会调用到AbstractJerseyEurekaHttpClient类的register()方法发送post请求至eureka进行服务注册</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> EurekaHttpResponse&lt;Void&gt; <span class="hljs-title">register</span><span class="hljs-params">(InstanceInfo info)</span> </span>&#123;    String urlPath = <span class="hljs-string">"apps/"</span> + info.getAppName();    ClientResponse response = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">try</span> &#123;        Builder resourceBuilder = jerseyClient.resource(serviceUrl).path(urlPath).getRequestBuilder();        addExtraHeaders(resourceBuilder);        response = resourceBuilder                .header(<span class="hljs-string">"Accept-Encoding"</span>, <span class="hljs-string">"gzip"</span>)                .type(MediaType.APPLICATION_JSON_TYPE)                .accept(MediaType.APPLICATION_JSON)                .post(ClientResponse<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">info</span>)</span>;        <span class="hljs-keyword">return</span> anEurekaHttpResponse(response.getStatus()).headers(headersOf(response)).build();    &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;            logger.debug(<span class="hljs-string">"Jersey HTTP POST &#123;&#125;/&#123;&#125; with instance &#123;&#125;; statusCode=&#123;&#125;"</span>, serviceUrl, urlPath, info.getId(),                    response == <span class="hljs-keyword">null</span> ? <span class="hljs-string">"N/A"</span> : response.getStatus());        &#125;        <span class="hljs-keyword">if</span> (response != <span class="hljs-keyword">null</span>) &#123;            response.close();        &#125;    &#125;&#125;</code></pre><h4 id="续约"><a href="#续约" class="headerlink" title="续约"></a>续约</h4><p>renew()方法中会调用到sendHeartBeat()方法，sendHeartBeat()方法最终也会调用到AbstractJerseyEurekaHttpClientl类的sendHeartBeat()方法，发送put请求将节点状态发到服务端。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> EurekaHttpResponse&lt;InstanceInfo&gt; <span class="hljs-title">sendHeartBeat</span><span class="hljs-params">(String appName, String id, InstanceInfo info, InstanceStatus overriddenStatus)</span> </span>&#123;    String urlPath = <span class="hljs-string">"apps/"</span> + appName + <span class="hljs-string">'/'</span> + id;    ClientResponse response = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">try</span> &#123;        WebResource webResource = jerseyClient.resource(serviceUrl)                .path(urlPath)                .queryParam(<span class="hljs-string">"status"</span>, info.getStatus().toString())                .queryParam(<span class="hljs-string">"lastDirtyTimestamp"</span>, info.getLastDirtyTimestamp().toString());        <span class="hljs-keyword">if</span> (overriddenStatus != <span class="hljs-keyword">null</span>) &#123;            webResource = webResource.queryParam(<span class="hljs-string">"overriddenstatus"</span>, overriddenStatus.name());        &#125;        Builder requestBuilder = webResource.getRequestBuilder();        addExtraHeaders(requestBuilder);        response = requestBuilder.put(ClientResponse<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        EurekaHttpResponseBuilder&lt;InstanceInfo&gt; eurekaResponseBuilder = anEurekaHttpResponse(response.getStatus(), InstanceInfo<span class="hljs-class">.<span class="hljs-keyword">class</span>).<span class="hljs-title">headers</span>(<span class="hljs-title">headersOf</span>(<span class="hljs-title">response</span>))</span>;        <span class="hljs-keyword">if</span> (response.hasEntity() &amp;&amp;                !HTML.equals(response.getType().getSubtype())) &#123; <span class="hljs-comment">//don't try and deserialize random html errors from the server</span>            eurekaResponseBuilder.entity(response.getEntity(InstanceInfo<span class="hljs-class">.<span class="hljs-keyword">class</span>))</span>;        &#125;        <span class="hljs-keyword">return</span> eurekaResponseBuilder.build();    &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;            logger.debug(<span class="hljs-string">"Jersey HTTP PUT &#123;&#125;/&#123;&#125;; statusCode=&#123;&#125;"</span>, serviceUrl, urlPath, response == <span class="hljs-keyword">null</span> ? <span class="hljs-string">"N/A"</span> : response.getStatus());        &#125;        <span class="hljs-keyword">if</span> (response != <span class="hljs-keyword">null</span>) &#123;            response.close();        &#125;    &#125;&#125;</code></pre><h2 id="eureka服务端源码解析"><a href="#eureka服务端源码解析" class="headerlink" title="eureka服务端源码解析"></a>eureka服务端源码解析</h2><p>ApplicationsResource类通过JAX-RS规范接收客户端请求，注册请求首先会被getApplicationResource()方法接收，getInstanceInfo()方法则接收到服务的续约请求。</p><pre><code class="hljs java"><span class="hljs-meta">@Path</span>(<span class="hljs-string">"&#123;appId&#125;"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> ApplicationResource <span class="hljs-title">getApplicationResource</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">        @PathParam(<span class="hljs-string">"version"</span>)</span> String version,</span><span class="hljs-function">        @<span class="hljs-title">PathParam</span><span class="hljs-params">(<span class="hljs-string">"appId"</span>)</span> String appId) </span>&#123;    CurrentRequestVersion.set(Version.toEnum(version));    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ApplicationResource(appId, serverConfig, registry);    &#125; <span class="hljs-keyword">finally</span> &#123;        CurrentRequestVersion.remove();    &#125;&#125;&#123;...&#125;<span class="hljs-meta">@Path</span>(<span class="hljs-string">"&#123;id&#125;"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> InstanceResource <span class="hljs-title">getInstanceInfo</span><span class="hljs-params">(@PathParam(<span class="hljs-string">"id"</span>)</span> String id) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> InstanceResource(<span class="hljs-keyword">this</span>, id, serverConfig, registry);&#125;</code></pre><h3 id="服务的注册"><a href="#服务的注册" class="headerlink" title="服务的注册"></a>服务的注册</h3><p>addInstrance()方法会在getApplicationResource()方法之后调用。</p><pre><code class="hljs java"><span class="hljs-meta">@POST</span><span class="hljs-meta">@Consumes</span>(&#123;<span class="hljs-string">"application/json"</span>, <span class="hljs-string">"application/xml"</span>&#125;)<span class="hljs-function"><span class="hljs-keyword">public</span> Response <span class="hljs-title">addInstance</span><span class="hljs-params">(InstanceInfo info,</span></span><span class="hljs-function"><span class="hljs-params">                            @HeaderParam(PeerEurekaNode.HEADER_REPLICATION)</span> String isReplication) </span>&#123;    logger.debug(<span class="hljs-string">"Registering instance &#123;&#125; (replication=&#123;&#125;)"</span>, info.getId(), isReplication);    <span class="hljs-comment">// validate that the instanceinfo contains all the necessary required fields</span>    <span class="hljs-keyword">if</span> (isBlank(info.getId())) &#123;        <span class="hljs-keyword">return</span> Response.status(<span class="hljs-number">400</span>).entity(<span class="hljs-string">"Missing instanceId"</span>).build();    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isBlank(info.getHostName())) &#123;        <span class="hljs-keyword">return</span> Response.status(<span class="hljs-number">400</span>).entity(<span class="hljs-string">"Missing hostname"</span>).build();    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isBlank(info.getIPAddr())) &#123;        <span class="hljs-keyword">return</span> Response.status(<span class="hljs-number">400</span>).entity(<span class="hljs-string">"Missing ip address"</span>).build();    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isBlank(info.getAppName())) &#123;        <span class="hljs-keyword">return</span> Response.status(<span class="hljs-number">400</span>).entity(<span class="hljs-string">"Missing appName"</span>).build();    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!appName.equals(info.getAppName())) &#123;        <span class="hljs-keyword">return</span> Response.status(<span class="hljs-number">400</span>).entity(<span class="hljs-string">"Mismatched appName, expecting "</span> + appName + <span class="hljs-string">" but was "</span> + info.getAppName()).build();    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (info.getDataCenterInfo() == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> Response.status(<span class="hljs-number">400</span>).entity(<span class="hljs-string">"Missing dataCenterInfo"</span>).build();    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (info.getDataCenterInfo().getName() == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> Response.status(<span class="hljs-number">400</span>).entity(<span class="hljs-string">"Missing dataCenterInfo Name"</span>).build();    &#125;    <span class="hljs-comment">// handle cases where clients may be registering with bad DataCenterInfo with missing data</span>    DataCenterInfo dataCenterInfo = info.getDataCenterInfo();    <span class="hljs-keyword">if</span> (dataCenterInfo <span class="hljs-keyword">instanceof</span> UniqueIdentifier) &#123;        String dataCenterInfoId = ((UniqueIdentifier) dataCenterInfo).getId();        <span class="hljs-keyword">if</span> (isBlank(dataCenterInfoId)) &#123;            <span class="hljs-keyword">boolean</span> experimental = <span class="hljs-string">"true"</span>.equalsIgnoreCase(serverConfig.getExperimental(<span class="hljs-string">"registration.validation.dataCenterInfoId"</span>));            <span class="hljs-keyword">if</span> (experimental) &#123;                String entity = <span class="hljs-string">"DataCenterInfo of type "</span> + dataCenterInfo.getClass() + <span class="hljs-string">" must contain a valid id"</span>;                <span class="hljs-keyword">return</span> Response.status(<span class="hljs-number">400</span>).entity(entity).build();            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dataCenterInfo <span class="hljs-keyword">instanceof</span> AmazonInfo) &#123;                AmazonInfo amazonInfo = (AmazonInfo) dataCenterInfo;                String effectiveId = amazonInfo.get(AmazonInfo.MetaDataKey.instanceId);                <span class="hljs-keyword">if</span> (effectiveId == <span class="hljs-keyword">null</span>) &#123;                    amazonInfo.getMetadata().put(AmazonInfo.MetaDataKey.instanceId.getName(), info.getId());                &#125;            &#125; <span class="hljs-keyword">else</span> &#123;                logger.warn(<span class="hljs-string">"Registering DataCenterInfo of type &#123;&#125; without an appropriate id"</span>, dataCenterInfo.getClass());            &#125;        &#125;    &#125;    registry.register(info, <span class="hljs-string">"true"</span>.equals(isReplication));    <span class="hljs-keyword">return</span> Response.status(<span class="hljs-number">204</span>).build();  <span class="hljs-comment">// 204 to be backwards compatible</span>&#125;</code></pre><p>addInstrance()方法最终会调用register()方法，完成服务注册。</p><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-type">void</span> register(final InstanceInfo <span class="hljs-keyword">info</span>, final <span class="hljs-type">boolean</span> isReplication) &#123;    <span class="hljs-type">int</span> leaseDuration = Lease.DEFAULT_DURATION_IN_SECS;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">info</span>.getLeaseInfo() != <span class="hljs-keyword">null</span> &amp;&amp; <span class="hljs-keyword">info</span>.getLeaseInfo().getDurationInSecs() &gt; <span class="hljs-number">0</span>) &#123;        leaseDuration = <span class="hljs-keyword">info</span>.getLeaseInfo().getDurationInSecs();    &#125;    super.register(<span class="hljs-keyword">info</span>, leaseDuration, isReplication);    replicateToPeers(Action.Register, <span class="hljs-keyword">info</span>.getAppName(), <span class="hljs-keyword">info</span>.getId(), <span class="hljs-keyword">info</span>, <span class="hljs-keyword">null</span>, isReplication);&#125;</code></pre><h4 id="服务的本地保存"><a href="#服务的本地保存" class="headerlink" title="服务的本地保存"></a>服务的本地保存</h4><p>register()方法会调用到AbstractInstanceRegistry的register()，将服务信息保存到ConcurrentHashMap中，Key是对应的服务名称，value则是这个服务对应的服务列表信息。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(InstanceInfo registrant, <span class="hljs-keyword">int</span> leaseDuration, <span class="hljs-keyword">boolean</span> isReplication)</span> </span>&#123;    <span class="hljs-keyword">try</span> &#123;        read.lock();        Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; gMap = registry.get(registrant.getAppName());        REGISTER.increment(isReplication);        <span class="hljs-keyword">if</span> (gMap == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">final</span> ConcurrentHashMap&lt;String, Lease&lt;InstanceInfo&gt;&gt; gNewMap = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;String, Lease&lt;InstanceInfo&gt;&gt;();            gMap = registry.putIfAbsent(registrant.getAppName(), gNewMap);            <span class="hljs-keyword">if</span> (gMap == <span class="hljs-keyword">null</span>) &#123;                gMap = gNewMap;            &#125;        &#125;        Lease&lt;InstanceInfo&gt; existingLease = gMap.get(registrant.getId());        <span class="hljs-comment">// Retain the last dirty timestamp without overwriting it, if there is already a lease</span>        <span class="hljs-keyword">if</span> (existingLease != <span class="hljs-keyword">null</span> &amp;&amp; (existingLease.getHolder() != <span class="hljs-keyword">null</span>)) &#123;            Long existingLastDirtyTimestamp = existingLease.getHolder().getLastDirtyTimestamp();            Long registrationLastDirtyTimestamp = registrant.getLastDirtyTimestamp();            logger.debug(<span class="hljs-string">"Existing lease found (existing=&#123;&#125;, provided=&#123;&#125;"</span>, existingLastDirtyTimestamp, registrationLastDirtyTimestamp);            <span class="hljs-comment">// this is a &gt; instead of a &gt;= because if the timestamps are equal, we still take the remote transmitted</span>            <span class="hljs-comment">// InstanceInfo instead of the server local copy.</span>            <span class="hljs-keyword">if</span> (existingLastDirtyTimestamp &gt; registrationLastDirtyTimestamp) &#123;                logger.warn(<span class="hljs-string">"There is an existing lease and the existing lease's dirty timestamp &#123;&#125; is greater"</span> +                        <span class="hljs-string">" than the one that is being registered &#123;&#125;"</span>, existingLastDirtyTimestamp, registrationLastDirtyTimestamp);                logger.warn(<span class="hljs-string">"Using the existing instanceInfo instead of the new instanceInfo as the registrant"</span>);                registrant = existingLease.getHolder();            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// The lease does not exist and hence it is a new registration</span>            <span class="hljs-keyword">synchronized</span> (lock) &#123;                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.expectedNumberOfClientsSendingRenews &gt; <span class="hljs-number">0</span>) &#123;                    <span class="hljs-comment">// Since the client wants to register it, increase the number of clients sending renews</span>                    <span class="hljs-keyword">this</span>.expectedNumberOfClientsSendingRenews = <span class="hljs-keyword">this</span>.expectedNumberOfClientsSendingRenews + <span class="hljs-number">1</span>;                    updateRenewsPerMinThreshold();                &#125;            &#125;            logger.debug(<span class="hljs-string">"No previous lease information found; it is new registration"</span>);        &#125;        Lease&lt;InstanceInfo&gt; lease = <span class="hljs-keyword">new</span> Lease&lt;InstanceInfo&gt;(registrant, leaseDuration);        <span class="hljs-keyword">if</span> (existingLease != <span class="hljs-keyword">null</span>) &#123;            lease.setServiceUpTimestamp(existingLease.getServiceUpTimestamp());        &#125;        gMap.put(registrant.getId(), lease);        recentRegisteredQueue.add(<span class="hljs-keyword">new</span> Pair&lt;Long, String&gt;(                System.currentTimeMillis(),                registrant.getAppName() + <span class="hljs-string">"("</span> + registrant.getId() + <span class="hljs-string">")"</span>));        <span class="hljs-comment">// This is where the initial state transfer of overridden status happens</span>        <span class="hljs-keyword">if</span> (!InstanceStatus.UNKNOWN.equals(registrant.getOverriddenStatus())) &#123;            logger.debug(<span class="hljs-string">"Found overridden status &#123;&#125; for instance &#123;&#125;. Checking to see if needs to be add to the "</span>                            + <span class="hljs-string">"overrides"</span>, registrant.getOverriddenStatus(), registrant.getId());            <span class="hljs-keyword">if</span> (!overriddenInstanceStatusMap.containsKey(registrant.getId())) &#123;                logger.info(<span class="hljs-string">"Not found overridden id &#123;&#125; and hence adding it"</span>, registrant.getId());                overriddenInstanceStatusMap.put(registrant.getId(), registrant.getOverriddenStatus());            &#125;        &#125;        InstanceStatus overriddenStatusFromMap = overriddenInstanceStatusMap.get(registrant.getId());        <span class="hljs-keyword">if</span> (overriddenStatusFromMap != <span class="hljs-keyword">null</span>) &#123;            logger.info(<span class="hljs-string">"Storing overridden status &#123;&#125; from map"</span>, overriddenStatusFromMap);            registrant.setOverriddenStatus(overriddenStatusFromMap);        &#125;        <span class="hljs-comment">// Set the status based on the overridden status rules</span>        InstanceStatus overriddenInstanceStatus = getOverriddenInstanceStatus(registrant, existingLease, isReplication);        registrant.setStatusWithoutDirty(overriddenInstanceStatus);        <span class="hljs-comment">// If the lease is registered with UP status, set lease service up timestamp</span>        <span class="hljs-keyword">if</span> (InstanceStatus.UP.equals(registrant.getStatus())) &#123;            lease.serviceUp();        &#125;        registrant.setActionType(ActionType.ADDED);        recentlyChangedQueue.add(<span class="hljs-keyword">new</span> RecentlyChangedItem(lease));        registrant.setLastUpdatedTimestamp();        invalidateCache(registrant.getAppName(), registrant.getVIPAddress(), registrant.getSecureVipAddress());        logger.info(<span class="hljs-string">"Registered instance &#123;&#125;/&#123;&#125; with status &#123;&#125; (replication=&#123;&#125;)"</span>,                registrant.getAppName(), registrant.getId(), registrant.getStatus(), isReplication);    &#125; <span class="hljs-keyword">finally</span> &#123;        read.unlock();    &#125;&#125;</code></pre><h4 id="服务的复制"><a href="#服务的复制" class="headerlink" title="服务的复制"></a>服务的复制</h4><p>replicateToPeers()方法会在register()中调用，该方法会获取到所有eureka节点，并调用replicateInstanceActionsToPeers()方法同步给所有节点。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">replicateToPeers</span><span class="hljs-params">(Action action, String appName, String id,</span></span><span class="hljs-function"><span class="hljs-params">                              InstanceInfo info <span class="hljs-comment">/* optional */</span>,</span></span><span class="hljs-function"><span class="hljs-params">                              InstanceStatus newStatus <span class="hljs-comment">/* optional */</span>, <span class="hljs-keyword">boolean</span> isReplication)</span> </span>&#123;    Stopwatch tracer = action.getTimer().start();    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">if</span> (isReplication) &#123;            numberOfReplicationsLastMin.increment();        &#125;        <span class="hljs-comment">// If it is a replication already, do not replicate again as this will create a poison replication</span>        <span class="hljs-keyword">if</span> (peerEurekaNodes == Collections.EMPTY_LIST || isReplication) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> PeerEurekaNode node : peerEurekaNodes.getPeerEurekaNodes()) &#123;            <span class="hljs-comment">// If the url represents this host, do not replicate to yourself.</span>            <span class="hljs-keyword">if</span> (peerEurekaNodes.isThisMyUrl(node.getServiceUrl())) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            replicateInstanceActionsToPeers(action, appName, id, info, newStatus, node);        &#125;    &#125; <span class="hljs-keyword">finally</span> &#123;        tracer.stop();    &#125;&#125;</code></pre><p>replicateInstanceActionsToPeers()方法，该方法只是简单的同步，并没有相应的机制保证一定成功，所以eureka只能保证CAP中的AP即可用行和分区容错性，不能保证一致性。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">replicateInstanceActionsToPeers</span><span class="hljs-params">(Action action, String appName,</span></span><span class="hljs-function"><span class="hljs-params">                                             String id, InstanceInfo info, InstanceStatus newStatus,</span></span><span class="hljs-function"><span class="hljs-params">                                             PeerEurekaNode node)</span> </span>&#123;    <span class="hljs-keyword">try</span> &#123;        InstanceInfo infoFromRegistry;        CurrentRequestVersion.set(Version.V2);        <span class="hljs-keyword">switch</span> (action) &#123;            <span class="hljs-keyword">case</span> Cancel:                node.cancel(appName, id);                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> Heartbeat:                InstanceStatus overriddenStatus = overriddenInstanceStatusMap.get(id);                infoFromRegistry = getInstanceByAppAndId(appName, id, <span class="hljs-keyword">false</span>);                node.heartbeat(appName, id, infoFromRegistry, overriddenStatus, <span class="hljs-keyword">false</span>);                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> Register:                node.register(info);                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> StatusUpdate:                infoFromRegistry = getInstanceByAppAndId(appName, id, <span class="hljs-keyword">false</span>);                node.statusUpdate(appName, id, newStatus, infoFromRegistry);                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> DeleteStatusOverride:                infoFromRegistry = getInstanceByAppAndId(appName, id, <span class="hljs-keyword">false</span>);                node.deleteStatusOverride(appName, id, infoFromRegistry);                <span class="hljs-keyword">break</span>;        &#125;    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;        logger.error(<span class="hljs-string">"Cannot replicate information to &#123;&#125; for action &#123;&#125;"</span>, node.getServiceUrl(), action.name(), t);    &#125; <span class="hljs-keyword">finally</span> &#123;        CurrentRequestVersion.remove();    &#125;&#125;</code></pre><h3 id="服务的续约"><a href="#服务的续约" class="headerlink" title="服务的续约"></a>服务的续约</h3><p>addInstrance()方法会在getInstanceInfo()方法之后调用，该方法会完成服务的心跳时间、心跳次数、状态等属性的更新，这里不在赘述。</p><pre><code class="hljs java"><span class="hljs-meta">@PUT</span><span class="hljs-function"><span class="hljs-keyword">public</span> Response <span class="hljs-title">renewLease</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">        @HeaderParam(PeerEurekaNode.HEADER_REPLICATION)</span> String isReplication,</span><span class="hljs-function">        @<span class="hljs-title">QueryParam</span><span class="hljs-params">(<span class="hljs-string">"overriddenstatus"</span>)</span> String overriddenStatus,</span><span class="hljs-function">        @<span class="hljs-title">QueryParam</span><span class="hljs-params">(<span class="hljs-string">"status"</span>)</span> String status,</span><span class="hljs-function">        @<span class="hljs-title">QueryParam</span><span class="hljs-params">(<span class="hljs-string">"lastDirtyTimestamp"</span>)</span> String lastDirtyTimestamp) </span>&#123;    <span class="hljs-keyword">boolean</span> isFromReplicaNode = <span class="hljs-string">"true"</span>.equals(isReplication);    <span class="hljs-keyword">boolean</span> isSuccess = registry.renew(app.getName(), id, isFromReplicaNode);    <span class="hljs-comment">// Not found in the registry, immediately ask for a register</span>    <span class="hljs-keyword">if</span> (!isSuccess) &#123;        logger.warn(<span class="hljs-string">"Not Found (Renew): &#123;&#125; - &#123;&#125;"</span>, app.getName(), id);        <span class="hljs-keyword">return</span> Response.status(Status.NOT_FOUND).build();    &#125;    <span class="hljs-comment">// Check if we need to sync based on dirty time stamp, the client</span>    <span class="hljs-comment">// instance might have changed some value</span>    Response response;    <span class="hljs-keyword">if</span> (lastDirtyTimestamp != <span class="hljs-keyword">null</span> &amp;&amp; serverConfig.shouldSyncWhenTimestampDiffers()) &#123;        response = <span class="hljs-keyword">this</span>.validateDirtyTimestamp(Long.valueOf(lastDirtyTimestamp), isFromReplicaNode);        <span class="hljs-comment">// Store the overridden status since the validation found out the node that replicates wins</span>        <span class="hljs-keyword">if</span> (response.getStatus() == Response.Status.NOT_FOUND.getStatusCode()                &amp;&amp; (overriddenStatus != <span class="hljs-keyword">null</span>)                &amp;&amp; !(InstanceStatus.UNKNOWN.name().equals(overriddenStatus))                &amp;&amp; isFromReplicaNode) &#123;            registry.storeOverriddenStatusIfRequired(app.getAppName(), id, InstanceStatus.valueOf(overriddenStatus));        &#125;    &#125; <span class="hljs-keyword">else</span> &#123;        response = Response.ok().build();    &#125;    logger.debug(<span class="hljs-string">"Found (Renew): &#123;&#125; - &#123;&#125;; reply status=&#123;&#125;"</span>, app.getName(), id, response.getStatus());    <span class="hljs-keyword">return</span> response;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>SpringCloud源码解读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>源码解读</tag>
      
      <tag>springcloud</tag>
      
      <tag>eureka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链路追踪</title>
    <link href="/blog/2020/04/27/springcloud-%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/"/>
    <url>/blog/2020/04/27/springcloud-%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/</url>
    
    <content type="html"><![CDATA[<h2 id="链路追踪"><a href="#链路追踪" class="headerlink" title="链路追踪"></a>链路追踪</h2><p>其实链路追踪就是日志追踪，微服务下日志跟踪，微服务系统之间的调用变得非常复杂，往往一个功能的调用要涉及到多台微服务主机的调用，那么日志追踪也就要在多台主机之间进行，人为的去每台主机查看日志这种工作几乎是不能完成的工作，所以需要有专门的日志监控工具，这里讲的就是zipkin工具，最终使使用elk监控。</p><p>增加pom依赖，sleuth可以完成对各个日志监控平台的整合，如阿里鹰眼，elk</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-sleuth<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>配置信息</p><pre><code class="hljs properties"><span class="hljs-comment">#向zipkin发送日志时的抽样比率</span><span class="hljs-meta">spring.sleuth.sampler.percentage</span>=<span class="hljs-string">1.0</span><span class="hljs-comment">#若在同一个注册中心的话可以启用自动发现，省略 base-url</span><span class="hljs-comment">#spring.zipkin.locator.discovery.enabled=true</span><span class="hljs-comment">#指定zipkin地址</span><span class="hljs-meta">spring.zipkin.base-url</span>=<span class="hljs-string">http://localhost:9411/</span></code></pre><p>然后直接启动zipkin.jar，既可以看到调用信息。</p>]]></content>
    
    
    <categories>
      
      <category>SpringCloud基本使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springcloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>服务网关Zuul</title>
    <link href="/blog/2020/04/26/springcloud-%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3zuul/"/>
    <url>/blog/2020/04/26/springcloud-%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3zuul/</url>
    
    <content type="html"><![CDATA[<h2 id="Zuul服务网关的搭建"><a href="#Zuul服务网关的搭建" class="headerlink" title="Zuul服务网关的搭建"></a>Zuul服务网关的搭建</h2><p>zuul是springcloud项目的流量入口，理论上所有进入到微服务系统的请求都要经过Zuul来过滤和路由。</p><p>pom</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-zuul<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>启动类</p><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EnableZuulProxy</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MicroZuulApplication</span> </span>&#123;&#125;</code></pre><p>配置文件</p><pre><code class="hljs properties"><span class="hljs-meta">spring.application.name</span>=<span class="hljs-string">micro-zuul</span><span class="hljs-meta">server.port</span>=<span class="hljs-string">8071</span><span class="hljs-meta">eureka.client.serviceUrl.defaultZone</span>=<span class="hljs-string">http://admin:admin@localhost:8763/eureka/</span><span class="hljs-comment"># 使用路径方式匹配路由规则</span><span class="hljs-comment"># 结构：zuul.routes.&lt;customName&gt;.path=xxx</span><span class="hljs-comment"># 其中customName自定义。通常使用要调用的服务名称，方便后期管理</span><span class="hljs-comment"># 可使用的通配符有：* ** ?</span><span class="hljs-comment"># ?单个字符</span><span class="hljs-comment"># ** 任意多个字符，包含多级路径</span><span class="hljs-meta">zuul.routes.micro-web.path</span>=<span class="hljs-string">/web/**</span><span class="hljs-meta">zuul.routes.micro-order.path</span>=<span class="hljs-string">/order/**</span><span class="hljs-comment"># 结构：zuul.routes.&lt;customName&gt;.url=xxx</span><span class="hljs-comment"># 用于配置符合path的请求路径路由到的服务地址</span><span class="hljs-comment">#zuul.routes.micro-order.url=http://localhost:8080/</span><span class="hljs-comment"># 结构：zuul.routes.&lt;customName&gt;.serviceId=xxx</span><span class="hljs-comment"># 用于配置符合path的请求路径路由到的服务名称</span><span class="hljs-meta">zuul.routes.micro-web.serviceId</span>=<span class="hljs-string">micro-web</span><span class="hljs-meta">zuul.routes.micro-order.serviceId</span>=<span class="hljs-string">micro-order</span><span class="hljs-comment"># 配置不被zuul管理的服务列表，多个服务名称使用，分隔。</span><span class="hljs-comment">#zuul.ignored-services=eureka-application-service</span><span class="hljs-comment"># 通配方式配置排除列表</span><span class="hljs-comment"># zuul.ignored-services=*</span><span class="hljs-comment"># 通配方式排除网关代理路径。所有符合ignored-patterns下的请求路径都不被zuul网关代理</span><span class="hljs-comment">#zuul.ignored-patterns=/**/local/**</span><span class="hljs-comment"># 配置请求路径前缀，所有基于此前缀的请求都由zuul网关提供代理</span><span class="hljs-comment">#zuul.prefix=/api</span><span class="hljs-comment">#过滤指定的headers信息，默认为Cookie、Set-Cookie、Authorization这三个信息</span><span class="hljs-comment">#为空的代表不需要过滤请求头信息</span><span class="hljs-meta">zuul.routes.micro-web.sensitive-headers</span>=<span class="hljs-string"></span><span class="hljs-meta">management.endpoint.health.show-details</span>=<span class="hljs-string">always</span><span class="hljs-meta">management.endpoint.shutdown.enabled</span>=<span class="hljs-string">true</span><span class="hljs-meta">management.endpoints.web.exposure.include</span>=<span class="hljs-string">*</span></code></pre><p>配置完成后可以通过<code>http://localhost:8071/actuator/routes</code>接口查看路由信息，也可以使用hystrix的路由监控功能，监控端点为：<code>http://localhost:8071/actuator/hystrix.stream</code>。zuul是集成了hystrix跟ribbon，可以直接进行相应的配置，如超时时间。</p><h2 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h2><p>需要结合分布式配置中心使用。</p><p>pom</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>LATEST<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-bus-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>配置信息</p><pre><code class="hljs properties"><span class="hljs-comment">#指定对应的环境</span><span class="hljs-meta">spring.cloud.config.profile</span>=<span class="hljs-string">zuul</span><span class="hljs-comment">#github分支名称</span><span class="hljs-meta">spring.cloud.config.label</span>=<span class="hljs-string">master</span><span class="hljs-comment">#configserver单机情况下的配置</span><span class="hljs-comment">#spring.cloud.config.uri=http://localhost:8085/</span><span class="hljs-comment">#开启config server服务发现功能</span><span class="hljs-meta">spring.cloud.config.discovery.enabled</span>=<span class="hljs-string">true</span><span class="hljs-comment">#config server服务名称</span><span class="hljs-meta">spring.cloud.config.discovery.service-id</span>=<span class="hljs-string">config-server</span><span class="hljs-comment">#如果连接不上获取配置有问题，快速响应失败</span><span class="hljs-meta">spring.cloud.config.fail-fast</span>=<span class="hljs-string">true</span><span class="hljs-comment">#默认重试的间隔时间，默认1000ms</span><span class="hljs-meta">spring.cloud.config.retry.multiplier</span>=<span class="hljs-string">1000</span><span class="hljs-comment">#下一间隔时间的乘数，默认是 1.1</span><span class="hljs-comment">#spring.cloud.config.retry.initial-interval=1</span><span class="hljs-comment">#最大间隔时间，默认2000ms</span><span class="hljs-meta">spring.cloud.config.retry.max-interval</span>=<span class="hljs-string">2000</span><span class="hljs-comment">#最大重试次数，默认 6 次</span><span class="hljs-meta">spring.cloud.config.retry.max-attempts</span>=<span class="hljs-string">6</span><span class="hljs-meta">spring.rabbitmq.host</span>=<span class="hljs-string">localhost</span><span class="hljs-meta">spring.rabbitmq.port</span>=<span class="hljs-string">5672</span><span class="hljs-meta">spring.rabbitmq.username</span>=<span class="hljs-string">guest</span><span class="hljs-meta">spring.rabbitmq.password</span>=<span class="hljs-string">guest</span><span class="hljs-meta">spring.cloud.bus.refresh.enabled</span>=<span class="hljs-string">true</span><span class="hljs-meta">spring.cloud.bus.trace.enabled</span>=<span class="hljs-string">true</span></code></pre><p>启动类</p><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EnableZuulProxy</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MicroZuulApplication</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(MicroZuulApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;        <span class="hljs-meta">@Bean</span>    <span class="hljs-meta">@RefreshScope</span>    <span class="hljs-meta">@ConfigurationProperties</span>(<span class="hljs-string">"zuul"</span>)    <span class="hljs-meta">@Primary</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ZuulProperties <span class="hljs-title">zuulProperties</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ZuulProperties();    &#125;&#125;</code></pre><p>修改配置后调用刷新接口：<code>http://localhost:8071/actuator/bus-refresh</code>就可以完成自动刷新。</p><h2 id="Zuul过滤器"><a href="#Zuul过滤器" class="headerlink" title="Zuul过滤器"></a>Zuul过滤器</h2><p>Zuul大部分功能都是通过过滤器来实现的，Zuul定义了4种标准的过滤器类型，这些过滤器类型对应于请求的典型生命周期。</p><ul><li><p><strong>pre</strong>：这种过滤器在请求被路由之前调用。可利用这种过滤器实现身份验证、在集群中选择请求的微服务，记录调试信息等。</p></li><li><p><strong>routing</strong>：这种过滤器将请求路由到微服务。这种过滤器用于构建发送给微服务的请求，并使用apachehttpclient或netflixribbon请求微服务。</p></li><li><p><strong>post</strong>：这种过滤器在路由到微服务以后执行。这种过滤器可用来为响应添加标准的httpheader、收集统计信息和指标、将响应从微服务发送给客户端等。</p></li><li><p><strong>error</strong>：在其他阶段发送错误时执行该过滤器。</p></li></ul><img src="/blog/2020/04/26/springcloud-%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3zuul/pic1.png" srcset="/blog/img/loading.gif" class><p>如使用前置过滤器完成accessToken的验证</p><pre><code class="hljs java"><span class="hljs-meta">@Slf</span>4j<span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccessFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ZuulFilter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">filterType</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> FilterConstants.PRE_TYPE;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">filterOrder</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldFilter</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> RequestContext.getCurrentContext().sendZuulResponse();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ZuulException </span>&#123;        <span class="hljs-comment">//获取上下文</span>        RequestContext ctx = RequestContext.getCurrentContext();        <span class="hljs-comment">//获取Request</span>        HttpServletRequest request = ctx.getRequest();        <span class="hljs-comment">//获取请求参数accessToken</span>        String accessToken = request.getParameter(<span class="hljs-string">"accessToken"</span>);        <span class="hljs-comment">//使用String工具类</span>        <span class="hljs-keyword">if</span> (StringUtils.isBlank(accessToken)) &#123;            log.warn(<span class="hljs-string">"accessToken is empty"</span>);            <span class="hljs-comment">//设置为false不进行路由</span>            ctx.setSendZuulResponse(<span class="hljs-keyword">false</span>);            ctx.setResponseStatusCode(<span class="hljs-number">401</span>);            <span class="hljs-keyword">try</span> &#123;                ctx.getResponse().getWriter().write(<span class="hljs-string">"accessToken is empty"</span>);            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            &#125;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        log.info(<span class="hljs-string">"access is ok"</span>);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;&#125;</code></pre><h2 id="SpringCloud-Admin"><a href="#SpringCloud-Admin" class="headerlink" title="SpringCloud Admin"></a>SpringCloud Admin</h2><p>pom文件</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.6.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>pers.zgc<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>micro-admin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>micro-admin<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>    <span class="hljs-comment">&lt;!-- FIXME change it to the project's website --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://www.example.com<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">spring-cloud.version</span>&gt;</span>Hoxton.SR3<span class="hljs-tag">&lt;/<span class="hljs-name">spring-cloud.version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>de.codecentric<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-admin-starter-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>LATEST<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>de.codecentric<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-admin-server-ui<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>LATEST<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">pluginManagement</span>&gt;</span><span class="hljs-comment">&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>                <span class="hljs-comment">&lt;!-- clean lifecycle, see https://maven.apache.org/ref/current/maven-core/lifecycles.html#clean_Lifecycle --&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-clean-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-comment">&lt;!-- default lifecycle, jar packaging: see https://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_jar_packaging --&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-resources-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.8.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.22.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-jar-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-install-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-deploy-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.8.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-comment">&lt;!-- site lifecycle, see https://maven.apache.org/ref/current/maven-core/lifecycles.html#site_Lifecycle --&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-site-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.7.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-project-info-reports-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">pluginManagement</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre><p>配置信息</p><pre><code class="hljs properties"><span class="hljs-meta">spring.application.name</span>=<span class="hljs-string">micro-admin</span><span class="hljs-meta">server.port</span>=<span class="hljs-string">8888</span><span class="hljs-comment">#是否注册到eureka</span><span class="hljs-meta">eureka.client.registerWithEureka</span>=<span class="hljs-string">true</span><span class="hljs-comment">#是否从eureka拉取注册信息</span><span class="hljs-meta">eureka.client.fetchRegistry</span>=<span class="hljs-string">true</span><span class="hljs-meta">eureka.client.serviceUrl.defaultZone</span>=<span class="hljs-string">http://admin:admin@localhost:8763/eureka/</span><span class="hljs-comment">#安全配置</span><span class="hljs-meta">spring.security.user.name</span>=<span class="hljs-string">admin</span><span class="hljs-meta">spring.security.user.password</span>=<span class="hljs-string">admin</span><span class="hljs-meta">eureka.instance.metadata-map.user.name</span>=<span class="hljs-string">$&#123;spring.security.user.name&#125;</span><span class="hljs-meta">eureka.instance.metadata-map.user.password</span>=<span class="hljs-string">$&#123;spring.security.user.password&#125;</span></code></pre><p>配置类</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecuritySecureConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String adminContextPath;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SecuritySecureConfig</span><span class="hljs-params">(AdminServerProperties adminServerProperties)</span> </span>&#123;        <span class="hljs-keyword">this</span>.adminContextPath = adminServerProperties.getContextPath();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        SavedRequestAwareAuthenticationSuccessHandler successHandler = <span class="hljs-keyword">new</span> SavedRequestAwareAuthenticationSuccessHandler();        successHandler.setTargetUrlParameter(<span class="hljs-string">"redirectTo"</span>);        http.authorizeRequests()                .antMatchers(adminContextPath + <span class="hljs-string">"/assets/**"</span>).permitAll()                .antMatchers(adminContextPath + <span class="hljs-string">"/login"</span>).permitAll()                .anyRequest().authenticated()                .and()                .formLogin().loginPage(adminContextPath + <span class="hljs-string">"/login"</span>).successHandler(successHandler).and()                .logout().logoutUrl(adminContextPath + <span class="hljs-string">"/logout"</span>).and()                .httpBasic().and()                .csrf().disable();    &#125;&#125;</code></pre><p>启动类</p><pre><code class="hljs java"><span class="hljs-meta">@EnableAdminServer</span><span class="hljs-meta">@EnableEurekaClient</span><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MicroAdminApplication</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(MicroAdminApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>SpringCloud基本使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springcloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式配置中心</title>
    <link href="/blog/2020/04/25/springcloud-%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"/>
    <url>/blog/2020/04/25/springcloud-%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/</url>
    
    <content type="html"><![CDATA[<h2 id="分布式配置中心的作用"><a href="#分布式配置中心的作用" class="headerlink" title="分布式配置中心的作用"></a>分布式配置中心的作用</h2><ul><li>抽取出公共配置，做到一处修改各处生效的目标。</li><li>配置文件的热加载，修改了配置文件后各个模块动态刷新，不需要重启服务器。</li></ul><h2 id="分布式配置中心的基本使用"><a href="#分布式配置中心的基本使用" class="headerlink" title="分布式配置中心的基本使用"></a>分布式配置中心的基本使用</h2><p>与hystrix的监控相同，配置中心可以不注册到eureka</p><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>pom文件</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>启动类</p><pre><code class="hljs java"><span class="hljs-meta">@EnableConfigServer</span><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConfigApplication</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(ConfigApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre><p>github连接配置</p><pre><code class="hljs properties"><span class="hljs-meta">spring.cloud.config.server.git.uri</span>=<span class="hljs-string">https://github.com/zgc97107/micro-config</span><span class="hljs-meta">spring.cloud.config.server.git.search-paths</span>=<span class="hljs-string">config</span><span class="hljs-meta">spring.cloud.config.server.git.username</span>=<span class="hljs-string">347398631@qq.com</span><span class="hljs-meta">spring.cloud.config.server.git.password</span>=<span class="hljs-string">zhao19971107</span></code></pre><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>pom文件</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>LATEST<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>配置文件</p><pre><code class="hljs properties"><span class="hljs-comment">#指定对应的环境</span><span class="hljs-meta">spring.cloud.config.profile</span>=<span class="hljs-string">dev</span><span class="hljs-comment">#github分支名称</span><span class="hljs-meta">spring.cloud.config.label</span>=<span class="hljs-string">master</span><span class="hljs-comment">#configserver单机情况下的配置</span><span class="hljs-meta">spring.cloud.config.uri</span>=<span class="hljs-string">http://localhost:8085/</span><span class="hljs-comment">#如果连接不上获取配置有问题，快速响应失败</span><span class="hljs-meta">spring.cloud.config.fail-fast</span>=<span class="hljs-string">true</span><span class="hljs-comment">#本地缓存目录</span><span class="hljs-comment">#spring.cloud.config.server.git.basedir=C:/work/config/tmp</span><span class="hljs-comment">#强制从GitHub中拉取配置信息，不走缓存</span><span class="hljs-meta">spring.cloud.config.server.git.force-pull</span>=<span class="hljs-string">true</span></code></pre><p>具体使用</p><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/user"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;    <span class="hljs-keyword">private</span> org.slf4j.Logger logger = LoggerFactory.getLogger(getClass());    <span class="hljs-meta">@Autowired</span>    UserService userService;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;username&#125;"</span>)    <span class="hljs-keyword">private</span> String username;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;redis.password&#125;"</span>)    <span class="hljs-keyword">private</span> String redispass;    <span class="hljs-meta">@Autowired</span>    Environment environment;    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/queryContent"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;ConsultContent&gt; <span class="hljs-title">queryContent</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;        logger.info(<span class="hljs-string">"==================已经调用=========="</span> + request.getRemotePort());        logger.info(<span class="hljs-string">"@Value======username======"</span> + username);        logger.info(<span class="hljs-string">"Environment======username======"</span> + environment.getProperty(<span class="hljs-string">"username"</span>));        logger.info(<span class="hljs-string">"@Value======redispass======"</span> + redispass);        logger.info(<span class="hljs-string">"Environment======redispass======"</span> + environment.getProperty(<span class="hljs-string">"redis.password"</span>));        <span class="hljs-keyword">return</span> userService.queryContent();    &#125;&#125;</code></pre><p>通过@Value跟environment.getProperty()方式都可以获取到。</p><h2 id="重试功能"><a href="#重试功能" class="headerlink" title="重试功能"></a>重试功能</h2><p>客户端jar包导入</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.retry<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-retry<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>配置</p><pre><code class="hljs properties"><span class="hljs-comment">#默认重试的间隔时间，默认1000ms</span><span class="hljs-meta">spring.cloud.config.retry.multiplier</span>=<span class="hljs-string">1000</span><span class="hljs-comment">#下一间隔时间的乘数，默认是 1.1</span><span class="hljs-meta">spring.cloud.config.retry.initial-interval</span>=<span class="hljs-string">1.1</span><span class="hljs-comment">#最大间隔时间，默认2000ms</span><span class="hljs-meta">spring.cloud.config.retry.max-interval</span>=<span class="hljs-string">2000</span><span class="hljs-comment">#最大重试次数，默认 6 次</span><span class="hljs-meta">spring.cloud.config.retry.max-attempts</span>=<span class="hljs-string">6</span></code></pre><h2 id="配置信息的加密"><a href="#配置信息的加密" class="headerlink" title="配置信息的加密"></a>配置信息的加密</h2><p>在配置中心中，有些信息是比较敏感的，比如密码信息，在配置密码信息的时候有必要对密码信息加密以免密码信息泄露，springcloud配置中心也支持配置信息加密的，这里一RSA非对称加密举例。</p><h3 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h3><ol><li><p>本地生成秘钥对：进入到jdk的keytool目录中：<code>jdk1.8.0_92\jre\bin\keytool</code></p></li><li><p>执行指令生成秘钥文件：<code>keytool -genkeypair -alias config-server -keyalg RSA -keystore config-server.keystore -validity 365</code>，指令执行成功后会在当前目录生成一个config-server.keystore文件。</p></li><li><p>将文件config-server.keystore复制到配置中心服务端的resources目录下</p></li><li><p>在pom文件的build标签下中添加设置，避免maven重新编译.keystore文件</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/java<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.txt<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.keystore<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span></code></pre></li><li><p>配置文件中</p><pre><code class="hljs properties"><span class="hljs-meta">encrypt.key-store.location</span>=<span class="hljs-string">config-server.keystore</span><span class="hljs-meta">encrypt.key-store.alias</span>=<span class="hljs-string">config-server</span><span class="hljs-meta">encrypt.key-store.password</span>=<span class="hljs-string">123456</span><span class="hljs-meta">encrypt.key-store.secret</span>=<span class="hljs-string">123456</span></code></pre></li></ol><h3 id="加密和解密接口"><a href="#加密和解密接口" class="headerlink" title="加密和解密接口"></a>加密和解密接口</h3><p>配置完成后，服务端会提供信息加密和解密接口：</p><ul><li>加密接口：<code>http://localhost:8085/encrypt</code>，请求方式POST，请求参数需要放到body中。</li><li>解密接口：<code>http://localhost:8085/decrypt</code>，请求方式POST，所需参数为加密接口返回的参数。</li></ul><p>注意：将配置信息通过加密接口加密后，设置到git时需要在密文前增加{cipher}标识。</p><h2 id="配置中心高可用"><a href="#配置中心高可用" class="headerlink" title="配置中心高可用"></a>配置中心高可用</h2><p>首先将配置中心注册到eureka中，来实现配置中心的服务化，然后启动多个配置中心即可。在配置之前需要将上面指定的配置中心uri删除。</p><h3 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h3><pre><code class="hljs properties"><span class="hljs-comment">#开启config server服务发现功能</span><span class="hljs-meta">spring.cloud.config.discovery.enabled</span>=<span class="hljs-string">true</span><span class="hljs-comment">#config server服务名称</span><span class="hljs-meta">spring.cloud.config.discovery.service-id</span>=<span class="hljs-string">config-server</span></code></pre><h3 id="服务端-2"><a href="#服务端-2" class="headerlink" title="服务端"></a>服务端</h3><p>需要引入并开启Eureka客户端功能，并向eureka注册</p><p>pom</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>properties</p><pre><code class="hljs properties"><span class="hljs-meta">spring.application.name</span>=<span class="hljs-string">config-server</span><span class="hljs-meta">eureka.client.serviceUrl.defaultZone</span>=<span class="hljs-string">http://admin:admin@localhost:8763/eureka/</span></code></pre><p>启动类</p><pre><code class="hljs java"><span class="hljs-meta">@EnableEurekaClient</span><span class="hljs-meta">@EnableConfigServer</span><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MicroConfigApplication</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(MicroConfigApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre><p>注意：此处有个坑，如果在配置文件bootstrap.properties文件中同时含有以下内容，会导致eureka中的服务状态变为unkown！可以将该配置注释掉，或者迁移至application.properties中。</p><pre><code class="hljs properties"><span class="hljs-comment">#开启健康检测</span><span class="hljs-meta">eureka.client.healthcheck.enabled</span>=<span class="hljs-string">true</span></code></pre><p>关于这个坑springcloud官网的解释</p><img src="/blog/2020/04/25/springcloud-%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/pic1.png" srcset="/blog/img/loading.gif" class><p>大意为，<code>eureka.client.healthcheck.enabled=true</code>应该设置在application.yml中，如果设置在bootstrap.yml文件中时可能会有UNKNOW的情况出现。</p><h2 id="动态加载刷新"><a href="#动态加载刷新" class="headerlink" title="动态加载刷新"></a>动态加载刷新</h2><p>这是一个革命性的功能，可以在运行期间修改配置文件后，不需要重启就能使最新的配置文件生效。</p><h3 id="Environment的动态刷新"><a href="#Environment的动态刷新" class="headerlink" title="Environment的动态刷新"></a>Environment的动态刷新</h3><p>动态刷新其实要有一个契机，其实这个契机就是手动调用刷新接口，如果你想刷新哪台主机的配置，就调用哪台注解的刷新接口。刷新接口为：<code>http://localhost:8081/actuator/refresh</code>，请求方式为POST。</p><h3 id="Value属性的动态刷新"><a href="#Value属性的动态刷新" class="headerlink" title="@Value属性的动态刷新"></a>@Value属性的动态刷新</h3><p>在调用刷新接口后，@Value注入的属性依然不会改变，因为@Value注入的属性是项目启动就已经确定的。如果要使@Value属性也刷新，就必须要在类上面加上@RefreshScope注解。加上该注解后，在调用刷新接口时，就会重新生成实例。</p><p>但是这种方式在需要刷新的集群机器数量比较多时会比较繁琐，此时可以使用Springcloud中提供消息总线，当需要刷新时只要调用一次刷新接口即可然后借助消息的广播来生效即可。</p><h3 id="消息总线"><a href="#消息总线" class="headerlink" title="消息总线"></a>消息总线</h3><p>pom文件</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-bus-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>properties文件</p><pre><code class="hljs properties"><span class="hljs-meta">spring.rabbitmq.host</span>=<span class="hljs-string">localhost</span><span class="hljs-meta">spring.rabbitmq.port</span>=<span class="hljs-string">5672</span><span class="hljs-meta">spring.rabbitmq.username</span>=<span class="hljs-string">guest</span><span class="hljs-meta">spring.rabbitmq.password</span>=<span class="hljs-string">guest</span>        <span class="hljs-meta">spring.cloud.bus.refresh.enabled</span>=<span class="hljs-string">true</span><span class="hljs-meta">spring.cloud.bus.trace.enabled</span>=<span class="hljs-string">true</span></code></pre><p>然后调用：<code>http://localhost:8081/actuator/bus-refresh</code>接口就可以通知到所有使用总线的服务。</p><p>也可以在git中配置，实现内容变动时自动调用接口。配置方式为Settings-&gt;Webhooks-&gt;Add webhook，然后输入url后点击Add webhook。</p><h2 id="自定义的分布式配置中心"><a href="#自定义的分布式配置中心" class="headerlink" title="自定义的分布式配置中心"></a>自定义的分布式配置中心</h2><p>原理是利用zookeeper节点的通知机制，完成对Environment中属性的修改及bean中@Value属性的修改，并将使用自定义作用域的对象销毁，然后重新生成，完成@Value的动态更新。如果要使@Value属性的动态更新，需要在类上加上@Scope(“refresh”)注解。</p><p>此处遗留问题：</p><ul><li>使用@Autowired属性注入的类中使用@Scope(“refresh”)能不能成功刷新。</li><li>使用redis的通知机制代替zookeeper的通知机制。</li></ul><p>引入jar包</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.curator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>curator-recipes<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.11.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>核心类</p><p>该类实现了ApplicationContextAware接口，将在类初始化完成并调用IOC、DI之后调用init()方法，在调用时会通过setApplicationContext()将上下文对象传入。</p><pre><code class="hljs java"><span class="hljs-meta">@Compoent</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CuratorUtil</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationContextAware</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String connnectStr = <span class="hljs-string">"192.168.67.139:2181"</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> CuratorFramework client;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String path = <span class="hljs-string">"/config"</span>;    <span class="hljs-meta">@Value</span>((<span class="hljs-string">"$&#123;zookeeper.config.enable:false&#125;"</span>))    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> enbale;    <span class="hljs-meta">@Autowired</span>    Environment environment;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String zkPropertyName = <span class="hljs-string">"zookeeperSource"</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String scopeName = <span class="hljs-string">"refresh"</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ConfigurableApplicationContext applicationContext;    <span class="hljs-keyword">private</span> ConcurrentHashMap map = <span class="hljs-keyword">new</span> ConcurrentHashMap();    <span class="hljs-keyword">private</span> BeanDefinitionRegistry beanDefinitionRegistry;    <span class="hljs-meta">@PostConstruct</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (!enbale) <span class="hljs-keyword">return</span>;        RefreshScopeRegistry refreshScopeRegistry = (RefreshScopeRegistry) applicationContext.getBean(<span class="hljs-string">"refreshScopeRegistry"</span>);        beanDefinitionRegistry = refreshScopeRegistry.getBeanDefinitionRegistry();        client = CuratorFrameworkFactory.                builder().                connectString(connnectStr).                sessionTimeoutMs(<span class="hljs-number">5000</span>).                retryPolicy(<span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">1000</span>, <span class="hljs-number">3</span>)).                build();        client.start();        <span class="hljs-keyword">try</span> &#123;            Stat stat = client.checkExists().forPath(path);            <span class="hljs-keyword">if</span> (stat == <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-comment">//创建zookeeper配置节点</span>                client.create().creatingParentsIfNeeded().withMode(CreateMode.PERSISTENT).                        forPath(path, <span class="hljs-string">"zookeeper config"</span>.getBytes());                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">//将zookeeper配置节点下面的子节点加载到spring容器的属性对象中</span>                addChildToSpringProperty(client, path);            &#125;<span class="hljs-comment">//            nodeCache(client,path);</span>            <span class="hljs-comment">//注册节点监听监听器</span>            childNodeCache(client, path);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addChildToSpringProperty</span><span class="hljs-params">(CuratorFramework client, String path)</span> </span>&#123;        <span class="hljs-keyword">if</span> (!checkExistsSpringProperty()) &#123;            <span class="hljs-comment">//如果不存在zookeeper的配置属性对象则创建</span>            createZookeeperSpringProperty();        &#125;        <span class="hljs-comment">//把config目录下的子节点添加到 zk的PropertySource对象中</span>        MutablePropertySources propertySources = applicationContext.getEnvironment().getPropertySources();        PropertySource&lt;?&gt; propertySource = propertySources.get(zkPropertyName);        ConcurrentHashMap zkmap = (ConcurrentHashMap) propertySource.getSource();        <span class="hljs-keyword">try</span> &#123;            List&lt;String&gt; strings = client.getChildren().forPath(path);            <span class="hljs-keyword">for</span> (String string : strings) &#123;                zkmap.put(string, client.getData().forPath(path + <span class="hljs-string">"/"</span> + string));            &#125;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 将节点中的信息添加到spring中</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createZookeeperSpringProperty</span><span class="hljs-params">()</span> </span>&#123;        MutablePropertySources propertySources = applicationContext.getEnvironment().getPropertySources();        OriginTrackedMapPropertySource zookeeperSource = <span class="hljs-keyword">new</span> OriginTrackedMapPropertySource(zkPropertyName, map);        propertySources.addLast(zookeeperSource);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkExistsSpringProperty</span><span class="hljs-params">()</span> </span>&#123;        MutablePropertySources propertySources = applicationContext.getEnvironment().getPropertySources();        <span class="hljs-keyword">for</span> (PropertySource&lt;?&gt; propertySource : propertySources) &#123;            <span class="hljs-keyword">if</span> (zkPropertyName.equals(propertySource.getName())) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">childNodeCache</span><span class="hljs-params">(CuratorFramework client, String path)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">final</span> PathChildrenCache pathChildrenCache = <span class="hljs-keyword">new</span> PathChildrenCache(client, path, <span class="hljs-keyword">false</span>);            pathChildrenCache.start(PathChildrenCache.StartMode.POST_INITIALIZED_EVENT);            pathChildrenCache.getListenable().addListener(<span class="hljs-keyword">new</span> PathChildrenCacheListener() &#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">childEvent</span><span class="hljs-params">(CuratorFramework client, PathChildrenCacheEvent event)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                    <span class="hljs-keyword">switch</span> (event.getType()) &#123;                        <span class="hljs-keyword">case</span> CHILD_ADDED:                            System.out.println(<span class="hljs-string">"增加了节点"</span>);                            addEnv(event.getData(), client);                            <span class="hljs-keyword">break</span>;                        <span class="hljs-keyword">case</span> CHILD_REMOVED:                            System.out.println(<span class="hljs-string">"删除了节点"</span>);                            delEnv(event.getData());                            <span class="hljs-keyword">break</span>;                        <span class="hljs-keyword">case</span> CHILD_UPDATED:                            System.out.println(<span class="hljs-string">"更新了节点"</span>);                            addEnv(event.getData(), client);                            <span class="hljs-keyword">break</span>;                        <span class="hljs-keyword">default</span>:                            <span class="hljs-keyword">break</span>;                    &#125;                    <span class="hljs-comment">//对refresh作用域的实例进行刷新</span>                    refreshBean();                &#125;            &#125;);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">refreshBean</span><span class="hljs-params">()</span> </span>&#123;        String[] beanDefinitionNames = applicationContext.getBeanDefinitionNames();        <span class="hljs-keyword">for</span> (String beanDefinitionName : beanDefinitionNames) &#123;            BeanDefinition beanDefinition = beanDefinitionRegistry.getBeanDefinition(beanDefinitionName);            <span class="hljs-keyword">if</span> (scopeName.equals(beanDefinition.getScope())) &#123;                <span class="hljs-comment">//先删除</span>                applicationContext.getBeanFactory().destroyScopedBean(beanDefinitionName);                <span class="hljs-comment">//在实例化</span>                applicationContext.getBean(beanDefinitionName);            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delEnv</span><span class="hljs-params">(ChildData childData)</span> </span>&#123;        ChildData next = childData;        String childpath = next.getPath();        MutablePropertySources propertySources = applicationContext.getEnvironment().getPropertySources();        <span class="hljs-keyword">for</span> (PropertySource&lt;?&gt; propertySource : propertySources) &#123;            <span class="hljs-keyword">if</span> (zkPropertyName.equals(propertySource.getName())) &#123;                OriginTrackedMapPropertySource ps = (OriginTrackedMapPropertySource) propertySource;                ConcurrentHashMap chm = (ConcurrentHashMap) ps.getSource();                chm.remove(childpath.substring(path.length() + <span class="hljs-number">1</span>));            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addEnv</span><span class="hljs-params">(ChildData childData, CuratorFramework client)</span> </span>&#123;        ChildData next = childData;        String childpath = next.getPath();        String data = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            data = <span class="hljs-keyword">new</span> String(client.getData().forPath(childpath));        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;        MutablePropertySources propertySources = applicationContext.getEnvironment().getPropertySources();        <span class="hljs-keyword">for</span> (PropertySource&lt;?&gt; propertySource : propertySources) &#123;            <span class="hljs-keyword">if</span> (zkPropertyName.equals(propertySource.getName())) &#123;                OriginTrackedMapPropertySource ps = (OriginTrackedMapPropertySource) propertySource;                ConcurrentHashMap chm = (ConcurrentHashMap) ps.getSource();                chm.put(childpath.substring(path.length() + <span class="hljs-number">1</span>), data);            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">nodeCache</span><span class="hljs-params">(<span class="hljs-keyword">final</span> CuratorFramework client, <span class="hljs-keyword">final</span> String path)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//第三个参数是是否压缩</span>            <span class="hljs-comment">//就是对path节点进行监控，是一个事件模板</span>            <span class="hljs-keyword">final</span> NodeCache nodeCache = <span class="hljs-keyword">new</span> NodeCache(client, path, <span class="hljs-keyword">false</span>);            nodeCache.start();            <span class="hljs-comment">//这个就是事件注册</span>            nodeCache.getListenable().addListener(<span class="hljs-keyword">new</span> NodeCacheListener() &#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">nodeChanged</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                    <span class="hljs-keyword">byte</span>[] data = nodeCache.getCurrentData().getData();                    String path1 = nodeCache.getCurrentData().getPath();                    Object put = map.put(path1.replace(<span class="hljs-string">"/"</span>, <span class="hljs-string">""</span>), <span class="hljs-keyword">new</span> String(data));                    MutablePropertySources propertySources = applicationContext.getEnvironment().getPropertySources();                    OriginTrackedMapPropertySource zookeeperSource = <span class="hljs-keyword">new</span> OriginTrackedMapPropertySource(<span class="hljs-string">"zookeeper source"</span>, map);                    propertySources.addLast(zookeeperSource);                &#125;            &#125;);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setApplicationContext</span><span class="hljs-params">(ApplicationContext context)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;        CuratorUtil.applicationContext = (ConfigurableApplicationContext) context;    &#125;&#125;</code></pre><p>自定义作用域</p><p>remove()方法将在销毁时调用，get()方法为获取时调用。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RefreshScope</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Scope</span> </span>&#123;    <span class="hljs-keyword">private</span> ConcurrentHashMap map = <span class="hljs-keyword">new</span> ConcurrentHashMap();    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">get</span><span class="hljs-params">(String name, ObjectFactory&lt;?&gt; objectFactory)</span> </span>&#123;        <span class="hljs-keyword">if</span> (map.containsKey(name)) &#123;            <span class="hljs-keyword">return</span> map.get(name);        &#125;        Object object = objectFactory.getObject();        map.put(name, object);        <span class="hljs-keyword">return</span> object;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">remove</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">return</span> map.remove(name);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerDestructionCallback</span><span class="hljs-params">(String name, Runnable callback)</span> </span>&#123;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">resolveContextualObject</span><span class="hljs-params">(String key)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getConversationId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;&#125;</code></pre><p>自定义作用域的注册</p><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RefreshScopeRegistry</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanDefinitionRegistryPostProcessor</span> </span>&#123;    <span class="hljs-keyword">private</span> BeanDefinitionRegistry beanDefinitionRegistry;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeanDefinitionRegistry</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;        <span class="hljs-keyword">this</span>.beanDefinitionRegistry = registry;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;        beanFactory.registerScope(<span class="hljs-string">"refresh"</span>,<span class="hljs-keyword">new</span> RefreshScope());    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>SpringCloud基本使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springcloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Feign的使用</title>
    <link href="/blog/2020/04/24/springcloud-feign%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/blog/2020/04/24/springcloud-feign%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><h3 id="提供方"><a href="#提供方" class="headerlink" title="提供方"></a>提供方</h3><p>controller</p><pre><code class="hljs java"><span class="hljs-meta">@Slf</span>4j<span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> OrderService orderService;    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/feign/order/listAll"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">listAll</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> orderService.listAll();    &#125;&#125;</code></pre><h3 id="消费方"><a href="#消费方" class="headerlink" title="消费方"></a>消费方</h3><p>pom文件</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>service接口（该service不需要实现类）</p><pre><code class="hljs java"><span class="hljs-meta">@FeignClient</span>(name = <span class="hljs-string">"MICRO-ORDER"</span>,path = <span class="hljs-string">"/feign"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">OrderService</span> </span>&#123;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/order/listAll"</span>)    <span class="hljs-function">String <span class="hljs-title">listAll</span><span class="hljs-params">()</span></span>;&#125;</code></pre><p>controller</p><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/order"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> OrderService orderFeignService;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/listAll"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">listAll</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> orderFeignService.listAll();    &#125;&#125;</code></pre><p>启动类</p><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EnableCircuitBreaker</span><span class="hljs-meta">@EnableEurekaClient</span><span class="hljs-meta">@EnableFeignClients</span>(clients = OrderService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">MicroWebApplication</span> </span>&#123;</code></pre><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>消费方</p><pre><code class="hljs java"><span class="hljs-meta">@FeignClient</span>(name = <span class="hljs-string">"MICRO-ORDER"</span>, path = <span class="hljs-string">"/feign"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">OrderService</span> </span>&#123;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/order/listAll"</span>)    <span class="hljs-function">String <span class="hljs-title">listAll</span><span class="hljs-params">()</span></span>;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/order/getById"</span>)    <span class="hljs-function">String <span class="hljs-title">getById</span><span class="hljs-params">(@RequestParam(<span class="hljs-string">"id"</span>)</span> Integer id)</span>;    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/order/save"</span>)    <span class="hljs-function">String <span class="hljs-title">save</span><span class="hljs-params">(@RequestBody Map&lt;String, String&gt; paramMap)</span></span>;&#125;</code></pre><p>提供方</p><pre><code class="hljs java"><span class="hljs-meta">@Slf</span>4j<span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> OrderService orderService;    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/feign/order/listAll"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">listAll</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> orderService.listAll();    &#125;    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/feign/order/save"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">save</span><span class="hljs-params">(@RequestBody Map&lt;String, String&gt; paramMap)</span> </span>&#123;        <span class="hljs-keyword">return</span> paramMap.keySet().stream().map(key -&gt; key + paramMap.get(key)).collect(Collectors.joining());    &#125;    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/feign/order/getById"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getById</span><span class="hljs-params">(@RequestParam(<span class="hljs-string">"id"</span>)</span> Integer id) </span>&#123;        <span class="hljs-keyword">return</span> id + <span class="hljs-string">""</span>;    &#125;&#125;</code></pre><h2 id="开启熔断功能"><a href="#开启熔断功能" class="headerlink" title="开启熔断功能"></a>开启熔断功能</h2><p>feign其实是对hystrix和ribbon的整合，@FeignClient中的每一个方法进行了服务隔离。</p><p>在properties中</p><pre><code class="hljs properties"><span class="hljs-comment">#feign开启熔断器</span><span class="hljs-meta">feign.hystrix.enabled</span>=<span class="hljs-string">true</span><span class="hljs-comment">#开启feign压缩功能</span><span class="hljs-meta">feign.compression.request.enabled</span>=<span class="hljs-string">true</span><span class="hljs-comment">#feign.compression.request.mime-types=text/xml,application/xml,application/json</span><span class="hljs-comment">#feign.compression.request.min-request-size=2048</span><span class="hljs-meta">feign.compression.response.enabled</span>=<span class="hljs-string">true</span></code></pre><h2 id="公共接口抽取"><a href="#公共接口抽取" class="headerlink" title="公共接口抽取"></a>公共接口抽取</h2><p>可以在项目的公共jar包中加入公共接口类，然后在提供方和消费方实现公共接口即可。</p><p>定义公共接口</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/feign/teacher"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TeacherService</span> </span>&#123;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/getAllTeacher"</span>)    <span class="hljs-function">String <span class="hljs-title">getAllTeacher</span><span class="hljs-params">()</span></span>;    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/saveTeacher"</span>)    <span class="hljs-function">String <span class="hljs-title">saveTeacher</span><span class="hljs-params">(@RequestBody Teacher Teacher)</span></span>;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/getTeacherById"</span>)    <span class="hljs-function">String <span class="hljs-title">getTeacherById</span><span class="hljs-params">(@RequestParam(<span class="hljs-string">"id"</span>)</span> Integer id)</span>;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/getTeacherByName/&#123;name&#125;"</span>)    <span class="hljs-function">String <span class="hljs-title">getTeacherByName</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"name"</span>)</span> String name)</span>;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/errorMessage"</span>)    <span class="hljs-function">String <span class="hljs-title">errorMessage</span><span class="hljs-params">(@RequestParam(<span class="hljs-string">"id"</span>)</span> Integer id)</span>;&#125;</code></pre><p>提供方</p><pre><code class="hljs java"><span class="hljs-meta">@FeignClient</span>(name = <span class="hljs-string">"MICRO-ORDER"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TeacherServiceFeign</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TeacherService</span> </span>&#123;&#125;</code></pre><p>消费方</p><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TeacherController</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TeacherService</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAllTeacher</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"micro-order.getAllTeacher"</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">saveTeacher</span><span class="hljs-params">(@RequestBody Teacher Teacher)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"micro-order.saveTeacher"</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getTeacherById</span><span class="hljs-params">(@RequestParam(<span class="hljs-string">"id"</span>)</span> Integer id) </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"micro-order.getTeacherById"</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getTeacherByName</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"name"</span>)</span> String name) </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"micro-order.getTeacherByName"</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">errorMessage</span><span class="hljs-params">(@RequestParam(<span class="hljs-string">"id"</span>)</span> Integer id) </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"micro-order.errorMessage"</span>;    &#125;&#125;</code></pre><h2 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h2><h3 id="设置fallback属性"><a href="#设置fallback属性" class="headerlink" title="设置fallback属性"></a>设置fallback属性</h3><p>使用方法</p><pre><code class="hljs java"><span class="hljs-meta">@FeignClient</span>(name = <span class="hljs-string">"MICRO-ORDER"</span>, path = <span class="hljs-string">"/feign"</span>, fallback = OrderServiceFallback<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">interface</span> <span class="hljs-title">OrderService</span> </span>&#123;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/order/listAll"</span>)    <span class="hljs-function">String <span class="hljs-title">listAll</span><span class="hljs-params">()</span></span>;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/order/getById"</span>)    <span class="hljs-function">String <span class="hljs-title">getById</span><span class="hljs-params">(@RequestParam(<span class="hljs-string">"id"</span>)</span> Integer id)</span>;    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/order/save"</span>)    <span class="hljs-function">String <span class="hljs-title">save</span><span class="hljs-params">(@RequestBody Map&lt;String, String&gt; paramMap)</span></span>;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-meta">@Slf</span>4j<span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderServiceFallback</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">OrderService</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">listAll</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"请求失败"</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getById</span><span class="hljs-params">(@RequestParam(<span class="hljs-string">"id"</span>)</span> Integer id) </span>&#123;        log.info(<span class="hljs-string">"id:&#123;&#125;"</span>, id);        <span class="hljs-keyword">return</span> <span class="hljs-string">"请求失败"</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">save</span><span class="hljs-params">(@RequestBody Map&lt;String, String&gt; paramMap)</span> </span>&#123;        paramMap.forEach((key, value) -&gt; &#123;            log.info(<span class="hljs-string">"key:&#123;&#125;,value:&#123;&#125;"</span>, key, value);        &#125;);        <span class="hljs-keyword">return</span> <span class="hljs-string">"请求失败"</span>;    &#125;&#125;</code></pre><p>当出现异常时，会调用OrderServiceFallback中对应的方法，但这种方式无法获取到出现的异常。</p><h3 id="设置fallbackFactory属性"><a href="#设置fallbackFactory属性" class="headerlink" title="设置fallbackFactory属性"></a>设置fallbackFactory属性</h3><p>这种方法可以获取到异常信息，推荐使用。</p><pre><code class="hljs java"><span class="hljs-meta">@FeignClient</span>(name = <span class="hljs-string">"MICRO-ORDER"</span>, path = <span class="hljs-string">"/feign"</span>        ,fallbackFactory = OrderServiceFallbackFactory<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">interface</span> <span class="hljs-title">OrderService</span> </span>&#123;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/order/listAll"</span>)    <span class="hljs-function">String <span class="hljs-title">listAll</span><span class="hljs-params">()</span></span>;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/order/getById"</span>)    <span class="hljs-function">String <span class="hljs-title">getById</span><span class="hljs-params">(@RequestParam(<span class="hljs-string">"id"</span>)</span> Integer id)</span>;    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/order/save"</span>)    <span class="hljs-function">String <span class="hljs-title">save</span><span class="hljs-params">(@RequestBody Map&lt;String, String&gt; paramMap)</span></span>;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-meta">@Slf</span>4j<span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderServiceFallback</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">OrderService</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">listAll</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"请求失败"</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getById</span><span class="hljs-params">(@RequestParam(<span class="hljs-string">"id"</span>)</span> Integer id) </span>&#123;        log.info(<span class="hljs-string">"id:&#123;&#125;"</span>, id);        <span class="hljs-keyword">return</span> <span class="hljs-string">"请求失败"</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">save</span><span class="hljs-params">(@RequestBody Map&lt;String, String&gt; paramMap)</span> </span>&#123;        paramMap.forEach((key, value) -&gt; &#123;            log.info(<span class="hljs-string">"key:&#123;&#125;,value:&#123;&#125;"</span>, key, value);        &#125;);        <span class="hljs-keyword">return</span> <span class="hljs-string">"请求失败"</span>;    &#125;&#125;</code></pre><h3 id="feign的全局过滤器"><a href="#feign的全局过滤器" class="headerlink" title="feign的全局过滤器"></a>feign的全局过滤器</h3><p>调用顺序在降级方法前，当服务提供方返回的状态码不是200时就会触发，可以进行异常的包装。</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FeignErrMessageFilter</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ErrorDecoder <span class="hljs-title">errorDecoder</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FeignErrorDecoder();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 当调用服务时，如果服务返回的状态码不是200，就会进入到Feign的ErrorDecoder中</span><span class="hljs-comment">     * 只有这种方式才能获取所有的被feign包装过的异常信息</span><span class="hljs-comment">     * 这里如果创建的Exception是HystrixBadRequestException,则不会走熔断逻辑，不记入熔断统计</span><span class="hljs-comment">     */</span>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FeignErrorDecoder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ErrorDecoder</span> </span>&#123;        <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(FeignErrorDecoder<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> Exception <span class="hljs-title">decode</span><span class="hljs-params">(String s, Response response)</span> </span>&#123;            RuntimeException runtimeException = <span class="hljs-keyword">null</span>;            <span class="hljs-keyword">try</span> &#123;                String retMsg = Util.toString(response.body().asReader());                logger.info(retMsg);                runtimeException = <span class="hljs-keyword">new</span> RuntimeException(retMsg);            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                e.printStackTrace();            &#125;            <span class="hljs-keyword">return</span> runtimeException;        &#125;    &#125;&#125;</code></pre><h2 id="超时时间的设置"><a href="#超时时间的设置" class="headerlink" title="超时时间的设置"></a>超时时间的设置</h2><p>feign整合了hystrix和ribbon，如果接口调用时间超过了ribbon的超时时间，ribbon就会重试。注意，重试的时间会累加，如果超过了hystrix的超时时间就会触发hystrix的降级方法不再重试。</p><pre><code class="hljs properties"><span class="hljs-comment">#单位ms，请求连接超时时间</span><span class="hljs-meta">ribbon.ConnectTimeout</span>=<span class="hljs-string">1000</span><span class="hljs-comment">#单位ms，请求处理超时时间</span><span class="hljs-meta">ribbon.ReadTimeout</span>=<span class="hljs-string">3000</span><span class="hljs-comment">#全局的超时时间</span><span class="hljs-meta">hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds</span>=<span class="hljs-string">5000</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>SpringCloud基本使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springcloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>熔断降级组件Hystrix</title>
    <link href="/blog/2020/04/24/springcloud-%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7%E7%BB%84%E4%BB%B6hystrix/"/>
    <url>/blog/2020/04/24/springcloud-%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7%E7%BB%84%E4%BB%B6hystrix/</url>
    
    <content type="html"><![CDATA[<h2 id="服务雪崩"><a href="#服务雪崩" class="headerlink" title="服务雪崩"></a>服务雪崩</h2><p>当整个微服务系统中有一个节点出现异常情况，就会导致调用它的上游系统出现响应延迟，高并发情况下的响应延迟会迅速消耗掉tomcat的连接数，使得上游节点不能正常的接收请求，这就是服务雪崩。</p><p>节点异常的发生原因多种多样，比如不合理的容量设计、高并发下某一个方法响应变慢、服务器的资源耗尽等，所以很难从源头上完全杜绝雪崩的发生，但是服务之间的强依赖也是雪崩的根本原因之一，解决服务之间强依赖关系也可以解决雪崩问题。</p><h2 id="服务隔离"><a href="#服务隔离" class="headerlink" title="服务隔离"></a>服务隔离</h2><p>如果整个系统雪崩是由于某个接口响应不及时导致的，那么就可以对这个接口进行隔离，比如限制这个接口占用连接的上限，这样就不会消耗掉所有的tomcat连接，其他接口依然能够正常响应。</p><p>Hystrix位于服务调用方和服务提供方之间，来控制对提供方的调用。</p><p>pom文件中引入</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>启动类开启hystrix熔断功能</p><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EnableCircuitBreaker</span><span class="hljs-meta">@EnableEurekaClient</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MicroWebApplication</span> </span>&#123;</code></pre><p>代码使用</p><pre><code class="hljs java"><span class="hljs-meta">@HystrixCommand</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">queryOrder</span><span class="hljs-params">()</span> </span>&#123;    String SERVICE_NAME = <span class="hljs-string">"micro-order"</span>;    <span class="hljs-keyword">return</span> restTemplate.getForObject(<span class="hljs-string">"http://"</span> + SERVICE_NAME + <span class="hljs-string">"/queryOrder"</span>, String<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;&#125;</code></pre><h2 id="Hystrix服务隔离策略"><a href="#Hystrix服务隔离策略" class="headerlink" title="Hystrix服务隔离策略"></a>Hystrix服务隔离策略</h2><p>Hystrix的服务隔离策略可以在@HystrixCommand注解中设置</p><pre><code class="hljs java"><span class="hljs-meta">@HystrixCommand</span>(commandProperties = &#123;        <span class="hljs-meta">@HystrixProperty</span>(name = <span class="hljs-string">"execution.isolation.strategy"</span>,value = <span class="hljs-string">"THREAD"</span>)&#125;)</code></pre><p><code>execution.isolation.strategy</code>属性代表使用的隔离策略，共有两种：</p><ul><li>THREAD：线程池隔离策略，接收到请求时交由线程池执行，是Hystrix的默认隔离策略。注意，这时的用户线程和请求线程是两个线程。</li><li>SEMAPHORE：信号量隔离策略是采用一个全局变量来控制并发量，用CAS锁机制来保证安全，接收到请求后全局变量加1，当加到与跟配置中的大小相等时不再接受用户请求了。</li></ul><p>THREAD的响应速度会比SEMAPHORE快，但资源占用也比较高，如果追求响应速度可以使用THREAD，如果追求资源消耗可以使用SEMAPHORE。</p><p>注意，Hystix的全局并发量默认为10，如果超过就会报异常。两种策略的设置全局并发量方式也不相同，线程池策略的设置方式如下</p><pre><code class="hljs java"><span class="hljs-meta">@HystrixCommand</span>(        commandProperties = &#123;                <span class="hljs-meta">@HystrixProperty</span>(name = <span class="hljs-string">"execution.isolation.strategy"</span>, value = <span class="hljs-string">"THREAD"</span>)        &#125;,        threadPoolProperties = &#123;                <span class="hljs-meta">@HystrixProperty</span>(name = <span class="hljs-string">"coreSize"</span>, value = <span class="hljs-string">"100"</span>)        &#125;)</code></pre><p>信号量策略的设置如下</p><pre><code class="hljs java"><span class="hljs-meta">@HystrixCommand</span>(        commandProperties = &#123;                <span class="hljs-meta">@HystrixProperty</span>(name = <span class="hljs-string">"execution.isolation.strategy"</span>, value = <span class="hljs-string">"SEMAPHORE"</span>),                <span class="hljs-meta">@HystrixProperty</span>(name = <span class="hljs-string">"execution.isolation.semaphore.maxConcurrentRequests"</span>,value = <span class="hljs-string">"100"</span>)        &#125;)</code></pre><p>@HystrixCommand注解中的其他几个属性</p><ul><li><p>groupKey：groupKey相同时将使用同一个线程池</p></li><li><p>threadPoolKey：用来指定使用的线程池，优先级要高于groupKey</p></li><li><p>commandKey：可以配合配置文件使用来指定某一个HystrixCommand的配置，如</p></li></ul><pre><code class="hljs java"><span class="hljs-meta">@HystrixCommand</span>(        commandKey = <span class="hljs-string">"queryOrder"</span>,        fallbackMethod = <span class="hljs-string">"queryOrderFallback"</span>,        commandProperties = &#123;                <span class="hljs-meta">@HystrixProperty</span>(name = <span class="hljs-string">"execution.isolation.strategy"</span>, value = <span class="hljs-string">"THREAD"</span>),                <span class="hljs-meta">@HystrixProperty</span>(name = <span class="hljs-string">"execution.isolation.thread.timeoutInMilliseconds"</span>, value = <span class="hljs-string">"10000"</span>)        &#125;,        threadPoolProperties = &#123;                <span class="hljs-meta">@HystrixProperty</span>(name = <span class="hljs-string">"coreSize"</span>, value = <span class="hljs-string">"9"</span>)        &#125;)</code></pre><p>配置文件中</p><pre><code class="hljs properties"><span class="hljs-comment">#全局的超时时间</span><span class="hljs-meta">hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds</span>=<span class="hljs-string">5000</span><span class="hljs-comment">#hystrix.command.&lt;commandKey&gt;作为前缀表示针对commandKey的Hystrix配置，commandKey默认是采用Feign的客户端的方法名字作为标识</span><span class="hljs-comment">#queryOrder的超时时间</span><span class="hljs-meta">hystrix.command.queryOrder.execution.isolation.thread.timeoutInMilliseconds</span>=<span class="hljs-string">6000</span></code></pre><h2 id="并发测试"><a href="#并发测试" class="headerlink" title="并发测试"></a>并发测试</h2><p>并发测试可以模拟多个线程同时请求的情况。</p><p>对应的jar包</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.databene<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>contiperf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>使用方法</p><pre><code class="hljs java"><span class="hljs-meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">@<span class="hljs-title">SpringBootTest</span>(<span class="hljs-title">classes</span> </span>= MicroWebApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">@<span class="hljs-title">WebAppConfiguration</span></span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">Test</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    OrderService orderService;    <span class="hljs-meta">@Rule</span>    <span class="hljs-keyword">public</span> ContiPerfRule contiPerfRule = <span class="hljs-keyword">new</span> ContiPerfRule();    <span class="hljs-meta">@org</span>.junit.Test     <span class="hljs-comment">/**</span><span class="hljs-comment">     * invocations：调用次数</span><span class="hljs-comment">     * threads：线程数 </span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@PerfTest</span>(invocations = <span class="hljs-number">5</span>,threads = <span class="hljs-number">5</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hystrixTest2</span><span class="hljs-params">()</span> </span>&#123;        log.info(Thread.currentThread().getName() + <span class="hljs-string">"==&gt;"</span> + orderService.queryOrder());    &#125;&#125;</code></pre><p>注意Hystrix默认的时间非常短，可以通过<code>@HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;, value = &quot;10000&quot;</code>重新设置超时时间来避免超时报错</p><pre><code class="hljs java"><span class="hljs-meta">@HystrixCommand</span>(        commandProperties = &#123;                <span class="hljs-meta">@HystrixProperty</span>(name = <span class="hljs-string">"execution.isolation.strategy"</span>, value = <span class="hljs-string">"THREAD"</span>),                <span class="hljs-meta">@HystrixProperty</span>(name = <span class="hljs-string">"execution.isolation.thread.timeoutInMilliseconds"</span>, value = <span class="hljs-string">"10000"</span>)        &#125;,        threadPoolProperties = &#123;                <span class="hljs-meta">@HystrixProperty</span>(name = <span class="hljs-string">"coreSize"</span>, value = <span class="hljs-string">"9"</span>)        &#125;)</code></pre><h2 id="Hystrix服务降级"><a href="#Hystrix服务降级" class="headerlink" title="Hystrix服务降级"></a>Hystrix服务降级</h2><p>服务降级相当于对服务调用过程的出现的异常进行友好封装抛一个友好的信息给前端。可以通过<code>@HystrixCommand</code>的<code>fallbackMethod</code>属性来指定。指定的降级方法可以使用<code>@HystrixCommand</code>注解再修饰，完成服务的再降级。</p><pre><code class="hljs java"><span class="hljs-meta">@HystrixCommand</span>(        fallbackMethod = <span class="hljs-string">"queryOrderFallback"</span>,        commandProperties = &#123;                <span class="hljs-meta">@HystrixProperty</span>(name = <span class="hljs-string">"execution.isolation.strategy"</span>, value = <span class="hljs-string">"THREAD"</span>),                <span class="hljs-meta">@HystrixProperty</span>(name = <span class="hljs-string">"execution.isolation.thread.timeoutInMilliseconds"</span>, value = <span class="hljs-string">"10000"</span>)        &#125;,        threadPoolProperties = &#123;                <span class="hljs-meta">@HystrixProperty</span>(name = <span class="hljs-string">"coreSize"</span>, value = <span class="hljs-string">"9"</span>)        &#125;)</code></pre><h2 id="Hystrix数据监控"><a href="#Hystrix数据监控" class="headerlink" title="Hystrix数据监控"></a>Hystrix数据监控</h2><p>Hystrix进行服务熔断时会对调用结果进行统计，比如超时数、bad请求数、降级数、异常数等等都会有统计，hystrix-dashboard就是展示hystrix统计结果的服务。</p><h3 id="被监控工程的配置"><a href="#被监控工程的配置" class="headerlink" title="被监控工程的配置"></a>被监控工程的配置</h3><p>pom文件中需要引入</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>并在配置文件中加入</p><pre><code class="hljs properties"><span class="hljs-meta">management.endpoint.health.show-details</span>=<span class="hljs-string">always</span><span class="hljs-meta">management.endpoint.shutdown.enabled</span>=<span class="hljs-string">true</span><span class="hljs-meta">management.endpoints.web.exposure.include</span>=<span class="hljs-string">*</span></code></pre><p>数据统计地址；<a href="http://localhost:8091/actuator/hystrix.stream" target="_blank" rel="noopener">http://localhost:8091/actuator/hystrix.stream</a></p><h3 id="Dashboard工程搭建"><a href="#Dashboard工程搭建" class="headerlink" title="Dashboard工程搭建"></a>Dashboard工程搭建</h3><p>pom</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.6.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>pers.zgc<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springcloud-dashboard<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>springcloud-dashboard<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.7<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.7<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">spring-cloud.version</span>&gt;</span>Hoxton.SR3<span class="hljs-tag">&lt;/<span class="hljs-name">spring-cloud.version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix-dashboard<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">pluginManagement</span>&gt;</span><span class="hljs-comment">&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>                <span class="hljs-comment">&lt;!-- clean lifecycle, see https://maven.apache.org/ref/current/maven-core/lifecycles.html#clean_Lifecycle --&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-clean-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-comment">&lt;!-- default lifecycle, jar packaging: see https://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_jar_packaging --&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-resources-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.8.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.22.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-jar-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-install-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-deploy-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.8.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-comment">&lt;!-- site lifecycle, see https://maven.apache.org/ref/current/maven-core/lifecycles.html#site_Lifecycle --&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-site-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.7.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-project-info-reports-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">pluginManagement</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre><p>application.properties</p><pre><code class="hljs properties"><span class="hljs-meta">server.port</span>=<span class="hljs-string">9990</span><span class="hljs-meta">management.endpoint.health.show-details</span>=<span class="hljs-string">always</span><span class="hljs-meta">management.endpoint.shutdown.enabled</span>=<span class="hljs-string">true</span><span class="hljs-meta">management.endpoints.web.exposure.include</span>=<span class="hljs-string">*</span></code></pre><p>启动类</p><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EnableHystrixDashboard</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DashboardApplication</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(DashboardApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre><p>启动之后进入监控地址：<a href="http://localhost:9990/hystrix，然后title中输入监控名称，点击Monitor" target="_blank" rel="noopener">http://localhost:9990/hystrix，然后title中输入监控名称，点击Monitor</a> Stream即可。</p><h2 id="Hystrix熔断"><a href="#Hystrix熔断" class="headerlink" title="Hystrix熔断"></a>Hystrix熔断</h2><p>Hystrix熔断常用于并发比较高的接口，避免在网络抖动时接口响应超时导致大量连接占用的情况，熔断器开启后会直接访问降级方法，不再请求接口加快响应时间。注意，熔断器适合的场景是高并发的场景，在并发量不高的场景下使用Ribbon的重试功能更加合适。</p><p>熔断器默认是开启的，触发的条件：在滚动窗口时间内，请求数达到断路器最小请求数，失败率达到断路器设置的百分比。滚动窗口的默认时间为10000ms，最小请求数默认为20次，失败率默认为50%</p><p>熔断器的三个状态：</p><ul><li>关闭状态：关闭状态时用户请求是可以到达服务提供方的</li><li>开启状态：开启状态时用户请求是不能到达服务提供方的，直接会走降级方法</li><li>半开状态：当hystrix熔断器开启时，过一段时间后（默认为5秒），熔断器就会由开启状态变成半开状态。半开状态的熔断器是可以将用户请求传递给服务提供方的，这时候如果远程调用返回成功，那么熔断器就会有半开状态变成关闭状态，反之，如果调用失败，熔断器就会有半开状态变成开启状态。</li></ul>]]></content>
    
    
    <categories>
      
      <category>SpringCloud基本使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springcloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springcloud注册中心eureka和负载均衡ribbon</title>
    <link href="/blog/2020/04/23/springcloud-eureka%E5%92%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1ribbon/"/>
    <url>/blog/2020/04/23/springcloud-eureka%E5%92%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1ribbon/</url>
    
    <content type="html"><![CDATA[<h2 id="Eureka用户认证"><a href="#Eureka用户认证" class="headerlink" title="Eureka用户认证"></a>Eureka用户认证</h2><p>eureka加入认证功能，在连接时会验证用户名密码。</p><h3 id="服务端配置"><a href="#服务端配置" class="headerlink" title="服务端配置"></a>服务端配置</h3><p>pom中添加</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>application.properties</p><pre><code class="hljs properties"><span class="hljs-meta">security.basic.enabled</span>=<span class="hljs-string">true</span><span class="hljs-meta">spring.security.user.name</span>=<span class="hljs-string">admin</span><span class="hljs-meta">spring.security.user.password</span>=<span class="hljs-string">admin</span></code></pre><p>添加配置类</p><pre><code class="hljs java"><span class="hljs-meta">@EnableWebSecurity</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSecurityConfigurer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//关闭csrf</span>        http.csrf().disable();        <span class="hljs-comment">//开启认证：URL格式登录必须是httpBasic</span>        http.authorizeRequests().anyRequest().authenticated().and().httpBasic();    &#125;&#125;</code></pre><h3 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h3><p>properties中的连接改为</p><pre><code class="hljs stylus">eureka<span class="hljs-selector-class">.client</span><span class="hljs-selector-class">.serviceUrl</span>.defaultZone=http:<span class="hljs-comment">//admin:admin@localhost:8763/eureka/</span></code></pre><h2 id="服务的续约和保活"><a href="#服务的续约和保活" class="headerlink" title="服务的续约和保活"></a>服务的续约和保活</h2><p>当客户端启动向eureka注册本身服务列表后，需要隔段时间发送一次心跳给eureka服务端来证明自己还活着，当eureka收到这个心跳请求后才会知道客户端还活着，继续维护该客户端的服务列表信息。一旦因为某些原因导致客户端没有按时发送心跳给eureka服务端，这时候eureka可能就会认为客户端已经挂掉，就有可能把该服务从服务列表中删除掉。</p><h3 id="客户端配置-1"><a href="#客户端配置-1" class="headerlink" title="客户端配置"></a>客户端配置</h3><pre><code class="hljs properties"><span class="hljs-comment">#服务续约，心跳的时间间隔</span><span class="hljs-meta">eureka.instance.lease-renewal-interval-in-seconds</span>=<span class="hljs-string">30</span><span class="hljs-comment">#如果从前一次发送心跳时间起，90秒没接受到新的心跳，将剔除服务</span><span class="hljs-meta">eureka.instance.lease-expiration-duration-in-seconds</span>=<span class="hljs-string">90</span><span class="hljs-comment">#表示eureka client间隔多久去拉取服务注册信息，默认为30秒</span><span class="hljs-meta">eureka.client.registry-fetch-interval-seconds</span>=<span class="hljs-string">30</span></code></pre><h3 id="服务端的配置"><a href="#服务端的配置" class="headerlink" title="服务端的配置"></a>服务端的配置</h3><pre><code class="hljs properties"><span class="hljs-comment">#自我保护模式，当出现网格分区，eureka在短时间内丢失过多客户端时，会进入自我保护模式</span><span class="hljs-meta">eureka.server.enable-self-preservation</span>=<span class="hljs-string">true</span><span class="hljs-comment">#Eureka Server 在运行期间会去统计心跳失败比例在15分钟之内是否低于85%，如果低于85%，Eureka Server会将这些实例保护起来</span><span class="hljs-meta">eureka.server.renewal-percent-threshold</span>=<span class="hljs-string">0.85</span><span class="hljs-comment">#eureka server清理无效节点的时间间隔，默认60000毫秒，单位毫秒</span><span class="hljs-meta">eureka.server.eviction-interval-timer-in-ms</span>=<span class="hljs-string">60000</span></code></pre><h2 id="Eureka监控检测"><a href="#Eureka监控检测" class="headerlink" title="Eureka监控检测"></a>Eureka监控检测</h2><p>Eureka默认的健康检测只是校验服务连接是否是UP还是DOWN的，客户端只会调用状态为UP状态的服务，但是可能会有服务连接正常，接口调用出现问题的情况，如连接Redis、mongodb、数据库出现问题导致接口调用失败，这时候就需要做自定义的检测。</p><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>pom文件中引入</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>application.properties</p><pre><code class="hljs properties"><span class="hljs-comment">#开启健康检测</span><span class="hljs-meta">eureka.client.healthcheck.enabled</span>=<span class="hljs-string">true</span></code></pre><p>配置类</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MicroOrderHealthIndicator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HealthIndicator</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Health <span class="hljs-title">health</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (OrderController.canVisitDb) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Health.Builder(Status.UP).build();        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Health.Builder(Status.DOWN).build();        &#125;    &#125;&#125;</code></pre><h2 id="服务下线"><a href="#服务下线" class="headerlink" title="服务下线"></a>服务下线</h2><p>比如有些情况是服务主机意外宕机了，无法给eureka发送心跳，但是eureka在没有接受到心跳的情况下依赖维护该服务90s，在这90s之内可能会有客户端调用到该服务，这就可能会导致调用失败。所以eureka提供了接口可以将宕机的服务立即从eureka服务列表中清除掉，避免被服务调用方调用到。</p><p>注意，该请求方式为DELETE，可以用postman请求这个接口，如果需要认证则在Authorization中选择Basic Auth然后输入用户名密码即可。如果服务状态正常，依然在发送心跳，即使调用这个接口也不会删除。</p><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">8763</span><span class="hljs-regexp">/eureka/</span>apps<span class="hljs-regexp">/&#123;Application&#125;/</span>&#123;Status中的地址&#125;</code></pre><p>还可以缩短eureka服务端中的清理无效节点、客户端拉取服务注册信息的时间间隔。</p><p>服务端</p><pre><code class="hljs properties"><span class="hljs-comment">#eureka server清理无效节点的时间间隔，默认60000毫秒，单位毫秒</span><span class="hljs-meta">eureka.server.eviction-interval-timer-in-ms</span>=<span class="hljs-string">60000</span></code></pre><p>客户端</p><pre><code class="hljs properties"><span class="hljs-comment">#表示 eureka client 间隔多久去拉取服务注册信息，默认为 30 秒</span><span class="hljs-meta">eureka.client.registry-fetch-interval-seconds</span>=<span class="hljs-string">30</span></code></pre><h2 id="Eureka高可用"><a href="#Eureka高可用" class="headerlink" title="Eureka高可用"></a>Eureka高可用</h2><img src="/blog/2020/04/23/springcloud-eureka%E5%92%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1ribbon/pic1.png" srcset="/blog/img/loading.gif" class><p>整个微服务中存在多个eureka服务，每个eureka服务都是相互复制的，会把客户端注册进来的服务复制到eureka集群中的其他节点里面来。其实简单来说就是eureka每个节点相互复制。</p><p>eureka1的配置</p><pre><code class="hljs properties"><span class="hljs-meta">server.port</span>=<span class="hljs-string">8761</span><span class="hljs-meta">eureka.instance.hostname</span>=<span class="hljs-string">eureka-8761</span><span class="hljs-comment">#是否注册到eureka</span><span class="hljs-meta">eureka.client.registerWithEureka</span>=<span class="hljs-string">true</span><span class="hljs-comment">#是否从eureka拉取注册信息</span><span class="hljs-meta">eureka.client.fetchRegistry</span>=<span class="hljs-string">true</span><span class="hljs-comment">#暴露eureka服务的地址</span><span class="hljs-meta">eureka.client.serviceUrl.defaultZone</span>=<span class="hljs-string">http://admin:admin@eureka-8762:8762/eureka/</span><span class="hljs-comment">#自我保护模式，当出现网格分区，eureka在短时间内丢失过多客户端时，会进入自我保护模式</span><span class="hljs-meta">eureka.server.enable-self-preservation</span>=<span class="hljs-string">true</span><span class="hljs-comment">#Eureka Server 在运行期间会去统计心跳失败比例在15分钟之内是否低于85%，如果低于85%，Eureka Server会将这些实例保护起来</span><span class="hljs-meta">eureka.server.renewal-percent-threshold</span>=<span class="hljs-string">0.85</span><span class="hljs-comment">#eureka server清理无效节点的时间间隔，默认60000毫秒，单位毫秒</span><span class="hljs-meta">eureka.server.eviction-interval-timer-in-ms</span>=<span class="hljs-string">60000</span><span class="hljs-meta">security.basic.enabled</span>=<span class="hljs-string">true</span><span class="hljs-meta">spring.security.user.name</span>=<span class="hljs-string">admin</span><span class="hljs-meta">spring.security.user.password</span>=<span class="hljs-string">admin</span></code></pre><p>eureka2的配置</p><pre><code class="hljs properties"><span class="hljs-meta">server.port</span>=<span class="hljs-string">8762</span><span class="hljs-meta">eureka.instance.hostname</span>=<span class="hljs-string">eureka-8762</span><span class="hljs-comment">#是否注册到eureka</span><span class="hljs-meta">eureka.client.registerWithEureka</span>=<span class="hljs-string">true</span><span class="hljs-comment">#是否从eureka拉取注册信息</span><span class="hljs-meta">eureka.client.fetchRegistry</span>=<span class="hljs-string">true</span><span class="hljs-comment">#暴露eureka服务的地址</span><span class="hljs-meta">eureka.client.serviceUrl.defaultZone</span>=<span class="hljs-string">http://admin:admin@eureka-8761:8761/eureka/</span><span class="hljs-comment">#自我保护模式，当出现网格分区，eureka在短时间内丢失过多客户端时，会进入自我保护模式</span><span class="hljs-meta">eureka.server.enable-self-preservation</span>=<span class="hljs-string">true</span><span class="hljs-comment">#Eureka Server 在运行期间会去统计心跳失败比例在15分钟之内是否低于85%，如果低于85%，Eureka Server会将这些实例保护起来</span><span class="hljs-meta">eureka.server.renewal-percent-threshold</span>=<span class="hljs-string">0.85</span><span class="hljs-comment">#eureka server清理无效节点的时间间隔，默认60000毫秒，单位毫秒</span><span class="hljs-meta">eureka.server.eviction-interval-timer-in-ms</span>=<span class="hljs-string">60000</span><span class="hljs-meta">security.basic.enabled</span>=<span class="hljs-string">true</span><span class="hljs-meta">spring.security.user.name</span>=<span class="hljs-string">admin</span><span class="hljs-meta">spring.security.user.password</span>=<span class="hljs-string">admin</span></code></pre><p>注意：eureka-8761、eureka-8762需要在本地配置host，对应的地址一般都为127.0.0.1。</p><h2 id="Eureka自我保护模式"><a href="#Eureka自我保护模式" class="headerlink" title="Eureka自我保护模式"></a>Eureka自我保护模式</h2><p>如果开启了自我保护，如果服务没有发送心跳会继续维护90s，如果关闭自我保护在很短一段时间就会删除服务，不会继续维护90s。</p><pre><code class="hljs properties"><span class="hljs-comment">#自我保护模式，当出现网格分区，eureka在短时间内丢失过多客户端时，会进入自我保护模式</span><span class="hljs-meta">eureka.server.enable-self-preservation</span>=<span class="hljs-string">true</span></code></pre><h2 id="Ribbon-API"><a href="#Ribbon-API" class="headerlink" title="Ribbon API"></a>Ribbon API</h2><p>Ribbon是一个独立的组件，用来进行远程接口调用的。Ribbon会从本地列表选择服务来调用。</p><p>配置类中</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> *负载均衡的注解</span><span class="hljs-comment"> */</span><span class="hljs-meta">@LoadBalanced</span><span class="hljs-meta">@Bean</span><span class="hljs-function">RestTemplate <span class="hljs-title">restTemplate</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate();&#125;</code></pre><p>具体的调用</p><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><span class="hljs-keyword">private</span> RestTemplate restTemplate;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">queryOrder</span><span class="hljs-params">()</span> </span>&#123;    String SERVICE_NAME = <span class="hljs-string">"micro-order"</span>;    <span class="hljs-keyword">return</span> restTemplate.getForObject(<span class="hljs-string">"http://"</span> + SERVICE_NAME + <span class="hljs-string">"/queryOrder"</span>, String<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;&#125;</code></pre><h2 id="Ribbon配置"><a href="#Ribbon配置" class="headerlink" title="Ribbon配置"></a>Ribbon配置</h2><p>配置文件方式：</p><pre><code class="hljs properties"><span class="hljs-comment">#是否从eureka获取服务列表</span><span class="hljs-meta">ribbon.eureka.enabled</span>=<span class="hljs-string">true</span><span class="hljs-comment">#用于不从eureka获取服务列表，提供服务调用的节点，不建议使用</span><span class="hljs-comment">#micro-order.ribbon.listOfServers=localhost:8081,localhost:8082</span><span class="hljs-comment">#单位ms，请求连接超时时间</span><span class="hljs-meta">micro-order.ribbon.ConnectTimeout</span>=<span class="hljs-string">1000</span><span class="hljs-comment">#单位mx，请求处理超时时间</span><span class="hljs-meta">micro-order.ribbon.ReadTimeout</span>=<span class="hljs-string">2000</span><span class="hljs-comment">#如果调用失败是否针对所有接口进行重试</span><span class="hljs-meta">micro-order.ribbon.OkToRetryOnAllOperations</span>=<span class="hljs-string">true</span><span class="hljs-comment">#切换实例的重试次数</span><span class="hljs-meta">micro-order.ribbon.MaxAutoRetriesNextServer</span>=<span class="hljs-string">2</span><span class="hljs-comment">#对当前实例的重试次数 当Eureka中可以找到服务，但是服务连接不上时会重试</span><span class="hljs-meta">micro-order.ribbon.MaxAutoRetries</span>=<span class="hljs-string">2</span><span class="hljs-comment">#配置负载均衡策略</span><span class="hljs-meta">micro-order.ribbon.NFLoadBalancerRuleClassName</span>=<span class="hljs-string">com.netflix.loadbalancer.RoundRobinRule</span><span class="hljs-comment">#</span><span class="hljs-meta">micro-order.ribbon.NFLoadBalancerPingClassName</span>=<span class="hljs-string">com.netflix.loadbalancer.PingUrl</span></code></pre><p>配置类方式：</p><p>使用@RebbonClients加载配置，这个配置类只针对micro-order服务，可以区别化配置。</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@RibbonClients</span>(value = &#123;        <span class="hljs-meta">@RibbonClient</span>(name = <span class="hljs-string">"micro-order"</span>,configuration = RibbonLoadBalanceMicroOrderConfig<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">&#125;)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">LoadBalanceConfig</span> </span>&#123;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">/*</span><span class="hljs-comment"> * 这个类最好不要出现在启动类的@ComponentScan扫描范围</span><span class="hljs-comment"> * 如果出现在@ComponentScan扫描访问，那么这个配置类就是每个服务共用的配置了</span><span class="hljs-comment"> * */</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RibbonLoadBalanceMicroOrderConfig</span> </span>&#123;    <span class="hljs-comment">//    @RibbonClientName</span>    <span class="hljs-keyword">private</span> String name = <span class="hljs-string">"micro-order"</span>;    <span class="hljs-meta">@Bean</span>    <span class="hljs-meta">@ConditionalOnClass</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> IClientConfig <span class="hljs-title">defaultClientConfigImpl</span><span class="hljs-params">()</span> </span>&#123;        DefaultClientConfigImpl config = <span class="hljs-keyword">new</span> DefaultClientConfigImpl();        config.loadProperties(name);        config.set(CommonClientConfigKey.MaxAutoRetries, <span class="hljs-number">2</span>);        config.set(CommonClientConfigKey.MaxAutoRetriesNextServer, <span class="hljs-number">2</span>);        config.set(CommonClientConfigKey.ConnectTimeout, <span class="hljs-number">2000</span>);        config.set(CommonClientConfigKey.ReadTimeout, <span class="hljs-number">4000</span>);        config.set(CommonClientConfigKey.OkToRetryOnAllOperations, <span class="hljs-keyword">true</span>);        <span class="hljs-keyword">return</span> config;    &#125;    <span class="hljs-comment">/*</span><span class="hljs-comment">     * 用于请求前判断服务是否存活，会拉长请求时间，不建议使用</span><span class="hljs-comment">     * */</span><span class="hljs-comment">//    @Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> IPing <span class="hljs-title">iPing</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//这个实现类会去调用服务来判断服务是否存活</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PingUrl();    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> IRule <span class="hljs-title">ribbonRule</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//线性轮训</span>        <span class="hljs-keyword">new</span> RoundRobinRule();        <span class="hljs-comment">//可以重试的轮训</span>        <span class="hljs-keyword">new</span> RetryRule();        <span class="hljs-comment">//根据运行情况来计算权重</span>        <span class="hljs-keyword">new</span> WeightedResponseTimeRule();        <span class="hljs-comment">//过滤掉故障实例，选择请求数最小的实例</span>        <span class="hljs-keyword">new</span> BestAvailableRule();        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RandomRule();    &#125;&#125;</code></pre><p>负载均衡策略：</p><ul><li>RoundRobinRule：线性轮询</li><li>RetryRule：可以重试的轮询</li><li>WeightedResponseTimeRule：根据运行情况计算权重</li><li>BestAvailableRule：过滤掉故障实例，选择请求数最小的</li></ul><p>注：涉及到的统计数据来源于actuator。</p><h2 id="Ribbon的单独使用"><a href="#Ribbon的单独使用" class="headerlink" title="Ribbon的单独使用"></a>Ribbon的单独使用</h2><p>Ribbon是一个独立的组件，可以脱离springcloud单独使用。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">//myClients随便取值</span>        ConfigurationManager.getConfigInstance().setProperty(<span class="hljs-string">"myClients.ribbon.listOfServers"</span>,<span class="hljs-string">"localhost:8001,localhost:8002"</span>);        RestClient client = (RestClient)ClientFactory.getNamedClient(<span class="hljs-string">"myClients"</span>);        HttpRequest request = HttpRequest.newBuilder().uri(<span class="hljs-keyword">new</span> URI(<span class="hljs-string">"/user/queryContent"</span>)).build();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            HttpResponse httpResponse = client.executeWithLoadBalancer(request);            String entity = httpResponse.getEntity(String<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;            System.out.println(entity);        &#125;    &#125; <span class="hljs-keyword">catch</span> (URISyntaxException e) &#123;        e.printStackTrace();    &#125; <span class="hljs-keyword">catch</span> (ClientException e) &#123;        e.printStackTrace();    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        e.printStackTrace();    &#125;&#125;</code></pre><p>需要的jar包：</p><ul><li>com.netflix.ribbon:ribbon-core:2.3.0</li><li>com.netflix.ribbon:ribbon-httpclient:2.3.0</li></ul>]]></content>
    
    
    <categories>
      
      <category>SpringCloud基本使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springcloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud的简单搭建</title>
    <link href="/blog/2020/04/23/springcloud-%E7%AE%80%E5%8D%95%E6%90%AD%E5%BB%BA/"/>
    <url>/blog/2020/04/23/springcloud-%E7%AE%80%E5%8D%95%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="注册中心的搭建"><a href="#注册中心的搭建" class="headerlink" title="注册中心的搭建"></a>注册中心的搭建</h2><p>pom文件</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.6.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springcould-eureka<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>springcould-eureka<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.7<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.7<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">spring-cloud.version</span>&gt;</span>Hoxton.SR3<span class="hljs-tag">&lt;/<span class="hljs-name">spring-cloud.version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.2.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.vintage<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-vintage-engine<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">pluginManagement</span>&gt;</span><span class="hljs-comment">&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>                <span class="hljs-comment">&lt;!-- clean lifecycle, see https://maven.apache.org/ref/current/maven-core/lifecycles.html#clean_Lifecycle --&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-clean-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-comment">&lt;!-- default lifecycle, jar packaging: see https://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_jar_packaging --&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-resources-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.8.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.22.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-jar-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-install-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-deploy-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.8.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-comment">&lt;!-- site lifecycle, see https://maven.apache.org/ref/current/maven-core/lifecycles.html#site_Lifecycle --&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-site-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.7.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-project-info-reports-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">pluginManagement</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre><p>application.properties</p><pre><code class="hljs properties"><span class="hljs-meta">server.port</span>=<span class="hljs-string">8763</span><span class="hljs-meta">eureka.instance.hostname</span>=<span class="hljs-string">localhost</span><span class="hljs-comment">#是否注册到eureka</span><span class="hljs-meta">eureka.client.registerWithEureka</span>=<span class="hljs-string">false</span><span class="hljs-comment">#是否从eureka拉取注册信息</span><span class="hljs-meta">eureka.client.fetchRegistry</span>=<span class="hljs-string">false</span><span class="hljs-comment">#暴露eureka服务的地址</span><span class="hljs-meta">eureka.client.serviceUrl.defaultZone</span>=<span class="hljs-string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span><span class="hljs-comment">#自我保护模式，当出现网格分区，eureka在短时间内丢失过多客户端时，会进入自我保护模式</span><span class="hljs-meta">eureka.server.enable-self-preservation</span>=<span class="hljs-string">true</span><span class="hljs-comment">#eureka server清理无效节点的时间间隔，默认60000毫秒，单位毫秒</span><span class="hljs-comment">#eureka.server.eviction-interval-timer-in-ms=60000</span></code></pre><p>启动类</p><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EnableEurekaServer</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EurekaApplication</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(EurekaApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre><h2 id="服务提供方"><a href="#服务提供方" class="headerlink" title="服务提供方"></a>服务提供方</h2><p>pom文件</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.6.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>pers.zgc<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>micro-order<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>micro-order<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.7<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.7<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">spring-cloud.version</span>&gt;</span>Hoxton.SR3<span class="hljs-tag">&lt;/<span class="hljs-name">spring-cloud.version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">pluginManagement</span>&gt;</span><span class="hljs-comment">&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>                <span class="hljs-comment">&lt;!-- clean lifecycle, see https://maven.apache.org/ref/current/maven-core/lifecycles.html#clean_Lifecycle --&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-clean-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-comment">&lt;!-- default lifecycle, jar packaging: see https://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_jar_packaging --&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-resources-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.8.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.22.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-jar-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-install-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-deploy-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.8.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-comment">&lt;!-- site lifecycle, see https://maven.apache.org/ref/current/maven-core/lifecycles.html#site_Lifecycle --&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-site-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.7.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-project-info-reports-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">pluginManagement</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre><p>boostarp.properties（优先级最高的配置文件）</p><pre><code class="hljs properties"><span class="hljs-meta">spring.application.name</span>=<span class="hljs-string">micro-order</span><span class="hljs-meta">server.port</span>=<span class="hljs-string">8081</span><span class="hljs-meta">eureka.client.serviceUrl.defaultZone</span>=<span class="hljs-string">http\://localhost\:8763/eureka/</span></code></pre><p>controller</p><pre><code class="hljs java"><span class="hljs-meta">@Slf</span>4j<span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderController</span> </span>&#123;    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/queryOrder"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">queryOrder</span><span class="hljs-params">()</span></span>&#123;        log.info(<span class="hljs-string">"====micro-order====queryOrder"</span>);        <span class="hljs-keyword">return</span> <span class="hljs-string">"queryOrder"</span>;    &#125;</code></pre><p>启动类</p><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MicroOrderApplication</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(MicroOrderApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre><h2 id="服务消费方"><a href="#服务消费方" class="headerlink" title="服务消费方"></a>服务消费方</h2><p>pom</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.6.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>pers.zgc<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>micro-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>micro-web<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.7<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.7<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">spring-cloud.version</span>&gt;</span>Hoxton.SR3<span class="hljs-tag">&lt;/<span class="hljs-name">spring-cloud.version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">pluginManagement</span>&gt;</span><span class="hljs-comment">&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>                <span class="hljs-comment">&lt;!-- clean lifecycle, see https://maven.apache.org/ref/current/maven-core/lifecycles.html#clean_Lifecycle --&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-clean-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-comment">&lt;!-- default lifecycle, jar packaging: see https://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_jar_packaging --&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-resources-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.8.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.22.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-jar-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-install-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-deploy-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.8.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-comment">&lt;!-- site lifecycle, see https://maven.apache.org/ref/current/maven-core/lifecycles.html#site_Lifecycle --&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-site-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.7.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-project-info-reports-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">pluginManagement</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre><p>bootstrap.properties</p><pre><code class="hljs properties"><span class="hljs-meta">spring.application.name</span>=<span class="hljs-string">micro-web</span><span class="hljs-meta">server.port</span>=<span class="hljs-string">8091</span><span class="hljs-meta">eureka.client.serviceUrl.defaultZone</span>=<span class="hljs-string">http://localhost:8763/eureka/</span></code></pre><p>controller</p><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/order"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> OrderService orderService;    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/query"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">queryOrder</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> orderService.queryOrder();    &#125;&#125;</code></pre><p>service</p><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">OrderService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RestTemplate restTemplate;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">queryOrder</span><span class="hljs-params">()</span> </span>&#123;        String SERVICE_NAME = <span class="hljs-string">"micro-order"</span>;        <span class="hljs-keyword">return</span> restTemplate.getForObject(<span class="hljs-string">"http://"</span> + SERVICE_NAME + <span class="hljs-string">"/queryOrder"</span>, String<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    &#125;&#125;</code></pre><p>启动类</p><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EnableEurekaClient</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MicroWebApplication</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     *负载均衡的注解</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@LoadBalanced</span>    <span class="hljs-function">RestTemplate <span class="hljs-title">restTemplate</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(MicroWebApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>SpringCloud基本使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springcloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>架构的演变过程</title>
    <link href="/blog/2020/04/23/springcloud-%E6%9E%B6%E6%9E%84%E7%9A%84%E6%BC%94%E5%8F%98%E8%BF%87%E7%A8%8B/"/>
    <url>/blog/2020/04/23/springcloud-%E6%9E%B6%E6%9E%84%E7%9A%84%E6%BC%94%E5%8F%98%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="单体"><a href="#单体" class="headerlink" title="单体"></a>单体</h3><p>我们最先接触的单体架构，整个系统就只有一个工程，打包往往是打成了war包，然后部署到单一tomcat上面，这种就是单体架构，如图:</p><img src="/blog/2020/04/23/springcloud-%E6%9E%B6%E6%9E%84%E7%9A%84%E6%BC%94%E5%8F%98%E8%BF%87%E7%A8%8B/pic1.png" srcset="/blog/img/loading.gif" class><p>假如系统按照功能划分了，商品模块，购物车模块，订单模块，物流模块等等模块。那么所有模块都会在一个工程里面，这就是单体架构。</p><p>单体架构优点</p><ul><li>结构简单</li><li>部署简单</li><li>所需的硬件资源少</li><li>节省成本</li></ul><p>缺点</p><ul><li>版本迭代慢，往往改动一个代码会影响全局</li><li>不能满足一定并发的访问</li><li>代码维护困难，所有代码在一个工程里面，存在被其他人修改的风险</li></ul><h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><p>随着业务的拓展，公司的发展，单体架构慢慢的不能满足我们的需求，我们需要对架构进行变动，我们能够想到的最简单的办法就是加机器，对应用横向扩展。</p><img src="/blog/2020/04/23/springcloud-%E6%9E%B6%E6%9E%84%E7%9A%84%E6%BC%94%E5%8F%98%E8%BF%87%E7%A8%8B/pic2.png" srcset="/blog/img/loading.gif" class><p>这种架构貌似暂时解决了我们的问题，但是用户量慢慢增加后，我们只能通过横向加机器来解决，还是会存在版本迭代慢，代码维护困难的问题。而且用户请求往往是读多写少的情况， 所以可能真正需要扩容的只是商品模块而已，而现在是整个工程都扩容了，这无形中是一种资源的浪费，因为其他模块可能根本不需要扩容就可以满足需求。所以我们有必要对整个工程按照模块进行拆分。</p><h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><img src="/blog/2020/04/23/springcloud-%E6%9E%B6%E6%9E%84%E7%9A%84%E6%BC%94%E5%8F%98%E8%BF%87%E7%A8%8B/pic3.png" srcset="/blog/img/loading.gif" class><p>模块拆分后，模块和模块之间是需要通过接口调用的方式进行通信，模块和模块之间通过分流软件进行负载均衡。这个架构解决前面的资源浪费问题和代码管理问题，因为我们是对系统进行拆分，各个模块都有单独的工程，比如我修改商品模块，就不需要担心会不会影响购物车模块。但是这种架构扩展非常麻烦，一旦需要横向加机器，或者减机器都需要修改nginx配置，一旦机器变多了以后，nginx的配置量就是一个不能完成的工作。</p><h3 id="SOA服务治理"><a href="#SOA服务治理" class="headerlink" title="SOA服务治理"></a>SOA服务治理</h3><p>这时候SOA服务治理框架就应运而生，架构图如下:</p><img src="/blog/2020/04/23/springcloud-%E6%9E%B6%E6%9E%84%E7%9A%84%E6%BC%94%E5%8F%98%E8%BF%87%E7%A8%8B/pic4.png" srcset="/blog/img/loading.gif" class><p>基于注册中心的SOA框架，扩展方便不需要维护分流工具，在启动应用的时会把服务通过http的方式注册到注册中心。<br>在SOA框架中一般会有三种角色</p><ul><li>注册中心：维护服务列表</li><li>服务提供方：服务提供方启动的时候会把自己注册到注册中心</li><li>服务消费方：服务消费方启动的时候会获取注册中心的服务列表，然后从这个服务列表中选择一个去调用。</li></ul><p>微服务工程的缺点:</p><ul><li>项目部署变得非常复杂，必须借助CI（持续集成Jenkins）工具。</li><li>分布式事务问题，接口设计要求较高，往往要考虑幂等问题。</li><li>网络抖动带来的不可控的接口超时。</li></ul><p>微服务项目要求：</p><ul><li>团队分工明确</li><li>项目迭代频繁</li><li>QPS（单位时间查询量）增加。</li></ul>]]></content>
    
    
    <categories>
      
      <category>SpringCloud基本使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springcloud</tag>
      
      <tag>架构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springboot自定义的启动器</title>
    <link href="/blog/2020/04/23/springboot-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%AF%E5%8A%A8%E5%99%A8/"/>
    <url>/blog/2020/04/23/springboot-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%AF%E5%8A%A8%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="定义启动器核心工程"><a href="#定义启动器核心工程" class="headerlink" title="定义启动器核心工程"></a>定义启动器核心工程</h2><p>当需要把一些共用的api封装成jar包的时候，就可以使用自定义启动器来做。自定义启动时用到的就是springboot的SPI原理，springboot会去加载META-INF/spring.factories配置文件中EnableAutoConfiguration为key的所有类，所以首先需要创建配置类。</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableCaching</span><span class="hljs-meta">@ComponentScan</span>(basePackages = <span class="hljs-string">"com.base.redis"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="hljs-title">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;        RedisTemplate&lt;String, Object&gt; redisTemplate = <span class="hljs-keyword">new</span> RedisTemplate&lt;&gt;();        redisTemplate.setConnectionFactory(redisConnectionFactory);        <span class="hljs-comment">// 设置value的序列化规则和 key的序列化规则</span>        StringRedisSerializer stringSerializer = <span class="hljs-keyword">new</span> StringRedisSerializer();        redisTemplate.setKeySerializer(stringSerializer);        redisTemplate.setValueSerializer(stringSerializer);        redisTemplate.setHashKeySerializer(stringSerializer);        redisTemplate.setHashValueSerializer(stringSerializer);        redisTemplate.afterPropertiesSet();        <span class="hljs-keyword">return</span> redisTemplate;    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> CacheManager <span class="hljs-title">cacheManager</span><span class="hljs-params">(RedisConnectionFactory factory, RedisCacheConfiguration redisCacheConfiguration)</span> </span>&#123;        <span class="hljs-comment">//RedisCacheManager 生成器创建</span>        RedisCacheManager.RedisCacheManagerBuilder builder = RedisCacheManager.builder(factory).cacheDefaults(redisCacheConfiguration);        <span class="hljs-keyword">return</span> builder.build();    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> RedisCacheConfiguration <span class="hljs-title">redisCacheConfiguration</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//加载redis缓存的默认配置</span>        RedisCacheConfiguration configuration = RedisCacheConfiguration.defaultCacheConfig();        configuration = configuration                .entryTtl(Duration.ofDays(<span class="hljs-number">1</span>))                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(<span class="hljs-keyword">new</span> FastJsonRedisSerializer&lt;&gt;(Object<span class="hljs-class">.<span class="hljs-keyword">class</span>)))</span>;        <span class="hljs-keyword">return</span> configuration;    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> HashOperations&lt;String, String, String&gt; <span class="hljs-title">hashOperations</span><span class="hljs-params">(RedisTemplate&lt;String, String&gt; redisTemplate)</span> </span>&#123;        <span class="hljs-keyword">return</span> redisTemplate.opsForHash();    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ValueOperations&lt;String, String&gt; <span class="hljs-title">valueOperations</span><span class="hljs-params">(RedisTemplate&lt;String, String&gt; redisTemplate)</span> </span>&#123;        <span class="hljs-keyword">return</span> redisTemplate.opsForValue();    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListOperations&lt;String, String&gt; <span class="hljs-title">listOperations</span><span class="hljs-params">(RedisTemplate&lt;String, String&gt; redisTemplate)</span> </span>&#123;        <span class="hljs-keyword">return</span> redisTemplate.opsForList();    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> SetOperations&lt;String, String&gt; <span class="hljs-title">setOperations</span><span class="hljs-params">(RedisTemplate&lt;String, String&gt; redisTemplate)</span> </span>&#123;        <span class="hljs-keyword">return</span> redisTemplate.opsForSet();    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ZSetOperations&lt;String, String&gt; <span class="hljs-title">zSetOperations</span><span class="hljs-params">(RedisTemplate&lt;String, String&gt; redisTemplate)</span> </span>&#123;        <span class="hljs-keyword">return</span> redisTemplate.opsForZSet();    &#125;&#125;</code></pre><p>然后在resources/META-INF/spring.factories中加入配置类</p><pre><code class="hljs properties"><span class="hljs-meta">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="hljs-string">\</span>  <span class="hljs-attr">com.base.redis.config.RedisConfig</span></code></pre><h2 id="自定义starter工程"><a href="#自定义starter工程" class="headerlink" title="自定义starter工程"></a>自定义starter工程</h2><p>该工程中没有代码，只是作为核心工程的启动类，封装和整合核心工程。所以只需要一个引入核心工程的pom文件。</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.base.cache<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cache-springboot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>cache-springboot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.base.redis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>redis-cache<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>SpringBoot源码解析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springboot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot启动分析</title>
    <link href="/blog/2020/04/22/springboot-%E5%90%AF%E5%8A%A8%E5%88%86%E6%9E%90/"/>
    <url>/blog/2020/04/22/springboot-%E5%90%AF%E5%8A%A8%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="springboot的启动分析"><a href="#springboot的启动分析" class="headerlink" title="springboot的启动分析"></a>springboot的启动分析</h2><p>main()方法中会调用springboot的run()方法，该方法是spring启动的入口，这里只分析几个重点的方法。</p><ol><li>调用getRunListeners()方法通过SPI机制加载META-INF/spring.factories文件中的类。</li><li>调用createApplicationContext()方法完成上下文对象的创建。</li><li>调用refreshContext()方法，最终会调用到上下文对象的refresh()，与之前不同的是这里在refresh()的onrefresh()方法中会完成tomcat的启动。</li></ol><p>SPI在spring、springboot、tomcat中都有使用，SPI全称为service provider interface，核心思想是服务提供接口的发现。spring主要是从外部文件中发现服务，这么做是由于加载的类文件是由开发者指定的包名下的，是不包括第三方的jar包的，所以spring提供了这种方式来加载jar包中的类文件。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ConfigurableApplicationContext <span class="hljs-title">run</span><span class="hljs-params">(String... args)</span> </span>&#123;   <span class="hljs-comment">// 统计时间用的工具类</span>   StopWatch stopWatch = <span class="hljs-keyword">new</span> StopWatch();   stopWatch.start();   ConfigurableApplicationContext context = <span class="hljs-keyword">null</span>;   Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();   configureHeadlessProperty();   <span class="hljs-comment">// 获取实现了SpringApplicationRunListener接口的实现类，通过SPI机制加载</span>   <span class="hljs-comment">// META-INF/spring.factories文件下的类</span>   SpringApplicationRunListeners listeners = getRunListeners(args);   <span class="hljs-comment">// 首先调用SpringApplicationRunListener的starting方法</span>   listeners.starting();   <span class="hljs-keyword">try</span> &#123;      ApplicationArguments applicationArguments = <span class="hljs-keyword">new</span> DefaultApplicationArguments(args);      <span class="hljs-comment">// 处理配置数据</span>      ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);      configureIgnoreBeanInfo(environment);      <span class="hljs-comment">// 启动时打印banner</span>      Banner printedBanner = printBanner(environment);      <span class="hljs-comment">// 创建上下文对象</span>      context = createApplicationContext();      <span class="hljs-comment">// 获取SpringBootExceptionReporter接口的类，异常报告</span>      exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter<span class="hljs-class">.<span class="hljs-keyword">class</span>,</span>            new Class[] &#123; ConfigurableApplicationContext.class &#125;, context);      prepareContext(context, environment, listeners, applicationArguments, printedBanner);      <span class="hljs-comment">// 核心方法，启动spring容器</span>      refreshContext(context);      afterRefresh(context, applicationArguments);      <span class="hljs-comment">// 统计结束</span>      stopWatch.stop();      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.logStartupInfo) &#123;         <span class="hljs-keyword">new</span> StartupInfoLogger(<span class="hljs-keyword">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);      &#125;      <span class="hljs-comment">// 调用started</span>      listeners.started(context);      <span class="hljs-comment">// ApplicationRunner</span>      <span class="hljs-comment">// CommandLineRunner</span>      <span class="hljs-comment">// 获取这两个接口的实现类，并调用其run方法</span>      callRunners(context, applicationArguments);   &#125;   <span class="hljs-keyword">catch</span> (Throwable ex) &#123;      handleRunFailure(context, ex, exceptionReporters, listeners);      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(ex);   &#125;   <span class="hljs-keyword">try</span> &#123;      <span class="hljs-comment">// 最后调用running方法</span>      listeners.running(context);   &#125;   <span class="hljs-keyword">catch</span> (Throwable ex) &#123;      handleRunFailure(context, ex, exceptionReporters, <span class="hljs-keyword">null</span>);      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(ex);   &#125;   <span class="hljs-keyword">return</span> context;&#125;</code></pre><h3 id="getRunListeners-方法"><a href="#getRunListeners-方法" class="headerlink" title="getRunListeners()方法"></a>getRunListeners()方法</h3><p>getSpringFactoriesInstances()是它的主要方法，该方法首先会通过loadFactoryNames()方法加载spring.factories中的内容，然后通过反射实例化。</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> &lt;T&gt; <span class="hljs-function">Collection&lt;T&gt; <span class="hljs-title">getSpringFactoriesInstances</span><span class="hljs-params">(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args)</span> </span>&#123;   ClassLoader classLoader = getClassLoader();   <span class="hljs-comment">// Use names and ensure unique to protect against duplicates</span>   Set&lt;String&gt; names = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(SpringFactoriesLoader.loadFactoryNames(type, classLoader));   <span class="hljs-comment">// 加载后反射实例化</span>   List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);   AnnotationAwareOrderComparator.sort(instances);   <span class="hljs-keyword">return</span> instances;&#125;</code></pre><h3 id="createApplicationContext-方法"><a href="#createApplicationContext-方法" class="headerlink" title="createApplicationContext()方法"></a>createApplicationContext()方法</h3><p>该方法会加载AnnotationConfigServletWebServerApplicationContext对象。该对象与之前分析的spring基于注解的启动方式中的AnnotationConfigApplicaitonContext对象基本相同，初始化逻辑也基本相同。</p><p>其构造函数中也会创建一个AnnotatedBeanDefinitionReader对象，AnnotatedBeanDefinitionReader的构造函数中会直接调用AnnotationConfigUtils.registerAnnotationConfigProcessors()将一些对象的转为BeanDefinition对象，这里有一个比较重要的对象：ConfigurationClassPostProcessor。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> ConfigurableApplicationContext <span class="hljs-title">createApplicationContext</span><span class="hljs-params">()</span> </span>&#123;   Class&lt;?&gt; contextClass = <span class="hljs-keyword">this</span>.applicationContextClass;   <span class="hljs-keyword">if</span> (contextClass == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">try</span> &#123;         <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">this</span>.webApplicationType) &#123;         <span class="hljs-keyword">case</span> SERVLET:            contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS);            <span class="hljs-keyword">break</span>;         <span class="hljs-keyword">case</span> REACTIVE:            contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS);            <span class="hljs-keyword">break</span>;         <span class="hljs-keyword">default</span>:            contextClass = Class.forName(DEFAULT_CONTEXT_CLASS);         &#125;      &#125;      <span class="hljs-keyword">catch</span> (ClassNotFoundException ex) &#123;         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(               <span class="hljs-string">"Unable create a default ApplicationContext, please specify an ApplicationContextClass"</span>, ex);      &#125;   &#125;   <span class="hljs-keyword">return</span> (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);&#125;</code></pre><h3 id="onRefresh-方法"><a href="#onRefresh-方法" class="headerlink" title="onRefresh()方法"></a>onRefresh()方法</h3><p>该方法会调用到ServletWebServerApplicationContext类的onRefresh()方法，该方法完成父类容器的onRefresh()方法后会调用createWebServer()方法创建web容器。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onRefresh</span><span class="hljs-params">()</span> </span>&#123;   <span class="hljs-keyword">super</span>.onRefresh();   <span class="hljs-keyword">try</span> &#123;      createWebServer();   &#125;   <span class="hljs-keyword">catch</span> (Throwable ex) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ApplicationContextException(<span class="hljs-string">"Unable to start web server"</span>, ex);   &#125;&#125;</code></pre><p>createWebServer()方法</p><p>该方法会调用到Jetty、Undertow、Tomcat的getWebServer()创建方法，这里我们只分析Tomcat的创建方法。</p><pre><code class="hljs java"><span class="hljs-comment">/*</span><span class="hljs-comment"> * 创建servlet容器</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createWebServer</span><span class="hljs-params">()</span> </span>&#123;   WebServer webServer = <span class="hljs-keyword">this</span>.webServer;   ServletContext servletContext = getServletContext();   <span class="hljs-keyword">if</span> (webServer == <span class="hljs-keyword">null</span> &amp;&amp; servletContext == <span class="hljs-keyword">null</span>) &#123;      ServletWebServerFactory factory = getWebServerFactory();      <span class="hljs-comment">// 主要看这个方法</span>      <span class="hljs-keyword">this</span>.webServer = factory.getWebServer(getSelfInitializer());   &#125;   <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (servletContext != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">try</span> &#123;         getSelfInitializer().onStartup(servletContext);      &#125;      <span class="hljs-keyword">catch</span> (ServletException ex) &#123;         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ApplicationContextException(<span class="hljs-string">"Cannot initialize servlet context"</span>, ex);      &#125;   &#125;   initPropertySources();&#125;</code></pre><p>getWebServer()方法</p><p>该方法会创建一个Tomcat容器，并完成其工作路径、connection属性的设置。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> WebServer <span class="hljs-title">getWebServer</span><span class="hljs-params">(ServletContextInitializer... initializers)</span> </span>&#123;   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.disableMBeanRegistry) &#123;      Registry.disableRegistry();   &#125;   Tomcat tomcat = <span class="hljs-keyword">new</span> Tomcat();   File baseDir = (<span class="hljs-keyword">this</span>.baseDirectory != <span class="hljs-keyword">null</span>) ? <span class="hljs-keyword">this</span>.baseDirectory : createTempDir(<span class="hljs-string">"tomcat"</span>);   tomcat.setBaseDir(baseDir.getAbsolutePath());   Connector connector = <span class="hljs-keyword">new</span> Connector(<span class="hljs-keyword">this</span>.protocol);   connector.setThrowOnFailure(<span class="hljs-keyword">true</span>);   tomcat.getService().addConnector(connector);   customizeConnector(connector);   tomcat.setConnector(connector);   tomcat.getHost().setAutoDeploy(<span class="hljs-keyword">false</span>);   configureEngine(tomcat.getEngine());   <span class="hljs-keyword">for</span> (Connector additionalConnector : <span class="hljs-keyword">this</span>.additionalTomcatConnectors) &#123;      tomcat.getService().addConnector(additionalConnector);   &#125;   prepareContext(tomcat.getHost(), initializers);   <span class="hljs-keyword">return</span> getTomcatWebServer(tomcat);&#125;</code></pre><h2 id="springboot的自动化配置分析"><a href="#springboot的自动化配置分析" class="headerlink" title="springboot的自动化配置分析"></a>springboot的自动化配置分析</h2><p>@SpringBootApplication中包含的注解：</p><ul><li>@ComponentScan注解：扫描包路径下的注解</li><li>@EnableAutoConfiguration注解：开启自动配置</li></ul><pre><code class="hljs java"><span class="hljs-meta">@Target</span>(ElementType.TYPE)<span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-meta">@Documented</span><span class="hljs-meta">@Inherited</span><span class="hljs-meta">@SpringBootConfiguration</span><span class="hljs-meta">@EnableAutoConfiguration</span><span class="hljs-meta">@ComponentScan</span>(excludeFilters = &#123; <span class="hljs-meta">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter<span class="hljs-class">.<span class="hljs-keyword">class</span>),</span><span class="hljs-class">      @<span class="hljs-title">Filter</span>(<span class="hljs-title">type</span> </span>= FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter<span class="hljs-class">.<span class="hljs-keyword">class</span>) &#125;)</span><span class="hljs-class"><span class="hljs-title">public</span> @<span class="hljs-title">interface</span> <span class="hljs-title">SpringBootApplication</span> </span>&#123;</code></pre><h3 id="EnableAutoConfiguration自动配置的实现"><a href="#EnableAutoConfiguration自动配置的实现" class="headerlink" title="@EnableAutoConfiguration自动配置的实现"></a>@EnableAutoConfiguration自动配置的实现</h3><p>该注解会引入AutoConfigurationImportSelector类，这个类将通过spi来引入自动配置类。</p><pre><code class="hljs java"><span class="hljs-meta">@Target</span>(ElementType.TYPE)<span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-meta">@Documented</span><span class="hljs-meta">@Inherited</span><span class="hljs-meta">@AutoConfigurationPackage</span><span class="hljs-meta">@Import</span>(AutoConfigurationImportSelector<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> @<span class="hljs-title">interface</span> <span class="hljs-title">EnableAutoConfiguration</span> </span>&#123;</code></pre><h4 id="AutoConfigurationImportSelector类"><a href="#AutoConfigurationImportSelector类" class="headerlink" title="AutoConfigurationImportSelector类"></a>AutoConfigurationImportSelector类</h4><p>process()方法</p><p>该方法会由上面注册的ConfigurationClassPostProcessor调用，首先调用getAutoConfigurationEntry()方法获取到自动配置的实体类，然后加入到spring容器，交由spring来管理。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(AnnotationMetadata annotationMetadata, DeferredImportSelector deferredImportSelector)</span> </span>&#123;   Assert.state(deferredImportSelector <span class="hljs-keyword">instanceof</span> AutoConfigurationImportSelector,         () -&gt; String.format(<span class="hljs-string">"Only %s implementations are supported, got %s"</span>,               AutoConfigurationImportSelector<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getSimpleName</span>(),</span><span class="hljs-class">               <span class="hljs-title">deferredImportSelector</span>.<span class="hljs-title">getClass</span>().<span class="hljs-title">getName</span>()))</span>;   AutoConfigurationEntry autoConfigurationEntry = ((AutoConfigurationImportSelector) deferredImportSelector)         .getAutoConfigurationEntry(getAutoConfigurationMetadata(), annotationMetadata);   <span class="hljs-keyword">this</span>.autoConfigurationEntries.add(autoConfigurationEntry);   <span class="hljs-keyword">for</span> (String importClassName : autoConfigurationEntry.getConfigurations()) &#123;      <span class="hljs-keyword">this</span>.entries.putIfAbsent(importClassName, annotationMetadata);   &#125;&#125;</code></pre><p>getAutoConfigurationEntry()方法</p><p>该方法首先会通过getCandidateConfigurations()方法获取到META-INF/spring.factories中所有键为EnableAutoConfiguration.class的类，这里也是SPI的运用。然后对类进行过滤后封装为AutoConfigurationEntry对象。</p><p>springboot主要是通过SPI加载配置文件的方式，把类加载到spring容器完成实例化。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> AutoConfigurationEntry <span class="hljs-title">getAutoConfigurationEntry</span><span class="hljs-params">(AutoConfigurationMetadata autoConfigurationMetadata,</span></span><span class="hljs-function"><span class="hljs-params">      AnnotationMetadata annotationMetadata)</span> </span>&#123;   <span class="hljs-keyword">if</span> (!isEnabled(annotationMetadata)) &#123;      <span class="hljs-keyword">return</span> EMPTY_ENTRY;   &#125;   AnnotationAttributes attributes = getAttributes(annotationMetadata);   <span class="hljs-comment">// SPI获取EnableAutoConfiguration为key的所有实现类</span>   List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);   configurations = removeDuplicates(configurations);   Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);   checkExcludedClasses(configurations, exclusions);   configurations.removeAll(exclusions);   <span class="hljs-comment">// 把某些自动配置类过滤掉</span>   configurations = filter(configurations, autoConfigurationMetadata);   fireAutoConfigurationImportEvents(configurations, exclusions);   <span class="hljs-comment">// 包装成自动配置实体类</span>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AutoConfigurationEntry(configurations, exclusions);&#125;</code></pre><h3 id="AOP的自动配置"><a href="#AOP的自动配置" class="headerlink" title="AOP的自动配置"></a>AOP的自动配置</h3><p>AopAutoConfiguration类默认会开启@EnableAspectJAutoProxy注解，注意这里使用了@ConditionalOnProperty注解，判断<code>spring.aop.auto</code>的值，为true和缺失时都会加载，matchIfMissing在cglib的配置中为true，所以默认是采用cglib代理的。如果要使用jdk的需要在配置文件中加入<code>spring.aop.proxy-target-class=false</code>。其他自动配置的代码基本相同，都是采用@Conditional注解来判断是否加载，不再分析。</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>(proxyBeanMethods = <span class="hljs-keyword">false</span>)<span class="hljs-meta">@ConditionalOnProperty</span>(prefix = <span class="hljs-string">"spring.aop"</span>, name = <span class="hljs-string">"auto"</span>, havingValue = <span class="hljs-string">"true"</span>, matchIfMissing = <span class="hljs-keyword">true</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AopAutoConfiguration</span> </span>&#123;   <span class="hljs-meta">@Configuration</span>(proxyBeanMethods = <span class="hljs-keyword">false</span>)   <span class="hljs-meta">@ConditionalOnClass</span>(Advice<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">   <span class="hljs-title">static</span> <span class="hljs-title">class</span> <span class="hljs-title">AspectJAutoProxyingConfiguration</span> </span>&#123;      <span class="hljs-meta">@Configuration</span>(proxyBeanMethods = <span class="hljs-keyword">false</span>)      <span class="hljs-meta">@EnableAspectJAutoProxy</span>(proxyTargetClass = <span class="hljs-keyword">false</span>)      <span class="hljs-meta">@ConditionalOnProperty</span>(prefix = <span class="hljs-string">"spring.aop"</span>, name = <span class="hljs-string">"proxy-target-class"</span>, havingValue = <span class="hljs-string">"false"</span>,            matchIfMissing = <span class="hljs-keyword">false</span>)      <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdkDynamicAutoProxyConfiguration</span> </span>&#123;      &#125;      <span class="hljs-meta">@Configuration</span>(proxyBeanMethods = <span class="hljs-keyword">false</span>)      <span class="hljs-meta">@EnableAspectJAutoProxy</span>(proxyTargetClass = <span class="hljs-keyword">true</span>)      <span class="hljs-meta">@ConditionalOnProperty</span>(prefix = <span class="hljs-string">"spring.aop"</span>, name = <span class="hljs-string">"proxy-target-class"</span>, havingValue = <span class="hljs-string">"true"</span>,            matchIfMissing = <span class="hljs-keyword">true</span>)      <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CglibAutoProxyConfiguration</span> </span>&#123;      &#125;   &#125;   <span class="hljs-meta">@Configuration</span>(proxyBeanMethods = <span class="hljs-keyword">false</span>)   <span class="hljs-meta">@ConditionalOnMissingClass</span>(<span class="hljs-string">"org.aspectj.weaver.Advice"</span>)   <span class="hljs-meta">@ConditionalOnProperty</span>(prefix = <span class="hljs-string">"spring.aop"</span>, name = <span class="hljs-string">"proxy-target-class"</span>, havingValue = <span class="hljs-string">"true"</span>,         matchIfMissing = <span class="hljs-keyword">true</span>)   <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassProxyingConfiguration</span> </span>&#123;      ClassProxyingConfiguration(BeanFactory beanFactory) &#123;         <span class="hljs-keyword">if</span> (beanFactory <span class="hljs-keyword">instanceof</span> BeanDefinitionRegistry) &#123;            BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;            AopConfigUtils.registerAutoProxyCreatorIfNecessary(registry);            AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);         &#125;      &#125;   &#125;&#125;</code></pre><h3 id="Conditional"><a href="#Conditional" class="headerlink" title="@Conditional"></a>@Conditional</h3><p>上面的代码中出现了@ConditionalOnProperty注解，这个是用来判断条件是否满足，通常与@Bean配合使用，完成有条件的初始化类的需求。spring的自动配置类中的组件初始化时，也会通过这个注解来决定是否初始化类。</p><p>常用的有：</p><ul><li><code>@ConditionalOnBean(name=&quot;test&quot;)</code>：当spring容器中有name为test的bean时再进行加载</li><li><code>@ConditionalOnClass(name=&quot;com.demo.TestController&quot;)</code>：当上下文中有com.demo.TestController时再进行加载</li><li><code>@ConditionalOnMissingClass(name=&quot;com.demo.TestController&quot;)</code>：与上面的相反，当上下文中没有com.demo.TestController时再进行加载</li><li><code>@ConditionalOnExpression(&quot;${spring.datasource.max-idle}=10&quot;)</code>：当spring.datasource.max-idle属性的值为10在进行加载</li></ul><p>还可以通过实现Condition接口来自定义Condition</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomCondition</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Condition</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;        System.out.println(<span class="hljs-string">"=====CustomCondition.matches======"</span>);        String property = context.getEnvironment().getProperty(<span class="hljs-string">"spring.redis.jedis.pool.max-active"</span>);        <span class="hljs-keyword">if</span>(<span class="hljs-string">"8"</span>.equals(property)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;    &#125;&#125;</code></pre><p>然后使用@Conditional注解将值设置为自定义的Condition。</p><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-meta">@Conditional</span>(value = CustomCondition<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">User</span> <span class="hljs-title">conditionalTest</span>() </span>&#123;    System.out.println(<span class="hljs-string">"======ConfigFamliy.conditionalTest"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User();&#125;</code></pre><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>实现原理也比较简单，spring完成BeanDefinition收集之后，会使用ConfigurationClassPostProcessor进行处理，所以只要在ConfigurationClassPostProcessor完成Condition的功能即可。</p><p>ConfigurationClassPostProcessor会调用到ConfigurationClassParser类的processConfigurationClass()方法，该方法会调用shouldSkip()方法对类进行过滤。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processConfigurationClass</span><span class="hljs-params">(ConfigurationClass configClass)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    <span class="hljs-comment">// 根据Condition接口来过滤类</span>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) &#123;        ConfigurationClass existingClass = (ConfigurationClass)<span class="hljs-keyword">this</span>.configurationClasses.get(configClass);        <span class="hljs-keyword">if</span> (existingClass != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">if</span> (configClass.isImported()) &#123;                <span class="hljs-keyword">if</span> (existingClass.isImported()) &#123;                    existingClass.mergeImportedBy(configClass);                &#125;                <span class="hljs-keyword">return</span>;            &#125;            <span class="hljs-keyword">this</span>.configurationClasses.remove(configClass);            <span class="hljs-keyword">this</span>.knownSuperclasses.values().removeIf(configClass::equals);        &#125;        ConfigurationClassParser.SourceClass sourceClass = <span class="hljs-keyword">this</span>.asSourceClass(configClass);        <span class="hljs-keyword">do</span> &#123;            sourceClass = <span class="hljs-keyword">this</span>.doProcessConfigurationClass(configClass, sourceClass);        &#125; <span class="hljs-keyword">while</span>(sourceClass != <span class="hljs-keyword">null</span>);        <span class="hljs-keyword">this</span>.configurationClasses.put(configClass, configClass);    &#125;&#125;</code></pre><p>shouldSkip()方法会获取到该类对应的所有Condition，然后调用matches()方法进行判断。</p><h5 id="matches-方法"><a href="#matches-方法" class="headerlink" title="matches()方法"></a>matches()方法</h5><p>AnnotatedTypeMetadata中包含类的所有信息、ConditionOutcome用来封装匹配之后的结果。getMatchOutcome()会到用到子类</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;   String classOrMethodName = getClassOrMethodName(metadata);   <span class="hljs-keyword">try</span> &#123;      <span class="hljs-comment">// 典型的钩子方法，调到用具体子类中方法。ConditionOutcome 这个类里面包装了是否需</span>      <span class="hljs-comment">// 跳过和打印的日志</span>      ConditionOutcome outcome = getMatchOutcome(context, metadata);      logOutcome(classOrMethodName, outcome);      recordEvaluation(context, classOrMethodName, outcome);      <span class="hljs-keyword">return</span> outcome.isMatch();   &#125;   <span class="hljs-keyword">catch</span> (NoClassDefFoundError ex) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Could not evaluate condition on "</span> + classOrMethodName + <span class="hljs-string">" due to "</span>            + ex.getMessage() + <span class="hljs-string">" not found. Make sure your own configuration does not rely on "</span>            + <span class="hljs-string">"that class. This can also happen if you are "</span>            + <span class="hljs-string">"@ComponentScanning a springframework package (e.g. if you "</span>            + <span class="hljs-string">"put a @ComponentScan in the default package by mistake)"</span>, ex);   &#125;   <span class="hljs-keyword">catch</span> (RuntimeException ex) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Error processing condition on "</span> + getName(metadata), ex);   &#125;&#125;</code></pre><h6 id="OnClassCondition类的getMatchOutcome-方法"><a href="#OnClassCondition类的getMatchOutcome-方法" class="headerlink" title="OnClassCondition类的getMatchOutcome()方法"></a>OnClassCondition类的getMatchOutcome()方法</h6><p>该方法会使用Class.forname()寻找ConditionalOnClass注解中的类，如果有异常就说明上下文中没有这个类，就过滤掉。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ConditionOutcome <span class="hljs-title">getMatchOutcome</span><span class="hljs-params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;   ClassLoader classLoader = context.getClassLoader();   ConditionMessage matchMessage = ConditionMessage.empty();   List&lt;String&gt; onClasses = getCandidates(metadata, ConditionalOnClass<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;   <span class="hljs-keyword">if</span> (onClasses != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-comment">// 核心方法，过滤一下，其实就是Class.forname一下ConditionalOnClass注解中的类，如果有异常就说明</span>      <span class="hljs-comment">// 上下文中没这个类，没有就过滤掉</span>      List&lt;String&gt; missing = filter(onClasses, ClassNameFilter.MISSING, classLoader);      <span class="hljs-keyword">if</span> (!missing.isEmpty()) &#123;         <span class="hljs-keyword">return</span> ConditionOutcome.noMatch(ConditionMessage.forCondition(ConditionalOnClass<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>               .didNotFind("required class", "required classes").items(Style.QUOTE, missing));      &#125;      matchMessage = matchMessage.andCondition(ConditionalOnClass<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>            .found("required class", "required classes")            .items(Style.QUOTE, filter(onClasses, ClassNameFilter.PRESENT, classLoader));   &#125;   List&lt;String&gt; onMissingClasses = getCandidates(metadata, ConditionalOnMissingClass<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;   <span class="hljs-keyword">if</span> (onMissingClasses != <span class="hljs-keyword">null</span>) &#123;      List&lt;String&gt; present = filter(onMissingClasses, ClassNameFilter.PRESENT, classLoader);      <span class="hljs-keyword">if</span> (!present.isEmpty()) &#123;         <span class="hljs-keyword">return</span> ConditionOutcome.noMatch(ConditionMessage.forCondition(ConditionalOnMissingClass<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>               .found("unwanted class", "unwanted classes").items(Style.QUOTE, present));      &#125;      matchMessage = matchMessage.andCondition(ConditionalOnMissingClass<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>            .didNotFind("unwanted class", "unwanted classes")            .items(Style.QUOTE, filter(onMissingClasses, ClassNameFilter.MISSING, classLoader));   &#125;   <span class="hljs-keyword">return</span> ConditionOutcome.match(matchMessage);&#125;</code></pre><h6 id="OnClassCondition类的getMatchOutcome-方法-1"><a href="#OnClassCondition类的getMatchOutcome-方法-1" class="headerlink" title="OnClassCondition类的getMatchOutcome()方法"></a>OnClassCondition类的getMatchOutcome()方法</h6><p>核心方法是判断spring容器中是否有ConditionalOnBean注解中的Bean。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ConditionOutcome <span class="hljs-title">getMatchOutcome</span><span class="hljs-params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;   ConditionMessage matchMessage = ConditionMessage.empty();   <span class="hljs-comment">// 获取类上面的注解</span>   MergedAnnotations annotations = metadata.getAnnotations();   <span class="hljs-keyword">if</span> (annotations.isPresent(ConditionalOnBean<span class="hljs-class">.<span class="hljs-keyword">class</span>)) </span>&#123;      <span class="hljs-comment">// 包装一下</span>      Spec&lt;ConditionalOnBean&gt; spec = <span class="hljs-keyword">new</span> Spec&lt;&gt;(context, metadata, annotations, ConditionalOnBean<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;      <span class="hljs-comment">// 核心方法，其实就是判断spring容器中是否有ConditionalOnBean注解中的bean</span>      MatchResult matchResult = getMatchingBeans(context, spec);      <span class="hljs-keyword">if</span> (!matchResult.isAllMatched()) &#123;         String reason = createOnBeanNoMatchReason(matchResult);         <span class="hljs-keyword">return</span> ConditionOutcome.noMatch(spec.message().because(reason));      &#125;      matchMessage = spec.message(matchMessage).found(<span class="hljs-string">"bean"</span>, <span class="hljs-string">"beans"</span>).items(Style.QUOTE,            matchResult.getNamesOfAllMatches());   &#125;   <span class="hljs-keyword">if</span> (metadata.isAnnotated(ConditionalOnSingleCandidate<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getName</span>())) </span>&#123;      Spec&lt;ConditionalOnSingleCandidate&gt; spec = <span class="hljs-keyword">new</span> SingleCandidateSpec(context, metadata, annotations);      MatchResult matchResult = getMatchingBeans(context, spec);      <span class="hljs-keyword">if</span> (!matchResult.isAllMatched()) &#123;         <span class="hljs-keyword">return</span> ConditionOutcome.noMatch(spec.message().didNotFind(<span class="hljs-string">"any beans"</span>).atAll());      &#125;      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!hasSingleAutowireCandidate(context.getBeanFactory(), matchResult.getNamesOfAllMatches(),            spec.getStrategy() == SearchStrategy.ALL)) &#123;         <span class="hljs-keyword">return</span> ConditionOutcome.noMatch(spec.message().didNotFind(<span class="hljs-string">"a primary bean from beans"</span>)               .items(Style.QUOTE, matchResult.getNamesOfAllMatches()));      &#125;      matchMessage = spec.message(matchMessage).found(<span class="hljs-string">"a primary bean from beans"</span>).items(Style.QUOTE,            matchResult.getNamesOfAllMatches());   &#125;   <span class="hljs-keyword">if</span> (metadata.isAnnotated(ConditionalOnMissingBean<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getName</span>())) </span>&#123;      Spec&lt;ConditionalOnMissingBean&gt; spec = <span class="hljs-keyword">new</span> Spec&lt;&gt;(context, metadata, annotations,            ConditionalOnMissingBean<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;      MatchResult matchResult = getMatchingBeans(context, spec);      <span class="hljs-keyword">if</span> (matchResult.isAnyMatched()) &#123;         String reason = createOnMissingBeanNoMatchReason(matchResult);         <span class="hljs-keyword">return</span> ConditionOutcome.noMatch(spec.message().because(reason));      &#125;      matchMessage = spec.message(matchMessage).didNotFind(<span class="hljs-string">"any beans"</span>).atAll();   &#125;   <span class="hljs-keyword">return</span> ConditionOutcome.match(matchMessage);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>SpringBoot源码解析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springboot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Springboot各种组件的整合</title>
    <link href="/blog/2020/04/22/springboot-%E4%B8%8E%E5%90%84%E7%A7%8D%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88/"/>
    <url>/blog/2020/04/22/springboot-%E4%B8%8E%E5%90%84%E7%A7%8D%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h2 id="springboot工程搭建"><a href="#springboot工程搭建" class="headerlink" title="springboot工程搭建"></a>springboot工程搭建</h2><p>springboot工程的搭建十分简单</p><ol><li>继承父工程</li></ol><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.6.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span></code></pre><ol start="2"><li>导入web启动器</li></ol><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><ol start="3"><li>启动类</li></ol><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span>(scanBasePackages = &#123;<span class="hljs-string">"com.demo.springboot"</span>&#125;)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringbootTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SpringBootServletInitializer</span> </span>&#123;    <span class="hljs-comment">/*</span><span class="hljs-comment">     * 1、完成Spring容器的启动</span><span class="hljs-comment">     * 2、把项目部署到tomcat</span><span class="hljs-comment">     * */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ConfigurableApplicationContext applicationContext = SpringApplication.run(SpringbootTest<span class="hljs-class">.<span class="hljs-keyword">class</span>,</span><span class="hljs-class">                <span class="hljs-title">args</span>)</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> SpringApplicationBuilder <span class="hljs-title">configure</span><span class="hljs-params">(SpringApplicationBuilder builder)</span> </span>&#123;        <span class="hljs-keyword">return</span> builder.sources(SpringBootTest<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    &#125;&#125;</code></pre><h2 id="Servlet、Filter、Listener的整合"><a href="#Servlet、Filter、Listener的整合" class="headerlink" title="Servlet、Filter、Listener的整合"></a>Servlet、Filter、Listener的整合</h2><p>只需要在启动类上加入<code>@ServletComponentScan(basePackages = {&quot;com.demo.springboot&quot;})</code>注解，然后在Servlet、Filter、Listener上加入相应的@WebFilter、@WebListener、@WebServlet注解即可，spring就会在初始化时扫描这些注解并把Servlet、Filter、Listener加入到spring容器中。</p><pre><code class="hljs java"><span class="hljs-meta">@WebFilter</span>(urlPatterns = <span class="hljs-string">"/*"</span>,filterName = <span class="hljs-string">"myFilter"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;        System.out.println(<span class="hljs-string">"--------MyFilter----------"</span>);        chain.doFilter(request,response);    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-meta">@WebListener</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ServletContextListener</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">contextDestroyed</span><span class="hljs-params">(ServletContextEvent contextEvent)</span> </span>&#123;        System.out.println(<span class="hljs-string">"contextDestroyed"</span>); &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">contextInitialized</span><span class="hljs-params">(ServletContextEvent contextEvent)</span> </span>&#123;        System.out.println(<span class="hljs-string">"contextInitialized"</span>); &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-meta">@WebServlet</span>(urlPatterns = <span class="hljs-string">"/jack/*"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1L</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">JackServlet</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">super</span>();    &#125;        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request,</span></span><span class="hljs-function"><span class="hljs-params">            HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        System.out.println(<span class="hljs-string">"-----------------doGet-----------------------"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest request,</span></span><span class="hljs-function"><span class="hljs-params">            HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        System.out.println(<span class="hljs-string">"------------------doPost----------------------"</span>);    &#125;    &#125;</code></pre><h2 id="druid多数据源及数据监控的整合"><a href="#druid多数据源及数据监控的整合" class="headerlink" title="druid多数据源及数据监控的整合"></a>druid多数据源及数据监控的整合</h2><p>Druid对数据库连接的管理比较优秀，而且还提供了可以实时监控数据库连接对象和数据库操作记录的监控界面。通过以下配置后就可以动态的切换数据源，使用方法为在方法上加入<code>@TargetDataSource</code>注解，如切换为ds2数据源<code>@TargetDataSource(name=&quot;ds2&quot;)</code>。durid监控界面的地址为{ip}:{port}/{contextPath}/druid/index.html</p><p>maven中引入jar包</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.26<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.mchange<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>c3p0<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.9.5.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.41<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h3 id="druid配置文件"><a href="#druid配置文件" class="headerlink" title="druid配置文件"></a>druid配置文件</h3><p><code>@ConfigurationProperties(prefix = &quot;spring.druid&quot;,ignoreInvalidFields = true)</code>的作用为读取默认的配置文件application.properties配置，以spring.druid作为前缀读取变量名对应的属性。要使用这个注解必须使用<code>@EnableConfigurationProperties(DruidConfig.class)</code>开启配置文件读取功能</p><p>需要注意默认是读取的application.properties配置文件，配置文件不在默认文件中需要在类中引入配置文件例如：<code>@PropertySource(value = &quot;classpath:druid.properties&quot;)</code></p><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">"spring.druid"</span>, ignoreInvalidFields = <span class="hljs-keyword">true</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DruidConfig</span> </span>&#123;    <span class="hljs-keyword">private</span> String driverClassName;    <span class="hljs-keyword">private</span> String jdbcUrl1;    <span class="hljs-keyword">private</span> String jdbcUrl2;    <span class="hljs-keyword">private</span> String username1;    <span class="hljs-keyword">private</span> String password1;    <span class="hljs-keyword">private</span> String username2;    <span class="hljs-keyword">private</span> String password2;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> maxActive;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> minIdle;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> initialSize;    <span class="hljs-keyword">private</span> Long timeBetweenEvictionRunsMillis;    <span class="hljs-keyword">private</span> Long minEvictableIdleTimeMillis;    <span class="hljs-keyword">private</span> String validationQuery;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> testWhileIdle;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> testOnBorrow;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> testOnReturn;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> poolPreparedStatements;    <span class="hljs-keyword">private</span> Integer maxPoolPreparedStatementPerConnectionSize;    <span class="hljs-keyword">private</span> String filters;    <span class="hljs-keyword">private</span> String connectionProperties;    <span class="hljs-meta">@Bean</span>(destroyMethod = <span class="hljs-string">"close"</span>, initMethod = <span class="hljs-string">"init"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">getDs1</span><span class="hljs-params">()</span> </span>&#123;        DruidDataSource druidDataSource = <span class="hljs-keyword">new</span> DruidDataSource();        druidDataSource.setDriverClassName(driverClassName);        druidDataSource.setUrl(jdbcUrl1);        druidDataSource.setUsername(username1);        druidDataSource.setPassword(password1);        druidDataSource.setMaxActive(maxActive);        druidDataSource.setInitialSize(initialSize);        druidDataSource.setTimeBetweenConnectErrorMillis(timeBetweenEvictionRunsMillis);        druidDataSource.setMinEvictableIdleTimeMillis(minEvictableIdleTimeMillis);        druidDataSource.setValidationQuery(validationQuery);        druidDataSource.setTestWhileIdle(testWhileIdle);        druidDataSource.setTestOnBorrow(testOnBorrow);        druidDataSource.setTestOnReturn(testOnReturn);        druidDataSource.setPoolPreparedStatements(poolPreparedStatements);        druidDataSource.setMaxPoolPreparedStatementPerConnectionSize(maxPoolPreparedStatementPerConnectionSize);        <span class="hljs-keyword">try</span> &#123;            druidDataSource.setFilters(filters);        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">return</span> druidDataSource;    &#125;    <span class="hljs-meta">@Bean</span>(destroyMethod = <span class="hljs-string">"close"</span>, initMethod = <span class="hljs-string">"init"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">getDs2</span><span class="hljs-params">()</span> </span>&#123;        DruidDataSource druidDataSource = <span class="hljs-keyword">new</span> DruidDataSource();        druidDataSource.setDriverClassName(driverClassName);        druidDataSource.setUrl(jdbcUrl2);        druidDataSource.setUsername(username2);        druidDataSource.setPassword(password2);        druidDataSource.setMaxActive(maxActive);        druidDataSource.setInitialSize(initialSize);        druidDataSource.setTimeBetweenConnectErrorMillis(timeBetweenEvictionRunsMillis);        druidDataSource.setMinEvictableIdleTimeMillis(minEvictableIdleTimeMillis);        druidDataSource.setValidationQuery(validationQuery);        druidDataSource.setTestWhileIdle(testWhileIdle);        druidDataSource.setTestOnBorrow(testOnBorrow);        druidDataSource.setTestOnReturn(testOnReturn);        druidDataSource.setPoolPreparedStatements(poolPreparedStatements);        druidDataSource.setMaxPoolPreparedStatementPerConnectionSize(maxPoolPreparedStatementPerConnectionSize);        <span class="hljs-keyword">try</span> &#123;            druidDataSource.setFilters(filters);        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">return</span> druidDataSource;    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">dynamicDataSource</span><span class="hljs-params">()</span> </span>&#123;        Map&lt;Object, Object&gt; targetDataSources = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        DataSource ds1 = getDs1();        targetDataSources.put(<span class="hljs-string">"ds1"</span>, ds1);        targetDataSources.put(<span class="hljs-string">"ds2"</span>, getDs2());        DynamicDataSource dynamicDataSource = <span class="hljs-keyword">new</span> DynamicDataSource();        dynamicDataSource.setTargetDataSources(targetDataSources);        dynamicDataSource.setDefaultTargetDataSource(ds1);        DynamicDataSourceContextHolder.dataSourceIds.add(<span class="hljs-string">"ds1"</span>);        DynamicDataSourceContextHolder.dataSourceIds.add(<span class="hljs-string">"ds2"</span>);        <span class="hljs-keyword">return</span> dynamicDataSource;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 配置访问druid监控</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ServletRegistrationBean <span class="hljs-title">druidStateViewServlet</span><span class="hljs-params">()</span> </span>&#123;        ServletRegistrationBean servletRegistrationBean = <span class="hljs-keyword">new</span> ServletRegistrationBean(<span class="hljs-keyword">new</span> StatViewServlet(), <span class="hljs-string">"/druid/*"</span>);        <span class="hljs-comment">//初始化参数initParams</span>        <span class="hljs-comment">//添加白名单</span>        servletRegistrationBean.addInitParameter(<span class="hljs-string">"allow"</span>, <span class="hljs-string">""</span>);        <span class="hljs-comment">//添加ip黑名单</span>        servletRegistrationBean.addInitParameter(<span class="hljs-string">"deny"</span>, <span class="hljs-string">"192.168.16.111"</span>);        <span class="hljs-comment">//登录查看信息的账号密码</span>        servletRegistrationBean.addInitParameter(<span class="hljs-string">"loginUsername"</span>, <span class="hljs-string">"admin"</span>);        servletRegistrationBean.addInitParameter(<span class="hljs-string">"loginPassword"</span>, <span class="hljs-string">"123"</span>);        <span class="hljs-comment">//是否能够重置数据</span>        servletRegistrationBean.addInitParameter(<span class="hljs-string">"resetEnable"</span>, <span class="hljs-string">"false"</span>);        <span class="hljs-keyword">return</span> servletRegistrationBean;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 过滤不需要监控的后缀</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> FilterRegistrationBean <span class="hljs-title">druidStatFilter</span><span class="hljs-params">()</span> </span>&#123;        FilterRegistrationBean filterRegistrationBean = <span class="hljs-keyword">new</span> FilterRegistrationBean(<span class="hljs-keyword">new</span> WebStatFilter());        <span class="hljs-comment">//添加过滤规则</span>        filterRegistrationBean.addUrlPatterns(<span class="hljs-string">"/*"</span>);        <span class="hljs-comment">//添加不需要忽略的格式信息</span>        filterRegistrationBean.addInitParameter(<span class="hljs-string">"exclusions"</span>, <span class="hljs-string">"*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*"</span>);        <span class="hljs-keyword">return</span> filterRegistrationBean;    &#125;&#125;</code></pre><h3 id="application-properties"><a href="#application-properties" class="headerlink" title="application.properties"></a>application.properties</h3><pre><code class="hljs properties"><span class="hljs-meta">spring.druid.jdbcUrl1</span>=<span class="hljs-string">jdbc:mysql://localhost/test</span><span class="hljs-meta">spring.druid.jdbcUrl2</span>=<span class="hljs-string">jdbc:mysql://localhost/test</span><span class="hljs-meta">spring.druid.username1</span>=<span class="hljs-string"></span><span class="hljs-meta">spring.druid.password1</span>=<span class="hljs-string"></span><span class="hljs-meta">spring.druid.username2</span>=<span class="hljs-string"></span><span class="hljs-meta">spring.druid.password2</span>=<span class="hljs-string"></span><span class="hljs-meta">spring.druid.initialSize</span>=<span class="hljs-string">2</span><span class="hljs-meta">spring.druid.minIdle</span>=<span class="hljs-string">2</span><span class="hljs-meta">spring.druid.maxActive</span>=<span class="hljs-string">2</span><span class="hljs-meta">spring.druid.maxWait</span>=<span class="hljs-string">60000</span><span class="hljs-meta">spring.druid.timeBetweenEvictionRunsMillis</span>=<span class="hljs-string">60000</span><span class="hljs-meta">spring.druid.minEvictableIdleTimeMillis</span>=<span class="hljs-string">300000</span><span class="hljs-meta">spring.druid.validationQuery</span>=<span class="hljs-string">SELECT 1 FROM DUAL</span><span class="hljs-meta">spring.druid.testWhileIdle</span>=<span class="hljs-string">true</span><span class="hljs-meta">spring.druid.testOnBorrow</span>=<span class="hljs-string">false</span><span class="hljs-meta">spring.druid.testOnReturn</span>=<span class="hljs-string">false</span><span class="hljs-meta">spring.druid.poolPreparedStatements</span>=<span class="hljs-string">true</span><span class="hljs-meta">spring.druid.maxPoolPreparedStatementPerConnectionSize</span>=<span class="hljs-string">20</span><span class="hljs-meta">spring.druid.filters</span>=<span class="hljs-string">stat,wall</span><span class="hljs-meta">spring.druid.connectionProperties</span>=<span class="hljs-string">druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000</span></code></pre><h3 id="多数据源切面"><a href="#多数据源切面" class="headerlink" title="多数据源切面"></a>多数据源切面</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DynamicDataSource</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractRoutingDataSource</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">determineCurrentLookupKey</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            Field targetF = <span class="hljs-keyword">this</span>.getClass().getSuperclass().getDeclaredField(<span class="hljs-string">"targetDataSources"</span>);            targetF.setAccessible(<span class="hljs-keyword">true</span>);            Map&lt;Object, Object&gt; targetV = (Map&lt;Object, Object&gt;) targetF.get(<span class="hljs-keyword">this</span>);            String ds = DynamicDataSourceContextHolder.getDataSourceType();            <span class="hljs-keyword">if</span> (ds != <span class="hljs-keyword">null</span>) &#123;                System.out.println(<span class="hljs-string">"操作的数据源是： "</span>                        + ds + <span class="hljs-string">"-&gt;url:"</span> + ((DruidDataSource) targetV.get(ds)).getUrl());            &#125;            <span class="hljs-keyword">return</span> DynamicDataSourceContextHolder.getDataSourceType();        &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-string">"ds1"</span>;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><span class="hljs-meta">@Order</span>(-<span class="hljs-number">1</span>)<span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DynamicDataSourceAspect</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger logger = LoggerFactory.getLogger(DynamicDataSourceAspect<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-meta">@Before</span>(<span class="hljs-string">"@annotation(ds)"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">changeDataSource</span><span class="hljs-params">(JoinPoint point, TargetDataSource ds)</span> </span>&#123;        <span class="hljs-comment">//这个就是数据源标识</span>        String dsId = ds.name();        <span class="hljs-keyword">if</span> (!DynamicDataSourceContextHolder.containsDataSource(dsId)) &#123;            logger.error(<span class="hljs-string">"数据源[&#123;&#125;]不存在，使用默认数据源 &gt; &#123;&#125;"</span>, ds.name(),                    point.getSignature());        &#125; <span class="hljs-keyword">else</span> &#123;            logger.debug(<span class="hljs-string">"使用数据源[&#123;&#125;] &gt; &#123;&#125;"</span>, ds.name(), point.getSignature());            <span class="hljs-comment">//如果容器中有数据源，那么就把数据源标识设置到ThreadLocal中</span>            DynamicDataSourceContextHolder.setDataSourceType(dsId);        &#125;    &#125;    <span class="hljs-meta">@After</span>(<span class="hljs-string">"@annotation(ds)"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">releaseLocal</span><span class="hljs-params">(JoinPoint point, TargetDataSource ds)</span> </span>&#123;        logger.info(<span class="hljs-string">"释放ds："</span> + ds.name() + <span class="hljs-string">"的ThreadLocal绑定"</span>);        <span class="hljs-keyword">if</span> (DynamicDataSourceContextHolder.getDataSourceType() != <span class="hljs-keyword">null</span>) &#123;            DynamicDataSourceContextHolder.getContextHolder().remove();        &#125;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DynamicDataSourceContextHolder</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;String&gt; contextHolder = <span class="hljs-keyword">new</span> ThreadLocal&lt;String&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;String&gt; <span class="hljs-title">getContextHolder</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> contextHolder;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; dataSourceIds = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDataSourceType</span><span class="hljs-params">(String dataSourceType)</span> </span>&#123;        contextHolder.set(dataSourceType);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getDataSourceType</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> contextHolder.get();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">containsDataSource</span><span class="hljs-params">(String dataSourceId)</span> </span>&#123;        <span class="hljs-keyword">return</span> dataSourceIds.contains(dataSourceId);    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-meta">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)<span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-meta">@Documented</span><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> TargetDataSource &#123;    <span class="hljs-function">String <span class="hljs-title">name</span><span class="hljs-params">()</span></span>;&#125;</code></pre><p>如果要使用但数据源也很简单，只要去掉切面注解、dynamicDataSource()方法上的@Bean即可。</p><h2 id="整合ORM框架"><a href="#整合ORM框架" class="headerlink" title="整合ORM框架"></a>整合ORM框架</h2><h3 id="mybatis"><a href="#mybatis" class="headerlink" title="mybatis"></a>mybatis</h3><p>pom文件中引入</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>在启动类添加扫描注解<code>@MapperScan(&quot;com.demo.springboot&quot;)</code></p><p>application.properties</p><pre><code class="hljs properties"><span class="hljs-comment">#配置该包下的bean别名</span><span class="hljs-meta">mybatis.typeAliasesPackage</span>=<span class="hljs-string">com.demo.mybatis.bean</span><span class="hljs-comment">#解析该路径下的xm建立接口映射关系</span><span class="hljs-meta">mybatis.mapperLocations</span>=<span class="hljs-string">classpath:mapper/*Mapper.xml</span></code></pre><p>注：如果出现xml找不到的情况可以在pom文件的build标签中加入以下内容</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/java<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.txt<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.keystore<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span></code></pre><h3 id="JPA"><a href="#JPA" class="headerlink" title="JPA"></a>JPA</h3><p>pom文件中加入</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>application.properties</p><pre><code class="hljs properties"><span class="hljs-comment">#设置为create时会自动创建表 </span><span class="hljs-meta">spring.jpa.hibernate.ddl-auto</span>=<span class="hljs-string">update</span><span class="hljs-comment">#打印sql语句</span><span class="hljs-meta">spring.jpa.show-sql</span>=<span class="hljs-string">true</span></code></pre><p>entity</p><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@Entity</span><span class="hljs-meta">@Table</span>(name = <span class="hljs-string">"studnet"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;    <span class="hljs-meta">@Id</span>    <span class="hljs-meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-meta">@Column</span>(name = <span class="hljs-string">"name"</span>)    <span class="hljs-keyword">private</span> String name;    <span class="hljs-meta">@Column</span>(name = <span class="hljs-string">"card_num"</span>)    <span class="hljs-keyword">private</span> String cardNum;&#125;</code></pre><p>dao</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">StudentDao</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">Student</span>,<span class="hljs-title">Integer</span>&gt; </span>&#123;&#125;</code></pre><p>业务代码中的使用</p><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StudentServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">StudentService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> StudentDao studentDao;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">()</span> </span>&#123;        Student s = <span class="hljs-keyword">new</span> Student();        s.setId(<span class="hljs-number">1</span>);        s.setName(<span class="hljs-string">"name"</span>);        s.setCardNum(<span class="hljs-string">"123123123"</span>);        studentDao.save(s);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Student&gt; <span class="hljs-title">getAll</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> studentDao.findAll();    &#125;&#125;</code></pre><h2 id="整合Atomikos"><a href="#整合Atomikos" class="headerlink" title="整合Atomikos"></a>整合Atomikos</h2><p> Atomikos是一个基于XA协议的分布式事务解决管理框架，其核心思想就是两段提交，一般使用在涉及到的对多个数据源的操作的业务方法中，保证对两个数据源的同时提交和同时回滚。</p><img src="/blog/2020/04/22/springboot-%E4%B8%8E%E5%90%84%E7%A7%8D%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88/pic1.png" srcset="/blog/img/loading.gif" class><p>Atomikos就是图中的事务协调器的角色，负责对两个数据源的管理，同时提交或同时回滚。 就是在真正提交之前有一个预提交的过程，就是检测两个数据源是否能够提交， 如果有一个返回 No，那么这个事务就不能提交。</p><p>pom中引入</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-jta-atomikos<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>application.properties文件中</p><pre><code class="hljs properties"><span class="hljs-comment"># Mysql 1</span><span class="hljs-meta">mysql.datasource.test1.url</span> = <span class="hljs-string">jdbc:mysql://localhost:3307/test?useUnicode=true&amp;characterEncoding=utf-8</span><span class="hljs-meta">mysql.datasource.test1.username</span> = <span class="hljs-string"></span><span class="hljs-meta">mysql.datasource.test1.password</span> = <span class="hljs-string"></span><span class="hljs-meta">mysql.datasource.test1.minPoolSize</span> = <span class="hljs-string">3</span><span class="hljs-meta">mysql.datasource.test1.maxPoolSize</span> = <span class="hljs-string">25</span><span class="hljs-meta">mysql.datasource.test1.maxLifetime</span> = <span class="hljs-string">20000</span><span class="hljs-meta">mysql.datasource.test1.borrowConnectionTimeout</span> = <span class="hljs-string">30</span><span class="hljs-meta">mysql.datasource.test1.loginTimeout</span> = <span class="hljs-string">30</span><span class="hljs-meta">mysql.datasource.test1.maintenanceInterval</span> = <span class="hljs-string">60</span><span class="hljs-meta">mysql.datasource.test1.maxIdleTime</span> = <span class="hljs-string">60</span><span class="hljs-comment"># Mysql 2</span><span class="hljs-meta">mysql.datasource.test2.url</span> =<span class="hljs-string">jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf-8</span><span class="hljs-meta">mysql.datasource.test2.username</span> =<span class="hljs-string"></span><span class="hljs-meta">mysql.datasource.test2.password</span> =<span class="hljs-string"></span><span class="hljs-meta">mysql.datasource.test2.minPoolSize</span> = <span class="hljs-string">3</span><span class="hljs-meta">mysql.datasource.test2.maxPoolSize</span> = <span class="hljs-string">25</span><span class="hljs-meta">mysql.datasource.test2.maxLifetime</span> = <span class="hljs-string">20000</span><span class="hljs-meta">mysql.datasource.test2.borrowConnectionTimeout</span> = <span class="hljs-string">30</span><span class="hljs-meta">mysql.datasource.test2.loginTimeout</span> = <span class="hljs-string">30</span><span class="hljs-meta">mysql.datasource.test2.maintenanceInterval</span> = <span class="hljs-string">60</span><span class="hljs-meta">mysql.datasource.test2.maxIdleTime</span> = <span class="hljs-string">60</span><span class="hljs-meta">logging.level.root</span>=<span class="hljs-string">info</span><span class="hljs-comment">#logging.level.org.springframework.*=debug</span><span class="hljs-meta">logging.level.com.xiangxue.atomikos.db1.dao</span>=<span class="hljs-string">debug</span><span class="hljs-meta">logging.level.com.xiangxue.atomikos.db2.dao</span>=<span class="hljs-string">debug</span><span class="hljs-meta">spring.devtools.restart.enabled</span>=<span class="hljs-string">true</span><span class="hljs-meta">spring.devtools.restart.additional-paths</span>=<span class="hljs-string">src/main/java</span><span class="hljs-meta">spring.devtools.restart.exclude</span>=<span class="hljs-string">WEB-INF/**</span></code></pre><p>数据源创建，这里只列举一个数据源的创建，另一个创建方式与这个相同。</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@MapperScan</span>(basePackages = <span class="hljs-string">"com.demo.atomikos.db1.dao"</span>, sqlSessionFactoryRef = <span class="hljs-string">"test1SqlSessionFactory"</span>,sqlSessionTemplateRef=<span class="hljs-string">"test1SqlSessionTemplate"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Db1Config</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    DBConfig1 testConfig;    <span class="hljs-meta">@Bean</span>(name = <span class="hljs-string">"test1DataSource"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">testDataSource</span><span class="hljs-params">()</span> </span>&#123;        MysqlXADataSource mysqlXaDataSource = <span class="hljs-keyword">new</span> MysqlXADataSource();        mysqlXaDataSource.setUrl(testConfig.getUrl());        mysqlXaDataSource.setPinGlobalTxToPhysicalConnection(<span class="hljs-keyword">true</span>);        mysqlXaDataSource.setPassword(testConfig.getPassword());        mysqlXaDataSource.setUser(testConfig.getUsername());        mysqlXaDataSource.setPinGlobalTxToPhysicalConnection(<span class="hljs-keyword">true</span>);        AtomikosDataSourceBean xaDataSource = <span class="hljs-keyword">new</span> AtomikosDataSourceBean();        xaDataSource.setXaDataSource(mysqlXaDataSource);        xaDataSource.setUniqueResourceName(<span class="hljs-string">"test1DataSource"</span>);        xaDataSource.setMinPoolSize(testConfig.getMinPoolSize());        xaDataSource.setMaxPoolSize(testConfig.getMaxPoolSize());        xaDataSource.setMaxLifetime(testConfig.getMaxLifetime());        xaDataSource.setBorrowConnectionTimeout(testConfig.getBorrowConnectionTimeout());        <span class="hljs-keyword">try</span> &#123;            xaDataSource.setLoginTimeout(testConfig.getLoginTimeout());        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;            e.printStackTrace();        &#125;        xaDataSource.setMaintenanceInterval(testConfig.getMaintenanceInterval());        xaDataSource.setMaxIdleTime(testConfig.getMaxIdleTime());        xaDataSource.setTestQuery(testConfig.getTestQuery());        <span class="hljs-keyword">return</span> xaDataSource;    &#125;    <span class="hljs-meta">@Bean</span>(name = <span class="hljs-string">"test1SqlSessionFactory"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> SqlSessionFactory <span class="hljs-title">testSqlSessionFactory</span><span class="hljs-params">(@Qualifier(<span class="hljs-string">"test1DataSource"</span>)</span> DataSource dataSource)</span><span class="hljs-function">            <span class="hljs-keyword">throws</span> Exception </span>&#123;        SqlSessionFactoryBean bean = <span class="hljs-keyword">new</span> SqlSessionFactoryBean();        bean.setDataSource(dataSource);        <span class="hljs-keyword">return</span> bean.getObject();    &#125;    <span class="hljs-meta">@Bean</span>(name = <span class="hljs-string">"test1SqlSessionTemplate"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> SqlSessionTemplate <span class="hljs-title">testSqlSessionTemplate</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">            @Qualifier(<span class="hljs-string">"test1SqlSessionFactory"</span>)</span> SqlSessionFactory sqlSessionFactory) <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SqlSessionTemplate(sqlSessionFactory);    &#125;&#125;</code></pre><p>具体使用</p><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AreaServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AreaService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> CommonMapper1 commonMapper1;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> CommonMapper2 commonMapper2;    <span class="hljs-meta">@Autowired</span>    TransactionManager transactionManager;    <span class="hljs-meta">@Transactional</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">saveArea</span><span class="hljs-params">(ConsultConfigArea area)</span> </span>&#123;        System.out.println(transactionManager);        JtaTransactionManager jtaTransactionManager = (JtaTransactionManager)transactionManager;        System.out.println(jtaTransactionManager.getUserTransaction());        UserTransaction userTransaction = jtaTransactionManager.getUserTransaction();        <span class="hljs-keyword">int</span> count = commonMapper1.addArea(area);        <span class="hljs-keyword">int</span> count1 = commonMapper2.addArea(area);        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">true</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"xx"</span>);        <span class="hljs-keyword">return</span> count;    &#125;&#125;</code></pre><p>这里 spring 事务已经交给 atomikos 来管理了，其实就是由 atomikos 中的 JtaTransationManager 来管理事务，重写了 commit 和 Rollback 和 getTransaction 方法，只是 commit 和 Rollback 是对两个数据源的操作而已。</p><h2 id="整合redis"><a href="#整合redis" class="headerlink" title="整合redis"></a>整合redis</h2><p>pom文件</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>application.prperties文件</p><pre><code class="hljs properties"><span class="hljs-meta">spring.redis.database</span>=<span class="hljs-string">0</span><span class="hljs-meta">spring.redis.host</span>=<span class="hljs-string">192.168.0.1</span><span class="hljs-meta">spring.redis.port</span>=<span class="hljs-string">6379</span><span class="hljs-meta">spring.redis.password</span>=<span class="hljs-string"></span><span class="hljs-meta">spring.redis.pool.max-active</span>=<span class="hljs-string">8</span><span class="hljs-meta">spring.redis.pool.max-wait</span>=<span class="hljs-string">-1</span><span class="hljs-meta">spring.redis.pool.max-idle</span>=<span class="hljs-string">8</span><span class="hljs-meta">spring.redis.pool.min-idle</span>=<span class="hljs-string">0</span><span class="hljs-meta">spring.redis.timeout</span>=<span class="hljs-string">0</span></code></pre><p>redis.config</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableCaching</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisConfig</span> </span>&#123;    <span class="hljs-comment">//缓存管理器</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> CacheManager <span class="hljs-title">cacheManager</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;        RedisCacheConfiguration redisCacheConfiguration = RedisCacheConfiguration.defaultCacheConfig()                .entryTtl(Duration.ofHours(<span class="hljs-number">1</span>)); <span class="hljs-comment">// 设置缓存有效期一小时</span>        <span class="hljs-keyword">return</span> RedisCacheManager                .builder(RedisCacheWriter.nonLockingRedisCacheWriter(redisConnectionFactory))                .cacheDefaults(redisCacheConfiguration).build();    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="hljs-title">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory factory)</span> </span>&#123;        RedisTemplate&lt;String, Object&gt; template = <span class="hljs-keyword">new</span> RedisTemplate&lt;&gt;();        <span class="hljs-comment">// 配置连接工厂</span>        template.setConnectionFactory(factory);        <span class="hljs-comment">//使用Jackson2JsonRedisSerializer来序列化和反序列化redis的value值（默认使用JDK的序列化方式）</span>        Jackson2JsonRedisSerializer jacksonSeial = <span class="hljs-keyword">new</span> Jackson2JsonRedisSerializer(Object<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        ObjectMapper om = <span class="hljs-keyword">new</span> ObjectMapper();        <span class="hljs-comment">// 指定要序列化的域，field,get和set,以及修饰符范围，ANY是都有包括private和public</span>        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);        <span class="hljs-comment">// 指定序列化输入的类型，类必须是非final修饰的，final修饰的类，比如String,Integer等会跑出异常</span>        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);        jacksonSeial.setObjectMapper(om);        <span class="hljs-comment">// 值采用json序列化</span>        template.setValueSerializer(jacksonSeial);        <span class="hljs-comment">//使用StringRedisSerializer来序列化和反序列化redis的key值</span>        template.setKeySerializer(<span class="hljs-keyword">new</span> StringRedisSerializer());        <span class="hljs-comment">// 设置hash key 和value序列化模式</span>        template.setHashKeySerializer(<span class="hljs-keyword">new</span> StringRedisSerializer());        template.setHashValueSerializer(jacksonSeial);        template.afterPropertiesSet();        <span class="hljs-keyword">return</span> template;    &#125;&#125;</code></pre><p>在业务代码中只要在方法上面加上@Cacheable@CachePut 注解就可以了，spring就会把业务代码的返回结果存到redis中。还可以通过直接注入RedisTemplate来使用。</p><h2 id="整合mongodb"><a href="#整合mongodb" class="headerlink" title="整合mongodb"></a>整合mongodb</h2><p>pom文件</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-mongodb<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>application.properteis</p><pre><code class="hljs properties"><span class="hljs-meta">spring.data.mongodb.uri</span>=<span class="hljs-string">mongodb://192.168.0.1:27017/xx_db</span></code></pre><p>代码案例</p><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MongoServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MongoService</span>&lt;<span class="hljs-title">User</span>&gt; </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> MongoTemplate mongoTemplate;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">save</span><span class="hljs-params">(User obj)</span> </span>&#123;        mongoTemplate.save(obj);        <span class="hljs-keyword">return</span> <span class="hljs-string">"1"</span>;    &#125;&#125;</code></pre><p>mongoTemplate对象同样可以通过依赖注入获取到。</p><h2 id="springboot整合JAX-RS规范"><a href="#springboot整合JAX-RS规范" class="headerlink" title="springboot整合JAX-RS规范"></a>springboot整合JAX-RS规范</h2><p>JAX-RS是JAVAEE6引入的一个新技术。JAX-RS即JavaAPIforRESTfulWebServices，是一个Java编程语言的应用程序接口，支持按照表述性状态转移(REST)架构风格创建Web服务。JAX-RS使用了JavaSE5引入的Java注解来简化Web服务的客户端和服务端的开发和部署。springcloud中就是用了JAX-RS规范，其实就是类似于Servlet规范来接收用户请求的一个规范。</p><p>pom文件</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-jersey<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>代码配置</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JerseyConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ServletRegistrationBean <span class="hljs-title">jerseyServlet</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//设置拦截路径</span>        ServletRegistrationBean registrationBean = <span class="hljs-keyword">new</span> ServletRegistrationBean(<span class="hljs-keyword">new</span> ServletContainer(), <span class="hljs-string">"/rest/*"</span>);        <span class="hljs-comment">//注册controller</span>        registrationBean.addInitParameter(ServletProperties.JAXRS_APPLICATION_CLASS, JerseyResourceConfig<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getName</span>())</span>;        <span class="hljs-keyword">return</span> registrationBean;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JerseyResourceConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ResourceConfig</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">JerseyResourceConfig</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 扫描某个类</span>        register(RequestContextFilter<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        <span class="hljs-comment">// 扫描包下的所有类</span>        packages(<span class="hljs-string">"com.demo.jersey"</span>);    &#125;&#125;</code></pre><p>具体使用</p><pre><code class="hljs java"><span class="hljs-meta">@Path</span>(<span class="hljs-string">"/jersey/"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JerseyController</span> </span>&#123;    <span class="hljs-meta">@Path</span>(<span class="hljs-string">"&#123;id&#125;"</span>)    <span class="hljs-meta">@GET</span>    <span class="hljs-meta">@Produces</span>(MediaType.APPLICATION_JSON)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(@PathParam(<span class="hljs-string">"id"</span>)</span> Long id) </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello"</span>;    &#125;&#125;</code></pre><h2 id="整合jsp"><a href="#整合jsp" class="headerlink" title="整合jsp"></a>整合jsp</h2><p>pom文件</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>tomcat-embed-jasper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jstl<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>application.properties</p><pre><code class="hljs properties"><span class="hljs-meta">spring.mvc.view.prefix</span>=<span class="hljs-string">/WEB-INF/jsp/</span><span class="hljs-meta">spring.mvc.view.suffix</span>=<span class="hljs-string">.jsp</span></code></pre><p>创建resources平级目录webapp然后将jsp放入/WEB-INF/jsp/后就可以正常使用。</p><h2 id="整合freemarker"><a href="#整合freemarker" class="headerlink" title="整合freemarker"></a>整合freemarker</h2><p>jar包导入</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-freemarker<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>application.properties文件</p><pre><code class="hljs properties"><span class="hljs-meta">spring.freemarker.allow-request-override</span>=<span class="hljs-string">false</span><span class="hljs-meta">spring.freemarker.cache</span>=<span class="hljs-string">true</span><span class="hljs-meta">spring.freemarker.check-template-location</span>=<span class="hljs-string">true</span><span class="hljs-meta">spring.freemarker.charset</span>=<span class="hljs-string">UTF-8</span><span class="hljs-meta">spring.freemarker.content-type</span>=<span class="hljs-string">text/html</span><span class="hljs-meta">spring.freemarker.expose-request-attributes</span>=<span class="hljs-string">false</span><span class="hljs-meta">spring.freemarker.expose-session-attributes</span>=<span class="hljs-string">false</span><span class="hljs-meta">spring.freemarker.expose-spring-macro-helpers</span>=<span class="hljs-string">false</span></code></pre><p>freemarker默认会加载resources下的.ftl后缀文件</p><h2 id="整合swagger2"><a href="#整合swagger2" class="headerlink" title="整合swagger2"></a>整合swagger2</h2><p>pom文件</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>代码配置</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableSwagger</span>2<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SwaggerConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">createRestApi</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2)                .pathMapping(<span class="hljs-string">"/"</span>)                .select()                .apis(RequestHandlerSelectors.basePackage(<span class="hljs-string">"com.demo.controller"</span>))                .paths(PathSelectors.any())                .build().apiInfo(<span class="hljs-keyword">new</span> ApiInfoBuilder()                        .title(<span class="hljs-string">"xx公司API文档"</span>)                        .description(<span class="hljs-string">"xx公司API文档"</span>)                        .version(<span class="hljs-string">"9.0"</span>)                        .contact(<span class="hljs-keyword">new</span> Contact(<span class="hljs-string">"test"</span>, <span class="hljs-string">"blog.csdn.net"</span>, <span class="hljs-string">"aaa@gmail.com"</span>))                        .license(<span class="hljs-string">"The Apache License"</span>)                        .licenseUrl(<span class="hljs-string">"http://www.baidu.com"</span>)                        .build());    &#125;&#125;</code></pre><p>具体使用</p><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-meta">@Api</span>(tags = <span class="hljs-string">"springboot学习工程相关接口"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JackController</span> </span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger logger = LoggerFactory.getLogger(JackController<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        <span class="hljs-meta">@Autowired</span>    AreaService areaService;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;application.field:default value jack&#125;"</span>)    <span class="hljs-keyword">private</span> String zhuguangField = <span class="hljs-string">""</span>;    <span class="hljs-meta">@ApiOperation</span>(<span class="hljs-string">"查询地区接口"</span>)    <span class="hljs-meta">@ApiImplicitParams</span>(&#123;            <span class="hljs-meta">@ApiImplicitParam</span>(name = <span class="hljs-string">"param"</span>, value = <span class="hljs-string">"地区编码"</span>)    &#125;)    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/queryArea"</span>)    <span class="hljs-keyword">public</span> <span class="hljs-meta">@ResponseBody</span> <span class="hljs-function">String <span class="hljs-title">queryArea</span><span class="hljs-params">(String param)</span> </span>&#123;        List&lt;ConsultConfigArea&gt; areas = areaService.qryArea(<span class="hljs-keyword">new</span> HashMap());        <span class="hljs-keyword">for</span> (ConsultConfigArea area : areas) &#123;            logger.info(area.getAreaCode() + <span class="hljs-string">"   "</span> + area.getAreaName() + <span class="hljs-string">"   "</span>                    + area.getState());        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-string">"OK"</span>;    &#125;&#125;</code></pre><p>文档地址<code>localhost:8080/swagger-ui.html</code></p><h2 id="整合-Actuator监控管理"><a href="#整合-Actuator监控管理" class="headerlink" title="整合 Actuator监控管理"></a>整合 Actuator监控管理</h2><p>Actuator监控是一个用于监控springboot健康状况的工具，可以实时监控的工程的健康和调用情况，通常配合springboot-admin使用。</p><p>pom文件中</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>application.properties配置</p><pre><code class="hljs properties"><span class="hljs-comment">#默认只有info、health接口</span><span class="hljs-meta">management.endpoints.web.exposure.include</span>=<span class="hljs-string">*</span></code></pre><p>这个监控不需要使用，是自动统计消息的。可以通过一下请求获取到系统信息：</p><ul><li><p>/health/{component}/{instance}：GET报告程序的健康指标，这些数据由HealthIndicator实现类提供</p></li><li><p>/info：GET获取程序指定发布的信息，这些信息由配置文件中info打头的属性提供</p></li><li><p>/configprops：GET描述配置属性(包含默认值)如何注入到bean</p></li><li><p>/beans：GET描述程序中的bean，及之间的依赖关系</p></li><li><p>/env：GET获取全部环境属性</p></li><li><p>/env/{name}：GET根据名称获取指定的环境属性值</p></li><li><p>/mappings：GET描述全部的URI路径，及和控制器的映射关系</p></li><li><p>/metrics/{requiredMetricName}：GET统计程序的各种度量信息，如内存用量和请求数</p></li><li><p>/httptrace：GET提供基本的http请求跟踪信息，如请求头等</p></li><li><p>/threaddump：GET获取线程活动的快照</p></li><li><p>/conditions：GET提供自动配置报告，记录哪些自动配置通过，哪些没有通过</p></li><li><p>/loggers/{name}：GET查看日志配置信息</p></li><li><p>/auditevents：GET查看系统发布的事件信息</p></li><li><p>/caches/{cache}：GET/DELETE查看系统的缓存管理器，另可根据缓存管理器名称查询;另DELETE操作</p></li><li><p>/scheduledtasks：GET查看系统发布的定时任务信息</p></li><li><p>/features：GET查看Springcloud全家桶组件信息</p></li><li><p>/refresh：POST重启应用程序，慎用</p></li><li><p>/shutdown：POST关闭应用程序，慎用</p></li></ul><h2 id="整合https"><a href="#整合https" class="headerlink" title="整合https"></a>整合https</h2><p>进入到jdk的bin目录中，执行生成证书的指令：</p><pre><code class="hljs angelscript">keytool -genkey -alias spring -keypass <span class="hljs-number">123456</span> -keyalg RSA -keysize <span class="hljs-number">1024</span> -validity <span class="hljs-number">365</span> -keystore E:/springboot.keystore -storepass <span class="hljs-number">123456</span></code></pre><p>参数介绍：</p><ul><li><p>genkey：表示要创建一个新的密钥。</p></li><li><p>alias：表示keystore的别名。</p></li><li><p>keyalg：表示使用的加密算法是RSA，一种非对称加密算法。</p></li><li><p>keysize：表示密钥的长度。</p></li><li><p>keystore：表示生成的密钥存放位置。validity表示密钥的有效时间，单位为天。</p></li></ul><p>注意：在正式开发过程中，需要申请正式的、能够被浏览器信任的证书。</p><p>然后将生成的证书复制到resource目录，在application.properties配置：</p><pre><code class="hljs properties"><span class="hljs-meta">server.port</span>=<span class="hljs-string">8881</span><span class="hljs-meta">server.ssl.key-password</span>=<span class="hljs-string">123456</span><span class="hljs-meta">server.ssl.key-store</span>=<span class="hljs-string">classpath:springboot.keystore</span><span class="hljs-meta">server.ssl.key-alias</span>=<span class="hljs-string">spring</span></code></pre><p>这时再使用http的访问方式就会出错。</p><h2 id="整合rabbitmq"><a href="#整合rabbitmq" class="headerlink" title="整合rabbitmq"></a>整合rabbitmq</h2><p>pom.xml中</p><pre><code class="hljs properties"><span class="hljs-attr">&lt;dependency&gt;</span>    <span class="hljs-attr">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span>    <span class="hljs-attr">&lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><span class="hljs-attr">&lt;/dependency&gt;</span></code></pre><p>application.properties</p><pre><code class="hljs properties"><span class="hljs-meta">spring.rabbitmq.host</span>=<span class="hljs-string">192.168.88.139</span><span class="hljs-meta">spring.rabbitmq.port</span>=<span class="hljs-string">5672</span><span class="hljs-meta">spring.rabbitmq.username</span>=<span class="hljs-string">admin</span><span class="hljs-meta">spring.rabbitmq.password</span>=<span class="hljs-string">admin</span></code></pre><p>配置类</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableRabbit</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitmqConfig</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 创建队列Queue</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Bean</span>(name = <span class="hljs-string">"message"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">queueMessage</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(<span class="hljs-string">"test.message"</span>);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 创建交换器Exchange</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> TopicExchange <span class="hljs-title">exchange</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TopicExchange(<span class="hljs-string">"exchange.message"</span>);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 创建Exchange跟Queue和routeKey的绑定关系bindings</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">Binding <span class="hljs-title">bindingExchangeMessage</span><span class="hljs-params">(@Qualifier(<span class="hljs-string">"message"</span>)</span>Queue queueMessage,TopicExchange exchange)</span>&#123;        <span class="hljs-keyword">return</span> BindingBuilder.bind(queueMessage)                .to(exchange)                .with(<span class="hljs-string">"test.message.routeKey"</span>);    &#125;&#125;</code></pre><p>发送消息</p><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><span class="hljs-keyword">private</span> AmqpTemplate amqpTemplate;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMessage</span><span class="hljs-params">()</span></span>&#123;    amqpTemplate.convertAndSend(<span class="hljs-string">"exchange.message"</span>,<span class="hljs-string">"test.message.routeKey"</span>,<span class="hljs-string">"hello"</span>);&#125;</code></pre><p>接受消息</p><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener</span>(queues = <span class="hljs-string">"test.message"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(String message)</span></span>&#123;    System.out.println(message);&#125;</code></pre><h2 id="docker化"><a href="#docker化" class="headerlink" title="docker化"></a>docker化</h2><p>pom文件中加入打包插件</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.spotify<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>docker-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">imageName</span>&gt;</span>demo/springboot<span class="hljs-tag">&lt;/<span class="hljs-name">imageName</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">dockerDirectory</span>&gt;</span>$&#123;project.basedir&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">dockerDirectory</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">targetPath</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">targetPath</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>$&#123;project.build.directory&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>$&#123;project.build.finalName&#125;.jar<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span></code></pre><p>在项目目录中创建Dockerfile文件</p><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> java:<span class="hljs-number">8</span><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span><span class="hljs-keyword">VOLUME</span><span class="bash"> /tmp</span><span class="hljs-keyword">ADD</span><span class="bash"> [<span class="hljs-string">"*.jar"</span>,<span class="hljs-string">"app.jar"</span>]</span><span class="hljs-keyword">ENTRYPOINT</span><span class="bash"> [<span class="hljs-string">"java"</span>,<span class="hljs-string">"-jar"</span>,<span class="hljs-string">"/app.jar"</span>]</span></code></pre><p>在项目目录下执行指令</p><pre><code class="hljs ada">mvn <span class="hljs-keyword">package</span> <span class="hljs-title">docker:build</span></code></pre><p>然后根据镜像来启动容器</p><pre><code class="hljs dockerfile">docker <span class="hljs-keyword">run</span><span class="bash"> -ti -d -p 8881:8881 --name springboot <span class="hljs-built_in">test</span>/springboot</span></code></pre><p>查看容器启动日志</p><pre><code class="hljs ebnf"><span class="hljs-attribute">docker logs -f springboot</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>SpringBoot源码解析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springboot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringMVC的请求响应分析</title>
    <link href="/blog/2020/04/21/springmvc-%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94/"/>
    <url>/blog/2020/04/21/springmvc-%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94/</url>
    
    <content type="html"><![CDATA[<h2 id="核心方法的入口"><a href="#核心方法的入口" class="headerlink" title="核心方法的入口"></a>核心方法的入口</h2><p>在servlet规范中，当请求到达servlet时首先会调用service()方法，此方法会根据请求的请求头调用不同的方法。</p><p>DispatcherServlet父类FrameworkServlet中的service()方法最终都会调用到processRequest()方法。通过super.service()方式会调用doPost()或者doGet()方法。本类中的doGet()、doPost()方法也会调用到processRequest()方法。</p><pre><code class="hljs java">   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span></span><span class="hljs-function">      <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;   HttpMethod httpMethod = HttpMethod.resolve(request.getMethod());   <span class="hljs-keyword">if</span> (httpMethod == HttpMethod.PATCH || httpMethod == <span class="hljs-keyword">null</span>) &#123;      processRequest(request, response);   &#125;   <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">super</span>.service(request, response);   &#125;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span></span><span class="hljs-function"><span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;processRequest(request, response);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span></span><span class="hljs-function"><span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;processRequest(request, response);&#125;</code></pre><p>processRequest()方法，主要逻辑为调用doService()方法。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processRequest</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span></span><span class="hljs-function">      <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;   <span class="hljs-keyword">long</span> startTime = System.currentTimeMillis();   Throwable failureCause = <span class="hljs-keyword">null</span>;   LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext();   LocaleContext localeContext = buildLocaleContext(request);   RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes();   ServletRequestAttributes requestAttributes = buildRequestAttributes(request, response, previousAttributes);   WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);   asyncManager.registerCallableInterceptor(FrameworkServlet<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getName</span>(), <span class="hljs-title">new</span> <span class="hljs-title">RequestBindingInterceptor</span>())</span>;   initContextHolders(request, localeContext, requestAttributes);   <span class="hljs-keyword">try</span> &#123;      doService(request, response);   &#125;   <span class="hljs-keyword">catch</span> (ServletException | IOException ex) &#123;      failureCause = ex;      <span class="hljs-keyword">throw</span> ex;   &#125;   <span class="hljs-keyword">catch</span> (Throwable ex) &#123;      failureCause = ex;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NestedServletException(<span class="hljs-string">"Request processing failed"</span>, ex);   &#125;   <span class="hljs-keyword">finally</span> &#123;      resetContextHolders(request, previousLocaleContext, previousAttributes);      <span class="hljs-keyword">if</span> (requestAttributes != <span class="hljs-keyword">null</span>) &#123;         requestAttributes.requestCompleted();      &#125;      logResult(request, response, failureCause, asyncManager);      publishRequestHandledEvent(request, response, startTime, failureCause);   &#125;&#125;</code></pre><p>doService()方法，该方法在DispatcherServlet中实现，在进行一些属性的设置后回到用到核心方法doDispatch()。</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doService</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;   logRequest(request);   <span class="hljs-comment">// Keep a snapshot of the request attributes in case of an include,</span>   <span class="hljs-comment">// to be able to restore the original attributes after the include.</span>   Map&lt;String, Object&gt; attributesSnapshot = <span class="hljs-keyword">null</span>;   <span class="hljs-keyword">if</span> (WebUtils.isIncludeRequest(request)) &#123;      attributesSnapshot = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();      Enumeration&lt;?&gt; attrNames = request.getAttributeNames();      <span class="hljs-keyword">while</span> (attrNames.hasMoreElements()) &#123;         String attrName = (String) attrNames.nextElement();         <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) &#123;            attributesSnapshot.put(attrName, request.getAttribute(attrName));         &#125;      &#125;   &#125;   <span class="hljs-comment">// Make framework objects available to handlers and view objects.</span>   request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());   request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, <span class="hljs-keyword">this</span>.localeResolver);   request.setAttribute(THEME_RESOLVER_ATTRIBUTE, <span class="hljs-keyword">this</span>.themeResolver);   request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.flashMapManager != <span class="hljs-keyword">null</span>) &#123;      FlashMap inputFlashMap = <span class="hljs-keyword">this</span>.flashMapManager.retrieveAndUpdate(request, response);      <span class="hljs-keyword">if</span> (inputFlashMap != <span class="hljs-keyword">null</span>) &#123;         request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));      &#125;      request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, <span class="hljs-keyword">new</span> FlashMap());      request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, <span class="hljs-keyword">this</span>.flashMapManager);   &#125;   <span class="hljs-keyword">try</span> &#123;      <span class="hljs-comment">//调用到核心流程</span>      doDispatch(request, response);   &#125;   <span class="hljs-keyword">finally</span> &#123;      <span class="hljs-keyword">if</span> (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;         <span class="hljs-comment">// Restore the original attribute snapshot, in case of an include.</span>         <span class="hljs-keyword">if</span> (attributesSnapshot != <span class="hljs-keyword">null</span>) &#123;            restoreAttributesAfterInclude(request, attributesSnapshot);         &#125;      &#125;   &#125;&#125;</code></pre><h2 id="核心方法-doDispatch"><a href="#核心方法-doDispatch" class="headerlink" title="核心方法-doDispatch()"></a>核心方法-doDispatch()</h2><p>springmvc的调用共分七个步骤</p><ol><li>通过getHandler()方法获取到HandlerExecutionChain对象。</li><li>调用getHanlderAdapter()方法根据HandlerExecutionChain对象获取到HandlerAdapter对象。</li><li>调用applyPreHandle()方法进行前置过滤器校验，如果为false直接返回。</li><li>handle()方法进行具体的业务逻辑调用。</li><li>调用applyPostHandle()方法执行中置过滤器方法。</li><li>调用processDispatchResult()进行视图渲染。</li><li>调用后置拦截器进行最后的收尾工作，一般是资源释放。</li></ol><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doDispatch</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;   HttpServletRequest processedRequest = request;   HandlerExecutionChain mappedHandler = <span class="hljs-keyword">null</span>;   <span class="hljs-keyword">boolean</span> multipartRequestParsed = <span class="hljs-keyword">false</span>;   <span class="hljs-comment">//异步管理</span>   WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);   <span class="hljs-keyword">try</span> &#123;      ModelAndView mv = <span class="hljs-keyword">null</span>;      Exception dispatchException = <span class="hljs-keyword">null</span>;      <span class="hljs-keyword">try</span> &#123;         <span class="hljs-comment">//文件上传</span>         processedRequest = checkMultipart(request);         multipartRequestParsed = (processedRequest != request);         <span class="hljs-comment">//这个方法很重要，重点看</span>         <span class="hljs-comment">// Determine handler for the current request.</span>         mappedHandler = getHandler(processedRequest);         <span class="hljs-keyword">if</span> (mappedHandler == <span class="hljs-keyword">null</span>) &#123;            noHandlerFound(processedRequest, response);            <span class="hljs-keyword">return</span>;         &#125;         <span class="hljs-comment">//获取跟HandlerMethod匹配的HandlerAdapter对象</span>         <span class="hljs-comment">// Determine handler adapter for the current request.</span>         HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());         <span class="hljs-comment">// Process last-modified header, if supported by the handler.</span>         String method = request.getMethod();         <span class="hljs-keyword">boolean</span> isGet = <span class="hljs-string">"GET"</span>.equals(method);         <span class="hljs-keyword">if</span> (isGet || <span class="hljs-string">"HEAD"</span>.equals(method)) &#123;            <span class="hljs-keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;               <span class="hljs-keyword">return</span>;            &#125;         &#125;         <span class="hljs-comment">//前置过滤器，如果为false则直接返回</span>         <span class="hljs-keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;            <span class="hljs-keyword">return</span>;         &#125;         <span class="hljs-comment">//调用到Controller具体方法，核心方法调用，重点看看</span>         <span class="hljs-comment">// Actually invoke the handler.</span>         mv = ha.handle(processedRequest, response, mappedHandler.getHandler());         <span class="hljs-keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;            <span class="hljs-keyword">return</span>;         &#125;                 applyDefaultViewName(processedRequest, mv);        <span class="hljs-comment">//中置过滤器</span>         mappedHandler.applyPostHandle(processedRequest, response, mv);      &#125;      <span class="hljs-keyword">catch</span> (Exception ex) &#123;         dispatchException = ex;      &#125;      <span class="hljs-keyword">catch</span> (Throwable err) &#123;         <span class="hljs-comment">// As of 4.3, we're processing Errors thrown from handler methods as well,</span>         <span class="hljs-comment">// making them available for @ExceptionHandler methods and other scenarios.</span>         dispatchException = <span class="hljs-keyword">new</span> NestedServletException(<span class="hljs-string">"Handler dispatch failed"</span>, err);      &#125;     <span class="hljs-comment">//视图渲染</span>      processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);   &#125;   <span class="hljs-keyword">catch</span> (Exception ex) &#123;      triggerAfterCompletion(processedRequest, response, mappedHandler, ex);   &#125;   <span class="hljs-keyword">catch</span> (Throwable err) &#123;      triggerAfterCompletion(processedRequest, response, mappedHandler,            <span class="hljs-keyword">new</span> NestedServletException(<span class="hljs-string">"Handler processing failed"</span>, err));   &#125;   <span class="hljs-keyword">finally</span> &#123;      <span class="hljs-keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;         <span class="hljs-comment">// Instead of postHandle and afterCompletion</span>         <span class="hljs-keyword">if</span> (mappedHandler != <span class="hljs-keyword">null</span>) &#123;            mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);         &#125;      &#125;      <span class="hljs-keyword">else</span> &#123;         <span class="hljs-comment">// Clean up any resources used by a multipart request.</span>         <span class="hljs-keyword">if</span> (multipartRequestParsed) &#123;            cleanupMultipart(processedRequest);         &#125;      &#125;   &#125;&#125;</code></pre><h3 id="getHandler-方法"><a href="#getHandler-方法" class="headerlink" title="getHandler()方法"></a>getHandler()方法</h3><p>该方法首先会通过getHandlerInternal()方法获取到HandlerMethod对象，然后调用getHandlerExecutionChain()方法匹配拦截器并将匹配到的拦截器跟HandlerMethod对象封装为HandlerExecutionChain对象并返回。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> HandlerExecutionChain <span class="hljs-title">getHandler</span><span class="hljs-params">(HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;   <span class="hljs-comment">//根据请求的uri拿到对应的HandlerMethod对象</span>   Object handler = getHandlerInternal(request);   <span class="hljs-keyword">if</span> (handler == <span class="hljs-keyword">null</span>) &#123;      handler = getDefaultHandler();   &#125;   <span class="hljs-keyword">if</span> (handler == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;   &#125;   <span class="hljs-comment">// Bean name or resolved handler?</span>   <span class="hljs-keyword">if</span> (handler <span class="hljs-keyword">instanceof</span> String) &#123;      String handlerName = (String) handler;      handler = obtainApplicationContext().getBean(handlerName);   &#125;   <span class="hljs-comment">//获取HandlerMethod和过滤器链的包装类</span>   HandlerExecutionChain executionChain = getHandlerExecutionChain(handler, request);   <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;      logger.trace(<span class="hljs-string">"Mapped to "</span> + handler);   &#125;   <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (logger.isDebugEnabled() &amp;&amp; !request.getDispatcherType().equals(DispatcherType.ASYNC)) &#123;      logger.debug(<span class="hljs-string">"Mapped to "</span> + executionChain.getHandler());   &#125;   <span class="hljs-comment">//是否是跨域请求,就是查看request请求头中是否有Origin属性</span>   <span class="hljs-keyword">if</span> (CorsUtils.isCorsRequest(request)) &#123;      CorsConfiguration globalConfig = <span class="hljs-keyword">this</span>.corsConfigurationSource.getCorsConfiguration(request);      CorsConfiguration handlerConfig = getCorsConfiguration(handler, request);      CorsConfiguration config = (globalConfig != <span class="hljs-keyword">null</span> ? globalConfig.combine(handlerConfig) : handlerConfig);      executionChain = getCorsHandlerExecutionChain(request, executionChain, config);   &#125;   <span class="hljs-keyword">return</span> executionChain;&#125;</code></pre><h4 id="getHandlerInternal-方法"><a href="#getHandlerInternal-方法" class="headerlink" title="getHandlerInternal()方法"></a>getHandlerInternal()方法</h4><p>getHandlerInternal()方法首先会从请求中获取uri，然后调用lookupHandlerMethod()方法获取到HandlerMethod对象。然后调用createWithResolvedBean()方法创建HandlerMethod中的bean。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> HandlerMethod <span class="hljs-title">getHandlerInternal</span><span class="hljs-params">(HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;   <span class="hljs-comment">//从request对象中获取uri，/common/query2</span>   String lookupPath = getUrlPathHelper().getLookupPathForRequest(request);   <span class="hljs-keyword">this</span>.mappingRegistry.acquireReadLock();   <span class="hljs-keyword">try</span> &#123;      <span class="hljs-comment">//根据uri从映射关系中找到对应的HandlerMethod对象</span>      HandlerMethod handlerMethod = lookupHandlerMethod(lookupPath, request);      <span class="hljs-comment">//把Controller类实例化</span>      <span class="hljs-keyword">return</span> (handlerMethod != <span class="hljs-keyword">null</span> ? handlerMethod.createWithResolvedBean() : <span class="hljs-keyword">null</span>);   &#125;   <span class="hljs-keyword">finally</span> &#123;      <span class="hljs-keyword">this</span>.mappingRegistry.releaseReadLock();   &#125;&#125;</code></pre><h5 id="lookupHandlerMethod-方法"><a href="#lookupHandlerMethod-方法" class="headerlink" title="lookupHandlerMethod()方法"></a>lookupHandlerMethod()方法</h5><p>该方法会根据uri从urlLookup中获取到RequestMappingInfo的List，然后调用addMatchingMappings()方法根据request的信息跟@ReqeustMaping中的信息对HandlerMethod进行匹配，最后将匹配后的RequestMappingInfo对象和匹配到的HandlerMethod对象封装到Match对象中。最后返回HandlerMethod对象。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> HandlerMethod <span class="hljs-title">lookupHandlerMethod</span><span class="hljs-params">(String lookupPath, HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;   List&lt;Match&gt; matches = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();   List&lt;T&gt; directPathMatches = <span class="hljs-keyword">this</span>.mappingRegistry.getMappingsByUrl(lookupPath);   <span class="hljs-keyword">if</span> (directPathMatches != <span class="hljs-keyword">null</span>) &#123;      addMatchingMappings(directPathMatches, matches, request);   &#125;   <span class="hljs-keyword">if</span> (matches.isEmpty()) &#123;      <span class="hljs-comment">// No choice but to go through all mappings...</span>      addMatchingMappings(<span class="hljs-keyword">this</span>.mappingRegistry.getMappings().keySet(), matches, request);   &#125;   <span class="hljs-keyword">if</span> (!matches.isEmpty()) &#123;      Comparator&lt;Match&gt; comparator = <span class="hljs-keyword">new</span> MatchComparator(getMappingComparator(request));      matches.sort(comparator);      Match bestMatch = matches.get(<span class="hljs-number">0</span>);      <span class="hljs-keyword">if</span> (matches.size() &gt; <span class="hljs-number">1</span>) &#123;         <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;            logger.trace(matches.size() + <span class="hljs-string">" matching mappings: "</span> + matches);         &#125;         <span class="hljs-keyword">if</span> (CorsUtils.isPreFlightRequest(request)) &#123;            <span class="hljs-keyword">return</span> PREFLIGHT_AMBIGUOUS_MATCH;         &#125;         Match secondBestMatch = matches.get(<span class="hljs-number">1</span>);         <span class="hljs-comment">//如果两个RequestMappinginfo什么都相同，报错</span>         <span class="hljs-keyword">if</span> (comparator.compare(bestMatch, secondBestMatch) == <span class="hljs-number">0</span>) &#123;            Method m1 = bestMatch.handlerMethod.getMethod();            Method m2 = secondBestMatch.handlerMethod.getMethod();            String uri = request.getRequestURI();            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(                  <span class="hljs-string">"Ambiguous handler methods mapped for '"</span> + uri + <span class="hljs-string">"': &#123;"</span> + m1 + <span class="hljs-string">", "</span> + m2 + <span class="hljs-string">"&#125;"</span>);         &#125;      &#125;      request.setAttribute(BEST_MATCHING_HANDLER_ATTRIBUTE, bestMatch.handlerMethod);      handleMatch(bestMatch.mapping, lookupPath, request);      <span class="hljs-keyword">return</span> bestMatch.handlerMethod;   &#125;   <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">return</span> handleNoMatch(<span class="hljs-keyword">this</span>.mappingRegistry.getMappings().keySet(), lookupPath, request);   &#125;&#125;</code></pre><h5 id="createWithResolvedBean-方法"><a href="#createWithResolvedBean-方法" class="headerlink" title="createWithResolvedBean()方法"></a>createWithResolvedBean()方法</h5><p>注意：此方法会重新创建一个HandlerMethod对象返回，原有对象不会进行修改。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> HandlerMethod <span class="hljs-title">createWithResolvedBean</span><span class="hljs-params">()</span> </span>&#123;    Object handler = <span class="hljs-keyword">this</span>.bean;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.bean <span class="hljs-keyword">instanceof</span> String) &#123;        Assert.state(<span class="hljs-keyword">this</span>.beanFactory != <span class="hljs-keyword">null</span>, <span class="hljs-string">"Cannot resolve bean name without BeanFactory"</span>);        String beanName = (String)<span class="hljs-keyword">this</span>.bean;        handler = <span class="hljs-keyword">this</span>.beanFactory.getBean(beanName);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HandlerMethod(<span class="hljs-keyword">this</span>, handler);&#125;</code></pre><h4 id="getHandlerExecutionChain-方法"><a href="#getHandlerExecutionChain-方法" class="headerlink" title="getHandlerExecutionChain()方法"></a>getHandlerExecutionChain()方法</h4><p>该方法首先会将HandlerMethod对象包装到HandlerExecutionChain对象中，然后根据uri获取到匹配的拦截器加入到HandlerExecutionChain对象中。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> HandlerExecutionChain <span class="hljs-title">getHandlerExecutionChain</span><span class="hljs-params">(Object handler, HttpServletRequest request)</span> </span>&#123;   <span class="hljs-comment">//把HandlerMethod对象包装到HandlerExecutionChain对象中，这个对象中有过滤器对象</span>   HandlerExecutionChain chain = (handler <span class="hljs-keyword">instanceof</span> HandlerExecutionChain ?         (HandlerExecutionChain) handler : <span class="hljs-keyword">new</span> HandlerExecutionChain(handler));   <span class="hljs-comment">//获取uri</span>   String lookupPath = <span class="hljs-keyword">this</span>.urlPathHelper.getLookupPathForRequest(request);   <span class="hljs-comment">//是否有过滤器</span>   <span class="hljs-keyword">for</span> (HandlerInterceptor interceptor : <span class="hljs-keyword">this</span>.adaptedInterceptors) &#123;      <span class="hljs-keyword">if</span> (interceptor <span class="hljs-keyword">instanceof</span> MappedInterceptor) &#123;         MappedInterceptor mappedInterceptor = (MappedInterceptor) interceptor;         <span class="hljs-keyword">if</span> (mappedInterceptor.matches(lookupPath, <span class="hljs-keyword">this</span>.pathMatcher)) &#123;            chain.addInterceptor(mappedInterceptor.getInterceptor());         &#125;      &#125;      <span class="hljs-keyword">else</span> &#123;         chain.addInterceptor(interceptor);      &#125;   &#125;   <span class="hljs-keyword">return</span> chain;&#125;</code></pre><p>根据request对象获取handlerMapping对象，然后根据handlerMapping对象获取匹配的HandlerAdapter对象，preHandle过滤器，然后handler方法会调用到controller中的具体方法，然后中置postHandler过滤器，试图渲染，rendler，afterCompletion后置过滤器。</p><h3 id="getHandlerAdapter-方法"><a href="#getHandlerAdapter-方法" class="headerlink" title="getHandlerAdapter()方法"></a>getHandlerAdapter()方法</h3><p>会循环HandlerExecutionChain对象，找到合适的HandlerAdapter对象，这里用到了策略模式。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> HandlerAdapter <span class="hljs-title">getHandlerAdapter</span><span class="hljs-params">(Object handler)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;   <span class="hljs-comment">//根据handlerMethod对象，找到合适的HandlerAdapter对象，这里用到了策略模式</span>   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.handlerAdapters != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">for</span> (HandlerAdapter adapter : <span class="hljs-keyword">this</span>.handlerAdapters) &#123;         <span class="hljs-keyword">if</span> (adapter.supports(handler)) &#123;            <span class="hljs-keyword">return</span> adapter;         &#125;      &#125;   &#125;   <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ServletException(<span class="hljs-string">"No adapter for handler ["</span> + handler +         <span class="hljs-string">"]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler"</span>);&#125;</code></pre><h3 id="applyPreHandle-方法"><a href="#applyPreHandle-方法" class="headerlink" title="applyPreHandle()方法"></a>applyPreHandle()方法</h3><p>该方法会调用HandlerExecutionChain中所有拦截器的preHandle()方法，如果为false直接返回，调用过程中会使用interceptorIndex记录拦截器的下标。常用来进行一些权限校验操作。</p><pre><code class="hljs reasonml">boolean apply<span class="hljs-constructor">PreHandle(HttpServletRequest <span class="hljs-params">request</span>, HttpServletResponse <span class="hljs-params">response</span>)</span> throws Exception &#123;   HandlerInterceptor<span class="hljs-literal">[]</span> interceptors = get<span class="hljs-constructor">Interceptors()</span>;   <span class="hljs-keyword">if</span> (!<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ObjectUtils</span>.</span></span>is<span class="hljs-constructor">Empty(<span class="hljs-params">interceptors</span>)</span>) &#123;      for (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; interceptors.length; i++) &#123;         HandlerInterceptor interceptor = interceptors<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>;         <span class="hljs-keyword">if</span> (!interceptor.pre<span class="hljs-constructor">Handle(<span class="hljs-params">request</span>, <span class="hljs-params">response</span>, <span class="hljs-params">this</span>.<span class="hljs-params">handler</span>)</span>) &#123;            trigger<span class="hljs-constructor">AfterCompletion(<span class="hljs-params">request</span>, <span class="hljs-params">response</span>, <span class="hljs-params">null</span>)</span>;            return <span class="hljs-literal">false</span>;         &#125;         this.interceptorIndex = i;      &#125;   &#125;   return <span class="hljs-literal">true</span>;&#125;</code></pre><h3 id="handle-方法"><a href="#handle-方法" class="headerlink" title="handle()方法"></a>handle()方法</h3><p>最终会调用到invokeHandlerMethod()方法，这里我们重点关注invokeAndHandle()方法。但要注意，本方法中每次创建一个ModelAndViewContainer对象，这个对象用于对@ModelAttribute注解方法的处理，并把方法返回值传入到ModelAndViewContainer的Map中，用于接来下进行的参数列表解析。最后会调用到getModelAndView()方法获取到ModelAndView对象并返回。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> ModelAndView <span class="hljs-title">invokeHandlerMethod</span><span class="hljs-params">(HttpServletRequest request,</span></span><span class="hljs-function"><span class="hljs-params">      HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;   ServletWebRequest webRequest = <span class="hljs-keyword">new</span> ServletWebRequest(request, response);   <span class="hljs-keyword">try</span> &#123;      <span class="hljs-comment">//获取数据绑定工厂</span>      WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);      <span class="hljs-comment">//Model工厂</span>      ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);      <span class="hljs-comment">//可调用的方法对象</span>      ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.argumentResolvers != <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-comment">//设置参数解析器</span>         invocableMethod.setHandlerMethodArgumentResolvers(<span class="hljs-keyword">this</span>.argumentResolvers);      &#125;      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.returnValueHandlers != <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-comment">//设置返回值解析器</span>         invocableMethod.setHandlerMethodReturnValueHandlers(<span class="hljs-keyword">this</span>.returnValueHandlers);      &#125;      <span class="hljs-comment">//设置参数绑定工厂</span>      invocableMethod.setDataBinderFactory(binderFactory);      <span class="hljs-comment">//设置参数名称解析类</span>      invocableMethod.setParameterNameDiscoverer(<span class="hljs-keyword">this</span>.parameterNameDiscoverer);      ModelAndViewContainer mavContainer = <span class="hljs-keyword">new</span> ModelAndViewContainer();      mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));      <span class="hljs-comment">//调用有@ModelAttribute注解的方法</span>      modelFactory.initModel(webRequest, mavContainer, invocableMethod);      mavContainer.setIgnoreDefaultModelOnRedirect(<span class="hljs-keyword">this</span>.ignoreDefaultModelOnRedirect);      AsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response);      asyncWebRequest.setTimeout(<span class="hljs-keyword">this</span>.asyncRequestTimeout);      <span class="hljs-comment">//异步处理</span>      WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);      asyncManager.setTaskExecutor(<span class="hljs-keyword">this</span>.taskExecutor);      asyncManager.setAsyncWebRequest(asyncWebRequest);      asyncManager.registerCallableInterceptors(<span class="hljs-keyword">this</span>.callableInterceptors);      asyncManager.registerDeferredResultInterceptors(<span class="hljs-keyword">this</span>.deferredResultInterceptors);      <span class="hljs-keyword">if</span> (asyncManager.hasConcurrentResult()) &#123;         Object result = asyncManager.getConcurrentResult();         mavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[<span class="hljs-number">0</span>];         asyncManager.clearConcurrentResult();         LogFormatUtils.traceDebug(logger, traceOn -&gt; &#123;            String formatted = LogFormatUtils.formatValue(result, !traceOn);            <span class="hljs-keyword">return</span> <span class="hljs-string">"Resume with async result ["</span> + formatted + <span class="hljs-string">"]"</span>;         &#125;);         invocableMethod = invocableMethod.wrapConcurrentResult(result);      &#125;      <span class="hljs-comment">//Controller方法调用，重点看看</span>      invocableMethod.invokeAndHandle(webRequest, mavContainer);      <span class="hljs-keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;      &#125;      <span class="hljs-keyword">return</span> getModelAndView(mavContainer, modelFactory, webRequest);   &#125;   <span class="hljs-keyword">finally</span> &#123;      webRequest.requestCompleted();   &#125;&#125;</code></pre><p>invokeAndHandle()方法</p><p>该方法会调用invokeForRequest()方法获取到返回值，然后使用handleReturnValue()方法对返回值进行处理。处理方式与入参的处理基本相同。如果为视图就会将viewName设置到mavContainer容器中，并将requestHandled属性设置为true。如果返回参数被@ResponseBody注解修饰，就不会设置requestHandled值，requestHandled默认值为false。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeAndHandle</span><span class="hljs-params">(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,</span></span><span class="hljs-function"><span class="hljs-params">      Object... providedArgs)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;   <span class="hljs-comment">//具体调用逻辑，重点看</span>   Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);   setResponseStatus(webRequest);   <span class="hljs-keyword">if</span> (returnValue == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">if</span> (isRequestNotModified(webRequest) || getResponseStatus() != <span class="hljs-keyword">null</span> || mavContainer.isRequestHandled()) &#123;         mavContainer.setRequestHandled(<span class="hljs-keyword">true</span>);         <span class="hljs-keyword">return</span>;      &#125;   &#125;   <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (StringUtils.hasText(getResponseStatusReason())) &#123;      mavContainer.setRequestHandled(<span class="hljs-keyword">true</span>);      <span class="hljs-keyword">return</span>;   &#125;   mavContainer.setRequestHandled(<span class="hljs-keyword">false</span>);   Assert.state(<span class="hljs-keyword">this</span>.returnValueHandlers != <span class="hljs-keyword">null</span>, <span class="hljs-string">"No return value handlers"</span>);   <span class="hljs-keyword">try</span> &#123;      <span class="hljs-keyword">this</span>.returnValueHandlers.handleReturnValue(            returnValue, getReturnValueType(returnValue), mavContainer, webRequest);   &#125;   <span class="hljs-keyword">catch</span> (Exception ex) &#123;      <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;         logger.trace(formatErrorForReturnValue(returnValue), ex);      &#125;      <span class="hljs-keyword">throw</span> ex;   &#125;&#125;</code></pre><p>invokeForRequest()方法</p><p>该方法首先通过getMethodArgumentValues()方法获取参数数组，然后使用反射调用并将返回值返回。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invokeForRequest</span><span class="hljs-params">(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,</span></span><span class="hljs-function"><span class="hljs-params">      Object... providedArgs)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;   <span class="hljs-comment">//获取参数数组,重点看</span>   Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);   <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;      logger.trace(<span class="hljs-string">"Arguments: "</span> + Arrays.toString(args));   &#125;   <span class="hljs-keyword">return</span> doInvoke(args);&#125;</code></pre><p>getMethodArgumentValues()方法</p><p>该方法会循环处理参数，首先会法判断参数是否有对应的处理类，判断方法为循环调用所有的HandlerMethodArgumentResolver处理类并调用supportsParameter()判断是否支持处理该参数。然后调用resolveArgument()方法获取到对应的处理类，并调用resolveArgument()方法对参数进行处理并包装为MethodParameter对象。</p><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Object[] getMethodArgumentValues(NativeWebRequest request, <span class="hljs-meta">@Nullable</span> ModelAndViewContainer mavContainer,      Object... providedArgs) <span class="hljs-keyword">throws</span> Exception &#123;   <span class="hljs-keyword">if</span> (ObjectUtils.isEmpty(getMethodParameters())) &#123;      <span class="hljs-keyword">return</span> EMPTY_ARGS;   &#125;   <span class="hljs-comment">//入参的包装类，里面包装了参数类型，参数名称，参数注解等等信息</span>   MethodParameter[] parameters = getMethodParameters();   Object[] args = <span class="hljs-keyword">new</span> Object[parameters.length];   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; parameters.length; i++) &#123;      MethodParameter parameter = parameters[i];      <span class="hljs-comment">//设置参数名称解析器</span>      parameter.initParameterNameDiscovery(<span class="hljs-keyword">this</span>.parameterNameDiscoverer);      args[i] = findProvidedArgument(parameter, providedArgs);      <span class="hljs-keyword">if</span> (args[i] != <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">continue</span>;      &#125;      <span class="hljs-comment">//典型的策略模式，根据parameter能否找到对应参数的处理类，能找到就返回true</span>      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.resolvers.supportsParameter(parameter)) &#123;         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(formatArgumentError(parameter, <span class="hljs-string">"No suitable resolver"</span>));      &#125;      <span class="hljs-keyword">try</span> &#123;         <span class="hljs-comment">//具体参数值解析过程,重点看看</span>         args[i] = <span class="hljs-keyword">this</span>.resolvers.resolveArgument(parameter, mavContainer, request, <span class="hljs-keyword">this</span>.dataBinderFactory);      &#125;      <span class="hljs-keyword">catch</span> (Exception ex) &#123;         <span class="hljs-comment">// Leave stack trace for later, exception may actually be resolved and handled..</span>         <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;            String error = ex.getMessage();            <span class="hljs-keyword">if</span> (error != <span class="hljs-keyword">null</span> &amp;&amp; !error.contains(parameter.getExecutable().toGenericString())) &#123;               logger.debug(formatArgumentError(parameter, error));            &#125;         &#125;         <span class="hljs-keyword">throw</span> ex;      &#125;   &#125;   <span class="hljs-keyword">return</span> args;&#125;</code></pre><p>getModelAndView()方法</p><p>该方法首先会判断requestHandled属性，如果属性为false就直接返回。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> ModelAndView <span class="hljs-title">getModelAndView</span><span class="hljs-params">(ModelAndViewContainer mavContainer,</span></span><span class="hljs-function"><span class="hljs-params">      ModelFactory modelFactory, NativeWebRequest webRequest)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;   modelFactory.updateModel(webRequest, mavContainer);   <span class="hljs-keyword">if</span> (mavContainer.isRequestHandled()) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;   &#125;   ModelMap model = mavContainer.getModel();   ModelAndView mav = <span class="hljs-keyword">new</span> ModelAndView(mavContainer.getViewName(), model, mavContainer.getStatus());   <span class="hljs-keyword">if</span> (!mavContainer.isViewReference()) &#123;      mav.setView((View) mavContainer.getView());   &#125;   <span class="hljs-keyword">if</span> (model <span class="hljs-keyword">instanceof</span> RedirectAttributes) &#123;      Map&lt;String, ?&gt; flashAttributes = ((RedirectAttributes) model).getFlashAttributes();      HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;      <span class="hljs-keyword">if</span> (request != <span class="hljs-keyword">null</span>) &#123;         RequestContextUtils.getOutputFlashMap(request).putAll(flashAttributes);      &#125;   &#125;   <span class="hljs-keyword">return</span> mav;&#125;</code></pre><h3 id="applyPostHandle-方法"><a href="#applyPostHandle-方法" class="headerlink" title="applyPostHandle()方法"></a>applyPostHandle()方法</h3><p>与前置过滤器的调用方法基本相同，不同的是他不需要进行判断，且与前置过滤器不同的是，它的遍历时倒序遍历。注意：中置过滤器中有ModelAndView入参可以对其进行处理。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">applyPostHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, @Nullable ModelAndView mv)</span></span><span class="hljs-function">      <span class="hljs-keyword">throws</span> Exception </span>&#123;   HandlerInterceptor[] interceptors = getInterceptors();   <span class="hljs-keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) &#123;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = interceptors.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;         HandlerInterceptor interceptor = interceptors[i];         interceptor.postHandle(request, response, <span class="hljs-keyword">this</span>.handler, mv);      &#125;   &#125;&#125;</code></pre><h3 id="processDispatchResult-方法"><a href="#processDispatchResult-方法" class="headerlink" title="processDispatchResult()方法"></a>processDispatchResult()方法</h3><p>该方法最终会落入renderMergedOutputModel()方法中，这里只着重分析这个方法。</p><p>注意，如果ModelAndView为空就会以流的方式响应json数据，不会进入这个方法。首先会调用exposeModelAsRequestAttributes()方法，将model中的对象设置到request中。然后获取到跳转地址，将地址转为RequestDispatcher对象，最后调用RequestDispatcher.forward()进行转发。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">renderMergedOutputModel</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">Map&lt;String, Object&gt; model, HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;   <span class="hljs-comment">// 把响应数据设置到reqeust对象中</span><span class="hljs-comment">// Expose the model object as request attributes.</span>exposeModelAsRequestAttributes(model, request);<span class="hljs-comment">// Expose helpers as request attributes, if any.</span>exposeHelpers(request);   <span class="hljs-comment">//获取到跳转地址</span><span class="hljs-comment">// Determine the path for the request dispatcher.</span>String dispatcherPath = prepareForRendering(request, response);<span class="hljs-comment">// Obtain a RequestDispatcher for the target resource (typically a JSP).</span>RequestDispatcher rd = getRequestDispatcher(request, dispatcherPath);<span class="hljs-keyword">if</span> (rd == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ServletException(<span class="hljs-string">"Could not get RequestDispatcher for ["</span> + getUrl() +<span class="hljs-string">"]: Check that the corresponding file exists within your web application archive!"</span>);&#125;<span class="hljs-comment">// If already included or response already committed, perform include, else forward.</span><span class="hljs-keyword">if</span> (useInclude(request, response)) &#123;response.setContentType(getContentType());<span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;logger.debug(<span class="hljs-string">"Including ["</span> + getUrl() + <span class="hljs-string">"]"</span>);&#125;rd.include(request, response);&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// Note: The forwarded resource is supposed to determine the content type itself.</span><span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;logger.debug(<span class="hljs-string">"Forwarding to ["</span> + getUrl() + <span class="hljs-string">"]"</span>);&#125;rd.forward(request, response);&#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>SpringMVC源码解析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>源码解析</tag>
      
      <tag>spring</tag>
      
      <tag>springmvc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringMVC的初始化过程</title>
    <link href="/blog/2020/04/20/springmvc-%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B/"/>
    <url>/blog/2020/04/20/springmvc-%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="初始化入口"><a href="#初始化入口" class="headerlink" title="初始化入口"></a>初始化入口</h2><p>springmvc是基于servlet规范来完成的一个请求响应模块，也是spring中比较大的一个模块，现在已经支持零配置的方式整合，不再需要web.xml和springmvc.xml文件。</p><h3 id="web-xml的替换"><a href="#web-xml的替换" class="headerlink" title="web.xml的替换"></a>web.xml的替换</h3><p>servlet规范中规定当servlet容器启动的时会加载META-INF/services/javax.servlet.ServletContainerInitializer文件中的类。这个类必须实现javax.servlet.ServletContainerInitializer接口，servlet容器在启动后会收集实现@HandlesTypes注解中的接口的实现类，然后传递给onStartup()方法。springmvc就是通过这个规范完成容器初始化。</p><pre><code class="hljs xml">org.springframework.web.SpringServletContainerInitializer</code></pre><p>spring中定义一个了WebApplicationInitializer接口，然后在onStartup()方法中通过反射调用onStart()方法。这里我们着重分析下这个接口的实现类AbstractContextLoaderInitializer跟AbstractDispatcherServletInitializer类。</p><pre><code class="hljs java"><span class="hljs-meta">@HandlesTypes</span>(WebApplicationInitializer<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">SpringServletContainerInitializer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ServletContainerInitializer</span> </span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStartup</span><span class="hljs-params">(@Nullable Set&lt;Class&lt;?&gt;&gt; webAppInitializerClasses, ServletContext servletContext)</span></span><span class="hljs-function"><span class="hljs-keyword">throws</span> ServletException </span>&#123;List&lt;WebApplicationInitializer&gt; initializers = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<span class="hljs-keyword">if</span> (webAppInitializerClasses != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">for</span> (Class&lt;?&gt; waiClass : webAppInitializerClasses) &#123;<span class="hljs-comment">// Be defensive: Some servlet containers provide us with invalid classes,</span><span class="hljs-comment">// no matter what @HandlesTypes says...</span><span class="hljs-keyword">if</span> (!waiClass.isInterface() &amp;&amp; !Modifier.isAbstract(waiClass.getModifiers()) &amp;&amp;WebApplicationInitializer<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">isAssignableFrom</span>(<span class="hljs-title">waiClass</span>)) </span>&#123;<span class="hljs-keyword">try</span> &#123;initializers.add((WebApplicationInitializer)ReflectionUtils.accessibleConstructor(waiClass).newInstance());&#125;<span class="hljs-keyword">catch</span> (Throwable ex) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ServletException(<span class="hljs-string">"Failed to instantiate WebApplicationInitializer class"</span>, ex);&#125;&#125;&#125;&#125;<span class="hljs-keyword">if</span> (initializers.isEmpty()) &#123;servletContext.log(<span class="hljs-string">"No Spring WebApplicationInitializer types detected on classpath"</span>);<span class="hljs-keyword">return</span>;&#125;servletContext.log(initializers.size() + <span class="hljs-string">" Spring WebApplicationInitializers detected on classpath"</span>);AnnotationAwareOrderComparator.sort(initializers);<span class="hljs-keyword">for</span> (WebApplicationInitializer initializer : initializers) &#123;initializer.onStartup(servletContext);&#125;&#125;&#125;</code></pre><h4 id="AbstractContextLoaderInitializer类"><a href="#AbstractContextLoaderInitializer类" class="headerlink" title="AbstractContextLoaderInitializer类"></a>AbstractContextLoaderInitializer类</h4><p>AbstractContextLoaderInitializer中的onStartup()方法会调用registerContextLoaderListener()方法，该方法中会调用createRootApplicationContext()方法创建spring上下文，并注册ContextLoaderListener。spring上下文的refresh()方法将由ContextLoaderListener来调用</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractContextLoaderInitializer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebApplicationInitializer</span> </span>&#123;<span class="hljs-comment">/** Logger available to subclasses. */</span><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Log logger = LogFactory.getLog(getClass());<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStartup</span><span class="hljs-params">(ServletContext servletContext)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;registerContextLoaderListener(servletContext);&#125;<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerContextLoaderListener</span><span class="hljs-params">(ServletContext servletContext)</span> </span>&#123;<span class="hljs-comment">//创建spring上下文，注册了SpringContainer</span>WebApplicationContext rootAppContext = createRootApplicationContext();<span class="hljs-keyword">if</span> (rootAppContext != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//创建监听器</span><span class="hljs-comment">/*</span><span class="hljs-comment">形如这种配置</span><span class="hljs-comment">* &lt;listener&gt;</span><span class="hljs-comment">  &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;</span><span class="hljs-comment">&lt;!--&lt;listener-class&gt;org.springframework.web.context.request.RequestContextListener&lt;/listener-class&gt;--&gt;</span><span class="hljs-comment">  &lt;/listener&gt;</span><span class="hljs-comment">*</span><span class="hljs-comment">* */</span>ContextLoaderListener listener = <span class="hljs-keyword">new</span> ContextLoaderListener(rootAppContext);listener.setContextInitializers(getRootApplicationContextInitializers());servletContext.addListener(listener);&#125;<span class="hljs-keyword">else</span> &#123;logger.debug(<span class="hljs-string">"No ContextLoaderListener registered, as "</span> +<span class="hljs-string">"createRootApplicationContext() did not return an application context"</span>);&#125;&#125;<span class="hljs-meta">@Nullable</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> WebApplicationContext <span class="hljs-title">createRootApplicationContext</span><span class="hljs-params">()</span></span>;<span class="hljs-meta">@Nullable</span><span class="hljs-keyword">protected</span> ApplicationContextInitializer&lt;?&gt;[] getRootApplicationContextInitializers() &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;&#125;</code></pre><p>AbstractAnnotationConfigDispatcherServletInitializer中的createRootApplicationContext()方法会调用getRootConfigClasses()方法获取一个configClasses对象，然后创建一个AnnotationConfigWebApplicationContext上下文对象，并向这个上下文对象中注册configClasses对象。这个过程类似于与注解启动spring容器过程相同。getRootConfigClasses()方法会由开发者自己实现，主要作用是将有@CompoentScan注解的类传递给spring用来创建上下文。要注意的是这个上下文对象是spring的上下文对象，不是sprngmvc的上下文，所以应该排除controller对象。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractAnnotationConfigDispatcherServletInitializer</span></span><span class="hljs-class"><span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractDispatcherServletInitializer</span> </span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-meta">@Nullable</span><span class="hljs-function"><span class="hljs-keyword">protected</span> WebApplicationContext <span class="hljs-title">createRootApplicationContext</span><span class="hljs-params">()</span> </span>&#123;Class&lt;?&gt;[] configClasses = getRootConfigClasses();<span class="hljs-keyword">if</span> (!ObjectUtils.isEmpty(configClasses)) &#123;AnnotationConfigWebApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigWebApplicationContext();context.register(configClasses);<span class="hljs-keyword">return</span> context;&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> WebApplicationContext <span class="hljs-title">createServletApplicationContext</span><span class="hljs-params">()</span> </span>&#123;AnnotationConfigWebApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigWebApplicationContext();Class&lt;?&gt;[] configClasses = getServletConfigClasses();<span class="hljs-keyword">if</span> (!ObjectUtils.isEmpty(configClasses)) &#123;context.register(configClasses);&#125;<span class="hljs-keyword">return</span> context;&#125;<span class="hljs-meta">@Nullable</span><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> Class&lt;?&gt;[] getRootConfigClasses();<span class="hljs-meta">@Nullable</span><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> Class&lt;?&gt;[] getServletConfigClasses();&#125;</code></pre><p>ContextLoaderListener的contextInitialized()方法会在servlet容器启动时调用。contextInitialized()将调用initWebApplicationContext()调用spring上下文加载的核心方法refresh()。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ContextLoaderListener</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ContextLoader</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ServletContextListener</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ContextLoaderListener</span><span class="hljs-params">()</span> </span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ContextLoaderListener</span><span class="hljs-params">(WebApplicationContext context)</span> </span>&#123;<span class="hljs-keyword">super</span>(context);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">contextInitialized</span><span class="hljs-params">(ServletContextEvent event)</span> </span>&#123;initWebApplicationContext(event.getServletContext());&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">contextDestroyed</span><span class="hljs-params">(ServletContextEvent event)</span> </span>&#123;closeWebApplicationContext(event.getServletContext());ContextCleanupListener.cleanupAttributes(event.getServletContext());&#125;&#125;</code></pre><h4 id="AbstractDispatcherServletInitializer类"><a href="#AbstractDispatcherServletInitializer类" class="headerlink" title="AbstractDispatcherServletInitializer类"></a>AbstractDispatcherServletInitializer类</h4><p>AbstractDispatcherServletInitializer的onStartup()方法中，会创建sprngmvc的上下文对象跟DispatcherServlet对象。Serlvet容器在启动时会调用DispatcherServlet的init()方法，该方法继承自父类HttpServletBean，init()方法最终会调用到springmvc上下文的refresh()方法。springmvc上下文对象初始化时会先获取spring的上下文对象，然后将其设置为父容器，之后getBean()操作中会优先从父容器中获取bean。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractDispatcherServletInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractContextLoaderInitializer</span> </span>&#123;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_SERVLET_NAME = <span class="hljs-string">"dispatcher"</span>;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStartup</span><span class="hljs-params">(ServletContext servletContext)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;      <span class="hljs-keyword">super</span>.onStartup(servletContext);      <span class="hljs-comment">//注册DispatcherServlet</span>      registerDispatcherServlet(servletContext);   &#125;   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerDispatcherServlet</span><span class="hljs-params">(ServletContext servletContext)</span> </span>&#123;      String servletName = getServletName();      Assert.hasLength(servletName, <span class="hljs-string">"getServletName() must not return null or empty"</span>);      <span class="hljs-comment">//创建springmvc的上下文，注册了MvcContainer类</span>      WebApplicationContext servletAppContext = createServletApplicationContext();      Assert.notNull(servletAppContext, <span class="hljs-string">"createServletApplicationContext() must not return null"</span>);      <span class="hljs-comment">//创建DispatcherServlet</span>      FrameworkServlet dispatcherServlet = createDispatcherServlet(servletAppContext);      Assert.notNull(dispatcherServlet, <span class="hljs-string">"createDispatcherServlet(WebApplicationContext) must not return null"</span>);      dispatcherServlet.setContextInitializers(getServletApplicationContextInitializers());      ServletRegistration.Dynamic registration = servletContext.addServlet(servletName, dispatcherServlet);      <span class="hljs-keyword">if</span> (registration == <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Failed to register servlet with name '"</span> + servletName + <span class="hljs-string">"'. "</span> +               <span class="hljs-string">"Check if there is another servlet registered under the same name."</span>);      &#125;      <span class="hljs-comment">/*</span><span class="hljs-comment">      * 如果该元素的值为负数或者没有设置，则容器会当Servlet被请求时再加载。</span><span class="hljs-comment">         如果值为正整数或者0时，表示容器在应用启动时就加载并初始化这个servlet，</span><span class="hljs-comment">         值越小，servlet的优先级越高，就越先被加载</span><span class="hljs-comment">      * */</span>      registration.setLoadOnStartup(<span class="hljs-number">1</span>);      registration.addMapping(getServletMappings());      registration.setAsyncSupported(isAsyncSupported());      Filter[] filters = getServletFilters();      <span class="hljs-keyword">if</span> (!ObjectUtils.isEmpty(filters)) &#123;         <span class="hljs-keyword">for</span> (Filter filter : filters) &#123;            registerServletFilter(servletContext, filter);         &#125;      &#125;      customizeRegistration(registration);   &#125;   <span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">getServletName</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> DEFAULT_SERVLET_NAME;   &#125;     <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> WebApplicationContext <span class="hljs-title">createServletApplicationContext</span><span class="hljs-params">()</span></span>;   <span class="hljs-function"><span class="hljs-keyword">protected</span> FrameworkServlet <span class="hljs-title">createDispatcherServlet</span><span class="hljs-params">(WebApplicationContext servletAppContext)</span> </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DispatcherServlet(servletAppContext);   &#125;   <span class="hljs-meta">@Nullable</span>   <span class="hljs-keyword">protected</span> ApplicationContextInitializer&lt;?&gt;[] getServletApplicationContextInitializers() &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;   &#125;   <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> String[] getServletMappings();   <span class="hljs-meta">@Nullable</span>   <span class="hljs-keyword">protected</span> Filter[] getServletFilters() &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;   &#125;     <span class="hljs-keyword">protected</span> FilterRegistration.<span class="hljs-function">Dynamic <span class="hljs-title">registerServletFilter</span><span class="hljs-params">(ServletContext servletContext, Filter filter)</span> </span>&#123;      String filterName = Conventions.getVariableName(filter);      Dynamic registration = servletContext.addFilter(filterName, filter);      <span class="hljs-keyword">if</span> (registration == <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">int</span> counter = <span class="hljs-number">0</span>;         <span class="hljs-keyword">while</span> (registration == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">if</span> (counter == <span class="hljs-number">100</span>) &#123;               <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Failed to register filter with name '"</span> + filterName + <span class="hljs-string">"'. "</span> +                     <span class="hljs-string">"Check if there is another filter registered under the same name."</span>);            &#125;            registration = servletContext.addFilter(filterName + <span class="hljs-string">"#"</span> + counter, filter);            counter++;         &#125;      &#125;      registration.setAsyncSupported(isAsyncSupported());      registration.addMappingForServletNames(getDispatcherTypes(), <span class="hljs-keyword">false</span>, getServletName());      <span class="hljs-keyword">return</span> registration;   &#125;   <span class="hljs-function"><span class="hljs-keyword">private</span> EnumSet&lt;DispatcherType&gt; <span class="hljs-title">getDispatcherTypes</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> (isAsyncSupported() ?            EnumSet.of(DispatcherType.REQUEST, DispatcherType.FORWARD, DispatcherType.INCLUDE, DispatcherType.ASYNC) :            EnumSet.of(DispatcherType.REQUEST, DispatcherType.FORWARD, DispatcherType.INCLUDE));   &#125;   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAsyncSupported</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;   &#125;   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">customizeRegistration</span><span class="hljs-params">(ServletRegistration.Dynamic registration)</span> </span>&#123;   &#125;&#125;</code></pre><h3 id="springmvc-xml的替换"><a href="#springmvc-xml的替换" class="headerlink" title="springmvc.xml的替换"></a>springmvc.xml的替换</h3><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:message-converters</span> <span class="hljs-attr">register-defaults</span>=<span class="hljs-string">"true"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.http.converter.StringHttpMessageConverter"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"supportedMediaTypes"</span> <span class="hljs-attr">value</span> = <span class="hljs-string">"text/plain;charset=UTF-8"</span> /&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:message-converters</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:annotation-driven</span>&gt;</span></code></pre><p>这个标签总过做了三件事情：</p><ol><li>创建HandlerMapping对象</li><li>创建HandlerAdapter对象</li><li>创建消息转换器加入到HandlerAdapter中</li></ol><p>@EnableWebMvc标签可以完成springmvc.xml中的所有工作。</p><p>该注解中会引入DelegatingWebMvcConfiguration类，该类会通过@Autowired获取到所有WebMvcConfigurer接口的实现类。该类的父类WebMvcConfigurationSupport类就是比较核心的类，会替代xml进行完成所有组件的注册。该类十分庞大，主要是通过@Bean的方式将组件注册到上下文对象中。此处我们只分析RequestMappingHandlerMapping的注册，其他组件的注册的流程也基本相同。</p><p>该类的requestMappingHandleMapping()方法进行RequestMappingHandlerMapping的注册，该方法会通过调用getInterceptors()方法获取拦截器，然后设置进去，之后设置的属性还包括跨域等属性，这里着重分析getInterceptors()方法，其他属性的获取方式也基本相同。</p><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> RequestMappingHandlerMapping <span class="hljs-title">requestMappingHandlerMapping</span><span class="hljs-params">()</span> </span>&#123;   RequestMappingHandlerMapping mapping = createRequestMappingHandlerMapping();   mapping.setOrder(<span class="hljs-number">0</span>);   mapping.setInterceptors(getInterceptors());   mapping.setContentNegotiationManager(mvcContentNegotiationManager());   mapping.setCorsConfigurations(getCorsConfigurations());   PathMatchConfigurer configurer = getPathMatchConfigurer();   Boolean useSuffixPatternMatch = configurer.isUseSuffixPatternMatch();   <span class="hljs-keyword">if</span> (useSuffixPatternMatch != <span class="hljs-keyword">null</span>) &#123;      mapping.setUseSuffixPatternMatch(useSuffixPatternMatch);   &#125;   Boolean useRegisteredSuffixPatternMatch = configurer.isUseRegisteredSuffixPatternMatch();   <span class="hljs-keyword">if</span> (useRegisteredSuffixPatternMatch != <span class="hljs-keyword">null</span>) &#123;      mapping.setUseRegisteredSuffixPatternMatch(useRegisteredSuffixPatternMatch);   &#125;   Boolean useTrailingSlashMatch = configurer.isUseTrailingSlashMatch();   <span class="hljs-keyword">if</span> (useTrailingSlashMatch != <span class="hljs-keyword">null</span>) &#123;      mapping.setUseTrailingSlashMatch(useTrailingSlashMatch);   &#125;   UrlPathHelper pathHelper = configurer.getUrlPathHelper();   <span class="hljs-keyword">if</span> (pathHelper != <span class="hljs-keyword">null</span>) &#123;      mapping.setUrlPathHelper(pathHelper);   &#125;   PathMatcher pathMatcher = configurer.getPathMatcher();   <span class="hljs-keyword">if</span> (pathMatcher != <span class="hljs-keyword">null</span>) &#123;      mapping.setPathMatcher(pathMatcher);   &#125;   Map&lt;String, Predicate&lt;Class&lt;?&gt;&gt;&gt; pathPrefixes = configurer.getPathPrefixes();   <span class="hljs-keyword">if</span> (pathPrefixes != <span class="hljs-keyword">null</span>) &#123;      mapping.setPathPrefixes(pathPrefixes);   &#125;   <span class="hljs-keyword">return</span> mapping;&#125;</code></pre><p>getInterceptors()方法</p><p>该方法会调用子类DelegatingWebMvcConfiguration的addInterceptors()方法，该类中会通过依赖注入的方式获取到所有实现WebMvcConfigurer接口的类，然后调用其addInterceptors()方法把我们自己定义的Interceptor传递进去。</p><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span>(required = <span class="hljs-keyword">false</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setConfigurers</span><span class="hljs-params">(List&lt;WebMvcConfigurer&gt; configurers)</span> </span>&#123;   <span class="hljs-keyword">if</span> (!CollectionUtils.isEmpty(configurers)) &#123;      <span class="hljs-keyword">this</span>.configurers.addWebMvcConfigurers(configurers);   &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>&#123;   <span class="hljs-keyword">this</span>.configurers.addInterceptors(registry);&#125;</code></pre><h2 id="DispatcherServlet中的组件初始化"><a href="#DispatcherServlet中的组件初始化" class="headerlink" title="DispatcherServlet中的组件初始化"></a>DispatcherServlet中的组件初始化</h2><p>DispatcherServlet的父类FrameworkServlet中有一个私有类ContextRefreshListener，这个私有类继承了spring的监听器ApplicationListener&lt;ContextRefreshedEvent&gt;，spring完成初始化会发布一个ContextRefreshedEvent类型的事件来触发这个监听器，监听器监听到这个事件后会在线程中调用私有类的onApplicationEvent()方法。</p><p>onApplicationEvent()方法会再调用FrameworkServlet类中的onApplicationEvent()方法，在这个方法中会调用onRefresh()方法。</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ContextRefreshListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationListener</span>&lt;<span class="hljs-title">ContextRefreshedEvent</span>&gt; </span>&#123;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onApplicationEvent</span><span class="hljs-params">(ContextRefreshedEvent event)</span> </span>&#123;      FrameworkServlet.<span class="hljs-keyword">this</span>.onApplicationEvent(event);   &#125;&#125;</code></pre><p>onRefresh()方法会调用到子类DispatcherServlet中的方法，最终调用到initStrategies()方法。完成DispatcherServlet组件的设置。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initStrategies</span><span class="hljs-params">(ApplicationContext context)</span> </span>&#123;   initMultipartResolver(context);   initLocaleResolver(context);   initThemeResolver(context);   initHandlerMappings(context);   initHandlerAdapters(context);   initHandlerExceptionResolvers(context);   initRequestToViewNameTranslator(context);   initViewResolvers(context);   initFlashMapManager(context);&#125;</code></pre><p>initHandlerMappings()方法会从上下文中获取到HandlerMapping对象，然后进行排序。如果没有配置HandlerMapping对象，就会加载默认的HandlerMappinig对象。最后设置到handlerMappings属性中。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initHandlerMappings</span><span class="hljs-params">(ApplicationContext context)</span> </span>&#123;   <span class="hljs-keyword">this</span>.handlerMappings = <span class="hljs-keyword">null</span>;   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.detectAllHandlerMappings) &#123;      <span class="hljs-comment">// Find all HandlerMappings in the ApplicationContext, including ancestor contexts.</span>      Map&lt;String, HandlerMapping&gt; matchingBeans =            BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">true</span>, <span class="hljs-title">false</span>)</span>;      <span class="hljs-keyword">if</span> (!matchingBeans.isEmpty()) &#123;         <span class="hljs-keyword">this</span>.handlerMappings = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(matchingBeans.values());         <span class="hljs-comment">// We keep HandlerMappings in sorted order.</span>         AnnotationAwareOrderComparator.sort(<span class="hljs-keyword">this</span>.handlerMappings);      &#125;   &#125;   <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">try</span> &#123;         HandlerMapping hm = context.getBean(HANDLER_MAPPING_BEAN_NAME, HandlerMapping<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;         <span class="hljs-keyword">this</span>.handlerMappings = Collections.singletonList(hm);      &#125;      <span class="hljs-keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;         <span class="hljs-comment">// Ignore, we'll add a default HandlerMapping later.</span>      &#125;   &#125;   <span class="hljs-comment">// Ensure we have at least one HandlerMapping, by registering</span>   <span class="hljs-comment">// a default HandlerMapping if no other mappings are found.</span>   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.handlerMappings == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">this</span>.handlerMappings = getDefaultStrategies(context, HandlerMapping<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;      <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;         logger.trace(<span class="hljs-string">"No HandlerMappings declared for servlet '"</span> + getServletName() +               <span class="hljs-string">"': using default strategies from DispatcherServlet.properties"</span>);      &#125;   &#125;&#125;</code></pre><h2 id="建立路径与方法的映射关系"><a href="#建立路径与方法的映射关系" class="headerlink" title="建立路径与方法的映射关系"></a>建立路径与方法的映射关系</h2><p>springmvc会在初始化时完成路径与方法的映射，具体是通过AbstractHandlerMethodMapping类的initHandlerMethods()方法来完成。AbstractHandlerMethodMapping类实现了InitializingBean接口，spring在Bean实例化并完成IOC、DI之后调用这个接口的afterPropertiesSet()方法。AbstractHandlerMethodMapping类的afterPropertiesSet()方法中调用了initHandlerMethods()方法。initHandlerMethods()方法会调用processCandidateBean()方法创建url跟method的映射关系。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initHandlerMethods</span><span class="hljs-params">()</span> </span>&#123;   <span class="hljs-keyword">for</span> (String beanName : getCandidateBeanNames()) &#123;      <span class="hljs-keyword">if</span> (!beanName.startsWith(SCOPED_TARGET_NAME_PREFIX)) &#123;         processCandidateBean(beanName);      &#125;   &#125;   handlerMethodsInitialized(getHandlerMethods());&#125;</code></pre><p>processCandidateBean()方法会判断类上面是否有@Controller、@RequestMapping注解，如果有会调用detectHandlerMethods()方法建立url跟method的映射关系。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processCandidateBean</span><span class="hljs-params">(String beanName)</span> </span>&#123;   Class&lt;?&gt; beanType = <span class="hljs-keyword">null</span>;   <span class="hljs-keyword">try</span> &#123;      beanType = obtainApplicationContext().getType(beanName);   &#125;   <span class="hljs-keyword">catch</span> (Throwable ex) &#123;      <span class="hljs-comment">// An unresolvable bean type, probably from a lazy bean - let's ignore it.</span>      <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;         logger.trace(<span class="hljs-string">"Could not resolve type for bean '"</span> + beanName + <span class="hljs-string">"'"</span>, ex);      &#125;   &#125;   <span class="hljs-comment">//如果类上面有@Controller注解或者@RequestMapping注解</span>   <span class="hljs-keyword">if</span> (beanType != <span class="hljs-keyword">null</span> &amp;&amp; isHandler(beanType)) &#123;      <span class="hljs-comment">//建立uri和method的映射关系</span>      detectHandlerMethods(beanName);   &#125;&#125;</code></pre><p>detectHandlerMethods()方法首先会获取方法对象和方法上的@RequestMapping注解属性，然后向selectMethods()方法中传入getMappingForMethod()方法用来封装映射关系，Map&lt;Method, T&gt;中的T就是属性的封装对象。最后调用registerHandlerMethod()方法建立映射关系。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">detectHandlerMethods</span><span class="hljs-params">(Object handler)</span> </span>&#123;   Class&lt;?&gt; handlerType = (handler <span class="hljs-keyword">instanceof</span> String ?         obtainApplicationContext().getType((String) handler) : handler.getClass());   <span class="hljs-keyword">if</span> (handlerType != <span class="hljs-keyword">null</span>) &#123;      Class&lt;?&gt; userType = ClassUtils.getUserClass(handlerType);      <span class="hljs-comment">//获取方法对象和方法上面的@RequestMapping注解属性封装对象的映射关系</span>      Map&lt;Method, T&gt; methods = MethodIntrospector.selectMethods(userType,            (MethodIntrospector.MetadataLookup&lt;T&gt;) method -&gt; &#123;               <span class="hljs-keyword">try</span> &#123;                  <span class="hljs-keyword">return</span> getMappingForMethod(method, userType);               &#125;               <span class="hljs-keyword">catch</span> (Throwable ex) &#123;                  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Invalid mapping on handler class ["</span> +                        userType.getName() + <span class="hljs-string">"]: "</span> + method, ex);               &#125;            &#125;);      <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;         logger.trace(formatMappings(userType, methods));      &#125;      methods.forEach((method, mapping) -&gt; &#123;         Method invocableMethod = AopUtils.selectInvocableMethod(method, userType);         <span class="hljs-comment">//建立uri和方法的各种映射关系，反正一条，根据uri要能够找到method对象</span>         registerHandlerMethod(handler, invocableMethod, mapping);      &#125;);   &#125;&#125;</code></pre><p>selectMethods()方法首先会获取类上的所有method，然后判断method上面是否有@RequestMapping注解，如果有调用外层传入的getMappingForMethod()方法封装成对象返回。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Map&lt;Method, T&gt; <span class="hljs-title">selectMethods</span><span class="hljs-params">(Class&lt;?&gt; targetType, <span class="hljs-keyword">final</span> MetadataLookup&lt;T&gt; metadataLookup)</span> </span>&#123;   <span class="hljs-keyword">final</span> Map&lt;Method, T&gt; methodMap = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;();   Set&lt;Class&lt;?&gt;&gt; handlerTypes = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;();   Class&lt;?&gt; specificHandlerType = <span class="hljs-keyword">null</span>;   <span class="hljs-keyword">if</span> (!Proxy.isProxyClass(targetType)) &#123;      specificHandlerType = ClassUtils.getUserClass(targetType);      handlerTypes.add(specificHandlerType);   &#125;   handlerTypes.addAll(ClassUtils.getAllInterfacesForClassAsSet(targetType));   <span class="hljs-keyword">for</span> (Class&lt;?&gt; currentHandlerType : handlerTypes) &#123;      <span class="hljs-keyword">final</span> Class&lt;?&gt; targetClass = (specificHandlerType != <span class="hljs-keyword">null</span> ? specificHandlerType : currentHandlerType);      <span class="hljs-comment">//循环currentHandlerType类的所有方法</span>      ReflectionUtils.doWithMethods(currentHandlerType, method -&gt; &#123;         Method specificMethod = ClassUtils.getMostSpecificMethod(method, targetClass);         <span class="hljs-comment">//判断方法上面是否有@RequestMapping注解，如果有封装对象返回</span>         T result = metadataLookup.inspect(specificMethod);         <span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) &#123;            Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(specificMethod);            <span class="hljs-keyword">if</span> (bridgedMethod == specificMethod || metadataLookup.inspect(bridgedMethod) == <span class="hljs-keyword">null</span>) &#123;               <span class="hljs-comment">//建立方法对象和注解封装对象的映射关系</span>               methodMap.put(specificMethod, result);            &#125;         &#125;      &#125;, ReflectionUtils.USER_DECLARED_METHODS);   &#125;   <span class="hljs-keyword">return</span> methodMap;&#125;</code></pre><p>getMappingForMethod()方法首先会调用createRequestMappingInfo()方法封装注解信息，然后将类上的@RequestMapping注解也封装成对象，最后将两个对象结合后返回。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> RequestMappingInfo <span class="hljs-title">getMappingForMethod</span><span class="hljs-params">(Method method, Class&lt;?&gt; handlerType)</span> </span>&#123;   <span class="hljs-comment">//寻找有@RequestMapping注解的方法，然后注解里面的内容封装成对象</span>   RequestMappingInfo info = createRequestMappingInfo(method);   <span class="hljs-keyword">if</span> (info != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-comment">//类上面的@RequestMapping注解也封装成对象</span>      RequestMappingInfo typeInfo = createRequestMappingInfo(handlerType);      <span class="hljs-keyword">if</span> (typeInfo != <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-comment">//把方法上面的注解属性结合到类上面的RequestMappingInfo对象中</span>         info = typeInfo.combine(info);      &#125;      String prefix = getPathPrefix(handlerType);      <span class="hljs-keyword">if</span> (prefix != <span class="hljs-keyword">null</span>) &#123;         info = RequestMappingInfo.paths(prefix).build().combine(info);      &#125;   &#125;   <span class="hljs-keyword">return</span> info;&#125;</code></pre><p>registerHandlerMethod()方法中的主要方法是register()，该方法首先会调用createHandlerMethod()方法创建HandlerMethod对象，该对象中封装了类跟方法信息，如果此时类还没有被实例化，就会将beanName跟beanFactory一起封装进去，如果类已经实例化就只会封装实例化之后的bean。然后将uri跟HandlerMethod放到mappingLookup中，url跟RequestMappingInfo信息放入urlLookup中。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(T mapping, Object handler, Method method)</span> </span>&#123;   <span class="hljs-keyword">this</span>.readWriteLock.writeLock().lock();   <span class="hljs-keyword">try</span> &#123;      <span class="hljs-comment">//创建HandlerMethod对象，其实</span>      HandlerMethod handlerMethod = createHandlerMethod(handler, method);      <span class="hljs-comment">//检验是否唯一</span>      assertUniqueMethodMapping(handlerMethod, mapping);      <span class="hljs-comment">//建立RequestMappingInfo对象和handlerMethod的映射关系</span>      <span class="hljs-keyword">this</span>.mappingLookup.put(mapping, handlerMethod);      List&lt;String&gt; directUrls = getDirectUrls(mapping);      <span class="hljs-keyword">for</span> (String url : directUrls) &#123;         <span class="hljs-comment">//建立url和RequestMappingInfo映射关系</span>         <span class="hljs-keyword">this</span>.urlLookup.add(url, mapping);      &#125;      String name = <span class="hljs-keyword">null</span>;      <span class="hljs-keyword">if</span> (getNamingStrategy() != <span class="hljs-keyword">null</span>) &#123;         name = getNamingStrategy().getName(handlerMethod, mapping);         addMappingName(name, handlerMethod);      &#125;      <span class="hljs-comment">//判断method上是否有CrossOrigin注解，把注解里面的属性封装成CorsConfiguration，这个是做跨域访问控制的</span>      CorsConfiguration corsConfig = initCorsConfiguration(handler, method, mapping);      <span class="hljs-keyword">if</span> (corsConfig != <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-comment">//建立映射关系</span>         <span class="hljs-keyword">this</span>.corsLookup.put(handlerMethod, corsConfig);      &#125;      <span class="hljs-keyword">this</span>.registry.put(mapping, <span class="hljs-keyword">new</span> MappingRegistration&lt;&gt;(mapping, handlerMethod, directUrls, name));   &#125;   <span class="hljs-keyword">finally</span> &#123;      <span class="hljs-keyword">this</span>.readWriteLock.writeLock().unlock();   &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>SpringMVC源码解析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>源码解析</tag>
      
      <tag>spring</tag>
      
      <tag>springmvc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring的缓存切面和异步切面</title>
    <link href="/blog/2020/04/20/spring-%E7%BC%93%E5%AD%98%E5%88%87%E9%9D%A2%E5%92%8C%E5%BC%82%E6%AD%A5%E5%88%87%E9%9D%A2/"/>
    <url>/blog/2020/04/20/spring-%E7%BC%93%E5%AD%98%E5%88%87%E9%9D%A2%E5%92%8C%E5%BC%82%E6%AD%A5%E5%88%87%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="缓存切面"><a href="#缓存切面" class="headerlink" title="缓存切面"></a>缓存切面</h2><p>开启缓存注解@EnableCaching</p><p>缓存切面的使用可以通过以下注解：</p><p>@Cacheable：先从缓存中取，如果有则直接返回，如果没有则调用被代理方法拿到返回值然后存到缓存中。<br>@CachePut：只要调用到被代理方法后把返回值存到缓存中。</p><p>@CacheEvict：删除key对应的注解。</p><p>在使用注解是需要通过cacheNames属性指定使用哪一个缓存，因为缓存管理器中可能会有多个缓存要使用的缓存对象。</p><h3 id="切面的注册"><a href="#切面的注册" class="headerlink" title="切面的注册"></a>切面的注册</h3><p>同样的，@EnableCaching注解也会引入CachingConfigurationSelector类</p><pre><code class="hljs java"><span class="hljs-meta">@Target</span>(ElementType.TYPE)<span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-meta">@Documented</span><span class="hljs-meta">@Import</span>(CachingConfigurationSelector<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> @<span class="hljs-title">interface</span> <span class="hljs-title">EnableCaching</span> </span>&#123;</code></pre><p>CachingConfigurationSelector类</p><p>这个类也会引入ProxyCachingConfiguration类来注册切面。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CachingConfigurationSelector</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AdviceModeImportSelector</span>&lt;<span class="hljs-title">EnableCaching</span>&gt; </span>&#123;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PROXY_JCACHE_CONFIGURATION_CLASS =         <span class="hljs-string">"org.springframework.cache.jcache.config.ProxyJCacheConfiguration"</span>;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String CACHE_ASPECT_CONFIGURATION_CLASS_NAME =         <span class="hljs-string">"org.springframework.cache.aspectj.AspectJCachingConfiguration"</span>;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String JCACHE_ASPECT_CONFIGURATION_CLASS_NAME =         <span class="hljs-string">"org.springframework.cache.aspectj.AspectJJCacheConfiguration"</span>;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> jsr107Present;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> jcacheImplPresent;   <span class="hljs-keyword">static</span> &#123;      ClassLoader classLoader = CachingConfigurationSelector<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getClassLoader</span>()</span>;      jsr107Present = ClassUtils.isPresent(<span class="hljs-string">"javax.cache.Cache"</span>, classLoader);      jcacheImplPresent = ClassUtils.isPresent(PROXY_JCACHE_CONFIGURATION_CLASS, classLoader);   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * Returns &#123;<span class="hljs-doctag">@link</span> ProxyCachingConfiguration&#125; or &#123;<span class="hljs-doctag">@code</span> AspectJCachingConfiguration&#125;</span><span class="hljs-comment">    * for &#123;<span class="hljs-doctag">@code</span> PROXY&#125; and &#123;<span class="hljs-doctag">@code</span> ASPECTJ&#125; values of &#123;<span class="hljs-doctag">@link</span> EnableCaching#mode()&#125;,</span><span class="hljs-comment">    * respectively. Potentially includes corresponding JCache configuration as well.</span><span class="hljs-comment">    */</span>   <span class="hljs-meta">@Override</span>   <span class="hljs-keyword">public</span> String[] selectImports(AdviceMode adviceMode) &#123;      <span class="hljs-keyword">switch</span> (adviceMode) &#123;         <span class="hljs-keyword">case</span> PROXY:            <span class="hljs-keyword">return</span> getProxyImports();         <span class="hljs-keyword">case</span> ASPECTJ:            <span class="hljs-keyword">return</span> getAspectJImports();         <span class="hljs-keyword">default</span>:            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;      &#125;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * Return the imports to use if the &#123;<span class="hljs-doctag">@link</span> AdviceMode&#125; is set to &#123;<span class="hljs-doctag">@link</span> AdviceMode#PROXY&#125;.</span><span class="hljs-comment">    * &lt;p&gt;Take care of adding the necessary JSR-107 import if it is available.</span><span class="hljs-comment">    */</span>   <span class="hljs-keyword">private</span> String[] getProxyImports() &#123;      List&lt;String&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-number">3</span>);      result.add(AutoProxyRegistrar<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getName</span>())</span>;      result.add(ProxyCachingConfiguration<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getName</span>())</span>;      <span class="hljs-keyword">if</span> (jsr107Present &amp;&amp; jcacheImplPresent) &#123;         result.add(PROXY_JCACHE_CONFIGURATION_CLASS);      &#125;      <span class="hljs-keyword">return</span> StringUtils.toStringArray(result);   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * Return the imports to use if the &#123;<span class="hljs-doctag">@link</span> AdviceMode&#125; is set to &#123;<span class="hljs-doctag">@link</span> AdviceMode#ASPECTJ&#125;.</span><span class="hljs-comment">    * &lt;p&gt;Take care of adding the necessary JSR-107 import if it is available.</span><span class="hljs-comment">    */</span>   <span class="hljs-keyword">private</span> String[] getAspectJImports() &#123;      List&lt;String&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-number">2</span>);      result.add(CACHE_ASPECT_CONFIGURATION_CLASS_NAME);      <span class="hljs-keyword">if</span> (jsr107Present &amp;&amp; jcacheImplPresent) &#123;         result.add(JCACHE_ASPECT_CONFIGURATION_CLASS_NAME);      &#125;      <span class="hljs-keyword">return</span> StringUtils.toStringArray(result);   &#125;&#125;</code></pre><p>ProxyCachingConfiguration类</p><p>这个类会创建一个缓存的advisor，此时的pointCut为检查类上是否有缓存相关的注解，Inteceptor为CacheInterceptor。同样的缓存切面也需要创建一个cacheManager缓存管理器。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProxyCachingConfiguration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractCachingConfiguration</span> </span>&#123;   <span class="hljs-meta">@Bean</span>(name = CacheManagementConfigUtils.CACHE_ADVISOR_BEAN_NAME)   <span class="hljs-meta">@Role</span>(BeanDefinition.ROLE_INFRASTRUCTURE)   <span class="hljs-function"><span class="hljs-keyword">public</span> BeanFactoryCacheOperationSourceAdvisor <span class="hljs-title">cacheAdvisor</span><span class="hljs-params">()</span> </span>&#123;      BeanFactoryCacheOperationSourceAdvisor advisor = <span class="hljs-keyword">new</span> BeanFactoryCacheOperationSourceAdvisor();      advisor.setCacheOperationSource(cacheOperationSource());      advisor.setAdvice(cacheInterceptor());      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.enableCaching != <span class="hljs-keyword">null</span>) &#123;         advisor.setOrder(<span class="hljs-keyword">this</span>.enableCaching.&lt;Integer&gt;getNumber(<span class="hljs-string">"order"</span>));      &#125;      <span class="hljs-keyword">return</span> advisor;   &#125;   <span class="hljs-meta">@Bean</span>   <span class="hljs-meta">@Role</span>(BeanDefinition.ROLE_INFRASTRUCTURE)   <span class="hljs-function"><span class="hljs-keyword">public</span> CacheOperationSource <span class="hljs-title">cacheOperationSource</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AnnotationCacheOperationSource();   &#125;   <span class="hljs-meta">@Bean</span>   <span class="hljs-meta">@Role</span>(BeanDefinition.ROLE_INFRASTRUCTURE)   <span class="hljs-function"><span class="hljs-keyword">public</span> CacheInterceptor <span class="hljs-title">cacheInterceptor</span><span class="hljs-params">()</span> </span>&#123;      CacheInterceptor interceptor = <span class="hljs-keyword">new</span> CacheInterceptor();      interceptor.configure(<span class="hljs-keyword">this</span>.errorHandler, <span class="hljs-keyword">this</span>.keyGenerator, <span class="hljs-keyword">this</span>.cacheResolver, <span class="hljs-keyword">this</span>.cacheManager);      interceptor.setCacheOperationSource(cacheOperationSource());      <span class="hljs-keyword">return</span> interceptor;   &#125;&#125;</code></pre><h3 id="缓存管理器的创建"><a href="#缓存管理器的创建" class="headerlink" title="缓存管理器的创建"></a>缓存管理器的创建</h3><p>同样的缓存切面也需要一个缓存管理器。缓存管理器中管理了缓存对象，比如redis缓存，map缓存，mongodb缓存，这些缓存对象都实现了Cache接口。</p><p>xml的创建方式</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"cacheManager"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.cache.support.SimpleCacheManager"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"caches"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span>            <span class="hljs-comment">&lt;!-- 这里可以配置多个redis --&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.xiangxue.jack.cache.RedisCache"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"redisTemplate"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"redisTemplate"</span> /&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"redisCache"</span>/&gt;</span>                <span class="hljs-comment">&lt;!-- name对应的名称要在类或方法的注解中使用 --&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.cache.concurrent.ConcurrentMapCacheFactoryBean"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"mapCache"</span>/&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.xiangxue.jack.cache.MongodbCache"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"collection"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"mongo_cache"</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"mongoCache"</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"mongoTemplate"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"mongoTemplate"</span>/&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><p>注解的创建方式</p><pre><code class="hljs java"><span class="hljs-meta">@PropertySource</span>(<span class="hljs-string">"classpath:redis/redis.properties"</span>)<span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisConfig</span> </span>&#123;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;redis.maxIdle&#125;"</span>)    <span class="hljs-keyword">private</span> Integer maxIdle;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;redis.maxWait&#125;"</span>)    <span class="hljs-keyword">private</span> Long maxWaitMillis;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;redis.testOnBorrow&#125;"</span>)    <span class="hljs-keyword">private</span> Boolean testOnBorrow;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;redis.host&#125;"</span>)    <span class="hljs-keyword">private</span> String hostName;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;redis.port&#125;"</span>)    <span class="hljs-keyword">private</span> Integer port;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> JedisPoolConfig <span class="hljs-title">jedisPoolConfig</span><span class="hljs-params">()</span></span>&#123;        JedisPoolConfig jedisPoolConfig = <span class="hljs-keyword">new</span> JedisPoolConfig();        jedisPoolConfig.setMaxIdle(maxIdle);        jedisPoolConfig.setMaxWaitMillis(maxWaitMillis);        jedisPoolConfig.setTestOnBorrow(testOnBorrow);        <span class="hljs-keyword">return</span> jedisPoolConfig;    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> RedisTemplate&lt;String, String&gt; <span class="hljs-title">redisTemplate</span><span class="hljs-params">(JedisConnectionFactory jedisConnectionFactory)</span></span>&#123;        RedisTemplate template = <span class="hljs-keyword">new</span> RedisTemplate();        template.setConnectionFactory(jedisConnectionFactory);        <span class="hljs-keyword">return</span> template;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSerializer</span><span class="hljs-params">(StringRedisTemplate template)</span></span>&#123;        <span class="hljs-meta">@SuppressWarnings</span>(&#123; <span class="hljs-string">"rawtypes"</span>, <span class="hljs-string">"unchecked"</span> &#125;)        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="hljs-keyword">new</span> Jackson2JsonRedisSerializer(Object<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        ObjectMapper om = <span class="hljs-keyword">new</span> ObjectMapper();        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);        jackson2JsonRedisSerializer.setObjectMapper(om);        template.setValueSerializer(jackson2JsonRedisSerializer);    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> JedisConnectionFactory <span class="hljs-title">jedisConnectionFactory</span><span class="hljs-params">(JedisPoolConfig jedisPoolConfig)</span></span>&#123;        JedisConnectionFactory jedisConnectionFactory = <span class="hljs-keyword">new</span> JedisConnectionFactory();        jedisConnectionFactory.setHostName(hostName);        jedisConnectionFactory.setPort(port);        jedisConnectionFactory.setPoolConfig(jedisPoolConfig);        <span class="hljs-keyword">return</span> jedisConnectionFactory;    &#125;&#125;</code></pre><p>CacheInterceptor与TransactionInterceptor中的流程基本相同只是实现功能不同，不再进行分析</p><h2 id="异步切面"><a href="#异步切面" class="headerlink" title="异步切面"></a>异步切面</h2><p>开启异步注解@EnableAsync，异步的使用也比较简单，直接在方法上加上Async即可，这里需要注意一下，如果采用异步，那么事务传播传播属性就会收到影响，异步是通过创建线程来实现的，这时是拿不到上个事务绑定的连接对象的，只能创建一个新的事务。</p><p>注册切面的过程基本一致，这里我们简单看下他的MethodInterceptor实现类AsyncExecutionInterceptor的invoke()方法</p><p>invoke()方法中会创建一个Callable类，然后将类交给executor去执行，如果返回值是一个Future类型，就会阻塞直到拿到返回值。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(<span class="hljs-keyword">final</span> MethodInvocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;   Class&lt;?&gt; targetClass = (invocation.getThis() != <span class="hljs-keyword">null</span> ? AopUtils.getTargetClass(invocation.getThis()) : <span class="hljs-keyword">null</span>);   Method specificMethod = ClassUtils.getMostSpecificMethod(invocation.getMethod(), targetClass);   <span class="hljs-keyword">final</span> Method userDeclaredMethod = BridgeMethodResolver.findBridgedMethod(specificMethod);   AsyncTaskExecutor executor = determineAsyncExecutor(userDeclaredMethod);   <span class="hljs-keyword">if</span> (executor == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(            <span class="hljs-string">"No executor specified and no default executor set on AsyncExecutionInterceptor either"</span>);   &#125;   Callable&lt;Object&gt; task = () -&gt; &#123;      <span class="hljs-keyword">try</span> &#123;         Object result = invocation.proceed();         <span class="hljs-keyword">if</span> (result <span class="hljs-keyword">instanceof</span> Future) &#123;            <span class="hljs-keyword">return</span> ((Future&lt;?&gt;) result).get();         &#125;      &#125;      <span class="hljs-keyword">catch</span> (ExecutionException ex) &#123;         handleError(ex.getCause(), userDeclaredMethod, invocation.getArguments());      &#125;      <span class="hljs-keyword">catch</span> (Throwable ex) &#123;         handleError(ex, userDeclaredMethod, invocation.getArguments());      &#125;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;   &#125;;   <span class="hljs-keyword">return</span> doSubmit(task, executor, invocation.getMethod().getReturnType());&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Spring源码解析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>源码解析</tag>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring的事务解析</title>
    <link href="/blog/2020/04/20/spring-%E4%BA%8B%E5%8A%A1%E8%A7%A3%E6%9E%90/"/>
    <url>/blog/2020/04/20/spring-%E4%BA%8B%E5%8A%A1%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="入口类的注册"><a href="#入口类的注册" class="headerlink" title="入口类的注册"></a>入口类的注册</h2><p>@EnableTransactionManaement注解中会引入TransactionManagementConfigurationSelector类</p><pre><code class="hljs java"><span class="hljs-meta">@Target</span>(ElementType.TYPE)<span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-meta">@Documented</span><span class="hljs-meta">@Import</span>(TransactionManagementConfigurationSelector<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> @<span class="hljs-title">interface</span> <span class="hljs-title">EnableTransactionManagement</span> </span>&#123;</code></pre><p>TransactionManagementConfigurationSelector类的selectImports()方法会在ConfigurationClassPostProcessor接口中调用，向spring中注册事务相关的切面对象。这里只分析比较重要的ProxyTransactionManagementConfiguration类。</p><pre><code class="hljs java"><span class="hljs-keyword">protected</span> String[] selectImports(AdviceMode adviceMode) &#123;   <span class="hljs-keyword">switch</span> (adviceMode) &#123;      <span class="hljs-keyword">case</span> PROXY:         <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String[] &#123;AutoProxyRegistrar<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getName</span>(),</span><span class="hljs-class">               <span class="hljs-title">ProxyTransactionManagementConfiguration</span>.<span class="hljs-title">class</span>.<span class="hljs-title">getName</span>()&#125;</span>;      <span class="hljs-keyword">case</span> ASPECTJ:         <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String[] &#123;determineTransactionAspectClass()&#125;;      <span class="hljs-keyword">default</span>:         <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;   &#125;&#125;</code></pre><p>TransactionManagementConfigurationSelector类</p><p>主要功能为：</p><ol><li>注册一个事务的AOP入口类（InfrastructureAdvisorAutoProxyCreator）</li><li>用@Bean的方式创建Advisor类并收集@Transactional注解中的属性设置到Advisor中，再创建一个在调用链中使用的TransactionInterceptor类设置到Advisor中。</li><li>创建一个DataSourceTransationManager事务管理器。</li></ol><p>在注册aop入口类时，如果已经被注册则会比较优先级，优先级比现有的入口类高才会注册进去替换到现有入口。优先级从低到高依次为：InfrastructureAdvisorAutoProxyCreator、AspectJAwareAdvisorAutoProxyGreator、AnnotationAwareAspectJAutoProxyCreator。第一个为事务AOP入口类，第二个为xml配置方式注册的入口类，第三个为注解方式的入口类。</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProxyTransactionManagementConfiguration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractTransactionManagementConfiguration</span> </span>&#123;   <span class="hljs-comment">/*</span><span class="hljs-comment">   * 创建事务切面实例</span><span class="hljs-comment">   * BeanFactoryTransactionAttributeSourceAdvisor</span><span class="hljs-comment">   *</span><span class="hljs-comment">   * */</span>   <span class="hljs-meta">@Bean</span>(name = TransactionManagementConfigUtils.TRANSACTION_ADVISOR_BEAN_NAME)   <span class="hljs-meta">@Role</span>(BeanDefinition.ROLE_INFRASTRUCTURE)   <span class="hljs-function"><span class="hljs-keyword">public</span> BeanFactoryTransactionAttributeSourceAdvisor <span class="hljs-title">transactionAdvisor</span><span class="hljs-params">()</span> </span>&#123;      BeanFactoryTransactionAttributeSourceAdvisor advisor = <span class="hljs-keyword">new</span> BeanFactoryTransactionAttributeSourceAdvisor();      advisor.setTransactionAttributeSource(transactionAttributeSource());      <span class="hljs-comment">//设置通知类</span>      advisor.setAdvice(transactionInterceptor());      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.enableTx != <span class="hljs-keyword">null</span>) &#123;         advisor.setOrder(<span class="hljs-keyword">this</span>.enableTx.&lt;Integer&gt;getNumber(<span class="hljs-string">"order"</span>));      &#125;      <span class="hljs-keyword">return</span> advisor;   &#125;   <span class="hljs-meta">@Bean</span>   <span class="hljs-meta">@Role</span>(BeanDefinition.ROLE_INFRASTRUCTURE)   <span class="hljs-function"><span class="hljs-keyword">public</span> TransactionAttributeSource <span class="hljs-title">transactionAttributeSource</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AnnotationTransactionAttributeSource();   &#125;   <span class="hljs-comment">/*</span><span class="hljs-comment">   * 创建事务advice</span><span class="hljs-comment">   * TransactionInterceptor</span><span class="hljs-comment">   * */</span>   <span class="hljs-meta">@Bean</span>   <span class="hljs-meta">@Role</span>(BeanDefinition.ROLE_INFRASTRUCTURE)   <span class="hljs-function"><span class="hljs-keyword">public</span> TransactionInterceptor <span class="hljs-title">transactionInterceptor</span><span class="hljs-params">()</span> </span>&#123;      TransactionInterceptor interceptor = <span class="hljs-keyword">new</span> TransactionInterceptor();      interceptor.setTransactionAttributeSource(transactionAttributeSource());      <span class="hljs-comment">//事务管理器要跟数据源挂钩，所以需要自己定义</span>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.txManager != <span class="hljs-keyword">null</span>) &#123;         interceptor.setTransactionManager(<span class="hljs-keyword">this</span>.txManager);      &#125;      <span class="hljs-keyword">return</span> interceptor;   &#125;&#125;</code></pre><p>自定义事务管理器的方式：</p><ul><li>实现TransactionManagementConfigurer接口</li></ul><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TransactionManagementConfigurerBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TransactionManagementConfigurer</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> DataSource dataSource;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> PlatformTransactionManager <span class="hljs-title">annotationDrivenTransactionManager</span><span class="hljs-params">()</span> </span>&#123;        DataSourceTransactionManager dtm = <span class="hljs-keyword">new</span> DataSourceTransactionManager();        dtm.setDataSource(dataSource);        <span class="hljs-keyword">return</span> dtm;    &#125;&#125;</code></pre><ul><li>创建PlatformTransactionManager类</li></ul><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-meta">@EnableTransactionManagement</span>(proxyTargetClass = <span class="hljs-keyword">false</span>)<span class="hljs-meta">@MapperScan</span>(basePackages = &#123;<span class="hljs-string">"com.xiangxue.jack.dao"</span>&#125;,annotationClass = Repository<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">EnableTransactionManagementBean</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> SqlSessionFactoryBean <span class="hljs-title">sqlSessionFactoryBean</span><span class="hljs-params">(DataSource dataSource)</span> </span>&#123;        SqlSessionFactoryBean sqlSessionFactoryBean = <span class="hljs-keyword">new</span> SqlSessionFactoryBean();        sqlSessionFactoryBean.setDataSource(dataSource);        <span class="hljs-keyword">return</span> sqlSessionFactoryBean;    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> PlatformTransactionManager <span class="hljs-title">annotationDrivenTransactionManager</span><span class="hljs-params">(DataSource dataSource)</span> </span>&#123;        DataSourceTransactionManager dtm = <span class="hljs-keyword">new</span> DataSourceTransactionManager();        dtm.setDataSource(dataSource);        <span class="hljs-keyword">return</span> dtm;    &#125;&#125;</code></pre><h2 id="TransactionInterceptor的分析"><a href="#TransactionInterceptor的分析" class="headerlink" title="TransactionInterceptor的分析"></a>TransactionInterceptor的分析</h2><p>在之前对aop的分析中，对代理方法的调用最终会落到Interceptor的invoke()方法，invokeWithinTransaction()方法是TransactionInterceptor.invoke()的主要方法，执行具体的事务操作。</p><p>该方法首先会调用getTransactionAttributeSource()获取到@Transactional的属性，然后获取到事务管理器，调用createTransactionIfNecessary()方法创建事务对象，然后进行调用链的火炬传递，最终会进入到被代理方法。如果被代理方法出现异常，就会进入catch中调用cleanupTransactionInfo()方法进行事务的回滚。如果没有异常然后调用commitTransactionAfterReturning()进行事务的提交。在事务提交和回滚的代码中会判断事务状态是否为最新，只要在事务状态为最新时，才会提交或回滚，提交完之后会回收数据库连接。</p><p>在有嵌套事务时内层的commitTransactionAfterReturning()方法会判断是否有savepoint，如果有就会抹掉所有savepoint，这样到达最外层的commitTransactionAfterReturning()时检测不到savepoint，就会全部提交。</p><p>在有嵌套事务时内层的cleanupTransactionInfo()方法会判断是否有savepoint，如果有就会按照savepoint回滚，注意，内层异常会向外层抛出，尽管内层按照回滚点回滚，但由于嵌套事务的connection与外层相同，外层捕获到异常触发cleanupTransactionInfo()后会导致全部回滚。解决方法为在外层手动捕获异常，避免触发cleanupTransactionInfo()。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">invokeWithinTransaction</span><span class="hljs-params">(Method method, @Nullable Class&lt;?&gt; targetClass,</span></span><span class="hljs-function"><span class="hljs-params">      <span class="hljs-keyword">final</span> InvocationCallback invocation)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;   <span class="hljs-comment">// If the transaction attribute is null, the method is non-transactional.</span>   <span class="hljs-comment">//获取事务属性类 AnnotationTransactionAttributeSource</span>   TransactionAttributeSource tas = getTransactionAttributeSource();   <span class="hljs-comment">//获取方法上面有@Transactional注解的属性</span>   <span class="hljs-keyword">final</span> TransactionAttribute txAttr = (tas != <span class="hljs-keyword">null</span> ? tas.getTransactionAttribute(method, targetClass) : <span class="hljs-keyword">null</span>);   <span class="hljs-comment">//获取事务管理器</span>   <span class="hljs-keyword">final</span> PlatformTransactionManager tm = determineTransactionManager(txAttr);   <span class="hljs-keyword">final</span> String joinpointIdentification = methodIdentification(method, targetClass, txAttr);   <span class="hljs-keyword">if</span> (txAttr == <span class="hljs-keyword">null</span> || !(tm <span class="hljs-keyword">instanceof</span> CallbackPreferringPlatformTransactionManager)) &#123;      <span class="hljs-comment">// Standard transaction demarcation with getTransaction and commit/rollback calls.</span>      TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);      Object retVal = <span class="hljs-keyword">null</span>;      <span class="hljs-keyword">try</span> &#123;         <span class="hljs-comment">// This is an around advice: Invoke the next interceptor in the chain.</span>         <span class="hljs-comment">// This will normally result in a target object being invoked.</span>         <span class="hljs-comment">//火炬传递</span>         retVal = invocation.proceedWithInvocation();      &#125;      <span class="hljs-keyword">catch</span> (Throwable ex) &#123;         <span class="hljs-comment">// target invocation exception</span>         <span class="hljs-comment">//事务回滚</span>         completeTransactionAfterThrowing(txInfo, ex);         <span class="hljs-keyword">throw</span> ex;      &#125;      <span class="hljs-keyword">finally</span> &#123;         cleanupTransactionInfo(txInfo);      &#125;      <span class="hljs-comment">//事务提交</span>      commitTransactionAfterReturning(txInfo);      <span class="hljs-keyword">return</span> retVal;   &#125;   <span class="hljs-comment">// 编程式事务，一般不会走</span>   <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">final</span> ThrowableHolder throwableHolder = <span class="hljs-keyword">new</span> ThrowableHolder();      <span class="hljs-comment">// It's a CallbackPreferringPlatformTransactionManager: pass a TransactionCallback in.</span>      <span class="hljs-keyword">try</span> &#123;         Object result = ((CallbackPreferringPlatformTransactionManager) tm).execute(txAttr, status -&gt; &#123;            TransactionInfo txInfo = prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);            <span class="hljs-keyword">try</span> &#123;               <span class="hljs-keyword">return</span> invocation.proceedWithInvocation();            &#125;            <span class="hljs-keyword">catch</span> (Throwable ex) &#123;               <span class="hljs-keyword">if</span> (txAttr.rollbackOn(ex)) &#123;                  <span class="hljs-comment">// A RuntimeException: will lead to a rollback.</span>                  <span class="hljs-keyword">if</span> (ex <span class="hljs-keyword">instanceof</span> RuntimeException) &#123;                     <span class="hljs-keyword">throw</span> (RuntimeException) ex;                  &#125;                  <span class="hljs-keyword">else</span> &#123;                     <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ThrowableHolderException(ex);                  &#125;               &#125;               <span class="hljs-keyword">else</span> &#123;                  <span class="hljs-comment">// A normal return value: will lead to a commit.</span>                  throwableHolder.throwable = ex;                  <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;               &#125;            &#125;            <span class="hljs-keyword">finally</span> &#123;               cleanupTransactionInfo(txInfo);            &#125;         &#125;);         <span class="hljs-comment">// Check result state: It might indicate a Throwable to rethrow.</span>         <span class="hljs-keyword">if</span> (throwableHolder.throwable != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">throw</span> throwableHolder.throwable;         &#125;         <span class="hljs-keyword">return</span> result;      &#125;      <span class="hljs-keyword">catch</span> (ThrowableHolderException ex) &#123;         <span class="hljs-keyword">throw</span> ex.getCause();      &#125;      <span class="hljs-keyword">catch</span> (TransactionSystemException ex2) &#123;         <span class="hljs-keyword">if</span> (throwableHolder.throwable != <span class="hljs-keyword">null</span>) &#123;            logger.error(<span class="hljs-string">"Application exception overridden by commit exception"</span>, throwableHolder.throwable);            ex2.initApplicationException(throwableHolder.throwable);         &#125;         <span class="hljs-keyword">throw</span> ex2;      &#125;      <span class="hljs-keyword">catch</span> (Throwable ex2) &#123;         <span class="hljs-keyword">if</span> (throwableHolder.throwable != <span class="hljs-keyword">null</span>) &#123;            logger.error(<span class="hljs-string">"Application exception overridden by commit exception"</span>, throwableHolder.throwable);         &#125;         <span class="hljs-keyword">throw</span> ex2;      &#125;   &#125;&#125;</code></pre><h3 id="createTransactionIfNecessary-方法"><a href="#createTransactionIfNecessary-方法" class="headerlink" title="createTransactionIfNecessary()方法"></a>createTransactionIfNecessary()方法</h3><p>主要逻辑为调用事务管理器的getTransaction()方法创建事务并返回一个事务状态对象。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> TransactionInfo <span class="hljs-title">createTransactionIfNecessary</span><span class="hljs-params">(@Nullable PlatformTransactionManager tm,</span></span><span class="hljs-function"><span class="hljs-params">      @Nullable TransactionAttribute txAttr, <span class="hljs-keyword">final</span> String joinpointIdentification)</span> </span>&#123;   <span class="hljs-comment">// If no name specified, apply method identification as transaction name.</span>   <span class="hljs-keyword">if</span> (txAttr != <span class="hljs-keyword">null</span> &amp;&amp; txAttr.getName() == <span class="hljs-keyword">null</span>) &#123;      txAttr = <span class="hljs-keyword">new</span> DelegatingTransactionAttribute(txAttr) &#123;         <span class="hljs-meta">@Override</span>         <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> joinpointIdentification;         &#125;      &#125;;   &#125;   TransactionStatus status = <span class="hljs-keyword">null</span>;   <span class="hljs-keyword">if</span> (txAttr != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">if</span> (tm != <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-comment">//开启事务，这里重点看</span>         status = tm.getTransaction(txAttr);      &#125;      <span class="hljs-keyword">else</span> &#123;         <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;            logger.debug(<span class="hljs-string">"Skipping transactional joinpoint ["</span> + joinpointIdentification +                  <span class="hljs-string">"] because no transaction manager has been configured"</span>);         &#125;      &#125;   &#125;   <span class="hljs-comment">//创建事务信息对象，记录新老事务信息对象</span>   <span class="hljs-keyword">return</span> prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);&#125;</code></pre><h3 id="getTransaction-方法"><a href="#getTransaction-方法" class="headerlink" title="getTransaction()方法"></a>getTransaction()方法</h3><ol><li><p>调用doGetTransaction()方法创建事务对象，如果当前线程已有connection会直接使用这个连接设置到事务对象，如果没有会在dobegin()方法中创建连接并绑定到当前线程，再次进入这个方法时会直接使用这个连接设置到事务对象。</p></li><li><p>调用isExistingTransaction()判断是否存在事务，判断逻辑为事务对象中是否有connection。如果有会直接调用handleExistingTransaction()方法处理已存在的事务并返回处理后的事务对象。</p></li><li><p>判断事务传播属性</p></li><li><p>创建事务状态对象，事务状态对象用于记录事务在运行时的特质，如事务是否是最新的。</p></li><li><p>调用doBegin()方法开启事务</p></li><li><p>调用prepareSynchronization()方法改变事务状态。</p></li></ol><p>传播属性用于告诉spring如何控制事务流转，这里只判断三种：</p><p>PROPAGATION_REQUIRED：如果没有事务就新建一个事务，如果有就加入到当前事务。</p><p>PROPAGATION_REQUIRES_NEW：如果没有事务就新建一个事务，如果有就挂起当前事务。</p><p>PROPAGATION_NESTED：如果有事务就嵌套在事务中执行。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> TransactionStatus <span class="hljs-title">getTransaction</span><span class="hljs-params">(@Nullable TransactionDefinition definition)</span> <span class="hljs-keyword">throws</span> TransactionException </span>&#123;   <span class="hljs-comment">//这里重点看，.DataSourceTransactionObject拿到对象</span>   Object transaction = doGetTransaction();   <span class="hljs-comment">// Cache debug flag to avoid repeated checks.</span>   <span class="hljs-keyword">boolean</span> debugEnabled = logger.isDebugEnabled();   <span class="hljs-keyword">if</span> (definition == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-comment">// Use defaults if no transaction definition given.</span>      definition = <span class="hljs-keyword">new</span> DefaultTransactionDefinition();   &#125;   <span class="hljs-comment">//第一次进来connectionHolder为空的，所以不存在事务</span>   <span class="hljs-keyword">if</span> (isExistingTransaction(transaction)) &#123;      <span class="hljs-comment">// Existing transaction found -&gt; check propagation behavior to find out how to behave.</span>      <span class="hljs-keyword">return</span> handleExistingTransaction(definition, transaction, debugEnabled);   &#125;   <span class="hljs-comment">// Check definition settings for new transaction.</span>   <span class="hljs-keyword">if</span> (definition.getTimeout() &lt; TransactionDefinition.TIMEOUT_DEFAULT) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidTimeoutException(<span class="hljs-string">"Invalid transaction timeout"</span>, definition.getTimeout());   &#125;   <span class="hljs-comment">// No existing transaction found -&gt; check propagation behavior to find out how to proceed.</span>   <span class="hljs-keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalTransactionStateException(            <span class="hljs-string">"No existing transaction found for transaction marked with propagation 'mandatory'"</span>);   &#125;   <span class="hljs-comment">//第一次进来大部分会走这里、对事务状态进行判断</span>   <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||         definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||         definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123;      <span class="hljs-comment">//先挂起</span>      SuspendedResourcesHolder suspendedResources = suspend(<span class="hljs-keyword">null</span>);         <span class="hljs-keyword">if</span> (debugEnabled) &#123;            logger.debug(<span class="hljs-string">"Creating new transaction with name ["</span> + definition.getName() + <span class="hljs-string">"]: "</span> + definition);         &#125;         <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">boolean</span> newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);            <span class="hljs-comment">//创建事务状态对象，其实就是封装了事务对象的一些信息，记录事务状态的</span>            DefaultTransactionStatus status = newTransactionStatus(                  definition, transaction, <span class="hljs-keyword">true</span>, newSynchronization, debugEnabled, suspendedResources);            <span class="hljs-comment">//开启事务,重点看看 DataSourceTransactionObject</span>            doBegin(transaction, definition);            <span class="hljs-comment">//开启事务后，改变事务状态</span>            prepareSynchronization(status, definition);            <span class="hljs-keyword">return</span> status;      &#125;      <span class="hljs-keyword">catch</span> (RuntimeException | Error ex) &#123;         resume(<span class="hljs-keyword">null</span>, suspendedResources);         <span class="hljs-keyword">throw</span> ex;      &#125;   &#125;   <span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">// Create "empty" transaction: no actual transaction, but potentially synchronization.</span>      <span class="hljs-keyword">if</span> (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT &amp;&amp; logger.isWarnEnabled()) &#123;         logger.warn(<span class="hljs-string">"Custom isolation level specified but no actual transaction initiated; "</span> +               <span class="hljs-string">"isolation level will effectively be ignored: "</span> + definition);      &#125;      <span class="hljs-keyword">boolean</span> newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);      <span class="hljs-keyword">return</span> prepareTransactionStatus(definition, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">true</span>, newSynchronization, debugEnabled, <span class="hljs-keyword">null</span>);   &#125;&#125;</code></pre><h4 id="doGetTransaction-方法"><a href="#doGetTransaction-方法" class="headerlink" title="doGetTransaction()方法"></a>doGetTransaction()方法</h4><p>该方法中首先会创建DataSourceTransactionObject事务对象，设置事务是否允许嵌套，然后调用getResource()方法获取数据库的连接。DataSourceTransactionObject中持有一个包装后的连接对象。传播属性主要用于控制方法是否使用事务，是否使用同一个事务。事务对象的作用是标识当前线程是否有事务，是否是最新的，包装connection对象。是否使用同一个事务是靠控制事务对象的connection来实现的。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">doGetTransaction</span><span class="hljs-params">()</span> </span>&#123;   <span class="hljs-comment">//管理connection对象，创建回滚点，按照回滚点回滚，释放回滚点</span>   DataSourceTransactionObject txObject = <span class="hljs-keyword">new</span> DataSourceTransactionObject();   <span class="hljs-comment">//DataSourceTransactionManager默认是允许嵌套事务的</span>   txObject.setSavepointAllowed(isNestedTransactionAllowed());   <span class="hljs-comment">//obtainDataSource() 获取数据源对象，其实就是数据库连接块对象</span>   ConnectionHolder conHolder =         (ConnectionHolder) TransactionSynchronizationManager.getResource(obtainDataSource());   txObject.setConnectionHolder(conHolder, <span class="hljs-keyword">false</span>);   <span class="hljs-keyword">return</span> txObject;&#125;</code></pre><p>getResource()方法</p><p>doGetResource()是getResource()方法的主要方法，主要逻辑为从resources对象中获取数据库连接对象。resources对象为Map类型的ThreadLocal容器，Map存储的是连接池对象与连接对象的映射。如果事务传播属性为REQUIRED，则会获取同一个连接对象。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">doGetResource</span><span class="hljs-params">(Object actualKey)</span> </span>&#123;   Map&lt;Object, Object&gt; map = resources.get();   <span class="hljs-keyword">if</span> (map == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;   &#125;   Object value = map.get(actualKey);   <span class="hljs-comment">// Transparently remove ResourceHolder that was marked as void...</span>   <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> ResourceHolder &amp;&amp; ((ResourceHolder) value).isVoid()) &#123;      map.remove(actualKey);      <span class="hljs-comment">// Remove entire ThreadLocal if empty...</span>      <span class="hljs-keyword">if</span> (map.isEmpty()) &#123;         resources.remove();      &#125;      value = <span class="hljs-keyword">null</span>;   &#125;   <span class="hljs-keyword">return</span> value;&#125;</code></pre><h4 id="doBegin-方法"><a href="#doBegin-方法" class="headerlink" title="doBegin()方法"></a>doBegin()方法</h4><p>如果没有数据库连接首先会获取数据库连接，设置到事务对象，然后设置事务的隔离级别、将连接的autoCommit()设置为false开启事务、设置事务是否只读、将事务对象设置为活跃的，最后如果是新创建的事务就调用bindResource()方法绑定连接对象。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doBegin</span><span class="hljs-params">(Object transaction, TransactionDefinition definition)</span> </span>&#123;   DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;   Connection con = <span class="hljs-keyword">null</span>;   <span class="hljs-keyword">try</span> &#123;      <span class="hljs-comment">//如果没有数据库连接</span>      <span class="hljs-keyword">if</span> (!txObject.hasConnectionHolder() ||            txObject.getConnectionHolder().isSynchronizedWithTransaction()) &#123;         <span class="hljs-comment">//从连接池里面获取连接</span>         Connection newCon = obtainDataSource().getConnection();         <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;            logger.debug(<span class="hljs-string">"Acquired Connection ["</span> + newCon + <span class="hljs-string">"] for JDBC transaction"</span>);         &#125;         <span class="hljs-comment">//把连接包装成ConnectionHolder，然后设置到事务对象中</span>         txObject.setConnectionHolder(<span class="hljs-keyword">new</span> ConnectionHolder(newCon), <span class="hljs-keyword">true</span>);      &#125;      txObject.getConnectionHolder().setSynchronizedWithTransaction(<span class="hljs-keyword">true</span>);      con = txObject.getConnectionHolder().getConnection();      <span class="hljs-comment">//从数据库连接中获取隔离级别</span>      Integer previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(con, definition);      txObject.setPreviousIsolationLevel(previousIsolationLevel);      <span class="hljs-comment">// Switch to manual commit if necessary. This is very expensive in some JDBC drivers,</span>      <span class="hljs-comment">// so we don't want to do it unnecessarily (for example if we've explicitly</span>      <span class="hljs-comment">// configured the connection pool to set it already).</span>      <span class="hljs-keyword">if</span> (con.getAutoCommit()) &#123;         txObject.setMustRestoreAutoCommit(<span class="hljs-keyword">true</span>);         <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;            logger.debug(<span class="hljs-string">"Switching JDBC Connection ["</span> + con + <span class="hljs-string">"] to manual commit"</span>);         &#125;         <span class="hljs-comment">//关闭连接的自动提交，其实这步就是开启了事务</span>         con.setAutoCommit(<span class="hljs-keyword">false</span>);      &#125;      <span class="hljs-comment">//设置只读事务 从这一点设置的时间点开始（时间点a）到这个事务结束的过程中，其他事务所提交的数据，该事务将看不见！</span>      <span class="hljs-comment">//设置只读事务就是告诉数据库，我这个事务内没有新增，修改，删除操作只有查询操作，不需要数据库锁等操作，减少数据库压力</span>      prepareTransactionalConnection(con, definition);      <span class="hljs-comment">//自己提交关闭了，就说明已经开启事务了，事务是活动的</span>      txObject.getConnectionHolder().setTransactionActive(<span class="hljs-keyword">true</span>);      <span class="hljs-keyword">int</span> timeout = determineTimeout(definition);      <span class="hljs-keyword">if</span> (timeout != TransactionDefinition.TIMEOUT_DEFAULT) &#123;         txObject.getConnectionHolder().setTimeoutInSeconds(timeout);      &#125;      <span class="hljs-comment">// Bind the connection holder to the thread.</span>      <span class="hljs-keyword">if</span> (txObject.isNewConnectionHolder()) &#123;         <span class="hljs-comment">//如果是新创建的事务，则建立当前线程和数据库连接的关系</span>         TransactionSynchronizationManager.bindResource(obtainDataSource(), txObject.getConnectionHolder());      &#125;   &#125;   <span class="hljs-keyword">catch</span> (Throwable ex) &#123;      <span class="hljs-keyword">if</span> (txObject.isNewConnectionHolder()) &#123;         DataSourceUtils.releaseConnection(con, obtainDataSource());         txObject.setConnectionHolder(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);      &#125;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> CannotCreateTransactionException(<span class="hljs-string">"Could not open JDBC Connection for transaction"</span>, ex);   &#125;&#125;</code></pre><p>bindResource()方法</p><p>将map设置到resources对象中与当前线程绑定，并将连接池对象与连接对象的映射关系放入map中提供给创建事务对象时调用的getResource()方法使用。这里绑定连接池对象与连接对象的是为了处理多数据源的情况。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bindResource</span><span class="hljs-params">(Object key, Object value)</span> <span class="hljs-keyword">throws</span> IllegalStateException </span>&#123;   Object actualKey = TransactionSynchronizationUtils.unwrapResourceIfNecessary(key);   Assert.notNull(value, <span class="hljs-string">"Value must not be null"</span>);   Map&lt;Object, Object&gt; map = resources.get();   <span class="hljs-comment">// set ThreadLocal Map if none found</span>   <span class="hljs-keyword">if</span> (map == <span class="hljs-keyword">null</span>) &#123;      map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();      resources.set(map);   &#125;   Object oldValue = map.put(actualKey, value);   <span class="hljs-comment">// Transparently suppress a ResourceHolder that was marked as void...</span>   <span class="hljs-keyword">if</span> (oldValue <span class="hljs-keyword">instanceof</span> ResourceHolder &amp;&amp; ((ResourceHolder) oldValue).isVoid()) &#123;      oldValue = <span class="hljs-keyword">null</span>;   &#125;   <span class="hljs-keyword">if</span> (oldValue != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Already value ["</span> + oldValue + <span class="hljs-string">"] for key ["</span> +            actualKey + <span class="hljs-string">"] bound to thread ["</span> + Thread.currentThread().getName() + <span class="hljs-string">"]"</span>);   &#125;   <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;      logger.trace(<span class="hljs-string">"Bound value ["</span> + value + <span class="hljs-string">"] for key ["</span> + actualKey + <span class="hljs-string">"] to thread ["</span> +            Thread.currentThread().getName() + <span class="hljs-string">"]"</span>);   &#125;&#125;</code></pre><h4 id="handleExistingTransaction-方法"><a href="#handleExistingTransaction-方法" class="headerlink" title="handleExistingTransaction()方法"></a>handleExistingTransaction()方法</h4><p>主要是根据传播属性对事务进行处理，这里只着重分析PROPAGATION_REQUIRES_NEW跟PROPAGATION_NESTED的情况。</p><p>PROPAGATION_REQUIRES_NEW会挂起当前事务，然后调用dobegin()方法为事务对象重新设置连接。挂起的逻辑比较简单就是将事务对象的connection设置为空，然后解除connection跟线程的绑定关系。</p><p>PROPAGATION_NESTED会将事务状态设置为非最新，然后创建一个savepoint。</p><p>如果是默认传播属性，只将事务状态设置为非最新。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> TransactionStatus <span class="hljs-title">handleExistingTransaction</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">      TransactionDefinition definition, Object transaction, <span class="hljs-keyword">boolean</span> debugEnabled)</span></span><span class="hljs-function">      <span class="hljs-keyword">throws</span> TransactionException </span>&#123;   <span class="hljs-comment">//不允许有事务，直接异常</span>   <span class="hljs-keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NEVER) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalTransactionStateException(            <span class="hljs-string">"Existing transaction found for transaction marked with propagation 'never'"</span>);   &#125;   <span class="hljs-comment">//以非事务方式执行操作，如果当前存在事务，就把当前事务挂起</span>   <span class="hljs-keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) &#123;      <span class="hljs-keyword">if</span> (debugEnabled) &#123;         logger.debug(<span class="hljs-string">"Suspending current transaction"</span>);      &#125;      <span class="hljs-comment">//挂起当前事务</span>      Object suspendedResources = suspend(transaction);      <span class="hljs-keyword">boolean</span> newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);      <span class="hljs-comment">//修改事务状态信息，把事务的一些信息存储到当前线程中，ThreadLocal中</span>      <span class="hljs-keyword">return</span> prepareTransactionStatus(            definition, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>, newSynchronization, debugEnabled, suspendedResources);   &#125;   <span class="hljs-keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) &#123;      <span class="hljs-keyword">if</span> (debugEnabled) &#123;         logger.debug(<span class="hljs-string">"Suspending current transaction, creating new transaction with name ["</span> +               definition.getName() + <span class="hljs-string">"]"</span>);      &#125;      <span class="hljs-comment">//挂起</span>      SuspendedResourcesHolder suspendedResources = suspend(transaction);      <span class="hljs-keyword">try</span> &#123;         <span class="hljs-keyword">boolean</span> newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);         DefaultTransactionStatus status = newTransactionStatus(               definition, transaction, <span class="hljs-keyword">true</span>, newSynchronization, debugEnabled, suspendedResources);         doBegin(transaction, definition);         prepareSynchronization(status, definition);         <span class="hljs-keyword">return</span> status;      &#125;      <span class="hljs-keyword">catch</span> (RuntimeException | Error beginEx) &#123;         resumeAfterBeginException(transaction, suspendedResources, beginEx);         <span class="hljs-keyword">throw</span> beginEx;      &#125;   &#125;   <span class="hljs-keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123;      <span class="hljs-keyword">if</span> (!isNestedTransactionAllowed()) &#123;         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NestedTransactionNotSupportedException(               <span class="hljs-string">"Transaction manager does not allow nested transactions by default - "</span> +               <span class="hljs-string">"specify 'nestedTransactionAllowed' property with value 'true'"</span>);      &#125;      <span class="hljs-keyword">if</span> (debugEnabled) &#123;         logger.debug(<span class="hljs-string">"Creating nested transaction with name ["</span> + definition.getName() + <span class="hljs-string">"]"</span>);      &#125;      <span class="hljs-comment">//默认是可以嵌套事务的</span>      <span class="hljs-keyword">if</span> (useSavepointForNestedTransaction()) &#123;         <span class="hljs-comment">// Create savepoint within existing Spring-managed transaction,</span>         <span class="hljs-comment">// through the SavepointManager API implemented by TransactionStatus.</span>         <span class="hljs-comment">// Usually uses JDBC 3.0 savepoints. Never activates Spring synchronization.</span>         DefaultTransactionStatus status =               prepareTransactionStatus(definition, transaction, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, debugEnabled, <span class="hljs-keyword">null</span>);         <span class="hljs-comment">//创建回滚点</span>         status.createAndHoldSavepoint();         <span class="hljs-keyword">return</span> status;      &#125;      <span class="hljs-keyword">else</span> &#123;         <span class="hljs-comment">// Nested transaction through nested begin and commit/rollback calls.</span>         <span class="hljs-comment">// Usually only for JTA: Spring synchronization might get activated here</span>         <span class="hljs-comment">// in case of a pre-existing JTA transaction.</span>         <span class="hljs-keyword">boolean</span> newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);         DefaultTransactionStatus status = newTransactionStatus(               definition, transaction, <span class="hljs-keyword">true</span>, newSynchronization, debugEnabled, <span class="hljs-keyword">null</span>);         doBegin(transaction, definition);         prepareSynchronization(status, definition);         <span class="hljs-keyword">return</span> status;      &#125;   &#125;   <span class="hljs-comment">// Assumably PROPAGATION_SUPPORTS or PROPAGATION_REQUIRED.</span>   <span class="hljs-keyword">if</span> (debugEnabled) &#123;      logger.debug(<span class="hljs-string">"Participating in existing transaction"</span>);   &#125;   <span class="hljs-keyword">if</span> (isValidateExistingTransaction()) &#123;      <span class="hljs-keyword">if</span> (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) &#123;         Integer currentIsolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel();         <span class="hljs-keyword">if</span> (currentIsolationLevel == <span class="hljs-keyword">null</span> || currentIsolationLevel != definition.getIsolationLevel()) &#123;            Constants isoConstants = DefaultTransactionDefinition.constants;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalTransactionStateException(<span class="hljs-string">"Participating transaction with definition ["</span> +                  definition + <span class="hljs-string">"] specifies isolation level which is incompatible with existing transaction: "</span> +                  (currentIsolationLevel != <span class="hljs-keyword">null</span> ?                        isoConstants.toCode(currentIsolationLevel, DefaultTransactionDefinition.PREFIX_ISOLATION) :                        <span class="hljs-string">"(unknown)"</span>));         &#125;      &#125;      <span class="hljs-keyword">if</span> (!definition.isReadOnly()) &#123;         <span class="hljs-keyword">if</span> (TransactionSynchronizationManager.isCurrentTransactionReadOnly()) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalTransactionStateException(<span class="hljs-string">"Participating transaction with definition ["</span> +                  definition + <span class="hljs-string">"] is not marked as read-only but existing transaction is"</span>);         &#125;      &#125;   &#125;   <span class="hljs-keyword">boolean</span> newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);   <span class="hljs-keyword">return</span> prepareTransactionStatus(definition, transaction, <span class="hljs-keyword">false</span>, newSynchronization, debugEnabled, <span class="hljs-keyword">null</span>);&#125;</code></pre><h2 id="编程式事务"><a href="#编程式事务" class="headerlink" title="编程式事务"></a>编程式事务</h2><p>编程式事务相比注解式事务粒度更细，如果方法流程很长注解式事务会产生连接占用问题，导致整个系统吞吐量下降。注解事务由于隔离级别的不同，可能导致可重复读的问题，比如使用数据库实现的乐观锁，在重复竞争锁时由于都是同一个连接对象，所以每次查询的数据都是一样的，这就会导致一个死循环。</p><p>getTicket()方法递归调用的时候，在可重复读的隔离级别下查询的数据是一样的，永远获取不到锁。</p><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getTicket</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//1、获取锁</span>    List&lt;ZgTicket&gt; zgTickets = commonMapper.queryTicketById(<span class="hljs-string">"12306"</span>);    Map lockmap = <span class="hljs-keyword">new</span> HashMap();    lockmap.put(<span class="hljs-string">"ticketId"</span>, <span class="hljs-string">"12306"</span>);    lockmap.put(<span class="hljs-string">"version"</span>, zgTickets.get(<span class="hljs-number">0</span>).getVersion());    <span class="hljs-keyword">int</span> i = commonMapper.updateLock(lockmap);    <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">//抢票</span>        ZgTicket zgTicket = zgTickets.get(<span class="hljs-number">0</span>);        zgTicket.setTicketCount(<span class="hljs-number">2</span>);        <span class="hljs-keyword">int</span> i1 = commonMapper.updateTicket(zgTicket);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">//继续抢</span>        ((TransationService) AopContext.currentProxy()).getTicket();    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>编程式事务在执行execute()前会自动开启时候，执行后就自动提交了事务。</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getTicketModeOne</span><span class="hljs-params">()</span> </span>&#123;    Integer execute = transactionTemplate.execute(status -&gt; &#123;        <span class="hljs-comment">//1、获取锁</span>        List&lt;ZgTicket&gt; zgTickets = commonMapper.queryTicketById(<span class="hljs-string">"12306"</span>);        Map lockmap = <span class="hljs-keyword">new</span> HashMap();        lockmap.put(<span class="hljs-string">"ticketId"</span>, <span class="hljs-string">"12306"</span>);        lockmap.put(<span class="hljs-string">"version"</span>, zgTickets.get(<span class="hljs-number">0</span>).getVersion());        <span class="hljs-keyword">int</span> i = commonMapper.updateLock(lockmap);        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">//抢票</span>            ZgTicket zgTicket = zgTickets.get(<span class="hljs-number">0</span>);            zgTicket.setTicketCount(<span class="hljs-number">2</span>);            <span class="hljs-keyword">int</span> i1 = commonMapper.updateTicket(zgTicket);        &#125;        <span class="hljs-keyword">return</span> i;    &#125;);    <span class="hljs-keyword">if</span> (execute == <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">//继续抢</span>        getTicketModeOne();    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>编程式事务控制粒度更细，不需要事务控制的代码可以不放在execute()方法内。</p><p>还可以手动控制事务</p><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span>PlatformTransactionManager platformTransactionManager;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">xxx</span><span class="hljs-params">()</span> </span>&#123;    DefaultTransactionDefinition defaultTransactionDefinition = <span class="hljs-keyword">new</span> DefaultTransactionDefinition();    defaultTransactionDefinition.setPropagationBehavior(<span class="hljs-number">0</span>);    TransactionStatus transaction = platformTransactionManager.getTransaction(defaultTransactionDefinition);    <span class="hljs-keyword">try</span> &#123;        System.out.println(<span class="hljs-string">"业务代码"</span>);    &#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;        platformTransactionManager.rollback(transaction);    &#125;    platformTransactionManager.commit(transaction);&#125;</code></pre><p>把控制代码可以写到切面中，跟业务代码解耦。</p>]]></content>
    
    
    <categories>
      
      <category>Spring源码解析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>源码解析</tag>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AOP源码解析</title>
    <link href="/blog/2020/04/19/spring-AOP%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/blog/2020/04/19/spring-AOP%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="AOP的入口解析"><a href="#AOP的入口解析" class="headerlink" title="AOP的入口解析"></a>AOP的入口解析</h2><p>在<a href="[http://zgcheng.top/2020/04/15/spring%E5%AE%9E%E4%BE%8B%E5%8C%96bean%E7%9A%84%E8%BF%87%E7%A8%8B/#initializeBean-%E6%96%B9%E6%B3%95](http://zgcheng.top/2020/04/15/spring实例化bean的过程/#initializeBean-方法)">spring实例化bean的过程</a>中我们提到过，applyBeanPostProcessorsAfterInitialization()方法是aop的入口。首先会将原始实例传入该方法，该方法会将原始实例替换为代理实例。该方法也是BeanPostProcessor的运用，最终会落入AbstractAutoProxyCreator类的wrapIfNecessary()方法。</p><h3 id="AbstractAutoProxyCreator类的来源"><a href="#AbstractAutoProxyCreator类的来源" class="headerlink" title="AbstractAutoProxyCreator类的来源"></a>AbstractAutoProxyCreator类的来源</h3><p>在进行aop标签解析时会创建org.springframework.aop.config.AopNamespaceHandler类，该类注册的aspectj-autoproxy解析类AspectJAutoProxyBeanDefinitionParser会注册AnnotationAwareAspectJAutoProxyCreator类，该类就是AbstractAutoProxyCreator的子类。</p><p>@EnableAspectJAutoProxy注解会引入AspectJAutoProxyRegistrar类，该类中有一个registerBeanDefinitions方法，该方法用于注册一个AnnotationAwareAspectJAutoProxyCreator类并进行proxyTargetClass、exposeProxy属性的设置。AUTO_PROXY_CREATOR_BEAN_NAME属性为BeanDefinition的名称。</p><p>AspectJAutoProxyRegistrar构造函数</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AspectJAutoProxyRegistrar</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ImportBeanDefinitionRegistrar</span> </span>&#123;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Register, escalate, and configure the AspectJ auto proxy creator based on the value</span><span class="hljs-comment"> * of the @&#123;<span class="hljs-doctag">@link</span> EnableAspectJAutoProxy#proxyTargetClass()&#125; attribute on the importing</span><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@code</span> <span class="hljs-doctag">@Configuration</span>&#125; class.</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinitions</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;<span class="hljs-comment">//注册注解AOP入口类</span>AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);<span class="hljs-comment">/*</span><span class="hljs-comment">* * true</span><span class="hljs-comment"> * 1、目标对象实现了接口 – 使用CGLIB代理机制</span><span class="hljs-comment"> * 2、目标对象没有接口(只有实现类) – 使用CGLIB代理机制</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * false</span><span class="hljs-comment"> * 1、目标对象实现了接口 – 使用JDK动态代理机制(代理所有实现了的接口)</span><span class="hljs-comment"> * 2、目标对象没有接口(只有实现类) – 使用CGLIB代理机制</span><span class="hljs-comment">* */</span>AnnotationAttributes enableAspectJAutoProxy =AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<span class="hljs-keyword">if</span> (enableAspectJAutoProxy != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="hljs-string">"proxyTargetClass"</span>)) &#123;AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);&#125;<span class="hljs-comment">//是否需要把代理对象暴露出来，简单来说是否需要把代理对象用ThreadLocal存起来，如果是true就是需要</span><span class="hljs-keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="hljs-string">"exposeProxy"</span>)) &#123;AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);&#125;&#125;&#125;&#125;</code></pre><h2 id="AOP的过程解析"><a href="#AOP的过程解析" class="headerlink" title="AOP的过程解析"></a>AOP的过程解析</h2><p>wrapIfNecessary()方法</p><p>该方法会调用getAdvicesAndAdvisorsForBean()方法判断类是否需要代理，如果需要会返回一个不为空的切面数组，然后将切面数组传递给createProxy()方法创建一个代理，在创建之前会将被代理对象封装为SingletonTargetSource对象。为bean创建一个代理类，最终放入一级缓存的是代理类。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">wrapIfNecessary</span><span class="hljs-params">(Object bean, String beanName, Object cacheKey)</span> </span>&#123;<span class="hljs-keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="hljs-keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;<span class="hljs-keyword">return</span> bean;&#125;<span class="hljs-keyword">if</span> (Boolean.FALSE.equals(<span class="hljs-keyword">this</span>.advisedBeans.get(cacheKey))) &#123;<span class="hljs-keyword">return</span> bean;&#125;<span class="hljs-keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;<span class="hljs-keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);<span class="hljs-keyword">return</span> bean;&#125;<span class="hljs-comment">//创建当前bean的代理，如果这个bean有advice的话，重点看，重要程度5</span><span class="hljs-comment">// Create proxy if we have advice.</span>Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="hljs-keyword">null</span>);<span class="hljs-comment">//如果有切面，则生成该bean的代理</span><span class="hljs-keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;<span class="hljs-keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);<span class="hljs-comment">//把被代理对象bean实例封装到SingletonTargetSource对象中</span>Object proxy = createProxy(bean.getClass(), beanName, specificInterceptors, <span class="hljs-keyword">new</span> SingletonTargetSource(bean));<span class="hljs-keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());<span class="hljs-keyword">return</span> proxy;&#125;<span class="hljs-keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);<span class="hljs-keyword">return</span> bean;</code></pre><h3 id="getAdvicesAndAdvisorsForBean-方法"><a href="#getAdvicesAndAdvisorsForBean-方法" class="headerlink" title="getAdvicesAndAdvisorsForBean()方法"></a>getAdvicesAndAdvisorsForBean()方法</h3><p>findEligibleAdvisors()方法收集所有@Aspect注解的所有类，收集完之后循环进行匹配。</p><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Object[] getAdvicesAndAdvisorsForBean(Class&lt;?&gt; beanClass, String beanName, <span class="hljs-meta">@Nullable</span> TargetSource targetSource) &#123;<span class="hljs-comment">//找到合格的切面，重点看</span>List&lt;Advisor&gt; advisors = findEligibleAdvisors(beanClass, beanName);<span class="hljs-keyword">if</span> (advisors.isEmpty()) &#123;<span class="hljs-keyword">return</span> DO_NOT_PROXY;&#125;<span class="hljs-keyword">return</span> advisors.toArray();&#125;</code></pre><p>findEligibleAdvisors()方法</p><p>该方法会调用findCandidateAdvisors()方法获取@Aspectj注解的所有类，然后调用findAdvisorsThatCanApply()方法匹配可以作用在类上的切面，然后拿到匹配的切面，再调用sortAdvisors()方法进行排序。findAdvisorsThatCanApply()方法其实就是根据PointCut对类名进行模糊匹配，这时还不对方法名进行匹配，因为这里只是判断类是否需要代理。这里不再对这个方法分析。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> List&lt;Advisor&gt; <span class="hljs-title">findEligibleAdvisors</span><span class="hljs-params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;<span class="hljs-comment">//找到候选的切面,其实就是一个寻找有@Aspectj注解的过程，把工程中所有有这个注解的类封装成Advisor返回</span>List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();<span class="hljs-comment">//判断候选的切面是否作用在当前beanClass上面，就是一个匹配过程。。现在就是一个匹配</span>List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);extendAdvisors(eligibleAdvisors);<span class="hljs-keyword">if</span> (!eligibleAdvisors.isEmpty()) &#123;<span class="hljs-comment">//对有@Order@Priority进行排序</span>eligibleAdvisors = sortAdvisors(eligibleAdvisors);&#125;<span class="hljs-keyword">return</span> eligibleAdvisors;&#125;</code></pre><p>findCandidateAdvisors()方法</p><p>buildAspectJAdvisors()方法是findCandidateAdvisors()方法的主要方法。该方法会获取当前spring容器中的所有BeanName后循环判断bean上是否有@Aspect注解，然后创建获取有@Aspect注解类的实例工厂，然后调用其getAdvisors()方法</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Advisor&gt; <span class="hljs-title">buildAspectJAdvisors</span><span class="hljs-params">()</span> </span>&#123;List&lt;String&gt; aspectNames = <span class="hljs-keyword">this</span>.aspectBeanNames;<span class="hljs-keyword">if</span> (aspectNames == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;aspectNames = <span class="hljs-keyword">this</span>.aspectBeanNames;<span class="hljs-keyword">if</span> (aspectNames == <span class="hljs-keyword">null</span>) &#123;List&lt;Advisor&gt; advisors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();aspectNames = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<span class="hljs-comment">//获取spring容器中的所有bean的名称BeanName</span>String[] beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(<span class="hljs-keyword">this</span>.beanFactory, Object<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">true</span>, <span class="hljs-title">false</span>)</span>;<span class="hljs-keyword">for</span> (String beanName : beanNames) &#123;<span class="hljs-keyword">if</span> (!isEligibleBean(beanName)) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-comment">// We must be careful not to instantiate beans eagerly as in this case they</span><span class="hljs-comment">// would be cached by the Spring container but would not have been weaved.</span>Class&lt;?&gt; beanType = <span class="hljs-keyword">this</span>.beanFactory.getType(beanName);<span class="hljs-keyword">if</span> (beanType == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-comment">//判断类上是否有@Aspect注解</span><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.advisorFactory.isAspect(beanType)) &#123;aspectNames.add(beanName);AspectMetadata amd = <span class="hljs-keyword">new</span> AspectMetadata(beanType, beanName);<span class="hljs-keyword">if</span> (amd.getAjType().getPerClause().getKind() == PerClauseKind.SINGLETON) &#123;<span class="hljs-comment">//创建获取有@Aspect注解类的实例工厂，负责获取有@Aspect注解类的实例</span>MetadataAwareAspectInstanceFactory factory =<span class="hljs-keyword">new</span> BeanFactoryAspectInstanceFactory(<span class="hljs-keyword">this</span>.beanFactory, beanName);<span class="hljs-comment">//创建切面advisor对象</span>List&lt;Advisor&gt; classAdvisors = <span class="hljs-keyword">this</span>.advisorFactory.getAdvisors(factory);<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.beanFactory.isSingleton(beanName)) &#123;<span class="hljs-keyword">this</span>.advisorsCache.put(beanName, classAdvisors);&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">this</span>.aspectFactoryCache.put(beanName, factory);&#125;advisors.addAll(classAdvisors);&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// Per target or per this.</span><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.beanFactory.isSingleton(beanName)) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Bean with name '"</span> + beanName +<span class="hljs-string">"' is a singleton, but aspect instantiation model is not singleton"</span>);&#125;MetadataAwareAspectInstanceFactory factory =<span class="hljs-keyword">new</span> PrototypeAspectInstanceFactory(<span class="hljs-keyword">this</span>.beanFactory, beanName);<span class="hljs-keyword">this</span>.aspectFactoryCache.put(beanName, factory);advisors.addAll(<span class="hljs-keyword">this</span>.advisorFactory.getAdvisors(factory));&#125;&#125;&#125;<span class="hljs-keyword">this</span>.aspectBeanNames = aspectNames;<span class="hljs-keyword">return</span> advisors;&#125;&#125;&#125;<span class="hljs-keyword">if</span> (aspectNames.isEmpty()) &#123;<span class="hljs-keyword">return</span> Collections.emptyList();&#125;List&lt;Advisor&gt; advisors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<span class="hljs-keyword">for</span> (String aspectName : aspectNames) &#123;List&lt;Advisor&gt; cachedAdvisors = <span class="hljs-keyword">this</span>.advisorsCache.get(aspectName);<span class="hljs-keyword">if</span> (cachedAdvisors != <span class="hljs-keyword">null</span>) &#123;advisors.addAll(cachedAdvisors);&#125;<span class="hljs-keyword">else</span> &#123;MetadataAwareAspectInstanceFactory factory = <span class="hljs-keyword">this</span>.aspectFactoryCache.get(aspectName);advisors.addAll(<span class="hljs-keyword">this</span>.advisorFactory.getAdvisors(factory));&#125;&#125;<span class="hljs-keyword">return</span> advisors;&#125;</code></pre><p>getAdvisors()方法</p><p>该方法会获取到有@Aspect注解的类名称。然后拿到没有@PointCut注解的所有方法，这样做是因为@PointCut并方法大多数情况下是空方法。然后调用getAdvisor()方法获取到advisor对象。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Advisor&gt; <span class="hljs-title">getAdvisors</span><span class="hljs-params">(MetadataAwareAspectInstanceFactory aspectInstanceFactory)</span> </span>&#123;<span class="hljs-comment">//从工厂中获取有@Aspect注解的类Class</span>Class&lt;?&gt; aspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();<span class="hljs-comment">//从工厂中获取有@Aspect注解的类的名称</span>String aspectName = aspectInstanceFactory.getAspectMetadata().getAspectName();validate(aspectClass);<span class="hljs-comment">//创建工厂的装饰类，获取实例只会获取一次</span><span class="hljs-comment">// We need to wrap the MetadataAwareAspectInstanceFactory with a decorator</span><span class="hljs-comment">// so that it will only instantiate once.</span>MetadataAwareAspectInstanceFactory lazySingletonAspectInstanceFactory =<span class="hljs-keyword">new</span> LazySingletonAspectInstanceFactoryDecorator(aspectInstanceFactory);List&lt;Advisor&gt; advisors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<span class="hljs-comment">//这里循环没有@Pointcut注解的方法</span><span class="hljs-keyword">for</span> (Method method : getAdvisorMethods(aspectClass)) &#123;<span class="hljs-comment">//非常重要重点看看，重要程度 5</span>Advisor advisor = getAdvisor(method, lazySingletonAspectInstanceFactory, advisors.size(), aspectName);<span class="hljs-keyword">if</span> (advisor != <span class="hljs-keyword">null</span>) &#123;advisors.add(advisor);&#125;&#125;<span class="hljs-comment">// If it's a per target aspect, emit the dummy instantiating aspect.</span><span class="hljs-keyword">if</span> (!advisors.isEmpty() &amp;&amp; lazySingletonAspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) &#123;Advisor instantiationAdvisor = <span class="hljs-keyword">new</span> SyntheticInstantiationAdvisor(lazySingletonAspectInstanceFactory);advisors.add(<span class="hljs-number">0</span>, instantiationAdvisor);&#125;<span class="hljs-comment">//判断属性上是否有引介注解</span><span class="hljs-comment">// Find introduction fields.</span><span class="hljs-keyword">for</span> (Field field : aspectClass.getDeclaredFields()) &#123;<span class="hljs-comment">//判断属性上是否有DeclareParents注解，如果有返回切面</span>Advisor advisor = getDeclareParentsAdvisor(field);<span class="hljs-keyword">if</span> (advisor != <span class="hljs-keyword">null</span>) &#123;advisors.add(advisor);&#125;&#125;<span class="hljs-keyword">return</span> advisors;&#125;</code></pre><p>getAdvisor()方法</p><p>getAdvisor()方法会调用getPointCut()方法获取到封装的AspectJAnnotation对象，然后使用InstantiationModelAwarePointcutAdvisorImpl()创建Advisor切面类。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Advisor <span class="hljs-title">getAdvisor</span><span class="hljs-params">(Method candidateAdviceMethod, MetadataAwareAspectInstanceFactory aspectInstanceFactory,</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span> declarationOrderInAspect, String aspectName)</span> </span>&#123;validate(aspectInstanceFactory.getAspectMetadata().getAspectClass());<span class="hljs-comment">//获取pointCut对象，最重要的是从注解中获取表达式</span>AspectJExpressionPointcut expressionPointcut = getPointcut(candidateAdviceMethod, aspectInstanceFactory.getAspectMetadata().getAspectClass());<span class="hljs-keyword">if</span> (expressionPointcut == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;<span class="hljs-comment">//创建Advisor切面类，这才是真正的切面类，一个切面类里面肯定要有1、pointCut 2、advice</span><span class="hljs-comment">//这里pointCut是expressionPointcut， advice 增强方法是 candidateAdviceMethod</span><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> InstantiationModelAwarePointcutAdvisorImpl(expressionPointcut, candidateAdviceMethod,<span class="hljs-keyword">this</span>, aspectInstanceFactory, declarationOrderInAspect, aspectName);&#125;</code></pre><p>getPoint()方法</p><p>getPointCut()方法会去寻找@Pointcut、@Around、@Before、@After、@AfterReturning、@ AfterThrowing注解，并把注解信息封装成AspectJAnnotation对象，然后创建一个PointCut类，并且把前面从注解里面解析的表达式设置进去。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> AspectJExpressionPointcut <span class="hljs-title">getPointcut</span><span class="hljs-params">(Method candidateAdviceMethod, Class&lt;?&gt; candidateAspectClass)</span> </span>&#123;<span class="hljs-comment">//从候选的增强方法里面 candidateAdviceMethod找到注解</span><span class="hljs-comment">//Pointcut.class, Around.class, Before.class, After.class, AfterReturning.class, AfterThrowing.class</span><span class="hljs-comment">//并把注解信息封装成AspectJAnnotation对象</span>AspectJAnnotation&lt;?&gt; aspectJAnnotation =AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);<span class="hljs-keyword">if</span> (aspectJAnnotation == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;<span class="hljs-comment">//创建一个PointCut类，并且把前面从注解里面解析的表达式设置进去</span>AspectJExpressionPointcut ajexp =<span class="hljs-keyword">new</span> AspectJExpressionPointcut(candidateAspectClass, <span class="hljs-keyword">new</span> String[<span class="hljs-number">0</span>], <span class="hljs-keyword">new</span> Class&lt;?&gt;[<span class="hljs-number">0</span>]);ajexp.setExpression(aspectJAnnotation.getPointcutExpression());<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.beanFactory != <span class="hljs-keyword">null</span>) &#123;ajexp.setBeanFactory(<span class="hljs-keyword">this</span>.beanFactory);&#125;<span class="hljs-keyword">return</span> ajexp;&#125;</code></pre><p>InstantiationModelAwarePointcutAdvisorImpl()方法</p><p>getAdvice()方法是他的主要方法，主要是根据不同的注解信息创建不同的Advice类实例。Advice接口是一个空接口，子类实现完全不同。MethodInterceptor接口也实现了Advice接口，只有AspectJMethodBeforeAdvice跟AspectJAfterReturningAdvice没有实现MethodInterceptor接口，原因是这些Advice的MethodInterceptor接口中的invoke()方法需要预留出来，完成执行链回调。LocalVariableTableParameterNameDiscoverer的getParameterNames()方法可以拿到方法参数名称。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Advice <span class="hljs-title">getAdvice</span><span class="hljs-params">(Method candidateAdviceMethod, AspectJExpressionPointcut expressionPointcut,</span></span><span class="hljs-function"><span class="hljs-params">MetadataAwareAspectInstanceFactory aspectInstanceFactory, <span class="hljs-keyword">int</span> declarationOrder, String aspectName)</span> </span>&#123;<span class="hljs-comment">//获取有@Aspect注解的类</span>Class&lt;?&gt; candidateAspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();validate(candidateAspectClass);<span class="hljs-comment">//找到candidateAdviceMethod方法上面的注解，并且包装成AspectJAnnotation对象，这个对象中就有注解类型</span>AspectJAnnotation&lt;?&gt; aspectJAnnotation =AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);<span class="hljs-keyword">if</span> (aspectJAnnotation == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;<span class="hljs-comment">// If we get here, we know we have an AspectJ method.</span><span class="hljs-comment">// Check that it's an AspectJ-annotated class</span><span class="hljs-keyword">if</span> (!isAspect(candidateAspectClass)) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AopConfigException(<span class="hljs-string">"Advice must be declared inside an aspect type: "</span> +<span class="hljs-string">"Offending method '"</span> + candidateAdviceMethod + <span class="hljs-string">"' in class ["</span> +candidateAspectClass.getName() + <span class="hljs-string">"]"</span>);&#125;<span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;logger.debug(<span class="hljs-string">"Found AspectJ method: "</span> + candidateAdviceMethod);&#125;AbstractAspectJAdvice springAdvice;<span class="hljs-comment">//根据不同的注解类型创建不同的advice类实例</span><span class="hljs-keyword">switch</span> (aspectJAnnotation.getAnnotationType()) &#123;<span class="hljs-keyword">case</span> AtPointcut:<span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;logger.debug(<span class="hljs-string">"Processing pointcut '"</span> + candidateAdviceMethod.getName() + <span class="hljs-string">"'"</span>);&#125;<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<span class="hljs-keyword">case</span> AtAround:<span class="hljs-comment">//实现了MethodInterceptor接口</span>springAdvice = <span class="hljs-keyword">new</span> AspectJAroundAdvice(candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> AtBefore:<span class="hljs-comment">//实现了MethodBeforeAdvice接口，没有实现MethodInterceptor接口</span>springAdvice = <span class="hljs-keyword">new</span> AspectJMethodBeforeAdvice(candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> AtAfter:<span class="hljs-comment">//实现了MethodInterceptor接口</span>springAdvice = <span class="hljs-keyword">new</span> AspectJAfterAdvice(candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> AtAfterReturning:<span class="hljs-comment">//实现了AfterReturningAdvice接口，没有实现MethodInterceptor接口</span>springAdvice = <span class="hljs-keyword">new</span> AspectJAfterReturningAdvice(candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);AfterReturning afterReturningAnnotation = (AfterReturning) aspectJAnnotation.getAnnotation();<span class="hljs-keyword">if</span> (StringUtils.hasText(afterReturningAnnotation.returning())) &#123;springAdvice.setReturningName(afterReturningAnnotation.returning());&#125;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> AtAfterThrowing:<span class="hljs-comment">//实现了MethodInterceptor接口</span>springAdvice = <span class="hljs-keyword">new</span> AspectJAfterThrowingAdvice(candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);AfterThrowing afterThrowingAnnotation = (AfterThrowing) aspectJAnnotation.getAnnotation();<span class="hljs-keyword">if</span> (StringUtils.hasText(afterThrowingAnnotation.throwing())) &#123;springAdvice.setThrowingName(afterThrowingAnnotation.throwing());&#125;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">default</span>:<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException(<span class="hljs-string">"Unsupported advice type on method: "</span> + candidateAdviceMethod);&#125;<span class="hljs-comment">// Now to configure the advice...</span>springAdvice.setAspectName(aspectName);springAdvice.setDeclarationOrder(declarationOrder);String[] argNames = <span class="hljs-keyword">this</span>.parameterNameDiscoverer.getParameterNames(candidateAdviceMethod);<span class="hljs-keyword">if</span> (argNames != <span class="hljs-keyword">null</span>) &#123;springAdvice.setArgumentNamesFromStringArray(argNames);&#125;<span class="hljs-comment">//计算argNames和类型的对应关系</span>springAdvice.calculateArgumentBindings();<span class="hljs-keyword">return</span> springAdvice;&#125;</code></pre><h3 id="createProxy-方法"><a href="#createProxy-方法" class="headerlink" title="createProxy()方法"></a>createProxy()方法</h3><p>该方法首先会判断代理方式，然后调用buildAdvisors()方法将传进来的切面数组包装成advisor切面，然后使用getProxy()此方法会根据生成动态代理的方式创建代理JdkDynamicAopProxy或者ObjenesisCglibAopProxy对象。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">createProxy</span><span class="hljs-params">(Class&lt;?&gt; beanClass, @Nullable String beanName,</span></span><span class="hljs-function"><span class="hljs-params">      @Nullable Object[] specificInterceptors, TargetSource targetSource)</span> </span>&#123;   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.beanFactory <span class="hljs-keyword">instanceof</span> ConfigurableListableBeanFactory) &#123;      AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) <span class="hljs-keyword">this</span>.beanFactory, beanName, beanClass);   &#125;   <span class="hljs-comment">//创建代理工厂</span>   ProxyFactory proxyFactory = <span class="hljs-keyword">new</span> ProxyFactory();   proxyFactory.copyFrom(<span class="hljs-keyword">this</span>);   <span class="hljs-comment">//该属性用来控制代理方式，cglib或JDK动态代理</span>   <span class="hljs-keyword">if</span> (!proxyFactory.isProxyTargetClass()) &#123;      <span class="hljs-keyword">if</span> (shouldProxyTargetClass(beanClass, beanName)) &#123;         <span class="hljs-comment">//proxyTargetClass 是否对类进行代理，而不是对接口进行代理，设置为true时，使用CGLib代理。</span>         proxyFactory.setProxyTargetClass(<span class="hljs-keyword">true</span>);      &#125;      <span class="hljs-keyword">else</span> &#123;         evaluateProxyInterfaces(beanClass, proxyFactory);      &#125;   &#125;   <span class="hljs-comment">//把advice类型的增强包装成advisor切面</span>   Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);   proxyFactory.addAdvisors(advisors);   proxyFactory.setTargetSource(targetSource);   customizeProxyFactory(proxyFactory);   <span class="hljs-comment">////用来控制代理工厂被配置后，是否还允许修改代理的配置,默认为false</span>   proxyFactory.setFrozen(<span class="hljs-keyword">this</span>.freezeProxy);   <span class="hljs-keyword">if</span> (advisorsPreFiltered()) &#123;      proxyFactory.setPreFiltered(<span class="hljs-keyword">true</span>);   &#125;   <span class="hljs-comment">//获取代理实例</span>   <span class="hljs-keyword">return</span> proxyFactory.getProxy(getProxyClassLoader());&#125;</code></pre><h4 id="buildAdvisors-方法"><a href="#buildAdvisors-方法" class="headerlink" title="buildAdvisors()方法"></a>buildAdvisors()方法</h4><p>此方法主要作用为扩展，对自己实现MethodInterceptor进行处理。</p><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Advisor[] buildAdvisors(<span class="hljs-meta">@Nullable</span> String beanName, <span class="hljs-meta">@Nullable</span> Object[] specificInterceptors) &#123;   <span class="hljs-comment">// Handle prototypes correctly...</span>   <span class="hljs-comment">//自定义MethodInterceptor.拿到AnnotationAwareAspectJAutoProxyCreator对象调用setInterceptorNames方法</span>   Advisor[] commonInterceptors = resolveInterceptorNames();   List&lt;Object&gt; allInterceptors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();   <span class="hljs-keyword">if</span> (specificInterceptors != <span class="hljs-keyword">null</span>) &#123;      allInterceptors.addAll(Arrays.asList(specificInterceptors));      <span class="hljs-keyword">if</span> (commonInterceptors.length &gt; <span class="hljs-number">0</span>) &#123;         <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.applyCommonInterceptorsFirst) &#123;            allInterceptors.addAll(<span class="hljs-number">0</span>, Arrays.asList(commonInterceptors));         &#125;         <span class="hljs-keyword">else</span> &#123;            allInterceptors.addAll(Arrays.asList(commonInterceptors));         &#125;      &#125;   &#125;   <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;      <span class="hljs-keyword">int</span> nrOfCommonInterceptors = commonInterceptors.length;      <span class="hljs-keyword">int</span> nrOfSpecificInterceptors = (specificInterceptors != <span class="hljs-keyword">null</span> ? specificInterceptors.length : <span class="hljs-number">0</span>);      logger.trace(<span class="hljs-string">"Creating implicit proxy for bean '"</span> + beanName + <span class="hljs-string">"' with "</span> + nrOfCommonInterceptors +            <span class="hljs-string">" common interceptors and "</span> + nrOfSpecificInterceptors + <span class="hljs-string">" specific interceptors"</span>);   &#125;   Advisor[] advisors = <span class="hljs-keyword">new</span> Advisor[allInterceptors.size()];   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; allInterceptors.size(); i++) &#123;      <span class="hljs-comment">//对自定义的advice要进行包装，把advice包装成advisor对象，切面对象</span>      advisors[i] = <span class="hljs-keyword">this</span>.advisorAdapterRegistry.wrap(allInterceptors.get(i));   &#125;   <span class="hljs-keyword">return</span> advisors;&#125;</code></pre><p>wrap()方法</p><p>大部分情况下会进入第一个if中强转后直接返回，如果是自定义实现的MethodInterceptor会包装为DefaultPointcutAdvisor，此对象会被直接设置为全局Advice然后返回。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Advisor <span class="hljs-title">wrap</span><span class="hljs-params">(Object adviceObject)</span> <span class="hljs-keyword">throws</span> UnknownAdviceTypeException </span>&#123;   <span class="hljs-keyword">if</span> (adviceObject <span class="hljs-keyword">instanceof</span> Advisor) &#123;      <span class="hljs-keyword">return</span> (Advisor) adviceObject;   &#125;   <span class="hljs-keyword">if</span> (!(adviceObject <span class="hljs-keyword">instanceof</span> Advice)) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnknownAdviceTypeException(adviceObject);   &#125;   Advice advice = (Advice) adviceObject;   <span class="hljs-keyword">if</span> (advice <span class="hljs-keyword">instanceof</span> MethodInterceptor) &#123;      <span class="hljs-comment">//用于自定义处理MethodInterceptor</span>      <span class="hljs-comment">// So well-known it doesn't even need an adapter.</span>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultPointcutAdvisor(advice);   &#125;   <span class="hljs-keyword">for</span> (AdvisorAdapter adapter : <span class="hljs-keyword">this</span>.adapters) &#123;      <span class="hljs-comment">// Check that it is supported.</span>      <span class="hljs-keyword">if</span> (adapter.supportsAdvice(advice)) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultPointcutAdvisor(advice);      &#125;   &#125;   <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnknownAdviceTypeException(advice);&#125;</code></pre><h4 id="getProxy"><a href="#getProxy" class="headerlink" title="getProxy()"></a>getProxy()</h4><h5 id="JdkDynamicAopProxy"><a href="#JdkDynamicAopProxy" class="headerlink" title="JdkDynamicAopProxy"></a>JdkDynamicAopProxy</h5><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getProxy</span><span class="hljs-params">(@Nullable ClassLoader classLoader)</span> </span>&#123;   <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;      logger.trace(<span class="hljs-string">"Creating JDK dynamic proxy: "</span> + <span class="hljs-keyword">this</span>.advised.getTargetSource());   &#125;   <span class="hljs-comment">//advised是代理工厂对象</span>   Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(<span class="hljs-keyword">this</span>.advised, <span class="hljs-keyword">true</span>);   findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);   <span class="hljs-keyword">return</span> Proxy.newProxyInstance(classLoader, proxiedInterfaces, <span class="hljs-keyword">this</span>);&#125;</code></pre><h5 id="cglib"><a href="#cglib" class="headerlink" title="cglib"></a>cglib</h5><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getProxy</span><span class="hljs-params">(@Nullable ClassLoader classLoader)</span> </span>&#123;   <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;      logger.trace(<span class="hljs-string">"Creating CGLIB proxy: "</span> + <span class="hljs-keyword">this</span>.advised.getTargetSource());   &#125;   <span class="hljs-keyword">try</span> &#123;      Class&lt;?&gt; rootClass = <span class="hljs-keyword">this</span>.advised.getTargetClass();      Assert.state(rootClass != <span class="hljs-keyword">null</span>, <span class="hljs-string">"Target class must be available for creating a CGLIB proxy"</span>);      Class&lt;?&gt; proxySuperClass = rootClass;      <span class="hljs-keyword">if</span> (ClassUtils.isCglibProxyClass(rootClass)) &#123;         proxySuperClass = rootClass.getSuperclass();         Class&lt;?&gt;[] additionalInterfaces = rootClass.getInterfaces();         <span class="hljs-keyword">for</span> (Class&lt;?&gt; additionalInterface : additionalInterfaces) &#123;            <span class="hljs-keyword">this</span>.advised.addInterface(additionalInterface);         &#125;      &#125;      <span class="hljs-comment">// Validate the class, writing log messages as necessary.</span>      validateClassIfNecessary(proxySuperClass, classLoader);      <span class="hljs-comment">// Configure CGLIB Enhancer...</span>      Enhancer enhancer = createEnhancer();      <span class="hljs-keyword">if</span> (classLoader != <span class="hljs-keyword">null</span>) &#123;         enhancer.setClassLoader(classLoader);         <span class="hljs-keyword">if</span> (classLoader <span class="hljs-keyword">instanceof</span> SmartClassLoader &amp;&amp;               ((SmartClassLoader) classLoader).isClassReloadable(proxySuperClass)) &#123;            enhancer.setUseCache(<span class="hljs-keyword">false</span>);         &#125;      &#125;      enhancer.setSuperclass(proxySuperClass);      enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(<span class="hljs-keyword">this</span>.advised));      enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);      enhancer.setStrategy(<span class="hljs-keyword">new</span> ClassLoaderAwareUndeclaredThrowableStrategy(classLoader));      Callback[] callbacks = getCallbacks(rootClass);      Class&lt;?&gt;[] types = <span class="hljs-keyword">new</span> Class&lt;?&gt;[callbacks.length];      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; types.length; x++) &#123;         types[x] = callbacks[x].getClass();      &#125;      <span class="hljs-comment">// fixedInterceptorMap only populated at this point, after getCallbacks call above</span>      enhancer.setCallbackFilter(<span class="hljs-keyword">new</span> ProxyCallbackFilter(            <span class="hljs-keyword">this</span>.advised.getConfigurationOnlyCopy(), <span class="hljs-keyword">this</span>.fixedInterceptorMap, <span class="hljs-keyword">this</span>.fixedInterceptorOffset));      enhancer.setCallbackTypes(types);      <span class="hljs-comment">// Generate the proxy class and create a proxy instance.</span>      <span class="hljs-keyword">return</span> createProxyClassAndInstance(enhancer, callbacks);   &#125;   <span class="hljs-keyword">catch</span> (CodeGenerationException | IllegalArgumentException ex) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AopConfigException(<span class="hljs-string">"Could not generate CGLIB subclass of "</span> + <span class="hljs-keyword">this</span>.advised.getTargetClass() +            <span class="hljs-string">": Common causes of this problem include using a final class or a non-visible class"</span>,            ex);   &#125;   <span class="hljs-keyword">catch</span> (Throwable ex) &#123;      <span class="hljs-comment">// TargetSource.getTarget() failed</span>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AopConfigException(<span class="hljs-string">"Unexpected AOP exception"</span>, ex);   &#125;&#125;</code></pre><h2 id="AOP方法的调用"><a href="#AOP方法的调用" class="headerlink" title="AOP方法的调用"></a>AOP方法的调用</h2><h3 id="JdkDynamicAopProxy-1"><a href="#JdkDynamicAopProxy-1" class="headerlink" title="JdkDynamicAopProxy"></a>JdkDynamicAopProxy</h3><p>JdkDynamicAopProxy跟被代理对象是一一对应的，对JdkDynamicAopProxy被代理对象的调用会直接进入到invoke()方法中，JdkDynamicAopProxy中含有一个advised代理工厂对象，代理工厂含有所有的切面对象。然后根据advised.exposeProxy进行暴露判断，如果允许暴露可以通过AopContext.currentProxy()获取到被代理的实例。然后调用getInterceptorsAndDynamicInterceptionAdvice()获取执行链。如果没有就直接反射调用，但也会走代理，如果有就会通过proceed()方法调用执行链。TargetSource中封装被代理对象。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;   MethodInvocation invocation;   Object oldProxy = <span class="hljs-keyword">null</span>;   <span class="hljs-keyword">boolean</span> setProxyContext = <span class="hljs-keyword">false</span>;   <span class="hljs-comment">//从代理工厂中拿到TargetSource对象，该对象包装了被代理实例bean</span>   TargetSource targetSource = <span class="hljs-keyword">this</span>.advised.targetSource;   Object target = <span class="hljs-keyword">null</span>;   <span class="hljs-keyword">try</span> &#123;      <span class="hljs-comment">//被代理对象的equals方法和hashCode方法是不能被代理的，不会走切面</span>      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) &#123;         <span class="hljs-comment">// The target does not implement the equals(Object) method itself.</span>         <span class="hljs-keyword">return</span> equals(args[<span class="hljs-number">0</span>]);      &#125;      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) &#123;         <span class="hljs-comment">// The target does not implement the hashCode() method itself.</span>         <span class="hljs-keyword">return</span> hashCode();      &#125;      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.getDeclaringClass() == DecoratingProxy<span class="hljs-class">.<span class="hljs-keyword">class</span>) </span>&#123;         <span class="hljs-comment">// There is only getDecoratedClass() declared -&gt; dispatch to proxy config.</span>         <span class="hljs-keyword">return</span> AopProxyUtils.ultimateTargetClass(<span class="hljs-keyword">this</span>.advised);      &#125;      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.advised.opaque &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp;            method.getDeclaringClass().isAssignableFrom(Advised<span class="hljs-class">.<span class="hljs-keyword">class</span>)) </span>&#123;         <span class="hljs-comment">// Service invocations on ProxyConfig with the proxy config...</span>         <span class="hljs-keyword">return</span> AopUtils.invokeJoinpointUsingReflection(<span class="hljs-keyword">this</span>.advised, method, args);      &#125;      Object retVal;      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.advised.exposeProxy) &#123;         <span class="hljs-comment">// Make invocation available if necessary.</span>         oldProxy = AopContext.setCurrentProxy(proxy);         setProxyContext = <span class="hljs-keyword">true</span>;      &#125;      <span class="hljs-comment">// Get as late as possible to minimize the time we "own" the target,</span>      <span class="hljs-comment">// in case it comes from a pool.</span>      <span class="hljs-comment">//这个target就是被代理实例</span>      target = targetSource.getTarget();      Class&lt;?&gt; targetClass = (target != <span class="hljs-keyword">null</span> ? target.getClass() : <span class="hljs-keyword">null</span>);      <span class="hljs-comment">// Get the interception chain for this method.</span>      <span class="hljs-comment">//从代理工厂中拿过滤器链 Object是一个MethodInterceptor类型的对象，其实就是一个advice对象</span>      List&lt;Object&gt; chain = <span class="hljs-keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);      <span class="hljs-comment">// Check whether we have any advice. If we don't, we can fallback on direct</span>      <span class="hljs-comment">// reflective invocation of the target, and avoid creating a MethodInvocation.</span>      <span class="hljs-comment">//如果该方法没有执行链，则说明这个方法不需要被拦截，则直接反射调用</span>      <span class="hljs-keyword">if</span> (chain.isEmpty()) &#123;         <span class="hljs-comment">// We can skip creating a MethodInvocation: just invoke the target directly</span>         <span class="hljs-comment">// Note that the final invoker must be an InvokerInterceptor so we know it does</span>         <span class="hljs-comment">// nothing but a reflective operation on the target, and no hot swapping or fancy proxying.</span>         Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);         retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);      &#125;      <span class="hljs-keyword">else</span> &#123;         <span class="hljs-comment">// We need to create a method invocation...</span>         invocation = <span class="hljs-keyword">new</span> ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);         <span class="hljs-comment">// Proceed to the joinpoint through the interceptor chain.</span>         retVal = invocation.proceed();      &#125;      <span class="hljs-comment">// Massage return value if necessary.</span>      Class&lt;?&gt; returnType = method.getReturnType();      <span class="hljs-keyword">if</span> (retVal != <span class="hljs-keyword">null</span> &amp;&amp; retVal == target &amp;&amp;            returnType != Object<span class="hljs-class">.<span class="hljs-keyword">class</span> &amp;&amp; <span class="hljs-title">returnType</span>.<span class="hljs-title">isInstance</span>(<span class="hljs-title">proxy</span>) &amp;&amp;</span><span class="hljs-class">            !<span class="hljs-title">RawTargetAccess</span>.<span class="hljs-title">class</span>.<span class="hljs-title">isAssignableFrom</span>(<span class="hljs-title">method</span>.<span class="hljs-title">getDeclaringClass</span>())) </span>&#123;         <span class="hljs-comment">// Special case: it returned "this" and the return type of the method</span>         <span class="hljs-comment">// is type-compatible. Note that we can't help if the target sets</span>         <span class="hljs-comment">// a reference to itself in another returned object.</span>         retVal = proxy;      &#125;      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (retVal == <span class="hljs-keyword">null</span> &amp;&amp; returnType != Void.TYPE &amp;&amp; returnType.isPrimitive()) &#123;         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AopInvocationException(               <span class="hljs-string">"Null return value from advice does not match primitive return type for: "</span> + method);      &#125;      <span class="hljs-keyword">return</span> retVal;   &#125;   <span class="hljs-keyword">finally</span> &#123;      <span class="hljs-keyword">if</span> (target != <span class="hljs-keyword">null</span> &amp;&amp; !targetSource.isStatic()) &#123;         <span class="hljs-comment">// Must have come from TargetSource.</span>         targetSource.releaseTarget(target);      &#125;      <span class="hljs-keyword">if</span> (setProxyContext) &#123;         <span class="hljs-comment">// Restore old proxy.</span>         AopContext.setCurrentProxy(oldProxy);      &#125;   &#125;&#125;</code></pre><p>getInterceptorsAndDynamicInterceptionAdvice()方法</p><p>该方法中完成对切面的类和方法的匹配，匹配成功后会对切面再次进行包装，主要将非MethodInterceptor对象即@Before、@AfterReturning、@AfterThrowing的Advice包装为MethodInterceptor对象。此处的包装主要是为了方便接下来的调用。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Object&gt; <span class="hljs-title">getInterceptorsAndDynamicInterceptionAdvice</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">      Advised config, Method method, @Nullable Class&lt;?&gt; targetClass)</span> </span>&#123;   <span class="hljs-comment">// This is somewhat tricky... We have to process introductions first,</span>   <span class="hljs-comment">// but we need to preserve order in the ultimate list.</span>   AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance();   <span class="hljs-comment">//从代理工厂中获得该被代理类的所有切面advisor，config就是代理工厂对象</span>   Advisor[] advisors = config.getAdvisors();   List&lt;Object&gt; interceptorList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(advisors.length);   Class&lt;?&gt; actualClass = (targetClass != <span class="hljs-keyword">null</span> ? targetClass : method.getDeclaringClass());   Boolean hasIntroductions = <span class="hljs-keyword">null</span>;   <span class="hljs-keyword">for</span> (Advisor advisor : advisors) &#123;      <span class="hljs-comment">//大部分走这里</span>      <span class="hljs-keyword">if</span> (advisor <span class="hljs-keyword">instanceof</span> PointcutAdvisor) &#123;         <span class="hljs-comment">// Add it conditionally.</span>         PointcutAdvisor pointcutAdvisor = (PointcutAdvisor) advisor;         <span class="hljs-comment">//如果切面的pointCut和被代理对象是匹配的，说明是切面要拦截的对象</span>         <span class="hljs-keyword">if</span> (config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(actualClass)) &#123;            MethodMatcher mm = pointcutAdvisor.getPointcut().getMethodMatcher();            <span class="hljs-keyword">boolean</span> match;            <span class="hljs-keyword">if</span> (mm <span class="hljs-keyword">instanceof</span> IntroductionAwareMethodMatcher) &#123;               <span class="hljs-keyword">if</span> (hasIntroductions == <span class="hljs-keyword">null</span>) &#123;                  hasIntroductions = hasMatchingIntroductions(advisors, actualClass);               &#125;               match = ((IntroductionAwareMethodMatcher) mm).matches(method, actualClass, hasIntroductions);            &#125;            <span class="hljs-keyword">else</span> &#123;               <span class="hljs-comment">//接下来判断方法是否是切面pointcut需要拦截的方法</span>               match = mm.matches(method, actualClass);            &#125;            <span class="hljs-comment">//如果类和方法都匹配</span>            <span class="hljs-keyword">if</span> (match) &#123;               <span class="hljs-comment">//获取到切面advisor中的advice，并且包装成MethodInterceptor类型的对象</span>               MethodInterceptor[] interceptors = registry.getInterceptors(advisor);               <span class="hljs-keyword">if</span> (mm.isRuntime()) &#123;                  <span class="hljs-comment">// Creating a new object instance in the getInterceptors() method</span>                  <span class="hljs-comment">// isn't a problem as we normally cache created chains.</span>                  <span class="hljs-keyword">for</span> (MethodInterceptor interceptor : interceptors) &#123;                     interceptorList.add(<span class="hljs-keyword">new</span> InterceptorAndDynamicMethodMatcher(interceptor, mm));                  &#125;               &#125;               <span class="hljs-keyword">else</span> &#123;                  interceptorList.addAll(Arrays.asList(interceptors));               &#125;            &#125;         &#125;      &#125;      <span class="hljs-comment">//如果是引介切面</span>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (advisor <span class="hljs-keyword">instanceof</span> IntroductionAdvisor) &#123;         IntroductionAdvisor ia = (IntroductionAdvisor) advisor;         <span class="hljs-keyword">if</span> (config.isPreFiltered() || ia.getClassFilter().matches(actualClass)) &#123;            Interceptor[] interceptors = registry.getInterceptors(advisor);            interceptorList.addAll(Arrays.asList(interceptors));         &#125;      &#125;      <span class="hljs-keyword">else</span> &#123;         Interceptor[] interceptors = registry.getInterceptors(advisor);         interceptorList.addAll(Arrays.asList(interceptors));      &#125;   &#125;   <span class="hljs-keyword">return</span> interceptorList;&#125;</code></pre><p>proceed()方法</p><p>该方法首先会判断执行链是否执行完毕，如果执行完毕会直接使用invokeJoinpoint()调用被代理方法。判断方式为当前执行位置是否与执行链长度相等。如果没有执行完毕会调用执行链中Advice的invoke()方法，此时的调用链的顺序与aspect中advice的出现顺序相同，invoke()方法执行完增强的逻辑后会再回调回proceed()方法。AspectJAroundAdvice类型的invoke()方法会直接通过反射调用aroud()方法，在aroud()方法中执行joinPoint.proceed()方法时会回调proceed()方法，MethodBeforeAdviceInterceptor在调用完before()方法后最后会执行proceed()方法，AspectJAfterAdvice类型的invoke()方法会先执行proceed()然后在finally块中调用after()方法。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">proceed</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;   <span class="hljs-comment">// We start with an index of -1 and increment early.</span>   <span class="hljs-comment">//如果执行链中的advice全部执行完，则直接调用joinPoint方法，就是被代理方法</span>   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.currentInterceptorIndex == <span class="hljs-keyword">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class="hljs-number">1</span>) &#123;      <span class="hljs-keyword">return</span> invokeJoinpoint();   &#125;   Object interceptorOrInterceptionAdvice =         <span class="hljs-keyword">this</span>.interceptorsAndDynamicMethodMatchers.get(++<span class="hljs-keyword">this</span>.currentInterceptorIndex);   <span class="hljs-keyword">if</span> (interceptorOrInterceptionAdvice <span class="hljs-keyword">instanceof</span> InterceptorAndDynamicMethodMatcher) &#123;      <span class="hljs-comment">// Evaluate dynamic method matcher here: static part will already have</span>      <span class="hljs-comment">// been evaluated and found to match.</span>      InterceptorAndDynamicMethodMatcher dm =            (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;      Class&lt;?&gt; targetClass = (<span class="hljs-keyword">this</span>.targetClass != <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">this</span>.targetClass : <span class="hljs-keyword">this</span>.method.getDeclaringClass());      <span class="hljs-keyword">if</span> (dm.methodMatcher.matches(<span class="hljs-keyword">this</span>.method, targetClass, <span class="hljs-keyword">this</span>.arguments)) &#123;         <span class="hljs-keyword">return</span> dm.interceptor.invoke(<span class="hljs-keyword">this</span>);      &#125;      <span class="hljs-keyword">else</span> &#123;         <span class="hljs-comment">// Dynamic matching failed.</span>         <span class="hljs-comment">// Skip this interceptor and invoke the next in the chain.</span>         <span class="hljs-keyword">return</span> proceed();      &#125;   &#125;   <span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">// It's an interceptor, so we just invoke it: The pointcut will have</span>      <span class="hljs-comment">// been evaluated statically before this object was constructed.</span>      <span class="hljs-comment">//调用MethodInterceptor中的invoke方法</span>      <span class="hljs-keyword">return</span> ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(<span class="hljs-keyword">this</span>);   &#125;&#125;</code></pre><h3 id="cglib-1"><a href="#cglib-1" class="headerlink" title="cglib"></a>cglib</h3><h2 id="自定义实现的MethodInterceptor"><a href="#自定义实现的MethodInterceptor" class="headerlink" title="自定义实现的MethodInterceptor"></a>自定义实现的MethodInterceptor</h2><p>通过使用Spring提供的MethodInterceptor可以实现拦截所有切面方法</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMethodInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(MethodInvocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;        String method = invocation.getMethod().getName();        Object[] arguments = invocation.getArguments();        System.out.println(<span class="hljs-string">"全局拦截器触发，method："</span> + method + <span class="hljs-string">"，args："</span> + arguments);        Object proceed = invocation.proceed();        System.out.println(<span class="hljs-string">"执行结果："</span> + proceed);        <span class="hljs-keyword">return</span> proceed;    &#125;&#125;</code></pre><p>test()方法</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">aopTest</span><span class="hljs-params">()</span></span>&#123;    AnnotationAwareAspectJAutoProxyCreator bean = applicationContext.getBean(AnnotationAwareAspectJAutoProxyCreator<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    bean.setInterceptorNames(<span class="hljs-string">"myMethodInterceptor"</span>);    AopService aopService = applicationContext.getBean(AopService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    aopService.testInterceptor();&#125;</code></pre><p>注意：在之前的aop分析中，spring会根据该类是否有切面来决定是否进入aop入口，aop的入口是在getBean()实例化完成后的initializeBean()方法中，完成aop处理之后会直接将创建的代理类放入缓存，之后的getBean()会直接从缓存中取不会触发实例化方法，也就不会再进入aop。所以，要保证自定义实现的MethodInterceptor能够正常触发，必须要保证setInterceptorNames()方法在getBean()之前完成，而且该类已经有对应的切面。</p>]]></content>
    
    
    <categories>
      
      <category>Spring源码解析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>源码解析</tag>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring基于注解的启动方式解析和Bean的作用域</title>
    <link href="/blog/2020/04/18/spring-%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F%E8%A7%A3%E6%9E%90%E5%92%8CBean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <url>/blog/2020/04/18/spring-%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F%E8%A7%A3%E6%9E%90%E5%92%8CBean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h2><p>@Scope注解可以设置bean的作用域，不同的作用域对bean对象的获取方式不同，spring也允许开发者注册自己的作用域，实现对对象作用域的控制。</p><h3 id="doGetBean-的再分析"><a href="#doGetBean-的再分析" class="headerlink" title="doGetBean()的再分析"></a>doGetBean()的再分析</h3><p>如果缓存中获取不到实例且实例作用域不是单例时，spring就会获取到bean的作用域对象，并调用作用域对象的get()方法创建实例。</p><pre><code class="hljs java"><span class="hljs-keyword">protected</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">doGetBean</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String name, @Nullable <span class="hljs-keyword">final</span> Class&lt;T&gt; requiredType,</span></span><span class="hljs-function"><span class="hljs-params">@Nullable <span class="hljs-keyword">final</span> Object[] args, <span class="hljs-keyword">boolean</span> typeCheckOnly)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;    <span class="hljs-keyword">final</span> String beanName = transformedBeanName(name);Object bean;<span class="hljs-comment">//从缓存中拿实例</span><span class="hljs-comment">// Eagerly check singleton cache for manually registered singletons.</span>Object sharedInstance = getSingleton(beanName);<span class="hljs-comment">//如果缓存里面能拿到实例</span><span class="hljs-keyword">if</span> (sharedInstance != <span class="hljs-keyword">null</span> &amp;&amp; args == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<span class="hljs-keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;logger.trace(<span class="hljs-string">"Returning eagerly cached instance of singleton bean '"</span> + beanName +<span class="hljs-string">"' that is not fully initialized yet - a consequence of a circular reference"</span>);&#125;<span class="hljs-keyword">else</span> &#123;logger.trace(<span class="hljs-string">"Returning cached instance of singleton bean '"</span> + beanName + <span class="hljs-string">"'"</span>);&#125;&#125;<span class="hljs-comment">//改方法是FactoryBean接口的调用入口</span>bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="hljs-keyword">null</span>);&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//如果singletonObjects缓存里面没有，则走下来</span><span class="hljs-comment">// Fail if we're already creating this bean instance:</span><span class="hljs-comment">// We're assumably within a circular reference.</span><span class="hljs-comment">//如果是scope 是Prototype的，校验是否有出现循环依赖，如果有则直接报错</span><span class="hljs-keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCurrentlyInCreationException(beanName);&#125;<span class="hljs-comment">// Check if bean definition exists in this factory.</span>BeanFactory parentBeanFactory = getParentBeanFactory();<span class="hljs-keyword">if</span> (parentBeanFactory != <span class="hljs-keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;<span class="hljs-comment">// Not found -&gt; check parent.</span>String nameToLookup = originalBeanName(name);<span class="hljs-keyword">if</span> (parentBeanFactory <span class="hljs-keyword">instanceof</span> AbstractBeanFactory) &#123;<span class="hljs-keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(nameToLookup, requiredType, args, typeCheckOnly);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (args != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">// Delegation to parent with explicit args.</span><span class="hljs-keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (requiredType != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">// No args -&gt; delegate to standard getBean method.</span><span class="hljs-keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup);&#125;&#125;<span class="hljs-keyword">if</span> (!typeCheckOnly) &#123;markBeanAsCreated(beanName);&#125;<span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//父子BeanDefinition合并</span><span class="hljs-keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);checkMergedBeanDefinition(mbd, beanName, args);<span class="hljs-comment">//获取依赖对象属性，依赖对象要先实例化</span><span class="hljs-comment">// Guarantee initialization of beans that the current bean depends on.</span>String[] dependsOn = mbd.getDependsOn();<span class="hljs-keyword">if</span> (dependsOn != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">for</span> (String dep : dependsOn) &#123;<span class="hljs-keyword">if</span> (isDependent(beanName, dep)) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,<span class="hljs-string">"Circular depends-on relationship between '"</span> + beanName + <span class="hljs-string">"' and '"</span> + dep + <span class="hljs-string">"'"</span>);&#125;registerDependentBean(dep, beanName);<span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//实例化</span>getBean(dep);&#125;<span class="hljs-keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,<span class="hljs-string">"'"</span> + beanName + <span class="hljs-string">"' depends on missing bean '"</span> + dep + <span class="hljs-string">"'"</span>, ex);&#125;&#125;&#125;<span class="hljs-comment">//作用域为单例时的实例化</span><span class="hljs-comment">// Create bean instance.</span><span class="hljs-keyword">if</span> (mbd.isSingleton()) &#123;sharedInstance = getSingleton(beanName, () -&gt; &#123;<span class="hljs-keyword">try</span> &#123;<span class="hljs-keyword">return</span> createBean(beanName, mbd, args);&#125;<span class="hljs-keyword">catch</span> (BeansException ex) &#123;<span class="hljs-comment">// Explicitly remove instance from singleton cache: It might have been put there</span><span class="hljs-comment">// eagerly by the creation process, to allow for circular reference resolution.</span><span class="hljs-comment">// Also remove any beans that received a temporary reference to the bean.</span>destroySingleton(beanName);<span class="hljs-keyword">throw</span> ex;&#125;&#125;);<span class="hljs-comment">//该方法是FactoryBean接口的调用入口</span>bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mbd.isPrototype()) &#123;<span class="hljs-comment">// It's a prototype -&gt; create a new instance.</span>Object prototypeInstance = <span class="hljs-keyword">null</span>;<span class="hljs-keyword">try</span> &#123;beforePrototypeCreation(beanName);prototypeInstance = createBean(beanName, mbd, args);&#125;<span class="hljs-keyword">finally</span> &#123;afterPrototypeCreation(beanName);&#125;<span class="hljs-comment">//该方法是FactoryBean接口的调用入口</span>bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);&#125;      <span class="hljs-comment">//其他作用域，如自定义作用域</span><span class="hljs-keyword">else</span> &#123;String scopeName = mbd.getScope();<span class="hljs-keyword">final</span> Scope scope = <span class="hljs-keyword">this</span>.scopes.get(scopeName);<span class="hljs-keyword">if</span> (scope == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"No Scope registered for scope name '"</span> + scopeName + <span class="hljs-string">"'"</span>);&#125;<span class="hljs-keyword">try</span> &#123;Object scopedInstance = scope.get(beanName, () -&gt; &#123;beforePrototypeCreation(beanName);<span class="hljs-keyword">try</span> &#123;<span class="hljs-keyword">return</span> createBean(beanName, mbd, args);&#125;<span class="hljs-keyword">finally</span> &#123;afterPrototypeCreation(beanName);&#125;&#125;);<span class="hljs-comment">//改方法是FactoryBean接口的调用入口</span>bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);&#125;<span class="hljs-keyword">catch</span> (IllegalStateException ex) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(beanName,<span class="hljs-string">"Scope '"</span> + scopeName + <span class="hljs-string">"' is not active for the current thread; consider "</span> +<span class="hljs-string">"defining a scoped proxy for this bean if you intend to refer to it from a singleton"</span>,ex);&#125;&#125;&#125;<span class="hljs-keyword">catch</span> (BeansException ex) &#123;cleanupAfterBeanCreationFailure(beanName);<span class="hljs-keyword">throw</span> ex;&#125;&#125;<span class="hljs-comment">// Check if required type matches the type of the actual bean instance.</span><span class="hljs-keyword">if</span> (requiredType != <span class="hljs-keyword">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;<span class="hljs-keyword">try</span> &#123;T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);<span class="hljs-keyword">if</span> (convertedBean == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());&#125;<span class="hljs-keyword">return</span> convertedBean;&#125;<span class="hljs-keyword">catch</span> (TypeMismatchException ex) &#123;<span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;logger.trace(<span class="hljs-string">"Failed to convert bean '"</span> + name + <span class="hljs-string">"' to required type '"</span> +ClassUtils.getQualifiedName(requiredType) + <span class="hljs-string">"'"</span>, ex);&#125;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());&#125;&#125;<span class="hljs-keyword">return</span> (T) bean;&#125;</code></pre><h3 id="自定义作用域的实现"><a href="#自定义作用域的实现" class="headerlink" title="自定义作用域的实现"></a>自定义作用域的实现</h3><p>spring在完成BeanDefinition的实例化及IOC、DI后，会调用BeanFactoryPostProcessor接口的postProcessBeanFactory()方法并将beanFactory传递进去，我们可以在这个方法中调用beanFactory的regtsterScope()方法将自定义作用域添加到spring容器中。</p><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadScopeRegistry</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanDefinitionRegistryPostProcessor</span> </span>&#123;    <span class="hljs-keyword">private</span> BeanDefinitionRegistry beanDefinitionRegistry;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeanDefinitionRegistry</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;        <span class="hljs-keyword">this</span>.beanDefinitionRegistry = registry;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;        beanFactory.registerScope(<span class="hljs-string">"refresh"</span>,<span class="hljs-keyword">new</span> ThreadScope());    &#125;&#125;</code></pre><p>在创建实例时会调用到Scope对象的get()方法， 并向get()方法中传递beanName跟创建方法factory.getObject()。所以我们可以在Scope中精准的控制bean对象的作用域。比如创建一个线程间共享的作用域。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadScope</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Scope</span> </span>&#123;    <span class="hljs-keyword">private</span> ThreadLocal local = <span class="hljs-keyword">new</span> ThreadLocal();    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">get</span><span class="hljs-params">(String name, ObjectFactory&lt;?&gt; objectFactory)</span> </span>&#123;        <span class="hljs-keyword">if</span> (local.get()!=<span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> local.get();        &#125;        Object bean = objectFactory.getObject();        local.set(bean);        <span class="hljs-keyword">return</span> bean;    &#125;&#125;</code></pre><h3 id="spring的作用域"><a href="#spring的作用域" class="headerlink" title="spring的作用域"></a>spring的作用域</h3><p>singleton：spring的默认作用域，在spring容器中仅存在一个Bean实例，在启动时会实例化并放入一级缓存中，之后都是从一级缓存中获取。</p><p>prototype：多实例每次getBean()操作时都会重新创建。启动时不会初始化，只有在getBean()时才会实例化，而且在实例话时不会放入一级缓存，但会放入singletonsCurrentlyInCreation容器，阻断循环依赖。</p><p>request：每次http请求都创建一个实例，仅在web容器中存在。如果以xml文件的方式启动会直接报错。原理就是将创建后的Bean实例放在request中。</p><p>session：与request基本相同，不同的是Bean实例会放在Session中。</p><h2 id="基于注解的启动方式解析"><a href="#基于注解的启动方式解析" class="headerlink" title="基于注解的启动方式解析"></a>基于注解的启动方式解析</h2><h3 id="AnnotationConfigApplicaitonContext类解析"><a href="#AnnotationConfigApplicaitonContext类解析" class="headerlink" title="AnnotationConfigApplicaitonContext类解析"></a>AnnotationConfigApplicaitonContext类解析</h3><p>其构造函数中会创建一个AnnotatedBeanDefinitionReader对象，然后将annotatedClasses对象交给register()方法完成解析</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AnnotationConfigApplicationContext</span><span class="hljs-params">(Class&lt;?&gt;... annotatedClasses)</span> </span>&#123;<span class="hljs-keyword">this</span>();register(annotatedClasses);refresh();&#125;</code></pre><h4 id="register-方法"><a href="#register-方法" class="headerlink" title="register()方法"></a>register()方法</h4><p>register()方法会调用到AnnotatedBeanDefinitionReader的register()方法循环annotatedClasses并调用registerBean()方法进行BeanDefinition的注册。</p><p>doRegisterBean()是registerBean()的主要方法。doRegisterBean()方法首会创建一个BeanDefinition对象，然后将收集annotatedClass的信息并包装为Metadata对象，之后使用AnnotationConfigUtils.processCommonDefinitionAnnotations()对Metadata对象的注解和处理并设置到BeanDefinition对象中，之后将BeanDefinition对象封装为BeanDefinitionHolder并注册。</p><pre><code class="hljs java">&lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doRegisterBean</span><span class="hljs-params">(Class&lt;T&gt; annotatedClass, @Nullable Supplier&lt;T&gt; instanceSupplier, @Nullable String name,</span></span><span class="hljs-function"><span class="hljs-params">@Nullable Class&lt;? extends Annotation&gt;[] qualifiers, BeanDefinitionCustomizer... definitionCustomizers)</span> </span>&#123;AnnotatedGenericBeanDefinition abd = <span class="hljs-keyword">new</span> AnnotatedGenericBeanDefinition(annotatedClass);<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.conditionEvaluator.shouldSkip(abd.getMetadata())) &#123;<span class="hljs-keyword">return</span>;&#125;abd.setInstanceSupplier(instanceSupplier);ScopeMetadata scopeMetadata = <span class="hljs-keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(abd);abd.setScope(scopeMetadata.getScopeName());String beanName = (name != <span class="hljs-keyword">null</span> ? name : <span class="hljs-keyword">this</span>.beanNameGenerator.generateBeanName(abd, <span class="hljs-keyword">this</span>.registry));   <span class="hljs-comment">//对注解进行收集</span>AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);<span class="hljs-keyword">if</span> (qualifiers != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">for</span> (Class&lt;? extends Annotation&gt; qualifier : qualifiers) &#123;<span class="hljs-keyword">if</span> (Primary<span class="hljs-class">.<span class="hljs-keyword">class</span> </span>== qualifier) &#123;abd.setPrimary(<span class="hljs-keyword">true</span>);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Lazy<span class="hljs-class">.<span class="hljs-keyword">class</span> </span>== qualifier) &#123;abd.setLazyInit(<span class="hljs-keyword">true</span>);&#125;<span class="hljs-keyword">else</span> &#123;abd.addQualifier(<span class="hljs-keyword">new</span> AutowireCandidateQualifier(qualifier));&#125;&#125;&#125;<span class="hljs-keyword">for</span> (BeanDefinitionCustomizer customizer : definitionCustomizers) &#123;customizer.customize(abd);&#125;   <span class="hljs-comment">//封装并创建BeanDefinitionHolder对象</span>BeanDefinitionHolder definitionHolder = <span class="hljs-keyword">new</span> BeanDefinitionHolder(abd, beanName);definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="hljs-keyword">this</span>.registry);BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, <span class="hljs-keyword">this</span>.registry);&#125;</code></pre><h5 id="processCommonDefinitionAnnotations-方法"><a href="#processCommonDefinitionAnnotations-方法" class="headerlink" title="processCommonDefinitionAnnotations()方法"></a>processCommonDefinitionAnnotations()方法</h5><p>该方法会对注解进行收集并放到BeanDefinition中。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processCommonDefinitionAnnotations</span><span class="hljs-params">(AnnotatedBeanDefinition abd, AnnotatedTypeMetadata metadata)</span> </span>&#123;   <span class="hljs-comment">//对@Lazy注解支持</span>   AnnotationAttributes lazy = attributesFor(metadata, Lazy<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;   <span class="hljs-keyword">if</span> (lazy != <span class="hljs-keyword">null</span>) &#123;      abd.setLazyInit(lazy.getBoolean(<span class="hljs-string">"value"</span>));   &#125;   <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (abd.getMetadata() != metadata) &#123;      lazy = attributesFor(abd.getMetadata(), Lazy<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;      <span class="hljs-keyword">if</span> (lazy != <span class="hljs-keyword">null</span>) &#123;         abd.setLazyInit(lazy.getBoolean(<span class="hljs-string">"value"</span>));      &#125;   &#125;   <span class="hljs-keyword">if</span> (metadata.isAnnotated(Primary<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getName</span>())) </span>&#123;      abd.setPrimary(<span class="hljs-keyword">true</span>);   &#125;   <span class="hljs-comment">//对@DependsOn注解支持</span>   AnnotationAttributes dependsOn = attributesFor(metadata, DependsOn<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;   <span class="hljs-keyword">if</span> (dependsOn != <span class="hljs-keyword">null</span>) &#123;      abd.setDependsOn(dependsOn.getStringArray(<span class="hljs-string">"value"</span>));   &#125;   AnnotationAttributes role = attributesFor(metadata, Role<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;   <span class="hljs-keyword">if</span> (role != <span class="hljs-keyword">null</span>) &#123;      abd.setRole(role.getNumber(<span class="hljs-string">"value"</span>).intValue());   &#125;   AnnotationAttributes description = attributesFor(metadata, Description<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;   <span class="hljs-keyword">if</span> (description != <span class="hljs-keyword">null</span>) &#123;      abd.setDescription(description.getString(<span class="hljs-string">"value"</span>));   &#125;&#125;</code></pre><h3 id="AnnotatedBeanDefinitionReader解析"><a href="#AnnotatedBeanDefinitionReader解析" class="headerlink" title="AnnotatedBeanDefinitionReader解析"></a>AnnotatedBeanDefinitionReader解析</h3><p>其构造函数中会调用AnnotationConfigUtils.registerAnnotationConfigProcessors()方法。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AnnotatedBeanDefinitionReader</span><span class="hljs-params">(BeanDefinitionRegistry registry, Environment environment)</span> </span>&#123;Assert.notNull(registry, <span class="hljs-string">"BeanDefinitionRegistry must not be null"</span>);Assert.notNull(environment, <span class="hljs-string">"Environment must not be null"</span>);<span class="hljs-keyword">this</span>.registry = registry;<span class="hljs-keyword">this</span>.conditionEvaluator = <span class="hljs-keyword">new</span> ConditionEvaluator(registry, environment, <span class="hljs-keyword">null</span>);AnnotationConfigUtils.registerAnnotationConfigProcessors(<span class="hljs-keyword">this</span>.registry);&#125;</code></pre><h4 id="registerAnnotationConfigProcessors-方法"><a href="#registerAnnotationConfigProcessors-方法" class="headerlink" title="registerAnnotationConfigProcessors()方法"></a>registerAnnotationConfigProcessors()方法</h4><p>此方法会创建一些BeanDefinitionRegistryPostProcessor类，用于在Bean实例化之前对BeanDefinition进行操作。BeanDefinitionRegistryPostProcessor类继承了BeanFactoryPostProcessor类，在spring会在实例化Bean之前创建BeanFactoryPostProcessor对象，并调用postProcessBeanDefinitionRegistry()方法。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Set&lt;BeanDefinitionHolder&gt; <span class="hljs-title">registerAnnotationConfigProcessors</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">BeanDefinitionRegistry registry, @Nullable Object source)</span> </span>&#123;DefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry);<span class="hljs-keyword">if</span> (beanFactory != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">if</span> (!(beanFactory.getDependencyComparator() <span class="hljs-keyword">instanceof</span> AnnotationAwareOrderComparator)) &#123;beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);&#125;<span class="hljs-keyword">if</span> (!(beanFactory.getAutowireCandidateResolver() <span class="hljs-keyword">instanceof</span> ContextAnnotationAutowireCandidateResolver)) &#123;beanFactory.setAutowireCandidateResolver(<span class="hljs-keyword">new</span> ContextAnnotationAutowireCandidateResolver());&#125;&#125;Set&lt;BeanDefinitionHolder&gt; beanDefs = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(<span class="hljs-number">8</span>);<span class="hljs-keyword">if</span> (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;     <span class="hljs-comment">// 重点关注这行代码中的ConfigurationClassPostProcessor类</span>RootBeanDefinition def = <span class="hljs-keyword">new</span> RootBeanDefinition(ConfigurationClassPostProcessor<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;def.setSource(source);beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));&#125;<span class="hljs-keyword">if</span> (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;RootBeanDefinition def = <span class="hljs-keyword">new</span> RootBeanDefinition(AutowiredAnnotationBeanPostProcessor<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;def.setSource(source);beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));&#125;<span class="hljs-comment">// Check for JSR-250 support, and if present add the CommonAnnotationBeanPostProcessor.</span><span class="hljs-keyword">if</span> (jsr250Present &amp;&amp; !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;RootBeanDefinition def = <span class="hljs-keyword">new</span> RootBeanDefinition(CommonAnnotationBeanPostProcessor<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;def.setSource(source);beanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME));&#125;<span class="hljs-comment">// Check for JPA support, and if present add the PersistenceAnnotationBeanPostProcessor.</span><span class="hljs-keyword">if</span> (jpaPresent &amp;&amp; !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;RootBeanDefinition def = <span class="hljs-keyword">new</span> RootBeanDefinition();<span class="hljs-keyword">try</span> &#123;def.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME,AnnotationConfigUtils<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getClassLoader</span>()))</span>;&#125;<span class="hljs-keyword">catch</span> (ClassNotFoundException ex) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Cannot load optional framework class: "</span> + PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, ex);&#125;def.setSource(source);beanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME));&#125;<span class="hljs-keyword">if</span> (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) &#123;RootBeanDefinition def = <span class="hljs-keyword">new</span> RootBeanDefinition(EventListenerMethodProcessor<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;def.setSource(source);beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME));&#125;<span class="hljs-keyword">if</span> (!registry.containsBeanDefinition(EVENT_LISTENER_FACTORY_BEAN_NAME)) &#123;RootBeanDefinition def = <span class="hljs-keyword">new</span> RootBeanDefinition(DefaultEventListenerFactory<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;def.setSource(source);beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_FACTORY_BEAN_NAME));&#125;<span class="hljs-keyword">return</span> beanDefs; &#125;</code></pre><h3 id="ConfigurationClassPostProcessor类解析"><a href="#ConfigurationClassPostProcessor类解析" class="headerlink" title="ConfigurationClassPostProcessor类解析"></a>ConfigurationClassPostProcessor类解析</h3><p>ConfigurationClassPostProcessor类是registerAnnotationConfigProcessors()方法注册的BeanDefinitionRegistryPostProcessor之一。</p><h4 id="processConfigBeanDefinitions-方法"><a href="#processConfigBeanDefinitions-方法" class="headerlink" title="processConfigBeanDefinitions()方法"></a>processConfigBeanDefinitions()方法</h4><p>该方法首先会调用ConfigurationClassUtils.checkConfigurationClassCandidate()方法将具有某些注解的BeanDefination对象放入configCandidates容器中，然后对configCandidates容器进行排序，再使用parse()方法对注解进行处理，最后使用loadBeanDefinitions()完成注册。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processConfigBeanDefinitions</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> </span>&#123;List&lt;BeanDefinitionHolder&gt; configCandidates = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();String[] candidateNames = registry.getBeanDefinitionNames();<span class="hljs-keyword">for</span> (String beanName : candidateNames) &#123;BeanDefinition beanDef = registry.getBeanDefinition(beanName);<span class="hljs-keyword">if</span> (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) &#123;<span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;logger.debug(<span class="hljs-string">"Bean definition has already been processed as a configuration class: "</span> + beanDef);&#125;&#125;<span class="hljs-comment">//判断是类上或方法上的注解，</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, <span class="hljs-keyword">this</span>.metadataReaderFactory)) &#123;configCandidates.add(<span class="hljs-keyword">new</span> BeanDefinitionHolder(beanDef, beanName));&#125;&#125;<span class="hljs-comment">// Return immediately if no @Configuration classes were found</span><span class="hljs-keyword">if</span> (configCandidates.isEmpty()) &#123;<span class="hljs-keyword">return</span>;&#125;   <span class="hljs-comment">//排序</span><span class="hljs-comment">// Sort by previously determined @Order value, if applicable</span>configCandidates.sort((bd1, bd2) -&gt; &#123;<span class="hljs-keyword">int</span> i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());<span class="hljs-keyword">int</span> i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());<span class="hljs-keyword">return</span> Integer.compare(i1, i2);&#125;);<span class="hljs-comment">// Detect any custom bean name generation strategy supplied through the enclosing application context</span>SingletonBeanRegistry sbr = <span class="hljs-keyword">null</span>;<span class="hljs-keyword">if</span> (registry <span class="hljs-keyword">instanceof</span> SingletonBeanRegistry) &#123;sbr = (SingletonBeanRegistry) registry;<span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.localBeanNameGeneratorSet) &#123;BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);<span class="hljs-keyword">if</span> (generator != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">this</span>.componentScanBeanNameGenerator = generator;<span class="hljs-keyword">this</span>.importBeanNameGenerator = generator;&#125;&#125;&#125;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.environment == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">this</span>.environment = <span class="hljs-keyword">new</span> StandardEnvironment();&#125;<span class="hljs-comment">//这个类很重要，@ComponentScan @Configuration支持</span><span class="hljs-comment">// Parse each @Configuration class</span>ConfigurationClassParser parser = <span class="hljs-keyword">new</span> ConfigurationClassParser(<span class="hljs-keyword">this</span>.metadataReaderFactory, <span class="hljs-keyword">this</span>.problemReporter, <span class="hljs-keyword">this</span>.environment,<span class="hljs-keyword">this</span>.resourceLoader, <span class="hljs-keyword">this</span>.componentScanBeanNameGenerator, registry);Set&lt;BeanDefinitionHolder&gt; candidates = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(configCandidates);Set&lt;ConfigurationClass&gt; alreadyParsed = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(configCandidates.size());<span class="hljs-keyword">do</span> &#123;parser.parse(candidates);parser.validate();Set&lt;ConfigurationClass&gt; configClasses = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(parser.getConfigurationClasses());configClasses.removeAll(alreadyParsed);<span class="hljs-comment">// Read the model and create bean definitions based on its content</span><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.reader == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">this</span>.reader = <span class="hljs-keyword">new</span> ConfigurationClassBeanDefinitionReader(registry, <span class="hljs-keyword">this</span>.sourceExtractor, <span class="hljs-keyword">this</span>.resourceLoader, <span class="hljs-keyword">this</span>.environment,<span class="hljs-keyword">this</span>.importBeanNameGenerator, parser.getImportRegistry());&#125;<span class="hljs-comment">//设置beanDefinition的属性值,重点看，具体执行 import importSource @Bean的逻辑</span><span class="hljs-keyword">this</span>.reader.loadBeanDefinitions(configClasses);alreadyParsed.addAll(configClasses);candidates.clear();<span class="hljs-keyword">if</span> (registry.getBeanDefinitionCount() &gt; candidateNames.length) &#123;String[] newCandidateNames = registry.getBeanDefinitionNames();Set&lt;String&gt; oldCandidateNames = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(Arrays.asList(candidateNames));Set&lt;String&gt; alreadyParsedClasses = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<span class="hljs-keyword">for</span> (ConfigurationClass configurationClass : alreadyParsed) &#123;alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());&#125;<span class="hljs-keyword">for</span> (String candidateName : newCandidateNames) &#123;<span class="hljs-keyword">if</span> (!oldCandidateNames.contains(candidateName)) &#123;BeanDefinition bd = registry.getBeanDefinition(candidateName);<span class="hljs-keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, <span class="hljs-keyword">this</span>.metadataReaderFactory) &amp;&amp;!alreadyParsedClasses.contains(bd.getBeanClassName())) &#123;candidates.add(<span class="hljs-keyword">new</span> BeanDefinitionHolder(bd, candidateName));&#125;&#125;&#125;candidateNames = newCandidateNames;&#125;&#125;<span class="hljs-keyword">while</span> (!candidates.isEmpty());<span class="hljs-comment">// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes</span><span class="hljs-keyword">if</span> (sbr != <span class="hljs-keyword">null</span> &amp;&amp; !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) &#123;sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());&#125;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.metadataReaderFactory <span class="hljs-keyword">instanceof</span> CachingMetadataReaderFactory) &#123;<span class="hljs-comment">// Clear cache in externally provided MetadataReaderFactory; this is a no-op</span><span class="hljs-comment">// for a shared cache since it'll be cleared by the ApplicationContext.</span>((CachingMetadataReaderFactory) <span class="hljs-keyword">this</span>.metadataReaderFactory).clearCache();&#125;&#125;</code></pre><h5 id="checkConfigurationClassCandidate-方法"><a href="#checkConfigurationClassCandidate-方法" class="headerlink" title="checkConfigurationClassCandidate()方法"></a>checkConfigurationClassCandidate()方法</h5><p>该方法会检查类上是否有@Component、@ComponentScan、@Import、@ImportResource、@Configuration注解或者方法上是否有@Bean注解，如果有会对用于排序的order属性进行设置。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkConfigurationClassCandidate</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">BeanDefinition beanDef, MetadataReaderFactory metadataReaderFactory)</span> </span>&#123;String className = beanDef.getBeanClassName();<span class="hljs-keyword">if</span> (className == <span class="hljs-keyword">null</span> || beanDef.getFactoryMethodName() != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;AnnotationMetadata metadata;<span class="hljs-keyword">if</span> (beanDef <span class="hljs-keyword">instanceof</span> AnnotatedBeanDefinition &amp;&amp;className.equals(((AnnotatedBeanDefinition) beanDef).getMetadata().getClassName())) &#123;<span class="hljs-comment">// Can reuse the pre-parsed metadata from the given BeanDefinition...</span>metadata = ((AnnotatedBeanDefinition) beanDef).getMetadata();&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (beanDef <span class="hljs-keyword">instanceof</span> AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) beanDef).hasBeanClass()) &#123;<span class="hljs-comment">// Check already loaded Class if present...</span><span class="hljs-comment">// since we possibly can't even load the class file for this Class.</span>Class&lt;?&gt; beanClass = ((AbstractBeanDefinition) beanDef).getBeanClass();metadata = <span class="hljs-keyword">new</span> StandardAnnotationMetadata(beanClass, <span class="hljs-keyword">true</span>);&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">try</span> &#123;MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(className);metadata = metadataReader.getAnnotationMetadata();&#125;<span class="hljs-keyword">catch</span> (IOException ex) &#123;<span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;logger.debug(<span class="hljs-string">"Could not find class file for introspecting configuration annotations: "</span> +className, ex);&#125;<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;&#125;<span class="hljs-comment">//判断是否有@Component、@ComponentScan、@Import、@ImportResource、@Configuration注解</span><span class="hljs-keyword">if</span> (isFullConfigurationCandidate(metadata)) &#123;beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_FULL);&#125;<span class="hljs-comment">//判断是否有@Component注解，或者类上面没注解（xml配置实例化）方法上面有@Bean注解</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isLiteConfigurationCandidate(metadata)) &#123;beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_LITE);&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;<span class="hljs-comment">// It's a full or lite configuration candidate... Let's determine the order value, if any.</span>   <span class="hljs-comment">//设置order属性</span>Integer order = getOrder(metadata);<span class="hljs-keyword">if</span> (order != <span class="hljs-keyword">null</span>) &#123;beanDef.setAttribute(ORDER_ATTRIBUTE, order);&#125;<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre><h5 id="parse-方法"><a href="#parse-方法" class="headerlink" title="parse()方法"></a>parse()方法</h5><p>parse()方法最终会调用doProcessConfigurationClass()方法对注解进行处理。此处分析的为componentScanParser中的doProcessConfigurationClass()方法，该方法会使用parse()方法解析某些有特定注解的类，然后对@Import注解进行处理，最后调用scanner.doScan()方法完成包扫描。@Import注解用于引用一个类，该类会交由spring初始化及管理，常用于引入扫描路径之外的类。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> SourceClass <span class="hljs-title">doProcessConfigurationClass</span><span class="hljs-params">(ConfigurationClass configClass, SourceClass sourceClass)</span></span><span class="hljs-function"><span class="hljs-keyword">throws</span> IOException </span>&#123;<span class="hljs-keyword">if</span> (configClass.getMetadata().isAnnotated(Component<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getName</span>())) </span>&#123;<span class="hljs-comment">// Recursively process any member (nested) classes first</span>processMemberClasses(configClass, sourceClass);&#125;<span class="hljs-comment">// Process any @PropertySource annotations</span><span class="hljs-keyword">for</span> (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources<span class="hljs-class">.<span class="hljs-keyword">class</span>,</span><span class="hljs-class"><span class="hljs-title">org</span>.<span class="hljs-title">springframework</span>.<span class="hljs-title">context</span>.<span class="hljs-title">annotation</span>.<span class="hljs-title">PropertySource</span>.<span class="hljs-title">class</span>)) </span>&#123;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.environment <span class="hljs-keyword">instanceof</span> ConfigurableEnvironment) &#123;processPropertySource(propertySource);&#125;<span class="hljs-keyword">else</span> &#123;logger.info(<span class="hljs-string">"Ignoring @PropertySource annotation on ["</span> + sourceClass.getMetadata().getClassName() +<span class="hljs-string">"]. Reason: Environment must implement ConfigurableEnvironment"</span>);&#125;&#125;<span class="hljs-comment">// Process any @ComponentScan annotations</span>Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), ComponentScans<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">ComponentScan</span>.<span class="hljs-title">class</span>)</span>;<span class="hljs-keyword">if</span> (!componentScans.isEmpty() &amp;&amp;!<span class="hljs-keyword">this</span>.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123;<span class="hljs-keyword">for</span> (AnnotationAttributes componentScan : componentScans) &#123;<span class="hljs-comment">// The config class is annotated with @ComponentScan -&gt; perform the scan immediately</span>       <span class="hljs-comment">//重点看这个方法</span>Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =<span class="hljs-keyword">this</span>.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());<span class="hljs-comment">// Check the set of scanned definitions for any further config classes and parse recursively if needed</span><span class="hljs-keyword">for</span> (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123;BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();<span class="hljs-keyword">if</span> (bdCand == <span class="hljs-keyword">null</span>) &#123;bdCand = holder.getBeanDefinition();&#125;         <span class="hljs-comment">//对特定注解进行扫描</span><span class="hljs-keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, <span class="hljs-keyword">this</span>.metadataReaderFactory)) &#123;parse(bdCand.getBeanClassName(), holder.getBeanName());&#125;&#125;&#125;&#125;   <span class="hljs-comment">//用于处理@import注解</span><span class="hljs-comment">// Process any @Import annotations</span>processImports(configClass, sourceClass, getImports(sourceClass), <span class="hljs-keyword">true</span>);<span class="hljs-comment">// Process any @ImportResource annotations</span>AnnotationAttributes importResource =AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<span class="hljs-keyword">if</span> (importResource != <span class="hljs-keyword">null</span>) &#123;String[] resources = importResource.getStringArray(<span class="hljs-string">"locations"</span>);Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass(<span class="hljs-string">"reader"</span>);<span class="hljs-keyword">for</span> (String resource : resources) &#123;String resolvedResource = <span class="hljs-keyword">this</span>.environment.resolveRequiredPlaceholders(resource);configClass.addImportedResource(resolvedResource, readerClass);&#125;&#125;<span class="hljs-comment">// Process individual @Bean methods</span>Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);<span class="hljs-keyword">for</span> (MethodMetadata methodMetadata : beanMethods) &#123;configClass.addBeanMethod(<span class="hljs-keyword">new</span> BeanMethod(methodMetadata, configClass));&#125;<span class="hljs-comment">// Process default methods on interfaces</span>processInterfaces(configClass, sourceClass);<span class="hljs-comment">// Process superclass, if any</span><span class="hljs-keyword">if</span> (sourceClass.getMetadata().hasSuperClass()) &#123;String superclass = sourceClass.getMetadata().getSuperClassName();<span class="hljs-keyword">if</span> (superclass != <span class="hljs-keyword">null</span> &amp;&amp; !superclass.startsWith(<span class="hljs-string">"java"</span>) &amp;&amp;!<span class="hljs-keyword">this</span>.knownSuperclasses.containsKey(superclass)) &#123;<span class="hljs-keyword">this</span>.knownSuperclasses.put(superclass, configClass);<span class="hljs-comment">// Superclass found, return its annotation metadata and recurse</span><span class="hljs-keyword">return</span> sourceClass.getSuperClass();&#125;&#125;<span class="hljs-comment">// No superclass -&gt; processing is complete</span><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>; &#125;</code></pre><h5 id="loadBeanDefinitions"><a href="#loadBeanDefinitions" class="headerlink" title="loadBeanDefinitions()"></a>loadBeanDefinitions()</h5><p>loadBeanDefinitions最终会调用loadBeanDefinitionsForConfigurationClass()方法完成对@Bean，@Import，@ImportSource注解的处理。@ImportSources注解会引入一个xml文件，loadBeanDefinitionsFromImportedResources()方法会调用loadBeanDefinitions()方法解析xml文件，这个方法在spring以xml文件的方式启动时调用的相同。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadBeanDefinitionsForConfigurationClass</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">ConfigurationClass configClass, TrackedConditionEvaluator trackedConditionEvaluator)</span> </span>&#123;<span class="hljs-keyword">if</span> (trackedConditionEvaluator.shouldSkip(configClass)) &#123;String beanName = configClass.getBeanName();<span class="hljs-keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="hljs-keyword">this</span>.registry.containsBeanDefinition(beanName)) &#123;<span class="hljs-keyword">this</span>.registry.removeBeanDefinition(beanName);&#125;<span class="hljs-keyword">this</span>.importRegistry.removeImportingClass(configClass.getMetadata().getClassName());<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">if</span> (configClass.isImported()) &#123;registerBeanDefinitionForImportedConfigurationClass(configClass);&#125;<span class="hljs-keyword">for</span> (BeanMethod beanMethod : configClass.getBeanMethods()) &#123;<span class="hljs-comment">//@Bean标签的处理</span>loadBeanDefinitionsForBeanMethod(beanMethod);&#125;<span class="hljs-comment">//@ImportSources注解处理</span>loadBeanDefinitionsFromImportedResources(configClass.getImportedResources());<span class="hljs-comment">//@Import注解处理</span>loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars());&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Spring源码解析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>源码解析</tag>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring实例化Bean的过程</title>
    <link href="/blog/2020/04/15/spring-%E5%AE%9E%E4%BE%8B%E5%8C%96bean%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
    <url>/blog/2020/04/15/spring-%E5%AE%9E%E4%BE%8B%E5%8C%96bean%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="DeanDefinition简介"><a href="#DeanDefinition简介" class="headerlink" title="DeanDefinition简介"></a>DeanDefinition简介</h2><p>BeanDefinition在spring中贯穿始终，spring要根据BeanDefiniton对象来实例化bean。在实例化之前，需要解析bean标签并封装成BeanDefiniton对象。</p><h3 id="BeanDefinition实现类"><a href="#BeanDefinition实现类" class="headerlink" title="BeanDefinition实现类"></a>BeanDefinition实现类</h3><ul><li>ChildBeanDefinition：ChildBeanDefinitio可以继承parent bean definition的设置，对RootBeanDefinition 有一定的依赖关系。 ChildBeanDefinition可以继承父类的构造参数值，属性值并可以重写父类的方法，同时也可以增加新的属性或者方法。若指定初始化方法，销毁方法或者静态工厂方法，ChildBeanDefinition将重写相应父类的设置。</li><li>RootBeanDefinition：RootBeanDefinition是一个可合并的bean definition，即在spring beanFactory运行期间，可以返回一个特定的bean。</li><li>GenericBeanDefinition：从spring 2.5以后了提供的更好的注册bean definition类，用来替代ChildBeanDefinition跟RootBeanDefinition。标准BeanDefinition，除了具有指定类、可选的构造参数值和属性参数这些其它BeanDefinition一样的特性外，它还具有通过parenetName属性来动态设置parent bean definition，而非硬编码作为root bean definition。 </li></ul><h3 id="BeanDefinition中的属性"><a href="#BeanDefinition中的属性" class="headerlink" title="BeanDefinition中的属性"></a>BeanDefinition中的属性</h3><img src="/blog/2020/04/15/spring-%E5%AE%9E%E4%BE%8B%E5%8C%96bean%E7%9A%84%E8%BF%87%E7%A8%8B/pic1.png" srcset="/blog/img/loading.gif" class><ul><li><p>id：Bean 的唯一标识名。它必须是合法的 XMLID，在整个 XML 文档中唯一。</p></li><li><p>name：用来为id创建一个或多个别名。它可以是任意的字母符合。多个别名之间用逗号或空格分开。</p></li><li><p>class：用来定义类的全限定名(包名+类名)。只有子类 Bean 不用定义该属性。</p></li><li><p>parent：子类Bean 定义它所引用它的父类Bean。这时前面的class 属性失效。子类Bean会继承父类Bean的所有属性，子类Bean也可以覆盖父类 Bean 的属性。注意:子类 Bean 和父类 Bean 是同一 个 Java 类。</p></li><li><p>abstract(默认为”false”)：用来定义Bean是否为抽象Bean。它表示这个Bean将不会被实例化，一般用于父类 Bean，因为父类Bean主要是供子类Bean继承使用。</p></li><li><p>lazy-init(默认为“default”)：用来定义这个Bean是否实现懒初始化。如果为“true”，它将在BeanFactory 启动时初始化所有的SingletonBean。反之，如果为“false”，它只在Bean请求时才开始创建SingletonBean。</p></li><li><p>autowire：(自动装配，默认为“default”：它定义了Bean的自动装载方式。 </p><ul><li><p>“no”：不使用自动装配功能。</p></li><li><p>“byName”：通过 Bean 的属性名实现自动装配。</p></li><li><p>“byType”：通过 Bean 的类型实现自动装配。</p></li><li><p>“constructor”：类似于 byType，但它是用于构造函数的参数的自动组装。</p></li><li><p>“autodetect”：通过 Bean 类的反省机制(introspection)决定是使用“constructor”还是使用“byType”。</p></li></ul></li><li><p>depends-on(依赖对象)：这个Bean在初始化时依赖的对象，这个对象会在这个Bean初始化之前创建。</p></li><li><p>init-method：用来定义Bean的初始化方法，它会在Bean组装之后调用。它必须是一个无参数的方法。</p></li><li><p>destroy-method：用来定义Bean的销毁方法，它在BeanFactory关闭时调用。同样，它也必须是一个无参数的方法。它只能应用于 singletonBean。</p></li><li><p>factory-method：定义创建该Bean对象的工厂方法。它用于下面的“factory-bean”，表示 这个Bean是通过工厂方法创建。此时，“class”属性失效。</p></li><li><p>factory-bean：定义创建该Bean对象的工厂类。如果使用了“factory-bean”则“class”属性失效。</p></li><li><p>autowire-candidate：采用xml格式配置bean时，将&lt;bean/&gt;元素的autowire-candidate属性设置为 false，这样容器在查找自动装配对象时，将不考虑该bean，即它不会被考虑作为其它bean自动装配的候选者，但是该bean本身还是可以使用自动装配来注入其它bean的。</p></li><li><p>MutablePropertyValues：用于封装&lt;property&gt;标签的信息，其实类里面就是有一个list，list里面是PropertyValue对象，PropertyValue就是一个name和value属性，用于封装&lt;property&gt;标签的名称和值信息</p></li><li><p>ConstructorArgumentValues：用于封装&lt;constructor-arg&gt;\标签的信息，其实类里面就是有一个map，map中用构造函数的参数顺序作为key，值作为value存储到map中</p></li><li><p>MethodOverrides：用于封装lookup-method和replaced-method标签的信息，同样的类里面有一个Set对象添加LookupOverride对象和ReplaceOverride对象</p></li></ul><h2 id="invokeBeanFactoryPostProcessors-方法"><a href="#invokeBeanFactoryPostProcessors-方法" class="headerlink" title="invokeBeanFactoryPostProcessors()方法"></a>invokeBeanFactoryPostProcessors()方法</h2><p>invokeBeanFactoryPostProcessors()方法在spring的核心方法refresh()中调用，主要用于处理BeanFactoryPostProcessor接口，是针对BeanFactory的扩展，主要用在bean实例化之前，读取bean的定义，完成对BeanDefinition的修改。</p><p>该方法会实例化和调用所有的BeanFactoryPostProcessor（包括子类BeanDefinitionRegistryPostProcessor），并调用postProcessBeanDefinitionRegistry()方法。</p><p>postProcessBeanDefinitionRegistry()方法的入参为BeanDefinitionRegistry对象，通过这个对象可以完成对所有BeanDefinition对象的增删改查。</p><p>在执行过程中会对实现排序接口的BeanFactoryPostProcessor进行排序，然后按照顺序进行调用。</p><p>调用顺序为: </p><ol><li>实现PriorityOrdered排序接口</li><li>实现Ordered排序接口</li><li>没有实现接口的调用</li></ol><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeBeanFactoryPostProcessors</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors)</span> </span>&#123;<span class="hljs-comment">// Invoke BeanDefinitionRegistryPostProcessors first, if any.</span>Set&lt;String&gt; processedBeans = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<span class="hljs-keyword">if</span> (beanFactory <span class="hljs-keyword">instanceof</span> BeanDefinitionRegistry) &#123;BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<span class="hljs-keyword">for</span> (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123;<span class="hljs-keyword">if</span> (postProcessor <span class="hljs-keyword">instanceof</span> BeanDefinitionRegistryPostProcessor) &#123;BeanDefinitionRegistryPostProcessor registryProcessor =(BeanDefinitionRegistryPostProcessor) postProcessor;registryProcessor.postProcessBeanDefinitionRegistry(registry);registryProcessors.add(registryProcessor);&#125;<span class="hljs-keyword">else</span> &#123;regularPostProcessors.add(postProcessor);&#125;&#125;<span class="hljs-comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span><span class="hljs-comment">// uninitialized to let the bean factory post-processors apply to them!</span><span class="hljs-comment">// Separate between BeanDefinitionRegistryPostProcessors that implement</span><span class="hljs-comment">// PriorityOrdered, Ordered, and the rest.</span>List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<span class="hljs-comment">//获取实现了BeanDefinitionRegistryPostProcessor接口的所有类的BeanDefinition对象的beanName</span><span class="hljs-comment">// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.</span>String[] postProcessorNames =beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">true</span>, <span class="hljs-title">false</span>)</span>;<span class="hljs-keyword">for</span> (String ppName : postProcessorNames) &#123;<span class="hljs-comment">//判断是否实现了排序接口 PriorityOrdered</span><span class="hljs-keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered<span class="hljs-class">.<span class="hljs-keyword">class</span>)) </span>&#123;currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor<span class="hljs-class">.<span class="hljs-keyword">class</span>))</span>;processedBeans.add(ppName);&#125;&#125;<span class="hljs-comment">//排序</span>sortPostProcessors(currentRegistryProcessors, beanFactory);registryProcessors.addAll(currentRegistryProcessors);<span class="hljs-comment">//调用过程</span>invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);currentRegistryProcessors.clear();<span class="hljs-comment">// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.</span>postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">true</span>, <span class="hljs-title">false</span>)</span>;<span class="hljs-keyword">for</span> (String ppName : postProcessorNames) &#123;<span class="hljs-comment">//判断是否是实现的Ordered接口</span><span class="hljs-keyword">if</span> (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered<span class="hljs-class">.<span class="hljs-keyword">class</span>)) </span>&#123;         <span class="hljs-comment">//完成实例化</span>currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor<span class="hljs-class">.<span class="hljs-keyword">class</span>))</span>;processedBeans.add(ppName);&#125;&#125;sortPostProcessors(currentRegistryProcessors, beanFactory);registryProcessors.addAll(currentRegistryProcessors);invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);currentRegistryProcessors.clear();<span class="hljs-comment">//没实现排序接口的调用</span><span class="hljs-comment">// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.</span><span class="hljs-keyword">boolean</span> reiterate = <span class="hljs-keyword">true</span>;<span class="hljs-keyword">while</span> (reiterate) &#123;reiterate = <span class="hljs-keyword">false</span>;postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">true</span>, <span class="hljs-title">false</span>)</span>;<span class="hljs-keyword">for</span> (String ppName : postProcessorNames) &#123;<span class="hljs-keyword">if</span> (!processedBeans.contains(ppName)) &#123;currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor<span class="hljs-class">.<span class="hljs-keyword">class</span>))</span>;processedBeans.add(ppName);reiterate = <span class="hljs-keyword">true</span>;&#125;&#125;sortPostProcessors(currentRegistryProcessors, beanFactory);registryProcessors.addAll(currentRegistryProcessors);<span class="hljs-comment">//</span>invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);currentRegistryProcessors.clear();&#125;<span class="hljs-comment">//调用postProcessBeanFactory方法</span><span class="hljs-comment">// Now, invoke the postProcessBeanFactory callback of all processors handled so far.</span>invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// Invoke factory processors registered with the context instance.</span>invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);&#125;<span class="hljs-comment">//获取实现了BeanFactoryPostProcessor接口的类，获取beanDefinition的名称</span><span class="hljs-comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span><span class="hljs-comment">// uninitialized to let the bean factory post-processors apply to them!</span>String[] postProcessorNames =beanFactory.getBeanNamesForType(BeanFactoryPostProcessor<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">true</span>, <span class="hljs-title">false</span>)</span>;<span class="hljs-comment">// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,</span><span class="hljs-comment">// Ordered, and the rest.</span>List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();List&lt;String&gt; orderedPostProcessorNames = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();List&lt;String&gt; nonOrderedPostProcessorNames = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<span class="hljs-keyword">for</span> (String ppName : postProcessorNames) &#123;<span class="hljs-keyword">if</span> (processedBeans.contains(ppName)) &#123;<span class="hljs-comment">// skip - already processed in first phase above</span>&#125;<span class="hljs-comment">//实现了PriorityOrdered接口的</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered<span class="hljs-class">.<span class="hljs-keyword">class</span>)) </span>&#123;priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor<span class="hljs-class">.<span class="hljs-keyword">class</span>))</span>;&#125;<span class="hljs-comment">//实现了Ordered接口的</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered<span class="hljs-class">.<span class="hljs-keyword">class</span>)) </span>&#123;orderedPostProcessorNames.add(ppName);&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//没实现接口的</span>nonOrderedPostProcessorNames.add(ppName);&#125;&#125;<span class="hljs-comment">//排序</span><span class="hljs-comment">// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.</span>sortPostProcessors(priorityOrderedPostProcessors, beanFactory);<span class="hljs-comment">//调用</span>invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);<span class="hljs-comment">// Next, invoke the BeanFactoryPostProcessors that implement Ordered.</span>List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<span class="hljs-keyword">for</span> (String postProcessorName : orderedPostProcessorNames) &#123;orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor<span class="hljs-class">.<span class="hljs-keyword">class</span>))</span>;&#125;sortPostProcessors(orderedPostProcessors, beanFactory);invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);<span class="hljs-comment">// Finally, invoke all other BeanFactoryPostProcessors.</span>List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<span class="hljs-keyword">for</span> (String postProcessorName : nonOrderedPostProcessorNames) &#123;nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor<span class="hljs-class">.<span class="hljs-keyword">class</span>))</span>;&#125;invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);<span class="hljs-comment">// Clear cached merged bean definitions since the post-processors might have</span><span class="hljs-comment">// modified the original metadata, e.g. replacing placeholders in values...</span>beanFactory.clearMetadataCache();&#125;</code></pre><h2 id="registerBeanPostProcessors-方法"><a href="#registerBeanPostProcessors-方法" class="headerlink" title="registerBeanPostProcessors()方法"></a>registerBeanPostProcessors()方法</h2><p>registerBeanPostProcessors方法主要用于处理BeanPostProcessor接口，会实例化所有的BeanPostProcessor，将所有实现了BeanPostProcessor接口的类加载到BeanFactory中。BeanPostProcessor接口用于在BeanDefination初始化过程中对Bean进行一些操作。</p><p>调用顺序与invokeBeanFactoryPostProcessors()方法相同。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanPostProcessors</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext)</span> </span>&#123;<span class="hljs-comment">//拿到工程里面所有实现了BeanPostProcessor接口的类，获取到BeanDefinition的名称</span>String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">true</span>, <span class="hljs-title">false</span>)</span>;<span class="hljs-comment">// Register BeanPostProcessorChecker that logs an info message when</span><span class="hljs-comment">// a bean is created during BeanPostProcessor instantiation, i.e. when</span><span class="hljs-comment">// a bean is not eligible for getting processed by all BeanPostProcessors.</span><span class="hljs-keyword">int</span> beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + <span class="hljs-number">1</span> + postProcessorNames.length;beanFactory.addBeanPostProcessor(<span class="hljs-keyword">new</span> BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));<span class="hljs-comment">// Separate between BeanPostProcessors that implement PriorityOrdered,</span><span class="hljs-comment">// Ordered, and the rest.</span>List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();List&lt;BeanPostProcessor&gt; internalPostProcessors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();List&lt;String&gt; orderedPostProcessorNames = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();List&lt;String&gt; nonOrderedPostProcessorNames = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<span class="hljs-comment">//提前实例化BeanPostProcessor类型的bean，然后bean进行排序</span><span class="hljs-keyword">for</span> (String ppName : postProcessorNames) &#123;<span class="hljs-keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered<span class="hljs-class">.<span class="hljs-keyword">class</span>)) </span>&#123;<span class="hljs-comment">//getBean是实例化方法，后面我们在讲bean实例化过程是会着重讲到</span>BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;priorityOrderedPostProcessors.add(pp);<span class="hljs-comment">//判断类型是否是MergedBeanDefinitionPostProcessor，如果是则代码是内部使用的</span><span class="hljs-keyword">if</span> (pp <span class="hljs-keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;internalPostProcessors.add(pp);&#125;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered<span class="hljs-class">.<span class="hljs-keyword">class</span>)) </span>&#123;orderedPostProcessorNames.add(ppName);&#125;<span class="hljs-keyword">else</span> &#123;nonOrderedPostProcessorNames.add(ppName);&#125;&#125;<span class="hljs-comment">// First, register the BeanPostProcessors that implement PriorityOrdered.</span>sortPostProcessors(priorityOrderedPostProcessors, beanFactory);<span class="hljs-comment">//注册到BeanFactory中</span>registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);<span class="hljs-comment">// Next, register the BeanPostProcessors that implement Ordered.</span>List&lt;BeanPostProcessor&gt; orderedPostProcessors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<span class="hljs-keyword">for</span> (String ppName : orderedPostProcessorNames) &#123;BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;orderedPostProcessors.add(pp);<span class="hljs-keyword">if</span> (pp <span class="hljs-keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;internalPostProcessors.add(pp);&#125;&#125;sortPostProcessors(orderedPostProcessors, beanFactory);registerBeanPostProcessors(beanFactory, orderedPostProcessors);<span class="hljs-comment">// Now, register all regular BeanPostProcessors.</span>List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<span class="hljs-keyword">for</span> (String ppName : nonOrderedPostProcessorNames) &#123;BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;nonOrderedPostProcessors.add(pp);<span class="hljs-keyword">if</span> (pp <span class="hljs-keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;internalPostProcessors.add(pp);&#125;&#125;registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);<span class="hljs-comment">// Finally, re-register all internal BeanPostProcessors.</span>sortPostProcessors(internalPostProcessors, beanFactory);registerBeanPostProcessors(beanFactory, internalPostProcessors);<span class="hljs-comment">// Re-register post-processor for detecting inner beans as ApplicationListeners,</span><span class="hljs-comment">// moving it to the end of the processor chain (for picking up proxies etc).</span>beanFactory.addBeanPostProcessor(<span class="hljs-keyword">new</span> ApplicationListenerDetector(applicationContext));&#125;</code></pre><h2 id="finishBeanFactoryInitialization-方法"><a href="#finishBeanFactoryInitialization-方法" class="headerlink" title="finishBeanFactoryInitialization()方法"></a>finishBeanFactoryInitialization()方法</h2><p>这个方法是spring中最重要的方法，包括bean实例化过程、ioc、注解支持、BeanPostProcessor的执行、Aop的入口。</p><ol><li><p>preInstantiateSingletons()是他的主要方法，完成对bean的实例化。该方法会遍历beanDefinitionNames，首先会将父子BeanDefinition合并，然后将具有某些特征的BeanDefinition通过getBean()方法实例化。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preInstantiateSingletons</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;logger.trace(<span class="hljs-string">"Pre-instantiating singletons in "</span> + <span class="hljs-keyword">this</span>);&#125;   <span class="hljs-comment">// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span><span class="hljs-comment">// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span><span class="hljs-comment">//xml解析时，讲过，把所有beanName都缓存到beanDefinitionNames了</span>List&lt;String&gt; beanNames = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-keyword">this</span>.beanDefinitionNames);   <span class="hljs-comment">// Trigger initialization of all non-lazy singleton beans...</span><span class="hljs-keyword">for</span> (String beanName : beanNames) &#123;<span class="hljs-comment">//把父BeanDefinition里面的属性拿到子BeanDefinition中</span>     <span class="hljs-comment">//在解析xml时父子标签会被解析为两个BeanDefinition但只会实例化一个对象</span>RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);   <span class="hljs-comment">//如果不是抽象的，单例的，非懒加载的就实例化</span><span class="hljs-keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;   <span class="hljs-comment">//判断bean是否实现了FactoryBean接口，这里可以不看</span><span class="hljs-keyword">if</span> (isFactoryBean(beanName)) &#123;Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);<span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> FactoryBean) &#123;<span class="hljs-keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;<span class="hljs-keyword">boolean</span> isEagerInit;<span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-keyword">null</span> &amp;&amp; factory <span class="hljs-keyword">instanceof</span> SmartFactoryBean) &#123;isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;)((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,getAccessControlContext());&#125;<span class="hljs-keyword">else</span> &#123;isEagerInit = (factory <span class="hljs-keyword">instanceof</span> SmartFactoryBean &amp;&amp;((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());&#125;<span class="hljs-keyword">if</span> (isEagerInit) &#123;getBean(beanName);&#125;&#125;&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//主要从这里进入，看看实例化过程</span>getBean(beanName);&#125;&#125;&#125;   <span class="hljs-comment">// Trigger post-initialization callback for all applicable beans...</span><span class="hljs-keyword">for</span> (String beanName : beanNames) &#123;Object singletonInstance = getSingleton(beanName);<span class="hljs-keyword">if</span> (singletonInstance <span class="hljs-keyword">instanceof</span> SmartInitializingSingleton) &#123;<span class="hljs-keyword">final</span> SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;<span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-keyword">null</span>) &#123;AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;smartSingleton.afterSingletonsInstantiated();<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;, getAccessControlContext());&#125;<span class="hljs-keyword">else</span> &#123;smartSingleton.afterSingletonsInstantiated();&#125;&#125;&#125;&#125;</code></pre></li><li><p>getBean()是实例化的核心方法，doGetBean()方法是getBean()方法的主要方法。该方法首先会尝试从缓存中获取实例，如果没有再进行类的实例化，此时缓存中一般是没有实例的。在类实例化之前会判断类上是否有@Dependon注解，如果有就先实例化@Dependon注解中的类。类的实例化是通过getSingleton()方法实现的。getObjectForBeanInstance()方法用于对BeanFactory接口的支持，之后会进行单独分析。</p><pre><code class="hljs java"><span class="hljs-keyword">protected</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">doGetBean</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String name, @Nullable <span class="hljs-keyword">final</span> Class&lt;T&gt; requiredType,</span></span><span class="hljs-function"><span class="hljs-params">@Nullable <span class="hljs-keyword">final</span> Object[] args, <span class="hljs-keyword">boolean</span> typeCheckOnly)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<span class="hljs-keyword">final</span> String beanName = transformedBeanName(name);Object bean;<span class="hljs-comment">//从缓存中拿实例</span><span class="hljs-comment">// Eagerly check singleton cache for manually registered singletons.</span>Object sharedInstance = getSingleton(beanName);<span class="hljs-comment">//如果缓存里面能拿到实例</span><span class="hljs-keyword">if</span> (sharedInstance != <span class="hljs-keyword">null</span> &amp;&amp; args == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<span class="hljs-keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;logger.trace(<span class="hljs-string">"Returning eagerly cached instance of singleton bean '"</span> + beanName +<span class="hljs-string">"' that is not fully initialized yet - a consequence of a circular reference"</span>);&#125;<span class="hljs-keyword">else</span> &#123;logger.trace(<span class="hljs-string">"Returning cached instance of singleton bean '"</span> + beanName + <span class="hljs-string">"'"</span>);&#125;&#125;<span class="hljs-comment">//改方法是FactoryBean接口的调用入口</span>bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="hljs-keyword">null</span>);&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//如果singletonObjects缓存里面没有，则走下来</span><span class="hljs-comment">// Fail if we're already creating this bean instance:</span><span class="hljs-comment">// We're assumably within a circular reference.</span><span class="hljs-comment">//如果是scope 是Prototype的，校验是否有出现循环依赖，如果有则直接报错</span><span class="hljs-keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCurrentlyInCreationException(beanName);&#125;<span class="hljs-comment">// Check if bean definition exists in this factory.</span>BeanFactory parentBeanFactory = getParentBeanFactory();<span class="hljs-keyword">if</span> (parentBeanFactory != <span class="hljs-keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;<span class="hljs-comment">// Not found -&gt; check parent.</span>String nameToLookup = originalBeanName(name);<span class="hljs-keyword">if</span> (parentBeanFactory <span class="hljs-keyword">instanceof</span> AbstractBeanFactory) &#123;<span class="hljs-keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(nameToLookup, requiredType, args, typeCheckOnly);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (args != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">// Delegation to parent with explicit args.</span><span class="hljs-keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (requiredType != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">// No args -&gt; delegate to standard getBean method.</span><span class="hljs-keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup);&#125;&#125;<span class="hljs-keyword">if</span> (!typeCheckOnly) &#123;markBeanAsCreated(beanName);&#125;<span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//父子BeanDefinition合并</span><span class="hljs-keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);checkMergedBeanDefinition(mbd, beanName, args);<span class="hljs-comment">//获取依赖对象属性，依赖对象要先实例化</span><span class="hljs-comment">// Guarantee initialization of beans that the current bean depends on.</span>String[] dependsOn = mbd.getDependsOn();<span class="hljs-keyword">if</span> (dependsOn != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">for</span> (String dep : dependsOn) &#123;<span class="hljs-keyword">if</span> (isDependent(beanName, dep)) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,<span class="hljs-string">"Circular depends-on relationship between '"</span> + beanName + <span class="hljs-string">"' and '"</span> + dep + <span class="hljs-string">"'"</span>);&#125;registerDependentBean(dep, beanName);<span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//实例化</span>getBean(dep);&#125;<span class="hljs-keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,<span class="hljs-string">"'"</span> + beanName + <span class="hljs-string">"' depends on missing bean '"</span> + dep + <span class="hljs-string">"'"</span>, ex);&#125;&#125;&#125;<span class="hljs-comment">//着重看，大部分是单例的情况</span><span class="hljs-comment">// Create bean instance.</span><span class="hljs-keyword">if</span> (mbd.isSingleton()) &#123;sharedInstance = getSingleton(beanName, () -&gt; &#123;<span class="hljs-keyword">try</span> &#123;<span class="hljs-keyword">return</span> createBean(beanName, mbd, args);&#125;<span class="hljs-keyword">catch</span> (BeansException ex) &#123;<span class="hljs-comment">// Explicitly remove instance from singleton cache: It might have been put there</span><span class="hljs-comment">// eagerly by the creation process, to allow for circular reference resolution.</span><span class="hljs-comment">// Also remove any beans that received a temporary reference to the bean.</span>destroySingleton(beanName);<span class="hljs-keyword">throw</span> ex;&#125;&#125;);<span class="hljs-comment">//该方法是FactoryBean接口的调用入口</span>bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mbd.isPrototype()) &#123;<span class="hljs-comment">// It's a prototype -&gt; create a new instance.</span>Object prototypeInstance = <span class="hljs-keyword">null</span>;<span class="hljs-keyword">try</span> &#123;beforePrototypeCreation(beanName);prototypeInstance = createBean(beanName, mbd, args);&#125;<span class="hljs-keyword">finally</span> &#123;afterPrototypeCreation(beanName);&#125;<span class="hljs-comment">//该方法是FactoryBean接口的调用入口</span>bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);&#125;<span class="hljs-keyword">else</span> &#123;String scopeName = mbd.getScope();<span class="hljs-keyword">final</span> Scope scope = <span class="hljs-keyword">this</span>.scopes.get(scopeName);<span class="hljs-keyword">if</span> (scope == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"No Scope registered for scope name '"</span> + scopeName + <span class="hljs-string">"'"</span>);&#125;<span class="hljs-keyword">try</span> &#123;Object scopedInstance = scope.get(beanName, () -&gt; &#123;beforePrototypeCreation(beanName);<span class="hljs-keyword">try</span> &#123;<span class="hljs-keyword">return</span> createBean(beanName, mbd, args);&#125;<span class="hljs-keyword">finally</span> &#123;afterPrototypeCreation(beanName);&#125;&#125;);<span class="hljs-comment">//改方法是FactoryBean接口的调用入口</span>bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);&#125;<span class="hljs-keyword">catch</span> (IllegalStateException ex) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(beanName,<span class="hljs-string">"Scope '"</span> + scopeName + <span class="hljs-string">"' is not active for the current thread; consider "</span> +<span class="hljs-string">"defining a scoped proxy for this bean if you intend to refer to it from a singleton"</span>,ex);&#125;&#125;&#125;<span class="hljs-keyword">catch</span> (BeansException ex) &#123;cleanupAfterBeanCreationFailure(beanName);<span class="hljs-keyword">throw</span> ex;&#125;&#125;<span class="hljs-comment">// Check if required type matches the type of the actual bean instance.</span><span class="hljs-keyword">if</span> (requiredType != <span class="hljs-keyword">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;<span class="hljs-keyword">try</span> &#123;T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);<span class="hljs-keyword">if</span> (convertedBean == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());&#125;<span class="hljs-keyword">return</span> convertedBean;&#125;<span class="hljs-keyword">catch</span> (TypeMismatchException ex) &#123;<span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;logger.trace(<span class="hljs-string">"Failed to convert bean '"</span> + name + <span class="hljs-string">"' to required type '"</span> +ClassUtils.getQualifiedName(requiredType) + <span class="hljs-string">"'"</span>, ex);&#125;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());&#125;&#125;<span class="hljs-keyword">return</span> (T) bean;&#125;</code></pre></li><li><p>getSingleton()方法在创建前会将beanName添加到singletonsCurrentlyInCreation容器中，该容器中存储着正在实例化的beanName，然后调用传入的singletonFactory的getObject()方法创建实例，创建完成后再从容器中删除，并放入一级缓存中。getObject()方法会调用上层传入的方法createBean()。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getSingleton</span><span class="hljs-params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;Assert.notNull(beanName, <span class="hljs-string">"Bean name must not be null"</span>);<span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.singletonObjects) &#123;<span class="hljs-comment">//如果缓存中有，则直接返回</span>Object singletonObject = <span class="hljs-keyword">this</span>.singletonObjects.get(beanName);<span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.singletonsCurrentlyInDestruction) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationNotAllowedException(beanName,<span class="hljs-string">"Singleton bean creation not allowed while singletons of this factory are in destruction "</span> +<span class="hljs-string">"(Do not request a bean from a BeanFactory in a destroy method implementation!)"</span>);&#125;<span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;logger.debug(<span class="hljs-string">"Creating shared instance of singleton bean '"</span> + beanName + <span class="hljs-string">"'"</span>);&#125;   <span class="hljs-comment">//把beanName添加到singletonsCurrentlyInCreation Set容器中，在这个集合里面的bean都是正在实例化的bean</span>beforeSingletonCreation(beanName);<span class="hljs-keyword">boolean</span> newSingleton = <span class="hljs-keyword">false</span>;<span class="hljs-keyword">boolean</span> recordSuppressedExceptions = (<span class="hljs-keyword">this</span>.suppressedExceptions == <span class="hljs-keyword">null</span>);<span class="hljs-keyword">if</span> (recordSuppressedExceptions) &#123;<span class="hljs-keyword">this</span>.suppressedExceptions = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;();&#125;       <span class="hljs-comment">//调用上层传入的方法创建实例</span><span class="hljs-keyword">try</span> &#123;singletonObject = singletonFactory.getObject();newSingleton = <span class="hljs-keyword">true</span>;&#125;<span class="hljs-keyword">catch</span> (IllegalStateException ex) &#123;<span class="hljs-comment">// Has the singleton object implicitly appeared in the meantime -&gt;</span><span class="hljs-comment">// if yes, proceed with it since the exception indicates that state.</span>singletonObject = <span class="hljs-keyword">this</span>.singletonObjects.get(beanName);<span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">throw</span> ex;&#125;&#125;<span class="hljs-keyword">catch</span> (BeanCreationException ex) &#123;<span class="hljs-keyword">if</span> (recordSuppressedExceptions) &#123;<span class="hljs-keyword">for</span> (Exception suppressedException : <span class="hljs-keyword">this</span>.suppressedExceptions) &#123;ex.addRelatedCause(suppressedException);&#125;&#125;<span class="hljs-keyword">throw</span> ex;&#125;<span class="hljs-keyword">finally</span> &#123;<span class="hljs-keyword">if</span> (recordSuppressedExceptions) &#123;<span class="hljs-keyword">this</span>.suppressedExceptions = <span class="hljs-keyword">null</span>;&#125;<span class="hljs-comment">//bean创建完成后singletonsCurrentlyInCreation要删除该bean</span>afterSingletonCreation(beanName);&#125;<span class="hljs-keyword">if</span> (newSingleton) &#123;<span class="hljs-comment">//创建对象成功时，把对象缓存到singletonObjects缓存中,bean创建完成时放入一级缓存</span>addSingleton(beanName, singletonObject);&#125;&#125;<span class="hljs-keyword">return</span> singletonObject;&#125;</code></pre></li><li><p>doCreateBean()是createBean()的主要方法。此方法中首先会通过createBeanInstance()方法创建实例，然后调用applyMergedBeanDefinitionPostProcessors()方法完成注解的装配，收集。addSingletonFactory()方法用于解决循环依赖的问题，之后会进行分析。populateBean()方法用于完成applyMergedBeanDefinitionPostProcessors(方法装配的注解进行处理，主要完成IOC、DI等工作。initializeBean()方法用于完成实例化后的一些操作。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">doCreateBean</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String beanName, <span class="hljs-keyword">final</span> RootBeanDefinition mbd, <span class="hljs-keyword">final</span> @Nullable Object[] args)</span></span><span class="hljs-function"><span class="hljs-keyword">throws</span> BeanCreationException </span>&#123;   <span class="hljs-comment">// Instantiate the bean.</span>BeanWrapper instanceWrapper = <span class="hljs-keyword">null</span>;<span class="hljs-keyword">if</span> (mbd.isSingleton()) &#123;instanceWrapper = <span class="hljs-keyword">this</span>.factoryBeanInstanceCache.remove(beanName);&#125;<span class="hljs-keyword">if</span> (instanceWrapper == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//创建实例 重点看 重要程度：5</span>instanceWrapper = createBeanInstance(beanName, mbd, args);&#125;<span class="hljs-keyword">final</span> Object bean = instanceWrapper.getWrappedInstance();Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();<span class="hljs-keyword">if</span> (beanType != NullBean<span class="hljs-class">.<span class="hljs-keyword">class</span>) </span>&#123;mbd.resolvedTargetType = beanType;&#125;   <span class="hljs-comment">// Allow post-processors to modify the merged bean definition.</span><span class="hljs-keyword">synchronized</span> (mbd.postProcessingLock) &#123;<span class="hljs-keyword">if</span> (!mbd.postProcessed) &#123;<span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//CommonAnnotationBeanPostProcessor  支持了@PostConstruct，@PreDestroy,@Resource注解</span><span class="hljs-comment">//AutowiredAnnotationBeanPostProcessor 支持 @Autowired,@Value注解</span><span class="hljs-comment">//BeanPostProcessor接口的典型运用，这里要理解这个接口</span><span class="hljs-comment">//对类中注解的装配过程</span><span class="hljs-comment">//重要程度5，必须看</span>applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);&#125;<span class="hljs-keyword">catch</span> (Throwable ex) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,<span class="hljs-string">"Post-processing of merged bean definition failed"</span>, ex);&#125;mbd.postProcessed = <span class="hljs-keyword">true</span>;&#125;&#125;   <span class="hljs-comment">// Eagerly cache singletons to be able to resolve circular references</span><span class="hljs-comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span><span class="hljs-comment">//是否单例bean提前暴露</span><span class="hljs-keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="hljs-keyword">this</span>.allowCircularReferences &amp;&amp;isSingletonCurrentlyInCreation(beanName));<span class="hljs-keyword">if</span> (earlySingletonExposure) &#123;<span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;logger.trace(<span class="hljs-string">"Eagerly caching bean '"</span> + beanName +<span class="hljs-string">"' to allow for resolving potential circular references"</span>);&#125;<span class="hljs-comment">//这里着重理解，对理解循环依赖帮助非常大，重要程度 5   添加三级缓存</span>addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));&#125;   <span class="hljs-comment">// Initialize the bean instance.</span>Object exposedObject = bean;<span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//ioc di，依赖注入的核心方法，该方法必须看，重要程度：5</span>populateBean(beanName, mbd, instanceWrapper);   <span class="hljs-comment">//bean 实例化+ioc依赖注入完以后的调用，非常重要，重要程度：5</span>exposedObject = initializeBean(beanName, exposedObject, mbd);&#125;<span class="hljs-keyword">catch</span> (Throwable ex) &#123;<span class="hljs-keyword">if</span> (ex <span class="hljs-keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;<span class="hljs-keyword">throw</span> (BeanCreationException) ex;&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="hljs-string">"Initialization of bean failed"</span>, ex);&#125;&#125;   <span class="hljs-keyword">if</span> (earlySingletonExposure) &#123;Object earlySingletonReference = getSingleton(beanName, <span class="hljs-keyword">false</span>);<span class="hljs-keyword">if</span> (earlySingletonReference != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">if</span> (exposedObject == bean) &#123;exposedObject = earlySingletonReference;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;String[] dependentBeans = getDependentBeans(beanName);Set&lt;String&gt; actualDependentBeans = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(dependentBeans.length);<span class="hljs-keyword">for</span> (String dependentBean : dependentBeans) &#123;<span class="hljs-keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;actualDependentBeans.add(dependentBean);&#125;&#125;<span class="hljs-keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCurrentlyInCreationException(beanName,<span class="hljs-string">"Bean with name '"</span> + beanName + <span class="hljs-string">"' has been injected into other beans ["</span> +StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +<span class="hljs-string">"] in its raw version as part of a circular reference, but has eventually been "</span> +<span class="hljs-string">"wrapped. This means that said other beans do not use the final version of the "</span> +<span class="hljs-string">"bean. This is often the result of over-eager type matching - consider using "</span> +<span class="hljs-string">"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example."</span>);&#125;&#125;&#125;&#125;   <span class="hljs-comment">// Register bean as disposable.</span><span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//注册bean销毁时的类DisposableBeanAdapter</span>registerDisposableBeanIfNecessary(beanName, bean, mbd);&#125;<span class="hljs-keyword">catch</span> (BeanDefinitionValidationException ex) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="hljs-string">"Invalid destruction signature"</span>, ex);&#125;   <span class="hljs-keyword">return</span> exposedObject;&#125;</code></pre></li></ol><h3 id="createBeanInstance-方法"><a href="#createBeanInstance-方法" class="headerlink" title="createBeanInstance()方法"></a>createBeanInstance()方法</h3><ol><li><p>createBeanInstance()方法，首先会通过反射拿到Class对象，然后会检查是否有FactoryMethodName属性，如果有则调用instantiateUsingFactoryMethod()方法创建后返回，如果没有会使用determineConstructorsFromBeanPostProcessors()方法扫描有Autowired注解的构造函数，如果有则使用autowireConstructor()方法创建对象并返回，无参构造直接使用反射调用构造函数创建实例并包装为BeanWrapperImpl返回。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> BeanWrapper <span class="hljs-title">createBeanInstance</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span> </span>&#123;<span class="hljs-comment">// Make sure bean class is actually resolved at this point.</span><span class="hljs-comment">//反射拿到Class对象</span>Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);   <span class="hljs-keyword">if</span> (beanClass != <span class="hljs-keyword">null</span> &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,<span class="hljs-string">"Bean class isn't public, and non-public access not allowed: "</span> + beanClass.getName());&#125;   Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();<span class="hljs-keyword">if</span> (instanceSupplier != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">return</span> obtainFromSupplier(instanceSupplier, beanName);&#125;   <span class="hljs-comment">//如果有FactoryMethodName属性</span><span class="hljs-keyword">if</span> (mbd.getFactoryMethodName() != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);&#125;   <span class="hljs-comment">// Shortcut when re-creating the same bean...</span><span class="hljs-keyword">boolean</span> resolved = <span class="hljs-keyword">false</span>;<span class="hljs-keyword">boolean</span> autowireNecessary = <span class="hljs-keyword">false</span>;<span class="hljs-keyword">if</span> (args == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;<span class="hljs-keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != <span class="hljs-keyword">null</span>) &#123;resolved = <span class="hljs-keyword">true</span>;autowireNecessary = mbd.constructorArgumentsResolved;&#125;&#125;&#125;<span class="hljs-keyword">if</span> (resolved) &#123;<span class="hljs-keyword">if</span> (autowireNecessary) &#123;<span class="hljs-keyword">return</span> autowireConstructor(beanName, mbd, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> instantiateBean(beanName, mbd);&#125;&#125;   <span class="hljs-comment">// Candidate constructors for autowiring?</span><span class="hljs-comment">//寻找当前正在实例化的bean中有@Autowired注解的构造函数</span>Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);<span class="hljs-keyword">if</span> (ctors != <span class="hljs-keyword">null</span> || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) &#123;<span class="hljs-comment">//如果ctors不为空，就说明构造函数上有@Autowired注解</span><span class="hljs-keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);&#125;   <span class="hljs-comment">// Preferred constructors for default construction?</span>ctors = mbd.getPreferredConstructors();<span class="hljs-keyword">if</span> (ctors != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">return</span> autowireConstructor(beanName, mbd, ctors, <span class="hljs-keyword">null</span>);&#125;   <span class="hljs-comment">//无参构造函数的实例化,大部分的实例是采用的无参构造函数的方式实例化</span><span class="hljs-comment">// No special handling: simply use no-arg constructor.</span><span class="hljs-keyword">return</span> instantiateBean(beanName, mbd);&#125;</code></pre></li><li><p>instantiateUsingFactoryMethod()方法是通过反射调用类中的factoryMethod方法创建对象，然后将对象包装为BeanWrapperImpl对象。BeanWrapperImpl对象中包含对实例的引用，以及一些编辑器和类型转换器，这个对象不需要深究，了解即可。@Bean注解其实就是把方法名称设置到BeanDefinition的factoryMethod属性中。该方法里面的参数解析过程不需要了解。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> BeanWrapper <span class="hljs-title">instantiateUsingFactoryMethod</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">String beanName, RootBeanDefinition mbd, @Nullable Object[] explicitArgs)</span> </span>&#123;   BeanWrapperImpl bw = <span class="hljs-keyword">new</span> BeanWrapperImpl();<span class="hljs-keyword">this</span>.beanFactory.initBeanWrapper(bw);   Object factoryBean;Class&lt;?&gt; factoryClass;<span class="hljs-keyword">boolean</span> isStatic;   String factoryBeanName = mbd.getFactoryBeanName();<span class="hljs-keyword">if</span> (factoryBeanName != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">if</span> (factoryBeanName.equals(beanName)) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,<span class="hljs-string">"factory-bean reference points back to the same bean definition"</span>);&#125;factoryBean = <span class="hljs-keyword">this</span>.beanFactory.getBean(factoryBeanName);<span class="hljs-keyword">if</span> (mbd.isSingleton() &amp;&amp; <span class="hljs-keyword">this</span>.beanFactory.containsSingleton(beanName)) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ImplicitlyAppearedSingletonException();&#125;factoryClass = factoryBean.getClass();isStatic = <span class="hljs-keyword">false</span>;&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// It's a static factory method on the bean class.</span><span class="hljs-keyword">if</span> (!mbd.hasBeanClass()) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,<span class="hljs-string">"bean definition declares neither a bean class nor a factory-bean reference"</span>);&#125;factoryBean = <span class="hljs-keyword">null</span>;factoryClass = mbd.getBeanClass();isStatic = <span class="hljs-keyword">true</span>;&#125;   Method factoryMethodToUse = <span class="hljs-keyword">null</span>;ArgumentsHolder argsHolderToUse = <span class="hljs-keyword">null</span>;Object[] argsToUse = <span class="hljs-keyword">null</span>;   <span class="hljs-keyword">if</span> (explicitArgs != <span class="hljs-keyword">null</span>) &#123;argsToUse = explicitArgs;&#125;<span class="hljs-keyword">else</span> &#123;Object[] argsToResolve = <span class="hljs-keyword">null</span>;<span class="hljs-keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;<span class="hljs-keyword">if</span> (factoryMethodToUse != <span class="hljs-keyword">null</span> &amp;&amp; mbd.constructorArgumentsResolved) &#123;<span class="hljs-comment">// Found a cached factory method...</span>argsToUse = mbd.resolvedConstructorArguments;<span class="hljs-keyword">if</span> (argsToUse == <span class="hljs-keyword">null</span>) &#123;argsToResolve = mbd.preparedConstructorArguments;&#125;&#125;&#125;<span class="hljs-keyword">if</span> (argsToResolve != <span class="hljs-keyword">null</span>) &#123;argsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve, <span class="hljs-keyword">true</span>);&#125;&#125;   <span class="hljs-keyword">if</span> (factoryMethodToUse == <span class="hljs-keyword">null</span> || argsToUse == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">// Need to determine the factory method...</span><span class="hljs-comment">// Try all methods with this name to see if they match the given arguments.</span>factoryClass = ClassUtils.getUserClass(factoryClass);   Method[] rawCandidates = getCandidateMethods(factoryClass, mbd);List&lt;Method&gt; candidateList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<span class="hljs-keyword">for</span> (Method candidate : rawCandidates) &#123;<span class="hljs-keyword">if</span> (Modifier.isStatic(candidate.getModifiers()) == isStatic &amp;&amp; mbd.isFactoryMethod(candidate)) &#123;candidateList.add(candidate);&#125;&#125;   <span class="hljs-keyword">if</span> (candidateList.size() == <span class="hljs-number">1</span> &amp;&amp; explicitArgs == <span class="hljs-keyword">null</span> &amp;&amp; !mbd.hasConstructorArgumentValues()) &#123;Method uniqueCandidate = candidateList.get(<span class="hljs-number">0</span>);<span class="hljs-keyword">if</span> (uniqueCandidate.getParameterCount() == <span class="hljs-number">0</span>) &#123;mbd.factoryMethodToIntrospect = uniqueCandidate;<span class="hljs-keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;mbd.resolvedConstructorOrFactoryMethod = uniqueCandidate;mbd.constructorArgumentsResolved = <span class="hljs-keyword">true</span>;mbd.resolvedConstructorArguments = EMPTY_ARGS;&#125;bw.setBeanInstance(instantiate(beanName, mbd, factoryBean, uniqueCandidate, EMPTY_ARGS));<span class="hljs-keyword">return</span> bw;&#125;&#125;   Method[] candidates = candidateList.toArray(<span class="hljs-keyword">new</span> Method[<span class="hljs-number">0</span>]);AutowireUtils.sortFactoryMethods(candidates);   ConstructorArgumentValues resolvedValues = <span class="hljs-keyword">null</span>;<span class="hljs-keyword">boolean</span> autowiring = (mbd.getResolvedAutowireMode() == AutowireCapableBeanFactory.AUTOWIRE_CONSTRUCTOR);<span class="hljs-keyword">int</span> minTypeDiffWeight = Integer.MAX_VALUE;Set&lt;Method&gt; ambiguousFactoryMethods = <span class="hljs-keyword">null</span>;   <span class="hljs-keyword">int</span> minNrOfArgs;<span class="hljs-keyword">if</span> (explicitArgs != <span class="hljs-keyword">null</span>) &#123;minNrOfArgs = explicitArgs.length;&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// We don't have arguments passed in programmatically, so we need to resolve the</span><span class="hljs-comment">// arguments specified in the constructor arguments held in the bean definition.</span><span class="hljs-keyword">if</span> (mbd.hasConstructorArgumentValues()) &#123;ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();resolvedValues = <span class="hljs-keyword">new</span> ConstructorArgumentValues();minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);&#125;<span class="hljs-keyword">else</span> &#123;minNrOfArgs = <span class="hljs-number">0</span>;&#125;&#125;   LinkedList&lt;UnsatisfiedDependencyException&gt; causes = <span class="hljs-keyword">null</span>;   <span class="hljs-keyword">for</span> (Method candidate : candidates) &#123;Class&lt;?&gt;[] paramTypes = candidate.getParameterTypes();   <span class="hljs-keyword">if</span> (paramTypes.length &gt;= minNrOfArgs) &#123;ArgumentsHolder argsHolder;   <span class="hljs-keyword">if</span> (explicitArgs != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">// Explicit arguments given -&gt; arguments length must match exactly.</span><span class="hljs-keyword">if</span> (paramTypes.length != explicitArgs.length) &#123;<span class="hljs-keyword">continue</span>;&#125;argsHolder = <span class="hljs-keyword">new</span> ArgumentsHolder(explicitArgs);&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// Resolved constructor arguments: type conversion and/or autowiring necessary.</span><span class="hljs-keyword">try</span> &#123;String[] paramNames = <span class="hljs-keyword">null</span>;ParameterNameDiscoverer pnd = <span class="hljs-keyword">this</span>.beanFactory.getParameterNameDiscoverer();<span class="hljs-keyword">if</span> (pnd != <span class="hljs-keyword">null</span>) &#123;paramNames = pnd.getParameterNames(candidate);&#125;argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw,paramTypes, paramNames, candidate, autowiring, candidates.length == <span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">catch</span> (UnsatisfiedDependencyException ex) &#123;<span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;logger.trace(<span class="hljs-string">"Ignoring factory method ["</span> + candidate + <span class="hljs-string">"] of bean '"</span> + beanName + <span class="hljs-string">"': "</span> + ex);&#125;<span class="hljs-comment">// Swallow and try next overloaded factory method.</span><span class="hljs-keyword">if</span> (causes == <span class="hljs-keyword">null</span>) &#123;causes = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();&#125;causes.add(ex);<span class="hljs-keyword">continue</span>;&#125;&#125;   <span class="hljs-keyword">int</span> typeDiffWeight = (mbd.isLenientConstructorResolution() ?argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));<span class="hljs-comment">// Choose this factory method if it represents the closest match.</span><span class="hljs-keyword">if</span> (typeDiffWeight &lt; minTypeDiffWeight) &#123;factoryMethodToUse = candidate;argsHolderToUse = argsHolder;argsToUse = argsHolder.arguments;minTypeDiffWeight = typeDiffWeight;ambiguousFactoryMethods = <span class="hljs-keyword">null</span>;&#125;<span class="hljs-comment">// Find out about ambiguity: In case of the same type difference weight</span><span class="hljs-comment">// for methods with the same number of parameters, collect such candidates</span><span class="hljs-comment">// and eventually raise an ambiguity exception.</span><span class="hljs-comment">// However, only perform that check in non-lenient constructor resolution mode,</span><span class="hljs-comment">// and explicitly ignore overridden methods (with the same parameter signature).</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (factoryMethodToUse != <span class="hljs-keyword">null</span> &amp;&amp; typeDiffWeight == minTypeDiffWeight &amp;&amp;!mbd.isLenientConstructorResolution() &amp;&amp;paramTypes.length == factoryMethodToUse.getParameterCount() &amp;&amp;!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) &#123;<span class="hljs-keyword">if</span> (ambiguousFactoryMethods == <span class="hljs-keyword">null</span>) &#123;ambiguousFactoryMethods = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;();ambiguousFactoryMethods.add(factoryMethodToUse);&#125;ambiguousFactoryMethods.add(candidate);&#125;&#125;&#125;   <span class="hljs-keyword">if</span> (factoryMethodToUse == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">if</span> (causes != <span class="hljs-keyword">null</span>) &#123;UnsatisfiedDependencyException ex = causes.removeLast();<span class="hljs-keyword">for</span> (Exception cause : causes) &#123;<span class="hljs-keyword">this</span>.beanFactory.onSuppressedException(cause);&#125;<span class="hljs-keyword">throw</span> ex;&#125;List&lt;String&gt; argTypes = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(minNrOfArgs);<span class="hljs-keyword">if</span> (explicitArgs != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">for</span> (Object arg : explicitArgs) &#123;argTypes.add(arg != <span class="hljs-keyword">null</span> ? arg.getClass().getSimpleName() : <span class="hljs-string">"null"</span>);&#125;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (resolvedValues != <span class="hljs-keyword">null</span>) &#123;Set&lt;ValueHolder&gt; valueHolders = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(resolvedValues.getArgumentCount());valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());valueHolders.addAll(resolvedValues.getGenericArgumentValues());<span class="hljs-keyword">for</span> (ValueHolder value : valueHolders) &#123;String argType = (value.getType() != <span class="hljs-keyword">null</span> ? ClassUtils.getShortName(value.getType()) :(value.getValue() != <span class="hljs-keyword">null</span> ? value.getValue().getClass().getSimpleName() : <span class="hljs-string">"null"</span>));argTypes.add(argType);&#125;&#125;String argDesc = StringUtils.collectionToCommaDelimitedString(argTypes);<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,<span class="hljs-string">"No matching factory method found: "</span> +(mbd.getFactoryBeanName() != <span class="hljs-keyword">null</span> ?<span class="hljs-string">"factory bean '"</span> + mbd.getFactoryBeanName() + <span class="hljs-string">"'; "</span> : <span class="hljs-string">""</span>) +<span class="hljs-string">"factory method '"</span> + mbd.getFactoryMethodName() + <span class="hljs-string">"("</span> + argDesc + <span class="hljs-string">")'. "</span> +<span class="hljs-string">"Check that a method with the specified name "</span> +(minNrOfArgs &gt; <span class="hljs-number">0</span> ? <span class="hljs-string">"and arguments "</span> : <span class="hljs-string">""</span>) +<span class="hljs-string">"exists and that it is "</span> +(isStatic ? <span class="hljs-string">"static"</span> : <span class="hljs-string">"non-static"</span>) + <span class="hljs-string">"."</span>);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">void</span><span class="hljs-class">.<span class="hljs-keyword">class</span> </span>== factoryMethodToUse.getReturnType()) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,<span class="hljs-string">"Invalid factory method '"</span> + mbd.getFactoryMethodName() +<span class="hljs-string">"': needs to have a non-void return type!"</span>);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ambiguousFactoryMethods != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,<span class="hljs-string">"Ambiguous factory method matches found in bean '"</span> + beanName + <span class="hljs-string">"' "</span> +<span class="hljs-string">"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): "</span> +ambiguousFactoryMethods);&#125;   <span class="hljs-keyword">if</span> (explicitArgs == <span class="hljs-keyword">null</span> &amp;&amp; argsHolderToUse != <span class="hljs-keyword">null</span>) &#123;mbd.factoryMethodToIntrospect = factoryMethodToUse;argsHolderToUse.storeCache(mbd, factoryMethodToUse);&#125;&#125;   Assert.state(argsToUse != <span class="hljs-keyword">null</span>, <span class="hljs-string">"Unresolved factory method arguments"</span>);bw.setBeanInstance(instantiate(beanName, mbd, factoryBean, factoryMethodToUse, argsToUse));<span class="hljs-keyword">return</span> bw;&#125;</code></pre></li><li><p>determineConstructorsFromBeanPostProcessors()首先会获取所有的BeanPostProcessor，然后调用determineCandidateConstructors()方法获取带@Autowired注解的构造函数。该方法是BeanPostProcessor接口类的首次应用，最终会掉到AutowiredAnnotationBeanPostProcessor类的方法，在方法中会扫描有注解的构造函数并返回。</p><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Constructor&lt;?&gt;[] determineConstructorsFromBeanPostProcessors(<span class="hljs-meta">@Nullable</span> Class&lt;?&gt; beanClass, String beanName)<span class="hljs-keyword">throws</span> BeansException &#123;   <span class="hljs-keyword">if</span> (beanClass != <span class="hljs-keyword">null</span> &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;<span class="hljs-comment">//获取所有的BeanPostProcessors</span><span class="hljs-keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;<span class="hljs-keyword">if</span> (bp <span class="hljs-keyword">instanceof</span> SmartInstantiationAwareBeanPostProcessor) &#123;SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;<span class="hljs-comment">//找到合适的构造函数</span>Constructor&lt;?&gt;[] ctors = ibp.determineCandidateConstructors(beanClass, beanName);<span class="hljs-keyword">if</span> (ctors != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">return</span> ctors;&#125;&#125;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre></li><li><p>AutowiredAnnotationBeanPostProcessor中的determineCandidateConstructors()方法，该方法会返回有@Autowired注解的构造函数。该方法首先会扫描所有方法，处理有@Lookup注解的方法，然后拿到所有的构造函数并使用findAutowiredAnnotation()方法对@Autowired跟@Value注解进行扫描，返回有@Autowired的构造函数。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> Constructor&lt;?&gt;[] determineCandidateConstructors(Class&lt;?&gt; beanClass, <span class="hljs-keyword">final</span> String beanName)<span class="hljs-keyword">throws</span> BeanCreationException &#123;   <span class="hljs-comment">// Let's check for lookup methods here..</span><span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.lookupMethodsChecked.contains(beanName)) &#123;<span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//拿到所有方法，循环回调lambda中的内容</span>ReflectionUtils.doWithMethods(beanClass, method -&gt; &#123;<span class="hljs-comment">//对注解@Lookup的支持，该注解用于替代方法返回值</span>Lookup lookup = method.getAnnotation(Lookup<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<span class="hljs-keyword">if</span> (lookup != <span class="hljs-keyword">null</span>) &#123;Assert.state(<span class="hljs-keyword">this</span>.beanFactory != <span class="hljs-keyword">null</span>, <span class="hljs-string">"No BeanFactory available"</span>);LookupOverride override = <span class="hljs-keyword">new</span> LookupOverride(method, lookup.value());<span class="hljs-keyword">try</span> &#123;RootBeanDefinition mbd = (RootBeanDefinition) <span class="hljs-keyword">this</span>.beanFactory.getMergedBeanDefinition(beanName);mbd.getMethodOverrides().addOverride(override);&#125;<span class="hljs-keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(beanName,<span class="hljs-string">"Cannot apply @Lookup to beans without corresponding bean definition"</span>);&#125;&#125;&#125;);&#125;<span class="hljs-keyword">catch</span> (IllegalStateException ex) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(beanName, <span class="hljs-string">"Lookup method resolution failed"</span>, ex);&#125;<span class="hljs-keyword">this</span>.lookupMethodsChecked.add(beanName);&#125;   <span class="hljs-comment">// Quick check on the concurrent map first, with minimal locking.</span>Constructor&lt;?&gt;[] candidateConstructors = <span class="hljs-keyword">this</span>.candidateConstructorsCache.get(beanClass);<span class="hljs-keyword">if</span> (candidateConstructors == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">// Fully synchronized resolution now...</span><span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.candidateConstructorsCache) &#123;candidateConstructors = <span class="hljs-keyword">this</span>.candidateConstructorsCache.get(beanClass);<span class="hljs-keyword">if</span> (candidateConstructors == <span class="hljs-keyword">null</span>) &#123;Constructor&lt;?&gt;[] rawCandidates;<span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//获取bean对应的所有构造器</span>rawCandidates = beanClass.getDeclaredConstructors();&#125;<span class="hljs-keyword">catch</span> (Throwable ex) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(beanName,<span class="hljs-string">"Resolution of declared constructors on bean Class ["</span> + beanClass.getName() +<span class="hljs-string">"] from ClassLoader ["</span> + beanClass.getClassLoader() + <span class="hljs-string">"] failed"</span>, ex);&#125;List&lt;Constructor&lt;?&gt;&gt; candidates = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(rawCandidates.length);Constructor&lt;?&gt; requiredConstructor = <span class="hljs-keyword">null</span>;Constructor&lt;?&gt; defaultConstructor = <span class="hljs-keyword">null</span>;Constructor&lt;?&gt; primaryConstructor = BeanUtils.findPrimaryConstructor(beanClass);<span class="hljs-keyword">int</span> nonSyntheticConstructors = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (Constructor&lt;?&gt; candidate : rawCandidates) &#123;<span class="hljs-keyword">if</span> (!candidate.isSynthetic()) &#123;nonSyntheticConstructors++;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (primaryConstructor != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-comment">//获取到构造函数上的@Autowired注解信息,这个方法可以不看</span>AnnotationAttributes ann = findAutowiredAnnotation(candidate);<span class="hljs-keyword">if</span> (ann == <span class="hljs-keyword">null</span>) &#123;Class&lt;?&gt; userClass = ClassUtils.getUserClass(beanClass);<span class="hljs-keyword">if</span> (userClass != beanClass) &#123;<span class="hljs-keyword">try</span> &#123;Constructor&lt;?&gt; superCtor =userClass.getDeclaredConstructor(candidate.getParameterTypes());   ann = findAutowiredAnnotation(superCtor);&#125;<span class="hljs-keyword">catch</span> (NoSuchMethodException ex) &#123;<span class="hljs-comment">// Simply proceed, no equivalent superclass constructor found...</span>&#125;&#125;&#125;<span class="hljs-keyword">if</span> (ann != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">if</span> (requiredConstructor != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(beanName,<span class="hljs-string">"Invalid autowire-marked constructor: "</span> + candidate +<span class="hljs-string">". Found constructor with 'required' Autowired annotation already: "</span> +requiredConstructor);&#125;<span class="hljs-comment">//获取到@Autowired里面的required方法的值</span><span class="hljs-keyword">boolean</span> required = determineRequiredStatus(ann);<span class="hljs-keyword">if</span> (required) &#123;<span class="hljs-keyword">if</span> (!candidates.isEmpty()) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(beanName,<span class="hljs-string">"Invalid autowire-marked constructors: "</span> + candidates +<span class="hljs-string">". Found constructor with 'required' Autowired annotation: "</span> +candidate);&#125;requiredConstructor = candidate;&#125;candidates.add(candidate);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (candidate.getParameterCount() == <span class="hljs-number">0</span>) &#123;defaultConstructor = candidate;&#125;&#125;<span class="hljs-keyword">if</span> (!candidates.isEmpty()) &#123;<span class="hljs-comment">// Add default constructor to list of optional constructors, as fallback.</span><span class="hljs-keyword">if</span> (requiredConstructor == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">if</span> (defaultConstructor != <span class="hljs-keyword">null</span>) &#123;candidates.add(defaultConstructor);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (candidates.size() == <span class="hljs-number">1</span> &amp;&amp; logger.isInfoEnabled()) &#123;logger.info(<span class="hljs-string">"Inconsistent constructor declaration on bean with name '"</span> + beanName +<span class="hljs-string">"': single autowire-marked constructor flagged as optional - "</span> +<span class="hljs-string">"this constructor is effectively required since there is no "</span> +<span class="hljs-string">"default constructor to fall back to: "</span> + candidates.get(<span class="hljs-number">0</span>));&#125;&#125;candidateConstructors = candidates.toArray(<span class="hljs-keyword">new</span> Constructor&lt;?&gt;[<span class="hljs-number">0</span>]);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rawCandidates.length == <span class="hljs-number">1</span> &amp;&amp; rawCandidates[<span class="hljs-number">0</span>].getParameterCount() &gt; <span class="hljs-number">0</span>) &#123;candidateConstructors = <span class="hljs-keyword">new</span> Constructor&lt;?&gt;[] &#123;rawCandidates[<span class="hljs-number">0</span>]&#125;;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nonSyntheticConstructors == <span class="hljs-number">2</span> &amp;&amp; primaryConstructor != <span class="hljs-keyword">null</span> &amp;&amp;defaultConstructor != <span class="hljs-keyword">null</span> &amp;&amp; !primaryConstructor.equals(defaultConstructor)) &#123;candidateConstructors = <span class="hljs-keyword">new</span> Constructor&lt;?&gt;[] &#123;primaryConstructor, defaultConstructor&#125;;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nonSyntheticConstructors == <span class="hljs-number">1</span> &amp;&amp; primaryConstructor != <span class="hljs-keyword">null</span>) &#123;candidateConstructors = <span class="hljs-keyword">new</span> Constructor&lt;?&gt;[] &#123;primaryConstructor&#125;;&#125;<span class="hljs-keyword">else</span> &#123;candidateConstructors = <span class="hljs-keyword">new</span> Constructor&lt;?&gt;[<span class="hljs-number">0</span>];&#125;<span class="hljs-keyword">this</span>.candidateConstructorsCache.put(beanClass, candidateConstructors);&#125;&#125;&#125;<span class="hljs-keyword">return</span> (candidateConstructors.length &gt; <span class="hljs-number">0</span> ? candidateConstructors : <span class="hljs-keyword">null</span>);&#125;</code></pre></li><li><p>autowireConstructor()方法中会获取@Autowired的参数，过程中会触发getBean()方法，此时的getBean()方法可能是从缓存中获取。获取到参数后使用反射创建实例并包装为BeanWrapperImpl后返回。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> BeanWrapper <span class="hljs-title">autowireConstructor</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd,</span></span><span class="hljs-function"><span class="hljs-params">@Nullable Constructor&lt;?&gt;[] chosenCtors, @Nullable Object[] explicitArgs)</span> </span>&#123;BeanWrapperImpl bw = <span class="hljs-keyword">new</span> BeanWrapperImpl();<span class="hljs-comment">//忽略可以不看，设置类型转换器，注册自定义编辑器</span><span class="hljs-keyword">this</span>.beanFactory.initBeanWrapper(bw);Constructor&lt;?&gt; constructorToUse = <span class="hljs-keyword">null</span>;ArgumentsHolder argsHolderToUse = <span class="hljs-keyword">null</span>;Object[] argsToUse = <span class="hljs-keyword">null</span>;<span class="hljs-keyword">if</span> (explicitArgs != <span class="hljs-keyword">null</span>) &#123;argsToUse = explicitArgs;&#125;<span class="hljs-keyword">else</span> &#123;Object[] argsToResolve = <span class="hljs-keyword">null</span>;<span class="hljs-keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;constructorToUse = (Constructor&lt;?&gt;) mbd.resolvedConstructorOrFactoryMethod;<span class="hljs-keyword">if</span> (constructorToUse != <span class="hljs-keyword">null</span> &amp;&amp; mbd.constructorArgumentsResolved) &#123;<span class="hljs-comment">// Found a cached constructor...</span>argsToUse = mbd.resolvedConstructorArguments;<span class="hljs-keyword">if</span> (argsToUse == <span class="hljs-keyword">null</span>) &#123;argsToResolve = mbd.preparedConstructorArguments;&#125;&#125;&#125;<span class="hljs-keyword">if</span> (argsToResolve != <span class="hljs-keyword">null</span>) &#123;argsToUse = resolvePreparedArguments(beanName, mbd, bw, constructorToUse, argsToResolve, <span class="hljs-keyword">true</span>);&#125;&#125;<span class="hljs-keyword">if</span> (constructorToUse == <span class="hljs-keyword">null</span> || argsToUse == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">// Take specified constructors, if any.</span>Constructor&lt;?&gt;[] candidates = chosenCtors;<span class="hljs-keyword">if</span> (candidates == <span class="hljs-keyword">null</span>) &#123;Class&lt;?&gt; beanClass = mbd.getBeanClass();<span class="hljs-keyword">try</span> &#123;candidates = (mbd.isNonPublicAccessAllowed() ?beanClass.getDeclaredConstructors() : beanClass.getConstructors());&#125;<span class="hljs-keyword">catch</span> (Throwable ex) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,<span class="hljs-string">"Resolution of declared constructors on bean Class ["</span> + beanClass.getName() +<span class="hljs-string">"] from ClassLoader ["</span> + beanClass.getClassLoader() + <span class="hljs-string">"] failed"</span>, ex);&#125;&#125;<span class="hljs-comment">//mbd.hasConstructorArgumentValues()这个是false的，因为是@Autowired的构造函数，不是&lt;constructor-arg&gt;标签</span><span class="hljs-keyword">if</span> (candidates.length == <span class="hljs-number">1</span> &amp;&amp; explicitArgs == <span class="hljs-keyword">null</span> &amp;&amp; !mbd.hasConstructorArgumentValues()) &#123;Constructor&lt;?&gt; uniqueCandidate = candidates[<span class="hljs-number">0</span>];<span class="hljs-comment">//如果是无参构造函数</span><span class="hljs-keyword">if</span> (uniqueCandidate.getParameterCount() == <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;mbd.resolvedConstructorOrFactoryMethod = uniqueCandidate;mbd.constructorArgumentsResolved = <span class="hljs-keyword">true</span>;mbd.resolvedConstructorArguments = EMPTY_ARGS;&#125;bw.setBeanInstance(instantiate(beanName, mbd, uniqueCandidate, EMPTY_ARGS));<span class="hljs-keyword">return</span> bw;&#125;&#125;<span class="hljs-comment">// Need to resolve the constructor.</span><span class="hljs-keyword">boolean</span> autowiring = (chosenCtors != <span class="hljs-keyword">null</span> ||mbd.getResolvedAutowireMode() == AutowireCapableBeanFactory.AUTOWIRE_CONSTRUCTOR);ConstructorArgumentValues resolvedValues = <span class="hljs-keyword">null</span>;<span class="hljs-keyword">int</span> minNrOfArgs;<span class="hljs-keyword">if</span> (explicitArgs != <span class="hljs-keyword">null</span>) &#123;minNrOfArgs = explicitArgs.length;&#125;<span class="hljs-keyword">else</span> &#123;ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();resolvedValues = <span class="hljs-keyword">new</span> ConstructorArgumentValues();minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);&#125;AutowireUtils.sortConstructors(candidates);<span class="hljs-keyword">int</span> minTypeDiffWeight = Integer.MAX_VALUE;Set&lt;Constructor&lt;?&gt;&gt; ambiguousConstructors = <span class="hljs-keyword">null</span>;LinkedList&lt;UnsatisfiedDependencyException&gt; causes = <span class="hljs-keyword">null</span>;<span class="hljs-keyword">for</span> (Constructor&lt;?&gt; candidate : candidates) &#123;<span class="hljs-comment">//获取到构造函数的参数类型</span>Class&lt;?&gt;[] paramTypes = candidate.getParameterTypes();<span class="hljs-keyword">if</span> (constructorToUse != <span class="hljs-keyword">null</span> &amp;&amp; argsToUse != <span class="hljs-keyword">null</span> &amp;&amp; argsToUse.length &gt; paramTypes.length) &#123;<span class="hljs-comment">// Already found greedy constructor that can be satisfied -&gt;</span><span class="hljs-comment">// do not look any further, there are only less greedy constructors left.</span><span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">if</span> (paramTypes.length &lt; minNrOfArgs) &#123;<span class="hljs-keyword">continue</span>;&#125;ArgumentsHolder argsHolder;<span class="hljs-keyword">if</span> (resolvedValues != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">try</span> &#123;String[] paramNames = ConstructorPropertiesChecker.evaluate(candidate, paramTypes.length);<span class="hljs-keyword">if</span> (paramNames == <span class="hljs-keyword">null</span>) &#123;ParameterNameDiscoverer pnd = <span class="hljs-keyword">this</span>.beanFactory.getParameterNameDiscoverer();<span class="hljs-keyword">if</span> (pnd != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//获取构造函数中参数的名称</span>paramNames = pnd.getParameterNames(candidate);&#125;&#125;<span class="hljs-comment">//获取到参数的值，建议不要看，比较深，主流程弄懂后再去细细打磨</span>argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames,getUserDeclaredConstructor(candidate), autowiring, candidates.length == <span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">catch</span> (UnsatisfiedDependencyException ex) &#123;<span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;logger.trace(<span class="hljs-string">"Ignoring constructor ["</span> + candidate + <span class="hljs-string">"] of bean '"</span> + beanName + <span class="hljs-string">"': "</span> + ex);&#125;<span class="hljs-comment">// Swallow and try next constructor.</span><span class="hljs-keyword">if</span> (causes == <span class="hljs-keyword">null</span>) &#123;causes = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();&#125;causes.add(ex);<span class="hljs-keyword">continue</span>;&#125;&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// Explicit arguments given -&gt; arguments length must match exactly.</span><span class="hljs-keyword">if</span> (paramTypes.length != explicitArgs.length) &#123;<span class="hljs-keyword">continue</span>;&#125;argsHolder = <span class="hljs-keyword">new</span> ArgumentsHolder(explicitArgs);&#125;<span class="hljs-keyword">int</span> typeDiffWeight = (mbd.isLenientConstructorResolution() ?argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));<span class="hljs-comment">// Choose this constructor if it represents the closest match.</span><span class="hljs-keyword">if</span> (typeDiffWeight &lt; minTypeDiffWeight) &#123;constructorToUse = candidate;argsHolderToUse = argsHolder;argsToUse = argsHolder.arguments;minTypeDiffWeight = typeDiffWeight;ambiguousConstructors = <span class="hljs-keyword">null</span>;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (constructorToUse != <span class="hljs-keyword">null</span> &amp;&amp; typeDiffWeight == minTypeDiffWeight) &#123;<span class="hljs-keyword">if</span> (ambiguousConstructors == <span class="hljs-keyword">null</span>) &#123;ambiguousConstructors = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;();ambiguousConstructors.add(constructorToUse);&#125;ambiguousConstructors.add(candidate);&#125;&#125;<span class="hljs-keyword">if</span> (constructorToUse == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">if</span> (causes != <span class="hljs-keyword">null</span>) &#123;UnsatisfiedDependencyException ex = causes.removeLast();<span class="hljs-keyword">for</span> (Exception cause : causes) &#123;<span class="hljs-keyword">this</span>.beanFactory.onSuppressedException(cause);&#125;<span class="hljs-keyword">throw</span> ex;&#125;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,<span class="hljs-string">"Could not resolve matching constructor "</span> +<span class="hljs-string">"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities)"</span>);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ambiguousConstructors != <span class="hljs-keyword">null</span> &amp;&amp; !mbd.isLenientConstructorResolution()) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,<span class="hljs-string">"Ambiguous constructor matches found in bean '"</span> + beanName + <span class="hljs-string">"' "</span> +<span class="hljs-string">"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): "</span> +ambiguousConstructors);&#125;<span class="hljs-keyword">if</span> (explicitArgs == <span class="hljs-keyword">null</span> &amp;&amp; argsHolderToUse != <span class="hljs-keyword">null</span>) &#123;argsHolderToUse.storeCache(mbd, constructorToUse);&#125;&#125;Assert.state(argsToUse != <span class="hljs-keyword">null</span>, <span class="hljs-string">"Unresolved constructor arguments"</span>);<span class="hljs-comment">//有参构造函数的实例化，反射实例化</span>bw.setBeanInstance(instantiate(beanName, mbd, constructorToUse, argsToUse));<span class="hljs-keyword">return</span> bw;&#125;</code></pre></li></ol><h3 id="applyMergedBeanDefinitionPostProcessors-方法"><a href="#applyMergedBeanDefinitionPostProcessors-方法" class="headerlink" title="applyMergedBeanDefinitionPostProcessors()方法"></a>applyMergedBeanDefinitionPostProcessors()方法</h3><ol><li><p>applyMergedBeanDefinitionPostProcessors()方法会拿到所有的BeanPostProcessor接口，然后调用MergedBeanDefinitionPostProcessor接口的postProcessMergedBeanDefinition()方法完成注解的收集。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">applyMergedBeanDefinitionPostProcessors</span><span class="hljs-params">(RootBeanDefinition mbd, Class&lt;?&gt; beanType, String beanName)</span> </span>&#123;<span class="hljs-keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;<span class="hljs-keyword">if</span> (bp <span class="hljs-keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;MergedBeanDefinitionPostProcessor bdp = (MergedBeanDefinitionPostProcessor) bp;bdp.postProcessMergedBeanDefinition(mbd, beanType, beanName);&#125;&#125;&#125;</code></pre></li><li><p>CommonAnnotationBeanPostProcessor的postProcessMergedBeanDefinition()方法会调用InitDestroyAnnotationBeanPostProcessor的postProcessMergedBeanDefinition()方法完成@postConstruct跟@PreDestory()注解的扫描，然后调用findResourceMetadata()扫描@Resource注解。</p><pre><code class="hljs reasonml">public void post<span class="hljs-constructor">ProcessMergedBeanDefinition(RootBeanDefinition <span class="hljs-params">beanDefinition</span>, Class&lt;?&gt; <span class="hljs-params">beanType</span>, String <span class="hljs-params">beanName</span>)</span> &#123;<span class="hljs-comment">//扫描@PostConstruct @PreDestroy</span>super.post<span class="hljs-constructor">ProcessMergedBeanDefinition(<span class="hljs-params">beanDefinition</span>, <span class="hljs-params">beanType</span>, <span class="hljs-params">beanName</span>)</span>;<span class="hljs-comment">//扫描@Resource,扫描属性和方法上面是否有@Resource注解，如果有则收集起来封装成对象</span>InjectionMetadata metadata = find<span class="hljs-constructor">ResourceMetadata(<span class="hljs-params">beanName</span>, <span class="hljs-params">beanType</span>, <span class="hljs-params">null</span>)</span>;metadata.check<span class="hljs-constructor">ConfigMembers(<span class="hljs-params">beanDefinition</span>)</span>;&#125;</code></pre></li><li><p>InitDestroyAnnotationBeanPostProcessor的postProcessMergedBeanDefinition()方法会调用findLifecycleMetadata()方法，然后再次封装其返回的LifecycleMetadata对象。buildLifecycleMetadata()是findLifecycleMetadata()的核心方法，会循环判断类中的所有方法是否有@postConstruct跟@PreDestory()注解，如果有就将这个方法放到容器中，最后包装为LifecycleMetadata并返回。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> LifecycleMetadata <span class="hljs-title">buildLifecycleMetadata</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Class&lt;?&gt; clazz)</span> </span>&#123;List&lt;LifecycleElement&gt; initMethods = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();List&lt;LifecycleElement&gt; destroyMethods = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();Class&lt;?&gt; targetClass = clazz;   <span class="hljs-keyword">do</span> &#123;<span class="hljs-keyword">final</span> List&lt;LifecycleElement&gt; currInitMethods = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<span class="hljs-keyword">final</span> List&lt;LifecycleElement&gt; currDestroyMethods = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();   ReflectionUtils.doWithLocalMethods(targetClass, method -&gt; &#123;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.initAnnotationType != <span class="hljs-keyword">null</span> &amp;&amp; method.isAnnotationPresent(<span class="hljs-keyword">this</span>.initAnnotationType)) &#123;LifecycleElement element = <span class="hljs-keyword">new</span> LifecycleElement(method);currInitMethods.add(element);<span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;logger.trace(<span class="hljs-string">"Found init method on class ["</span> + clazz.getName() + <span class="hljs-string">"]: "</span> + method);&#125;&#125;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.destroyAnnotationType != <span class="hljs-keyword">null</span> &amp;&amp; method.isAnnotationPresent(<span class="hljs-keyword">this</span>.destroyAnnotationType)) &#123;currDestroyMethods.add(<span class="hljs-keyword">new</span> LifecycleElement(method));<span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;logger.trace(<span class="hljs-string">"Found destroy method on class ["</span> + clazz.getName() + <span class="hljs-string">"]: "</span> + method);&#125;&#125;&#125;);   initMethods.addAll(<span class="hljs-number">0</span>, currInitMethods);destroyMethods.addAll(currDestroyMethods);targetClass = targetClass.getSuperclass();&#125;<span class="hljs-keyword">while</span> (targetClass != <span class="hljs-keyword">null</span> &amp;&amp; targetClass != Object<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LifecycleMetadata(clazz, initMethods, destroyMethods);&#125;</code></pre></li><li><p>findResourceMetadata()方法会调用buildResourceMetadata()方法获取包装后的InjectionMetadata，放入缓存后返回。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> InjectionMetadata <span class="hljs-title">findResourceMetadata</span><span class="hljs-params">(String beanName, <span class="hljs-keyword">final</span> Class&lt;?&gt; clazz, @Nullable PropertyValues pvs)</span> </span>&#123;<span class="hljs-comment">// Fall back to class name as cache key, for backwards compatibility with custom callers.</span>String cacheKey = (StringUtils.hasLength(beanName) ? beanName : clazz.getName());<span class="hljs-comment">// Quick check on the concurrent map first, with minimal locking.</span>InjectionMetadata metadata = <span class="hljs-keyword">this</span>.injectionMetadataCache.get(cacheKey);<span class="hljs-keyword">if</span> (InjectionMetadata.needsRefresh(metadata, clazz)) &#123;<span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.injectionMetadataCache) &#123;metadata = <span class="hljs-keyword">this</span>.injectionMetadataCache.get(cacheKey);<span class="hljs-keyword">if</span> (InjectionMetadata.needsRefresh(metadata, clazz)) &#123;<span class="hljs-keyword">if</span> (metadata != <span class="hljs-keyword">null</span>) &#123;metadata.clear(pvs);&#125;<span class="hljs-comment">//主要看这个方法</span>metadata = buildResourceMetadata(clazz);<span class="hljs-keyword">this</span>.injectionMetadataCache.put(cacheKey, metadata);&#125;&#125;&#125;<span class="hljs-keyword">return</span> metadata;&#125;</code></pre></li><li><p>buildResourceMetadata()方法会去获取类上的所有属性，然后循环调用lambda中的内容放到容器中，最后封装为InjectionMetadata对象后返回。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> InjectionMetadata <span class="hljs-title">buildResourceMetadata</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Class&lt;?&gt; clazz)</span> </span>&#123;List&lt;InjectionMetadata.InjectedElement&gt; elements = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();Class&lt;?&gt; targetClass = clazz;   <span class="hljs-keyword">do</span> &#123;<span class="hljs-keyword">final</span> List&lt;InjectionMetadata.InjectedElement&gt; currElements = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();   ReflectionUtils.doWithLocalFields(targetClass, field -&gt; &#123;<span class="hljs-keyword">if</span> (webServiceRefClass != <span class="hljs-keyword">null</span> &amp;&amp; field.isAnnotationPresent(webServiceRefClass)) &#123;<span class="hljs-keyword">if</span> (Modifier.isStatic(field.getModifiers())) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"@WebServiceRef annotation is not supported on static fields"</span>);&#125;currElements.add(<span class="hljs-keyword">new</span> WebServiceRefElement(field, field, <span class="hljs-keyword">null</span>));&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ejbRefClass != <span class="hljs-keyword">null</span> &amp;&amp; field.isAnnotationPresent(ejbRefClass)) &#123;<span class="hljs-keyword">if</span> (Modifier.isStatic(field.getModifiers())) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"@EJB annotation is not supported on static fields"</span>);&#125;currElements.add(<span class="hljs-keyword">new</span> EjbRefElement(field, field, <span class="hljs-keyword">null</span>));&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (field.isAnnotationPresent(Resource<span class="hljs-class">.<span class="hljs-keyword">class</span>)) </span>&#123;<span class="hljs-keyword">if</span> (Modifier.isStatic(field.getModifiers())) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"@Resource annotation is not supported on static fields"</span>);&#125;<span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.ignoredResourceTypes.contains(field.getType().getName())) &#123;currElements.add(<span class="hljs-keyword">new</span> ResourceElement(field, field, <span class="hljs-keyword">null</span>));&#125;&#125;&#125;);   ReflectionUtils.doWithLocalMethods(targetClass, method -&gt; &#123;Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);<span class="hljs-keyword">if</span> (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) &#123;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">if</span> (method.equals(ClassUtils.getMostSpecificMethod(method, clazz))) &#123;<span class="hljs-keyword">if</span> (webServiceRefClass != <span class="hljs-keyword">null</span> &amp;&amp; bridgedMethod.isAnnotationPresent(webServiceRefClass)) &#123;<span class="hljs-keyword">if</span> (Modifier.isStatic(method.getModifiers())) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"@WebServiceRef annotation is not supported on static methods"</span>);&#125;<span class="hljs-keyword">if</span> (method.getParameterCount() != <span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"@WebServiceRef annotation requires a single-arg method: "</span> + method);&#125;PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz);currElements.add(<span class="hljs-keyword">new</span> WebServiceRefElement(method, bridgedMethod, pd));&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ejbRefClass != <span class="hljs-keyword">null</span> &amp;&amp; bridgedMethod.isAnnotationPresent(ejbRefClass)) &#123;<span class="hljs-keyword">if</span> (Modifier.isStatic(method.getModifiers())) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"@EJB annotation is not supported on static methods"</span>);&#125;<span class="hljs-keyword">if</span> (method.getParameterCount() != <span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"@EJB annotation requires a single-arg method: "</span> + method);&#125;PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz);currElements.add(<span class="hljs-keyword">new</span> EjbRefElement(method, bridgedMethod, pd));&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bridgedMethod.isAnnotationPresent(Resource<span class="hljs-class">.<span class="hljs-keyword">class</span>)) </span>&#123;<span class="hljs-keyword">if</span> (Modifier.isStatic(method.getModifiers())) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"@Resource annotation is not supported on static methods"</span>);&#125;Class&lt;?&gt;[] paramTypes = method.getParameterTypes();<span class="hljs-keyword">if</span> (paramTypes.length != <span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"@Resource annotation requires a single-arg method: "</span> + method);&#125;<span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.ignoredResourceTypes.contains(paramTypes[<span class="hljs-number">0</span>].getName())) &#123;PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz);currElements.add(<span class="hljs-keyword">new</span> ResourceElement(method, bridgedMethod, pd));&#125;&#125;&#125;&#125;);   elements.addAll(<span class="hljs-number">0</span>, currElements);targetClass = targetClass.getSuperclass();&#125;<span class="hljs-keyword">while</span> (targetClass != <span class="hljs-keyword">null</span> &amp;&amp; targetClass != Object<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> InjectionMetadata(clazz, elements);&#125;</code></pre></li></ol><p>注：其他类型的BeanPostProcessor收集过程与InitDestroyAnnotationBeanPostProcessor基本相同，只是扫描的注解不同，此处不在赘述。</p><h3 id="populateBean-方法"><a href="#populateBean-方法" class="headerlink" title="populateBean()方法"></a>populateBean()方法</h3><ol><li><p>依赖注入的核心方法，主要方法为postProcessProperties()，依据applyMergedBeanDefinitionPostProcessors收集的注解进行依赖注入。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">populateBean</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw)</span> </span>&#123;<span class="hljs-keyword">if</span> (bw == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">if</span> (mbd.hasPropertyValues()) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="hljs-string">"Cannot apply property values to null instance"</span>);&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// Skip property population phase for null instance.</span><span class="hljs-keyword">return</span>;&#125;&#125;   <span class="hljs-comment">// Give any InstantiationAwareBeanPostProcessors the opportunity to modify the</span><span class="hljs-comment">// state of the bean before properties are set. This can be used, for example,</span><span class="hljs-comment">// to support styles of field injection.</span><span class="hljs-keyword">boolean</span> continueWithPropertyPopulation = <span class="hljs-keyword">true</span>;   <span class="hljs-comment">//这里很有意思，写接口可以让所有类都不能依赖注入</span><span class="hljs-keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;<span class="hljs-keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;<span class="hljs-keyword">if</span> (bp <span class="hljs-keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;<span class="hljs-keyword">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;   <span class="hljs-comment">//是否需要DI，依赖注入</span>continueWithPropertyPopulation = <span class="hljs-keyword">false</span>;<span class="hljs-keyword">break</span>;&#125;&#125;&#125;&#125;   <span class="hljs-keyword">if</span> (!continueWithPropertyPopulation) &#123;<span class="hljs-keyword">return</span>;&#125;   PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : <span class="hljs-keyword">null</span>);   <span class="hljs-keyword">if</span> (mbd.getResolvedAutowireMode() == AUTOWIRE_BY_NAME || mbd.getResolvedAutowireMode() == AUTOWIRE_BY_TYPE) &#123;MutablePropertyValues newPvs = <span class="hljs-keyword">new</span> MutablePropertyValues(pvs);<span class="hljs-comment">// Add property values based on autowire by name if applicable.</span><span class="hljs-keyword">if</span> (mbd.getResolvedAutowireMode() == AUTOWIRE_BY_NAME) &#123;autowireByName(beanName, mbd, bw, newPvs);&#125;<span class="hljs-comment">// Add property values based on autowire by type if applicable.</span><span class="hljs-keyword">if</span> (mbd.getResolvedAutowireMode() == AUTOWIRE_BY_TYPE) &#123;autowireByType(beanName, mbd, bw, newPvs);&#125;pvs = newPvs;&#125;   <span class="hljs-keyword">boolean</span> hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();<span class="hljs-keyword">boolean</span> needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);   PropertyDescriptor[] filteredPds = <span class="hljs-keyword">null</span>;   <span class="hljs-comment">//重点看这个if代码块，重要程度 5</span><span class="hljs-keyword">if</span> (hasInstAwareBpps) &#123;<span class="hljs-keyword">if</span> (pvs == <span class="hljs-keyword">null</span>) &#123;pvs = mbd.getPropertyValues();&#125;<span class="hljs-keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;<span class="hljs-keyword">if</span> (bp <span class="hljs-keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;<span class="hljs-comment">//依赖注入过程，@Autowired的支持</span>PropertyValues pvsToUse = ibp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);<span class="hljs-keyword">if</span> (pvsToUse == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">if</span> (filteredPds == <span class="hljs-keyword">null</span>) &#123;filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);&#125;   <span class="hljs-comment">//老版本用这个完成依赖注入过程，@Autowired的支持</span>pvsToUse = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);<span class="hljs-keyword">if</span> (pvsToUse == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">return</span>;&#125;&#125;pvs = pvsToUse;&#125;&#125;&#125;<span class="hljs-keyword">if</span> (needsDepCheck) &#123;<span class="hljs-keyword">if</span> (filteredPds == <span class="hljs-keyword">null</span>) &#123;filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);&#125;checkDependencies(beanName, mbd, filteredPds, pvs);&#125;   <span class="hljs-comment">//这个方法很鸡肋了，建议不看，是老版本用&lt;property name="username" value="Jack"/&gt;</span><span class="hljs-comment">//标签做依赖注入的代码实现，复杂且无用</span><span class="hljs-keyword">if</span> (pvs != <span class="hljs-keyword">null</span>) &#123;applyPropertyValues(beanName, mbd, bw, pvs);&#125;&#125;</code></pre></li><li><p>AutowiredAnnotationBeanPostProcessor的postProcessProperties()方法。该方法首先从缓存中获取之前收集好的所有InjectionMetadata对象，然后调用循环调用inject()方法进行注入。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> PropertyValues <span class="hljs-title">postProcessProperties</span><span class="hljs-params">(PropertyValues pvs, Object bean, String beanName)</span> </span>&#123;   <span class="hljs-comment">// 从缓存中获取InjectionMetadata对象</span>InjectionMetadata metadata = findAutowiringMetadata(beanName, bean.getClass(), pvs);<span class="hljs-keyword">try</span> &#123;metadata.inject(bean, beanName, pvs);&#125;<span class="hljs-keyword">catch</span> (BeanCreationException ex) &#123;<span class="hljs-keyword">throw</span> ex;&#125;<span class="hljs-keyword">catch</span> (Throwable ex) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(beanName, <span class="hljs-string">"Injection of autowired dependencies failed"</span>, ex);&#125;<span class="hljs-keyword">return</span> pvs;&#125;</code></pre></li><li><p>此处为inject()方法，先从spring容器中拿到参数对应的值，这时可能会触发实例化，然后通过反射完成对象的注入。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inject</span><span class="hljs-params">(Object bean, @Nullable String beanName, @Nullable PropertyValues pvs)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;Field field = (Field) <span class="hljs-keyword">this</span>.member;Object value;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.cached) &#123;value = resolvedCachedArgument(beanName, <span class="hljs-keyword">this</span>.cachedFieldValue);&#125;<span class="hljs-keyword">else</span> &#123;DependencyDescriptor desc = <span class="hljs-keyword">new</span> DependencyDescriptor(field, <span class="hljs-keyword">this</span>.required);desc.setContainingClass(bean.getClass());Set&lt;String&gt; autowiredBeanNames = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(<span class="hljs-number">1</span>);Assert.state(beanFactory != <span class="hljs-keyword">null</span>, <span class="hljs-string">"No BeanFactory available"</span>);TypeConverter typeConverter = beanFactory.getTypeConverter();<span class="hljs-keyword">try</span> &#123;value = beanFactory.resolveDependency(desc, beanName, autowiredBeanNames, typeConverter);&#125;<span class="hljs-keyword">catch</span> (BeansException ex) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsatisfiedDependencyException(<span class="hljs-keyword">null</span>, beanName, <span class="hljs-keyword">new</span> InjectionPoint(field), ex);&#125;<span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.cached) &#123;<span class="hljs-keyword">if</span> (value != <span class="hljs-keyword">null</span> || <span class="hljs-keyword">this</span>.required) &#123;<span class="hljs-keyword">this</span>.cachedFieldValue = desc;registerDependentBeans(beanName, autowiredBeanNames);<span class="hljs-keyword">if</span> (autowiredBeanNames.size() == <span class="hljs-number">1</span>) &#123;String autowiredBeanName = autowiredBeanNames.iterator().next();<span class="hljs-keyword">if</span> (beanFactory.containsBean(autowiredBeanName) &amp;&amp;beanFactory.isTypeMatch(autowiredBeanName, field.getType())) &#123;<span class="hljs-keyword">this</span>.cachedFieldValue = <span class="hljs-keyword">new</span> ShortcutDependencyDescriptor(desc, autowiredBeanName, field.getType());&#125;&#125;&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">this</span>.cachedFieldValue = <span class="hljs-keyword">null</span>;&#125;<span class="hljs-keyword">this</span>.cached = <span class="hljs-keyword">true</span>;&#125;&#125;&#125;<span class="hljs-keyword">if</span> (value != <span class="hljs-keyword">null</span>) &#123;ReflectionUtils.makeAccessible(field);field.set(bean, value);&#125;&#125;&#125;</code></pre></li></ol><p>注：其他类的postProcessProperties与此处基本相同。</p><h3 id="initializeBean-方法"><a href="#initializeBean-方法" class="headerlink" title="initializeBean()方法"></a>initializeBean()方法</h3><ol><li><p>initializeBean()方法是BeanDefinition实例化完成后的操作。首先会使用applyBeanPostProcessorsBeforeInitialization()方法对@PostConstruct，Aware接口进行调用，然后使用invokeInitMethods()接口，完成对InitializingBean接口的afterPropertiesSet()方法、BeanDefination中init-method对应方法的调用。这些注解在applyMergedBeanDefinitionPostProcessors()方法中已经被收集并封装为Metadata对象。applyBeanPostProcessorsAfterInitialization()方法是aop入口类，在之后会有详细分析。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">initializeBean</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String beanName, <span class="hljs-keyword">final</span> Object bean, @Nullable RootBeanDefinition mbd)</span> </span>&#123;<span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-keyword">null</span>) &#123;AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;invokeAwareMethods(beanName, bean);<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;, getAccessControlContext());&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//调用Aware方法</span>invokeAwareMethods(beanName, bean);&#125;   Object wrappedBean = bean;<span class="hljs-keyword">if</span> (mbd == <span class="hljs-keyword">null</span> || !mbd.isSynthetic()) &#123;<span class="hljs-comment">//对类中某些特殊方法的调用，比如@PostConstruct，Aware接口，非常重要 重要程度 ：5</span>wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);&#125;   <span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//InitializingBean接口，afterPropertiesSet，init-method属性调用,非常重要，重要程度：5</span>invokeInitMethods(beanName, wrappedBean, mbd);&#125;<span class="hljs-keyword">catch</span> (Throwable ex) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException((mbd != <span class="hljs-keyword">null</span> ? mbd.getResourceDescription() : <span class="hljs-keyword">null</span>),beanName, <span class="hljs-string">"Invocation of init method failed"</span>, ex);&#125;<span class="hljs-keyword">if</span> (mbd == <span class="hljs-keyword">null</span> || !mbd.isSynthetic()) &#123;wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);&#125;   <span class="hljs-keyword">return</span> wrappedBean;&#125;</code></pre></li><li><p>applyBeanPostProcessorsBeforeInitialization()方法</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">applyBeanPostProcessorsBeforeInitialization</span><span class="hljs-params">(Object existingBean, String beanName)</span></span><span class="hljs-function"><span class="hljs-keyword">throws</span> BeansException </span>&#123;   Object result = existingBean;<span class="hljs-comment">/*</span><span class="hljs-comment">* 着重看几个</span><span class="hljs-comment">* 1、ApplicationContextAwareProcessor  对某个Aware接口方法的调用</span><span class="hljs-comment">* 2、InitDestroyAnnotationBeanPostProcessor  @PostConstruct注解方法的调用</span><span class="hljs-comment">*</span><span class="hljs-comment">* 3、ImportAwareBeanPostProcessor  对ImportAware类型实例setImportMetadata调用</span><span class="hljs-comment">* 这个对理解springboot有很大帮助。 这里暂时不需要深入看</span><span class="hljs-comment">* */</span><span class="hljs-keyword">for</span> (BeanPostProcessor processor : getBeanPostProcessors()) &#123;Object current = processor.postProcessBeforeInitialization(result, beanName);<span class="hljs-keyword">if</span> (current == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">return</span> result;&#125;result = current;&#125;<span class="hljs-keyword">return</span> result;&#125;</code></pre></li><li><p>InitDestroyAnnotationBeanPostProcessor的postProcessBeforeInitialization()方法会通过反射调用metadata中的方法，此处被调用的方法不能有任何参数。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;LifecycleMetadata metadata = findLifecycleMetadata(bean.getClass());<span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//调用@PostConstruct注解的方法</span>metadata.invokeInitMethods(bean, beanName);&#125;<span class="hljs-keyword">catch</span> (InvocationTargetException ex) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(beanName, <span class="hljs-string">"Invocation of init method failed"</span>, ex.getTargetException());&#125;<span class="hljs-keyword">catch</span> (Throwable ex) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(beanName, <span class="hljs-string">"Failed to invoke init method"</span>, ex);&#125;<span class="hljs-keyword">return</span> bean;&#125;</code></pre></li><li><p>invokeInitMethods()方法首先会判断bean是否实现了InitializingBean接口，如果是就直接通过反射调用该接口的afterPropertiesSet()方法。然后会通过invokeCustomInitMethod()方法调用initMethod()方法方法。如果要在Bean实例化之后去做一些事情可以实现InitializingBean接口，比如缓存预热，注册到注册中心等，Mybatis中xml的解析也是用了该接口。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeInitMethods</span><span class="hljs-params">(String beanName, <span class="hljs-keyword">final</span> Object bean, @Nullable RootBeanDefinition mbd)</span></span><span class="hljs-function"><span class="hljs-keyword">throws</span> Throwable </span>&#123;   <span class="hljs-keyword">boolean</span> isInitializingBean = (bean <span class="hljs-keyword">instanceof</span> InitializingBean);<span class="hljs-keyword">if</span> (isInitializingBean &amp;&amp; (mbd == <span class="hljs-keyword">null</span> || !mbd.isExternallyManagedInitMethod(<span class="hljs-string">"afterPropertiesSet"</span>))) &#123;<span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;logger.trace(<span class="hljs-string">"Invoking afterPropertiesSet() on bean with name '"</span> + beanName + <span class="hljs-string">"'"</span>);&#125;<span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">try</span> &#123;AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) () -&gt; &#123;((InitializingBean) bean).afterPropertiesSet();<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;, getAccessControlContext());&#125;<span class="hljs-keyword">catch</span> (PrivilegedActionException pae) &#123;<span class="hljs-keyword">throw</span> pae.getException();&#125;&#125;<span class="hljs-keyword">else</span> &#123;((InitializingBean) bean).afterPropertiesSet();&#125;&#125;   <span class="hljs-keyword">if</span> (mbd != <span class="hljs-keyword">null</span> &amp;&amp; bean.getClass() != NullBean<span class="hljs-class">.<span class="hljs-keyword">class</span>) </span>&#123;String initMethodName = mbd.getInitMethodName();<span class="hljs-keyword">if</span> (StringUtils.hasLength(initMethodName) &amp;&amp;!(isInitializingBean &amp;&amp; <span class="hljs-string">"afterPropertiesSet"</span>.equals(initMethodName)) &amp;&amp;!mbd.isExternallyManagedInitMethod(initMethodName)) &#123;invokeCustomInitMethod(beanName, bean, mbd);&#125;&#125;&#125;</code></pre></li></ol><h3 id="registerDisposableBeanIfNecessary-方法"><a href="#registerDisposableBeanIfNecessary-方法" class="headerlink" title="registerDisposableBeanIfNecessary()方法"></a>registerDisposableBeanIfNecessary()方法</h3><p>该方法首先会将需要销毁的Bean包装为DisposableBeanAdapter对象，然后通过registerDisposableBean()方法放入disposableBeans容器中。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerDisposableBeanIfNecessary</span><span class="hljs-params">(String beanName, Object bean, RootBeanDefinition mbd)</span> </span>&#123;AccessControlContext acc = (System.getSecurityManager() != <span class="hljs-keyword">null</span> ? getAccessControlContext() : <span class="hljs-keyword">null</span>);<span class="hljs-keyword">if</span> (!mbd.isPrototype() &amp;&amp; requiresDestruction(bean, mbd)) &#123;<span class="hljs-keyword">if</span> (mbd.isSingleton()) &#123;<span class="hljs-comment">// Register a DisposableBean implementation that performs all destruction</span><span class="hljs-comment">// work for the given bean: DestructionAwareBeanPostProcessors,</span><span class="hljs-comment">// DisposableBean interface, custom destroy method.</span>registerDisposableBean(beanName,<span class="hljs-keyword">new</span> DisposableBeanAdapter(bean, beanName, mbd, getBeanPostProcessors(), acc));&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// A bean with a custom scope...</span>Scope scope = <span class="hljs-keyword">this</span>.scopes.get(mbd.getScope());<span class="hljs-keyword">if</span> (scope == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"No Scope registered for scope name '"</span> + mbd.getScope() + <span class="hljs-string">"'"</span>);&#125;scope.registerDestructionCallback(beanName,<span class="hljs-keyword">new</span> DisposableBeanAdapter(bean, beanName, mbd, getBeanPostProcessors(), acc));&#125;&#125;&#125;</code></pre><p>DisposableBeanAdapter的构造方法。该方法首先会拿到类的destory-method属性，然后通过filterPostProcessors()方法获取到DestructionAwareBeanPostProcessor类型的BeanPostProcessor。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DisposableBeanAdapter</span><span class="hljs-params">(Object bean, String beanName, RootBeanDefinition beanDefinition,</span></span><span class="hljs-function"><span class="hljs-params">List&lt;BeanPostProcessor&gt; postProcessors, @Nullable AccessControlContext acc)</span> </span>&#123;Assert.notNull(bean, <span class="hljs-string">"Disposable bean must not be null"</span>);<span class="hljs-keyword">this</span>.bean = bean;<span class="hljs-keyword">this</span>.beanName = beanName;<span class="hljs-keyword">this</span>.invokeDisposableBean =(<span class="hljs-keyword">this</span>.bean <span class="hljs-keyword">instanceof</span> DisposableBean &amp;&amp; !beanDefinition.isExternallyManagedDestroyMethod(<span class="hljs-string">"destroy"</span>));<span class="hljs-keyword">this</span>.nonPublicAccessAllowed = beanDefinition.isNonPublicAccessAllowed();<span class="hljs-keyword">this</span>.acc = acc;String destroyMethodName = inferDestroyMethodIfNecessary(bean, beanDefinition);<span class="hljs-keyword">if</span> (destroyMethodName != <span class="hljs-keyword">null</span> &amp;&amp; !(<span class="hljs-keyword">this</span>.invokeDisposableBean &amp;&amp; <span class="hljs-string">"destroy"</span>.equals(destroyMethodName)) &amp;&amp;!beanDefinition.isExternallyManagedDestroyMethod(destroyMethodName)) &#123;<span class="hljs-keyword">this</span>.destroyMethodName = destroyMethodName;<span class="hljs-keyword">this</span>.destroyMethod = determineDestroyMethod(destroyMethodName);<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.destroyMethod == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">if</span> (beanDefinition.isEnforceDestroyMethod()) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanDefinitionValidationException(<span class="hljs-string">"Could not find a destroy method named '"</span> +destroyMethodName + <span class="hljs-string">"' on bean with name '"</span> + beanName + <span class="hljs-string">"'"</span>);&#125;&#125;<span class="hljs-keyword">else</span> &#123;Class&lt;?&gt;[] paramTypes = <span class="hljs-keyword">this</span>.destroyMethod.getParameterTypes();<span class="hljs-keyword">if</span> (paramTypes.length &gt; <span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanDefinitionValidationException(<span class="hljs-string">"Method '"</span> + destroyMethodName + <span class="hljs-string">"' of bean '"</span> +beanName + <span class="hljs-string">"' has more than one parameter - not supported as destroy method"</span>);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (paramTypes.length == <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-keyword">boolean</span><span class="hljs-class">.<span class="hljs-keyword">class</span> !</span>= paramTypes[<span class="hljs-number">0</span>]) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanDefinitionValidationException(<span class="hljs-string">"Method '"</span> + destroyMethodName + <span class="hljs-string">"' of bean '"</span> +beanName + <span class="hljs-string">"' has a non-boolean parameter - not supported as destroy method"</span>);&#125;&#125;&#125;<span class="hljs-keyword">this</span>.beanPostProcessors = filterPostProcessors(postProcessors, bean);&#125;</code></pre><p>destory()方法首先会调用BeanPostProcessor接口的postProcessBeforeDestruction()方法，然后调用DisposableBean接口的distory()方法，再通过反射调用destory-method属性设置的方法。这个方法一般由tomcat中servlet规范中的ContextLoaderListener.contextDestroyed()方法触发。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">if</span> (!CollectionUtils.isEmpty(<span class="hljs-keyword">this</span>.beanPostProcessors)) &#123;<span class="hljs-keyword">for</span> (DestructionAwareBeanPostProcessor processor : <span class="hljs-keyword">this</span>.beanPostProcessors) &#123;processor.postProcessBeforeDestruction(<span class="hljs-keyword">this</span>.bean, <span class="hljs-keyword">this</span>.beanName);&#125;&#125;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.invokeDisposableBean) &#123;<span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;logger.trace(<span class="hljs-string">"Invoking destroy() on bean with name '"</span> + <span class="hljs-keyword">this</span>.beanName + <span class="hljs-string">"'"</span>);&#125;<span class="hljs-keyword">try</span> &#123;<span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-keyword">null</span>) &#123;AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) () -&gt; &#123;((DisposableBean) <span class="hljs-keyword">this</span>.bean).destroy();<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;, <span class="hljs-keyword">this</span>.acc);&#125;<span class="hljs-keyword">else</span> &#123;((DisposableBean) <span class="hljs-keyword">this</span>.bean).destroy();&#125;&#125;<span class="hljs-keyword">catch</span> (Throwable ex) &#123;String msg = <span class="hljs-string">"Invocation of destroy method failed on bean with name '"</span> + <span class="hljs-keyword">this</span>.beanName + <span class="hljs-string">"'"</span>;<span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;logger.info(msg, ex);&#125;<span class="hljs-keyword">else</span> &#123;logger.info(msg + <span class="hljs-string">": "</span> + ex);&#125;&#125;&#125;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.destroyMethod != <span class="hljs-keyword">null</span>) &#123;invokeCustomDestroyMethod(<span class="hljs-keyword">this</span>.destroyMethod);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.destroyMethodName != <span class="hljs-keyword">null</span>) &#123;Method methodToCall = determineDestroyMethod(<span class="hljs-keyword">this</span>.destroyMethodName);<span class="hljs-keyword">if</span> (methodToCall != <span class="hljs-keyword">null</span>) &#123;invokeCustomDestroyMethod(methodToCall);&#125;&#125;&#125;</code></pre><h2 id="单实例循环依赖"><a href="#单实例循环依赖" class="headerlink" title="单实例循环依赖"></a>单实例循环依赖</h2><p><a href="https://www.processon.com/view/link/5df9ce52e4b0c4255ea1a84f" target="_blank" rel="noopener">循环依赖流程图</a></p><p>单例实例无参构造函数的循环依赖是可以解决的，但如果是参构造函数@Autowired 的方式造成的循环依赖会直接报错，多例的循环依赖也是直接报错。</p><p>doGetBean()方法的再分析。在调用doGetBean()方法获取实例时，在该方法中会尝试通过getSingleton(beanName)方法从缓存中获取实例，如果没有会通过getSingleton()的重载方法创建实例。</p><pre><code class="hljs java"><span class="hljs-keyword">protected</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">doGetBean</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String name, @Nullable <span class="hljs-keyword">final</span> Class&lt;T&gt; requiredType,</span></span><span class="hljs-function"><span class="hljs-params">@Nullable <span class="hljs-keyword">final</span> Object[] args, <span class="hljs-keyword">boolean</span> typeCheckOnly)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<span class="hljs-keyword">final</span> String beanName = transformedBeanName(name);Object bean;<span class="hljs-comment">//从缓存中拿实例</span><span class="hljs-comment">// Eagerly check singleton cache for manually registered singletons.</span>Object sharedInstance = getSingleton(beanName);<span class="hljs-comment">//如果缓存里面能拿到实例</span><span class="hljs-keyword">if</span> (sharedInstance != <span class="hljs-keyword">null</span> &amp;&amp; args == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<span class="hljs-keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;logger.trace(<span class="hljs-string">"Returning eagerly cached instance of singleton bean '"</span> + beanName +<span class="hljs-string">"' that is not fully initialized yet - a consequence of a circular reference"</span>);&#125;<span class="hljs-keyword">else</span> &#123;logger.trace(<span class="hljs-string">"Returning cached instance of singleton bean '"</span> + beanName + <span class="hljs-string">"'"</span>);&#125;&#125;<span class="hljs-comment">//改方法是FactoryBean接口的调用入口</span>bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="hljs-keyword">null</span>);&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//如果singletonObjects缓存里面没有，则走下来</span><span class="hljs-comment">// Fail if we're already creating this bean instance:</span><span class="hljs-comment">// We're assumably within a circular reference.</span><span class="hljs-comment">//如果是scope 是Prototype的，校验是否有出现循环依赖，如果有则直接报错</span><span class="hljs-keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCurrentlyInCreationException(beanName);&#125;<span class="hljs-comment">// Check if bean definition exists in this factory.</span>BeanFactory parentBeanFactory = getParentBeanFactory();<span class="hljs-keyword">if</span> (parentBeanFactory != <span class="hljs-keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;<span class="hljs-comment">// Not found -&gt; check parent.</span>String nameToLookup = originalBeanName(name);<span class="hljs-keyword">if</span> (parentBeanFactory <span class="hljs-keyword">instanceof</span> AbstractBeanFactory) &#123;<span class="hljs-keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(nameToLookup, requiredType, args, typeCheckOnly);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (args != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">// Delegation to parent with explicit args.</span><span class="hljs-keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (requiredType != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">// No args -&gt; delegate to standard getBean method.</span><span class="hljs-keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup);&#125;&#125;<span class="hljs-keyword">if</span> (!typeCheckOnly) &#123;markBeanAsCreated(beanName);&#125;<span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//父子BeanDefinition合并</span><span class="hljs-keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);checkMergedBeanDefinition(mbd, beanName, args);<span class="hljs-comment">//获取依赖对象属性，依赖对象要先实例化</span><span class="hljs-comment">// Guarantee initialization of beans that the current bean depends on.</span>String[] dependsOn = mbd.getDependsOn();<span class="hljs-keyword">if</span> (dependsOn != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">for</span> (String dep : dependsOn) &#123;<span class="hljs-keyword">if</span> (isDependent(beanName, dep)) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,<span class="hljs-string">"Circular depends-on relationship between '"</span> + beanName + <span class="hljs-string">"' and '"</span> + dep + <span class="hljs-string">"'"</span>);&#125;registerDependentBean(dep, beanName);<span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//实例化</span>getBean(dep);&#125;<span class="hljs-keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,<span class="hljs-string">"'"</span> + beanName + <span class="hljs-string">"' depends on missing bean '"</span> + dep + <span class="hljs-string">"'"</span>, ex);&#125;&#125;&#125;<span class="hljs-comment">//着重看，大部分是单例的情况</span><span class="hljs-comment">// Create bean instance.</span><span class="hljs-keyword">if</span> (mbd.isSingleton()) &#123;sharedInstance = getSingleton(beanName, () -&gt; &#123;<span class="hljs-keyword">try</span> &#123;<span class="hljs-keyword">return</span> createBean(beanName, mbd, args);&#125;<span class="hljs-keyword">catch</span> (BeansException ex) &#123;<span class="hljs-comment">// Explicitly remove instance from singleton cache: It might have been put there</span><span class="hljs-comment">// eagerly by the creation process, to allow for circular reference resolution.</span><span class="hljs-comment">// Also remove any beans that received a temporary reference to the bean.</span>destroySingleton(beanName);<span class="hljs-keyword">throw</span> ex;&#125;&#125;);<span class="hljs-comment">//该方法是FactoryBean接口的调用入口</span>bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mbd.isPrototype()) &#123;<span class="hljs-comment">// It's a prototype -&gt; create a new instance.</span>Object prototypeInstance = <span class="hljs-keyword">null</span>;<span class="hljs-keyword">try</span> &#123;beforePrototypeCreation(beanName);prototypeInstance = createBean(beanName, mbd, args);&#125;<span class="hljs-keyword">finally</span> &#123;afterPrototypeCreation(beanName);&#125;<span class="hljs-comment">//该方法是FactoryBean接口的调用入口</span>bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);&#125;<span class="hljs-keyword">else</span> &#123;String scopeName = mbd.getScope();<span class="hljs-keyword">final</span> Scope scope = <span class="hljs-keyword">this</span>.scopes.get(scopeName);<span class="hljs-keyword">if</span> (scope == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"No Scope registered for scope name '"</span> + scopeName + <span class="hljs-string">"'"</span>);&#125;<span class="hljs-keyword">try</span> &#123;Object scopedInstance = scope.get(beanName, () -&gt; &#123;beforePrototypeCreation(beanName);<span class="hljs-keyword">try</span> &#123;<span class="hljs-keyword">return</span> createBean(beanName, mbd, args);&#125;<span class="hljs-keyword">finally</span> &#123;afterPrototypeCreation(beanName);&#125;&#125;);<span class="hljs-comment">//该方法是FactoryBean接口的调用入口</span>bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);&#125;<span class="hljs-keyword">catch</span> (IllegalStateException ex) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(beanName,<span class="hljs-string">"Scope '"</span> + scopeName + <span class="hljs-string">"' is not active for the current thread; consider "</span> +<span class="hljs-string">"defining a scoped proxy for this bean if you intend to refer to it from a singleton"</span>,ex);&#125;&#125;&#125;<span class="hljs-keyword">catch</span> (BeansException ex) &#123;cleanupAfterBeanCreationFailure(beanName);<span class="hljs-keyword">throw</span> ex;&#125;&#125;<span class="hljs-comment">// Check if required type matches the type of the actual bean instance.</span><span class="hljs-keyword">if</span> (requiredType != <span class="hljs-keyword">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;<span class="hljs-keyword">try</span> &#123;T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);<span class="hljs-keyword">if</span> (convertedBean == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());&#125;<span class="hljs-keyword">return</span> convertedBean;&#125;<span class="hljs-keyword">catch</span> (TypeMismatchException ex) &#123;<span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;logger.trace(<span class="hljs-string">"Failed to convert bean '"</span> + name + <span class="hljs-string">"' to required type '"</span> +ClassUtils.getQualifiedName(requiredType) + <span class="hljs-string">"'"</span>, ex);&#125;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());&#125;&#125;<span class="hljs-keyword">return</span> (T) bean;&#125;</code></pre><p>getSingleton()方法，该方法用于从缓存中获取实例，会按照一级缓存、二级缓存、三级缓存的顺序获取，再从三级缓存中获取实例后，会将实例放到二级缓存并删除三级缓存。一级缓存中的bean是完成实例化，IOC、DI注入的，三级缓存中时仅仅执行完构造方法，还没有对属性进行赋值操作的bean，二级缓存中的bean与三级缓存相同，二级缓存存在的意义是为了提升效率。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">getSingleton</span><span class="hljs-params">(String beanName, <span class="hljs-keyword">boolean</span> allowEarlyReference)</span> </span>&#123;<span class="hljs-comment">//根据beanName从缓存中拿实例</span><span class="hljs-comment">//先从一级缓存拿</span>Object singletonObject = <span class="hljs-keyword">this</span>.singletonObjects.get(beanName);<span class="hljs-comment">//如果bean还正在创建，还没创建完成，其实就是堆内存有了，属性还没有DI依赖注入</span><span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;<span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.singletonObjects) &#123;<span class="hljs-comment">//从二级缓存中拿</span>singletonObject = <span class="hljs-keyword">this</span>.earlySingletonObjects.get(beanName);<span class="hljs-comment">//如果还拿不到，并且允许bean提前暴露</span><span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-keyword">null</span> &amp;&amp; allowEarlyReference) &#123;<span class="hljs-comment">//从三级缓存中拿到对象工厂</span>ObjectFactory&lt;?&gt; singletonFactory = <span class="hljs-keyword">this</span>.singletonFactories.get(beanName);<span class="hljs-keyword">if</span> (singletonFactory != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//从工厂中拿到对象</span>singletonObject = singletonFactory.getObject();<span class="hljs-comment">//升级到二级缓存</span><span class="hljs-keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);<span class="hljs-comment">//删除三级缓存</span><span class="hljs-keyword">this</span>.singletonFactories.remove(beanName);&#125;&#125;&#125;&#125;<span class="hljs-keyword">return</span> singletonObject;&#125;</code></pre><p>重载的getSingleton()方法，该方法在创建Bean之前会将beanName添加到singletonsCurrentlyInCreation容器中，如果容器中已有该beanName会直接报错，然后通过singletonFactory.getObject()方法创建实例，如果有返回值，就表示实例已经完成创建，再从容器中删除beanName，创建完成后调用addSingleton()方法放入一级缓存。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getSingleton</span><span class="hljs-params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;Assert.notNull(beanName, <span class="hljs-string">"Bean name must not be null"</span>);<span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.singletonObjects) &#123;<span class="hljs-comment">//如果缓存中有，则直接返回</span>Object singletonObject = <span class="hljs-keyword">this</span>.singletonObjects.get(beanName);<span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.singletonsCurrentlyInDestruction) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationNotAllowedException(beanName,<span class="hljs-string">"Singleton bean creation not allowed while singletons of this factory are in destruction "</span> +<span class="hljs-string">"(Do not request a bean from a BeanFactory in a destroy method implementation!)"</span>);&#125;<span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;logger.debug(<span class="hljs-string">"Creating shared instance of singleton bean '"</span> + beanName + <span class="hljs-string">"'"</span>);&#125;<span class="hljs-comment">//把beanName添加到singletonsCurrentlyInCreation Set容器中，在这个集合里面的bean都是正在实例化的bean</span>beforeSingletonCreation(beanName);<span class="hljs-keyword">boolean</span> newSingleton = <span class="hljs-keyword">false</span>;<span class="hljs-keyword">boolean</span> recordSuppressedExceptions = (<span class="hljs-keyword">this</span>.suppressedExceptions == <span class="hljs-keyword">null</span>);<span class="hljs-keyword">if</span> (recordSuppressedExceptions) &#123;<span class="hljs-keyword">this</span>.suppressedExceptions = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;();&#125;<span class="hljs-keyword">try</span> &#123;singletonObject = singletonFactory.getObject();newSingleton = <span class="hljs-keyword">true</span>;&#125;<span class="hljs-keyword">catch</span> (IllegalStateException ex) &#123;<span class="hljs-comment">// Has the singleton object implicitly appeared in the meantime -&gt;</span><span class="hljs-comment">// if yes, proceed with it since the exception indicates that state.</span>singletonObject = <span class="hljs-keyword">this</span>.singletonObjects.get(beanName);<span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">throw</span> ex;&#125;&#125;<span class="hljs-keyword">catch</span> (BeanCreationException ex) &#123;<span class="hljs-keyword">if</span> (recordSuppressedExceptions) &#123;<span class="hljs-keyword">for</span> (Exception suppressedException : <span class="hljs-keyword">this</span>.suppressedExceptions) &#123;ex.addRelatedCause(suppressedException);&#125;&#125;<span class="hljs-keyword">throw</span> ex;&#125;<span class="hljs-keyword">finally</span> &#123;<span class="hljs-keyword">if</span> (recordSuppressedExceptions) &#123;<span class="hljs-keyword">this</span>.suppressedExceptions = <span class="hljs-keyword">null</span>;&#125;<span class="hljs-comment">//bean创建完成后singletonsCurrentlyInCreation要删除该bean</span>afterSingletonCreation(beanName);&#125;<span class="hljs-keyword">if</span> (newSingleton) &#123;<span class="hljs-comment">//创建对象成功时，把对象缓存到singletonObjects缓存中,bean创建完成时放入一级缓存</span>addSingleton(beanName, singletonObject);&#125;&#125;<span class="hljs-keyword">return</span> singletonObject;&#125;</code></pre><p>addSington()方法，该方法在实例创建后会将实例放入一级缓存，并删除二级、三级缓存中的实例。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addSingleton</span><span class="hljs-params">(String beanName, Object singletonObject)</span> </span>&#123;<span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.singletonObjects) &#123;<span class="hljs-comment">//一级缓存</span><span class="hljs-keyword">this</span>.singletonObjects.put(beanName, singletonObject);<span class="hljs-comment">//三级缓存</span><span class="hljs-keyword">this</span>.singletonFactories.remove(beanName);<span class="hljs-comment">//二级缓存</span><span class="hljs-keyword">this</span>.earlySingletonObjects.remove(beanName);<span class="hljs-keyword">this</span>.registeredSingletons.add(beanName);&#125;&#125;</code></pre><p>singletonFactory.getObject()方法会回调到doCreateBean()方法，该方法完成实例的构造函数后创建实例后，会判断类是否需要提前暴露，如果需要会调用addSingletonFactory()方法将正在创建的bean添加到三级缓存，注意此时注解装配已经完成，但对注解的IOC、DI等操作还未开始。addSingletonFactory()方法会调用到getEarlyBeanReference()方法获取完成实例化的bean。判断bean是否正在创建的方法为判断beanName在singletonsCurrentlyInCreation中是否存在。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">doCreateBean</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String beanName, <span class="hljs-keyword">final</span> RootBeanDefinition mbd, <span class="hljs-keyword">final</span> @Nullable Object[] args)</span></span><span class="hljs-function"><span class="hljs-keyword">throws</span> BeanCreationException </span>&#123;<span class="hljs-comment">// Instantiate the bean.</span>BeanWrapper instanceWrapper = <span class="hljs-keyword">null</span>;<span class="hljs-keyword">if</span> (mbd.isSingleton()) &#123;instanceWrapper = <span class="hljs-keyword">this</span>.factoryBeanInstanceCache.remove(beanName);&#125;<span class="hljs-keyword">if</span> (instanceWrapper == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//创建实例 重点看 重要程度：5</span>instanceWrapper = createBeanInstance(beanName, mbd, args);&#125;<span class="hljs-keyword">final</span> Object bean = instanceWrapper.getWrappedInstance();Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();<span class="hljs-keyword">if</span> (beanType != NullBean<span class="hljs-class">.<span class="hljs-keyword">class</span>) </span>&#123;mbd.resolvedTargetType = beanType;&#125;<span class="hljs-comment">// Allow post-processors to modify the merged bean definition.</span><span class="hljs-keyword">synchronized</span> (mbd.postProcessingLock) &#123;<span class="hljs-keyword">if</span> (!mbd.postProcessed) &#123;<span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//CommonAnnotationBeanPostProcessor  支持了@PostConstruct，@PreDestroy,@Resource注解</span><span class="hljs-comment">//AutowiredAnnotationBeanPostProcessor 支持 @Autowired,@Value注解</span><span class="hljs-comment">//BeanPostProcessor接口的典型运用，这里要理解这个接口</span><span class="hljs-comment">//对类中注解的装配过程</span><span class="hljs-comment">//重要程度5，必须看</span>applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);&#125;<span class="hljs-keyword">catch</span> (Throwable ex) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,<span class="hljs-string">"Post-processing of merged bean definition failed"</span>, ex);&#125;mbd.postProcessed = <span class="hljs-keyword">true</span>;&#125;&#125;<span class="hljs-comment">// Eagerly cache singletons to be able to resolve circular references</span><span class="hljs-comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span><span class="hljs-comment">//是否单例bean提前暴露</span><span class="hljs-keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="hljs-keyword">this</span>.allowCircularReferences &amp;&amp;isSingletonCurrentlyInCreation(beanName));<span class="hljs-keyword">if</span> (earlySingletonExposure) &#123;<span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;logger.trace(<span class="hljs-string">"Eagerly caching bean '"</span> + beanName +<span class="hljs-string">"' to allow for resolving potential circular references"</span>);&#125;<span class="hljs-comment">//这里着重理解，对理解循环依赖帮助非常大，重要程度 5   添加三级缓存</span>addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));&#125;<span class="hljs-comment">// Initialize the bean instance.</span>Object exposedObject = bean;<span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//ioc di，依赖注入的核心方法，该方法必须看，重要程度：5</span>populateBean(beanName, mbd, instanceWrapper);<span class="hljs-comment">//bean 实例化+ioc依赖注入完以后的调用，非常重要，重要程度：5</span>exposedObject = initializeBean(beanName, exposedObject, mbd);&#125;<span class="hljs-keyword">catch</span> (Throwable ex) &#123;<span class="hljs-keyword">if</span> (ex <span class="hljs-keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;<span class="hljs-keyword">throw</span> (BeanCreationException) ex;&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="hljs-string">"Initialization of bean failed"</span>, ex);&#125;&#125;<span class="hljs-keyword">if</span> (earlySingletonExposure) &#123;Object earlySingletonReference = getSingleton(beanName, <span class="hljs-keyword">false</span>);<span class="hljs-keyword">if</span> (earlySingletonReference != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">if</span> (exposedObject == bean) &#123;exposedObject = earlySingletonReference;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;String[] dependentBeans = getDependentBeans(beanName);Set&lt;String&gt; actualDependentBeans = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(dependentBeans.length);<span class="hljs-keyword">for</span> (String dependentBean : dependentBeans) &#123;<span class="hljs-keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;actualDependentBeans.add(dependentBean);&#125;&#125;<span class="hljs-keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCurrentlyInCreationException(beanName,<span class="hljs-string">"Bean with name '"</span> + beanName + <span class="hljs-string">"' has been injected into other beans ["</span> +StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +<span class="hljs-string">"] in its raw version as part of a circular reference, but has eventually been "</span> +<span class="hljs-string">"wrapped. This means that said other beans do not use the final version of the "</span> +<span class="hljs-string">"bean. This is often the result of over-eager type matching - consider using "</span> +<span class="hljs-string">"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example."</span>);&#125;&#125;&#125;&#125;<span class="hljs-comment">// Register bean as disposable.</span><span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//注册bean销毁时的类DisposableBeanAdapter</span>registerDisposableBeanIfNecessary(beanName, bean, mbd);&#125;<span class="hljs-keyword">catch</span> (BeanDefinitionValidationException ex) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="hljs-string">"Invalid destruction signature"</span>, ex);&#125;<span class="hljs-keyword">return</span> exposedObject;&#125;</code></pre><p>getEarlyBeanReference()会将刚执行完构造函数，还没有进行属性设置的类返回。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">getEarlyBeanReference</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, Object bean)</span> </span>&#123;Object exposedObject = bean;<span class="hljs-keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;<span class="hljs-keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;<span class="hljs-keyword">if</span> (bp <span class="hljs-keyword">instanceof</span> SmartInstantiationAwareBeanPostProcessor) &#123;SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);&#125;&#125;&#125;<span class="hljs-keyword">return</span> exposedObject;&#125;</code></pre><p>循环依赖步骤:</p><ol><li>A类无参构造函数实例化后，设置三级缓存。</li><li>A类进行依赖注入，调用B类的getBean()操作。</li><li>B类无参构造函数实例化后，设置三级缓存。</li><li>B类依赖注入，再次触发了A类getBean()操作。</li><li>B类拿到了A的三级缓存中的实例并注入。</li><li>B类的实例化完成，由于B类的初始化是A类调用getBean()完成的，B类完成实例化后会返回给A类。</li><li>A类获取到B类，完成依赖注入。</li></ol><p>看完上面的流程后，对于有参构造函数中的@Autowired造成的循环依赖直接报错的原因就显而易见了。如果A类在执行有@Autowired注解的构造函数时需要注入B类，B类的构造函数中也使用@Autowired要求注入A类，那么在调用A的构造函数时会触发B类的初始化。而要处理B类构造函数的@Autowired就需要获取A的实例，就会再次触发A类的getBean()，但此时A的构造函数还没有完成，通过三级缓存是拿不到A类的，所以会再次触发getSingleton往singletonsCurrentlyInCreation中放入beanName，但由于在上面执行A的构造函数之前就已经往singletonsCurrentlyInCreation放入了A类的beanName，此时再次放入会直接报错。</p><h2 id="FactoryBean接口"><a href="#FactoryBean接口" class="headerlink" title="FactoryBean接口"></a>FactoryBean接口</h2><p>该接口主要是在BeanFactory完成实例化后，创建交给Spring管理的、可以用于@Autowired注解的对象。注意此时根据beanName获取的是BeanFactory接口创建的实例，如果要获取BeanFactory接口的实例需要在BeanName前加上&amp;符号。</p><p>getObjectForBeanInstance()方法用于对该接口的支持，如果beanName不是以&amp;开头，并且beanInstance是FactoryBean类型，就会从缓存里面拿FactoryBean类型的实例，然后调用getObjectFromFactoryBean()方法创建实例。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">getObjectForBeanInstance</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">Object beanInstance, String name, String beanName, @Nullable RootBeanDefinition mbd)</span> </span>&#123;<span class="hljs-comment">// Don't let calling code try to dereference the factory if the bean isn't a factory.</span><span class="hljs-keyword">if</span> (BeanFactoryUtils.isFactoryDereference(name)) &#123;<span class="hljs-keyword">if</span> (beanInstance <span class="hljs-keyword">instanceof</span> NullBean) &#123;<span class="hljs-keyword">return</span> beanInstance;&#125;<span class="hljs-keyword">if</span> (!(beanInstance <span class="hljs-keyword">instanceof</span> FactoryBean)) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanIsNotAFactoryException(transformedBeanName(name), beanInstance.getClass());&#125;&#125;<span class="hljs-comment">// Now we have the bean instance, which may be a normal bean or a FactoryBean.</span><span class="hljs-comment">// If it's a FactoryBean, we use it to create a bean instance, unless the</span><span class="hljs-comment">// caller actually wants a reference to the factory.</span><span class="hljs-comment">//如果实例不是FactoryBean类型的，或者name是以&amp;号开头的，则直接返回实例</span><span class="hljs-keyword">if</span> (!(beanInstance <span class="hljs-keyword">instanceof</span> FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) &#123;<span class="hljs-keyword">return</span> beanInstance;&#125;<span class="hljs-comment">//如果代码能走下来，则说明 beanName不是以&amp;开头，并且beanInstance是FactoryBean类型的</span>Object object = <span class="hljs-keyword">null</span>;<span class="hljs-keyword">if</span> (mbd == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//从缓存里面拿FactoryBean类型的实例</span>object = getCachedObjectForFactoryBean(beanName);&#125;<span class="hljs-keyword">if</span> (object == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">// Return bean instance from factory.</span>FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance;<span class="hljs-comment">// Caches object obtained from FactoryBean if it is a singleton.</span><span class="hljs-keyword">if</span> (mbd == <span class="hljs-keyword">null</span> &amp;&amp; containsBeanDefinition(beanName)) &#123;mbd = getMergedLocalBeanDefinition(beanName);&#125;<span class="hljs-keyword">boolean</span> synthetic = (mbd != <span class="hljs-keyword">null</span> &amp;&amp; mbd.isSynthetic());<span class="hljs-comment">//重点看</span>object = getObjectFromFactoryBean(factory, beanName, !synthetic);&#125;<span class="hljs-keyword">return</span> object;&#125;</code></pre><p>getObjectFromFactoryBean()方法会调用FactoryBean接口的getObject()方法获取实例，然后将创建的对象会放入factoryBeanObjectCache容器中，而不是一级缓存的容器。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">getObjectFromFactoryBean</span><span class="hljs-params">(FactoryBean&lt;?&gt; factory, String beanName, <span class="hljs-keyword">boolean</span> shouldPostProcess)</span> </span>&#123;<span class="hljs-keyword">if</span> (factory.isSingleton() &amp;&amp; containsSingleton(beanName)) &#123;<span class="hljs-keyword">synchronized</span> (getSingletonMutex()) &#123;Object object = <span class="hljs-keyword">this</span>.factoryBeanObjectCache.get(beanName);<span class="hljs-keyword">if</span> (object == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//调用getObject方法</span>object = doGetObjectFromFactoryBean(factory, beanName);<span class="hljs-comment">// Only post-process and store if not put there already during getObject() call above</span><span class="hljs-comment">// (e.g. because of circular reference processing triggered by custom getBean calls)</span>Object alreadyThere = <span class="hljs-keyword">this</span>.factoryBeanObjectCache.get(beanName);<span class="hljs-keyword">if</span> (alreadyThere != <span class="hljs-keyword">null</span>) &#123;object = alreadyThere;&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span> (shouldPostProcess) &#123;<span class="hljs-keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;<span class="hljs-comment">// Temporarily return non-post-processed object, not storing it yet..</span><span class="hljs-keyword">return</span> object;&#125;beforeSingletonCreation(beanName);<span class="hljs-keyword">try</span> &#123;object = postProcessObjectFromFactoryBean(object, beanName);&#125;<span class="hljs-keyword">catch</span> (Throwable ex) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(beanName,<span class="hljs-string">"Post-processing of FactoryBean's singleton object failed"</span>, ex);&#125;<span class="hljs-keyword">finally</span> &#123;afterSingletonCreation(beanName);&#125;&#125;<span class="hljs-keyword">if</span> (containsSingleton(beanName)) &#123;<span class="hljs-comment">//把实例缓存到factoryBeanObjectCache map中，这个是单独缓存FactoryBean类型实例的map</span><span class="hljs-keyword">this</span>.factoryBeanObjectCache.put(beanName, object);&#125;&#125;&#125;<span class="hljs-keyword">return</span> object;&#125;&#125;<span class="hljs-keyword">else</span> &#123;Object object = doGetObjectFromFactoryBean(factory, beanName);<span class="hljs-keyword">if</span> (shouldPostProcess) &#123;<span class="hljs-keyword">try</span> &#123;object = postProcessObjectFromFactoryBean(object, beanName);&#125;<span class="hljs-keyword">catch</span> (Throwable ex) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(beanName, <span class="hljs-string">"Post-processing of FactoryBean's object failed"</span>, ex);&#125;&#125;<span class="hljs-keyword">return</span> object;&#125;&#125;</code></pre><h2 id="BeanPostProcessor接口"><a href="#BeanPostProcessor接口" class="headerlink" title="BeanPostProcessor接口"></a>BeanPostProcessor接口</h2><p>BeanPostProcessor接口类型实例是针对某种特定功能的埋点，在这个点会根据接口类型来过滤掉不关注这个点的其他类，只有真正关注的类才会在这个点进行相应的功能实现。在使用时通常会拿到所有的BeanPostProcessor接口，然后循环根据BeanPostProcessor接口的类型进行过滤，或者直接调用对应的方法，如果该BeanPostProcessor接口不关注这个点，对应的方法中就没有相应的实现。</p><h3 id="获取有-Autowired注解的构造函数埋点"><a href="#获取有-Autowired注解的构造函数埋点" class="headerlink" title="获取有@Autowired注解的构造函数埋点"></a>获取有@Autowired注解的构造函数埋点</h3><p>doCreateBean()初始化Bean实例时，用于创建Bean实例的createBeanInstance()方法中，会调用determineConstructorsFromBeanPostProcessors()方法获得有@Autowired注解的构造方法。</p><pre><code class="hljs reasonml"><span class="hljs-comment">// Candidate constructors for autowiring?</span><span class="hljs-comment">//寻找当前正在实例化的bean中有@Autowired注解的构造函数</span>Constructor&lt;?&gt;<span class="hljs-literal">[]</span> ctors = determine<span class="hljs-constructor">ConstructorsFromBeanPostProcessors(<span class="hljs-params">beanClass</span>, <span class="hljs-params">beanName</span>)</span>;<span class="hljs-keyword">if</span> (ctors != null<span class="hljs-operator"> || </span>mbd.get<span class="hljs-constructor">ResolvedAutowireMode()</span><span class="hljs-operator"> == </span>AUTOWIRE_CONSTRUCTOR <span class="hljs-pattern-match"><span class="hljs-operator">||</span></span><span class="hljs-pattern-match">mbd.has<span class="hljs-constructor">ConstructorArgumentValues()</span> <span class="hljs-operator">||</span> !<span class="hljs-constructor">ObjectUtils</span>.is<span class="hljs-constructor">Empty(<span class="hljs-params">args</span>)</span>) &#123;</span><span class="hljs-pattern-match"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>如果ctors不为空，就说明构造函数上有@<span class="hljs-constructor">Autowired</span>注解</span><span class="hljs-pattern-match">return autowire<span class="hljs-constructor">Constructor(<span class="hljs-params">beanName</span>, <span class="hljs-params">mbd</span>, <span class="hljs-params">ctors</span>, <span class="hljs-params">args</span>)</span>;</span><span class="hljs-pattern-match">&#125;</span></code></pre><p>这里过滤的接口类型是SmartInstantiationAwareBeanPostProcessor，调用的方法是determineCandidateConstructors()。</p><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Constructor&lt;?&gt;[] determineConstructorsFromBeanPostProcessors(<span class="hljs-meta">@Nullable</span> Class&lt;?&gt; beanClass, String beanName)<span class="hljs-keyword">throws</span> BeansException &#123;<span class="hljs-keyword">if</span> (beanClass != <span class="hljs-keyword">null</span> &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;<span class="hljs-comment">//获取所有的BeanPostProcessors</span><span class="hljs-keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;<span class="hljs-keyword">if</span> (bp <span class="hljs-keyword">instanceof</span> SmartInstantiationAwareBeanPostProcessor) &#123;SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;<span class="hljs-comment">//找到合适的构造函数</span>Constructor&lt;?&gt;[] ctors = ibp.determineCandidateConstructors(beanClass, beanName);<span class="hljs-keyword">if</span> (ctors != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">return</span> ctors;&#125;&#125;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre><h3 id="收集-Resource、-Autowired、-Value-PostConstruct、-PreDestroy注解的方法和属性埋点"><a href="#收集-Resource、-Autowired、-Value-PostConstruct、-PreDestroy注解的方法和属性埋点" class="headerlink" title="收集@Resource、@Autowired、@Value@PostConstruct、@PreDestroy注解的方法和属性埋点"></a>收集@Resource、@Autowired、@Value@PostConstruct、@PreDestroy注解的方法和属性埋点</h3><p>doCreateBean()进行注解的装配时，会使用applyMergedBeanDefinitionPostProcessors()方法。</p><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (mbd.postProcessingLock) &#123;<span class="hljs-keyword">if</span> (!mbd.postProcessed) &#123;<span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//CommonAnnotationBeanPostProcessor  支持了@PostConstruct，@PreDestroy,@Resource注解</span><span class="hljs-comment">//AutowiredAnnotationBeanPostProcessor 支持 @Autowired,@Value注解</span><span class="hljs-comment">//BeanPostProcessor接口的典型运用，这里要理解这个接口</span><span class="hljs-comment">//对类中注解的装配过程</span><span class="hljs-comment">//重要程度5，必须看</span>applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);&#125;<span class="hljs-keyword">catch</span> (Throwable ex) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,<span class="hljs-string">"Post-processing of merged bean definition failed"</span>, ex);&#125;mbd.postProcessed = <span class="hljs-keyword">true</span>;&#125;&#125;</code></pre><p>过滤的接口类型是MergedBeanDefinitionPostProcessor，调用的方法是postProcessMergedBeanDefinition()。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">applyMergedBeanDefinitionPostProcessors</span><span class="hljs-params">(RootBeanDefinition mbd, Class&lt;?&gt; beanType, String beanName)</span> </span>&#123;<span class="hljs-keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;<span class="hljs-keyword">if</span> (bp <span class="hljs-keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;MergedBeanDefinitionPostProcessor bdp = (MergedBeanDefinitionPostProcessor) bp;bdp.postProcessMergedBeanDefinition(mbd, beanType, beanName);&#125;&#125;&#125;</code></pre><h3 id="循环依赖解决中bean的提前暴露埋点"><a href="#循环依赖解决中bean的提前暴露埋点" class="headerlink" title="循环依赖解决中bean的提前暴露埋点"></a>循环依赖解决中bean的提前暴露埋点</h3><p>doCreateBean()对Bean进行提前暴露时，会调用getEarlyBeanReference()方法获取到Bean实例。</p><pre><code class="hljs java"><span class="hljs-comment">//是否单例bean提前暴露</span><span class="hljs-keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="hljs-keyword">this</span>.allowCircularReferences &amp;&amp;isSingletonCurrentlyInCreation(beanName));<span class="hljs-keyword">if</span> (earlySingletonExposure) &#123;<span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;logger.trace(<span class="hljs-string">"Eagerly caching bean '"</span> + beanName +<span class="hljs-string">"' to allow for resolving potential circular references"</span>);&#125;<span class="hljs-comment">//这里着重理解，对理解循环依赖帮助非常大，重要程度 5   添加三级缓存</span>addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));&#125;</code></pre><p>过滤的接口类型是SmartInstantiationAwareBeanPostProcessor，调用的方法是determineCandidateConstructors()。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">getEarlyBeanReference</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, Object bean)</span> </span>&#123;Object exposedObject = bean;<span class="hljs-keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;<span class="hljs-keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;<span class="hljs-keyword">if</span> (bp <span class="hljs-keyword">instanceof</span> SmartInstantiationAwareBeanPostProcessor) &#123;SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);&#125;&#125;&#125;<span class="hljs-keyword">return</span> exposedObject;&#125;</code></pre><h3 id="阻止依赖注入埋点"><a href="#阻止依赖注入埋点" class="headerlink" title="阻止依赖注入埋点"></a>阻止依赖注入埋点</h3><p>位于doCreateBean()进行依赖注入时，populateBean()方法中。</p><p>过滤的接口类型是InstantiationAwareBeanPostProcessor，调用的方法是postProcessAfterInstantiation。</p><pre><code class="hljs java"><span class="hljs-comment">//这里写接口可以让所有类都不能依赖注入</span><span class="hljs-keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;<span class="hljs-keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;<span class="hljs-keyword">if</span> (bp <span class="hljs-keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;<span class="hljs-keyword">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;<span class="hljs-comment">//是否需要DI，依赖注入</span>continueWithPropertyPopulation = <span class="hljs-keyword">false</span>;<span class="hljs-keyword">break</span>;&#125;&#125;&#125;&#125;</code></pre><h3 id="IOC-DI-依赖注入埋点"><a href="#IOC-DI-依赖注入埋点" class="headerlink" title="IOC/DI 依赖注入埋点"></a>IOC/DI 依赖注入埋点</h3><p>位于doCreateBean()进行依赖注入时，populateBean()方法中。</p><p>过滤的接口类型是InstantiationAwareBeanPostProcessor，调用的方法是postProcessProperties。</p><pre><code class="hljs java"><span class="hljs-comment">//重点看这个if代码块，重要程度 5</span><span class="hljs-keyword">if</span> (hasInstAwareBpps) &#123;<span class="hljs-keyword">if</span> (pvs == <span class="hljs-keyword">null</span>) &#123;pvs = mbd.getPropertyValues();&#125;<span class="hljs-keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;<span class="hljs-keyword">if</span> (bp <span class="hljs-keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;<span class="hljs-comment">//依赖注入过程，@Autowired的支持</span>PropertyValues pvsToUse = ibp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);<span class="hljs-keyword">if</span> (pvsToUse == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">if</span> (filteredPds == <span class="hljs-keyword">null</span>) &#123;filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);&#125;<span class="hljs-comment">//老版本用这个完成依赖注入过程，@Autowired的支持</span>pvsToUse = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);<span class="hljs-keyword">if</span> (pvsToUse == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">return</span>;&#125;&#125;pvs = pvsToUse;&#125;&#125;  &#125;</code></pre><h3 id="Bean销毁的埋点"><a href="#Bean销毁的埋点" class="headerlink" title="Bean销毁的埋点"></a>Bean销毁的埋点</h3><p>位于doGreateBean().registerDisposableBeanIfNecessary()方法中调用DisposableBeanAdapter的构造函数时。用于寻找DestructionAwareBeanPostProcessor类型的BeanPostProcessor。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;DestructionAwareBeanPostProcessor&gt; <span class="hljs-title">filterPostProcessors</span><span class="hljs-params">(List&lt;BeanPostProcessor&gt; processors, Object bean)</span> </span>&#123;List&lt;DestructionAwareBeanPostProcessor&gt; filteredPostProcessors = <span class="hljs-keyword">null</span>;<span class="hljs-keyword">if</span> (!CollectionUtils.isEmpty(processors)) &#123;filteredPostProcessors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(processors.size());<span class="hljs-keyword">for</span> (BeanPostProcessor processor : processors) &#123;<span class="hljs-keyword">if</span> (processor <span class="hljs-keyword">instanceof</span> DestructionAwareBeanPostProcessor) &#123;DestructionAwareBeanPostProcessor dabpp = (DestructionAwareBeanPostProcessor) processor;<span class="hljs-keyword">if</span> (dabpp.requiresDestruction(bean)) &#123;filteredPostProcessors.add(dabpp);&#125;&#125;&#125;&#125;<span class="hljs-keyword">return</span> filteredPostProcessors;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Spring源码解析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>源码解析</tag>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring的初始化入口和xml解析</title>
    <link href="/blog/2020/04/13/spring-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%85%A5%E5%8F%A3%E5%92%8Cxml%E8%A7%A3%E6%9E%90/"/>
    <url>/blog/2020/04/13/spring-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%85%A5%E5%8F%A3%E5%92%8Cxml%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="Spring的历史"><a href="#Spring的历史" class="headerlink" title="Spring的历史"></a>Spring的历史</h2><ul><li><p>2002年10月，Rod Johnso发布《Expert One-on-One J2EE 设计和开发》一书</p></li><li><p>2004 年 3 月，Spring1.0 发布</p><p>2003 年 6 月，Spring Framework 第一次以 Apache 2.0 许可证下发布 0.9 版 本，2004 年 3 月，Spring1.0 正式发布。对于 Spring1.0，其源码只有一个包，在该包中包含了 aop、beans、context、 core、jdbc、orm 等。对于此时的版本，Spring1.0 仅支持 XML 配置的方式。</p></li><li><p>2006 年 10 月，Spring2.0 发布<br>对于 2.0，Spring 主要增加了对注解的支持，实现了基于注解的配置。</p><p>在 2007 年 11 月，发布 Spring2.5，该版本具备的特性有：</p><ul><li><p>添加可扩展的 XML 配置功能，用于简化 XML 配置，</p></li><li><p>支持 Java5</p></li><li><p>添加额外的 IOC 容器扩展点，支持动态语言(如 groovy，aop 增强功能和新 的 bean 范围 )</p></li></ul></li><li><p>2009 年 12 月，Spring3.0 发布</p><p>Spring3.0 主要具有的特性有: </p><ul><li>模块重组系统</li><li>支持 Spring 表达式语言(Spring Expression)</li><li>基于 Java 的 Bean 配置(JavaConfig) 支持嵌入式数据库:HSQL、H2 等 支持 REST</li><li>支持 Java6</li></ul></li><li><p>2013 年 12 月，发布 Spring4.0</p><p>对于 Spring4.0 是 Spring 版本历史上的一重大升级。其特性为: </p><ul><li>全面支持 Java8支持 Lambda 表达式。</li><li>支持 Java8 的时间和日期 API</li><li>支持重复注解</li><li>支持 Java8 的 Optional</li><li>核心容器增强</li><li>增加泛型依赖注入</li><li>增加 Map 依赖注入</li><li>增加 List 依赖注入</li><li>支持 lazy 注解配置懒加载</li><li>支持 Condition 条件注解</li><li>CGLIB 动态代理增强</li><li>支持基于 GroovyDSL 定义 Bean</li><li>Web 增强</li><li>增强 SpringMVC，基于 Servlet3.0 开发</li><li>提供 RestController 注解</li><li>提供 AsyncRestTemplate 支持客户端的异步无阻塞请求</li><li>增加对 WebSocket 的支持</li></ul></li><li><p>2017 年 9 月，Spring5.0 发布</p><p>Spring5.0 特性如下：</p><ul><li>升级到 Java8、JavaEE7</li><li>废弃低版本，将 Java8、JavaEE 7 作为最低版本要求 兼容 Java9、兼容 JavaEE8</li><li>反应式编程模型，增加 WebFlux 模块</li><li>升级 SpringMVC，增加对最新的 API(Jackson 等)的支持 增加函数式编程模式</li><li>重构源码，部分功能使用 Lambda 表达式实现</li></ul></li></ul><h2 id="Spring的子项目"><a href="#Spring的子项目" class="headerlink" title="Spring的子项目"></a>Spring的子项目</h2><ul><li>Spring IO Platform : Spring IO 是可集成的、构建现代化应用的版本平台。Spring IO 是模块化的、企业级的分布式系统，包括一系列依赖，是的开发者仅能对自己所需的部分进行完全的部署控制。</li><li>Spring Boot:Spring 应用快速开发工具，用来简化 Spring 应用开发过程。 </li><li>Spring XD:Spring XD(eXtreme Date，极限数据)是 Pivotal 的大数据产品。它结合了 Spring Boot 和 Grails，组成 Spring IO 平台的执行部分。</li><li>Spring Data:Spring Data 是为了简化构建基于 Spring 框架应用的数据访问实现，包括非关系数据库、Map-Reduce 框架、云数据服务等;另外，也包含对关 系数据库的访问支持。</li><li>Spring Integration:Spring Integration 为企业数据集成提供了各种适配器，可以通过这些适配器来转换各种消息格式，并帮助 Spring 应用完成与企业应用系统的集成。</li><li>Spring Batch:Spring Batch 是一个轻量级的完整批处理框架，旨在帮助应用开发者构建一个健壮、高效的企业级批处理应用(这些应用的特点是不需要与用 户交互，重复的操作量大，对于大容量的批量数据处理而言，这些操作往往要求 较高的可靠性)</li><li>Spring Security:Spring Security 是一个能够为基于 Spring 的企业应用系统提 供声明式的安全访问控制解决方案的安全框架。它提供了一组可以在 Spring 应用 上下文配置的 bean，充分利用 Ioc 和 AOP 功能，为应用系统提供声明式的安全 访问控制功能。</li><li>Spring Hateoas:Spring Hateoas 是一个用户支持实现超文本驱动的 REST Web 服务的开发库，是 Hateoas 的实现。Hateoas(Hypermedia as the engine of application state)是 REST 架构风格中最复杂的约束，也是构建成熟 REST 服务的核 心。它的重要性在于打破了客户端和服务器之间严格的契约，是的客户端可以更加智能和自适应。</li><li>Spring Social:Spring Social 是 Spring 框架的扩展，用来方便开发 Web 社交应用程序，可通过该项目来创建与各种社交网站的交互，如 Facebook，LinkedIn、 Twitter 等。</li><li>Spring AMQP:Spring AMQP 是基于 Spring 框架的 AMQP 消息解决方案，提供 模版化的发送和接收消息的抽象层，提供基于消息驱动的 POJO。这个项目支持 Java和.NET连个版本。Spring Source旗下的Rabbit MQ就是一个开源的基于AMQP 的消息服务器。</li><li>Spring for Android:Spring for Android 为 Android 终端开发应用提供 Spring 的 支持，它提供了一个在 Android 应用环境中工作、基于 Java的REST 客户端。</li><li>Spring Mobile:Spring Mobile 是基于 Spring MVC 构建的，为移动端的服务器 应用开发提供支持。</li><li>Spring Web Flow:Spring Web Flow(SWF)一个建立在 Spring MVC 基础上的 Web 页面流引擎。</li><li>Spring Web Service:Spring Web Service 是基于 Spring 框架的 Web 服务框架， 主要侧重于基于文档驱动的 Web 服务，提供 SOAP 服务开发，允许通过多种方 式创建 Web 服务。</li><li>Spring LDAP:Spring LDAP 是一个用户操作 LDAP 的 Java 框架，类似 Spring JDBC 提供了 JdbcTemplate 方式来操作数据库。这个框架提供了一个 LdapTemplate 操 作模版，可帮助开发人员简化 looking up、closing contexts、encoding/decoding、 filters 等操作。</li><li>Spring Session: Spring Session 致力于提供一个公共基础设施会话，支持从任意环境中访问一个会话，在 Web 环境下支持独立于容器的集群会话，支持可插拔策略来确定 Session ID，WebSocket 活跃的时候可以简单地保持 HttpSession。</li><li>Spring Shell: Spring Shell 提供交互式的 Shell，用户可以简单的基于 Spring 的编程模型来开发命令。</li></ul><h2 id="Spring容器的加载方式"><a href="#Spring容器的加载方式" class="headerlink" title="Spring容器的加载方式"></a>Spring容器的加载方式</h2><ul><li><p>类路径获取配置文件<br>ApplicationContext applicationContext= new ClassPathXmlApplicationContext(“spring.xml”);</p></li><li><p>文件系统路径获取配置文件【绝对路径】<br>ApplicationContext applicationContext = new FileSystemXmlApplicationContext(“E:\idea\public\springdemo\src\main\resou rces\spring.xml”);</p></li><li><p>无配置文件加载容器 ApplicationContext applicationContext = new<br>AnnotationConfigApplicationContext(“com.xx.jack”);</p></li><li><p>springboot 加载容器 ApplicationContext applicationContext = new<br>EmbeddedWebApplicationContext();</p></li></ul><h2 id="Spring容器加载的核心方法"><a href="#Spring容器加载的核心方法" class="headerlink" title="Spring容器加载的核心方法"></a>Spring容器加载的核心方法</h2><p>AbstractApplicationContext.refresh()方法</p><p>refresh()方法是spring容器启动过程中的核心方法，spring容器要加载必须执行该方法。</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">refresh</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException, IllegalStateException </span>&#123;<span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.startupShutdownMonitor) &#123;<span class="hljs-comment">//为容器初始化做准备，重要程度：0</span><span class="hljs-comment">//Prepare this context for refreshing.</span>prepareRefresh();<span class="hljs-comment">/**</span><span class="hljs-comment">* 重要程度：5</span><span class="hljs-comment">* 1、创建BeanFactory对象</span><span class="hljs-comment">* 2、xml解析</span><span class="hljs-comment">* 传统标签解析：bean、import等</span><span class="hljs-comment">* 自定义标签解析 如：&lt;context:component-scan base-package="com.xiangxue.jack"/&gt;</span><span class="hljs-comment">* 自定义标签解析流程：</span><span class="hljs-comment">* a、根据当前解析标签的头信息找到对应的namespaceUri</span><span class="hljs-comment">* b、加载spring所以jar中的spring.handlers文件。并建立映射关系</span><span class="hljs-comment">* c、根据namespaceUri从映射关系中找到对应的实现了NamespaceHandler接口的类</span><span class="hljs-comment">* d、调用类的init方法，init方法是注册了各种自定义标签的解析类</span><span class="hljs-comment">* e、根据namespaceUri找到对应的解析类，然后调用paser方法完成标签解析</span><span class="hljs-comment">*</span><span class="hljs-comment">* 3、把解析出来的xml标签封装成BeanDefinition对象</span><span class="hljs-comment">* */</span><span class="hljs-comment">// Tell the subclass to refresh the internal bean factory.</span>ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();<span class="hljs-comment">/*</span><span class="hljs-comment">* 给beanFactory设置一些属性值，可以不看</span><span class="hljs-comment">* */</span><span class="hljs-comment">// Prepare the bean factory for use in this context.</span>prepareBeanFactory(beanFactory);<span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//TODO</span><span class="hljs-comment">// Allows post-processing of the bean factory in context subclasses.</span>postProcessBeanFactory(beanFactory);<span class="hljs-comment">/*</span><span class="hljs-comment">* BeanDefinitionRegistryPostProcessor</span><span class="hljs-comment">* BeanFactoryPostProcessor</span><span class="hljs-comment">* 完成对这两个接口的调用</span><span class="hljs-comment">* */</span><span class="hljs-comment">// Invoke factory processors registered as beans in the context.</span>invokeBeanFactoryPostProcessors(beanFactory);<span class="hljs-comment">/*</span><span class="hljs-comment">* 把实现了BeanPostProcessor接口的类实例化，并且加入到BeanFactory中</span><span class="hljs-comment">* */</span><span class="hljs-comment">// Register bean processors that intercept bean creation.</span>registerBeanPostProcessors(beanFactory);<span class="hljs-comment">/*</span><span class="hljs-comment">* 国际化,重要程度2</span><span class="hljs-comment">* */</span><span class="hljs-comment">// Initialize message source for this context.</span>initMessageSource();<span class="hljs-comment">//初始化事件管理类</span><span class="hljs-comment">// Initialize event multicaster for this context.</span>initApplicationEventMulticaster();<span class="hljs-comment">//这个方法着重理解模板设计模式，因为在springboot中，这个方法是用来做内嵌tomcat启动的</span><span class="hljs-comment">// Initialize other special beans in specific context subclasses.</span>onRefresh();<span class="hljs-comment">/*</span><span class="hljs-comment">* 往事件管理类中注册事件类</span><span class="hljs-comment">* */</span><span class="hljs-comment">// Check for listener beans and register them.</span>registerListeners();<span class="hljs-comment">/*</span><span class="hljs-comment">* 这个方法是spring中最重要的方法，没有之一</span><span class="hljs-comment">* 所以这个方法一定要理解要具体看</span><span class="hljs-comment">* 1、bean实例化过程</span><span class="hljs-comment">* 2、ioc</span><span class="hljs-comment">* 3、注解支持</span><span class="hljs-comment">* 4、BeanPostProcessor的执行</span><span class="hljs-comment">* 5、Aop的入口</span><span class="hljs-comment">*</span><span class="hljs-comment">* */</span><span class="hljs-comment">// Instantiate all remaining (non-lazy-init) singletons.</span>finishBeanFactoryInitialization(beanFactory);<span class="hljs-comment">// Last step: publish corresponding event.</span>finishRefresh();&#125;<span class="hljs-keyword">catch</span> (BeansException ex) &#123;<span class="hljs-keyword">if</span> (logger.isWarnEnabled()) &#123;logger.warn(<span class="hljs-string">"Exception encountered during context initialization - "</span> +<span class="hljs-string">"cancelling refresh attempt: "</span> + ex);&#125;<span class="hljs-comment">// Destroy already created singletons to avoid dangling resources.</span>destroyBeans();<span class="hljs-comment">// Reset 'active' flag.</span>cancelRefresh(ex);<span class="hljs-comment">// Propagate exception to caller.</span><span class="hljs-keyword">throw</span> ex;&#125;<span class="hljs-keyword">finally</span> &#123;<span class="hljs-comment">// Reset common introspection caches in Spring's core, since we</span><span class="hljs-comment">// might not ever need metadata for singleton beans anymore...</span>resetCommonCaches();&#125;&#125;&#125;</code></pre><h2 id="设计模式1-模版设计模式"><a href="#设计模式1-模版设计模式" class="headerlink" title="设计模式1-模版设计模式"></a>设计模式1-模版设计模式</h2><p>spring源码中大量使用了模版设计模式，是使用的最多的设计模式。</p><p>模版设计模式一般有两种类，抽象的父类，以及具体实现的子类。父类中实现逻辑中不变的部分，将可变的行为定义为抽象方法交给子类实现，但方法的执行顺序由父类决定。</p><p>创建一个抽象模版结构</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AblstractClass</span> </span>&#123;    <span class="hljs-comment">//模板方法用来控制子类的顺序 要想有人生必须按老爸的人生顺序来  </span>    <span class="hljs-comment">//声明final不让子类覆盖这个方法，防止改变人生顺序</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> 人生()&#123;        学习();        工作();        爱情();    &#125;        <span class="hljs-comment">//家里穷更得用工学习</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> 学习()&#123;        System.out.println(<span class="hljs-string">"每天晚上趴在邻居窗上学习"</span>);    &#125;        <span class="hljs-comment">//工作必须稳定</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> 工作()&#123;               System.out.println(<span class="hljs-string">"从一而终"</span>);    &#125;        <span class="hljs-comment">//恋爱自由  让儿子自由恋去</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> 爱情();&#125;</code></pre><p>创建一个具体模版</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AblstractClass</span> </span>&#123;        <span class="hljs-comment">//儿子不认可父亲的学习方法  考高分影响同学关系</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> 学习() &#123;        System.out.println(<span class="hljs-string">"60分万岁..."</span>);    &#125;        <span class="hljs-comment">//父亲给我爱情自由  一定好好谈恋爱</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> 爱情() &#123;        System.out.println(<span class="hljs-string">"肤白貌美大长腿..."</span>);    &#125;&#125;</code></pre><p>具体的调用</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestMain</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;         ConcreteClass cs  = <span class="hljs-keyword">new</span> ConcreteClass();         cs.人生();    &#125;&#125;</code></pre><h2 id="xml解析"><a href="#xml解析" class="headerlink" title="xml解析"></a>xml解析</h2><p>ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</p><p>该方法主要进行xml解析工作，流程如下：</p><ol><li><p>创建XmlBeanDefinitionReader对象</p><pre><code class="hljs java">XmlBeanDefinitionReader beanDefinitionReader = <span class="hljs-keyword">new</span> XmlBeanDefinitionReader(beanFactory);</code></pre></li><li><p>通过Reader对象加载配置文件</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(XmlBeanDefinitionReader reader)</span> <span class="hljs-keyword">throws</span> BeansException, IOException </span>&#123;Resource[] configResources = getConfigResources();<span class="hljs-keyword">if</span> (configResources != <span class="hljs-keyword">null</span>) &#123;reader.loadBeanDefinitions(configResources);&#125;<span class="hljs-comment">//获取需要加载的xml配置文件</span>String[] configLocations = getConfigLocations();<span class="hljs-keyword">if</span> (configLocations != <span class="hljs-keyword">null</span>) &#123;reader.loadBeanDefinitions(configLocations);&#125;&#125;</code></pre></li><li><p>根据加载的配置文件把配置文件封装成document对象</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">doLoadBeanDefinitions</span><span class="hljs-params">(InputSource inputSource, Resource resource)</span></span><span class="hljs-function"><span class="hljs-keyword">throws</span> BeanDefinitionStoreException </span>&#123;   <span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//把inputSource 封装成Document文件对象，这是jdk的API</span>Document doc = doLoadDocument(inputSource, resource);   <span class="hljs-comment">//主要看这个方法，根据解析出来的document对象，拿到里面的标签元素封装成BeanDefinition</span><span class="hljs-keyword">int</span> count = registerBeanDefinitions(doc, resource);<span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;logger.debug(<span class="hljs-string">"Loaded "</span> + count + <span class="hljs-string">" bean definitions from "</span> + resource);&#125;<span class="hljs-keyword">return</span> count;&#125;</code></pre></li><li><p>创建BeanDefinitionDocumentReader对象，DocumentReader负责对document对象解析</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">registerBeanDefinitions</span><span class="hljs-params">(Document doc, Resource resource)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException </span>&#123;<span class="hljs-comment">//又来一记委托模式，BeanDefinitionDocumentReader委托这个类进行document的解析</span>BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();<span class="hljs-keyword">int</span> countBefore = getRegistry().getBeanDefinitionCount();<span class="hljs-comment">//主要看这个方法，createReaderContext(resource) XmlReaderContext上下文，封装了XmlBeanDefinitionReader对象</span>documentReader.registerBeanDefinitions(doc, createReaderContext(resource));<span class="hljs-keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;&#125;</code></pre></li><li><p>parseDefaultElement(ele,delegate);负责常规标签的解析，delegate.parseCustomElement(ele)负责自定义标签的解析</p><pre><code class="hljs reasonml">protected void parse<span class="hljs-constructor">BeanDefinitions(Element <span class="hljs-params">root</span>, BeanDefinitionParserDelegate <span class="hljs-params">delegate</span>)</span> &#123;<span class="hljs-keyword">if</span> (delegate.is<span class="hljs-constructor">DefaultNamespace(<span class="hljs-params">root</span>)</span>) &#123;NodeList nl = root.get<span class="hljs-constructor">ChildNodes()</span>;for (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; nl.get<span class="hljs-constructor">Length()</span>; i++) &#123;Node node = nl.item(i);<span class="hljs-keyword">if</span> (node instanceof Element) &#123;Element ele = (Element) node;<span class="hljs-keyword">if</span> (delegate.is<span class="hljs-constructor">DefaultNamespace(<span class="hljs-params">ele</span>)</span>) &#123;<span class="hljs-comment">//默认标签解析</span>parse<span class="hljs-constructor">DefaultElement(<span class="hljs-params">ele</span>, <span class="hljs-params">delegate</span>)</span>;&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//自定义标签解析</span>delegate.parse<span class="hljs-constructor">CustomElement(<span class="hljs-params">ele</span>)</span>;&#125;&#125;&#125;&#125;<span class="hljs-keyword">else</span> &#123;delegate.parse<span class="hljs-constructor">CustomElement(<span class="hljs-params">root</span>)</span>;&#125;&#125;</code></pre></li><li><p>最终解析的标签封装成BeanDefinition并缓存到容器中。</p></li><li><p>xml流程分析</p></li></ol><img src="/blog/2020/04/13/spring-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%85%A5%E5%8F%A3%E5%92%8Cxml%E8%A7%A3%E6%9E%90/pic1.png" srcset="/blog/img/loading.gif" class><h2 id="自定义标签解析"><a href="#自定义标签解析" class="headerlink" title="自定义标签解析"></a>自定义标签解析</h2><ol><li><p>首先获取自定义标签头的namespace命名空间，例如：<code>http://www.springframework.org/schema/context</code>，然后通过namespace获取到NamespaceHandler处理类，之后再使用NamespaceHandler中的解析类解析标签获得BeanDefinition对象。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> BeanDefinition <span class="hljs-title">parseCustomElement</span><span class="hljs-params">(Element ele, @Nullable BeanDefinition containingBd)</span> </span>&#123;  <span class="hljs-comment">// 获取自定义标签的命名空间</span>String namespaceUri = getNamespaceURI(ele);<span class="hljs-keyword">if</span> (namespaceUri == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;   <span class="hljs-comment">// 这里有SPI服务发现的思想，根据配置文件获取namespaceUri对应的处理类</span>NamespaceHandler handler = <span class="hljs-keyword">this</span>.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);<span class="hljs-keyword">if</span> (handler == <span class="hljs-keyword">null</span>) &#123;error(<span class="hljs-string">"Unable to locate Spring NamespaceHandler for XML schema namespace ["</span> + namespaceUri + <span class="hljs-string">"]"</span>, ele);<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;<span class="hljs-keyword">return</span> handler.parse(ele, <span class="hljs-keyword">new</span> ParserContext(<span class="hljs-keyword">this</span>.readerContext, <span class="hljs-keyword">this</span>, containingBd));&#125;</code></pre></li><li><p>获取namespace与NamespaceHandler实例的映射关系，然后通过反射创建实例，并调用NamespaceHandler的init()方法完成解析类的注册。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> NamespaceHandler <span class="hljs-title">resolve</span><span class="hljs-params">(String namespaceUri)</span> </span>&#123;<span class="hljs-comment">//获取spring中所有jar包里面的 "META-INF/spring.handlers"文件，并且建立映射关系</span>Map&lt;String, Object&gt; handlerMappings = getHandlerMappings();   <span class="hljs-comment">//根据namespaceUri：http://www.springframework.org/schema/p，获取到这个命名空间的处理类</span>Object handlerOrClassName = handlerMappings.get(namespaceUri);<span class="hljs-keyword">if</span> (handlerOrClassName == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (handlerOrClassName <span class="hljs-keyword">instanceof</span> NamespaceHandler) &#123;<span class="hljs-keyword">return</span> (NamespaceHandler) handlerOrClassName;&#125;<span class="hljs-keyword">else</span> &#123;String className = (String) handlerOrClassName;<span class="hljs-keyword">try</span> &#123;Class&lt;?&gt; handlerClass = ClassUtils.forName(className, <span class="hljs-keyword">this</span>.classLoader);<span class="hljs-keyword">if</span> (!NamespaceHandler<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">isAssignableFrom</span>(<span class="hljs-title">handlerClass</span>)) </span>&#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> FatalBeanException(<span class="hljs-string">"Class ["</span> + className + <span class="hljs-string">"] for namespace ["</span> + namespaceUri +"] does not implement the [" + NamespaceHandler.class.getName() + "] interface");&#125;NamespaceHandler namespaceHandler = (NamespaceHandler) BeanUtils.instantiateClass(handlerClass);   <span class="hljs-comment">//调用处理类的init方法，在init方法中完成标签元素解析类的注册</span>namespaceHandler.init();handlerMappings.put(namespaceUri, namespaceHandler);<span class="hljs-keyword">return</span> namespaceHandler;&#125;<span class="hljs-keyword">catch</span> (ClassNotFoundException ex) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> FatalBeanException(<span class="hljs-string">"Could not find NamespaceHandler class ["</span> + className +<span class="hljs-string">"] for namespace ["</span> + namespaceUri + <span class="hljs-string">"]"</span>, ex);&#125;<span class="hljs-keyword">catch</span> (LinkageError err) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> FatalBeanException(<span class="hljs-string">"Unresolvable class definition for NamespaceHandler class ["</span> +className + <span class="hljs-string">"] for namespace ["</span> + namespaceUri + <span class="hljs-string">"]"</span>, err);&#125;&#125;&#125;</code></pre></li><li><p>获取namespace跟NamespaceHandler映射关系的详细过程。spring在jar包的META-INF/spring.handlers文件中，已经保存了NamespaceUri和NamepsaceHandler之间的映射。此处会加载spring.handlers中的所有内容并保存在map中。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Map&lt;String, Object&gt; <span class="hljs-title">getHandlerMappings</span><span class="hljs-params">()</span> </span>&#123;Map&lt;String, Object&gt; handlerMappings = <span class="hljs-keyword">this</span>.handlerMappings;<span class="hljs-keyword">if</span> (handlerMappings == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;handlerMappings = <span class="hljs-keyword">this</span>.handlerMappings;<span class="hljs-keyword">if</span> (handlerMappings == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;logger.trace(<span class="hljs-string">"Loading NamespaceHandler mappings from ["</span> + <span class="hljs-keyword">this</span>.handlerMappingsLocation + <span class="hljs-string">"]"</span>);&#125;<span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//加载"META-INF/spring.handlers"文件过程</span>Properties mappings =PropertiesLoaderUtils.loadAllProperties(<span class="hljs-keyword">this</span>.handlerMappingsLocation, <span class="hljs-keyword">this</span>.classLoader);<span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;logger.trace(<span class="hljs-string">"Loaded NamespaceHandler mappings: "</span> + mappings);&#125;   <span class="hljs-comment">//所有"META-INF/spring.handlers"文件里面的内容建立映射关系</span>handlerMappings = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;(mappings.size());CollectionUtils.mergePropertiesIntoMap(mappings, handlerMappings);<span class="hljs-keyword">this</span>.handlerMappings = handlerMappings;&#125;<span class="hljs-keyword">catch</span> (IOException ex) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Unable to load NamespaceHandler mappings from location ["</span> + <span class="hljs-keyword">this</span>.handlerMappingsLocation + <span class="hljs-string">"]"</span>, ex);&#125;&#125;&#125;&#125;<span class="hljs-keyword">return</span> handlerMappings;&#125;</code></pre></li></ol><h2 id="默认标签的解析"><a href="#默认标签的解析" class="headerlink" title="默认标签的解析"></a>默认标签的解析</h2><ol><li><p>默认标签分为四种，import、alias、bean、beans，这里主要看bean标签的解析。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parseDefaultElement</span><span class="hljs-params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;<span class="hljs-comment">//import标签解析  重要程度 1 ，可看可不看</span><span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;importBeanDefinitionResource(ele);&#125;<span class="hljs-comment">//alias标签解析 别名标签  重要程度 1 ，可看可不看</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;processAliasRegistration(ele);&#125;<span class="hljs-comment">//bean标签，重要程度  5，必须看</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;processBeanDefinition(ele, delegate);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;<span class="hljs-comment">// recurse</span>doRegisterBeanDefinitions(ele);&#125;&#125;</code></pre></li><li><p>先调用parseBeanDefinitionElement(ele)方法首先解析节点属性封装为BeanDefinitionHolder对象，之后再解析BeanDefinitionHolder对象中的自定义属性，并使用装饰者模式将解析后的属性设置到BeanDefinitionHolder中，然后对BeanDefinitionHolder进行注册。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processBeanDefinition</span><span class="hljs-params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;<span class="hljs-comment">//重点看这个方法，重要程度 5 ，解析ele，封装成BeanDefinition</span>BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);<span class="hljs-keyword">if</span> (bdHolder != <span class="hljs-keyword">null</span>) &#123;   <span class="hljs-comment">//该方法功能不重要，设计模式重点看一下，装饰者设计模式，加上SPI设计思想</span>bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);<span class="hljs-keyword">try</span> &#123;   <span class="hljs-comment">//完成document到BeanDefinition对象转换后，对BeanDefinition对象进行缓存注册</span><span class="hljs-comment">// Register the final decorated instance.</span><span class="hljs-comment">//注册过程，重要程度5</span>BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());&#125;<span class="hljs-keyword">catch</span> (BeanDefinitionStoreException ex) &#123;getReaderContext().error(<span class="hljs-string">"Failed to register bean definition with name '"</span> +bdHolder.getBeanName() + <span class="hljs-string">"'"</span>, ele, ex);&#125;<span class="hljs-comment">// Send registration event.</span>getReaderContext().fireComponentRegistered(<span class="hljs-keyword">new</span> BeanComponentDefinition(bdHolder));&#125;&#125;</code></pre></li><li><p>初次解析标签的过程。这里解析完成后会返回到上层方法，上层方法会将BeanDefinition、beanname、aliases（别名）封装为BeanDefinitionHolder并返回。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> AbstractBeanDefinition <span class="hljs-title">parseBeanDefinitionElement</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">Element ele, String beanName, @Nullable BeanDefinition containingBean)</span> </span>&#123;   <span class="hljs-keyword">this</span>.parseState.push(<span class="hljs-keyword">new</span> BeanEntry(beanName));   String className = <span class="hljs-keyword">null</span>;<span class="hljs-keyword">if</span> (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123;className = ele.getAttribute(CLASS_ATTRIBUTE).trim();&#125;String parent = <span class="hljs-keyword">null</span>;<span class="hljs-keyword">if</span> (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123;parent = ele.getAttribute(PARENT_ATTRIBUTE);&#125;   <span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//创建GenericBeanDefinition对象</span>AbstractBeanDefinition bd = createBeanDefinition(className, parent);   <span class="hljs-comment">//解析bean标签的属性，并把解析出来的属性设置到BeanDefinition对象中</span>parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));   <span class="hljs-comment">//解析bean中的meta标签</span>parseMetaElements(ele, bd);   <span class="hljs-comment">//解析bean中的lookup-method标签  重要程度：2，可看可不看</span>parseLookupOverrideSubElements(ele, bd.getMethodOverrides());   <span class="hljs-comment">//解析bean中的replaced-method标签  重要程度：2，可看可不看</span>parseReplacedMethodSubElements(ele, bd.getMethodOverrides());   <span class="hljs-comment">//解析bean中的constructor-arg标签  重要程度：2，可看可不看</span>parseConstructorArgElements(ele, bd);   <span class="hljs-comment">//解析bean中的property标签  重要程度：2，可看可不看</span>parsePropertyElements(ele, bd);   <span class="hljs-comment">//可以不看，用不到</span>parseQualifierElements(ele, bd);   bd.setResource(<span class="hljs-keyword">this</span>.readerContext.getResource());bd.setSource(extractSource(ele));   <span class="hljs-keyword">return</span> bd;&#125;</code></pre></li><li><p>对标签中的自定义属性再次进行解析，此处用到的SPI思想跟装饰者模式，通过SPI思想获取处理类的方式与自定义标签解析中的方式相同，此处不再赘述。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> BeanDefinitionHolder <span class="hljs-title">decorateIfRequired</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">Node node, BeanDefinitionHolder originalDef, @Nullable BeanDefinition containingBd)</span> </span>&#123;   <span class="hljs-comment">//根据node获取到node的命名空间，形如：http://www.springframework.org/schema/p</span>String namespaceUri = getNamespaceURI(node);<span class="hljs-keyword">if</span> (namespaceUri != <span class="hljs-keyword">null</span> &amp;&amp; !isDefaultNamespace(namespaceUri)) &#123;   <span class="hljs-comment">//这里有SPI服务发现的思想，根据配置文件获取namespaceUri对应的处理类</span>NamespaceHandler handler = <span class="hljs-keyword">this</span>.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);<span class="hljs-keyword">if</span> (handler != <span class="hljs-keyword">null</span>) &#123;   <span class="hljs-comment">//调用NamespaceHandler处理类的decorate方法，开始具体装饰过程，并返回装饰完的对象</span>BeanDefinitionHolder decorated =handler.decorate(node, originalDef, <span class="hljs-keyword">new</span> ParserContext(<span class="hljs-keyword">this</span>.readerContext, <span class="hljs-keyword">this</span>, containingBd));<span class="hljs-keyword">if</span> (decorated != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">return</span> decorated;&#125;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (namespaceUri.startsWith(<span class="hljs-string">"http://www.springframework.org/"</span>)) &#123;error(<span class="hljs-string">"Unable to locate Spring NamespaceHandler for XML schema namespace ["</span> + namespaceUri + <span class="hljs-string">"]"</span>, node);&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// A custom namespace, not to be handled by Spring - maybe "xml:...".</span><span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;logger.debug(<span class="hljs-string">"No Spring NamespaceHandler found for XML schema namespace ["</span> + namespaceUri + <span class="hljs-string">"]"</span>);&#125;&#125;&#125;<span class="hljs-keyword">return</span> originalDef;&#125;</code></pre></li><li><p>注册过程，此处完成完成BeanDefinition的注册后会将beanname与aliases建立联系。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinition</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span></span><span class="hljs-function"><span class="hljs-keyword">throws</span> BeanDefinitionStoreException </span>&#123;   <span class="hljs-comment">// Register bean definition under primary name.</span>String beanName = definitionHolder.getBeanName();   <span class="hljs-comment">//完成BeanDefinition的注册，重点看，重要程度 5</span>registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());   <span class="hljs-comment">//建立别名和 id的映射，这样就可以根据别名获取到id</span><span class="hljs-comment">// Register aliases for bean name, if any.</span>String[] aliases = definitionHolder.getAliases();<span class="hljs-keyword">if</span> (aliases != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">for</span> (String alias : aliases) &#123;registry.registerAlias(beanName, alias);&#125;&#125;&#125;</code></pre></li><li><p>BeanDefinition的注册详细过程。将beanname与beanDefinition缓存到map中、beanName放到beanDefinitionNames中，之后将通过beanDefinitionNames实例化bean</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinition</span><span class="hljs-params">(String beanName, BeanDefinition beanDefinition)</span></span><span class="hljs-function"><span class="hljs-keyword">throws</span> BeanDefinitionStoreException </span>&#123;   Assert.hasText(beanName, <span class="hljs-string">"Bean name must not be empty"</span>);Assert.notNull(beanDefinition, <span class="hljs-string">"BeanDefinition must not be null"</span>);   <span class="hljs-keyword">if</span> (beanDefinition <span class="hljs-keyword">instanceof</span> AbstractBeanDefinition) &#123;<span class="hljs-keyword">try</span> &#123;((AbstractBeanDefinition) beanDefinition).validate();&#125;<span class="hljs-keyword">catch</span> (BeanDefinitionValidationException ex) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,<span class="hljs-string">"Validation of bean definition failed"</span>, ex);&#125;&#125;   <span class="hljs-comment">//先判断BeanDefinition是否已经注册</span>BeanDefinition existingDefinition = <span class="hljs-keyword">this</span>.beanDefinitionMap.get(beanName);<span class="hljs-keyword">if</span> (existingDefinition != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (existingDefinition.getRole() &lt; beanDefinition.getRole()) &#123;<span class="hljs-comment">// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE</span><span class="hljs-keyword">if</span> (logger.isInfoEnabled()) &#123;logger.info(<span class="hljs-string">"Overriding user-defined bean definition for bean '"</span> + beanName +<span class="hljs-string">"' with a framework-generated bean definition: replacing ["</span> +existingDefinition + <span class="hljs-string">"] with ["</span> + beanDefinition + <span class="hljs-string">"]"</span>);&#125;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!beanDefinition.equals(existingDefinition)) &#123;<span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;logger.debug(<span class="hljs-string">"Overriding bean definition for bean '"</span> + beanName +<span class="hljs-string">"' with a different definition: replacing ["</span> + existingDefinition +<span class="hljs-string">"] with ["</span> + beanDefinition + <span class="hljs-string">"]"</span>);&#125;&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;logger.trace(<span class="hljs-string">"Overriding bean definition for bean '"</span> + beanName +<span class="hljs-string">"' with an equivalent definition: replacing ["</span> + existingDefinition +<span class="hljs-string">"] with ["</span> + beanDefinition + <span class="hljs-string">"]"</span>);&#125;&#125;<span class="hljs-keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span> (hasBeanCreationStarted()) &#123;<span class="hljs-comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span><span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.beanDefinitionMap) &#123;<span class="hljs-keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);List&lt;String&gt; updatedDefinitions = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-keyword">this</span>.beanDefinitionNames.size() + <span class="hljs-number">1</span>);updatedDefinitions.addAll(<span class="hljs-keyword">this</span>.beanDefinitionNames);updatedDefinitions.add(beanName);<span class="hljs-keyword">this</span>.beanDefinitionNames = updatedDefinitions;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.manualSingletonNames.contains(beanName)) &#123;Set&lt;String&gt; updatedSingletons = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(<span class="hljs-keyword">this</span>.manualSingletonNames);updatedSingletons.remove(beanName);<span class="hljs-keyword">this</span>.manualSingletonNames = updatedSingletons;&#125;&#125;&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//把beanDefinition缓存到map中</span><span class="hljs-comment">// Still in startup registration phase</span><span class="hljs-keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);   <span class="hljs-comment">//把beanName放到beanDefinitionNames list中</span><span class="hljs-keyword">this</span>.beanDefinitionNames.add(beanName);<span class="hljs-keyword">this</span>.manualSingletonNames.remove(beanName);&#125;<span class="hljs-keyword">this</span>.frozenBeanDefinitionNames = <span class="hljs-keyword">null</span>;&#125;   <span class="hljs-keyword">if</span> (existingDefinition != <span class="hljs-keyword">null</span> || containsSingleton(beanName)) &#123;resetBeanDefinition(beanName);&#125;&#125;</code></pre></li></ol><h2 id="设计模式2-委托模式"><a href="#设计模式2-委托模式" class="headerlink" title="设计模式2-委托模式"></a>设计模式2-委托模式</h2><p>不属于23种设计模式之一，是面向对象设计模式中常用的一种模式，可以理解为静态代理和策略模式的一种特殊的组合。简单来说就是接受请求的对象将请求委托给另一个对象来处理，在spring中比较常见。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Company</span></span>&#123;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">product</span><span class="hljs-params">()</span></span>;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sum</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Company</span></span>&#123;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">product</span><span class="hljs-params">()</span></span>&#123;    System.out.println(<span class="hljs-string">"sum product"</span>);  &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Boss</span> <span class="hljs-title">implemets</span> <span class="hljs-title">Company</span></span>&#123;Sun sun = <span class="hljs-keyword">new</span> Sun();<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">product</span><span class="hljs-params">()</span></span>&#123;sun.product();&#125;&#125;</code></pre><h2 id="设计模式3-装饰模式"><a href="#设计模式3-装饰模式" class="headerlink" title="设计模式3-装饰模式"></a>设计模式3-装饰模式</h2><p>装饰模式通过创建一个包装对象，包装对象中通常持有真实对象的引用，通常与装饰对象有相同的接口，提供与真实对象相同的交互方式。装饰对象在接收请求时会将请求转发给真实对象，并在转发前后增加一些附加功能。这样就可以在不改变真实对象的前提下，动态扩展真实对象的功能。</p><p>创建装饰的公共接口</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">desc</span><span class="hljs-params">()</span></span>;&#125;</code></pre><p>创建被装饰类</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FeiZhai</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">desc</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"这是一个快乐肥宅"</span>);    &#125;&#125;</code></pre><p>创建装饰器</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Decorator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Person</span> </span>&#123;    Person person;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PersonDecorator</span><span class="hljs-params">(Person person)</span> </span>&#123;        <span class="hljs-keyword">this</span>.person = person;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">desc</span><span class="hljs-params">()</span> </span>&#123;        person.desc();    &#125;&#125;</code></pre><p>创建装饰子类：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DecoratorDnfPlayer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">PersonDecorator</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HighPerson</span><span class="hljs-params">(Person person)</span> </span>&#123;        <span class="hljs-keyword">super</span>(person);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">desc</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">super</span>.desc();        System.out.println(<span class="hljs-string">"DNF玩家，八百万勇士之一！！！"</span>);    &#125;&#125;</code></pre><p>具体使用</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DecorationTest</span> </span>&#123;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"创建一个肥宅"</span>);        Person person = <span class="hljs-keyword">new</span> FeiZhai();        person.desc();        System.out.println(<span class="hljs-string">"使用装饰器，装饰肥宅"</span>);        person = <span class="hljs-keyword">new</span> DecoratorDnfPlayer(persion);        person.desc();    &#125;&#125;</code></pre><h2 id="设计模式4策略模式"><a href="#设计模式4策略模式" class="headerlink" title="设计模式4策略模式"></a>设计模式4策略模式</h2><p>简单来说就是创建不同的处理逻辑，然后根据条件去选择处理逻辑。当代码中出现大量的if时，为了避免修改核心代码，以及增加拓展性就经常需要使用策略模式。</p><p>比如，有省份不同省份做不同处理的需求时：</p><p>先创建一个接口</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Province</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">support</span><span class="hljs-params">(String flag)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">handler</span><span class="hljs-params">()</span></span>;&#125;</code></pre><p>湖北的处理策略</p><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HN</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Province</span></span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String flag = <span class="hljs-string">"HN"</span>;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">support</span><span class="hljs-params">(String flag)</span> </span>&#123;        <span class="hljs-keyword">return</span> HN.flag.equalsIgnoreCase(flag);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">handler</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"======HN处理类处理"</span>);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;&#125;</code></pre><p>湖南的处理策略</p><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HN</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Province</span></span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String flag = <span class="hljs-string">"HN"</span>;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">support</span><span class="hljs-params">(String flag)</span> </span>&#123;        <span class="hljs-keyword">return</span> HN.flag.equalsIgnoreCase(flag);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">handler</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"======HN处理类处理"</span>);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;&#125;</code></pre><p>具体的使用</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;    String flag = <span class="hljs-string">"CQ"</span>;    Map&lt;String, Province&gt; beansOfType = applicationContext.getBeansOfType(Province<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    beansOfType.forEach((k,v) -&gt; &#123;        <span class="hljs-keyword">if</span>(v.support(flag)) &#123;            v.handler();        &#125;    &#125;);&#125;</code></pre><h2 id="设计模式5建造者模式"><a href="#设计模式5建造者模式" class="headerlink" title="设计模式5建造者模式"></a>设计模式5建造者模式</h2><p>当类的属性过于复杂时，使用构造方法或set()方法设置会让代码变的混乱，这时就可以通过建造者模式对类进行装配。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BuilderClass</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> servingSize;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> servings;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> calories;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> fat;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> sodium;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> carbohydrate;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Builder</span> </span>&#123;        <span class="hljs-comment">// 必要参数</span>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> servingSize;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> servings;        <span class="hljs-comment">// 可选参数</span>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> calories = <span class="hljs-number">0</span>;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> fat = <span class="hljs-number">0</span>;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> carbohydrate = <span class="hljs-number">0</span>;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> sodium = <span class="hljs-number">0</span>;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Builder</span><span class="hljs-params">(<span class="hljs-keyword">int</span> servingSize, <span class="hljs-keyword">int</span> servings)</span> </span>&#123;            <span class="hljs-keyword">this</span>.servingSize = servingSize;            <span class="hljs-keyword">this</span>.servings = servings;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">calories</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;            calories = val;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">fat</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;            fat = val;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">carbohydrate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;            carbohydrate = val;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">sodium</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;            sodium = val;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> BuilderClass <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BuilderClass(<span class="hljs-keyword">this</span>);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">BuilderClass</span><span class="hljs-params">(Builder builder)</span> </span>&#123;        servingSize = builder.servingSize;        servings = builder.servings;        calories = builder.calories;        fat = builder.fat;        sodium = builder.sodium;        carbohydrate = builder.carbohydrate;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        BuilderClass cocaCola = <span class="hljs-keyword">new</span> BuilderClass.Builder(<span class="hljs-number">240</span>, <span class="hljs-number">8</span>)                .calories(<span class="hljs-number">100</span>).sodium(<span class="hljs-number">35</span>).carbohydrate(<span class="hljs-number">27</span>).build();    &#125;&#125;</code></pre><h2 id="component-scan标签的解析"><a href="#component-scan标签的解析" class="headerlink" title="component-scan标签的解析"></a>component-scan标签的解析</h2><ol><li><p>context属于自定义标签，所以需要先通过namespace命名空间在spring.handlers文件中获取到对应的NamepsaceHandler处理类之后再调用init()方法注册BeanDefinitionParser解析类，然后再获取scan对应的BeanDefinitionParser解析类进行解析。</p><pre><code class="hljs elixir">http\<span class="hljs-symbol">://www</span>.springframework.org/schema/context=org.springframework.context.config.ContextNamespaceHandlerhttp\<span class="hljs-symbol">://www</span>.springframework.org/schema/jee=org.springframework.ejb.config.JeeNamespaceHandlerhttp\<span class="hljs-symbol">://www</span>.springframework.org/schema/lang=org.springframework.scripting.config.LangNamespaceHandlerhttp\<span class="hljs-symbol">://www</span>.springframework.org/schema/task=org.springframework.scheduling.config.TaskNamespaceHandlerhttp\<span class="hljs-symbol">://www</span>.springframework.org/schema/cache=org.springframework.cache.config.CacheNamespaceHandler</code></pre></li><li><p>调用ContextNamespaceHandler的init()方法注册BeanDefinitionParser解析类。</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;registerBeanDefinitionParser(<span class="hljs-string">"property-placeholder"</span>, <span class="hljs-keyword">new</span> PropertyPlaceholderBeanDefinitionParser());registerBeanDefinitionParser(<span class="hljs-string">"property-override"</span>, <span class="hljs-keyword">new</span> PropertyOverrideBeanDefinitionParser());registerBeanDefinitionParser(<span class="hljs-string">"annotation-config"</span>, <span class="hljs-keyword">new</span> AnnotationConfigBeanDefinitionParser());registerBeanDefinitionParser(<span class="hljs-string">"component-scan"</span>, <span class="hljs-keyword">new</span> ComponentScanBeanDefinitionParser());registerBeanDefinitionParser(<span class="hljs-string">"load-time-weaver"</span>, <span class="hljs-keyword">new</span> LoadTimeWeaverBeanDefinitionParser());registerBeanDefinitionParser(<span class="hljs-string">"spring-configured"</span>, <span class="hljs-keyword">new</span> SpringConfiguredBeanDefinitionParser());registerBeanDefinitionParser(<span class="hljs-string">"mbean-export"</span>, <span class="hljs-keyword">new</span> MBeanExportBeanDefinitionParser());registerBeanDefinitionParser(<span class="hljs-string">"mbean-server"</span>, <span class="hljs-keyword">new</span> MBeanServerBeanDefinitionParser());&#125;</code></pre></li><li><p>BeanDefinitionParser的parser()方法中的逻辑。在这里将创建扫描器对基础包路径下的类进行扫描，并创建为BeanDefiniton对象，然后通过registerComponents()方法注册BeanPostProcessor。BeanPostProcessor主要是支撑类中其他注解的功能，如@Autowired、@PostConstruct、@PreDestory等。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> BeanDefinition <span class="hljs-title">parse</span><span class="hljs-params">(Element element, ParserContext parserContext)</span> </span>&#123;<span class="hljs-comment">//获取basePackage属性</span>String basePackage = element.getAttribute(BASE_PACKAGE_ATTRIBUTE);basePackage = parserContext.getReaderContext().getEnvironment().resolvePlaceholders(basePackage);<span class="hljs-comment">//可以用逗号分开</span>String[] basePackages = StringUtils.tokenizeToStringArray(basePackage,ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);   <span class="hljs-comment">//创建注解扫描器</span><span class="hljs-comment">// Actually scan for bean definitions and register them.</span>ClassPathBeanDefinitionScanner scanner = configureScanner(parserContext, element);<span class="hljs-comment">//扫描并把扫描的类封装成beanDefinition对象  核心方法，重要程度 5</span>Set&lt;BeanDefinitionHolder&gt; beanDefinitions = scanner.doScan(basePackages);   <span class="hljs-comment">//注册BeanPostProcessor</span>registerComponents(parserContext.getReaderContext(), beanDefinitions, element);   <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre></li><li><p>doScan()方法中会扫描到有注解的类并封装成BeanDefinitionHolder对象。在通过findCandidateComponents()获取到BeanDefinition之后，会根据ScopeMetadata对BeanDefinitionHolder的属性再次进行设置，并创建BeanDefinitionHolder对象，最后注册BeanDefinitonHolder。注册过程与默认实例化中相同，此处不再赘述。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="hljs-title">doScan</span><span class="hljs-params">(String... basePackages)</span> </span>&#123;Assert.notEmpty(basePackages, <span class="hljs-string">"At least one base package must be specified"</span>);Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;();<span class="hljs-keyword">for</span> (String basePackage : basePackages) &#123;<span class="hljs-comment">//扫描到有注解的类并封装成BeanDefinition对象</span>Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);<span class="hljs-keyword">for</span> (BeanDefinition candidate : candidates) &#123;ScopeMetadata scopeMetadata = <span class="hljs-keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);candidate.setScope(scopeMetadata.getScopeName());String beanName = <span class="hljs-keyword">this</span>.beanNameGenerator.generateBeanName(candidate, <span class="hljs-keyword">this</span>.registry);<span class="hljs-keyword">if</span> (candidate <span class="hljs-keyword">instanceof</span> AbstractBeanDefinition) &#123;postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);&#125;<span class="hljs-keyword">if</span> (candidate <span class="hljs-keyword">instanceof</span> AnnotatedBeanDefinition) &#123;<span class="hljs-comment">//支持了@Lazy @DependOn注解</span>AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);&#125;<span class="hljs-keyword">if</span> (checkCandidate(beanName, candidate)) &#123;BeanDefinitionHolder definitionHolder = <span class="hljs-keyword">new</span> BeanDefinitionHolder(candidate, beanName);<span class="hljs-comment">//这里不看</span>definitionHolder =AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="hljs-keyword">this</span>.registry);beanDefinitions.add(definitionHolder);   <span class="hljs-comment">//BeanDefinition注册</span>registerBeanDefinition(definitionHolder, <span class="hljs-keyword">this</span>.registry);&#125;&#125;&#125;<span class="hljs-keyword">return</span> beanDefinitions;&#125;</code></pre></li><li><p>findCandidateComponents()会递寻找包路径下文件，然后将文件封装为MetadataReader对象，之后再根据MetadataReader中的类注解判断是否进行实例化。进行处理并封装为BeanDefinition。MetadataReader中持有一个ClassMetadata，ClassMetadata对象中几乎包括类的所有信息。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Set&lt;BeanDefinition&gt; <span class="hljs-title">scanCandidateComponents</span><span class="hljs-params">(String basePackage)</span> </span>&#123;Set&lt;BeanDefinition&gt; candidates = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;();<span class="hljs-keyword">try</span> &#123;String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +resolveBasePackage(basePackage) + <span class="hljs-string">'/'</span> + <span class="hljs-keyword">this</span>.resourcePattern;   <span class="hljs-comment">//这里递归寻找文件</span>Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath);<span class="hljs-keyword">boolean</span> traceEnabled = logger.isTraceEnabled();<span class="hljs-keyword">boolean</span> debugEnabled = logger.isDebugEnabled();<span class="hljs-keyword">for</span> (Resource resource : resources) &#123;<span class="hljs-keyword">if</span> (traceEnabled) &#123;logger.trace(<span class="hljs-string">"Scanning "</span> + resource);&#125;<span class="hljs-keyword">if</span> (resource.isReadable()) &#123;<span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//将文件信息包装为类基本信息的对象</span>MetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(resource);<span class="hljs-comment">//如果类上面有includeFilters中的注解</span><span class="hljs-keyword">if</span> (isCandidateComponent(metadataReader)) &#123;ScannedGenericBeanDefinition sbd = <span class="hljs-keyword">new</span> ScannedGenericBeanDefinition(metadataReader);sbd.setResource(resource);sbd.setSource(resource);<span class="hljs-keyword">if</span> (isCandidateComponent(sbd)) &#123;<span class="hljs-keyword">if</span> (debugEnabled) &#123;logger.debug(<span class="hljs-string">"Identified candidate component class: "</span> + resource);&#125;candidates.add(sbd);&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span> (debugEnabled) &#123;logger.debug(<span class="hljs-string">"Ignored because not a concrete top-level class: "</span> + resource);&#125;&#125;&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span> (traceEnabled) &#123;logger.trace(<span class="hljs-string">"Ignored because not matching any filter: "</span> + resource);&#125;&#125;&#125;<span class="hljs-keyword">catch</span> (Throwable ex) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanDefinitionStoreException(<span class="hljs-string">"Failed to read candidate component class: "</span> + resource, ex);&#125;&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span> (traceEnabled) &#123;logger.trace(<span class="hljs-string">"Ignored because not readable: "</span> + resource);&#125;&#125;&#125;&#125;<span class="hljs-keyword">catch</span> (IOException ex) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanDefinitionStoreException(<span class="hljs-string">"I/O failure during classpath scanning"</span>, ex);&#125;<span class="hljs-keyword">return</span> candidates;&#125;</code></pre></li><li><p>递归寻找文件的主要方法</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doRetrieveMatchingFiles</span><span class="hljs-params">(String fullPattern, File dir, Set&lt;File&gt; result)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;logger.trace(<span class="hljs-string">"Searching directory ["</span> + dir.getAbsolutePath() +<span class="hljs-string">"] for files matching pattern ["</span> + fullPattern + <span class="hljs-string">"]"</span>);&#125;<span class="hljs-keyword">for</span> (File content : listDirectory(dir)) &#123;String currPath = StringUtils.replace(content.getAbsolutePath(), File.separator, <span class="hljs-string">"/"</span>);<span class="hljs-comment">//如果是一个文件夹，则递归</span><span class="hljs-keyword">if</span> (content.isDirectory() &amp;&amp; getPathMatcher().matchStart(fullPattern, currPath + <span class="hljs-string">"/"</span>)) &#123;<span class="hljs-keyword">if</span> (!content.canRead()) &#123;<span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;logger.debug(<span class="hljs-string">"Skipping subdirectory ["</span> + dir.getAbsolutePath() +<span class="hljs-string">"] because the application is not allowed to read the directory"</span>);&#125;&#125;<span class="hljs-keyword">else</span> &#123;doRetrieveMatchingFiles(fullPattern, content, result);&#125;&#125;   <span class="hljs-comment">//如果是一个文件，则加入到容器</span><span class="hljs-keyword">if</span> (getPathMatcher().match(fullPattern, currPath)) &#123;result.add(content);&#125;&#125;&#125;</code></pre></li><li><p>注册BeanPostProcessor过程</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Set&lt;BeanDefinitionHolder&gt; <span class="hljs-title">registerAnnotationConfigProcessors</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">BeanDefinitionRegistry registry, @Nullable Object source)</span> </span>&#123;   DefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry);<span class="hljs-keyword">if</span> (beanFactory != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">if</span> (!(beanFactory.getDependencyComparator() <span class="hljs-keyword">instanceof</span> AnnotationAwareOrderComparator)) &#123;beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);&#125;<span class="hljs-keyword">if</span> (!(beanFactory.getAutowireCandidateResolver() <span class="hljs-keyword">instanceof</span> ContextAnnotationAutowireCandidateResolver)) &#123;beanFactory.setAutowireCandidateResolver(<span class="hljs-keyword">new</span> ContextAnnotationAutowireCandidateResolver());&#125;&#125;   Set&lt;BeanDefinitionHolder&gt; beanDefs = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(<span class="hljs-number">8</span>);   <span class="hljs-keyword">if</span> (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;RootBeanDefinition def = <span class="hljs-keyword">new</span> RootBeanDefinition(ConfigurationClassPostProcessor<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;def.setSource(source);beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));&#125;   <span class="hljs-keyword">if</span> (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;RootBeanDefinition def = <span class="hljs-keyword">new</span> RootBeanDefinition(AutowiredAnnotationBeanPostProcessor<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;def.setSource(source);beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));&#125;   <span class="hljs-comment">// Check for JSR-250 support, and if present add the CommonAnnotationBeanPostProcessor.</span><span class="hljs-keyword">if</span> (jsr250Present &amp;&amp; !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;RootBeanDefinition def = <span class="hljs-keyword">new</span> RootBeanDefinition(CommonAnnotationBeanPostProcessor<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;def.setSource(source);beanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME));&#125;   <span class="hljs-comment">// Check for JPA support, and if present add the PersistenceAnnotationBeanPostProcessor.</span><span class="hljs-keyword">if</span> (jpaPresent &amp;&amp; !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;RootBeanDefinition def = <span class="hljs-keyword">new</span> RootBeanDefinition();<span class="hljs-keyword">try</span> &#123;def.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME,AnnotationConfigUtils<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getClassLoader</span>()))</span>;&#125;<span class="hljs-keyword">catch</span> (ClassNotFoundException ex) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Cannot load optional framework class: "</span> + PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, ex);&#125;def.setSource(source);beanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME));&#125;   <span class="hljs-keyword">if</span> (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) &#123;RootBeanDefinition def = <span class="hljs-keyword">new</span> RootBeanDefinition(EventListenerMethodProcessor<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;def.setSource(source);beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME));&#125;   <span class="hljs-keyword">if</span> (!registry.containsBeanDefinition(EVENT_LISTENER_FACTORY_BEAN_NAME)) &#123;RootBeanDefinition def = <span class="hljs-keyword">new</span> RootBeanDefinition(DefaultEventListenerFactory<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;def.setSource(source);beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_FACTORY_BEAN_NAME));&#125;   <span class="hljs-keyword">return</span> beanDefs;&#125;</code></pre></li></ol><h2 id="简单上手"><a href="#简单上手" class="headerlink" title="简单上手"></a>简单上手</h2><h3 id="使用自定义标签连接redis"><a href="#使用自定义标签连接redis" class="headerlink" title="使用自定义标签连接redis"></a>使用自定义标签连接redis</h3><ol><li>创建自定义标签约束文件myMags.xsd，位置为在resources/META-INF/</li></ol><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">xsd:schema</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.test.com/schema/mytags"</span></span><span class="hljs-tag">            <span class="hljs-attr">xmlns:xsd</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema"</span> <span class="hljs-attr">targetNamespace</span>=<span class="hljs-string">"http://www.test.com/schema/mytags"</span></span><span class="hljs-tag">            <span class="hljs-attr">elementFormDefault</span>=<span class="hljs-string">"qualified"</span> <span class="hljs-attr">attributeFormDefault</span>=<span class="hljs-string">"unqualified"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">xsd:element</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"redis"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">xsd:complexType</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">xsd:attribute</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"xsd:string"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">xsd:attribute</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">xsd:attribute</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"ip"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"xsd:string"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">xsd:attribute</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">xsd:attribute</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"port"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"xsd:string"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">xsd:attribute</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">xsd:complexType</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">xsd:element</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">xsd:schema</span>&gt;</span></code></pre><ol start="2"><li>在相同位置为xsd文件创建映射文件spring.schemas</li></ol><pre><code class="hljs scheme">http\://www.test.com/schema/mytags.xsd=META-INF/myTags.xsd</code></pre><ol start="3"><li>在相同位置下创建spring.handlers文件</li></ol><pre><code class="hljs elixir">http\<span class="hljs-symbol">://www</span>.test.com/schema/mytags=org.example.tag.TagsNamespaceHandler</code></pre><ol start="4"><li>创建RedisBeanDefinitionParser类</li></ol><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisBeanDefinitionParser</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractSingleBeanDefinitionParser</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> Class&lt;?&gt; getBeanClass(Element element) &#123;        <span class="hljs-keyword">return</span> Jedis<span class="hljs-class">.<span class="hljs-keyword">class</span></span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doParse</span><span class="hljs-params">(Element element, BeanDefinitionBuilder builder)</span> </span>&#123;        String ip = element.getAttribute(<span class="hljs-string">"ip"</span>);        String port = element.getAttribute(<span class="hljs-string">"port"</span>);        builder.addConstructorArgValue(ip);        builder.addConstructorArgValue(Integer.parseInt(port));    &#125;&#125;</code></pre><ol start="5"><li>创建TagsNamespaceHandler类</li></ol><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TagsNamespaceHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">NamespaceHandlerSupport</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.registerBeanDefinitionParser(<span class="hljs-string">"redis"</span>,<span class="hljs-keyword">new</span> RedisBeanDefinitionParser());    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> BeanDefinitionHolder <span class="hljs-title">decorate</span><span class="hljs-params">(Node node, BeanDefinitionHolder definition, ParserContext parserContext)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.decorate(node, definition, parserContext);    &#125;&#125;</code></pre><ol start="6"><li>在spring.xml中使用自定义标签</li></ol><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="hljs-attr">xmlns:my</span>=<span class="hljs-string">"http://www.test.com/schema/mytags"</span></span><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans</span></span><span class="hljs-tag"><span class="hljs-string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><span class="hljs-tag"><span class="hljs-string">       http://www.test.com/schema/mytags</span></span><span class="hljs-tag"><span class="hljs-string">       http://www.test.com/schema/mytags.xsd"</span></span><span class="hljs-tag">       <span class="hljs-attr">default-lazy-init</span>=<span class="hljs-string">"false"</span>&gt;</span>    <span class="hljs-comment">&lt;!--自定义标签--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">my:redis</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"redis"</span> <span class="hljs-attr">ip</span>=<span class="hljs-string">"localhost"</span> <span class="hljs-attr">port</span>=<span class="hljs-string">"6379"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre><ol start="7"><li>测试类</li></ol><pre><code class="hljs java"><span class="hljs-meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">@<span class="hljs-title">ContextConfiguration</span>(<span class="hljs-title">locations</span> </span>= &#123;<span class="hljs-string">"classpath:spring.xml"</span>&#125;)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTest</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> Jedis jedis;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myTag</span><span class="hljs-params">()</span> </span>&#123;        jedis.set(<span class="hljs-string">"tag"</span>,<span class="hljs-string">"test"</span>);        System.out.println(jedis.get(<span class="hljs-string">"tag"</span>));    &#125;&#125;</code></pre><h3 id="使用自定义注解创建Bean对象"><a href="#使用自定义注解创建Bean对象" class="headerlink" title="使用自定义注解创建Bean对象"></a>使用自定义注解创建Bean对象</h3><ol><li>创建MyBeanDefinitionRegistryPostProcessor</li></ol><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBeanDefinitionRegistryPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanDefinitionRegistryPostProcessor</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeanDefinitionRegistry</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;        GenericBeanDefinition genericBeanDefinition = <span class="hljs-keyword">new</span> GenericBeanDefinition();        genericBeanDefinition.setBeanClass(BeanClass<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        MutablePropertyValues propertyValues = genericBeanDefinition.getPropertyValues();        propertyValues.addPropertyValue(<span class="hljs-string">"username"</span>,<span class="hljs-string">"test"</span>);        registry.registerBeanDefinition(<span class="hljs-string">"beanClass"</span>,genericBeanDefinition);        ClassPathBeanDefinitionScanner scanner = <span class="hljs-keyword">new</span> ClassPathBeanDefinitionScanner(registry);        scanner.addIncludeFilter(<span class="hljs-keyword">new</span> AnnotationTypeFilter(MyService<span class="hljs-class">.<span class="hljs-keyword">class</span>))</span>;        scanner.scan(<span class="hljs-string">"org.example.beanDefinition"</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;    &#125;&#125;</code></pre><ol start="2"><li>创建BeanClass</li></ol><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeanClass</span> </span>&#123;    <span class="hljs-keyword">private</span> String username;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUsername</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> username;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUsername</span><span class="hljs-params">(String username)</span> </span>&#123;        <span class="hljs-keyword">this</span>.username = username;    &#125;&#125;</code></pre><ol start="3"><li>创建</li></ol><pre><code class="hljs java"><span class="hljs-meta">@Target</span>(&#123;ElementType.TYPE&#125;)<span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-meta">@Documented</span><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyService &#123;ßß    <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> ""</span>;&#125;</code></pre><ol start="4"><li>测试类</li></ol><pre><code class="hljs java"><span class="hljs-meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">@<span class="hljs-title">ContextConfiguration</span>(<span class="hljs-title">locations</span> </span>= &#123;<span class="hljs-string">"classpath:spring.xml"</span>&#125;)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTest</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> Jedis jedis;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myTag</span><span class="hljs-params">()</span> </span>&#123;        jedis.set(<span class="hljs-string">"tag"</span>,<span class="hljs-string">"test"</span>);        System.out.println(jedis.get(<span class="hljs-string">"tag"</span>));    &#125;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> BeanClass beanClass;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beanDefinition</span><span class="hljs-params">()</span></span>&#123;        System.out.println(beanClass.getUsername());    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Spring源码解析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>源码解析</tag>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL的索引与执行计划</title>
    <link href="/blog/2020/04/03/MySQL%E7%9A%84%E7%B4%A2%E5%BC%95%E4%B8%8E%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/"/>
    <url>/blog/2020/04/03/MySQL%E7%9A%84%E7%B4%A2%E5%BC%95%E4%B8%8E%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。可以得到索引的本质：<strong>索引是数据结构</strong>。</p><img src="/blog/2020/04/03/MySQL%E7%9A%84%E7%B4%A2%E5%BC%95%E4%B8%8E%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/pic1.png" srcset="/blog/img/loading.gif" class><p>MySQL默认存储引擎InnoDB只显示支持B-Tree（从技术上来说是B+Tree），在创建创建主键索引时会新增一个节点，当通过主键来查询内容的时候，首先去查索引库快速的定位索引的具体位置。</p><h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>二分查找法（binary search） 也称为折半查找法，用来查找一组有序的记录数组中的某一记录。</p><p>其基本思想是：将记录按有序化（递增或递减）排列，在查找过程中采用跳跃式方式查找，即先以有序数列的中点位置作为比较对象，如果要找的元素值小于该中点元素，则将待查序列缩小为左半部分，否则为右半部分。通过一次比较，将查找区间缩小一半。</p><h4 id="二叉树-Binary-Tree"><a href="#二叉树-Binary-Tree" class="headerlink" title="二叉树(Binary Tree)"></a>二叉树(Binary Tree)</h4><p>每个节点至多只有二棵子树； </p><ul><li><p>二叉树的子树有左右之分，次序不能颠倒； </p></li><li><p>一棵深度为k，且有2的k-1次方个节点，称为满二叉树(Full Tree)； </p></li><li><p>一棵深度为k，且跟节点到k-1层的节点树都达到最大，第k层的所有节点都连续集中在最左边，此时为完全二叉树（Complete Tree）</p></li></ul><img src="/blog/2020/04/03/MySQL%E7%9A%84%E7%B4%A2%E5%BC%95%E4%B8%8E%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/pic2.png" srcset="/blog/img/loading.gif" class><img src="/blog/2020/04/03/MySQL%E7%9A%84%E7%B4%A2%E5%BC%95%E4%B8%8E%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/pic3.png" srcset="/blog/img/loading.gif" class><h4 id="平衡二叉树（AVL-树）"><a href="#平衡二叉树（AVL-树）" class="headerlink" title="平衡二叉树（AVL-树）"></a>平衡二叉树（AVL-树）</h4><ul><li>左子树和右子树的高度差绝对值不超过1</li><li>左子树和右子树都是平衡二叉树</li></ul><img src="/blog/2020/04/03/MySQL%E7%9A%84%E7%B4%A2%E5%BC%95%E4%B8%8E%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/pic4.png" srcset="/blog/img/loading.gif" class><img src="/blog/2020/04/03/MySQL%E7%9A%84%E7%B4%A2%E5%BC%95%E4%B8%8E%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/pic5.png" srcset="/blog/img/loading.gif" class><h5 id="平衡二叉树的遍历"><a href="#平衡二叉树的遍历" class="headerlink" title="平衡二叉树的遍历"></a>平衡二叉树的遍历</h5><ul><li>前序 ：6 ,3, 2, 5,7, 8（ROOT节点在开头, 中-左-右 顺序）</li><li>中序 ：2, 3, 5, 6,7, 8（中序遍历即为升序，左-中-右 顺序）</li><li>后序 ：2, 5, 3, 8,7, 6 （ROOT节点在结尾，左-右-中 顺序）</li></ul><h5 id="平衡二叉树的旋转"><a href="#平衡二叉树的旋转" class="headerlink" title="平衡二叉树的旋转"></a>平衡二叉树的旋转</h5><img src="/blog/2020/04/03/MySQL%E7%9A%84%E7%B4%A2%E5%BC%95%E4%B8%8E%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/pic6.png" srcset="/blog/img/loading.gif" class><p>需要通过旋转（左旋，右旋）来维护平衡二叉树的平衡，在添加和删除的时候需要有额外的开销。</p><h4 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><ul><li><p>数据只存储在叶子节点上，非叶子节点只保存索引信息；</p><ul><li>非叶子节点（索引节点）存储的只是一个Flag，不保存实际数据记录； </li><li>索引节点指示该节点的左子树比这个Flag小，而右子树大于等于这个Flag；</li></ul></li><li><p>叶子节点本身按照数据的升序排序进行链接（串联起来）；</p><ul><li>叶子节点中的数据在物理存储上是无序的，仅仅是在逻辑上有序（通过指针串在一起）；</li></ul></li></ul><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ul><li>在块设备上，通过B+树可以有效的存储数据； </li><li>所有记录都存储在叶子节点上，非叶子(non-leaf)存储索引(keys)信息； </li><li>B+树含有非常高的扇出（fanout），通常超过100，在查找一个记录时，可以有效的减少IO操作； </li></ul><h5 id="扇出"><a href="#扇出" class="headerlink" title="扇出"></a>扇出</h5><img src="/blog/2020/04/03/MySQL%E7%9A%84%E7%B4%A2%E5%BC%95%E4%B8%8E%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/pic7.png" srcset="/blog/img/loading.gif" class><p>扇出是每个索引节点(Non-LeafPage)指向每个叶子节点(LeafPage)的指针，扇出数 = 索引节点(Non-LeafPage)可存储的最大关键字个数 + 1。图例中的索引节点（Non-LeafPage）最大可以存放4个关键字，但实际使用了3个；</p><ul><li>该 B+ 树高度为 2</li><li>每叶子页（LeafPage）4条记录</li><li>扇出数为5 ，</li><li>叶子节点(LeafPage)由小到大（有序）串联在一起</li></ul><h5 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h5><p>B+树的插入必须保证插入后叶子节点中的记录依然排序。 </p><img src="/blog/2020/04/03/MySQL%E7%9A%84%E7%B4%A2%E5%BC%95%E4%B8%8E%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/pic8.png" srcset="/blog/img/loading.gif" class><h3 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h3><ul><li><p>普通索引：即一个索引只包含单个列，一个表可以有多个单列索引</p></li><li><p>唯一索引：索引列的值必须唯一，但允许有空值</p></li><li><p>复合索引：即一个索引包含多个列</p></li><li><p>聚簇索引（聚集索引）：并不是一种单独的索引类型，而是一种数据存储方式。将数据存储与索引存储在一起，找到索引也就找到了数据。聚簇索引是唯一的，InnoDB通过聚簇索引保存数据，非聚簇索引一定存储有聚簇索引的列值。</p></li><li><p>非聚簇索引：将数据存储与索引分开存储的结构，索引结构的叶子节点指向了数据的对应行，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因。</p></li></ul><h3 id="索引的使用"><a href="#索引的使用" class="headerlink" title="索引的使用"></a>索引的使用</h3><p><strong>查看索引</strong></p><pre><code class="hljs pgsql"><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">INDEX</span> <span class="hljs-keyword">FROM</span> <span class="hljs-built_in">table_name</span>;</code></pre><p><strong>创建索引</strong></p><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> [<span class="hljs-keyword">UNIQUE</span> ] <span class="hljs-keyword">INDEX</span> indexName <span class="hljs-keyword">ON</span> mytable(columnname(<span class="hljs-keyword">length</span>));<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">ADD</span> [<span class="hljs-keyword">UNIQUE</span> ] <span class="hljs-keyword">INDEX</span> [indexName] <span class="hljs-keyword">ON</span> (columnname(<span class="hljs-keyword">length</span>));</code></pre><p><strong>删除索引</strong></p><pre><code class="hljs n1ql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">INDEX</span> [indexName] <span class="hljs-keyword">ON</span> mytable;</code></pre><h2 id="执行计划"><a href="#执行计划" class="headerlink" title="执行计划"></a>执行计划</h2><p>使用EXPLAIN关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理你的SQL语句的，分析你的查询语句或是表结构的性能瓶颈。</p><p>执行计划的语法比较简单，只要在SQL查询前加上EXPLAIN关键字就行。</p><p>比如：EXPLAIN select * from table1;</p><p>通过执行计划的结果可以分析出以下内容：</p><ul><li>表的读取顺序</li><li>数据读取操作的操作类型</li><li>哪些索引可以使用</li><li>哪些索引被实际使用</li><li>表之间的引用</li><li>每张表有多少行被优化器查询</li></ul><p>通过EXPLAIN关键分析的结果由以下列组成，接下来挨个分析每一个列</p>{% asset_img pic9.png %}<h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p>描述select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序</p><p>根据ID的数值结果可以分成一下三种情况</p><ul><li>id相同：执行顺序由上至下</li><li>id不同：如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</li><li>id相同不同：同时存在</li></ul><h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><p>查询类型，主要是用于区别普通查询，联合查询，自查询等的复杂查询</p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>SIMPLE</td><td>简单的select查询，查询中不包含子查询或者UNION</td></tr><tr><td>PRIMARY</td><td>查询中包含任何复杂的子部分，则最外层查询被标记为PRIMARY</td></tr><tr><td>SUBQUERY</td><td>在SELECT或者WHERE列表中包含的子查询</td></tr><tr><td>DERIVED</td><td>在FROM列表中包含的子查询被标记为DERIVED（衍生），MySQL会递归执行这些子查询，把结果放在临时表里。</td></tr><tr><td>UNION</td><td>若第二个SELECT出现在UNION之后，则标记为UNION；若UNION包含在FROM子句的子查询中，外层的SELECT被标记为DEIRIVED</td></tr><tr><td>UNION RESULT</td><td>从UNION表获取结果的SELECT</td></tr></tbody></table><h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><p>所关联的表</p><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>type显示的是访问类型，是较为重要的一个指标，结果值从最好到最坏依次是：</p><p>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL </p><p>常用的：</p><p>system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;ALL</p><p>一般来说，得保证查询至少达到range级别，最好能达到ref。</p><ul><li><p><strong>system</strong>：表只有一行记录（等于系统表），这是const类型的特例，平时不会出现，可以忽略不计</p></li><li><p><strong>const</strong>：表示通过索引一次就找到了，const用于比较primary key 或者 unique索引。因为只需匹配一行数据，所有很快。如果将主键置于where列表中，mysql就能将该查询转换为一个const </p></li><li><p><strong>eq_ref</strong>： 唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描。</p></li><li><p><strong>ref</strong>：非唯一性索引扫描，返回匹配某个单独值的所有行。本质是也是一种索引访问，它返回所有匹配某个单独值的行，然而他可能会找到多个符合条件的行，所以它应该属于查找和扫描的混合体 。</p></li><li><p><strong>range</strong>：只检索给定范围的行，使用一个索引来选择行。key列显示使用了那个索引。一般就是在where语句中出现了bettween、&lt;、&gt;、in等的查询。这种索引列上的范围扫描比全索引扫描要好。只需要开始于某个点，结束于另一个点，不用扫描全部索引 </p></li><li><p><strong>index</strong>：Full Index Scan，index与ALL区别为index类型只遍历索引树。这通常为ALL块，应为索引文件通常比数据文件小。（Index与ALL虽然都是读全表，但index是从索引中读取，而ALL是从硬盘读取） </p></li><li><p><strong>ALL</strong>：Full Table Scan，遍历全表以找到匹配的行</p></li></ul><h3 id="possible-keys与key"><a href="#possible-keys与key" class="headerlink" title="possible_keys与key"></a>possible_keys与key</h3><ul><li><p>possible_keys：可能使用的索引。</p></li><li><p>key：实际使用的索引，如果为NULL，则没有使用索引。</p></li></ul><h3 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h3><p>Key_len表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好。如果充分用了索引key_len会比没有充分用到索引要长。key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的。</p><ul><li>根据这个值，就可以判断索引使用情况，特别是在组合索引的时候，判断所有的索引字段是否都被查询用到。</li><li>char和varchar跟字符编码也有密切的联系。</li><li>latin1占用1个字节，gbk占用2个字节，utf8占用3个字节。（不同字符编码占用的存储空间不同）</li></ul><h4 id="字符类型key-len计算"><a href="#字符类型key-len计算" class="headerlink" title="字符类型key_len计算"></a>字符类型key_len计算</h4><p>变长字段（varchar）需要额外的2个字节（VARCHAR值保存时只保存需要的字符数，另加一个字节来记录长度（如果列声明的长度超过255，则使用两个字节），所以VARCAHR索引长度计算时候要加2），固定长度字段（char）不需要额外的字节。 </p><p>而如果允许为NULL都需要1个字节的额外空间，所以索引字段最好不要允许为NULL，因为允许为NULL会让统计更加复杂并且需要额外的存储空间。</p><p>复合索引有最左前缀的特性，如果复合索引能全部使用上，则是复合索引字段的索引长度之和，这也可以用来判定复合索引是否部分使用，还是全部使用。</p><h4 id="整数-浮点数-时间类型的索引长度"><a href="#整数-浮点数-时间类型的索引长度" class="headerlink" title="整数/浮点数/时间类型的索引长度"></a>整数/浮点数/时间类型的索引长度</h4><p>整数/浮点数/时间类型的索引长度等于字段本身的字段长度，如果为NULL就等于字段本身的长度+1。</p><p>datetime类型在5.6中字段长度是5个字节，datetime类型在5.5中字段长度是8个字节。</p><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值</p><h3 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h3><p>根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数</p><h3 id="extra"><a href="#extra" class="headerlink" title="extra"></a>extra</h3><p>包含不适合在其他列中显示但十分重要的额外信息。</p><p>Using filesort：文件排序，表示MySQL中无法利用索引完成的排序。当查询的排序规则与复合索引顺序不同时，MySQL会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。。</p><p>Using temporary：表示使用了临时表保存中间结果，常见于排序order by和分组查询group by。</p><p>Using index：表示使用了覆盖索引。覆盖索引表示在获取查询结果时只需要遍历索引树，不需要从硬盘中读取。</p><p>Using where：表示使用了where或者on过滤。</p><p>Using join buffer：表示使用了连接缓存，连接缓存的大小可以使用<code>show VARIABLES like &#39;%join_buffer_size%&#39;</code></p><p>Impossible where：where子句的值总是false，不能用来获取任何元组。</p><h2 id="SQL优化策略"><a href="#SQL优化策略" class="headerlink" title="SQL优化策略"></a>SQL优化策略</h2><p><strong>尽量全值匹配</strong>：如果使用复合索引，应使where条件中尽量包含复合索引的全部列。</p><p><strong>最佳左前缀法则</strong>：复合索引在使用时要遵守最左前缀法则，即查询条件应从从索引最左侧的列开始并且不跳过索引中间的列。</p><p><strong>不在索引列上做任何操作</strong>：索引列上做任何操作（计数、函数、类型转换）会导致索引失效而转向全表扫描。</p><p><strong>进行范围条件查询的列放最后</strong>：如果对复合索引中的列进行范围查询，而且该列处于复合索引的中间位置，会导致符合索引后面的索引列全部失效。</p><p><strong>尽量使用覆盖索引</strong>：尽量使用覆盖索引(只访问索引的查询(索引列和查询列一致))，减少select *</p><p><strong>不等于要慎用</strong>：mysql 在使用不等于（!= 或者&lt;&gt;）的时候会导致索引失效会导致全表扫描，解决方式为使用覆盖索引</p><p><strong>NULL、NOT NULL会影响索引</strong>：在列不允许为空的情况下，使用IS NULL或IS NOT NULL会导致索引失效，在列允许为空的情况下IS NOT NULL会导致索引失效，使用覆盖索引也可以解决这个问题。</p><p><strong>慎用LIKE查询</strong>：如果LIKE以通配符开头（’%abc…’）会导致索引失效变成全表扫描的操作，同样使用覆盖索引也可以解决这个问题。</p><p><strong>字符类型加引号</strong>：字符串不加单引号索引失效。</p><p><strong>OR改为UNION效率高</strong>：OR会导致索引失效，解决方式为使用UNION改写SQL。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><table><thead><tr><th>where语句</th><th>使用到的索引</th></tr></thead><tbody><tr><td>where a = 3</td><td>a</td></tr><tr><td>where a = 3 and b = 5</td><td>a,b</td></tr><tr><td>where a = 3 and b = 5 and c = 4</td><td>a,b,c</td></tr><tr><td>where b = 3 或者 where b = 3 and c = 4 或者 where c = 5</td><td>空</td></tr><tr><td>where a = 3 and c = 5</td><td>a</td></tr><tr><td>where a = 3 and b &gt;4 and c = 5</td><td>a,b</td></tr><tr><td>where a = 3 and b like ‘kk%’ and c = 4</td><td>a,b,c</td></tr><tr><td>where a = 3 and b like ‘%kk’ and c = 4</td><td>a</td></tr><tr><td>where a = 3 and b like ‘%kk%’ and c = 4</td><td>a</td></tr><tr><td>where a = 3 and b like ‘k%kk%’ and c = 4</td><td>a,b,c</td></tr></tbody></table><h3 id="记忆总结"><a href="#记忆总结" class="headerlink" title="记忆总结"></a>记忆总结</h3><ul><li><p>全值匹配我最爱，最左前缀要遵守；</p></li><li><p>带头大哥不能死，中间兄弟不能断；</p></li><li><p>索引列上少计算，范围之后全失效；</p></li><li><p>LIKE百分写最右，覆盖索引不写*；</p></li><li><p>不等空值还有OR，索引影响要注意；</p></li><li><p>VARCHAR引号不可丢， SQL优化有诀窍。</p></li></ul><h3 id="数据的迁移"><a href="#数据的迁移" class="headerlink" title="数据的迁移"></a>数据的迁移</h3><p>使用前需要确认MySQL是否允许允许导入导出。</p><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">VARIABLES</span> <span class="hljs-keyword">like</span> <span class="hljs-string">'secure_file_priv'</span></code></pre><ul><li><p>secure_file_priv为NULL时，表示限制MySQL不允许导入或导出。</p></li><li><p>secure_file_priv为/tmp时，表示限制MySQL只能在/tmp目录中执行导入导出，其他目录不能执行。</p></li><li><p>secure_file_priv没有值时，表示不限制MySQL在任意目录的导入导出。</p></li></ul><p>修改方法为将<code>source_file_priv=&#39;&#39;</code>添加到my.cnf文件中。</p><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">into</span> <span class="hljs-keyword">OUTFILE</span> <span class="hljs-string">'D:\\product.txt'</span> <span class="hljs-keyword">from</span> product_info    <span class="hljs-comment">-- 将表中的数据迁移到product.txt文件中</span><span class="hljs-keyword">load</span> <span class="hljs-keyword">data</span> <span class="hljs-keyword">INFILE</span> <span class="hljs-string">'D:\\product.txt'</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">table</span> product_info    <span class="hljs-comment">-- 将product.txt文件中的数据导入到表中</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>MySQL进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL的慢查询</title>
    <link href="/blog/2020/04/02/MySQL%E7%9A%84%E6%85%A2%E6%9F%A5%E8%AF%A2/"/>
    <url>/blog/2020/04/02/MySQL%E7%9A%84%E6%85%A2%E6%9F%A5%E8%AF%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="慢查询的配置"><a href="#慢查询的配置" class="headerlink" title="慢查询的配置"></a>慢查询的配置</h2><p>慢查询日志是指MySQL记录所有执行超过long_query_time参数设定的时间阈值的SQL语句的日志。该日志能为SQL语句的优化带来很好的帮助。默认情况下，慢查询日志是关闭的，要使用慢查询日志功能，首先要开启慢查询日志功能。</p><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><ul><li>slow_query_log 启动停止技术慢查询日志</li><li>slow_query_log_file 指定慢查询日志得存储路径及文件（默认和数据文件放一起）</li><li>long_query_time 指定记录慢查询日志SQL执行时间得伐值（单位:秒，默认10秒）</li><li>log_queries_not_using_indexes 是否记录未使用索引的SQL</li><li>log_output 日志存放的地方[TABLE][FILE][FILE,TABLE]</li></ul><p>通过下面命令查看下上面的配置：</p><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">VARIABLES</span> <span class="hljs-keyword">like</span> <span class="hljs-string">'%slow_query_log%'</span><span class="hljs-keyword">show</span> <span class="hljs-keyword">VARIABLES</span> <span class="hljs-keyword">like</span> <span class="hljs-string">'%slow_query_log_file%'</span><span class="hljs-keyword">show</span> <span class="hljs-keyword">VARIABLES</span> <span class="hljs-keyword">like</span> <span class="hljs-string">'%long_query_time%'</span><span class="hljs-keyword">show</span> <span class="hljs-keyword">VARIABLES</span> <span class="hljs-keyword">like</span> <span class="hljs-string">'%log_queries_not_using_indexes%'</span><span class="hljs-keyword">show</span> <span class="hljs-keyword">VARIABLES</span> <span class="hljs-keyword">like</span> <span class="hljs-string">'%log_output%'</span></code></pre><p>通过下面命令设置上面的配置：</p><pre><code class="hljs sql"><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> long_query_time=<span class="hljs-number">5</span>;  <span class="hljs-comment">-- 默认10秒，这里设置为5秒</span><span class="hljs-keyword">set</span> <span class="hljs-keyword">GLOBAL</span> slow_query_log = <span class="hljs-number">1</span>; <span class="hljs-comment">-- 开启慢查询日志</span><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> log_output=<span class="hljs-string">'FILE,TABLE'</span> <span class="hljs-comment">-- 记录在表跟文件中，项目开发中日志只能记录在日志文件中，不能记表中</span></code></pre><p>设置完成后在datadir中就可以看到慢查询语句，数据库的datadir查看方式为<code>show VARIABLES like &#39;datadir&#39;</code></p><h2 id="慢查询解读"><a href="#慢查询解读" class="headerlink" title="慢查询解读"></a>慢查询解读</h2><pre><code class="hljs sql"><span class="hljs-comment"># User@Host: root[root] @ localhost [127.0.0.1]  Id:   10    -- 用户名 、用户的IP信息、线程ID号</span><span class="hljs-comment"># Query_time: 0.001042    -- 执行花费的时间【单位：毫秒】</span><span class="hljs-comment"># Lock_time:0.000000    -- 执行获得锁的时间</span><span class="hljs-comment"># Rows_sent: 2    -- 获得的结果行数</span><span class="hljs-comment"># Rows_examined: 2    -- 扫描的数据行数</span><span class="hljs-keyword">SET</span> <span class="hljs-built_in">timestamp</span>=<span class="hljs-number">1535462721</span>;    <span class="hljs-comment">-- 这SQL执行的具体时间</span><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> mvarchive <span class="hljs-keyword">LIMIT</span> O, <span class="hljs-number">1000</span>;    <span class="hljs-comment">-- 具体的SQL语句</span></code></pre><h2 id="慢查询分析"><a href="#慢查询分析" class="headerlink" title="慢查询分析"></a>慢查询分析</h2><p>慢查询的日志记录非常多，要从里面找寻一条查询慢的日志并不是很容易的事情，一般来说都需要一些工具辅助才能快速定位到需要优化的SQL语句，下面介绍两个慢查询辅助工具。</p><h3 id="mysql-dumpslow"><a href="#mysql-dumpslow" class="headerlink" title="mysql dumpslow"></a>mysql dumpslow</h3><p>常用的慢查询日志分析工具，汇总除查询条件外其他完全相同的SQL，并将分析结果按照参数中所指定的顺序输出。</p><p>使用方法：</p><pre><code class="hljs vim">mysqldumpslow -s r -t <span class="hljs-number">10</span> slow-mysql.<span class="hljs-built_in">log</span>-s 排序规则，可选参数[<span class="hljs-keyword">c</span>,t,<span class="hljs-keyword">l</span>,r,at,<span class="hljs-keyword">al</span>,<span class="hljs-keyword">ar</span>]   <span class="hljs-keyword">c</span>:总次数   <span class="hljs-variable">t:</span>总时间   <span class="hljs-variable">l:</span>锁的时间   r:总数据行   at,<span class="hljs-keyword">al</span>,<span class="hljs-keyword">ar</span>:平均数[例如：at = 总时间/总次数]-t 选取条数</code></pre><h3 id="pt-query-digest"><a href="#pt-query-digest" class="headerlink" title="pt_query_digest"></a>pt_query_digest</h3><p>是用于分析mysql慢查询的一个工具，与mysqldumpshow工具相比，py-query_digest 工具的分析结果更具体，更完善。但可能因为某些原因如权限不足等，无法在服务器上记录查询。</p><h4 id="安装方式"><a href="#安装方式" class="headerlink" title="安装方式"></a>安装方式</h4><pre><code class="hljs sql">安装依赖工具：yum <span class="hljs-keyword">install</span> perl-DBIyum <span class="hljs-keyword">install</span> perl-DBD-MySQLyum <span class="hljs-keyword">install</span> perl-<span class="hljs-built_in">Time</span>-HiResyum <span class="hljs-keyword">install</span> perl-IO-Socket-SSLyum <span class="hljs-keyword">install</span> perl-Digest-<span class="hljs-keyword">MD5</span>下载pt-<span class="hljs-keyword">query</span>-disgest、授权、将其放到/usr/<span class="hljs-keyword">bin</span>下：wget percona.com/<span class="hljs-keyword">get</span>/pt-<span class="hljs-keyword">query</span>-digestchmod u+x pt-<span class="hljs-keyword">query</span>-digestmv /usr/src/pt-<span class="hljs-keyword">query</span>-digest /usr/<span class="hljs-keyword">bin</span>/perl ./pt-<span class="hljs-keyword">query</span>-digest  <span class="hljs-comment">--explain h=127.0.0.1,u=root,p=root1234%  /usr/local/mysql/data/mysql-slow.log</span></code></pre><h4 id="语法与重要选项"><a href="#语法与重要选项" class="headerlink" title="语法与重要选项"></a>语法与重要选项</h4><pre><code class="hljs brainfuck"><span class="hljs-comment">pt</span><span class="hljs-literal">-</span><span class="hljs-comment">query</span><span class="hljs-literal">-</span><span class="hljs-comment">digest</span> <span class="hljs-title">[</span><span class="hljs-comment">OPTIONS</span><span class="hljs-title">]</span> <span class="hljs-title">[</span><span class="hljs-comment">FILES</span><span class="hljs-title">]</span> <span class="hljs-title">[</span><span class="hljs-comment">DSN</span><span class="hljs-title">]</span>--<span class="hljs-comment">create</span><span class="hljs-literal">-</span><span class="hljs-comment">review</span><span class="hljs-literal">-</span><span class="hljs-comment">table</span>  <span class="hljs-comment">当使用</span>--<span class="hljs-comment">review参数把分析结果输出到表中时，如果没有表就自动创建。</span><span class="hljs-comment"></span>--<span class="hljs-comment">create</span><span class="hljs-literal">-</span><span class="hljs-comment">history</span><span class="hljs-literal">-</span><span class="hljs-comment">table</span>  <span class="hljs-comment">当使用</span>--<span class="hljs-comment">history参数把分析结果输出到表中时，如果没有表就自动创建。</span><span class="hljs-comment"></span>--<span class="hljs-comment">filter</span>  <span class="hljs-comment">对输入的慢查询按指定的字符串进行匹配过滤后再进行分析</span><span class="hljs-comment"></span>--<span class="hljs-comment">limit限制输出结果百分比或数量，默认值是20</span><span class="hljs-string">,</span><span class="hljs-comment">即将最慢的20条语句输出，如果是50%则按总响应时间占比从大到小排序，输出到总和达到50%位置截止。</span><span class="hljs-comment"></span>--<span class="hljs-comment">host</span>  <span class="hljs-comment">mysql服务器地址</span><span class="hljs-comment"></span>--<span class="hljs-comment">user</span>  <span class="hljs-comment">mysql用户名</span><span class="hljs-comment"></span>--<span class="hljs-comment">password</span>  <span class="hljs-comment">mysql用户密码</span><span class="hljs-comment"></span>--<span class="hljs-comment">history</span> <span class="hljs-comment">将分析结果保存到表中，分析结果比较详细，下次再使用</span>--<span class="hljs-comment">history时，如果存在相同的语句，且查询所在的时间区间和历史表中的不同，则会记录到数据表中，可以通过查询同一CHECKSUM来比较某类型查询的历史变化。</span><span class="hljs-comment"></span>--<span class="hljs-comment">review</span> <span class="hljs-comment">将分析结果保存到表中，这个分析只是对查询条件进行参数化，一个类型的查询一条记录，比较简单。当下次使用</span>--<span class="hljs-comment">review时，如果存在相同的语句分析，就不会记录到数据表中。</span><span class="hljs-comment"></span>--<span class="hljs-comment">output</span> <span class="hljs-comment">分析结果输出类型，值可以是report(标准分析报告)、slowlog(Mysql</span> <span class="hljs-comment">slow</span> <span class="hljs-comment">log)、json、json</span><span class="hljs-literal">-</span><span class="hljs-comment">anon，一般使用report，以便于阅读。</span><span class="hljs-comment"></span>--<span class="hljs-comment">since</span> <span class="hljs-comment">从什么时间开始分析，值为字符串，可以是指定的某个”yyyy</span><span class="hljs-literal">-</span><span class="hljs-comment">mm</span><span class="hljs-literal">-</span><span class="hljs-comment">dd</span> <span class="hljs-title">[</span><span class="hljs-comment">hh:mm:ss</span><span class="hljs-title">]</span><span class="hljs-comment">”格式的时间点，也可以是简单的一个时间值：s(秒)、h(小时)、m(分钟)、d(天)，如12h就表示从12小时前开始统计。</span><span class="hljs-comment"></span>--<span class="hljs-comment">until</span> <span class="hljs-comment">截止时间，配合—since可以分析一段时间内的慢查询。</span></code></pre><h4 id="用法示例"><a href="#用法示例" class="headerlink" title="用法示例"></a>用法示例</h4><p>直接分析慢查询文件:</p><pre><code class="hljs bash"><span class="hljs-comment">#分析slow.log日志，并将分析报告输入到slow_report.log中</span>shell&gt; pt-query-digest  slow.log &gt; slow_report.log</code></pre><p>分析最近12小时内的查询：</p><pre><code class="hljs bash">shell&gt; pt-query-digest  --since=12h  slow.log &gt; slow_report2.log</code></pre><p>分析指定时间范围内的查询：</p><pre><code class="hljs bash">pt-query-digest slow.log --since <span class="hljs-string">'2014-04-17 09:30:00'</span> --until <span class="hljs-string">'2014-04-17 10:00:00'</span> &gt; slow_report3.log</code></pre><p>分析指含有select语句的慢查询</p><pre><code class="hljs bash">shell&gt; pt-query-digest--filter <span class="hljs-string">'$event-&gt;&#123;fingerprint&#125; =~ m/^select/i'</span> slow.log&gt; slow_report4.log</code></pre><p>针对某个用户的慢查询</p><pre><code class="hljs bash">shell&gt; pt-query-digest--filter <span class="hljs-string">'($event-&gt;&#123;user&#125; || "") =~ m/^root/i'</span> slow.log&gt; slow_report5.log</code></pre><p>查询所有所有的全表扫描或full join的慢查询</p><pre><code class="hljs bash">pt-query-digest--filter <span class="hljs-string">'(($event-&gt;&#123;Full_scan&#125; || "") eq "yes") ||(($event-&gt;&#123;Full_join&#125; || "") eq "yes")'</span> slow.log&gt; slow_report6.log</code></pre><p>把查询保存到query_review表</p><pre><code class="hljs bash">pt-query-digest  --user=root –password=abc123 --review  h=localhost,D=<span class="hljs-built_in">test</span>,t=query_review--create-review-table  slow.log</code></pre><p>把查询保存到query_history表</p><pre><code class="hljs bash">pt-query-digest  --user=root –password=abc123 --review  h=localhost,D=<span class="hljs-built_in">test</span>,t=query_ <span class="hljs-built_in">history</span>--create-review-table  slow.log_20140401pt-query-digest  --user=root –password=abc123--review  h=localhost,D=<span class="hljs-built_in">test</span>,t=query_history--create-review-table  slow.log_20140402</code></pre><p>通过tcpdump抓取mysql的tcp协议数据，然后再分析</p><pre><code class="hljs bash">tcpdump -s 65535 -x -nn -q -tttt -i any -c 1000 port 3306 &gt; mysql.tcp.txtpt-query-digest --<span class="hljs-built_in">type</span> tcpdump mysql.tcp.txt&gt; slow_report9.log</code></pre><p>分析binlog</p><pre><code class="hljs bash">mysqlbinlog mysql-bin.000093 &gt; mysql-bin000093.sqlpt-query-digest  --<span class="hljs-built_in">type</span>=binlog  mysql-bin000093.sql &gt; slow_report10.log</code></pre><p>分析general log</p><pre><code class="hljs bash">pt-query-digest  --<span class="hljs-built_in">type</span>=genlog  localhost.log &gt; slow_report11.log</code></pre><h4 id="报告参数说明"><a href="#报告参数说明" class="headerlink" title="报告参数说明"></a>报告参数说明</h4>{% asset_img pic1.png %}<h5 id="第一部分：总体统计结果"><a href="#第一部分：总体统计结果" class="headerlink" title="第一部分：总体统计结果"></a>第一部分：总体统计结果</h5><ul><li>Overall：总共有多少条查询</li><li>Time range：查询执行的时间范围</li><li>unique：唯一查询数量，即对查询条件进行参数化以后，总共有多少个不同的查询</li><li>total：总计 min：最小 max：最大 avg：平均</li><li>95%：把所有值从小到大排列，位置位于95%的那个数，这个数一般最具有参考价值</li><li>median：中位数，把所有值从小到大排列，位置位于中间那个数</li></ul><pre><code class="hljs angelscript"># 该工具执行日志分析的用户时间，系统时间，物理内存占用大小，虚拟内存占用大小# <span class="hljs-number">340</span>ms user time, <span class="hljs-number">140</span>ms system time, <span class="hljs-number">23.99</span>M rss, <span class="hljs-number">203.11</span>M vsz# 工具执行时间# Current date: Fri Nov <span class="hljs-number">25</span> <span class="hljs-number">02</span>:<span class="hljs-number">37</span>:<span class="hljs-number">18</span> <span class="hljs-number">2016</span># 运行分析工具的主机名# Hostname: localhost.localdomain# 被分析的文件名# Files: slow.log# 语句总数量，唯一的语句数量，QPS，并发数# Overall: <span class="hljs-number">2</span> total, <span class="hljs-number">2</span> unique, <span class="hljs-number">0.01</span> QPS, <span class="hljs-number">0.01</span>x concurrency # 日志记录的时间范围# Time range: <span class="hljs-number">2016</span><span class="hljs-number">-11</span><span class="hljs-number">-22</span> <span class="hljs-number">06</span>:<span class="hljs-number">06</span>:<span class="hljs-number">18</span> to <span class="hljs-number">06</span>:<span class="hljs-number">11</span>:<span class="hljs-number">40</span># 属性    总计  最小 最大 平均 <span class="hljs-number">95</span>% 标准 中等# Attribute   total  min  max  avg  <span class="hljs-number">95</span>% stddev median# ============  ======= ======= ======= ======= ======= ======= =======# 语句执行时间# Exec time    <span class="hljs-number">3</span>s <span class="hljs-number">640</span>ms  <span class="hljs-number">2</span>s  <span class="hljs-number">1</span>s  <span class="hljs-number">2</span>s <span class="hljs-number">999</span>ms  <span class="hljs-number">1</span>s# 锁占用时间# Lock time   <span class="hljs-number">1</span>ms  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>ms <span class="hljs-number">723</span>us  <span class="hljs-number">1</span>ms  <span class="hljs-number">1</span>ms <span class="hljs-number">723</span>us# 发送到客户端的行数# Rows sent    <span class="hljs-number">5</span>  <span class="hljs-number">1</span>  <span class="hljs-number">4</span> <span class="hljs-number">2.50</span>  <span class="hljs-number">4</span> <span class="hljs-number">2.12</span> <span class="hljs-number">2.50</span># select语句扫描行数# Rows examine  <span class="hljs-number">186.17</span>k  <span class="hljs-number">0</span> <span class="hljs-number">186.17</span>k <span class="hljs-number">93.09</span>k <span class="hljs-number">186.17</span>k <span class="hljs-number">131.64</span>k <span class="hljs-number">93.09</span>k# 查询的字符数# Query size   <span class="hljs-number">455</span>  <span class="hljs-number">15</span>  <span class="hljs-number">440</span> <span class="hljs-number">227.50</span>  <span class="hljs-number">440</span> <span class="hljs-number">300.52</span> <span class="hljs-number">227.50</span></code></pre><h5 id="第二部分：查询分组统计结果"><a href="#第二部分：查询分组统计结果" class="headerlink" title="第二部分：查询分组统计结果"></a>第二部分：查询分组统计结果</h5><ul><li>Rank：所有语句的排名，默认按查询时间降序排列，通过–order-by指定</li><li>Query ID：语句的ID，（去掉多余空格和文本字符，计算hash值）</li><li>Response：总的响应时间</li><li>time：该查询在本次分析中总的时间占比</li><li>calls：执行次数，即本次分析总共有多少条这种类型的查询语句</li><li>R/Call：平均每次执行的响应时间</li><li>V/M：响应时间Variance-to-mean的比率</li><li>Item：查询对象</li></ul><pre><code class="hljs angelscript"># Profile# Rank Query ID   Response time Calls R/Call V/M Item# ==== ================== ============= ===== ====== ===== ===============# <span class="hljs-number">1</span> <span class="hljs-number">0xF9A57DD5A41825CA</span> <span class="hljs-number">2.0529</span> <span class="hljs-number">76.2</span>%  <span class="hljs-number">1</span> <span class="hljs-number">2.0529</span> <span class="hljs-number">0.00</span> SELECT# <span class="hljs-number">2</span> <span class="hljs-number">0x4194D8F83F4F9365</span> <span class="hljs-number">0.6401</span> <span class="hljs-number">23.8</span>%  <span class="hljs-number">1</span> <span class="hljs-number">0.6401</span> <span class="hljs-number">0.00</span> SELECT wx_member_base</code></pre><h5 id="第三部分：每一种查询的详细统计结果"><a href="#第三部分：每一种查询的详细统计结果" class="headerlink" title="第三部分：每一种查询的详细统计结果"></a>第三部分：每一种查询的详细统计结果</h5><p>由下面查询的详细统计结果，最上面的表格列出了执行次数、最大、最小、平均、95%等各项目的统计。</p><ul><li>ID：查询的ID号，和上图的Query ID对应</li><li>Databases：数据库名</li><li>Users：各个用户执行的次数（占比）</li><li>Query_time distribution ：查询时间分布, 长短体现区间占比，本例中1s-10s之间查询数量是10s以上的两倍。</li><li>Tables：查询中涉及到的表</li><li>Explain：SQL语句</li></ul><pre><code class="hljs clean"># Query <span class="hljs-number">1</span>: <span class="hljs-number">0</span> QPS, <span class="hljs-number">0</span>x concurrency, ID <span class="hljs-number">0xF9A57DD5A41825CA</span> at byte <span class="hljs-number">802</span> # This item is included <span class="hljs-keyword">in</span> the report because it matches --limit.# Scores: V/M = <span class="hljs-number">0.00</span># Time range: all events occurred at <span class="hljs-number">2016</span><span class="hljs-number">-11</span><span class="hljs-number">-22</span> <span class="hljs-number">06</span>:<span class="hljs-number">11</span>:<span class="hljs-number">40</span># Attribute pct total  min  max  avg  <span class="hljs-number">95</span>% stddev median# ============ === ======= ======= ======= ======= ======= ======= =======# Count   <span class="hljs-number">50</span>  <span class="hljs-number">1</span># Exec time  <span class="hljs-number">76</span>  <span class="hljs-number">2</span>s  <span class="hljs-number">2</span>s  <span class="hljs-number">2</span>s  <span class="hljs-number">2</span>s  <span class="hljs-number">2</span>s  <span class="hljs-number">0</span>  <span class="hljs-number">2</span>s# Lock time  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span># Rows sent  <span class="hljs-number">20</span>  <span class="hljs-number">1</span>  <span class="hljs-number">1</span>  <span class="hljs-number">1</span>  <span class="hljs-number">1</span>  <span class="hljs-number">1</span>  <span class="hljs-number">0</span>  <span class="hljs-number">1</span># Rows examine <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span># Query size  <span class="hljs-number">3</span>  <span class="hljs-number">15</span>  <span class="hljs-number">15</span>  <span class="hljs-number">15</span>  <span class="hljs-number">15</span>  <span class="hljs-number">15</span>  <span class="hljs-number">0</span>  <span class="hljs-number">15</span># String:# Databases test# Hosts  <span class="hljs-number">192.168</span><span class="hljs-number">.8</span><span class="hljs-number">.1</span># Users  mysql# Query_time distribution# <span class="hljs-number">1</span>us# <span class="hljs-number">10</span>us# <span class="hljs-number">100</span>us# <span class="hljs-number">1</span>ms# <span class="hljs-number">10</span>ms# <span class="hljs-number">100</span>ms# <span class="hljs-number">1</span>s ################################################################# <span class="hljs-number">10</span>s+# EXPLAIN <span class="hljs-comment">/*!50100 PARTITIONS*/</span>select sleep(<span class="hljs-number">2</span>)\G</code></pre>]]></content>
    
    
    <categories>
      
      <category>MySQL进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL的业务设计</title>
    <link href="/blog/2020/04/01/MySQL%E7%9A%84%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1/"/>
    <url>/blog/2020/04/01/MySQL%E7%9A%84%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="逻辑设计"><a href="#逻辑设计" class="headerlink" title="逻辑设计"></a>逻辑设计</h2><h3 id="数据库设计的三大范式"><a href="#数据库设计的三大范式" class="headerlink" title="数据库设计的三大范式"></a>数据库设计的三大范式</h3><h4 id="一、要求每一列属性值都不可再分，确保每一列的原子性"><a href="#一、要求每一列属性值都不可再分，确保每一列的原子性" class="headerlink" title="一、要求每一列属性值都不可再分，确保每一列的原子性"></a>一、要求每一列属性值都不可再分，确保每一列的原子性</h4><img src="/blog/2020/04/01/MySQL%E7%9A%84%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1/pic1.png" srcset="/blog/img/loading.gif" class><p>这张表的name-age列具有name跟age两个属性，不符合第一个范式，这时候就需要对name-age列进行拆分。</p><img src="/blog/2020/04/01/MySQL%E7%9A%84%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1/pic2.png" srcset="/blog/img/loading.gif" class><h4 id="二、必须满足第一范式，并且所有非主属性都完全依赖于主键即不允许有第二主键。"><a href="#二、必须满足第一范式，并且所有非主属性都完全依赖于主键即不允许有第二主键。" class="headerlink" title="二、必须满足第一范式，并且所有非主属性都完全依赖于主键即不允许有第二主键。"></a>二、必须满足第一范式，并且所有非主属性都完全依赖于主键即不允许有第二主键。</h4><img src="/blog/2020/04/01/MySQL%E7%9A%84%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1/pic3.png" srcset="/blog/img/loading.gif" class><p>一个订单有多个产品，所以订单的主键为订单ID和产品ID组成的联合主键，这样的设计不符合第二范式，而且产品ID和订单ID没有强关联，所以需要把订单表进行拆分为订单表与订单与商品的中间表</p><img src="/blog/2020/04/01/MySQL%E7%9A%84%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1/pic4.png" srcset="/blog/img/loading.gif" class><h4 id="三、必须满足第二范式，并且数据不能存在传递关系，即每个属性都跟主键有直接关系而不是间接关系。"><a href="#三、必须满足第二范式，并且数据不能存在传递关系，即每个属性都跟主键有直接关系而不是间接关系。" class="headerlink" title="三、必须满足第二范式，并且数据不能存在传递关系，即每个属性都跟主键有直接关系而不是间接关系。"></a>三、必须满足第二范式，并且数据不能存在传递关系，即每个属性都跟主键有直接关系而不是间接关系。</h4><img src="/blog/2020/04/01/MySQL%E7%9A%84%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1/pic5.png" srcset="/blog/img/loading.gif" class><p>此时，如果客户编号发生改变，用户姓名也会改变，这样不符合第三大范式，应该把客户姓名这一列删除</p><h3 id="反范式设计"><a href="#反范式设计" class="headerlink" title="反范式设计"></a>反范式设计</h3><p>范式设计是为了尽可能的降低数据的冗余，完全符合范式化的设计有时并不能得到良好得SQL查询性能。反范式化是针对范式化而言得，是为了性能而适当得对数据库设计范式得要求进行违反，允许存在少量得冗余，换句话来说反范式化就是使用空间来换取时间。</p><h2 id="物理设计"><a href="#物理设计" class="headerlink" title="物理设计"></a>物理设计</h2><h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><ul><li>可读性原则：使用下划线来格式化的库对象名字以获得良好的可读性</li><li>表意性原则：对象的名字应该能够描述它所表示的对象，对于存储过程，存储过程应该能够体现存储过程的功能。</li><li>长名原则：尽可能少使用或者不使用缩写</li></ul><h3 id="存储引擎的选择"><a href="#存储引擎的选择" class="headerlink" title="存储引擎的选择"></a>存储引擎的选择</h3><table><thead><tr><th><strong>功 能</strong></th><th><strong>MYISAM</strong></th><th><strong>Memory</strong></th><th><strong>InnoDB</strong></th><th><strong>Archive</strong></th></tr></thead><tbody><tr><td>存储限制</td><td>256TB</td><td>RAM</td><td>64TB</td><td>None</td></tr><tr><td>支持事务</td><td>No</td><td>No</td><td>Yes</td><td>No</td></tr><tr><td>支持全文索引</td><td>Yes</td><td>No</td><td>No</td><td>No</td></tr><tr><td>支持数索引</td><td>Yes</td><td>Yes</td><td>Yes</td><td>No</td></tr><tr><td>支持哈希索引</td><td>No</td><td>Yes</td><td>No</td><td>No</td></tr><tr><td>支持数据缓存</td><td>No</td><td>N/A</td><td>Yes</td><td>No</td></tr><tr><td>支持外键</td><td>No</td><td>No</td><td>Yes</td><td>No</td></tr></tbody></table><p>如果要提供提交、回滚、崩溃恢复能力的事物安全（ACID兼容）能力，并要求实现并发控制，InnoDB是一个好的选择。</p><p>如果数据表主要用来插入和查询记录，则MyISAM引擎能提供较高的处理效率。</p><p>如果只是临时存放数据，数据量不大，并且不需要较高的数据安全性，可以选择将数据保存在内存中的Memory引擎，MySQL中使用该引擎作为临时表，存放查询的中间结果。</p><p>如果只有INSERT和SELECT操作，可以选择Archive，Archive支持高并发的插入操作，但是本身不是事务安全的。Archive非常适合存储归档数据，如记录日志信息可以使用Archive。</p><p>使用哪一种引擎需要灵活选择，<strong>一个数据库中多个表可以使用不同引擎以满足各种性能和实际需求</strong>，使用合适的存储引擎，将会提高整个数据库的性能</p><h3 id="数据类型选择"><a href="#数据类型选择" class="headerlink" title="数据类型选择"></a>数据类型选择</h3><p>选择原则</p><ul><li><p><strong>更小的通常更好</strong>：一般情况下选择可以正确存储数据的最小数据类型。越小的数据类型通常更快，占用磁盘，内存和CPU缓存更小。</p></li><li><p><strong>简单就好</strong>：简单的数据类型的操作通常需要更少的CPU周期。例如：整型比字符操作代价要小得多，因为字符集和校对规则(排序规则)使字符比整型比较更加复杂。</p></li><li><p><strong>尽量避免NULL</strong>:尽量制定列为NOT NULL，除非真的需要NULL类型的值。因为可能为NULL列使得索引，索引统计和值比较都更复杂。可为NULL的列会使用更多的存储空间，在MySQL里也需要特殊处理。</p></li></ul><p>当一个列可以选择多种数据类型时</p><ul><li>优先考虑数字类型</li><li>其次是日期、时间类型</li><li>最后是字符类型</li><li>对于相同级别的数据类型，应该优先选择占用空间小的数据类型</li></ul>]]></content>
    
    
    <categories>
      
      <category>MySQL进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL中的锁和事务</title>
    <link href="/blog/2020/03/31/MySQL%E4%B8%AD%E7%9A%84%E9%94%81%E5%92%8C%E4%BA%8B%E5%8A%A1/"/>
    <url>/blog/2020/03/31/MySQL%E4%B8%AD%E7%9A%84%E9%94%81%E5%92%8C%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="锁的简介"><a href="#锁的简介" class="headerlink" title="锁的简介"></a>锁的简介</h2><h3 id="锁的类型"><a href="#锁的类型" class="headerlink" title="锁的类型"></a>锁的类型</h3><ul><li>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。</li><li>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</li><li>页面锁（gap锁，间隙锁）：开销界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</li></ul><h3 id="锁的选择"><a href="#锁的选择" class="headerlink" title="锁的选择"></a>锁的选择</h3><p>从锁的角度来说，表级锁更适合以查询为主，只有少量按索引条件更新数据的应用，行级锁更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用。锁的使用需要根据具体应用的特点来确定，不能一概而论。</p><h2 id="MyISAM锁"><a href="#MyISAM锁" class="headerlink" title="MyISAM锁"></a>MyISAM锁</h2><p>MyISAM引擎只支持表锁，表锁又分为表共享读锁（Table Read Lock）和表独占写锁（Table Write Lock）。</p><p>读锁的语法为：<code>lock table 表名 read</code>，写锁的语法为：<code>lock table 表名write</code>，解锁语法为：<code>unlock tables;</code></p><p>当使用读锁锁住MyISAM表时，当前会话对这张表的写操作以及对其他表（如果给这张表起别名MySQL会认为这张表不是被锁住的表）的读写操作都会报错，其他会话对这张表的写操作会被阻塞，对这张表的读操作以及其他表的操作不会被影响，也可以使用读锁锁住这张表，但写锁会被阻塞。</p><p>当使用写锁锁住MyISAM表时，对其他表的读写操作都会报错，其他会话对这张表的读写操作以及对这张表的锁操作会被阻塞，对其他表的操作不会被影响。</p><h2 id="InnnoDB锁"><a href="#InnnoDB锁" class="headerlink" title="InnnoDB锁"></a>InnnoDB锁</h2><p>InnoDB支持多种锁粒度，默认使用行锁，锁粒度最小，锁冲突发生的概率最低，支持的并发度也最高，但系统消耗成本也相对较高。共享锁与排他锁是InnoDB实现的两种标准的行锁。</p><p>InnoDB有三种锁算法——记录锁、gap间隙锁、还有结合了记录锁与间隙锁的next-key锁，InnoDB对于行的查询加锁是使用的是next-key locking这种算法，一定程度上解决了幻读问题。</p><p>共享锁和排他锁的关系为：</p><ul><li><p>当一个事务对某几行上共享锁时，允许其他事务对这几行进行读操作，但不允许其进行写操作，也不允许其他事务给这几行上排它锁，但允许上读锁。</p></li><li><p>当一个事务对某几个上排它锁时，不允许其他事务写，但允许读。更不允许其他事务给这几行上任何锁。包括写锁。 </p></li></ul><p>共享锁的语法：<code>lock in share mode</code>，例如： <code>select * from 表 where 条件 lock in share mode;</code></p><p>排它锁的写法：<code>for update</code>，例如：<code>select * from 表 where 条件 for update;</code></p><p>注意：</p><ol><li><p>两个事务不能锁同一条数据。</p></li><li><p>insert、delete、update在事务中都会自动默认加上排它锁。</p></li><li><p>行锁必须有索引才能实现，否则会自动锁全表，那么就不是行锁了。</p></li></ol><h2 id="锁的等待问题"><a href="#锁的等待问题" class="headerlink" title="锁的等待问题"></a>锁的等待问题</h2><p>实际开发过程中，你的同事在debug程序的时候可能会锁住一部分数据库的数据，而这个时候再操作这部分数据就可能会超时，这就是锁等待问题的一个体现。</p><p>通过下面这个语句可以查看数据库中锁的情况。</p><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> information_schema.INNODB_LOCKS;</code></pre><p>如果数据库版本为5.7可以通过下面这个指令获取pid，之后使用最下面的kill命令，退出阻塞的SQL</p><pre><code class="hljs cs"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> sys.innodb_lock_waits</code></pre><p>如果不是5.7版本，可以通过下面这条语句来查看阻塞的SQL的线程号</p><pre><code class="hljs mipsasm">SELECT  r.trx_id <span class="hljs-keyword">waiting_trx_id,</span><span class="hljs-keyword"> </span> r.trx_mysql_thread_id <span class="hljs-keyword">waiting_thread,</span><span class="hljs-keyword"> </span> r.trx_query <span class="hljs-keyword">waiting_query,</span><span class="hljs-keyword"> </span> <span class="hljs-keyword">b.trx_id </span><span class="hljs-keyword">blocking_trx_id,</span><span class="hljs-keyword"> </span> <span class="hljs-keyword">b.trx_mysql_thread_id </span><span class="hljs-keyword">blocking_thread</span><span class="hljs-keyword">FROM</span><span class="hljs-keyword"> </span> information_schema.innodb_lock_waits wINNER <span class="hljs-keyword">JOIN</span><span class="hljs-keyword"> </span> information_schema.innodb_trx <span class="hljs-keyword">b </span>ON <span class="hljs-keyword">b.trx_id </span>= w.<span class="hljs-keyword">blocking_trx_id</span><span class="hljs-keyword">INNER </span><span class="hljs-keyword">JOIN</span><span class="hljs-keyword"> </span> information_schema.innodb_trx r ON r.trx_id = w.requesting_trx_id;</code></pre><p>得到线程号后就可以通过<code>kill [线程号]</code>这样来退出阻塞的线程。</p><p>不过如果你的同事在进行比较重要的调试，强行kill掉他的SQL可能会影响同事间的关系，如果不是迫不得已这种做法还是少用比较好。</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>现在的很多软件都是多用户，多程序，多线程的，对同一个表可能同时有很多人在用，为保持数据的一致性，所以提出了事务的概念，目前只有InnoDB引擎支持事务。</p><h3 id="ACID特性"><a href="#ACID特性" class="headerlink" title="ACID特性"></a>ACID特性</h3><p>事务应该具有4个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为ACID特性。</p><ul><li>原子性（atomicity）：一个事务必须被视为一个不可分割的最小单元，整个事务中的所有操作要么全部提交成功，要么全部失败，对于一个事务来说，不可能只执行其中的一部分操作</li><li>一致性（consistency）：一致性是指事务将数据库从一种一致性转换到另外一种一致性状态，在事务开始之前和事务结束之后数据库中数据的完整性没有被破坏。</li><li>持久性（durability）：一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，已经提交的修改数据也不会丢失，如果单纯依靠是数据库，持久性并不能完全解决。</li><li>隔离性（isolation）：一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</li></ul><h3 id="并发问题"><a href="#并发问题" class="headerlink" title="并发问题"></a>并发问题</h3><p>数据库中共有四种隔离级别：未提交读（READ UNCOMMITED）、已提交读 （READ COMMITED）、可重复读（REPEATABLE READ）、可串行化（SERIALIZABLE）。MySQL默认的事务隔离级别为repeatable-read可以通过<code>show VARIABLES LIKE &#39;%tx_isolation%&#39;;</code>查看数据库目前的隔离级别。</p><p>事务并发引发的问题总共有三种：</p><ul><li><p>脏读：如果在事务B更新数据时，被事务A读取了更新的数据，然后B回滚操作，那么A读取到的数据是脏数据。</p></li><li><p>不可重复读：事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。</p></li><li><p>幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。</p></li></ul><p>不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表</p><p>与隔离级别的对应关系</p><table><thead><tr><th>事务隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>未提交读（READ UNCOMMITED）</td><td>是</td><td>是</td><td>是</td></tr><tr><td>已提交读 （READ COMMITED）</td><td>否</td><td>是</td><td>是</td></tr><tr><td>可重复读（REPEATABLE READ）</td><td>否</td><td>否</td><td>是</td></tr><tr><td>可串行化（SERIALIZABLE）</td><td>否</td><td>否</td><td>否</td></tr></tbody></table><h3 id="间隙锁（Gap-Lock）"><a href="#间隙锁（Gap-Lock）" class="headerlink" title="间隙锁（Gap Lock）"></a>间隙锁（Gap Lock）</h3><p>间隙锁（Gap Lock）是InnoDB在可重复读提交下为了解决幻读问题时引入的锁机制，间隙锁是一个在索引记录之间的间隙上的锁。</p><p>当使用唯一索引来搜索唯一行的语句时，不需要间隙锁定。如下面语句的id列有唯一索引，此时只会对id值为10的行使用记录锁。</p><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> t <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> = <span class="hljs-number">10</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;// 注意：普通查询是快照读，不需要加锁</code></pre><p>如果上面语句中id列没有建立索引或者是非唯一索引时，则语句会产生间隙锁。</p><p>如果搜索条件里有多个查询条件(即使每个列都有唯一索引)，也是会有间隙锁的。</p><p>需要注意的是，当id列上没有索引时，SQL会走聚簇索引的全表扫描进行过滤，由于过滤是在MySQL Server层面进行的。因此每条记录（无论是否满足条件）都会被加上锁。但是，为了效率考量，MySQL做了优化，对于不满足条件的记录，会在判断后<strong>放锁</strong>，最终持有的，是满足条件的记录上的锁。但是不满足条件的记录上的加锁/放锁动作是不会省略的。所以在没有索引时，不满足条件的数据行会有加锁又放锁的耗时过程。</p><h3 id="事务的使用"><a href="#事务的使用" class="headerlink" title="事务的使用"></a>事务的使用</h3><ul><li><p>开启事务：begin、START TRANSACTION（推荐）、begin work </p></li><li><p>事务回滚：rollback</p></li><li><p>事务提交：commit</p></li><li><p>设置还原点：savepoint [变量名]</p></li><li><p>回退到还原点：rollback to savepoint [变量名]</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>MySQL进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL架构与存储引擎</title>
    <link href="/blog/2020/03/30/MySQL%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    <url>/blog/2020/03/30/MySQL%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</url>
    
    <content type="html"><![CDATA[<h2 id="MySQL逻辑架构"><a href="#MySQL逻辑架构" class="headerlink" title="MySQL逻辑架构"></a>MySQL逻辑架构</h2><img src="/blog/2020/03/30/MySQL%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/pic1.png" srcset="/blog/img/loading.gif" class><h3 id="连接层"><a href="#连接层" class="headerlink" title="连接层"></a>连接层</h3><img src="/blog/2020/03/30/MySQL%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/pic2.png" srcset="/blog/img/loading.gif" class><p>当MySQL启动（MySQL服务器就是一个进程），等待客户端连接，每一个客户端连接请求，服务器都会新建一个线程处理（如果是线程池的话，则是分配一个空的线程），每个线程独立，拥有各自的内存处理空间。</p><p>show VARIABLES like ‘%max_connections%’</p><img src="/blog/2020/03/30/MySQL%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/pic3.png" srcset="/blog/img/loading.gif" class><p>连接到服务器，服务器需要对其进行验证，也就是用户名、IP、密码验证，一旦连接成功，还需要验证是否具有执行某个特定的查询权限。</p><h3 id="处理层"><a href="#处理层" class="headerlink" title="处理层"></a>处理层</h3><img src="/blog/2020/03/30/MySQL%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/pic4.png" srcset="/blog/img/loading.gif" class><p>这一层主要功能有：SQL语句的解析、优化，缓存的查询，MySQL内置函数的实现，跨存储引擎功能（所谓跨存储引擎就是说每个引擎都需提供的功能（引擎需对外提供接口）），例如：存储过程、触发器、视图等。</p><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">variables</span> <span class="hljs-keyword">like</span> <span class="hljs-string">'%query_cache_type%'</span></code></pre><p>大概步骤为：</p><ol><li><p>如果是查询语句（select语句），首先会查询缓存是否已有相应结果，有则返回结果，无则进行下一步（如果不是查询语句，同样调到下一步）</p></li><li><p>解析查询，创建一个内部数据结构（解析树），这个解析树主要用来SQL语句的语义与语法解析；</p></li><li><p>优化：优化SQL语句，例如重写查询，决定表的读取顺序，以及选择需要的索引等。这一阶段用户是可以查询的，查询服务器优化器是如何进行优化的，便于用户重构查询和修改相关配置，达到最优化。这一阶段还涉及到存储引擎，优化器会询问存储引擎，比如某个操作的开销信息、是否对特定索引有查询优化等。</p></li></ol><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">variables</span> <span class="hljs-keyword">like</span>  <span class="hljs-string">'%query_cache_type%'</span>  <span class="hljs-comment">-- 查看缓存类型，默认不开启</span><span class="hljs-keyword">show</span> <span class="hljs-keyword">variables</span> <span class="hljs-keyword">like</span>  <span class="hljs-string">'%query_cache_size%'</span>  <span class="hljs-comment">-- 查看缓存空间大小，默认值1M</span></code></pre><p>query_cache_type只能在my.cnf文件中修改，使用set修改会报错，缓存只有在两次SQL连接的数据库、协议版本、字符集等因素完全一致时才会起作用。</p><p>具体配置方法：</p><ol><li><p>将query_cache_size设置为具体的大小，具体大小是多少取决于查询的实际情况，但最好设置为1024的倍数，参考值32M。</p></li><li><p>增加一行：query_cache_type=1</p></li><li><p>保存文件后重启MySQL服务。</p></li></ol><p>如：</p><pre><code class="hljs ini"><span class="hljs-attr">query_cache_size</span>=<span class="hljs-number">128</span>M <span class="hljs-attr">query_cache_type</span>=<span class="hljs-number">1</span></code></pre><h4 id="解析查询顺序"><a href="#解析查询顺序" class="headerlink" title="解析查询顺序"></a>解析查询顺序</h4><img src="/blog/2020/03/30/MySQL%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/pic5.png" srcset="/blog/img/loading.gif" class><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>SQL编辑器会对SQL语句进行优化，例如重写查询，决定表的读取顺序，以及选择需要的索引等。这一阶段还涉及到存储引擎，优化器会询问存储引擎，比如某个操作的开销信息、是否对特定索引有查询优化等。</p><h3 id="逻辑架构"><a href="#逻辑架构" class="headerlink" title="逻辑架构"></a>逻辑架构</h3><img src="/blog/2020/03/30/MySQL%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/pic6.png" srcset="/blog/img/loading.gif" class><p>在mysql中schema与oracle schemas其实是不一样的，oracle中schemas的概念可理解为 “多个表（数据库对象）的集合，但在mysql中schema与database等价，只是为了兼容其他数据库，所以也提出了这个。如果通过sql语句删除schema，database也会被删除。</p><h3 id="物理存储结构"><a href="#物理存储结构" class="headerlink" title="物理存储结构"></a>物理存储结构</h3><p>mysql的数据文件都存放在datadir中，其查看方式为<code>show VARIABLES like &#39;datadir&#39;</code>。当创建一个数据库时，datadir中也会新增一个同名目录，用户建立的表都会在这个目录中，表文件跟具体的存储引擎相关，但都有个后缀为frm的文件用来存放表结构。</p><p>frm文件可以通过安装mysql utilities工具来查看</p><pre><code class="hljs vim">tar -zxvf mysql-utilities-<span class="hljs-number">1.6</span>.<span class="hljs-number">5</span>.tar.gz <span class="hljs-keyword">cd</span> mysql-utilities-<span class="hljs-number">1.6</span>.<span class="hljs-number">5</span><span class="hljs-keyword">python</span> ./setup.<span class="hljs-keyword">py</span> build<span class="hljs-keyword">python</span> ./setup.<span class="hljs-keyword">py</span> install</code></pre><p>通过以上步骤安装mysql utilities之后，运行以下命令就可以看到表结构</p><pre><code class="hljs awk">mysqlfrm --diagnostic <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/mysql/</span>data<span class="hljs-regexp">/mall/</span>account.frm</code></pre><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>存储引擎是数据库的核心，对于mysql来说，存储引擎是以插件的形式运行的。MySQL允许在一个数据库中使用不同的存储引擎，综合实际需求选择存储引擎可以提升数据库的性能。可以通过<code>show engines;</code>查看数据库的支持的引擎，<code>show variables like &#39;%storage_engine%&#39;;</code>可以查看当前默认的存储引擎。</p><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>使用这个存储引擎，每个MyISAM在磁盘上存储成三个文件。</p><ol><li><p>frm文件：存储表的定义数据</p></li><li><p>MYD文件：存放表具体记录的数据</p></li><li><p>MYI文件：存储索引</p></li></ol><p>frm和MYI可以存放在不同的目录下。MYI文件用来存储索引，但仅保存记录所在页的指针，索引的结构是B+树结构。这种索引跟数据分开存储的表也被称为堆表。</p><p>MyISAM支持表压缩，但是压缩之后的表就无法进行新增操作，需要再进行解压缩。</p><pre><code class="hljs awk">myisampack -b -f <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/mysql/</span>data<span class="hljs-regexp">/mall/</span>testmysam.MYI  -- 压缩myisamchk -r -f <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/mysql/</span>data<span class="hljs-regexp">/mall/</span>testmysam.MYI  -- 解压缩</code></pre><p>MyISAM是不支持事务的，所以他的存储速度相比InnorDB也更快，如果读写操作允许有错误数据，只追求速度的话，可以选择这个存储引擎。不过由于现在innodb越来越强大，MyISAM已经停止维护，绝大多数场景下已经不适合MyISAM。</p><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>InnoDB是默认的数据库存储引擎，他的主要特点有：</p><ul><li><p>可以通过自动增长列，方法是auto_increment。</p></li><li><p>支持事务。默认的事务隔离级别为可重复度，通过MVCC（并发版本控制）来实现的。</p></li><li><p>使用的锁粒度为行级锁，可以支持更高的并发；</p></li><li><p>支持外键约束；外键约束其实降低了表的查询速度，但是增加了表之间的耦合度。</p></li><li><p>配合一些热备工具可以支持在线热备份；</p></li><li><p>在InnoDB中存在着缓冲管理，通过缓冲池，将索引和数据全部缓存起来，加快查询的速度；</p></li><li><p>对于InnoDB类型的表，其数据的物理组织形式是聚簇表。所有的数据按照主键来组织。数据和索引放在一块，都位于B+数的叶子节点上；</p></li></ul><p>InnoDB的存储表和索引也有下面两种形式：</p><ul><li><p>使用共享表空间存储：所有的表和索引存放在同一个表空间中。</p></li><li><p>使用多表空间存储：表结构放在frm文件，数据和索引放在IBD文件中。分区表的话，每个分区对应单独的IBD文件，分区表的定义可以查看我的其他文章。使用分区表的好处在于提升查询效率。</p></li></ul><p>对于InnoDB来说，最大的特点在于支持事务。但是这是以损失效率来换取的。</p><h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><p>将数据存在内存，为了提高数据的访问速度，每一个表实际上和一个磁盘文件关联。文件是frm。</p><ul><li><p>支持的数据类型有限制，比如：不支持TEXT和BLOB类型，对于字符串类型的数据，只支持固定长度的行，VARCHAR会被自动存储为CHAR类型；</p></li><li><p>支持的锁粒度为表级锁。所以，在访问量比较大时，表级锁会成为MEMORY存储引擎的瓶颈；</p></li><li><p>由于数据是存放在内存中，一旦服务器出现故障，数据都会丢失；</p></li><li><p>查询的时候，如果有用到临时表，而且临时表中有BLOB，TEXT类型的字段，那么这个临时表就会转化为MyISAM类型的表，性能会急剧降低；</p></li><li><p>默认使用hash索引。</p></li><li><p>如果一个内部表很大，会转化为磁盘表。</p></li></ul><img src="/blog/2020/03/30/MySQL%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/pic7.png" srcset="/blog/img/loading.gif" class><h3 id="CSV"><a href="#CSV" class="headerlink" title="CSV"></a>CSV</h3><p> CSV引擎类似Oracle的外部表。它将数据存储在“逗号分隔值（CSV）文件”中，但不支持在这种文件上建立相关索引，所有列也不允许为NULL。这种引擎支持从数据库中拷入/拷出CSV文件，比如从电子表格软件输出一个CSV文件，将其存放在MySQL服务器的数据目录中，服务器执行刷新表操作后（<code>flush table</code>），就能够马上读取相关的CSV文件。同样，如果写数据库到一个CSV表，外部程序也可以立刻读取它。在实现某种类型的日志记录时，CSV表作为一种数据交换格式，特别有用。</p><h3 id="Archive"><a href="#Archive" class="headerlink" title="Archive"></a>Archive</h3><p> 从archive单词的解释我们大概可以明白这个存储引擎的用途，这个存储引擎基本上用于数据归档；它的压缩比非常的高，存储空间大概是innodb的10-15分之一所以它用来存储历史数据非常的适合，由于它不支持索引同时也不能缓存索引和数据，所以它不适合作为并发访问表的存储引擎。Archivec存储引擎使用行锁来实现高并发插入操作，但是它不支持事务，而且只允许在自增id列上加索引，其设计目标只是提供高速的插入和压缩功能。</p><h3 id="Ferderated"><a href="#Ferderated" class="headerlink" title="Ferderated"></a>Ferderated</h3><p>Ferderated引擎将数据存储在远程MySQL上，本地只存储表结构和连接信息，相当于提供了一个远程访问MySQL服务器上表的方法。通常使用在统计分析和数据查询中，在游戏行业使用的比较多。</p><p>在MySQL中默认是禁止的，需要在my.ini配置文件中增加federated参数来启用。可以通过<code>show ENGINES</code>查看已经开启的引擎。具体使用如下</p><pre><code class="hljs routeros">CREATE TABLE `local_fed` ( `id` int(11) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT, `c1` varchar(10) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span><span class="hljs-built_in"> DEFAULT </span><span class="hljs-string">''</span>, `c2` char(10) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span><span class="hljs-built_in"> DEFAULT </span><span class="hljs-string">''</span>, PRIMARY KEY (`id`)) <span class="hljs-attribute">ENGINE</span>=federated<span class="hljs-built_in"> CONNECTION </span>=<span class="hljs-string">'mysql://root:root1234%@127.0.0.1:3306/remote/remote_fed'</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>MySQL进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL基础</title>
    <link href="/blog/2020/03/25/MySQL%E5%9F%BA%E7%A1%80/"/>
    <url>/blog/2020/03/25/MySQL%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="MySQL安装"><a href="#MySQL安装" class="headerlink" title="MySQL安装"></a>MySQL安装</h2><p>Linux 使用的版本是centos 7，为方便起见先把防火墙关闭，配置好网络，在安装部分，会分成两部分首先会进行单实例安装，也就是一台服务器上就装一个mysql，接下来就多实例安装，在一个服务器上安装2个甚至多个mysql。</p><h3 id="单实例的安装"><a href="#单实例的安装" class="headerlink" title="单实例的安装"></a>单实例的安装</h3><ol><li><p>解压：将mysql-5.7.9-linux-glibc2.5-x86_64.tar.gz解压到/usr/local/目录下</p><pre><code class="hljs angelscript">cp /soft/mysql<span class="hljs-number">-5.7</span><span class="hljs-number">.9</span>-linux-glibc2<span class="hljs-number">.5</span>-x86_64.tar.gz  /usr/local/tar -zxvf mysql<span class="hljs-number">-5.7</span><span class="hljs-number">.9</span>-linux-glibc2<span class="hljs-number">.5</span>-x86_64.tar.gz</code></pre></li><li><p>之后的步骤可以根据解压后目录中的INSTALL-BINARY文件来</p><pre><code class="hljs dockerfile"><span class="hljs-keyword">shell</span><span class="bash">&gt; groupadd mysql</span><span class="hljs-keyword">shell</span><span class="bash">&gt; useradd -r -g mysql mysql</span><span class="hljs-keyword">shell</span><span class="bash">&gt; <span class="hljs-built_in">cd</span> /usr/<span class="hljs-built_in">local</span></span><span class="hljs-keyword">shell</span><span class="bash">&gt; tar zxvf /path/to/mysql-VERSION-OS.tar.gz</span><span class="hljs-keyword">shell</span><span class="bash">&gt; ln -s full-path-to-mysql-VERSION-OS mysql</span><span class="hljs-keyword">shell</span><span class="bash">&gt; <span class="hljs-built_in">cd</span> mysql</span><span class="hljs-keyword">shell</span><span class="bash">&gt; mkdir mysql-files</span><span class="hljs-keyword">shell</span><span class="bash">&gt; chmod 770 mysql-files</span><span class="hljs-keyword">shell</span><span class="bash">&gt; chown -R mysql .</span><span class="hljs-keyword">shell</span><span class="bash">&gt; chgrp -R mysql .</span><span class="hljs-keyword">shell</span><span class="bash">&gt; bin/mysqld --initialize --user=mysql     <span class="hljs-comment"># MySQL 5.7.6 and up //这一步会出现数据库密码注意保存</span></span><span class="hljs-keyword">shell</span><span class="bash">&gt; bin/mysql_ssl_rsa_setup              <span class="hljs-comment"># MySQL 5.7.6 and up</span></span><span class="hljs-keyword">shell</span><span class="bash">&gt; chown -R root .</span><span class="hljs-keyword">shell</span><span class="bash">&gt; chown -R mysql data mysql-files //在此之前需要手动创建data目录</span><span class="hljs-keyword">shell</span><span class="bash">&gt; bin/mysqld_safe --user=mysql &amp; //如果此时报错可以删除etc下的my.cnf文件之后再从bin/mysqld --initialize --user=mysql开始重新执行</span><span class="hljs-comment"># Next command is optional</span><span class="hljs-keyword">shell</span><span class="bash">&gt; cp support-files/mysql.server /etc/init.d/mysql.server //可选项</span></code></pre></li><li><p>配置环境变量：</p><p>在<code>/etc/profile</code>中添加<code>export PATH=/usr/local/mysql/bin:$PATH</code></p><p>保存后输入<code>source /etc/profile</code>命令使配置生效</p></li><li><p>配置开启启动</p><p><code>chkconfig mysql.server on</code></p><p><code>chkconfig --list</code></p></li><li><p>登录、修改密码、允许远程登录</p><p><code>mysql -uroot  -p&#39;使用第二步中保存的密码&#39;</code></p><p>成功进入后：</p><p><code>set password = &#39;新密码&#39;;</code></p><p>允许远程登陆</p><p><code>GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;密码&#39;</code></p><p>刷新权限</p><p><code>flush privileges;</code></p></li></ol><h3 id="多实例的安装"><a href="#多实例的安装" class="headerlink" title="多实例的安装"></a>多实例的安装</h3><p>在mysql中已经考虑到了多实例安装的情况。也有相应的脚本命令的支持。</p><p>比如现在装两个mysql端口分别为3307、3308</p><ol><li><p>新建 /etc/my.cnf 配置如下</p><pre><code class="hljs ini"><span class="hljs-section">[mysqld]</span><span class="hljs-attr">sql_mode</span> = <span class="hljs-string">"STRICT_TRANS_TABLES,NO_ENGINE_SUBSTITUTION,NO_ZERO_DATE,NO_ZERO_IN_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER"</span><span class="hljs-section">[mysqld_multi]</span><span class="hljs-attr">mysqld</span> = /usr/local/mysql/bin/mysqld_safe<span class="hljs-attr">mysqladmin</span> = /usr/local/mysql/bin/mysqladmin<span class="hljs-attr">log</span> = /var/log/mysqld_multi.log<span class="hljs-section">[mysqld1]</span> <span class="hljs-attr">server-id</span> = <span class="hljs-number">11</span><span class="hljs-attr">socket</span> = /tmp/mysql.sock1<span class="hljs-attr">port</span> = <span class="hljs-number">3307</span><span class="hljs-attr">datadir</span> = /data1<span class="hljs-attr">user</span> = mysql<span class="hljs-attr">performance_schema</span> = <span class="hljs-literal">off</span><span class="hljs-attr">innodb_buffer_pool_size</span> = <span class="hljs-number">32</span>M<span class="hljs-attr">skip_name_resolve</span> = <span class="hljs-number">1</span><span class="hljs-attr">log_error</span> = error.log<span class="hljs-attr">pid-file</span> = /data1/mysql.pid1<span class="hljs-section">[mysqld2]</span><span class="hljs-attr">server-id</span> = <span class="hljs-number">12</span><span class="hljs-attr">socket</span> = /tmp/mysql.sock2<span class="hljs-attr">port</span> = <span class="hljs-number">3308</span><span class="hljs-attr">datadir</span> = /data2<span class="hljs-attr">user</span> = mysql<span class="hljs-attr">performance_schema</span> = <span class="hljs-literal">off</span><span class="hljs-attr">innodb_buffer_pool_size</span> = <span class="hljs-number">32</span>M<span class="hljs-attr">skip_name_resolve</span> = <span class="hljs-number">1</span><span class="hljs-attr">log_error</span> = error.log<span class="hljs-attr">pid-file</span> = /data2/mysql.pid2</code></pre></li><li><p>创建2个数据目录</p><pre><code class="hljs arduino"><span class="hljs-built_in">mkdir</span> /data1<span class="hljs-built_in">mkdir</span> /data2</code></pre></li><li><p>初始化MySQL</p><pre><code class="hljs jboss-cli">chown mysql.mysql <span class="hljs-string">/data</span>&#123;1.<span class="hljs-string">.2</span>&#125;mysqld <span class="hljs-params">--initialize</span> <span class="hljs-params">--user=mysql</span> <span class="hljs-params">--datadir=/data1</span>mysqld <span class="hljs-params">--initialize</span> <span class="hljs-params">--user=mysql</span> <span class="hljs-params">--datadir=/data2</span>cp <span class="hljs-string">/usr/local/mysql/support-files/mysqld_multi.server</span> <span class="hljs-string">/etc/init.d/mysqld_multid</span></code></pre></li><li><p>安装perl环境</p><pre><code class="hljs vim">yum -<span class="hljs-keyword">y</span> install <span class="hljs-keyword">perl</span> <span class="hljs-keyword">perl</span>-devel</code></pre></li><li><p>查看状态</p><pre><code class="hljs elm"><span class="hljs-title">mysqld_multi</span> re<span class="hljs-keyword">port</span></code></pre></li><li><p>启动</p><pre><code class="hljs crmsh">mysqld_multi <span class="hljs-literal">start</span></code></pre></li><li><p>修改密码，允许远程连接</p><pre><code class="hljs sql">mysql -u root -S /tmp/mysql.sock1 -p -P3307mysql -u root -S /tmp/mysql.sock2 -p -P3308<span class="hljs-keyword">set</span> <span class="hljs-keyword">password</span> = <span class="hljs-string">'root1234%'</span>;<span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALL</span> <span class="hljs-keyword">PRIVILEGES</span> <span class="hljs-keyword">ON</span> *.* <span class="hljs-keyword">TO</span> <span class="hljs-string">'root'</span>@<span class="hljs-string">'%'</span> <span class="hljs-keyword">IDENTIFIED</span> <span class="hljs-keyword">BY</span> <span class="hljs-string">'root1234%'</span>;<span class="hljs-keyword">flush</span> <span class="hljs-keyword">privileges</span>;</code></pre></li></ol><h2 id="MySQL权限"><a href="#MySQL权限" class="headerlink" title="MySQL权限"></a>MySQL权限</h2><p>MySQL的权限简单的理解就是MySQK允许你做权限以内的事情，不可以越界。比如只允许你执行select操作，那么你就不能执行update操作。只允许你从某台机器上连接mysql，那么你就不能从除那台机器以外的其他机器连接mysql。</p><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><pre><code class="hljs sql"><span class="hljs-keyword">grant</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">on</span> mall.* <span class="hljs-keyword">TO</span> <span class="hljs-string">'dev'</span>@<span class="hljs-string">'192.168.244.%'</span> <span class="hljs-keyword">IDENTIFIED</span> <span class="hljs-keyword">BY</span> <span class="hljs-string">'123'</span> <span class="hljs-keyword">WITH</span> <span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">OPTION</span>;</code></pre><p>以上语可以创建一个拥有mall中所有表进行select操作，用户名为dev，密码为123，允许在网段192.168.0.*连接的用户。</p><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">grants</span> <span class="hljs-keyword">for</span> <span class="hljs-string">'dev'</span>@<span class="hljs-string">'192.168.244.%'</span></code></pre><p>这条命令可以输出刚才创建的dev用户的权限</p><h3 id="用户标识"><a href="#用户标识" class="headerlink" title="用户标识"></a>用户标识</h3><p>在MySQL中的权限不是单纯的赋予给用户的，而是赋予给”用户+IP”的。</p><p>比如dev用户是否能登陆，用什么密码登陆，并且能访问什么数据库等都需要加上IP，这样才算一个完整的用户标识，换句话说 ‘dev’@’192.168.0.168’ 、‘dev’@’127.0.0.1’与‘dev’@’localhost’ 这3个是完全不同的用户标识（哪怕你本机的ip就是192.168.0.168）。</p><h3 id="用户权限所涉及的表"><a href="#用户权限所涉及的表" class="headerlink" title="用户权限所涉及的表"></a>用户权限所涉及的表</h3><p>在mysql库中中存在4个控制权限的表，<code>分别为user表，db表，tables_priv表，columns_priv表</code></p><ul><li>user：存储用户标识</li><li>db：用户对数据库的权限</li><li>table_priv：用户对表的权限</li><li>column_priv：用户对某一列的权限</li></ul><p>MySQL的权限粒度甚至可以细化到某一列上。</p><pre><code class="hljs sql"><span class="hljs-keyword">grant</span> <span class="hljs-keyword">select</span>(<span class="hljs-keyword">id</span>,<span class="hljs-keyword">name</span>) <span class="hljs-keyword">on</span> mall.account <span class="hljs-keyword">to</span> <span class="hljs-string">'dev'</span>@<span class="hljs-string">'192.168.244.%'</span>;</code></pre><p>这条语句可以将mall数据库中account表的id跟name的查询条件给‘dev’@’192.168.244.%’用户，但如果用户之前拥有更高的权限，会以之前权限为准，所以要想生效就需要移除‘dev’@’192.168.244.%’用户之前的权限。</p><pre><code class="hljs sql"><span class="hljs-keyword">revoke</span> <span class="hljs-keyword">select</span> <span class="hljs-keyword">on</span> mail.* <span class="hljs-keyword">from</span> <span class="hljs-string">'dev'</span>@<span class="hljs-string">'192.168.244.%'</span>;</code></pre><p>此时再使用‘dev’@’192.168.244.%’用户查看表account时可能会报错，此时可以用过以下语句查看是否设置成功。</p><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">id</span>,<span class="hljs-keyword">name</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">account</span>;</code></pre><h2 id="MySQL的角色"><a href="#MySQL的角色" class="headerlink" title="MySQL的角色"></a>MySQL的角色</h2><p> MySql基于”用户+IP”的这种授权模式在设置给多个用户设置相同权限时会比较繁琐。所以MySQL官方在5.7之后推出“Role Like”功能来实现类似角色的功能，更加方便管理多个同样权限的账户。</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol><li><p>检查是否开启角色功能</p><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">variables</span> <span class="hljs-keyword">like</span> <span class="hljs-string">"%proxy%"</span></code></pre></li><li><p><code>check_proxy_users</code>，<code>mysql_native_password_proxy_users</code>这两个变量需要设置成true</p><pre><code class="hljs gams"><span class="hljs-keyword">set</span> GLOBAL <span class="hljs-comment">check_proxy_users =1</span>;<span class="hljs-keyword">set</span> GLOBAL <span class="hljs-comment">mysql_native_password_proxy_users = 1</span>;</code></pre></li></ol><h3 id="简单使用-1"><a href="#简单使用-1" class="headerlink" title="简单使用"></a>简单使用</h3><ol><li><p>创建一个dev_role用户</p><pre><code class="hljs routeros">create<span class="hljs-built_in"> USER </span><span class="hljs-string">'dev_role'</span></code></pre></li><li><p>在创建两个用户</p><pre><code class="hljs routeros">create<span class="hljs-built_in"> USER </span><span class="hljs-string">'test1'</span>create<span class="hljs-built_in"> USER </span><span class="hljs-string">'test2'</span></code></pre></li><li><p>把两个用户加到组里面</p><pre><code class="hljs routeros">grant<span class="hljs-built_in"> proxy </span>on <span class="hljs-string">'dev_role'</span> <span class="hljs-keyword">to</span> <span class="hljs-string">'test1'</span>grant<span class="hljs-built_in"> proxy </span>on <span class="hljs-string">'dev_role'</span> <span class="hljs-keyword">to</span> <span class="hljs-string">'test2'</span></code></pre></li><li><p>如果是远程连接需要给远程连接的ROOTGRANT权限</p><pre><code class="hljs routeros">GRANT<span class="hljs-built_in"> PROXY </span>ON <span class="hljs-string">''</span>@<span class="hljs-string">''</span> <span class="hljs-keyword">TO</span> <span class="hljs-string">'root'</span>@<span class="hljs-string">'%'</span> WITH GRANT OPTION;</code></pre></li><li><p>给<code>dev_role</code>设置权限</p><pre><code class="hljs sql"><span class="hljs-keyword">grant</span> <span class="hljs-keyword">select</span>(<span class="hljs-keyword">id</span>,<span class="hljs-keyword">name</span>) <span class="hljs-keyword">on</span> mall.account <span class="hljs-keyword">to</span> <span class="hljs-string">'dev_role'</span></code></pre></li></ol><h2 id="MySQL的数据类型"><a href="#MySQL的数据类型" class="headerlink" title="MySQL的数据类型"></a>MySQL的数据类型</h2><h3 id="int类型"><a href="#int类型" class="headerlink" title="int类型"></a>int类型</h3><table><thead><tr><th><strong>类型</strong></th><th><strong>字节</strong></th><th><strong>最小值</strong>（有符号/无符号）</th><th><strong>最大值</strong>（有符号/无符号）</th></tr></thead><tbody><tr><td>TINYINT</td><td>1</td><td>-128 / 0</td><td>127 / 255</td></tr><tr><td>SMALLINT</td><td>2</td><td>-32768 / 0</td><td>32767/65535</td></tr><tr><td>MEDIUMINT</td><td>3</td><td>-8388608 / 0</td><td>8388607/16777215</td></tr><tr><td>INT</td><td>4</td><td>-2147483648 / 0</td><td>2147483647/4294967295</td></tr><tr><td>BIGINT</td><td>8</td><td>-9223372036854775808 / 0</td><td>9223372036854775807/18446744073709551615</td></tr></tbody></table><p>注：</p><ul><li>项目中通常使用有符号的BIGINT。</li><li>int(N)中N是指显示宽度，并不是最大存储长度，如果开启zerofill（填充0），在数据长度未达到N时会在左侧填充数字0至N（可视化工具中可能会将左侧的0屏蔽）。</li><li>自动增长只能用于主键，且只有主键类型为NULL时会触发。</li></ul><h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3><table><thead><tr><th>类型</th><th>说明</th><th>N的含义</th><th>是否有字符集</th><th>最大长度</th></tr></thead><tbody><tr><td>CHAR(N)</td><td>定长字符</td><td>字符</td><td>是</td><td>255</td></tr><tr><td>VARCHAR(N)</td><td>变长字符</td><td>字符</td><td>是</td><td>16384</td></tr><tr><td>BINARY(N)</td><td>定长二进制字节</td><td>字节</td><td>否</td><td>255</td></tr><tr><td>VARBINARY(N)</td><td>变长二进制字节</td><td>字节</td><td>否</td><td>16384</td></tr><tr><td>TINYBLOB(N)</td><td>二进制大对象</td><td>字节</td><td>否</td><td>256</td></tr><tr><td>BLOB(N)</td><td>二进制大对象</td><td>字节</td><td>否</td><td>16K</td></tr><tr><td>MEDIUMBLOB(N)</td><td>二进制大对象</td><td>字节</td><td>否</td><td>16M</td></tr><tr><td>LONGBLOB(N)</td><td>二进制大对象</td><td>字节</td><td>否</td><td>4G</td></tr><tr><td>TINYTEXT(N)</td><td>大对象</td><td>字节</td><td>是</td><td>256</td></tr><tr><td>TEXT(N)</td><td>大对象</td><td>字节</td><td>是</td><td>16K</td></tr><tr><td>MEDIUMTEXT(N)</td><td>大对象</td><td>字节</td><td>是</td><td>16M</td></tr><tr><td>LONGTEXT(N)</td><td>大对象</td><td>字节</td><td>是</td><td>4G</td></tr></tbody></table><p>注：</p><ul><li>排序规则中_ci为不区分大小写比较，_cs为区分大小写比较，_bin为使用二进制编码比较。</li><li>utf8_unicode_ci和utf8_general_ci对中、英文来说没有实质的差别。utf8_general_ci校对速度快，但准确度稍差，utf8_unicode_ci准确度高，但校对速度稍慢。如果你的应用有德语、法语或者俄语，请一定使用utf8_unicode_ci，其余情况下utf8_general_ci就够了。</li><li>除char，varchar中的N表示字符长度外，其余类型中的N均表示字节长度。</li></ul><h3 id="时间类型"><a href="#时间类型" class="headerlink" title="时间类型"></a>时间类型</h3><table><thead><tr><th>日期类型</th><th>占用空间</th><th>表示范围</th></tr></thead><tbody><tr><td>DATETIME</td><td>8</td><td>1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</td></tr><tr><td>DATE</td><td>3</td><td>1000-01-01 ~ 9999-12-31</td></tr><tr><td>TIMESTAMP</td><td>4</td><td>1970-01-01 00:00:00UTC ~ 2038-01-19 03:14:07UTC</td></tr><tr><td>YEAR</td><td>1</td><td>YEAR(2):1970-2070, YEAR(4):1901-2155</td></tr><tr><td>TIME</td><td>3</td><td>-838:59:59 ~ 838:59:59</td></tr></tbody></table><p>注：datetime与timestamp区别在于，再修改时区后timestamp会相应的变化，datetime不会。</p><h3 id="JSON类型"><a href="#JSON类型" class="headerlink" title="JSON类型"></a>JSON类型</h3><p>MySQK5.7开始引入JSON数据类型用来保存JSON类型的数据，与varchar的区别在于</p><ul><li>MySQL提供了一组操作JSON数据的内置函数。</li></ul><ul><li>JSON数据类型会自动校验数据是否为JSON格式，如果不是JSON格式数据，则会报错。</li><li>存储在JSON列中的JSON数据被转换成内部的存储格式，允许快速读取。</li><li>可以修改特定的键值</li></ul><h3 id="相关的内置函数"><a href="#相关的内置函数" class="headerlink" title="相关的内置函数"></a>相关的内置函数</h3><ul><li><p>json_type：显示当前JSON字符串的类型，如<code>select json_type(&#39;[&quot;test1&quot;,&quot;test2&quot;,&quot;test3&quot;]&#39;);</code>输出结果为：<code>ARRAY</code></p></li><li><p>json_array：将数组对象转为JSON数组，如<code>select json_array(1,now(),&quot;test&quot;);</code>输出结果为：<code>[1, &quot;2020-03-29 20:44:41.000000&quot;, &quot;test1&quot;]</code></p></li><li><p>json_object：将对象转为JSON格式数据，如<code>select json_object(&quot;name&quot;, &quot;enjoy&quot;, &quot;email&quot;, &quot;enjoy.com&quot;, &quot;age&quot;,35);</code>输出结果为：<code>{&quot;age&quot;: 35, &quot;name&quot;: &quot;enjoy&quot;, &quot;email&quot;: &quot;enjoy.com&quot;}</code></p></li><li><p>json_extract：可以提取JSON格式中的属性，如<code>select json_extract(&#39;[10, 20, [30, 40]]&#39;, &#39;$[1]&#39;);</code>输出结果为：<code>20</code></p></li><li><p>json_insert：向JSON中插入数据，如果已存在则不会修改，如</p><pre><code class="hljs sql"><span class="hljs-keyword">set</span> @<span class="hljs-keyword">json</span> = <span class="hljs-string">'&#123; "a": 1, "b": [2, 3]&#125;'</span>;<span class="hljs-keyword">select</span> json_insert(@<span class="hljs-keyword">json</span>, <span class="hljs-string">'$.a'</span>, <span class="hljs-number">10</span>, <span class="hljs-string">'$.c'</span>, <span class="hljs-string">'[true, false]'</span>);</code></pre><p>输出结果为：<code>{&quot;a&quot;: 1, &quot;b&quot;: [2, 3], &quot;c&quot;: &quot;[true, false]&quot;}</code></p></li><li><p>json_merge：合并数据并返回，如<code>select json_merge(&#39;{&quot;name&quot;: &quot;enjoy&quot;}&#39;, &#39;{&quot;id&quot;: 47}&#39;);</code>输出结果为：<code>{&quot;id&quot;: 47, &quot;name&quot;: &quot;enjoy&quot;}</code></p></li></ul><p><a href="https://dev.mysql.com/doc/refman/5.7/en/json-function-reference.html" target="_blank" rel="noopener">其他函数</a></p><h3 id="JSON类型的索引"><a href="#JSON类型的索引" class="headerlink" title="JSON类型的索引"></a>JSON类型的索引</h3><p>由于JSON类型数据本身无法直接创建索引，所以将要建立索引的JSON数据中的字段，重新生成虚拟字段（Virtual Columns）之后，再对该字段进行索引。</p><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">test</span>( <span class="hljs-keyword">data</span> <span class="hljs-keyword">json</span>, gen_col <span class="hljs-built_in">varchar</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">generated</span> <span class="hljs-keyword">always</span> <span class="hljs-keyword">as</span> (<span class="hljs-keyword">data</span>-&gt;&gt;<span class="hljs-string">'$.name'</span>),  <span class="hljs-keyword">index</span> idx (gen_col) );</code></pre><p>上面的语句将为test表中data字段中的name属性创建名为gen_col的虚拟字段，再为gen_col创建名为idx的索引。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编写高效优雅的Java代码</title>
    <link href="/blog/2020/03/24/JVM-%E7%BC%96%E5%86%99%E9%AB%98%E6%95%88%E4%BC%98%E9%9B%85%E7%9A%84Java%E4%BB%A3%E7%A0%81/"/>
    <url>/blog/2020/03/24/JVM-%E7%BC%96%E5%86%99%E9%AB%98%E6%95%88%E4%BC%98%E9%9B%85%E7%9A%84Java%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h3 id="避免过多的构造器参数"><a href="#避免过多的构造器参数" class="headerlink" title="避免过多的构造器参数"></a>避免过多的构造器参数</h3><p>如果参数过多，会导致构造方法非常复杂、拓展性差、难以理解。</p><p>可以使用get()、set()方法对非必须的属性进行设置，构造方法中只包含必须的属性，将原本的一行代码转为多行代码。</p><p>还可以使用建造者模式，一般有</p><ol><li>抽象建造者：一般来说是个接口，包含1）建造方法，建造部件的方法（不止一个），2）返回产品的方法</li><li>具体建造者</li><li>导演者，调用具体的建造者，创建产品对象</li><li>产品，需要建造的复杂对象</li></ol><p>使用时需要创建导演者和具体建造者，并把具体建造者交给导演者，然后通知导演者操纵建造者进行产品的创建。在实际的应用过程中，有时会省略抽象建造者和导演者。建造者模式的代码易于阅读和编写，相对于上一种方式更加安全。</p><pre><code class="hljs arduino"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 建造者模式（简单版）</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BoxBuilder</span> &#123;</span>    <span class="hljs-comment">//required必须参数</span>    <span class="hljs-keyword">private</span>  <span class="hljs-keyword">final</span> <span class="hljs-keyword">String</span> name;<span class="hljs-comment">//礼盒名称</span>    <span class="hljs-keyword">private</span>  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> price;<span class="hljs-comment">//礼盒价格</span>    <span class="hljs-comment">//optional可选参数</span>    <span class="hljs-keyword">private</span>   <span class="hljs-keyword">int</span> zz;<span class="hljs-comment">//粽子</span>    <span class="hljs-keyword">private</span>   <span class="hljs-keyword">int</span> xyd;<span class="hljs-comment">//咸鸭蛋</span>    <span class="hljs-keyword">private</span>   <span class="hljs-keyword">int</span> ldg;<span class="hljs-comment">//绿豆糕</span>    <span class="hljs-keyword">private</span>   <span class="hljs-keyword">int</span> yb;<span class="hljs-comment">//月饼</span>    <span class="hljs-keyword">private</span>   <span class="hljs-keyword">int</span> jg;<span class="hljs-comment">//坚果</span>    <span class="hljs-comment">//具体建造者</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Builder</span>&#123;</span>        <span class="hljs-comment">//required必须参数</span>        <span class="hljs-keyword">private</span>  <span class="hljs-keyword">final</span> <span class="hljs-keyword">String</span> name;<span class="hljs-comment">//礼盒名称</span>        <span class="hljs-keyword">private</span>  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> price;<span class="hljs-comment">//礼盒价格</span>        <span class="hljs-comment">//optional可选参数</span>        <span class="hljs-keyword">private</span>   <span class="hljs-keyword">int</span> zz;<span class="hljs-comment">//粽子</span>        <span class="hljs-keyword">private</span>   <span class="hljs-keyword">int</span> xyd;<span class="hljs-comment">//咸鸭蛋</span>        <span class="hljs-keyword">private</span>   <span class="hljs-keyword">int</span> ldg;<span class="hljs-comment">//绿豆糕</span>        <span class="hljs-keyword">private</span>   <span class="hljs-keyword">int</span> yb;<span class="hljs-comment">//月饼</span>        <span class="hljs-keyword">private</span>   <span class="hljs-keyword">int</span> jg;<span class="hljs-comment">//坚果</span>        <span class="hljs-comment">//构造方法</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Builder</span><span class="hljs-params">(<span class="hljs-keyword">String</span> name, <span class="hljs-keyword">int</span> price)</span> </span>&#123;            super();            <span class="hljs-keyword">this</span>.name = name;            <span class="hljs-keyword">this</span>.price = price;        &#125;        <span class="hljs-comment">//建造方法</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> BoxBuilder <span class="hljs-title">builder</span><span class="hljs-params">()</span></span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BoxBuilder(<span class="hljs-keyword">this</span>);        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">zz</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span></span>&#123;            <span class="hljs-keyword">this</span>.zz=value;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">xyd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span></span>&#123;            <span class="hljs-keyword">this</span>.xyd=value;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;        &#125;        <span class="hljs-comment">//......</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">BoxBuilder</span> <span class="hljs-params">(Builder builder)</span></span>&#123;        name = builder.name;        price =builder.price;        zz =builder.zz;        xyd =builder.xyd;        ldg=builder.ldg;        yb=builder.yb;        jg=builder.jg;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;        BoxBuilder box1 = <span class="hljs-keyword">new</span> Builder(<span class="hljs-string">"端午节礼盒1"</span>,<span class="hljs-number">120</span>)                .zz(<span class="hljs-number">8</span>)                .xyd(<span class="hljs-number">4</span>)                .builder();    &#125;&#125;</code></pre><h3 id="类构造器私有化"><a href="#类构造器私有化" class="headerlink" title="类构造器私有化"></a>类构造器私有化</h3><p>一些不需要实例化的类比如工具类，这些类是不应该提供具体实例的，此时可以将构造函数私有化，防止使用者new出实例。</p><h4 id="不要创建不必要的对象"><a href="#不要创建不必要的对象" class="headerlink" title="不要创建不必要的对象"></a>不要创建不必要的对象</h4><ol><li><p>避免无意中创建的对象，如自动装箱，<code>String a = new String(&quot;a&quot;)</code>等</p></li><li><p>尽量重用不可变的对象，以及不会被修改的对象。</p></li><li><p>使用静态工厂替代构造方法可以避免过多的创建对象。</p></li><li><p>通过维护对象池（pool）来避免创建对象并不是一种好的做法，除非是重量级的对象，比如数据库的连接等。</p></li></ol><h3 id="避免使用终结方法"><a href="#避免使用终结方法" class="headerlink" title="避免使用终结方法"></a>避免使用终结方法</h3><p>jdk不能保证finalizer方法何时执行，也不能保证一定会执行，如果需要释放资源可以使用try/finally。</p><h3 id="使类和成员的可访问性最小化"><a href="#使类和成员的可访问性最小化" class="headerlink" title="使类和成员的可访问性最小化"></a>使类和成员的可访问性最小化</h3><p>模块对外部其他模块来说，隐藏其内部数据和其他实现细节–封装</p><p>编写程序和设计架构，最重要的目标之一就是模块之间的解耦。使类和成员的可访问性最小化无疑是有效的途径之一。让每个类或成员尽可能的不可访问，即使用尽可能低的实现细节，避免公开公共类的成员，在仔细设计类公共方法之后，让所有成员设计为私有的。 只有当同一个包中的其他类真的需要访问成员时，再去修改私有修饰符，从而使成员包成为包级私有的。</p><p>对于成员(属性、方法、嵌套类和嵌套接口)，有四种可能的访问级别，在这里，按照可访问性从小到大列出：</p><ul><li><p>private：该成员只能在声明它的顶级类内访问。</p></li><li><p>package-private：成员可以从被声明的包中的任何类中访问。从技术上讲，如果没有指定访问修饰符(接口成员除外，它默认是公共的)，这是默认访问级别。</p></li><li><p>protected：成员可以从被声明的类的子类中访问(受一些限制，JLS，6.6.2)，以及它声明的包中的任何类。</p></li><li><p>public：该成员可以从任何地方被访问。</p></li></ul><h3 id="使可变性最小"><a href="#使可变性最小" class="headerlink" title="使可变性最小"></a>使可变性最小</h3><p>不可变类只是其实例不能被修改的类。每个实例中包含的所有信息都必须在创建该实例的时候就提供，并在对象的整个生命周期内固定不变。Java平台类库中包含许多不可变的类，其中有String、基本类型的包装类、BigInteger和BigDecimal。存在不可变的类有许多理由：不可变的类比可变的泪更加易于设计、实现和使用。他们不容易出错，且更加安全。</p><p>为了使类成为不可变，要遵循下面五条规则：</p><ul><li><p>不要提供任何会修改对象状态的方法。</p></li><li><p>保证类不会被扩展。为了防止子类化，一般做法是使这个类成为final的 。</p></li><li><p>使所有的域都是final的。一是为了表明意图，二是为了在多线程间确保对对象使用正确的行为。</p></li><li><p>使所有的域都成为私有的。这样可以防止客户端获得访问被域引用的可变对象的权限，并防止客户端直接修改这些对象。</p></li><li><p>确保对于任何可变组件的互斥访问。如果类具有指向可变对象的域，则必须确保该类的使用者无法获得指向这些对象的引用。并且，永远不要对使用者提供的对象引用来初始化这样的域，也不要从任何方法中返回该对象引用。</p></li></ul><h3 id="复合优先于继承"><a href="#复合优先于继承" class="headerlink" title="复合优先于继承"></a>复合优先于继承</h3><p>你永远不知道你的用户是如何使用你写的产品，同样使用继承拓展一个其他人的类也是危险的。父类的具体实现很容易影响子类的正确性。尽量不使用继承扩展现有的类，而是在新类中引用现有的类，这种设计称为复合（Composition）。</p><h3 id="接口优于抽象类"><a href="#接口优于抽象类" class="headerlink" title="接口优于抽象类"></a>接口优于抽象类</h3><p>由于Java只允许单继承的，当发生业务变化需要新增业务方法时，使用抽象类有可能导致不需要变化的其他子类也不得不实现新增的业务方法，如果使用接口，只需要在实现中增加新创建的接口即可。</p><p>JDK源码通常声明一个抽象的骨架类实现接口，骨架类类实现通用的方法，实际业务类可以同时实现接口又继承骨架类，也可以只实现接口。如HashSet实现了Set接口 但是继承AbstractSet类，而AbstractSet本身也实现了Set接口。其他如Map，List都是这样的设计的。</p><h3 id="慎用可变参数"><a href="#慎用可变参数" class="headerlink" title="慎用可变参数"></a>慎用可变参数</h3><p>在定义参数数目不定的方法时，可变参数方法是一种很方便的方式，但是他们不应该被过渡滥用。如果使用不当，会产生混乱的结果。</p><p>可变参数的机制原理：</p><ol><li><p>创建一个array[]，它的size就是所传参数的个数；</p></li><li><p>将参数放入到array[]中；</p></li><li><p>将array[]传给方法。</p></li></ol><p>可变参数方法是允许传入0个参数或者null的，而且编译时正常但会在运行时失败。可变参数方法的每次调用都会进行一次数组分配和初始化，对系统性能有一定影响。</p><h3 id="返回空的数组或集合，不要返回null"><a href="#返回空的数组或集合，不要返回null" class="headerlink" title="返回空的数组或集合，不要返回null"></a>返回空的数组或集合，不要返回null</h3><p>如果方法的结果返回null，会导致开发者的要单独处理为null的情况。这样的方法比较难以使用，更容易出错，并且没有性能优势。而返回零长度，调用方可以统一处理，如使用foreach即可。</p><p>JDK提供的空集合：<code>Collections.emptyList()</code>、<code>Collections.emptySet()</code>、<code>Collections.emptyMap</code></p><h3 id="优先使用标准的异常"><a href="#优先使用标准的异常" class="headerlink" title="优先使用标准的异常"></a>优先使用标准的异常</h3><p>代码重用是值得提倡的，这是一条通用的规则，异常也不例外。Java平台类库提供了一组基本的未受检的异常，他们满足了绝大多数API的异常抛出需要。</p><p>常用的异常：</p><ul><li><p>IllegalArgumentException：调用者传递的参数不合适</p></li><li><p>IllegalStateException：接收的对象状态不对，</p></li><li><p>NullPointerException：对象为空</p></li><li><p>UnsupportedOperationException：不支持的操作</p></li><li><p>ConcurrentModificationExccetion：禁止并发修改时，监测到对象的并发修改</p></li></ul><p>重用现有的异常有多方面的好处。其中最主要的好处是使代码更加易于学习和使用，现有异常大多是是开发者已知的，他们的可读性会更好。还有就是异常类越少，意味着需要加载的类越少，装载这些类的时间开销也越少。</p><h3 id="用枚举代替int常量"><a href="#用枚举代替int常量" class="headerlink" title="用枚举代替int常量"></a>用枚举代替int常量</h3><p>针对int常量以下不足： </p><ol><li>在类型安全方面，使用相同的常量值的两个常量，编译器并不能检测出错误； </li><li>因为int常量是编译时常量，被编译到使用它们class文件中。若常量发生变化，相关类必须重新编译，否则它们的行为就不确定； </li><li>想要描述常量是比较困难的。</li></ol><p>枚举高级用法：</p><ul><li><p>枚举常量与数据关联：枚举常量可以与数据相关，可以在其构造方法中加入逻辑代码，然后在枚举中提供新的属性以存放和返回结果信息。</p></li><li><p>枚举常量与行为关联：枚举常量还可以与行为关联，如实现四则运算</p><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> Operation &#123;  PLUS(<span class="hljs-string">"+"</span>) &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">apply</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">double</span> y)</span> </span>&#123;      <span class="hljs-keyword">return</span> x + y;    &#125;  &#125;,  MINUS(<span class="hljs-string">"-"</span>) &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">apply</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">double</span> y)</span> </span>&#123;      <span class="hljs-keyword">return</span> x - y;    &#125;  &#125;,  TIMES(<span class="hljs-string">"*"</span>) &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">apply</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">double</span> y)</span> </span>&#123;      <span class="hljs-keyword">return</span> x * y;    &#125;  &#125;,  DIVIDE(<span class="hljs-string">"/"</span>) &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">apply</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">double</span> y)</span> </span>&#123;      <span class="hljs-keyword">return</span> x / y;    &#125;  &#125;;  <span class="hljs-keyword">private</span> String symbol;  Operation(String symbol) &#123;    <span class="hljs-keyword">this</span>.symbol = symbol;  &#125;  <span class="hljs-meta">@Override</span>  <span class="hljs-keyword">public</span> <span class="hljs-function">String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> symbol;  &#125;  <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">apply</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">double</span> y)</span></span>;&#125;</code></pre></li><li><p>枚举策略模式：以下代码是计算工人工资。平时工作8小时，超过8小时，以加班工资方式另外计算，如果是双休日，都按照加班方式处理工资。</p><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> PayRoll &#123;  MONDY(PayType.WEEKDAY),  TUESDAY(PayType.WEEKDAY),  WEDNESDAY(PayType.WEEKDAY),  THURSDAY(PayType.WEEKDAY),  FRIDAY(PayType.WEEKDAY),  SATURDAY(PayType.WEEKEND),  SUNDAY(PayType.WEEKEND);  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PayType payType;  PayRoll(PayType payType) &#123;    <span class="hljs-keyword">this</span>.payType = payType;  &#125;  <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">pay</span><span class="hljs-params">(<span class="hljs-keyword">double</span> hoursWorked, <span class="hljs-keyword">double</span> payRate)</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">return</span> payType.<span class="hljs-title">pay</span><span class="hljs-params">(hoursWorked, payRate)</span></span>;  &#125;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">enum</span> PayType &#123;    WEEKDAY &#123;      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">overtimePay</span><span class="hljs-params">(<span class="hljs-keyword">double</span> hoursWorked, <span class="hljs-keyword">double</span> payRate)</span> </span>&#123;        <span class="hljs-keyword">double</span> overtime = hoursWorked - HOURS_PER_SHIFT;        <span class="hljs-keyword">return</span> overtime &lt;= <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : overtime * payRate / 2;      &#125;    &#125;,    WEEKEND &#123;      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">overtimePay</span><span class="hljs-params">(<span class="hljs-keyword">double</span> hoursWorked, <span class="hljs-keyword">double</span> payRate)</span> </span>&#123;        <span class="hljs-keyword">return</span> hoursWorked * payRate / <span class="hljs-number">2</span>;      &#125;    &#125;;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> HOURS_PER_SHIFT = <span class="hljs-number">8</span>;    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">overtimePay</span><span class="hljs-params">(<span class="hljs-keyword">double</span> hoursWorked, <span class="hljs-keyword">double</span> payRate)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">pay</span><span class="hljs-params">(<span class="hljs-keyword">double</span> hoursWorked, <span class="hljs-keyword">double</span> payRate)</span> </span>&#123;      <span class="hljs-keyword">double</span> basePay = hoursWorked * payRate;      <span class="hljs-keyword">return</span> basePay + overtimePay(hoursWorked, payRate);    &#125;  &#125;&#125;</code></pre></li></ul><h3 id="将局部变量的作用域最小化"><a href="#将局部变量的作用域最小化" class="headerlink" title="将局部变量的作用域最小化"></a>将局部变量的作用域最小化</h3><p>将局部变量的作用域最小化，可以增强代码的可读性和可维护性，并降低出错的可能性。</p><ul><li>使一个局部变量的作用域最小化，最有力的技术是在第一次使用它的地方声明。如果变量在使用之前进行声明，这只会造成混乱————对于试图理解程序功能的读者来说，这又多了一种只会分散他们注意力的因素。等到用到该变量的时候，读者可能已经记不起该变量的类型或者初始值了。</li><li>尽量使局部变量的声明都包含一个初始化表达式，如果初始化条件不满足，就需要推迟声明。</li><li>使方法体尽可能小而集中 ，如果把两个操作（activity）合并到同一个方法中，与其中一个操作相关的局部变量就有可能会出现在执行另一个操作的代码范围之内。此时可以把这个方法分成两个，每个方法各执行一个操作。</li></ul><h3 id="精确计算，避免使用float和double"><a href="#精确计算，避免使用float和double" class="headerlink" title="精确计算，避免使用float和double"></a>精确计算，避免使用float和double</h3><p>float和double主要为了科学计算和工程计算而设计，执行二进制浮点运算，这是为了在广泛的数值范围上提供较为精确的快速近似计算而精心设计的。然而，它们没有提供完全精确的结果，所以不适合用于需要精确结果的场合，尤其是货币计算。</p><p>可以使用BigDecimal来解决这个问题，BigDecimal还提供了八种舍入模式来让开发者完全控制舍入，然而使用BigDecimal有两个缺点：与使用基本运算类型相比，这样做很不方便，而且很慢。</p><p>除了使用BigDecimal之外，还有一种办法是使用int或者long，到底选用int或者long，到底选用int或者long要取决于所涉及数值的大小，同时要自己处理十进制小数点。</p><h3 id="当心字符串连接的性能"><a href="#当心字符串连接的性能" class="headerlink" title="当心字符串连接的性能"></a>当心字符串连接的性能</h3><p>在存在大量字符串拼接或者大型字符串拼接的时候，尽量使用StringBuilder和StringBuffer，不要使用字符串连接操作符来合并多个字符串，除非性能无关紧要。</p><h3 id="控制方法的大小"><a href="#控制方法的大小" class="headerlink" title="控制方法的大小"></a>控制方法的大小</h3><p>尽量将方法长度控制的尽量小，方法复杂度&gt;=代码行数^2，当代码超过10行以上时，方法的复杂度就会大幅攀升，超过500行的代码可维护性就会大打折扣。</p>]]></content>
    
    
    <categories>
      
      <category>JVM虚拟机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入了解性能优化</title>
    <link href="/blog/2020/03/23/JVM-%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <url>/blog/2020/03/23/JVM-%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="性能评价-测试指标"><a href="#性能评价-测试指标" class="headerlink" title="性能评价/测试指标"></a>性能评价/测试指标</h2><p>一个web应用不是一个孤立的个体，它是一个系统的部分，系统中的每一部分都会影响整个系统的性能</p><ul><li><p><strong>响应时间</strong>：提交请求和返回该请求的响应之间使用的时间，一般比较关注平均响应时间。常用操作的响应时间列表：</p><table><thead><tr><th>操作</th><th>响应时间</th></tr></thead><tbody><tr><td>打开一个站点</td><td>几秒</td></tr><tr><td>数据库查询一条记录（有索引）</td><td>十几毫秒</td></tr><tr><td>机械磁盘一次寻址定位</td><td>4毫秒</td></tr><tr><td>从机械磁盘顺序读取1M数据</td><td>2毫秒</td></tr><tr><td>从SSD磁盘顺序读取1M数据</td><td>0.3毫秒</td></tr><tr><td>从远程分布式换成Redis读取一个数据</td><td>0.5毫秒</td></tr><tr><td>从内存读取1M数据</td><td>十几微妙</td></tr><tr><td>Java程序本地方法调用</td><td>几微妙</td></tr><tr><td>网络传输2Kb数据</td><td>1微妙</td></tr></tbody></table></li></ul><ul><li><strong>并发数</strong>：同一时刻，对服务器有实际交互的请求数。如果有1000个同时在线用户数，可以估计并发数在5%到15%之间，也就是同时并发数在50~150之间。</li><li><strong>吞吐量</strong>：对单位时间内完成的工作量（请求）的量度。</li></ul><p>当请求数很少时，响应速度比较快，但是单位时间的响应也比较少，所以吞吐量也比较少。随着请求数的增多，响应速度会收到影响，但是吞吐量会增加的很快；请求数的继续增加，响应速度影响比较大，单位时间内完成的请求次数会受到影响，会进一步影响到吞吐量。</p><p>如果请求数继续增加，导致系统资源耗尽，系统将会无法完成响应。</p><h2 id="性能优化的注意事项"><a href="#性能优化的注意事项" class="headerlink" title="性能优化的注意事项"></a>性能优化的注意事项</h2><ul><li><p><strong>避免过早优化</strong>：项目初期，我们应该着重于编写清晰，直接，易读和易理解高效优雅的代码，真正的优化应该留到以后，等到性能分析表明优化措施有巨大的收益时再进行。</p></li><li><p><strong>不应该把大量的时间耗费在小的性能改进上，过早考虑优化是所有噩梦的根源。</strong></p></li><li><p><strong>进行系统性能测试</strong>：所有的性能调优，都有应该建立在性能测试的基础上，直觉很重要，但是要用数据说话，可以推测，但是要通过测试求证。</p></li><li><p><strong>寻找系统瓶颈，分而治之，逐步优化</strong>：性能测试后，对整个请求经历的各个环节进行分析，排查出现性能瓶颈的地方，定位问题，分析影响性能的的主要因素，如内存、磁盘IO、网络、CPU、代码问题、架构设计、系统资源等。</p></li><li><p>调优是个很复杂、很细致的过程，要根据实际情况调整，不同的机器、不同的应用、不同的性能要求调优的手段都是不同的，也没有一个放之四海而皆准的配置或者公式。</p></li></ul><h2 id="前端优化常用手段"><a href="#前端优化常用手段" class="headerlink" title="前端优化常用手段"></a>前端优化常用手段</h2><ul><li><p><strong>合并请求</strong>：合并CSS，Js，图片请求，使用http中的keep-alive减少连接消耗（http1.1中默认开启，包括nginx）</p></li><li><p><strong>使用客户端缓冲</strong>：将静态资源文件（css、图标等）缓存在浏览器中，可以通过Cache-Control（相对时间）和Expires设置相关的属性，如果文件发生了变化，需要更新，则通过改变文件名来解决。</p></li><li><p><strong>启用压缩</strong>：使用压缩可以减少网络传输量，但也会给浏览器和服务器带来性能的压力，需要权衡使用。</p></li><li><p><strong>资源文件加载顺序</strong>：css放在页面前，js放在页面后，JS只要加载后就会立刻执行，有些JS可能执行时间比较长影响css加载速度，浏览器在加载完CSS才会对页面进行渲染。</p></li><li><p><strong>减少Cookie传输</strong>：cookie包含在每次的请求和响应中，因此哪些数据写入cookie需要慎重考虑（静态资源不需要放入cookie）</p></li><li><p><strong>友好的提示（非技术手段）</strong>：有时候在给用户一个提示，就能收到良好的效果。</p></li><li><p><strong>CDN加速</strong>：CDN，又称内容分发网络，本质是一个缓存，而且是将数据缓存在用户最近的地方。无法自行实现CDN的时候，可以根据经济实力考虑商用CDN服务。</p></li><li><p><strong>反向代理缓存（动静分离）</strong>：将静态资源文件缓存在反向代理服务器上，一般是Nginx。</p></li><li><p><strong>WEB组件分离</strong>：将js，css和图片文件放在不同的域名下。可以提高浏览器在下载web组件的并发数。因为浏览器在下载同一个域名的的数据存在并发数限制。</p></li></ul><h2 id="后端优化常用手段"><a href="#后端优化常用手段" class="headerlink" title="后端优化常用手段"></a>后端优化常用手段</h2><ol><li><p><strong>缓存</strong>：网站性能优化第一定律：优先考虑使用缓存优化性能。缓存是将数据存在访问速度较高的介质中，减少数据访问的时间，同时避免重复计算。合理使用缓存的准则：</p><ul><li>频繁修改的数据，尽量不要缓存，读写比2:1以上才有缓存的价值。</li><li>缓存一定是热点数据。</li><li>应用能够容忍一定时间的数据不一致。</li><li>缓存可用性问题，一般通过热备或者集群来解决。 </li></ul><p><strong>分布式缓存</strong>，即以集群的方式提供缓存服务，可以很好的将用户的请求分配到多个机器处理，对总体性能有很大的提升。集群有两种实现；</p><ul><li>需要更新同步的分布式缓存，所有的服务器保存相同的缓存数据，带来的问题就是，缓存的数据量受限制，其次，数据要在所有的机器上同步，代价很大。</li><li>每台机器只缓存一部分数据，然后通过一定的算法选择缓存服务器。常见的余数hash算法存在当有服务器上下线的时候，大量缓存数据重建的问题。所以提出了一致性哈希算法。</li></ul><p><strong>哈希一致性</strong>：首先求出服务器（节点）的哈希值，并将其配置到0～2的32次方的圆（continuum）上。然后采用同样的方法求出存储数据的键的哈希值，并映射到相同的圆上。然后从数据映射到的位置开始顺时针查找，将数据保存到找到的第一个服务器上。如果超过232仍然找不到服务器，就会保存到第一台服务器上。</p><p>哈希一致性算法对于节点的增减都只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性。</p><p><strong>数据倾斜</strong>：一致性哈希算法在服务节点太少时，容易因为节点分部不均匀而造成数据倾斜问题，此时必然造成大量数据集中到Node A上，而只有极少量会定位到Node B上。为了解决这种数据倾斜问题，一致性哈希算法引入了虚拟节点机制，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。具体做法可以在服务器ip或主机名的后面增加编号来实现。例如，可以为每台服务器计算三个虚拟节点，于是可以分别计算 “Node A#1”、“Node A#2”、“Node A#3”、“Node B#1”、“Node B#2”、“Node B#3”的哈希值，于是形成六个虚拟节点：同时数据定位算法不变，只是多了一步虚拟节点到实际节点的映射，例如定位到“Node A#1”、“Node A#2”、“Node A#3”三个虚拟节点的数据均定位到Node A上。这样就解决了服务节点少时数据倾斜的问题。在实际应用中，通常将虚拟节点数设置为32甚至更大，因此即使很少的服务节点也能做到相对均匀的数据分布。</p></li><li><p><strong>异步</strong>：<strong>同步和异步关注的是结果消息的通信机制</strong>，同步的意思就是调用方需要主动等待结果的返回，异步的意思就是不需要主动等待结果的返回，而是通过其他手段比如，状态通知，回调函数等。</p><p><strong>阻塞和非阻塞主要关注的是等待结果返回的调用方的状态</strong>，<strong>阻塞</strong>是指结果返回之前，当前线程被挂起，不做任何事。<strong>非阻塞</strong>是指结果在返回之前，线程可以做一些其他事，不会被挂起。</p><p><strong>同步阻塞</strong>基本也是编程中最常见的模型，比如说同步队列的take()方法，如果队列中没有元素，当前线程会一直阻塞直到获取到元素，BIO也属于同步阻塞。</p><p><strong>同步非阻塞</strong>在编程中可以抽象为一个轮询模式，比如说同步队列的poll()方法，如果队列中没有元素会返回null，此时我们可以执行其他的逻辑，在此期间会不断调用poll()方法直到不为null，jdk里的NIO就属于 同步非阻塞。</p><p><strong>异步阻塞</strong>这个编程里面用的较少，如果在线程池中提交有返回值的任务之后，马上调用future.get()，此时线程会马上被阻塞，直到任务之行结束。所以这个模式有点憨，与同步阻塞的效果相同，但还需要调用资源开辟线程。</p><p><strong>异步非阻塞</strong>例如jdk提供的CompletableFuture，它采用了观察者设计模式，可以完成异步非阻塞的计算，弥补了future阻塞式获取结果的不足，jdk里的AIO就属于异步。</p><p><strong>常见异步的手段</strong>有Servlet异步、多线程、消息队列。</p></li><li><p><strong>代码优化</strong>：一个应用的性能归根结底取决于代码是如何编写的。</p><ul><li><p><strong>选择合适的数据结构</strong>，比如ArrayList和LinkedList的选择，LinkedList在进行add()操作时不需要进行扩容，而ArrayList内部是数组实现，数据量较大时会进行扩容，扩容时的数据复制会比较耗费时间。</p></li><li><p><strong>选择更优的算法</strong></p></li><li><p><strong>编写更少的代码</strong></p></li><li><p><strong>并发编程</strong></p></li><li><p><strong>资源的复用</strong>，目的是减少开销很大的系统资源的创建和销毁，比如数据库连接，网络通信连接，线程资源等等。</p></li><li><p><strong>单例模式</strong>，比如Spring中的bean，减少了频繁创建对象产生的资源占用。</p></li><li><p><strong>池化技术</strong>，跟单例模式相同。</p></li></ul></li><li><p><strong>存储性能优化</strong>：如<strong>尽量使用SSD</strong>、<strong>定时清理数据或者按数据的性质分开存放</strong>、<strong>结果集处理</strong>，比如用setFetchSize控制jdbc每次从数据库中返回多少数据。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>JVM虚拟机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>性能优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>总复习和常见的并发面试题</title>
    <link href="/blog/2020/03/04/%E6%80%BB%E5%A4%8D%E4%B9%A0%E5%92%8C%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B9%B6%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/blog/2020/03/04/%E6%80%BB%E5%A4%8D%E4%B9%A0%E5%92%8C%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B9%B6%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="总复习和常见并发面试题"><a href="#总复习和常见并发面试题" class="headerlink" title="总复习和常见并发面试题"></a>总复习和常见并发面试题</h2><h3 id="谈面试"><a href="#谈面试" class="headerlink" title="谈面试"></a>谈面试</h3><ol><li><p>面试主要分为两块：一块是考查工程师对基础知识（包括了技术广度、深度、对技术的热情度等）的掌握程度，因为<strong>基础知识决定了一个技术人员发展的上限</strong>；另一块是考察工程师的工程能力，比如：做过哪些项目？遇到最难的问题怎样解决的？说说最有成就感的一项任务？<strong>工程能力是考察工程师当下能为公司带来的利益</strong>。当然还有其它考核方面：抗压性、合作能力。</p></li><li><p>Java只是一门语言，即使是Java工程师也不能局限于Java，要从面向对象语言本身，甚至从整个计算机体系，从工程实际出发看Java。</p></li><li><p>很多知识在一般公司的开发中是用不到的，常有人戏称：“面试造火箭，工作拧螺丝”，但这只是通常情况下公司对程序员的标准——迅速产出，完成任务。所以，工程师为了自己职业的发展不能局限于公司对自己的要求，不能停留在应用层面，要能够很好地掌握基础知识，要多看源码，自己多实践，学成记得产出，比如多为开源社区贡献代码，帮助初学者指路等。</p></li></ol><h3 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h3><ul><li><p>在java中守护线程和用户线程的区别？</p><p>java中的线程分为两种：守护线程（Daemon）和用户线程（User）。</p><p>任何线程都可以设置为守护线程和用户线程，通过方法Thread.setDaemon(bool on)；true则把该线程设置为守护线程，反之则为用户线程。Thread.setDaemon()必须在Thread.start()之前调用，否则运行时会抛出异常。</p><p>两者的区别： </p><p>唯一的区别是判断虚拟机(JVM)何时离开，Daemon是为其他线程提供服务，如果全部的User Thread已经结束，Daemon 没有可服务的线程，JVM关闭。</p><p>扩展：Thread Dump打印出来的线程信息，含有daemon字样的线程即为守护进程</p></li><li><p>线程与进程的区别</p><p>进程是操作系统分配资源的最小单元，线程是操作系统调度的最小单元。</p><p>一个程序至少有一个进程,一个进程至少有一个线程。</p></li><li><p>什么是多线程中的上下文切换</p><p>多线程会共同使用一组计算机上的CPU，而线程数大于给程序分配的CPU数量时，为了让各个线程都有执行的机会，就需要轮转使用CPU。不同的线程切换使用CPU发生的切换数据等就是上下文切换。</p></li><li><p>死锁与活锁的区别，死锁与饥饿的区别？</p><p>死锁：是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。 </p><p>产生死锁的必要条件： </p><p>互斥条件：所谓互斥就是进程在某一时间内独占资源。</p><p>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 </p><p>不剥夺条件:进程已获得资源，在末使用完之前，不能强行剥夺。 </p><p>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</p><p>活锁：任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。</p><p>活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，所谓的“活”， 而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。</p><p>饥饿：一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行的状态。</p></li><li><p>synchronized底层实现原理</p><p>synchronized (this)原理：涉及两条指令：monitorenter，monitorexit；再说同步方法，从同步方法反编译的结果来看，方法的同步并没有通过指令monitorenter和monitorexit来实现，相对于普通方法，其常量池中多了ACC_SYNCHRONIZED标示符。</p><p>JVM就是根据该标示符来实现方法的同步的：当方法被调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。在方法执行期间，其他任何线程都无法再获得同一个monitor对象。</p><p>注意，这个问题可能会接着追问，java对象头信息，偏向锁，轻量锁，重量级锁及其他们相互间转化。</p></li><li><p>什么是线程组，为什么在Java中不推荐使用？</p><p>ThreadGroup类，可以把线程归属到某一个线程组中，线程组中可以有线程对象，也可以有线程组，组中还可以有线程，这样的组织结构有点类似于树的形式。</p><ol><li>线程组ThreadGroup对象中比较有用的方法是stop、resume、suspend等方法，由于这几个方法会导致线程的安全问题（主要是死锁问题），已经被官方废弃掉了，所以线程组本身的应用价值就大打折扣了。</li><li>线程组ThreadGroup不是线程安全的，这在使用过程中获取的信息并不全是及时有效的，这就降低了它的统计使用价值。</li></ol></li><li><p>什么是Executors框架？为什么使用Executor框架？</p><p>Executor框架是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架。</p><p>每次执行任务创建线程 new Thread()比较消耗性能，创建一个线程是比较耗时、耗资源的。</p><p>调用 new Thread()创建的线程缺乏管理，而且可以无限制的创建，线程之间的相互竞争会导致过多占用系统资源而导致系统瘫痪，还有线程之间的频繁交替也会消耗很多系统资源。</p><p>接使用new Thread() 启动的线程不利于扩展，比如定时执行、定期执行、定时定期执行、线程中断等都不便实现。</p></li><li><p>在Java中Executor和Executors的区别？</p><p>Executors 工具类的不同方法按照我们的需求创建了不同的线程池，来满足业务的需求。 </p><p>Executor 接口对象能执行我们的线程任务。 </p><p>ExecutorService接口继承了Executor接口并进行了扩展，提供了更多的方法我们能获得任务执行的状态并且可以获取任务的返回值。 </p><p>使用ThreadPoolExecutor 可以创建自定义线程池。</p></li><li><p>什么是原子操作？在Java Concurrency API中有哪些原子类(atomic classes)<strong>？</strong></p><p>原子操作（atomic operation）意为”不可被中断的一个或一系列操作” 。 </p><p>处理器使用基于对缓存加锁或总线加锁的方式来实现多处理器之间的原子操作。 </p><p>在Java中可以通过锁和循环CAS的方式来实现原子操作。 CAS操作——Compare &amp; Set，或是 Compare &amp; Swap，现在几乎所有的CPU指令都支持CAS的原子操作。</p><p>java.util.concurrent.atomic下提供了大量的原子操作类，比如原子类：AtomicBoolean，AtomicInteger，AtomicLong，AtomicReference ，原子数组：AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray ，原子属性更新器：AtomicLongFieldUpdater，AtomicIntegerFieldUpdater，AtomicReferenceFieldUpdater</p></li><li><p>Java Concurrency API中的Lock接口(Lock interface)是什么？对比synchronized它有什么优势？</p><p>Lock接口比同步方法和同步块提供了更具扩展性的锁操作。 </p><p>他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。</p><p>它的优势有：可以使锁更公平，可以使线程在等待锁的时候响应中断，可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间，可以在不同的范围，以不同的顺序获取和释放锁。</p><p>整体上来说Lock是synchronized的扩展版，Lock提供了无条件的、可轮询的(tryLock方法)、定时的(tryLock带参方法)、可中断的(lockInterruptibly)、可多条件队列的(newCondition方法)锁操作。另外Lock的实现类基本都支持非公平锁(默认)和公平锁，synchronized只支持非公平锁，当然，在大部分情况下，非公平锁是高效的选择。</p></li><li><p>什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？</p><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。</p><p>这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。</p><p>阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p><p>JDK7提供了7个阻塞队列。在实现上，主要是利用了Condition和Lock的等待通知模式。</p></li><li><p>什么是Callable和Future?</p><p>Callable接口类似于Runnable，从名字就可以看出来了，但是Runnable不会返回结果，并且无法抛出返回结果的异常，而Callable功能更强大一些，被线程执行后，可以返回值，这个返回值可以被Future拿到，也就是说，</p><p>Future可以拿到异步执行任务的返回值，可以认为是带有回调的Runnable。</p><p>Future接口表示异步任务，是还没有完成的任务给出的未来结果。所以说Callable用于产生结果，Future用于获取结果。</p></li><li><p>什么是<strong>FutureTask?</strong></p><p>在Java并发程序中FutureTask表示一个可以取消的异步运算。它有启动和取消运算、查询运算是否完成和取回运算结果等方法。只有当运算完成的时候结果才能取回，如果运算尚未完成get方法将会阻塞。一个FutureTask对象可以对调用了Callable和Runnable的对象进行包装，由于FutureTask也是调用了Runnable接口所以它可以提交给Executor来执行。</p></li><li><p>什么是并发容器的实现？</p><p>何为同步容器：可以简单地理解为通过synchronized来实现同步的容器，如果有多个线程调用同步容器的方法，它们将会串行执行。比如Vector，Hashtable，以及Collections.synchronizedSet，synchronizedList等方法返回的容器。 </p><p>并发容器使用了与同步容器完全不同的加锁策略来提供更高的并发性和伸缩性，例如在ConcurrentHashMap中采用了一种粒度更细的加锁机制，可以称为分段锁，在这种锁机制下，允许任意数量的读线程并发地访问map，并且执行读操作的线程和写操作的线程也可以并发的访问map，同时允许一定数量的写操作线程并发地修改map，所以它可以在并发环境下实现更高的吞吐量。</p></li><li><p>多线程同步和互斥有几种实现方法，都是什么？</p><p>线程同步是指线程之间所具有的一种制约关系，一个线程的执行依赖另一个线程的消息，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒。 </p><p>线程互斥是指对于共享的进程系统资源，在各单个线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步。</p><p>线程间的同步方法大体可分为两类：用户模式和内核模式。顾名思义，内核模式就是指利用系统内核对象的单一性来进行同步，使用时需要切换内核态与用户态，而用户模式就是不需要切换到内核态，只在用户态完成操作。 </p><p>用户模式下的方法有：原子操作（例如一个单一的全局变量），临界区。内核模式下的方法有：事件，信号量，互斥量。</p></li><li><p>什么是竞争条件？</p><p>当多个进程都企图对共享数据进行某种处理，而最后的结果又取决于进程运行的顺序时，则我们认为这发生了竞争条件（race condition）。</p></li><li><p>为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？</p><p>当你调用start()方法时你将创建新的线程，并且执行在run()方法里的代码。 </p><p>但是如果你直接调用run()方法，它不会创建新的线程也不会执行调用线程的代码，只会把run方法当作普通方法去执行。</p></li><li><p>在Java中CycliBarriar和CountdownLatch有什么区别？</p><p>CyclicBarrier可以重复使用，而CountdownLatch不能重复使用。 </p></li><li><p>什么是不可变对象，它对写并发应用有什么帮助？</p><p>不可变对象(Immutable Objects)即对象一旦被创建它的状态（对象的数据，也即对象属性值）就不能改变，反之即为可变对象(Mutable Objects)。 </p><p>不可变对象的类即为不可变类(Immutable Class)。Java平台类库中包含许多不可变类，如String、基本类型的包装类、BigInteger和BigDecimal等。 </p><p>不可变对象天生是线程安全的。它们的常量（域）是在构造函数中创建的。既然它们的状态无法修改，这些常量永远不会变。</p><p>不可变对象永远是线程安全的。 </p><p>只有满足如下状态，一个对象才是不可变的； </p><p>它的状态不能在创建后再被修改； </p><p>所有域都是final类型；</p><p>它被正确创建；</p></li><li><p>notify()和notifyAll()有什么区别？</p><p>当一个线程进入wait之后，就必须等其他线程notify/notifyall,使用notifyall,可以唤醒所有处于wait状态的线程，使其重新进入锁的争夺队列中，而notify只能唤醒一个。</p><p>如果没把握，建议notifyAll，防止notigy因为信号丢失而造成程序异常。</p></li><li><p>什么是可重入锁（ReentrantLock）？谈谈它的实现。</p><p>线程可以重复进入任何一个它已经拥有的锁所同步着的代码块，synchronized、ReentrantLock都是可重入的锁。在实现上，就是线程每次获取锁时判定如果获得锁的线程是它自己时，简单将计数器累积即可，每 释放一次锁，进行计数器累减，直到计算器归零，表示线程已经彻底释放锁。</p></li><li><p>当一个线程进入某个对象的一个synchronized的实例方法后，其它线程是否可进入此对象的其它方法？</p><p>如果其他方法没有synchronized的话，其他线程是可以进入的。所以要开放一个线程安全的对象时，得保证每个方法都是线程安全的。</p></li><li><p>乐观锁和悲观锁的理解及如何实现，有哪些实现方式？</p><p><strong>悲观锁：</strong>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。Java里面的同步原语synchronized关键字的实现是悲观锁。</p><p><strong>乐观锁：</strong>顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。在Java中j原子变量类就是使用了乐观锁的一种实现方式CAS实现的。</p><p>乐观锁的实现方式： </p><ul><li>使用版本标识来确定读到的数据与提交时的数据是否一致。提交后修改版本标识，不一致时可以采取丢弃和再次尝试的策略。 </li><li>java中的Compare and Swap即CAS ，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。</li></ul></li><li><p>什么是CAS操作，缺点是什么？</p><p>CAS的基本思路就是，如果这个地址上的值和期望的值相等，则给其赋予新值，否则不做任何事儿，但是要返回原值是多少。每一个CAS操作过程都包含三个运算符：一个内存地址V，一个期望的值A和一个新值B，操作的时候如果这个地址上存放的值等于这个期望的值A，则将地址上的值赋为新值B，否则不做任何操作。</p><p>CAS缺点： </p><p>ABA问题：比如说一个线程one从内存位置V中取出A，这时候另一个线程two也从内存中取出A，并且two进行了一些操作变成了B，然后two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后one操作成功。尽管线程one的CAS操作成功，但可能存在潜藏的问题。从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。 </p><p>循环时间长开销大： </p><p>对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。 </p><p>只能保证一个共享变量的原子操作： </p><p>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。</p></li><li><p>SynchronizedMap和ConcurrentHashMap有什么区别？</p><p>SynchronizedMap一次锁住整张表来保证线程安全，所以每次只能有一个线程来访为map。</p><p>ConcurrentHashMap使用分段锁来保证在多线程下的性能。</p></li><li><p>写时复制容器可以用于什么应用场景？</p><p>CopyOnWrite并发容器用于对于绝大部分访问都是读，且<strong>偶尔写</strong>的并发场景。比如白名单，黑名单，商品类目的访问和更新场景。</p><p>透露的思想：</p><p>读写分离</p><p>最终一致性 </p><p>使用另外开辟空间的思路，来解决并发冲突</p></li><li><p>volatile有什么用？能否用一句话说明下volatile的应用场景？</p><p>volatile保证内存可见性和禁止指令重排。</p><p>volatile用于多线程环境下的一写多读，或者无关联的多写。</p></li><li><p>为什么代码会重排序？</p><p>在执行程序时，为了提供性能，处理器和编译器常常会对指令进行重排序，但是不能随意重排序，它需要满足以下两个条件：</p><p>在单线程环境下不能改变程序运行的结果；</p><p>存在数据依赖关系的不允许重排序</p></li><li><p>在java中wait和sleep方法的不同？</p><p>最大的不同是在等待时wait会释放锁，而sleep一直持有锁。Wait通常被用于线程间交互，sleep通常被用于暂停执行。</p></li><li><p>一个线程运行时发生异常会怎样？</p><p>如果异常没有被捕获该线程将会停止执行。Thread.UncaughtExceptionHandler是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候JVM会使用Thread.getUncaughtExceptionHandler()来查询线程的UncaughtExceptionHandler并将线程和异常作为参数传递给handler的uncaughtException()方法进行处理。</p></li><li><p>为什么wait, notify 和 notifyAll这些方法不在thread类里面？</p><p>JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。</p></li><li><p>什么是ThreadLocal变量？</p><p>ThreadLocal是Java里一种特殊的变量。每个线程都有一个ThreadLocal就是每个线程都拥有了自己独立的一个变量，竞争条件被彻底消除了。</p></li><li><p>Java中interrupted和isInterrupted方法的区别？</p><p>interrupted() 和 isInterrupted()的主要区别是前者会将中断状态清除而后者不会。Java多线程的中断机制是用内部标识来实现的，调用Thread.interrupt()来中断一个线程就会设置中断标识为true。当中断线程调用静态方法Thread.interrupted()来检查中断状态时，中断状态会被清零。而非静态方法isInterrupted()用来查询其它线程的中断状态且不会改变中断状态标识。</p></li><li><p>为什么wait和notify方法要在同步块中调用？</p><p>主要是因为Java API强制要求这样做，如果你不这么做，你的代码会抛出IllegalMonitorStateException异常。</p></li><li><p>为什么你应该在循环中检查等待条件<strong>?</strong></p><p>处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。因此，当一个等待线程醒来时，不能认为它原来的等待状态仍然是有效的，在notify()方法调用之后和等待线程醒来之前这段时间它可能会改变。这就是在循环中使用wait()方法效果更好的原因</p></li><li><p>怎么检测一个线程是否拥有锁？</p><p>在java.lang.Thread中有一个方法叫holdsLock()，它返回true如果当前线程拥有某个具体对象的锁。</p></li><li><p>你如何在Java中获取线程堆栈？</p><p>kill -3 [java pid] 不会在当前终端输出，它会输出到代码执行的或指定的地方去。比如，kill -3 tomcat pid, 输出堆栈到log目录下。</p><p>Jstack [java pid] 这个比较简单，在当前终端显示，也可以重定向到指定文件中。</p><p>或者使用Java提供的拟机线程系统的管理接口ManagementFactory.getThreadMXBean()。</p></li><li><p>Java线程池中submit() <strong>和</strong> execute()方法有什么区别？</p><p>两个方法都可以向线程池提交任务</p><p>execute()方法的返回类型是void，它定义在Executor接口中。</p><p>submit()方法可以返回持有计算结果的Future对象，它定义在ExecutorService接口中，它扩展了Executor接口</p></li><li><p>你对线程优先级的理解是什么？</p><p>每一个线程都是有优先级的，一般来说，高优先级的线程在运行时会具有优先权，但这依赖于线程调度的实现，这个实现是和操作系统相关的(OS dependent)。我们可以定义线程的优先级，但是这并不能保证高优先级的线程会在低优先级的线程前执行。线程优先级是一个int变量(从1-10)，1代表最低优先级，10代表最高优先级。</p><p>java的线程优先级调度会委托给操作系统去处理，所以与具体的操作系统优先级有关，如非特别需要，一般无需设置线程优先级。</p></li><li><p>你如何确保main()方法所在的线程是Java 程序最后结束的线程？</p><p>可以使用Thread类的join()方法（或者CountDownLatch工具类）来确保所有程序创建的线程在main()方法退出前结束。</p></li><li><p>为什么Thread类的sleep()和yield ()方法是静态的？</p><p>Thread类的sleep()和yield()方法将在当前正在执行的线程上运行。所以在其他处于等待状态的线程上调用这些方法是没有意义的。这就是为什么这些方法是静态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法。</p></li><li><p>现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？</p><p>可以用join方法实现。</p></li><li><p>你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它？</p><p>volatile关键字，读写锁，写时复制等等都可以实现。</p></li><li><p>用Java实现阻塞队列</p><p>见作业答案：包cn.enjoyedu.ch5.answer下</p></li><li><p>用Java写代码来解决生产者——消费者问题。</p><p>阻塞队列实现即可，也可以用wait和notify来解决这个问题，或者用Semaphore（信号量）</p></li><li><p>用Java编程一个会导致死锁的程序，你将怎么解决？</p><p> 参见代码cn.enjoyedu.ch7. NormalDeadLock，如何解决死锁，参见笔记。</p></li><li><p>Java中如何停止一个线程？</p><p>使用共享变量的方式 </p><p>在这种方式中，之所以引入共享变量，是因为该变量可以被多个执行相同任务的线程用来作为是否中断的信号，通知中断线程的执行。</p><p>使用interrupt方法终止线程 </p><p>如果一个线程由于等待某些事件的发生而被阻塞，比如当一个线程由于需要等候键盘输入而被阻塞，或者调用Thread.join()方法，或者Thread.sleep()方法，在网络中调用ServerSocket.accept()方法，或者调用了DatagramSocket.receive()方法时，都有可能导致线程阻塞，使线程处于处于不可运行状态时，即使主程序中将该线程的共享变量设置为true，但该线程此时根本无法检查循环标志，当然也就无法立即中断。所以应该尽量使用Thread提供的interrupt()方法，因为该方法虽然不会中断一个正在运行的线程，但是它可以使一个被阻塞的线程抛出一个中断异常，从而使线程提前结束阻塞状态。</p></li><li><p>JVM中哪个参数是用来控制线程的栈堆栈大小的</p><p>-Xss</p></li><li><p>如果同步块内的线程抛出异常锁会释放吗？</p><p>会</p></li><li><p>单例模式的双重检查实现是什么？为什么并不安全？如何在Java中创建线程安全的Singleton？</p><p>实现参见cn.enjoyedu.ch7.dcl. SingleDcl，不安全的根本原因是重排序会导致未初始化完成的对象可以被其他线程看见而导致错误。创建安全的单例模式有：延迟占位模式、在声明的时候就new这个类的实例、枚举</p></li><li><p>写出3条你遵循的多线程最佳实践</p><p>给你的线程起个有意义的名字。 这样可以方便找bug或追踪。OrderProcessor, QuoteProcessor or TradeProcessor 这种名字比 Thread-1. Thread-2 and Thread-3 好多了，给线程起一个和它要完成的任务相关的名字，所有的主要框架甚至JDK都遵循这个最佳实践。</p><p>避免锁定和缩小同步的范围 锁花费的代价高昂且上下文切换更耗费时间空间，试试最低限度的使用同步和锁，缩小临界区。因此相对于同步方法我更喜欢同步块，它给我拥有对锁的绝对控制权。</p><p>多用同步类少用wait 和 notify 首先，CountDownLatch, Semaphore, CyclicBarrier 和 Exchanger 这些同步类简化了编码操作，而用wait和notify很难实现对复杂控制流的控制。其次，这些类是由最好的企业编写和维护在后续的JDK中它们还会不断优化和完善，使用这些更高等级的同步工具你的程序可以不费吹灰之力获得优化。</p><p>多用并发集合少用同步集合 这是另外一个容易遵循且受益巨大的最佳实践，并发集合比同步集合的可扩展性更好，所以在并发编程时使用并发集合效果更好。</p><p>比如并发编程的黄金原则，尽量无锁化编程等等……..</p></li><li><p>请概述线程池的创建参数，怎么样合理配置一个线程池的参数？</p><p>参见笔记中线程池一章的内容</p></li><li><p>请概述锁的公平和非公平，JDK内部是如何实现的。</p><p>公平锁是指所有试图获得锁的线程按照获取锁的顺序依次获得锁，而非公平锁则是当前的锁状态没有被占用时,当前线程可以直接占用,而不需要等待。在实现上，非公平锁逻辑基本跟公平锁一致，唯一的区别是，当前线程不需要判断同步队列中是否有等待线程。</p><p>非公平锁性能高于公平锁性能。首先，在恢复一个被挂起的线程与该线程真正运行之间存在着严重的延迟。而且，非公平锁能更充分的利用cpu的时间片，尽量的减少cpu空闲的状态时间。</p><p>使用场景的话呢，其实还是和他们的属性一一相关，比如：如果业务中线程占用(处理)时间要远长于线程等待，那用非公平锁其实效率并不明显，但是用公平锁可以保证不会有线程被饿死。</p></li><li><p>请概述AQS</p><p>是用来构建锁或者其他同步组件的基础框架，比如ReentrantLock、ReentrantReadWriteLock和CountDownLatch就是基于AQS实现的。它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。它是CLH队列锁的一种变体实现。它可以实现2种同步方式：独占式，共享式。</p><p>AQS的主要使用方式是继承，子类通过继承AQS并实现它的抽象方法来管理同步状态，同步器的设计基于模板方法模式，所以如果要实现我们自己的同步工具类就需要覆盖其中几个可重写的方法，如tryAcquire、tryReleaseShared等等。</p><p>这样设计的目的是同步组件（比如锁）是面向使用者的，它定义了使用者与同步组件交互的接口（比如可以允许两个线程并行访问），隐藏了实现细节；同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。这样就很好地隔离了使用者和实现者所需关注的领域。</p><p>在内部，AQS维护一个共享资源state，通过内置的FIFO来完成获取资源线程的排队工作。该队列由一个一个的Node结点组成，每个Node结点维护一个prev引用和next引用，分别指向自己的前驱和后继结点，构成一个双端双向链表。</p><p>同时与Condition相关的等待队列，节点类型也是Node，构成一个单向链表。</p></li><li><p>请概述volatile</p><p>volatile关键字的作用主要有两点：</p><p>多线程主要围绕可见性和原子性两个特性而展开，使用volatile关键字修饰的变量，保证了其在多线程之间的可见性，即每次读取到volatile变量，一定是最新的数据。但是volatile只能以保证任意单个volatile变量的读/写具有原子性，但类似于++这种复合操作不具有原子性。</p><p>代码底层在执行时为了获取更好的性能会对指令进行重排序，多线程下可能会出现一些意想不到的问题。使用volatile则会对禁止重排序，当然这也一定程度上降低了代码执行效率。</p><p>同时在内存语义上，当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存，当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。</p><p>在Java中对于volatile修饰的变量，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序问题、强制刷新和读取。</p><p>在具体实现上，volatile关键字修饰的变量会存在一个“lock:”的前缀。它不是一种内存屏障，但是它能完成类似内存屏障的功能。Lock会对CPU总线和高速缓存加锁，可以理解为CPU指令级的一种锁。</p><p>同时该指令会将当前处理器缓存行的数据直接写会到系统内存中，且这个写回内存的操作会使在其他CPU里缓存了该地址的数据无效。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实战项目</title>
    <link href="/blog/2020/02/02/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE/"/>
    <url>/blog/2020/02/02/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="可查询进度的并发任务执行框架"><a href="#可查询进度的并发任务执行框架" class="headerlink" title="可查询进度的并发任务执行框架"></a>可查询进度的并发任务执行框架</h2><h3 id="需求的产生和分析"><a href="#需求的产生和分析" class="headerlink" title="需求的产生和分析"></a>需求的产生和分析</h3><p>公司里有两个项目组，考试组有批量的离线文档要生成，题库组则经常有批量的题目进行排重和根据条件批量修改题目的内容。</p><p>架构组通过对实际的上线产品进行用户调查，发现这些功能在实际使用时，用户都反应速度很慢，而且提交任务后，不知道任务的进行情况，做没做？做到哪一步了？有哪些成功？哪些失败了？都一概不知道。</p><p>架构组和实际的开发人员沟通，他们都说，因为前端提交任务到Web后台以后，是一次要处理多个文档和题目，所以速度快不起来。提示用多线程进行改进，实际的开发人员表示多线程没有用过，不知道如何使用，也担心用不好。综合以上情况，架构组决定在公司的基础构件库中提供一个并发任务执行框架，以解决上述用户和业务开发人员的痛点：</p><ol><li><p>对批量型任务提供统一的开发接口</p></li><li><p>在使用上尽可能的对业务开发人员友好  </p></li><li><p>要求可以查询批量任务的执行进度</p></li></ol><h3 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h3><p>要实现这么一个批量任务并发执行的框架，我们来分析一下我们要做些什么？</p><ol><li><p>提高批量任务性能。必然的我们要使用java里的多线程，为了在使用上尽可能的对业务开发人员友好和简单，需要屏蔽一些底层java并发编程中的细节，让他们不需要去了解并发容器，阻塞队列，异步任务，线程安全等等方面的知识，只要专心于自己的业务处理即可。</p></li><li><p>每个批量任务拥有自己的上下文环境。因为一个项目组里同时要处理的批量任务可能有多个，比如考试组，可能就会有不同的学校的批量的离线文档生成，而题库组则会不同的学科都会有老师同时进行工作，因此需要一个并发安全的容器保存每个任务的属性信息，</p></li><li><p>自动清除已完成和过期任务。因为要提供进度查询，系统需要在内存中维护每个任务的进度信息以供查询，但是这种查询又是有时间限制的，一个任务完成一段时间后，就不再提供进度查询了，则就需要我们自动清除已完成和过期任务，用定时轮询吗？</p></li></ol><img src="/blog/2020/02/02/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE/pic1.png" srcset="/blog/img/loading.gif" class><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><ol><li><p>框架使用者业务方法的执行结果共有三种，成功：按预想的流程出了结果；失败：按预想的流程没出结果；异常：没按预想的流程抛出了预料之外的错误。因此我们定义了一个枚举，表示这三种情况。</p><img src="/blog/2020/02/02/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE/pic2.png" srcset="/blog/img/loading.gif" class><p>业务方法的返回值有很多种可能，基本类型、系统定义的对象类型、框架使用者自定义的对象类型都是存在的，所以需要用泛型来说表示这个结果。如果方法执行失败了，还需要告诉用户或者框架使用者失败的原因，还需要再定义一个任务的执行结束后的返回值类。</p><img src="/blog/2020/02/02/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE/pic3.png" srcset="/blog/img/loading.gif" class></li><li><p>定义执行业务方法的接口，框架就只执行这个方法，框架的使用者都应该来实现这个接口，由于用户业务的数据多样性，方法的参数也应该用泛型。</p><img src="/blog/2020/02/02/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE/pic4.png" srcset="/blog/img/loading.gif" class></li><li><p>提供一种封装机制，让框架使用者可以将用户在前端提交的工作（JOB）提交给这个封装机制，当用户的需要查询进度的时候，也从这个封装机制中取得，同时封装机制内部也要负责清除已完成任务。</p><p>在这个封装机制里我们定义了一个类JobInfo，抽象了对用户工作（JOB）的封装，一个工作可以包含多个子任务（TASK），这个JobInfo中就包括了这个工作的相关信息，比如工作名，用以区分框架中唯一的工作，也可以避免重复提交，也方便查询时快速定位工作，除了工作名以外，工作中任务（TASK）的列表，工作中任务的处理器都在其中定义。</p><img src="/blog/2020/02/02/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE/pic5.png" srcset="/blog/img/loading.gif" class><p>同时JobInfo还有相当多的关于这个工作的方法，比如查询工作进度，查询每个任务的处理结果，记录每个任务的处理结果等等</p><img src="/blog/2020/02/02/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE/pic6.png" srcset="/blog/img/loading.gif" class><p>负责清除已完成任务，我们则交给CheckJobProcesser类来完成，定时轮询的机制不够优雅，因此我们选用了DelayQueue来实现这个功能</p><img src="/blog/2020/02/02/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE/pic7.png" srcset="/blog/img/loading.gif" class><p>并且在其中定义了清除已完成任务的Runnable和相关的工作线程。</p><img src="/blog/2020/02/02/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE/pic8.png" srcset="/blog/img/loading.gif" class></li><li><p>框架的主体类则是PendingJobPool，这也是框架使用者主要使用的类。这个类主要负责调度，例如工作（JOB）和任务（TASK）的提交，任务（TASK）的保存，任务（TASK）的并发执行，工作进度的查询接口和任务执行情况的查询等等。</p><img src="/blog/2020/02/02/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE/pic9.png" srcset="/blog/img/loading.gif" class><img src="/blog/2020/02/02/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE/pic10.png" srcset="/blog/img/loading.gif" class></li></ol><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><img src="/blog/2020/02/02/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE/pic11.png" srcset="/blog/img/loading.gif" class><p>如果需要spring集成的话，某些单例化的部分就不需要了。</p><h2 id="项目优化"><a href="#项目优化" class="headerlink" title="项目优化"></a>项目优化</h2><h3 id="项目背景和问题"><a href="#项目背景和问题" class="headerlink" title="项目背景和问题"></a>项目背景和问题</h3><p>这个项目来自为电信教育系统设计开发的一套自适应的考试学习系统，面向的用户主要是职业学院的的老师和学生以及短时间脱产学习的在职人员。什么叫自适应呢？就是当时提出一种教育理念，对学员的学习要求经常考试进行检查，学员的成绩出来以后，老师会要求系统根据每个学员的考卷上错误的题目从容量为10万左右的题库中抽取题目，为每个学员生成一套各自个性化的考后复习和练习的离线练习册。所以，每次考完试，特别是比较大型的考试后，要求生成的离线文档数量是比较多的，一个考试2000多人，就要求生成2000多份文档。当时我们在做这个项目的时候，因为时间紧，人员少，很快做出第一版就上线运营了。</p><p>当然，大家可以想到，问题是很多的，但是反应最大，用户最不满意的就是这个离线文档生成的功能，用户最不满意的点：离线文档生成的速度非常慢，慢到什么程度呢？一份离线文档的生成平均时长在50~55秒左右，遇到成绩不好的学生，文档内容多的，生成甚至需要3分钟，大家可以算一下，2000人，平均55秒，全部生成完，需要2000*55=110000秒，大约是30个小时。</p><p>为什么如此之慢？这跟离线文档的生成机制密切相关，对于每一个题目要从保存题库的数据库中找到需要的题目，单个题目的表现形式如图，数据库中存储则采用类html形式保存，对于每个题目而言，解析题目文本，找到需要下载的图片，每道题目都含有大量或大型的图片需要下载，等到文档中所有题目图片下载到本地完成后，整个文档才能继续进行处理。</p><h3 id="分析和改进"><a href="#分析和改进" class="headerlink" title="分析和改进"></a>分析和改进</h3><p>第一版的实现，服务器在接收到老师的请求后，就会把批量生成请求分解为一个个单独的任务，然后串行的完成。</p><img src="/blog/2020/02/02/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE/pic12.png" srcset="/blog/img/loading.gif" class><p>于是在第二版的实现上，首先我们做了个服务拆分，将生成离线文档的功能拆了出来成为了单独的服务，对外提供RPC接口，在WEB服务器接收到了老师们提出的批量生成离线文档的要求以后，将请求拆分后再一一调用离线文档生成RPC服务，这个RPC服务在实现的时候有一个缓冲的机制，会将收到的请求进行缓存，然后迅速返回一个结果给调用者，告诉调用者已经收到了请求，这样WEB服务器也可以很快的对用户的请求进行应答。</p><p>所以我们有了第一次改进，参见cn.enjoyedu.ch8b. RpcServiceWebV1</p><p> 我们看这个离线文档，每份文档的生成独立性是很高的，天生就适用于多线程并发进行。所以在RPC服务实现的时候，使用了生产者消费者模式，RPC接口的实现收到了一个调用方的请求时，会把请求打包放入一个容器，然后会有多个线程进行消费处理，也就是生成每个具体文档。</p><p>当文档生成后，再使用一次生产者消费者模式，投入另一个阻塞队列，由另外的一组线程负责进行上传。当上传成功完成后，由上传线程返回文档的下载地址，表示当前文档已经成功完成。</p><p>文档具体的下载地址则由WEB服务器单独去数据库或者缓存中去查询。</p><p><img src="blob:file:///808f1ea5-3745-41ac-b3fb-dac06fe50317" srcset="/blog/img/loading.gif" alt="pastedGraphic_1.png"></p><p>对于每个离线文档生成本身，我们来看看它的业务，</p><p>1、从容量为10万左右的题库中为每个学生抽取适合他的题目，</p><p>2、每道题目都含有大量的图片需要下载到本地，和文字部分一起渲染。</p><p>但是我们仔细考察整个系统的业务就会发现，我们是在一次考试后为学员生成自适应的练习册，换句话说，不管考试考察的内容如何，学生的成绩如何，每次考试的知识点是有限的，而从这些知识点中可以抽取的相关联的题目数也总是有限的，不同的学生之间所需要的题目会有很大的重复性。</p><p>举个例子我们为甲学生因为他考卷上的错误部分抽取了80个题目，有很大的概率其他学生跟甲学生错误的地方会有重复，相对应的题目也会有重复。对于这部分题目，我们是完全没有必要重复处理的，包括从数据库中重新获取题目、解析和下载图片。这也是我们可供优化的一大突破点。</p><p>其次，一篇练习册是由很多的题目组成的，每个题目相互之间是独立的，我们也可以完全并行的、异步的处理每个题目。</p><p>具体怎么做？要避免重复工作肯定是使用缓存机制，对已处理过的题目进行缓存。我们看看怎么使用缓存机制进行优化。这个业务，毋庸置疑，map肯定是最适合的，因为我们要根据题目的id来找题目的详情，用哪个map？我们现在是在多线程下使用，考虑的是并发安全的concurrentHashMap。</p><p>当我们的服务接收到处理一个题目的请求，首先会在缓存中get一次，没有找到，可以认为这是个新题目，准备向数据库请求题目数据并进行题目的解析，图片的下载。</p><p>这里有一个并发安全的点需要注意，因为是多线程的应用，会发生多个线程在处理多个文档时有同时进行处理相同题目的情况，这种情况下不做控制，一是会造成数据冲突和混乱，比如同时读写同一个磁盘文件，二是会造成计算资源的浪费，同时为了防止文档的生成阻塞在当前题目上，因此每个新题目的处理过程会包装成一个Callable投入一个线程池中 而把处理结果作为一个Future返回，等到线程在实际生成文档时再从Future中get出结果进行处理。因此在每个新题目实际处理前，还会检查当前是否有这个题目的处理任务正在进行。</p><p>如果题目在缓存中被找到，并不是直接引用就可以了，因为题库中的题目因为种种关系存在被修改的可能，比如存在错误，比如可能内容被替换，这个时候缓存中数据其实是失效过期的，所以需要先行检查一次。如何检查？</p><p>我们前面说过题库中的题目平均长度在800个字节左右，直接equals来检查题目正文是否变动过，明显效率比较低，所以我们这里又做了一番处理，什么处理？对题目正文事先做了一次SHA的摘要并保存在数据库，并且要求题库开发小组在处理题目数据入库的时候进行SHA摘要。</p><p>在本机缓存中同样保存了这个摘要信息，在比较题目是否变动过时，首先检查摘要是否一致，摘要一致说明题目不需要更新，摘要不一致时，才需要更新题目文本，将这个题目视为新题目，进入新题目的处理流程，这样的话就减少了数据的传输量，也降低了数据库的压力。</p><p>题目处理的流程就变为：</p><p><img src="blob:file:///5a45d7e5-6994-4eae-9ff7-7feb13186194" srcset="/blog/img/loading.gif" alt="pastedGraphic_2.png"></p><p>所以我们有了第二次改进，</p><p>1、在题目实体类QuestionInDBVo中增加一个</p><p><img src="blob:file:///0d5213fa-8bc0-435c-8088-3bded0d7bd21" srcset="/blog/img/loading.gif" alt="pastedGraphic_3.png"></p><p>2、增加一个题目保存在缓存中的实体类QuestionInCacheVo</p><p><img src="blob:file:///c567de1d-7575-4bd9-8a0b-ec9949b5aacd" srcset="/blog/img/loading.gif" alt="pastedGraphic_4.png"></p><p>3、增加一个并发处理时返回的题目结果实体类TaskResultVo</p><p><img src="blob:file:///658f3823-8257-49ac-a425-0ed1517749e9" srcset="/blog/img/loading.gif" alt="pastedGraphic_5.png"></p><p>按照我们前面的描述，我们可以得知，题目要么已经处理完成，要么正在处理，所以在获取题目结果时，先从questionDetail获取一次，获取为null，则从questionFuture获取。那么这个类的构造方法需要单独处理一下。</p><p><img src="blob:file:///e07738ef-3a22-46fa-9e04-43ce2bad9014" srcset="/blog/img/loading.gif" alt="pastedGraphic_6.png"></p><p>4、在处理文档的服务的类ProduceDocService中增加一个处理文档的新方法makeDocAsyn</p><p><img src="blob:file:///40cc1cc3-ddc5-40ed-95fe-4dc65cfd87ae" srcset="/blog/img/loading.gif" alt="pastedGraphic_7.png"></p><p>在这个方法中，会调用一个并发处理题目的方法。</p><p>5、增加一个优化题目处理的类ParallelQstService，其中提供了并发处理题目的方法，还包括了</p><p><img src="blob:file:///4f69b9df-654b-4d27-b6ca-0eb2ae208a22" srcset="/blog/img/loading.gif" alt="pastedGraphic_8.png"></p><p>主程序参见cn.enjoyedu.ch8b. RpcServiceWebV2</p><p><strong>继续改进</strong></p><p><strong>数据结构的改进</strong></p><p>但是我们仔细分析就会发现，作为一个长期运行的服务，如果我们使用concurrentHashMap，意味着随着时间的推进，缓存对内存的占用会不断的增长。最极端的情况，十万个题目全部被加载到内存，这种情况下会占据多少内存呢？我们做了统计，题库中题目的平均长度在800个字节左右，十万个题目大约会使用75M左右的空间。</p><p>看起来还好，但是有几点，第一，我们除了题目本身还会有其他的一些附属信息需要缓存，比如题目图片在本地磁盘的存储位置等等，那就说，实际缓存的数据内容会远远超过800个字节，</p><p>第二，map类型的的内存使用效率是比较低的，以hashmap为例，内存利用率一般只有20%到40%左右，而concurrentHashMap只会更低，有时候只有hashmap的十分之一到4分之一，这也就是说十万个题目放在concurrentHashMap中会实际占据几百兆的内存空间，是很容易造成内存溢出的，也就是大家常见的OOM。</p><p>考虑到这种情况，我们需要一种数据结构有map的方便但同时可以限制内存的占用大小或者可以根据需要按照某种策略刷新缓存。最后，在实际的工作中，我们选择了ConcurrentLinkedHashMap，这是由Google开源一个线程安全的hashmap，它本身是对ConcurrentHashMap的封装，可以限定最大容量，并实现一个了基于LRU也就是最近最少使用算法策略的进行更新的缓存。很完美的契合了我们的要求，对于已经缓冲的题目，越少使用的就可以认为这个题目离当前考试考察的章节越远，被再次选中的概率就越小，在容量已满，需要腾出空间给新缓冲的题目时，越少使用就会优先被清除。</p><p><strong>线程数的设置</strong></p><p>原来我们设置的线程数按照我们通用的IO密集型任务，两个线程池设置的都是机器的CPU核心数<em>2，但是这个就是最佳的吗？不一定，通过反复试验我们发现，处理文档的线程池线程数设置为CPU核心数</em>4，继续提高线程数并不能带来性能上的提升。而因为我们改进后处理文档的时间和上传文档的时间基本在1：4到1：3的样子，所以处理文档的线程池线程数设置为CPU核心数<em>4</em>3。</p><p>这时我们有了第三次改进，参见cn.enjoyedu.ch8b. RpcServiceWebV3</p><p><strong>缓存的改进</strong></p><p>在这里我们除了本地内存缓存还使用了本地文件存储，启用了一个二级缓存机制。为什么要使用本地文件存储？因为考虑到服务器会升级、会宕机，已经在内存中缓存的数据会丢失，为了避免这一点，我们将相关的数据在本地进行了一个持久化的操作，保存在了本地磁盘。</p><p><strong>改进后的效果</strong></p><p>1、原单WEB串行处理，3个文档耗时</p><p><img src="blob:file:///be0c58ca-0688-4cb3-879c-44286023edc4" srcset="/blog/img/loading.gif" alt="pastedGraphic_9.png"></p><p><strong>平均一个文档耗时**</strong>51<strong>**秒。</strong></p><p>2、服务化，文档生成并行化后，60个文档耗时</p><p><img src="blob:file:///ee6d333f-60d4-4c7e-a816-1b4f7952a0f4" srcset="/blog/img/loading.gif" alt="pastedGraphic_10.png"></p><p><strong>平均一个文档耗时**</strong>3.5<strong><strong>秒，已经比单</strong></strong>WEB<strong>**串行版的实现有了数量级上的提高。</strong></p><p>3、引入缓存避免重复工作、题目处理并行和异步化后，60个文档耗时</p><p><img src="blob:file:///b7138258-6a03-4bf9-adba-85ccf901fa2e" srcset="/blog/img/loading.gif" alt="pastedGraphic_11.png"></p><p><strong>平均一个文档耗时**</strong>0.65<strong>**秒，再次有了数量级上的提高。</strong></p><p>4、调整线程数后，60个文档耗时</p><p><img src="blob:file:///e71d7f5a-2eb8-494a-a6ba-abe801fcef1e" srcset="/blog/img/loading.gif" alt="pastedGraphic_12.png"></p><p><strong>平均一个文档耗时**</strong>0.23<strong><strong>秒，再次提升了</strong></strong>3<strong><strong>倍的速度</strong></strong>,<strong><strong>而相对我们第一版的性能而言，平均一个文档处理性能提升了</strong></strong>51/0.23=221<strong>**倍。</strong></p><p><strong>这就是善用并发编程后威力！</strong></p><p><strong>用户体验的改进</strong></p><p>还可以和我们前面实战的并发任务执行框架中的思想相结合，在前端显示处理进度，給用户带来更好的使用体验。</p><p><strong>启示</strong></p><p>这次项目的优化给我们带来了什么样的启示呢？</p><p>性能优化一定要建立在对业务的深入分析上，比如我们在性能优化的切入点，在缓存数据结构的选择就建立在对业务的深入理解上；</p><p>性能优化要善于利用语言的高并发特性，</p><p>性能优化多多利用缓存，异步任务等机制，正是因为我们使用这些特性和机制，才让我们的应用在性能上有个了质的飞跃；</p><ol><li>引入各种机制的同时要注意避免带来新的不安全因素和瓶颈，比如说缓存数据过期的问题，并发时的线程安全问题，都是需要我们去克服和解决的。</li></ol>]]></content>
    
    
    <categories>
      
      <category>并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>并发编程 - 实战项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发安全</title>
    <link href="/blog/2020/01/23/JUC-%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8/"/>
    <url>/blog/2020/01/23/JUC-%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h2><p>在《Java并发编程实战》中，定义如下：</p><p>类是线程安全是指当多个线程访问某个类时，不管线程将如何交替执行，调用代码中不需要增加任何额外保证安全性的代码，这个类也能始终表现出正确的行为。</p><h2 id="线程封闭"><a href="#线程封闭" class="headerlink" title="线程封闭"></a>线程封闭</h2><p>实现安全的并发是一件困难的事情，所以很多时候我们都想躲避并发。避免并发最简单的方法就是线程封闭。</p><p>线程封闭就是把对象封装到一个线程里，只有这一个线程能看到此对象。那么这个对象就算不是线程安全的也不会出现任何安全问题。</p><h3 id="ad-hoc线程封闭"><a href="#ad-hoc线程封闭" class="headerlink" title="ad-hoc线程封闭"></a>ad-hoc线程封闭</h3><p>Ad-hoc线程封闭是完全靠开发者控制的线程封闭，但没有任何一种语言特性能够将对象封闭到线程上，所以Ad-hoc线程封闭对开发的要求比较苛刻，非常脆弱，应该尽量避免使用。</p><h3 id="栈封闭"><a href="#栈封闭" class="headerlink" title="栈封闭"></a>栈封闭</h3><p>栈封闭是我们编程当中遇到的最多的线程封闭，栈封闭简单的说就是局部变量。当多个线程访问一个方法时，方法中的局部变量都会被线程在栈中重新创建，也就不会出现并发问题。全局变量一般是放在堆中，容易引起并发问题。在开发过程中应该尽量使用局部变量，避免使用全局变量。ThreadLocal本质上是每个线程内部都有一个value副本，相当于将value的副本封闭在栈中，所以使用ThreadLocal不会引发线程安全问题。</p><h3 id="无状态的类"><a href="#无状态的类" class="headerlink" title="无状态的类"></a>无状态的类</h3><p>成员变量被称为类的状态，没有任何成员变量的类，就是无状态的类，这种类一定是线程安全的。</p><p>即使这个类的方法参数中使用了对象，也是线程安全的，比如：</p><img src="/blog/2020/01/23/JUC-%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8/pic4.png" srcset="/blog/img/loading.gif" class><p>因为多线程下的使用，虽然user这个对象的实例会出现问题，但是它并不被StatelessClass这个类的对象实例所持有，所以Stateless这个类还是线程安全的。如果要避免在使用过程中出现问题的话，可以在user类中实现线程安全。</p><h3 id="让类不可变"><a href="#让类不可变" class="headerlink" title="让类不可变"></a>让类不可变</h3><p>让状态不可变，两种方式：</p><ol><li><p>使用final关键字：为该类的所有成员变量都应该加上final关键字。如果成员变量是一个对象时，这个对象所对应的类也应该是不可变类，才能保证整个类是不可变的。</p></li><li><p>不提供任何可供修改成员变量的地方，同时成员变量也不作为方法的返回值。</p></li></ol><p>注意：反射不属于正常使用方式，不在考虑范围内。如果类的成员变量中有对象，final关键字是保证引用不可变，并不能保证对应的实例不可变。在多线程下，对象在堆上的实例是有可能被多个线程同时修改的，没有正确处理的情况下，对象实例在堆中的数据是不可预知的，这就牵涉到了如何安全的发布对象这个问题。</p><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>只能保证类的可见性，并不能保证类的线程安全性。适合一个线程写，多个线程读的情景。</p><h3 id="加锁和CAS"><a href="#加锁和CAS" class="headerlink" title="加锁和CAS"></a>加锁和CAS</h3><p>是最常使用的保证线程安全的手段，包括使用<strong>synchronized</strong>关键字、显式锁、原子变量，或者修改数据时使用CAS机制等。</p><h3 id="安全的发布"><a href="#安全的发布" class="headerlink" title="安全的发布"></a>安全的发布</h3><p>类中持有的成员变量如果是基本类型，可以直接发布出去，此时发布出去的其实是这个变量的一个副本。</p><p>如果类中持有的成员变量是对象的引用，这个成员对象不是线程安全的，通过get等方法发布出去，会造成这个成员对象本身持有的数据在多线程下不正确的修改，从而造成整个类线程不安全的问题。</p><pre><code class="hljs arduino"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 不安全的发布</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnSafePublish</span> &#123;</span>   <span class="hljs-keyword">private</span> List&lt;Integer&gt; <span class="hljs-built_in">list</span> = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-number">3</span>);       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UnSafePublish</span><span class="hljs-params">()</span> </span>&#123;       <span class="hljs-built_in">list</span>.add(<span class="hljs-number">1</span>);       <span class="hljs-built_in">list</span>.add(<span class="hljs-number">2</span>);       <span class="hljs-built_in">list</span>.add(<span class="hljs-number">3</span>);    &#125;      <span class="hljs-function"><span class="hljs-keyword">public</span> List <span class="hljs-title">getList</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;      UnSafePublish unSafePublish = <span class="hljs-keyword">new</span> UnSafePublish();      List&lt;Integer&gt; <span class="hljs-built_in">list</span> = unSafePublish.getList();      System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">list</span>);      <span class="hljs-built_in">list</span>.add(<span class="hljs-number">4</span>);      System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">list</span>);      System.out.<span class="hljs-built_in">println</span>(unSafePublish.getList());   &#125;&#125;</code></pre><p>将list发布出去后，外部线程就可以修改这个list，如果有多个线程同时修改就会出现不安全的情况，所以在发布这对象出去的时，就应该用线程安全的方式包装这个对象。</p><pre><code class="hljs arduino"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 安全的发布</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SafePublishToo</span> &#123;</span>    <span class="hljs-keyword">private</span> List&lt;Integer&gt; <span class="hljs-built_in">list</span>            = Collections.synchronizedList(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-number">3</span>));    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SafePublishToo</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-built_in">list</span>.add(<span class="hljs-number">1</span>);        <span class="hljs-built_in">list</span>.add(<span class="hljs-number">2</span>);        <span class="hljs-built_in">list</span>.add(<span class="hljs-number">3</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> List <span class="hljs-title">getList</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;        SafePublishToo safePublishToo = <span class="hljs-keyword">new</span> SafePublishToo();        List&lt;Integer&gt; <span class="hljs-built_in">list</span> = safePublishToo.getList();        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">list</span>);        <span class="hljs-built_in">list</span>.add(<span class="hljs-number">4</span>);        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">list</span>);        System.out.<span class="hljs-built_in">println</span>(safePublishToo.getList());    &#125;&#125;</code></pre><p>将list用Collections.synchronizedList()进行包装以后，无论多少线程使用这个list，就都是线程安全的了。</p><p>对于我们自己使用或者声明的类，JDK自然没有提供这种包装类的办法，但是我们可以仿造这种模式或者委托给线程安全的类。</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 仿Collections对容器的包装，将内部成员对象进行线程安全包装</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SoftPublicUser</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> UserVo user;    <span class="hljs-function"><span class="hljs-keyword">public</span> UserVo <span class="hljs-title">getUser</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> user;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SoftPublicUser</span><span class="hljs-params">(UserVo user)</span> </span>&#123;        <span class="hljs-keyword">this</span>.user = <span class="hljs-keyword">new</span> SynUser(user);    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynUser</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">UserVo</span></span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> UserVo userVo;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object lock = <span class="hljs-keyword">new</span> Object();        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SynUser</span><span class="hljs-params">(UserVo userVo)</span> </span>&#123;            <span class="hljs-keyword">this</span>.userVo = userVo;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">synchronized</span> (lock)&#123;                System.out.println(<span class="hljs-string">"lock success"</span>);                <span class="hljs-keyword">return</span> userVo.getAge();            &#125;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;            <span class="hljs-keyword">synchronized</span> (lock)&#123;                userVo.setAge(age);            &#125;        &#125;    &#125;&#125;</code></pre><p>如果为final类，则可以采用委托的方式，将一些方法委托给一个线程安全的类。</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 类说明：委托给线程安全的类来做</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SafePublicFinalUser</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SynFinalUser user;    <span class="hljs-function"><span class="hljs-keyword">public</span> SynFinalUser <span class="hljs-title">getUser</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> user;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SafePublicFinalUser</span><span class="hljs-params">(FinalUserVo user)</span> </span>&#123;        <span class="hljs-keyword">this</span>.user = <span class="hljs-keyword">new</span> SynFinalUser(user);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynFinalUser</span></span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> FinalUserVo userVo;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object lock = <span class="hljs-keyword">new</span> Object();        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SynFinalUser</span><span class="hljs-params">(FinalUserVo userVo)</span> </span>&#123;            <span class="hljs-keyword">this</span>.userVo = userVo;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">synchronized</span> (lock)&#123;                <span class="hljs-keyword">return</span> userVo.getAge();            &#125;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;            <span class="hljs-keyword">synchronized</span> (lock)&#123;                userVo.setAge(age);            &#125;        &#125;    &#125;&#125;</code></pre><p>对这种通过get等方法发布出去的对象，最根本的解决办法还是应该在实现上就考虑到线程安全问题。</p><h3 id="TheadLocal"><a href="#TheadLocal" class="headerlink" title="TheadLocal"></a>TheadLocal</h3><p>ThreadLocal是实现线程封闭的最好方法。ThreadLocal为每个线程都创建一个ThreadLocalMap，Map的key是ThreadLoacl对象，Map的值就是我们要封闭的对象。每个线程中的ThreadLocalMap互不影响，避免了多个线程操作同一个对象的情况。</p><h3 id="Servlet辨析"><a href="#Servlet辨析" class="headerlink" title="Servlet辨析"></a>Servlet辨析</h3><p>servlet其实不是线程安全的类，由于很少有对Servlet中成员变量的写操作的需求，一般情况下并不会引发线程安全问题，但是一旦有多线程下写servlet中的成员变量，就很容易产生线程安全问题。</p><p>servlet会为每个单独的请求创建单独的线程，即请求自始至终只有一个线程在处理，避免了并发读写的问题。</p><p>spring容器并没有使用ConcurrentHashMap而是使用了普通的Map，在初始化时通过Sync关键字来保证线程安全。这样做主要是因为spring只在初始化时进行放入Map的操作，之后的使用都是获取，相对于使用ConcurrentHashMap性能会更高。</p><h2 id="线程不安全引发的问题"><a href="#线程不安全引发的问题" class="headerlink" title="线程不安全引发的问题"></a>线程不安全引发的问题</h2><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法继续进行下去。此时称系统处于死锁状态或系统产生了死锁。</p><p>死锁是必然发生在多操作者（M&gt;=2个）情况下，争夺多个资源（N&gt;=2个，且N&lt;=M）才会发生这种情况。很明显，单线程自然不会有死锁；单资源情况下线程之间只会产生激烈竞争，也不会产生死锁。同时，死锁还有一个重要的要求，争夺资源的顺序不同，如果争夺资源的顺序是一样的，也不会产生死锁。</p><h4 id="学术化的定义"><a href="#学术化的定义" class="headerlink" title="学术化的定义"></a>学术化的定义</h4><p>死锁的发生必须具备以下四个必要条件。 </p><ol><li><p>互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。</p></li><li><p>请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</p></li><li><p>不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</p></li><li><p>环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。</p></li></ol><p>理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和解除死锁。只要打破四个必要条件之一就能有效预防死锁的发生。</p><ul><li>打破互斥条件：改造独占性资源为虚拟资源，大部分资源已无法改造。</li><li>打破不可抢占条件：当一进程占有一独占性资源后又申请一独占性资源而无法满足，则退出原占有的资源。</li><li>打破占有且申请条件：采用资源预先分配策略，即进程运行前申请全部资源，满足则运行，不然就等待，这样就不会占有且申请。</li><li>打破循环等待条件：实现资源有序分配策略，对所有设备实现分类编号，所有进程只能采用按序号递增的形式申请资源。</li></ul><p>避免死锁常见的算法有有序资源分配法、银行家算法。</p><h4 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h4><p>数据库里多事务而且要同时操作多个表的情况下就可能产生死锁。所以数据库设计的时候就考虑到了检测死锁和从死锁中恢复的机制。比如oracle提供了检测和处理死锁的语句，而mysql也提供了“循环依赖检测的机制”</p><img src="/blog/2020/01/23/JUC-%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8/pic6.png" srcset="/blog/img/loading.gif" class><h5 id="简单顺序死锁"><a href="#简单顺序死锁" class="headerlink" title="简单顺序死锁"></a>简单顺序死锁</h5><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><span class="hljs-comment"> *类说明：演示普通账户的死锁和解决</span><span class="hljs-comment"> */</span>public <span class="hljs-keyword">class</span> NormalDeadLock &#123;    <span class="hljs-keyword">private</span> static Object valueFirst = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Object()</span>;<span class="hljs-comment">//第一个锁</span>    <span class="hljs-keyword">private</span> static Object valueSecond = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Object()</span>;<span class="hljs-comment">//第二个锁</span>    <span class="hljs-comment">//先拿第一个锁，再拿第二个锁</span>    <span class="hljs-keyword">private</span> static void fisrt<span class="hljs-constructor">ToSecond()</span> throws InterruptedException &#123;        String threadName = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>;        synchronized (valueFirst)&#123;            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(threadName+<span class="hljs-string">" get 1st"</span>);            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>sleep(<span class="hljs-number">100</span>);            synchronized (valueSecond)&#123;                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(threadName+<span class="hljs-string">" get 2nd"</span>);            &#125;        &#125;    &#125;    <span class="hljs-comment">//先拿第二个锁，再拿第一个锁</span>    <span class="hljs-keyword">private</span> static void <span class="hljs-constructor">SecondToFisrt()</span> throws InterruptedException &#123;        String threadName = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>;        synchronized (valueFirst)&#123;            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(threadName+<span class="hljs-string">" get 2nd"</span>);            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>sleep(<span class="hljs-number">100</span>);            synchronized (valueSecond)&#123;                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(threadName+<span class="hljs-string">" get 1st"</span>);            &#125;        &#125;    &#125;    <span class="hljs-keyword">private</span> static <span class="hljs-keyword">class</span> TestThread extends Thread&#123;        <span class="hljs-keyword">private</span> String name;        public <span class="hljs-constructor">TestThread(String <span class="hljs-params">name</span>)</span> &#123;            this.name = name;        &#125;        public void run<span class="hljs-literal">()</span>&#123;            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.set<span class="hljs-constructor">Name(<span class="hljs-params">name</span>)</span>;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-constructor">SecondToFisrt()</span>;            &#125; catch (InterruptedException e) &#123;                e.print<span class="hljs-constructor">StackTrace()</span>;            &#125;        &#125;    &#125;    public static void main(String<span class="hljs-literal">[]</span> args) &#123;        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.set<span class="hljs-constructor">Name(<span class="hljs-string">"TestDeadLock"</span>)</span>;        TestThread testThread = <span class="hljs-keyword">new</span> <span class="hljs-constructor">TestThread(<span class="hljs-string">"SubTestThread"</span>)</span>;        testThread.start<span class="hljs-literal">()</span>;        <span class="hljs-keyword">try</span> &#123;            fisrt<span class="hljs-constructor">ToSecond()</span>;        &#125; catch (InterruptedException e) &#123;            e.print<span class="hljs-constructor">StackTrace()</span>;        &#125;    &#125;&#125;</code></pre><h5 id="动态顺序死锁"><a href="#动态顺序死锁" class="headerlink" title="动态顺序死锁"></a>动态顺序死锁</h5><p>顾名思义也是和获取锁的顺序有关，但是比较隐蔽，不像简单顺序死锁，往往从代码一眼就看出获取锁的顺序不对。</p><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><span class="hljs-comment"> *类说明：不安全的转账动作的实现</span><span class="hljs-comment"> */</span>public <span class="hljs-keyword">class</span> TrasnferAccount implements ITransfer &#123;    @Override    public void transfer(UserAccount from, UserAccount <span class="hljs-keyword">to</span>, <span class="hljs-built_in">int</span> amount)          throws InterruptedException &#123;        synchronized (from)&#123;            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>                  +<span class="hljs-string">" get"</span>+from.get<span class="hljs-constructor">Name()</span>);            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>sleep(<span class="hljs-number">100</span>);            synchronized (<span class="hljs-keyword">to</span>)&#123;                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>                      +<span class="hljs-string">" get"</span>+<span class="hljs-keyword">to</span>.get<span class="hljs-constructor">Name()</span>);                from.fly<span class="hljs-constructor">Money(<span class="hljs-params">amount</span>)</span>;                <span class="hljs-keyword">to</span>.add<span class="hljs-constructor">Money(<span class="hljs-params">amount</span>)</span>;            &#125;        &#125;    &#125;&#125;</code></pre><pre><code class="hljs arduino"><span class="hljs-comment">/**</span><span class="hljs-comment"> *@author Mark老师   享学课堂 https://enjoy.ke.qq.com </span><span class="hljs-comment"> *</span><span class="hljs-comment"> *类说明：模拟支付公司转账的动作</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PayCompany</span> &#123;</span>   <span class="hljs-comment">/*执行转账动作的线程*/</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TransferThread</span> <span class="hljs-title">extends</span> <span class="hljs-title">Thread</span>&#123;</span>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> name;        <span class="hljs-keyword">private</span> UserAccount from;        <span class="hljs-keyword">private</span> UserAccount to;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> amount;        <span class="hljs-keyword">private</span> ITransfer <span class="hljs-built_in">transfer</span>;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TransferThread</span><span class="hljs-params">(<span class="hljs-keyword">String</span> name, UserAccount from, UserAccount to,</span></span><span class="hljs-function"><span class="hljs-params">                              <span class="hljs-keyword">int</span> amount, ITransfer <span class="hljs-built_in">transfer</span>)</span> </span>&#123;            <span class="hljs-keyword">this</span>.name = name;            <span class="hljs-keyword">this</span>.from = from;            <span class="hljs-keyword">this</span>.to = to;            <span class="hljs-keyword">this</span>.amount = amount;            <span class="hljs-keyword">this</span>.<span class="hljs-built_in">transfer</span> = <span class="hljs-built_in">transfer</span>;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;            Thread.currentThread().setName(name);            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-built_in">transfer</span>.<span class="hljs-built_in">transfer</span>(from,to,amount);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;        PayCompany payCompany = <span class="hljs-keyword">new</span> PayCompany();        UserAccount zhangsan = <span class="hljs-keyword">new</span> UserAccount(<span class="hljs-string">"zhangsan"</span>,<span class="hljs-number">20000</span>);        UserAccount lisi = <span class="hljs-keyword">new</span> UserAccount(<span class="hljs-string">"lisi"</span>,<span class="hljs-number">20000</span>);        ITransfer <span class="hljs-built_in">transfer</span> = <span class="hljs-keyword">new</span> SafeOperateToo();        TransferThread zhangsanToLisi = <span class="hljs-keyword">new</span> TransferThread(<span class="hljs-string">"zhangsanToLisi"</span>                ,zhangsan,lisi,<span class="hljs-number">2000</span>,<span class="hljs-built_in">transfer</span>);        TransferThread lisiToZhangsan = <span class="hljs-keyword">new</span> TransferThread(<span class="hljs-string">"lisiToZhangsan"</span>                ,lisi,zhangsan,<span class="hljs-number">4000</span>,<span class="hljs-built_in">transfer</span>);        zhangsanToLisi.start();        lisiToZhangsan.start();    &#125;&#125;</code></pre><h4 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h4><p>时间不定，不是每次必现；一旦出现没有任何异常信息，只知道这个应用的所有业务越来越慢，最后停止服务，无法确定是哪个具体业务导致的问题；测试部门也无法复现，并发量不够。</p><ol><li>线程不工作了，但是整个程序还是活着的</li><li>没有任何的异常信息可以供我们检查。</li><li>一旦程序发生了发生了死锁，是没有任何的办法恢复的，只能重启程序，对生产平台的程序来说，这是个很严重的问题。</li></ol><h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><h5 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h5><p>通过<strong>jps</strong> 查询应用的id，再通过<strong>jstack[id]</strong> 查看应用的锁的持有情况</p><img src="/blog/2020/01/23/JUC-%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8/pic1.png" srcset="/blog/img/loading.gif" class><img src="/blog/2020/01/23/JUC-%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8/pic2.png" srcset="/blog/img/loading.gif" class><img src="/blog/2020/01/23/JUC-%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8/pic3.png" srcset="/blog/img/loading.gif" class><h5 id="修正"><a href="#修正" class="headerlink" title="修正"></a>修正</h5><p>关键是保证拿锁的顺序一致</p><p>两种解决方式：</p><ol><li>内部通过顺序比较，确定拿锁的顺序；</li></ol><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><span class="hljs-comment"> *@author Mark老师   享学课堂 https://enjoy.ke.qq.com </span><span class="hljs-comment"> *</span><span class="hljs-comment"> *类说明：不会产生死锁的安全转账</span><span class="hljs-comment"> */</span>public <span class="hljs-keyword">class</span> SafeOperate implements ITransfer &#123;    <span class="hljs-keyword">private</span> static Object tieLock = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Object()</span>;<span class="hljs-comment">//第三把锁</span>    @Override    public void transfer(UserAccount from, UserAccount <span class="hljs-keyword">to</span>, <span class="hljs-built_in">int</span> amount)            throws InterruptedException &#123;        <span class="hljs-built_in">int</span> fromHash = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>identity<span class="hljs-constructor">HashCode(<span class="hljs-params">from</span>)</span>;        <span class="hljs-built_in">int</span> toHash = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>identity<span class="hljs-constructor">HashCode(<span class="hljs-params">to</span>)</span>;        <span class="hljs-keyword">if</span>(fromHash&lt;toHash)&#123;            synchronized (from)&#123;                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>+<span class="hljs-string">" get "</span>+from.get<span class="hljs-constructor">Name()</span>);                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>sleep(<span class="hljs-number">100</span>);                synchronized (<span class="hljs-keyword">to</span>)&#123;                    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>+<span class="hljs-string">" get "</span>+<span class="hljs-keyword">to</span>.get<span class="hljs-constructor">Name()</span>);                    from.fly<span class="hljs-constructor">Money(<span class="hljs-params">amount</span>)</span>;                    <span class="hljs-keyword">to</span>.add<span class="hljs-constructor">Money(<span class="hljs-params">amount</span>)</span>;                    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(from);                    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-keyword">to</span>);                &#125;            &#125;        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(toHash&lt;fromHash)&#123;            synchronized (<span class="hljs-keyword">to</span>)&#123;                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>+<span class="hljs-string">" get"</span>+<span class="hljs-keyword">to</span>.get<span class="hljs-constructor">Name()</span>);                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>sleep(<span class="hljs-number">100</span>);                synchronized (from)&#123;                    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>+<span class="hljs-string">" get"</span>+from.get<span class="hljs-constructor">Name()</span>);                    from.fly<span class="hljs-constructor">Money(<span class="hljs-params">amount</span>)</span>;                    <span class="hljs-keyword">to</span>.add<span class="hljs-constructor">Money(<span class="hljs-params">amount</span>)</span>;                    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(from);                    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-keyword">to</span>);                &#125;            &#125;        &#125;<span class="hljs-keyword">else</span>&#123;            synchronized (tieLock)&#123;                synchronized (from)&#123;                    synchronized (<span class="hljs-keyword">to</span>)&#123;                        from.fly<span class="hljs-constructor">Money(<span class="hljs-params">amount</span>)</span>;                        <span class="hljs-keyword">to</span>.add<span class="hljs-constructor">Money(<span class="hljs-params">amount</span>)</span>;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><ol start="2"><li>采用尝试拿锁的机制。</li></ol><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><span class="hljs-comment"> * @author Mark老师   享学课堂 https://enjoy.ke.qq.com</span><span class="hljs-comment"> * &lt;p&gt;</span><span class="hljs-comment"> * 类说明：不会产生死锁的安全转账第二种方法</span><span class="hljs-comment"> */</span>public <span class="hljs-keyword">class</span> SafeOperateToo implements ITransfer &#123;    @Override    public void transfer(UserAccount from, UserAccount <span class="hljs-keyword">to</span>, <span class="hljs-built_in">int</span> amount)            throws InterruptedException &#123;        Random r = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Random()</span>;        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;            <span class="hljs-keyword">if</span> (from.get<span class="hljs-constructor">Lock()</span>.<span class="hljs-keyword">try</span><span class="hljs-constructor">Lock()</span>) &#123;                <span class="hljs-keyword">try</span> &#123;                    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>                            + <span class="hljs-string">" get"</span> + from.get<span class="hljs-constructor">Name()</span>);                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">to</span>.get<span class="hljs-constructor">Lock()</span>.<span class="hljs-keyword">try</span><span class="hljs-constructor">Lock()</span>) &#123;                        <span class="hljs-keyword">try</span> &#123;                            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>                                    + <span class="hljs-string">" get"</span> + <span class="hljs-keyword">to</span>.get<span class="hljs-constructor">Name()</span>);                            from.fly<span class="hljs-constructor">Money(<span class="hljs-params">amount</span>)</span>;                            <span class="hljs-keyword">to</span>.add<span class="hljs-constructor">Money(<span class="hljs-params">amount</span>)</span>;                            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(from);                            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-keyword">to</span>);                            break;                        &#125; finally &#123;                            <span class="hljs-keyword">to</span>.get<span class="hljs-constructor">Lock()</span>.unlock<span class="hljs-literal">()</span>;                        &#125;                    &#125;                &#125; finally &#123;                    from.get<span class="hljs-constructor">Lock()</span>.unlock<span class="hljs-literal">()</span>;                &#125;            &#125;            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>sleep(r.next<span class="hljs-constructor">Int(2)</span>);        &#125;    &#125;&#125;</code></pre><h3 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h3><p>两个线程在尝试拿锁的机制中，发生多个线程之间互相谦让，不断发生同一个线程总是拿到同一把锁，在尝试拿另一把锁时因为拿不到，而将本来已经持有的锁释放的过程。</p><p>解决办法：每个线程休眠随机数，错开拿锁的时间。</p><h3 id="线程饥饿"><a href="#线程饥饿" class="headerlink" title="线程饥饿"></a>线程饥饿</h3><p>低优先级的线程，总是拿不到执行时间</p><h3 id="性能和思考"><a href="#性能和思考" class="headerlink" title="性能和思考"></a>性能和思考</h3><p>使用并发的目标是为了提高性能，引入多线程后，其实会引入额外的开销，如线程之间的协调、增加的上下文切换，线程的创建和销毁，线程的调度等等。过度的使用和不恰当的使用，会导致多线程程序甚至比单线程还要低。</p><p>衡量应用的程序的性能：服务时间，延迟时间，吞吐量，可伸缩性等等，其中服务时间，延迟时间（多快），吞吐量（处理能力的指标，完成工作的多少）。多快和多少，完全独立，甚至是相互矛盾的。</p><p>对服务器应用来说：多少（可伸缩性，吞吐量）这个方面比多快更受重视。</p><p>我们做应用的时候：</p><ol><li><p>先保证程序正确，确实达不到要求的时候，再提高速度（黄金原则）。</p></li><li><p>一定要以测试为基准。</p></li></ol><h4 id="线程引入的开销"><a href="#线程引入的开销" class="headerlink" title="线程引入的开销"></a>线程引入的开销</h4><h5 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h5><p>如果主线程是唯一的线程，那么它基本上不会被调度出去。另一方面,如果可运行的线程数大于CPU的数量,那么操作系统最终会将某个正在运行的线程调度出来，从而使其他线程能够使用CPU。这将导致一次上下文切换，在这个过程中将保存当前运行线程的执行上下文，并将新调度进来的线程的执行上下文设置为当前上下文。上下文切换有点像我们同时阅读几本书，在来回切换书本的同时我们需要记住每本书当前读到的页码。</p><p>切换上下文需要一定的开销，而在线程调度过程中需要访问由操作系统和JVM共享的数据结构。由于应用程序、操作系统以及JVM都使用同一组CPU，所以在JVM和操作系统中消耗越多的CPU时钟周期，应用程序的可用CPU时钟周期就越少。而且上下文切换的开销并不只是包含JVM和操作系统的开销，由于当一个新的线程被切换进来时，它所需要的数据可能不在当前处理器的本地缓存，所以上下文切换也将导致一些缓存缺失，线程在首次调度运行时会更加缓慢。</p><p>当线程由于等待某个发生竞争的锁而被阻塞时，JVM通常会将这个线程挂起，并允许它被交换出去。如果线程频繁地发生阻塞，那么它们将无法使用完整的调度时间片。在程序中发生越多的阻塞（包括阻塞IO、等待获取发生竞争的锁或者在条件变量上等待）与CPU密集型的程序就会发生越多的上下文切换，从而增加调度开销，降低吞吐量。</p><p>上下文切换是计算密集型操作。也就是说，它需要相当可观的处理器时间。所以上下文切换对系统来说意味着消耗大量的 CPU 时间，而且可能是操作系统中时间消耗最大的操作。上下文切换的实际开销会随着平台的不同而变化，按照实际经验来看，在大多数通用的处理器中，上下文切换的开销相当于50~10000个时钟周期,也就是几微秒。</p><p>UNIX系统的vmstat命令能报告上下文切换次数以及在内核中执行时间所占比例等信息。如果内核占用率较高（超过10%），那么通常表示调度活动发生得很频繁，这很可能是由IO或竞争锁导致的阻塞引起的。</p><h5 id="内存同步"><a href="#内存同步" class="headerlink" title="内存同步"></a>内存同步</h5><p>同步操作的性能开销包括多个方面。在 synchronized和 volatile提供的可见性保证中可能会使用一些特殊指令，即内存栅栏( Memory Barrier)。</p><p>内存栅栏可以刷新缓存，使缓存无效从而刷新硬件的写缓冲，以及停止执行管道。</p><p>内存栅栏可能同样会对性能带来间接的影响，因为它们将抑制一些编译器优化操作。在内存栅栏中，大多数操作都是不能被重排序的。</p><h5 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h5><p>引起阻塞的原因：包括阻塞IO，等待获取发生竞争的锁或者在条件变量上的等待等等。</p><p>阻塞会导致线程挂起，挂起进程在操作系统中可以定义为暂时被淘汰出内存的进程，机器的资源是有限的，在资源不足的情况下，操作系统对在内存中的程序进行合理的安排，其中有的进程被暂时调离出内存，当条件允许的时候，会被操作系统再次调回内存，重新进入等待被执行的状态即就绪态。这个操作至少包括两次额外的上下文切换，还有相关的操作系统级的操作等等。</p><h4 id="如何减少锁的竞争"><a href="#如何减少锁的竞争" class="headerlink" title="如何减少锁的竞争"></a>如何减少锁的竞争</h4><h5 id="减少锁的粒度"><a href="#减少锁的粒度" class="headerlink" title="减少锁的粒度"></a>减少锁的粒度</h5><p>使用锁的时候，锁所保护的对象是多个，当这些多个对象其实是独立变化的时候，不如用多个锁来一一保护这些对象。但是如果有同时要持有多个锁的业务方法，要注意避免发生死锁。</p><h5 id="缩小锁的范围"><a href="#缩小锁的范围" class="headerlink" title="缩小锁的范围"></a>缩小锁的范围</h5><p>对锁的持有实现快进快出，尽量缩短持由锁的的时间。将一些与锁无关的代码移出锁的范围，特别是一些耗时，可能阻塞的操作</p><h5 id="避免多余的锁"><a href="#避免多余的锁" class="headerlink" title="避免多余的锁"></a>避免多余的锁</h5><p>两次加锁之间的语句非常简单，导致加锁的时间比执行这些语句还长，这个时候应该进行锁粗化即扩大锁的范围。</p><h5 id="锁分段"><a href="#锁分段" class="headerlink" title="锁分段"></a>锁分段</h5><p>ConcurrrentHashMap就是典型的锁分段。</p><h5 id="替换独占锁"><a href="#替换独占锁" class="headerlink" title="替换独占锁"></a>替换独占锁</h5><p>在业务允许的情况下：</p><ol><li>使用读写锁，</li><li>用自旋CAS</li><li>使用系统的并发容器</li></ol><h2 id="线程安全的单例模式"><a href="#线程安全的单例模式" class="headerlink" title="线程安全的单例模式"></a>线程安全的单例模式</h2><h3 id="双重检查锁定"><a href="#双重检查锁定" class="headerlink" title="双重检查锁定"></a>双重检查锁定</h3><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 懒汉式-双重检查</span><span class="hljs-comment"> */</span>public <span class="hljs-keyword">class</span> SingleDcl &#123;    <span class="hljs-keyword">private</span> volatile static SingleDcl singleDcl;    <span class="hljs-comment">//私有化</span>    <span class="hljs-keyword">private</span> <span class="hljs-constructor">SingleDcl()</span>&#123;    &#125;    public static SingleDcl get<span class="hljs-constructor">Instance()</span>&#123;        <span class="hljs-keyword">if</span> (singleDcl<span class="hljs-operator"> == </span>null)&#123; <span class="hljs-comment">//第一次检查，不加锁</span>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>+<span class="hljs-string">" is null"</span>);            synchronized(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SingleDcl</span>.</span></span><span class="hljs-keyword">class</span>)&#123; <span class="hljs-comment">//加锁</span>                <span class="hljs-keyword">if</span> (singleDcl<span class="hljs-operator"> == </span>null)&#123; <span class="hljs-comment">//第二次检查，加锁情况下</span>                    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>+<span class="hljs-string">" is null"</span>);                    singleDcl = <span class="hljs-keyword">new</span> <span class="hljs-constructor">SingleDcl()</span>;                &#125;            &#125;        &#125;        return singleDcl;    &#125;&#125;</code></pre><p>仅仅是双重检查无法保证多线程下使用的安全性，因为在创建对象时为内存中分配空间、对象在内存空间的初始化、把这个内存空间的地址赋值给引用这三个步骤是可能被重新排序的，只要引用指向了内存空间的地址判断条件singleDc1==null就会不成立，而此时对象很可能还没有完成初始化，所以还需要加入volatile关键字保证指令不会被重排序。</p><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 饿汉式</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingleEHan</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingleEHan</span><span class="hljs-params">()</span></span>&#123;&#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SingleEHan singleDcl = <span class="hljs-keyword">new</span> SingleEHan();&#125;</code></pre><p>JVM对类的加载和类初始化，由虚拟机保证线程安全。多个线程同时加载一个类时会为其加锁保证只有一个类加载成功，所以饿汉式单例模式是线程安全的。</p><h3 id="延迟初始化占位类模式"><a href="#延迟初始化占位类模式" class="headerlink" title="延迟初始化占位类模式"></a>延迟初始化占位类模式</h3><pre><code class="hljs smali">/** * 懒汉式-延迟初始化占位类模式 */public class SingleInit &#123;   <span class="hljs-keyword"> private</span> SingleInit()&#123;&#125;   <span class="hljs-keyword"> private</span><span class="hljs-keyword"> static</span> class InstanceHolder&#123;       <span class="hljs-keyword"> private</span><span class="hljs-keyword"> static</span> SingleInit<span class="hljs-built_in"> instance </span>=<span class="hljs-built_in"> new </span>SingleInit();    &#125;   <span class="hljs-keyword"> public</span><span class="hljs-keyword"> static</span> SingleInit getInstance()&#123;       <span class="hljs-built_in"> return </span>InstanceHolder.instance;    &#125;&#125;</code></pre><p>延迟初始化占位类模式其实也是利用JVM类加载的线程安全，在子类中完成实例的初始化，如果在其他地方没有对子类的引用，子类的初始化将只在首次获取实例时完成，以此来解决饿汉式单例模式资源占用的问题。延迟占位模式也可以用在多线程下实例域的延迟赋值。</p>]]></content>
    
    
    <categories>
      
      <category>并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并发安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Tomcat性能优化</title>
    <link href="/blog/2020/01/10/tomcat%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <url>/blog/2020/01/10/tomcat%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="Tomcat内存优化"><a href="#Tomcat内存优化" class="headerlink" title="Tomcat内存优化"></a>Tomcat内存优化</h2><p>tomcat默认参数是为开发环境制定，而非适合生产环境，尤其是内存和线程的配置，默认都很低，容易成为性能瓶颈。</p><p>TOMCAT_HOME/bin/catalina.sh，在前面加入</p><pre><code class="hljs ini"><span class="hljs-attr">JAVA_OPTS</span>=<span class="hljs-string">"-XX:PermSize=64M -XX:MaxPermSize=128m -Xms512m -Xmx1024m -Duser.timezone=Asia/Shanghai"</span></code></pre><p>此设置将最大堆内存改为1024m，实际调整时还是按照服务器的具体配置优化。</p><ul><li>JVM初始化堆大小：Xms</li><li>JVM堆的最大值：Xmx</li><li>JVM初始分配的非堆内存：PermSize</li><li>JVM最大允许分配的非堆内存：MaxPermSize</li></ul><h2 id="Tomcat线程优化"><a href="#Tomcat线程优化" class="headerlink" title="Tomcat线程优化"></a>Tomcat线程优化</h2><p>在TOMCAT_HOME/conf/server.xml中设置</p><pre><code class="hljs routeros">&lt;Connector <span class="hljs-attribute">port</span>=<span class="hljs-string">"8080"</span> <span class="hljs-attribute">protocol</span>=<span class="hljs-string">"HTTP/1.1"</span> <span class="hljs-attribute">maxThreads</span>=<span class="hljs-string">"600"</span> <span class="hljs-attribute">minSpareThreads</span>=<span class="hljs-string">"100"</span> <span class="hljs-attribute">maxSpareThreads</span>=<span class="hljs-string">"500"</span> <span class="hljs-attribute">acceptCount</span>=<span class="hljs-string">"700"</span><span class="hljs-attribute">connectionTimeout</span>=<span class="hljs-string">"20000"</span> <span class="hljs-attribute">redirectPort</span>=<span class="hljs-string">"8443"</span> /&gt;</code></pre><ul><li>maxThreads：最大线程数</li><li>minSpareThreads：最小空闲线程数（tomcat初始化时创建的线程数）</li><li>maxSpareThreads：最大空闲线程数（超过这个值之后，tomcat会关闭多余的socket线程）</li><li>acceptCount：等待队列长度。超过这个数的请求将不予处理，http请求将返回502状态码</li></ul><p>如果使用apache和tomcat做集群的负载均衡，并且使用ajp协议做apache和tomcat的协议转发，那么还需要优化ajp connector。</p><pre><code class="hljs routeros">&lt;Connector <span class="hljs-attribute">port</span>=<span class="hljs-string">"8009"</span> <span class="hljs-attribute">protocol</span>=<span class="hljs-string">"AJP/1.3"</span> <span class="hljs-attribute">maxThreads</span>=<span class="hljs-string">"600"</span> <span class="hljs-attribute">minSpareThreads</span>=<span class="hljs-string">"100"</span> <span class="hljs-attribute">maxSpareThreads</span>=<span class="hljs-string">"500"</span> <span class="hljs-attribute">acceptCount</span>=<span class="hljs-string">"700"</span><span class="hljs-attribute">connectionTimeout</span>=<span class="hljs-string">"20000"</span> <span class="hljs-attribute">redirectPort</span>=<span class="hljs-string">"8443"</span> /&gt;</code></pre><p>由于tomcat有多个connector，所以tomcat线程的配置可以支持多个connector共享一个线程池。</p><pre><code class="hljs routeros">&lt;Executor <span class="hljs-attribute">name</span>=<span class="hljs-string">"tomcatThreadPool"</span> <span class="hljs-attribute">namePrefix</span>=<span class="hljs-string">"catalina-exec-"</span> <span class="hljs-attribute">maxThreads</span>=<span class="hljs-string">"500"</span> <span class="hljs-attribute">minSpareThreads</span>=<span class="hljs-string">"20"</span> <span class="hljs-attribute">maxIdleTime</span>=<span class="hljs-string">"60000"</span> /&gt;</code></pre><p>修改Connector节点，增加executor属性设置为线程池的名字</p><pre><code class="hljs routeros">&lt;Connector <span class="hljs-attribute">executor</span>=<span class="hljs-string">"tomcatThreadPool"</span> <span class="hljs-attribute">port</span>=<span class="hljs-string">"80"</span> <span class="hljs-attribute">protocol</span>=<span class="hljs-string">"HTTP/1.1"</span>  <span class="hljs-attribute">connectionTimeout</span>=<span class="hljs-string">"60000"</span> <span class="hljs-attribute">keepAliveTimeout</span>=<span class="hljs-string">"15000"</span> <span class="hljs-attribute">maxKeepAliveRequests</span>=<span class="hljs-string">"1"</span>  <span class="hljs-attribute">redirectPort</span>=<span class="hljs-string">"443"</span> /&gt;</code></pre><p>可以多个connector公用1个线程池，所以ajp connector也同样可以设置使用tomcatThreadPool线程池。</p><h2 id="Tomcat的连接器优化"><a href="#Tomcat的连接器优化" class="headerlink" title="Tomcat的连接器优化"></a>Tomcat的连接器优化</h2><p>Tomcat Connector(Tomcat连接器)有bio、nio、apr三种运行模式</p><h3 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h3><p>bio（blocking I/O，阻塞式I/O操作），表示Tomcat使用的是传统的Java I/O操作(即java.io包及其子包)。<br><strong>默认的模式，性能最差，没有经过任何优化处理和支持。</strong></p><h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><p>nio(non-blocking I/O，非阻塞式I/O操作)，也被看成是<code>non-blocking I/O</code>的缩写，是Java SE 1.4及后续版本提供的一种新的I/O操作方式(即java.nio包及其子包)。Java nio是一个基于缓冲区、并能提供非阻塞I/O操作的Java API。拥有比传统I/O操作(bio)更好的并发运行性能。 tomcat在8.0之后已经将nio作为默认运行模式，在8.0之前要让tomcat以nio方式来运行也比较简单，只需要修改tomcat目录下的/conf/servcer.xml中的protocol设置为<code>org.apache.coyote.http11.Http11NioProtocol</code>即可</p><pre><code class="hljs routeros">&lt;Connector <span class="hljs-attribute">port</span>=<span class="hljs-string">"8080"</span> <span class="hljs-attribute">protocol</span>=<span class="hljs-string">"org.apache.coyote.http11.Http11NioProtocol"</span><span class="hljs-attribute">connectionTimeout</span>=<span class="hljs-string">"20000"</span><span class="hljs-attribute">redirectPort</span>=<span class="hljs-string">"8443"</span> /&gt;</code></pre><p>点击tomcat管理页面的server status之后就可以看到当前的运行模式</p><img src="/blog/2020/01/10/tomcat%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/pic1.png" srcset="/blog/img/loading.gif" class><h3 id="APR"><a href="#APR" class="headerlink" title="APR"></a>APR</h3><p>apr(Apache Portable Runtime/Apache可移植运行时库)，Tomcat将以JNI(Java Native Interface)的形式调用Apache HTTP服务器的核心动态链接库来处理文件读取或网络传输操作，从而大大地提高Tomcat对静态文件的处理性能。使用操作系统的部分本地操作，解决异步的IO问题，大幅度的提高性能。 Tomcat apr也是在Tomcat上运行高并发应用的首选模式。</p><p>Tomcat apr运行模式的配置是三种运行模式之中相对比较麻烦的一种。据官方文档所述，Tomcat apr需要以下三个组件的支持：</p><ul><li>APR library[APR库]</li><li>JNI wrappers for APR used by Tomcat (libtcnative)[简单地说，如果是在Windows操作系统上，就是一个名为tcnative-1.dll的动态链接库文件]</li><li>OpenSSL libraries[OpenSSL库]</li></ul><h3 id="centos7下tomcat8开启APR步骤"><a href="#centos7下tomcat8开启APR步骤" class="headerlink" title="centos7下tomcat8开启APR步骤"></a>centos7下tomcat8开启APR步骤</h3><ol><li>下载APR组件依赖</li></ol><img src="/blog/2020/01/10/tomcat%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/pic2.png" srcset="/blog/img/loading.gif" class><ol start="2"><li>安装apr</li></ol><pre><code class="hljs angelscript">tar zxvf apr<span class="hljs-number">-1.6</span><span class="hljs-number">.5</span>.tar.gzcd apr<span class="hljs-number">-1.6</span><span class="hljs-number">.5</span>./configure --prefix=/usr/local/aprmake &amp;&amp; make install</code></pre><ol start="3"><li>安装apr-iconv</li></ol><pre><code class="hljs vim">tar zxvf apr-<span class="hljs-built_in">iconv</span>.<span class="hljs-number">1.2</span>.<span class="hljs-number">2</span>.tar.gz<span class="hljs-keyword">cd</span> apr-<span class="hljs-built_in">iconv</span>-<span class="hljs-number">1.2</span>.<span class="hljs-number">2</span>./configure --prefix=/usr/local/apr-<span class="hljs-built_in">iconv</span> --with-apr=/usr/local/apr<span class="hljs-keyword">make</span> &amp;&amp; <span class="hljs-keyword">make</span> install</code></pre><ol start="4"><li>安装apr-util</li></ol><pre><code class="hljs awk">tar zxvf apr-util.<span class="hljs-number">1.6</span>.<span class="hljs-number">1</span>.tar.gzcd apr-util-<span class="hljs-number">1.6</span>.<span class="hljs-number">1</span>.<span class="hljs-regexp">/configure --prefix=/u</span>sr<span class="hljs-regexp">/local/</span>apr-util --with-apr=<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/apr --with-apr-iconv=/u</span>sr<span class="hljs-regexp">/local/</span>apr-iconv<span class="hljs-regexp">/bin/</span>apriconvmake &amp;&amp; make install</code></pre><ol start="5"><li>安装tomcat的bin目录下的tomcat-native-1.2.21-src.tar.gz</li></ol><pre><code class="hljs angelscript">tar zxf tomcat-native<span class="hljs-number">-1.2</span><span class="hljs-number">.21</span>-src.tar.gzcd tomcat-native<span class="hljs-number">-1.2</span><span class="hljs-number">.21</span>cd native./configure --with-apr=/usr/local/apr --with-java-home=/usr/java/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0</span>_65make &amp;&amp; make install</code></pre><ol start="6"><li>在tomcat的bin目录下的catalina.sh的最后一行添加变量</li></ol><pre><code class="hljs routeros"><span class="hljs-attribute">JAVA_OPTS</span>=”$JAVA_OPTS -Djava.library.<span class="hljs-attribute">path</span>=/usr/local/apr/lib”</code></pre><ol start="7"><li>重启tomcat启动日志中出现以下内容证明APR模式启动</li></ol><pre><code class="hljs css">10<span class="hljs-selector-tag">-Jan-2020</span> 17<span class="hljs-selector-pseudo">:23</span><span class="hljs-selector-pseudo">:29.744</span> 信息 <span class="hljs-selector-attr">[main]</span> <span class="hljs-selector-tag">org</span><span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.coyote</span><span class="hljs-selector-class">.AbstractProtocol</span><span class="hljs-selector-class">.init</span> <span class="hljs-selector-tag">Initializing</span> <span class="hljs-selector-tag">ProtocolHandler</span> <span class="hljs-selector-attr">[<span class="hljs-string">"http-apr-9080"</span>]</span></code></pre><p>同理，通过tomcat的启动日志也可以判断出其运行状态</p><ul><li>bio</li></ul><pre><code class="hljs css"><span class="hljs-selector-tag">INFO</span>: <span class="hljs-selector-tag">Initializing</span> <span class="hljs-selector-tag">ProtocolHandler</span> <span class="hljs-selector-attr">[<span class="hljs-string">"http-bio-8080"</span>]</span><span class="hljs-selector-tag">Aug</span> 04, 2015 10<span class="hljs-selector-pseudo">:20</span><span class="hljs-selector-pseudo">:35</span> <span class="hljs-selector-tag">PM</span> <span class="hljs-selector-tag">org</span><span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.coyote</span><span class="hljs-selector-class">.AbstractProtocol</span> <span class="hljs-selector-tag">init</span></code></pre><ul><li>nio</li></ul><pre><code class="hljs css"><span class="hljs-selector-tag">INFO</span>: <span class="hljs-selector-tag">Initializing</span> <span class="hljs-selector-tag">ProtocolHandler</span> <span class="hljs-selector-attr">[<span class="hljs-string">"http-nio-8080"</span>]</span><span class="hljs-selector-tag">Aug</span> 04, 2015 10<span class="hljs-selector-pseudo">:27</span><span class="hljs-selector-pseudo">:58</span> <span class="hljs-selector-tag">PM</span> <span class="hljs-selector-tag">org</span><span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.coyote</span><span class="hljs-selector-class">.AbstractProtocol</span> <span class="hljs-selector-tag">init</span></code></pre><ul><li>apr</li></ul><pre><code class="hljs css"><span class="hljs-selector-tag">INFO</span>: <span class="hljs-selector-tag">Initializing</span> <span class="hljs-selector-tag">ProtocolHandler</span> <span class="hljs-selector-attr">[<span class="hljs-string">"http-apr-8080"</span>]</span><span class="hljs-selector-tag">Aug</span> 04, 2015 10<span class="hljs-selector-pseudo">:33</span><span class="hljs-selector-pseudo">:45</span> <span class="hljs-selector-tag">PM</span> <span class="hljs-selector-tag">org</span><span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.coyote</span><span class="hljs-selector-class">.AbstractProtocol</span> <span class="hljs-selector-tag">init</span></code></pre><h2 id="禁用DNS查询"><a href="#禁用DNS查询" class="headerlink" title="禁用DNS查询"></a>禁用DNS查询</h2><p>当web应用程序向要记录客户端的信息时，它也会记录客户端的IP地址或者通过域名服务器查找机器名 转换为IP地址。</p><p>DNS查询需要占用网络，并且包括可能从很多很远的服务器或者不起作用的服务器上去获取对应的IP的过程，这样会消耗一定的时间。</p><p>修改server.xml文件中的Connector元素，修改属性enableLookups参数值: enableLookups=”false”</p><p>如果为true，则可以通过调用request.getRemoteHost()进行DNS查询来得到远程客户端的实际主机名，若为false则不进行DNS查询，而是返回其ip地址</p><h2 id="设置session过期时间"><a href="#设置session过期时间" class="headerlink" title="设置session过期时间"></a>设置session过期时间</h2><p>在tomcat目录下的conf\web.xml中通过参数指定，单位为分钟。</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">session-config</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">session-timeout</span>&gt;</span>180<span class="hljs-tag">&lt;/<span class="hljs-name">session-timeout</span>&gt;</span>     <span class="hljs-tag">&lt;/<span class="hljs-name">session-config</span>&gt;</span></code></pre><h2 id="Maven项目远程部署到Tomcat"><a href="#Maven项目远程部署到Tomcat" class="headerlink" title="Maven项目远程部署到Tomcat"></a>Maven项目远程部署到Tomcat</h2><p>其实本节内容并不属于tomcat性能调优，但内容较少不足以再开一篇文章，凑合凑合塞到这吧。</p><ol><li>在tomcat根目录下的/conf/tomcat-users.xml添加用户</li></ol><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">tomcat-users</span> <span class="hljs-attr">version</span>=<span class="hljs-string">"1.0"</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://tomcat.apache.org/xml"</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://tomcat.apache.org/xml tomcat-users.xsd"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">role</span> <span class="hljs-attr">rolename</span>=<span class="hljs-string">"manager-gui"</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">role</span> <span class="hljs-attr">rolename</span>=<span class="hljs-string">"manager-script"</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">role</span> <span class="hljs-attr">rolename</span>=<span class="hljs-string">"admin-gui"</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">role</span> <span class="hljs-attr">rolename</span>=<span class="hljs-string">"admin-script"</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">user</span> <span class="hljs-attr">username</span>=<span class="hljs-string">"admin"</span> <span class="hljs-attr">password</span>=<span class="hljs-string">"tomcat"</span> <span class="hljs-attr">roles</span>=<span class="hljs-string">"manager-gui,manager-script,admin-gui,admin-script"</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tomcat-users</span>&gt;</span></code></pre><ol start="2"><li>pom文件中加入maven插件</li></ol><pre><code class="hljs dust"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">charset</span>&gt;</span>utf-8<span class="hljs-tag">&lt;/<span class="hljs-name">charset</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">update</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://</span><span class="hljs-template-variable">&#123;yourIP&#125;</span><span class="xml">:8080/manager/text<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">mode</span>&gt;</span>war<span class="hljs-tag">&lt;/<span class="hljs-name">mode</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">username</span>&gt;</span>username<span class="hljs-tag">&lt;/<span class="hljs-name">username</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span>password<span class="hljs-tag">&lt;/<span class="hljs-name">password</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">path</span>&gt;</span>/$</span><span class="hljs-template-variable">&#123;project.artifactId&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></span></code></pre><p>tomcat7-maven-plugin是很久以前的插件版本，默认支持到Tomcat7，但是对于目前最新的Tomcat9同样可以使用该插件</p><p>官方介绍文档为：<code>http://tomcat.apache.org/maven-plugin-2.1/index.html</code></p><p>参数说明：</p><p>以下参数必选，但是可以在pom中空缺，空缺时将采用默认值</p><table><thead><tr><th>名称</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td>charset</td><td>在与Tomcat Manager通信是的URL编 码字符集</td><td>ISO-8859-1</td></tr><tr><td>mode</td><td>部署的模式，值可为：war,context,both</td><td>war</td></tr><tr><td>path</td><td>应用程序运行的上下文路径，必须以’/‘开始</td><td>/${project.artifactId}</td></tr><tr><td>update</td><td>当部署已存在的应用时，是否自动 undeploy该应用</td><td>false</td></tr><tr><td>url</td><td>Tomcat Manager实例使用的全路径</td><td>tomcat的根路径/manager/text</td></tr><tr><td>warFile</td><td>部署warFile的路径</td><td>${project.build.directory} ${project.build.finalName}.war</td></tr></tbody></table><p>对于个性化的需求，tomcat7插件提供了可配置的参数</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>contextFile</td><td>Tomcat的context的XML路径，对于mode=war不适用，默认为 ${project.build.directory}/${project.build.finalName}/ META-INF/context.xml</td></tr><tr><td>ignorePackaging</td><td>如果设置为true，忽略类型不是war的项目</td></tr><tr><td>username</td><td>部署到Tomcat的username</td></tr><tr><td>password</td><td>部署到Tomcat的password</td></tr><tr><td>server</td><td>指定Maven的setting.xml中配置的server id用于Tomcat认证</td></tr><tr><td>tag</td><td>应用程序在Tomcat中使用的标签的名字</td></tr></tbody></table><p>还可以在maven目录中的conf/setting.xml中添加tomcat的用户名和密码</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servers</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">server</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>tomcatServer<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">username</span>&gt;</span>username<span class="hljs-tag">&lt;/<span class="hljs-name">username</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span>password<span class="hljs-tag">&lt;/<span class="hljs-name">password</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">server</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servers</span>&gt;</span></code></pre><p>之后在pom文件中指定server的id即可，不在需要用户名密码</p><pre><code class="hljs dust"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://</span><span class="hljs-template-variable">&#123;yourIP&#125;</span><span class="xml">:8080/manager/text<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">server</span>&gt;</span>tomcatServer<span class="hljs-tag">&lt;/<span class="hljs-name">server</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">update</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">path</span>&gt;</span>/$</span><span class="hljs-template-variable">&#123;project.artifactId&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>        </span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></span></code></pre><ol start="3"><li>idea部署项目</li></ol><p>idea可以直接在右侧边栏中的plugins中找到tomcat7，第一次部署时选择deploy之后选择redeploy就可以了</p><p>mvn命令</p><pre><code class="hljs armasm"><span class="hljs-keyword">mvn </span>tomcat7:deploy<span class="hljs-keyword">mvn </span>tomcat7:redeploy<span class="hljs-keyword">mvn </span>tomcat7:undeploy</code></pre>]]></content>
    
    
    <categories>
      
      <category>性能优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>性能优化</tag>
      
      <tag>tomcat</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原子操作CAS(Compare And Swap)</title>
    <link href="/blog/2019/12/24/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9CCAS/"/>
    <url>/blog/2019/12/24/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9CCAS/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是原子操作，如何实现？"><a href="#什么是原子操作，如何实现？" class="headerlink" title="什么是原子操作，如何实现？"></a>什么是原子操作，如何实现？</h2><p>谓原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束。</p><p>实现原子操作可以使用锁机制即synchronized关键字来实现，但synchronized关键字是基于阻塞的锁机制，也就是说当一个线程拥有锁的时候，访问同一资源的其它线程需要等待该线程执行完毕释放锁。这种机制不是很灵活，如果被阻塞的线程优先级比较高、获得锁的线程一直不释放锁，导致大量的线程来竞争资源，这时就需要会花费更多的资源来处理这些竞争，还可能出现一些例如死锁之类的情况，这些都会严重影响程序的性能。其实锁机制是一种比较粗糙，粒度比较大的机制，相对于简单的需求就过于笨重。</p><p>CAS是利用CPU的多处理能力，实现硬件层面的阻塞，再加上volatile变量的特性即可实现基于原子操作的线程安全。当前的处理器基本都支持CAS指令，只不过每个厂家所实现的算法并不一样。每一个CAS操作过程都包含三个运算符：一个内存地址V，一个期望的值A和一个新值B，操作的时候如果这个地址上存放的值等于这个期望的值A，则将地址上的值赋为新值B，否则将循环这个指令直到成功为止。</p><img src="/blog/2019/12/24/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9CCAS/pic1.png" srcset="/blog/img/loading.gif" class><h2 id="CAS实现原子操作的三大问题"><a href="#CAS实现原子操作的三大问题" class="headerlink" title="CAS实现原子操作的三大问题"></a>CAS实现原子操作的三大问题</h2><h3 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h3><p>CAS在更新值的时候，需要检查值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。</p><p>ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加1，那么A→B→A就会变成1A→2B→3A。</p><h3 id="循环时间长开销大"><a href="#循环时间长开销大" class="headerlink" title="循环时间长开销大"></a>循环时间长开销大</h3><p>多个线程争夺同一个资源时，如果自旋一直不成功，将会一直占用CPU。</p><p>解决方法：破坏掉死循环，当超过一定时间或者一定次数时退出。或者使用JDK8新增的LongAddr和ConcurrentHashMap类似的方法，当多个线程竞争时将粒度变小，将一个变量拆分为多个变量，达到多个线程访问多个资源的效果，最后再调用sum把它合起来。</p><h3 id="只能保证一个共享变量的原子操作"><a href="#只能保证一个共享变量的原子操作" class="headerlink" title="只能保证一个共享变量的原子操作"></a>只能保证一个共享变量的原子操作</h3><p>CAS指令同时刻只能保证对一个地址的操作是原子的，当同时刻对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法使用，这个时候就可以用锁。还有一个取巧的办法，就是把多个共享变量合并成一个共享变量或者封装为对象来操作。比如，有两个共享变量i＝2，j=a，合并一下ij=2a，然后用CAS来操作ij。从Java 1.5开始，JDK提供了AtomicReference类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行CAS操作。</p><h2 id="Jdk中相关原子操作类的使用"><a href="#Jdk中相关原子操作类的使用" class="headerlink" title="Jdk中相关原子操作类的使用"></a>Jdk中相关原子操作类的使用</h2><h3 id="jdk中提供的原子操作类"><a href="#jdk中提供的原子操作类" class="headerlink" title="jdk中提供的原子操作类"></a>jdk中提供的原子操作类</h3><ul><li>更新基本类型：AtomicBoolean,AtomicInteger,AtomicLong</li><li>更新数组类型：AtomicIntegerArray,AtomicLongArray,AtomicReferenceArray</li><li>更新基本引用类型：AtomicReference,AtomicMarkableReference,AtomicStampedReference</li><li>更新字段类型：AtomicReferenceFieldUpdater,AtomicIntegerFieldUpdater,AtomicLongFieldUpdater</li></ul><h3 id="更新基本类型"><a href="#更新基本类型" class="headerlink" title="更新基本类型"></a>更新基本类型</h3><p><strong>AtomicInteger</strong></p><ul><li><p>int addAndGet(int delta)：以原子方式将输入的数值与实例中的值相加，并返回结果。</p></li><li><p>Int  (int delta)：返回实例中的值之后，以原子操作与输入的值相加。</p></li><li><p>int getAndIncrement()：返回实例中的值之后以原子方式加1</p></li><li><p>int incrementAndGet()：以原子操作将实例中的值加1之后返回</p></li><li><p>int getAndDecrement()：返回实例中的值之后以原子方式减1</p></li><li><p>int decrementAndGet()：以原子操作将实例中的值减1之后返回</p></li><li><p>int getAndSet(int newValue)：返回实例中的值之后以原子方式设置为newValue的值。</p></li><li><p>boolean compareAndSet(int expect，int update)：如果实例中的值等于expect值，则以原子方式设置为update的值。</p></li></ul><h3 id="更新数组类型"><a href="#更新数组类型" class="headerlink" title="更新数组类型"></a>更新数组类型</h3><p><strong>AtomicIntegerArray</strong></p><p>主要是提供原子的方式更新数组里的整型，其常用方法如下。</p><ul><li><p>int addAndGet(int i，int delta)：以原子方式将输入值与实例中索引i的元素相加后返回。</p></li><li><p>boolean compareAndSet(int i，int expect，int update)：如果实例中索引i的元素等于预期值，则以原子方式将实例中索引i的元素设置成update值。</p></li><li><p>int getAndAccumulate(int i, int x,IntBinaryOperator accumulatorFunction)：将实例中索引i的元素返回之后以原子方式设置为accumulatorFunction中的操作返回的值，accumulatorFunction的left为原始值，left为传入的值。</p></li></ul><p>需要注意的是，AtomicIntegerArray中存储的数组是复制之后的原数组，当使用AtomicIntegerArray对内部的数组元素进行修改时，不会影响原数组。</p><h3 id="更新引用类型"><a href="#更新引用类型" class="headerlink" title="更新引用类型"></a>更新引用类型</h3><p>原子更新基本类型的AtomicInteger，只能更新一个变量，如果要原子更新多个变量，就需要使用这个原子更新引用类型提供的类。Atomic包提供了以下3个类。</p><p><strong>AtomicReference</strong></p><p>原子更新引用类型（不能解决ABA问题）。</p><ul><li>boolean compareAndSet(V expect，V update)：如果实例中对象等于预期值，则以原子方式将实例中对象替换为输入的对象</li></ul><p><strong>AtomicMarkableReference</strong></p><p>可以解决ABA问题，  可以记录更新过程中有没有变化</p><ul><li>AtomicMarkableReference(V initialRef, boolean initialMark)：initialRef（要关联的对象），initialMark（版本戳）</li></ul><p>AtomicStampedReference利用版本戳的形式记录了每次改变以后的版本号，版本戳为boolean类型，可以记录值是否被修改过。</p><p><strong>AtomicStampedReference</strong></p><p>能够解决ABA问题，并且可以记录变化次数</p><ul><li>AtpmicStampedReference(V initialRef,int initialStamp)：构造函数，initialRef（要关联的对象），initialStamp（版本戳）</li><li>V getStamp()：获取当前版本号</li><li>V getReference()：获取当前对象</li><li>boolean compareAndSet(V   expectedReference,V   newReference,int expectedStamp,int newStamp) ：更新当前对象及版本号</li></ul><p>AtomicStampedReference跟AtomicMarkableReference差不多， AtomicStampedReference是使用int类型的值作为版本戳，AtomicMarkableReference使用boolean mark作为版本戳。 </p><h3 id="原子更新字段类"><a href="#原子更新字段类" class="headerlink" title="原子更新字段类"></a>原子更新字段类</h3><p>如果需原子地更新某个类里的某个字段时，就需要使用原子更新字段类，Atomic包提供了以下3个类进行原子字段更新。</p><ul><li><p>AtomicIntegerFieldUpdater：原子更新整型的字段的更新器。</p></li><li><p>AtomicLongFieldUpdater：原子更新长整型字段的更新器。</p></li><li><p>AtomicReferenceFieldUpdater：原子更新引用类型里的字段。</p></li></ul><p>要想原子地更新字段类需要两步。第一步，因为原子更新字段类都是抽象类，每次使用的时候必须使用静态方法newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。第二步，更新类的字段（属性）必须使用public volatile修饰符。</p>]]></content>
    
    
    <categories>
      
      <category>并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CAS</tag>
      
      <tag>原子操作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springboot2+shiro+token认证</title>
    <link href="/blog/2019/12/13/springboot2-shiro-token%E8%AE%A4%E8%AF%81/"/>
    <url>/blog/2019/12/13/springboot2-shiro-token%E8%AE%A4%E8%AF%81/</url>
    
    <content type="html"><![CDATA[<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>从shiro过滤器的源码中可以看到，shiro过滤器拦截请求之后会调用isAccessAllowed()和onAccessDenied()方法，只要其中一个方法返回true，这次请求就会被放行。本文的实现方法是在onAccessDenied()中的执行登录验证即执行executeLogin()方法，这个方法会去执行AuthorizingRealm中的doGetAuthenticationInfo()方法，所以我们只需要在doGetAuthenticationInfo()里实现token的合法性检查，而doGetAuthenticationInfo()中需要AuthenticationToken类，这个类一般是存用户的用户名和密码，所以要重写这个类，把等待验证的token放入这个类，在executeLogin()方法会调用shiro过滤器中的createToken()方法创建AuthenticationToken实例，所以我们只需要重写createToken()方法创建带有token的重写之后的AuthenticationToken类即可。如果验证失败，因为我们是在executeLogin()方法中执行的登录，所以登录失败后会进入shiro过滤器中的onLoginFailure()方法，我们再重写这个方法，将验证失败的结果写入response就可以实现返回json而不是shiro默认的重定向到登录页。</p><p>多点登录限制是借助于redis实现，在用户登录时会将用户id作为键，当前token作为值存入redis中，在验证时获取token中的用户id，然后根据用户id去取redis中的token后对比，如果不同则当前token已经失效，提醒用户重新登录。</p><h2 id="pom文件"><a href="#pom文件" class="headerlink" title="pom文件"></a>pom文件</h2><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--shiro--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.shiro<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>shiro-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.shiro<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>shiro-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!--jwt--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.auth0<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>java-jwt<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!--redis--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h2 id="重写shiro过滤器"><a href="#重写shiro过滤器" class="headerlink" title="重写shiro过滤器"></a>重写shiro过滤器</h2><pre><code class="hljs reasonml">import com.alibaba.fastjson.JSON;import com.minte.english.security.common.utils.JwtUtil;import com.minte.english.security.common.utils.R;import org.apache.commons.lang3.StringUtils;import org.apache.shiro.authc.AuthenticationException;import org.apache.shiro.authc.AuthenticationToken;import org.apache.shiro.web.filter.authc.AuthenticatingFilter;import org.springframework.web.bind.annotation.RequestMethod;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public <span class="hljs-keyword">class</span> OAuth2Filter extends AuthenticatingFilter &#123;    @Override    protected AuthenticationToken create<span class="hljs-constructor">Token(ServletRequest <span class="hljs-params">request</span>, ServletResponse <span class="hljs-params">response</span>)</span> throws Exception &#123;        <span class="hljs-comment">//获取请求token</span>        String token = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JwtUtil</span>.</span></span>get<span class="hljs-constructor">RequestToken((HttpServletRequest)</span> request);        <span class="hljs-keyword">if</span>(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">StringUtils</span>.</span></span>is<span class="hljs-constructor">Blank(<span class="hljs-params">token</span>)</span>)&#123;            return null;        &#125;        return <span class="hljs-keyword">new</span> <span class="hljs-constructor">OAuth2Token(<span class="hljs-params">token</span>)</span>;    &#125;    @Override    protected boolean is<span class="hljs-constructor">AccessAllowed(ServletRequest <span class="hljs-params">request</span>, ServletResponse <span class="hljs-params">response</span>, Object <span class="hljs-params">mappedValue</span>)</span> &#123;        <span class="hljs-keyword">if</span>(((HttpServletRequest) request).get<span class="hljs-constructor">Method()</span>.equals(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">RequestMethod</span>.</span><span class="hljs-module"><span class="hljs-identifier">OPTIONS</span>.</span></span>name<span class="hljs-literal">()</span>))&#123;            return <span class="hljs-literal">true</span>;        &#125;        return <span class="hljs-literal">false</span>;    &#125;    @Override    protected boolean on<span class="hljs-constructor">AccessDenied(ServletRequest <span class="hljs-params">request</span>, ServletResponse <span class="hljs-params">response</span>)</span> throws Exception &#123;        <span class="hljs-comment">//获取请求token，如果token不存在，直接返回401</span>        String token = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JwtUtil</span>.</span></span>get<span class="hljs-constructor">RequestToken((HttpServletRequest)</span> request);        <span class="hljs-keyword">if</span>(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">StringUtils</span>.</span></span>is<span class="hljs-constructor">Blank(<span class="hljs-params">token</span>)</span>)&#123;            HttpServletResponse httpResponse = (HttpServletResponse) response;            httpResponse.set<span class="hljs-constructor">Header(<span class="hljs-string">"Access-Control-Allow-Credentials"</span>, <span class="hljs-string">"true"</span>)</span>;            String json = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JSON</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">JSONString(R.<span class="hljs-params">failed</span>(<span class="hljs-string">"false"</span>, <span class="hljs-string">"获取token信息失败"</span>)</span>);            httpResponse.get<span class="hljs-constructor">Writer()</span>.print(json);            return <span class="hljs-literal">false</span>;        &#125;        return execute<span class="hljs-constructor">Login(<span class="hljs-params">request</span>, <span class="hljs-params">response</span>)</span>;    &#125;    @Override    protected boolean on<span class="hljs-constructor">LoginFailure(AuthenticationToken <span class="hljs-params">token</span>, AuthenticationException <span class="hljs-params">e</span>, ServletRequest <span class="hljs-params">request</span>, ServletResponse <span class="hljs-params">response</span>)</span> &#123;        HttpServletResponse httpResponse = (HttpServletResponse) response;        httpResponse.set<span class="hljs-constructor">ContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>)</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//处理登录失败的异常</span>            Throwable throwable = e.get<span class="hljs-constructor">Cause()</span><span class="hljs-operator"> == </span>null ? e : e.get<span class="hljs-constructor">Cause()</span>;            R r = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">R</span>.</span></span>re<span class="hljs-constructor">Login(<span class="hljs-params">throwable</span>.<span class="hljs-params">getMessage</span>()</span>);            String json = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JSON</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">JSONString(<span class="hljs-params">r</span>)</span>;            httpResponse.get<span class="hljs-constructor">Writer()</span>.print(json);        &#125; catch (IOException e1) &#123;        &#125;        return <span class="hljs-literal">false</span>;    &#125;&#125;</code></pre><h2 id="重写AuthorizingRealm"><a href="#重写AuthorizingRealm" class="headerlink" title="重写AuthorizingRealm"></a>重写AuthorizingRealm</h2><pre><code class="hljs actionscript"><span class="hljs-meta"><span class="hljs-meta-keyword">import</span> com.auth0.jwt.exceptions.TokenExpiredException;</span><span class="hljs-meta"><span class="hljs-meta-keyword">import</span> com.minte.english.security.common.utils.JwtUtil;</span><span class="hljs-meta"><span class="hljs-meta-keyword">import</span> com.minte.english.security.module.sys.redis.UserRedis;</span><span class="hljs-meta"><span class="hljs-meta-keyword">import</span> com.minte.english.security.module.user.pojo.Role;</span><span class="hljs-meta"><span class="hljs-meta-keyword">import</span> com.minte.english.security.module.user.pojo.User;</span><span class="hljs-meta"><span class="hljs-meta-keyword">import</span> com.minte.english.security.module.user.service.IRoleService;</span><span class="hljs-meta"><span class="hljs-meta-keyword">import</span> com.minte.english.security.module.user.service.IUserRoleService;</span><span class="hljs-meta"><span class="hljs-meta-keyword">import</span> org.apache.shiro.authc.*;</span><span class="hljs-meta"><span class="hljs-meta-keyword">import</span> org.apache.shiro.authc.pam.UnsupportedTokenException;</span><span class="hljs-meta"><span class="hljs-meta-keyword">import</span> org.apache.shiro.authz.AuthorizationInfo;</span><span class="hljs-meta"><span class="hljs-meta-keyword">import</span> org.apache.shiro.authz.SimpleAuthorizationInfo;</span><span class="hljs-meta"><span class="hljs-meta-keyword">import</span> org.apache.shiro.authz.UnauthenticatedException;</span><span class="hljs-meta"><span class="hljs-meta-keyword">import</span> org.apache.shiro.realm.AuthorizingRealm;</span><span class="hljs-meta"><span class="hljs-meta-keyword">import</span> org.apache.shiro.subject.PrincipalCollection;</span><span class="hljs-meta"><span class="hljs-meta-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><span class="hljs-meta"><span class="hljs-meta-keyword">import</span> org.springframework.stereotype.Component;</span><span class="hljs-meta"><span class="hljs-meta-keyword">import</span> java.io.UnsupportedEncodingException;</span><span class="hljs-meta"><span class="hljs-meta-keyword">import</span> java.util.Arrays;</span><span class="hljs-meta"><span class="hljs-meta-keyword">import</span> java.util.HashSet;</span><span class="hljs-meta"><span class="hljs-meta-keyword">import</span> java.util.Set;</span>@Component<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OAuth2Realm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AuthorizingRealm</span> </span>&#123;    @Autowired    <span class="hljs-keyword">private</span> IUserRoleService userRoleService;    @Autowired    <span class="hljs-keyword">private</span> IRoleService roleService;    @Autowired    <span class="hljs-keyword">private</span> UserRedis userRedis;    @Override    <span class="hljs-keyword">public</span> boolean supports(AuthenticationToken token) &#123;        <span class="hljs-keyword">return</span> token <span class="hljs-keyword">instanceof</span> OAuth2Token;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 授权(验证权限时调用)</span><span class="hljs-comment">     */</span>    @Override    <span class="hljs-keyword">protected</span> AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) &#123;        User user = (User) principals.getPrimaryPrincipal();        Long userId = user.getId();        Integer roleId = userRoleService.getRoleIdByUserId(userId);        Role role = roleService.getById(roleId);        <span class="hljs-comment">//用户权限列表</span>        Set&lt;String&gt; permsSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(Arrays.asList(role.getPermissions().split(<span class="hljs-string">","</span>)));        SimpleAuthorizationInfo info = <span class="hljs-keyword">new</span> SimpleAuthorizationInfo();        info.setStringPermissions(permsSet);        <span class="hljs-keyword">return</span> info;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 认证(登录时调用)</span><span class="hljs-comment">     */</span>    @Override    <span class="hljs-keyword">protected</span> AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123;        String accessToken = (String) token.getPrincipal();        <span class="hljs-comment">// 验证token信息</span>        <span class="hljs-keyword">try</span> &#123;            JwtUtil.verify(accessToken);        &#125; <span class="hljs-keyword">catch</span> (TokenExpiredException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ExpiredCredentialsException();        &#125; <span class="hljs-keyword">catch</span> (UnsupportedEncodingException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedTokenException(<span class="hljs-string">"token已失效"</span>);        &#125;        <span class="hljs-comment">// 检测是否在其他设备登录</span>        Long userId = JwtUtil.getUserId(accessToken);        String onlineToken = userRedis.getOnlineUserToken(userId);        <span class="hljs-keyword">if</span> (!onlineToken.equals(accessToken)) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentAccessException(<span class="hljs-string">"该账号已在其他设备登录"</span>);        &#125;        <span class="hljs-comment">// 检查用户授权天数，是否被冻结</span>        User user = userRedis.get(accessToken);        <span class="hljs-keyword">if</span> (user.getValidityDays() &lt;= <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnauthenticatedException(<span class="hljs-string">"授权天数不足"</span>);        &#125;        <span class="hljs-comment">//账号锁定</span>        <span class="hljs-keyword">if</span> (!user.getEnabled()) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> DisabledAccountException(<span class="hljs-string">"该账号已被禁用"</span>);        &#125;        SimpleAuthenticationInfo info = <span class="hljs-keyword">new</span> SimpleAuthenticationInfo(user, accessToken, getName());        <span class="hljs-keyword">return</span> info;    &#125;&#125;</code></pre><h2 id="Config类"><a href="#Config类" class="headerlink" title="Config类"></a>Config类</h2><pre><code class="hljs reasonml">@Configurationpublic <span class="hljs-keyword">class</span> ShiroConfig &#123;    @<span class="hljs-constructor">Bean(<span class="hljs-string">"securityManager"</span>)</span>    public SecurityManager security<span class="hljs-constructor">Manager(OAuth2Realm <span class="hljs-params">oAuth2Realm</span>)</span> &#123;        DefaultWebSecurityManager securityManager = <span class="hljs-keyword">new</span> <span class="hljs-constructor">DefaultWebSecurityManager()</span>;        securityManager.set<span class="hljs-constructor">Realm(<span class="hljs-params">oAuth2Realm</span>)</span>;        securityManager.set<span class="hljs-constructor">RememberMeManager(<span class="hljs-params">null</span>)</span>;        return securityManager;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * setUsePrefix(false)用于解决一个奇怪的bug。在引入spring aop的情况下。</span><span class="hljs-comment">     * 在@Controller注解的类的方法中加入@RequiresRole注解，会导致该方法无法映射请求，导致返回404。 加入这项配置能解决这个bug</span><span class="hljs-comment">     * 在使用@Transaction注解时出现无法注入bug解决</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * @return</span><span class="hljs-comment">     */</span>    @Bean    public static DefaultAdvisorAutoProxyCreator get<span class="hljs-constructor">DefaultAdvisorAutoProxyCreator()</span> &#123;        DefaultAdvisorAutoProxyCreator creator = <span class="hljs-keyword">new</span> <span class="hljs-constructor">DefaultAdvisorAutoProxyCreator()</span>;        creator.set<span class="hljs-constructor">ProxyTargetClass(<span class="hljs-params">true</span>)</span>;        creator.set<span class="hljs-constructor">UsePrefix(<span class="hljs-params">false</span>)</span>;        return creator;    &#125;    @<span class="hljs-constructor">Bean(<span class="hljs-string">"shiroFilter"</span>)</span>    public ShiroFilterFactoryBean shir<span class="hljs-constructor">Filter(SecurityManager <span class="hljs-params">manager</span>)</span> &#123;        ShiroFilterFactoryBean shiroFilterFactory = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ShiroFilterFactoryBean()</span>;        shiroFilterFactory.set<span class="hljs-constructor">SecurityManager(<span class="hljs-params">manager</span>)</span>;        Map&lt;String, Filter&gt; filterMap = shiroFilterFactory.get<span class="hljs-constructor">Filters()</span>;        filterMap.put(<span class="hljs-string">"oauth2"</span>, <span class="hljs-keyword">new</span> <span class="hljs-constructor">OAuth2Filter()</span>);        shiroFilterFactory.set<span class="hljs-constructor">Filters(<span class="hljs-params">filterMap</span>)</span>;        Map&lt;String, String&gt; filterChainDefinitionMap = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;<span class="hljs-literal">()</span>;        filterChainDefinitionMap.put(<span class="hljs-string">"/login"</span>, <span class="hljs-string">"anon"</span>);        filterChainDefinitionMap.put(<span class="hljs-string">"/actuator"</span>, <span class="hljs-string">"anon"</span>);        filterChainDefinitionMap.put(<span class="hljs-string">"/actuator/**"</span>, <span class="hljs-string">"anon"</span>);        filterChainDefinitionMap.put(<span class="hljs-string">"/validate/**"</span>, <span class="hljs-string">"anon"</span>);        filterChainDefinitionMap.put(<span class="hljs-string">"/user/getByUsername"</span>, <span class="hljs-string">"anon"</span>);        filterChainDefinitionMap.put(<span class="hljs-string">"/**"</span>, <span class="hljs-string">"oauth2"</span>);        shiroFilterFactory.set<span class="hljs-constructor">FilterChainDefinitionMap(<span class="hljs-params">filterChainDefinitionMap</span>)</span>;        return shiroFilterFactory;    &#125;    @<span class="hljs-constructor">Bean(<span class="hljs-string">"lifecycleBeanPostProcessor"</span>)</span>    public LifecycleBeanPostProcessor lifecycle<span class="hljs-constructor">BeanPostProcessor()</span> &#123;        return <span class="hljs-keyword">new</span> <span class="hljs-constructor">LifecycleBeanPostProcessor()</span>;    &#125;    @Bean    public AuthorizationAttributeSourceAdvisor authorization<span class="hljs-constructor">AttributeSourceAdvisor(SecurityManager <span class="hljs-params">securityManager</span>)</span> &#123;        AuthorizationAttributeSourceAdvisor advisor = <span class="hljs-keyword">new</span> <span class="hljs-constructor">AuthorizationAttributeSourceAdvisor()</span>;        advisor.set<span class="hljs-constructor">SecurityManager(<span class="hljs-params">securityManager</span>)</span>;        return advisor;    &#125;&#125;</code></pre><h2 id="重写AuthenticationToken类"><a href="#重写AuthenticationToken类" class="headerlink" title="重写AuthenticationToken类"></a>重写AuthenticationToken类</h2><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.shiro.authc.AuthenticationToken;<span class="hljs-comment">/**</span><span class="hljs-comment"> * token</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Mark sunlightcs@gmail.com</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OAuth2Token</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AuthenticationToken</span> </span>&#123;    <span class="hljs-keyword">private</span> String token;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">OAuth2Token</span><span class="hljs-params">(String token)</span></span>&#123;        <span class="hljs-keyword">this</span>.token = token;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPrincipal</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> token;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getCredentials</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> token;    &#125;&#125;</code></pre><h2 id="userRedis的配置"><a href="#userRedis的配置" class="headerlink" title="userRedis的配置"></a>userRedis的配置</h2><pre><code class="hljs reasonml">import com.minte.english.security.common.utils.JwtUtil;import com.minte.english.security.common.utils.RedisKeys;import com.minte.english.security.common.utils.RedisUtil;import com.minte.english.security.<span class="hljs-keyword">module</span>.sys.service.ISysConfigService;import com.minte.english.security.<span class="hljs-keyword">module</span>.user.pojo.User;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;<span class="hljs-comment">/**</span><span class="hljs-comment"> * @author zgc</span><span class="hljs-comment"> * @since 2019/12/5</span><span class="hljs-comment"> */</span>@Componentpublic <span class="hljs-keyword">class</span> UserRedis &#123;    @Autowired    <span class="hljs-keyword">private</span> RedisUtil redisUtil;    @Autowired    <span class="hljs-keyword">private</span> ISysConfigService sysConfigService;    public void save<span class="hljs-constructor">OrUpdate(User <span class="hljs-params">user</span>, String <span class="hljs-params">token</span>)</span> &#123;        String imgPath = sysConfigService.get<span class="hljs-constructor">Value(<span class="hljs-string">"ICON_PATH"</span>)</span> + user.get<span class="hljs-constructor">ImagePath()</span>;        user.set<span class="hljs-constructor">ImagePath(<span class="hljs-params">imgPath</span>)</span>;        redisUtil.set(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">RedisKeys</span>.</span></span>get<span class="hljs-constructor">UserKey(<span class="hljs-params">token</span>)</span>, user, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JwtUtil</span>.</span></span>get<span class="hljs-constructor">ExpiresTime(<span class="hljs-params">token</span>)</span>);    &#125;    public void delete(String token) &#123;        redisUtil.delete(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">RedisKeys</span>.</span></span>get<span class="hljs-constructor">UserKey(<span class="hljs-params">token</span>)</span>);    &#125;    public User get(String token) &#123;        return redisUtil.get(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">RedisKeys</span>.</span></span>get<span class="hljs-constructor">UserKey(<span class="hljs-params">token</span>)</span>, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">User</span>.</span></span><span class="hljs-keyword">class</span>);    &#125;    public void save<span class="hljs-constructor">OrUpdateOnlineUser(Long <span class="hljs-params">userId</span>, String <span class="hljs-params">token</span>)</span> &#123;        redisUtil.set(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">RedisKeys</span>.</span></span>get<span class="hljs-constructor">OnlineUserKey(<span class="hljs-params">userId</span>)</span>, token, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JwtUtil</span>.</span></span>get<span class="hljs-constructor">ExpiresTime(<span class="hljs-params">token</span>)</span>);    &#125;    public String get<span class="hljs-constructor">OnlineUserToken(Long <span class="hljs-params">userId</span>)</span> &#123;        return redisUtil.get(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">RedisKeys</span>.</span></span>get<span class="hljs-constructor">OnlineUserKey(<span class="hljs-params">userId</span>)</span>, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">String</span>.</span></span><span class="hljs-keyword">class</span>);    &#125;    public void delete<span class="hljs-constructor">OnlineUser(Long <span class="hljs-params">userId</span>, String <span class="hljs-params">token</span>)</span> &#123;        <span class="hljs-keyword">if</span> (get<span class="hljs-constructor">OnlineUserToken(<span class="hljs-params">userId</span>)</span>.equals(token)) &#123;            redisUtil.delete(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">RedisKeys</span>.</span></span>get<span class="hljs-constructor">OnlineUserKey(<span class="hljs-params">userId</span>)</span>);        &#125;    &#125;    public boolean is<span class="hljs-constructor">Online(Long <span class="hljs-params">userId</span>)</span> &#123;        return userId<span class="hljs-operator"> == </span>null ? <span class="hljs-literal">false</span> : redisUtil.contains<span class="hljs-constructor">Key(RedisKeys.<span class="hljs-params">getOnlineUserKey</span>(<span class="hljs-params">userId</span>)</span>);    &#125;    public void update(User user) &#123;        Long userId = user.get<span class="hljs-constructor">Id()</span>;        <span class="hljs-keyword">if</span> (is<span class="hljs-constructor">Online(<span class="hljs-params">userId</span>)</span>) &#123;            String token = get<span class="hljs-constructor">OnlineUserToken(<span class="hljs-params">userId</span>)</span>;            save<span class="hljs-constructor">OrUpdate(<span class="hljs-params">user</span>, <span class="hljs-params">token</span>)</span>;        &#125;    &#125;&#125;</code></pre><h2 id="Shiro的异常"><a href="#Shiro的异常" class="headerlink" title="Shiro的异常"></a>Shiro的异常</h2><ul><li>AuthenticationException:身份验证异常<ul><li>CredentitalsException:凭证异常<ul><li>IncorrectCredentialsException:不支持的凭证</li><li>ExpiredCredentialsException:凭证过期</li></ul></li><li>AccountException:账号异常<ul><li>ConcurrentAccessException:并发访问异常</li><li>UnknownAccountException:未知的账号</li><li>ExcessiveAttemptsException:认证次数超限</li><li>DisabledAccountException:账号被禁用</li><li>LockedAccountException:账号被锁定</li></ul></li><li>UnsupportedTokenException:Token异常</li></ul></li><li>AuthorizationException:授权异常<ul><li>UnauthorizedException:抛出以指示请求的操作或对请求的资源的访问是不允许的</li><li>UnanthenticatedException:当尚未完成成功认证时，尝试执行授权操作时引发异常</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>shiro</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>shiro</tag>
      
      <tag>token</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ajax跨域访问shiro问题</title>
    <link href="/blog/2019/12/06/ajax%E8%B7%A8%E5%9F%9F%E8%AE%BF%E9%97%AEshiro%E9%97%AE%E9%A2%98/"/>
    <url>/blog/2019/12/06/ajax%E8%B7%A8%E5%9F%9F%E8%AE%BF%E9%97%AEshiro%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="ajax跨域访问shiro问题"><a href="#ajax跨域访问shiro问题" class="headerlink" title="ajax跨域访问shiro问题"></a>ajax跨域访问shiro问题</h1><p>因为之前的ssm项目要做一次迭代，将前后端不分离改为前后端分离，但是做了跨域设置之后登录可以成功，但其他接口仍然访问不到，前端控制台报错为跨域错误：预请求被重定向。既然登录访问可以成功，说明跨域已经成功，但依然访问不到登录其他接口应该是shiro的问题。查看代码后发现，之前的shiro并没有对预请求进行处理，而且也没有做cookie的跨域，因为shiro所需要的sessionId依赖于cookie或url中的sessionId，但前端没有对sessionId进行处理，cookie也不允许跨域，shiro依然会对登录成功之后的请求进行拦截。所以这次要解决两个问题</p><ol><li>shiro过滤器中放行预请求</li><li>做关于cookie跨域的设置</li></ol><h2 id="ajax参考"><a href="#ajax参考" class="headerlink" title="ajax参考"></a>ajax参考</h2><pre><code class="hljs dts">$.ajax(&#123;<span class="hljs-symbol">url:</span>url,<span class="hljs-symbol">data:</span>&#123;<span class="hljs-symbol">unitId:</span><span class="hljs-string">"801"</span>&#125;,<span class="hljs-comment">// 允许携带cookie跨域</span><span class="hljs-symbol">crossDomain:</span> true, <span class="hljs-symbol">xhrFields:</span>&#123;<span class="hljs-symbol">              withCredentials:</span>true          &#125;,<span class="hljs-symbol">type:</span><span class="hljs-string">"GET"</span>,<span class="hljs-symbol">success:</span>function(data)&#123;console.log(data);&#125;&#125;)</code></pre><h2 id="后端跨域处理"><a href="#后端跨域处理" class="headerlink" title="后端跨域处理"></a>后端跨域处理</h2><p>因为项目为ssm项目，所以跨域的处理使用filter实现</p><ol><li>添加跨域cookie后，Allow-Origin不能设置为*</li><li>Allow-Method根据情况而定</li></ol><pre><code class="hljs reasonml">@<span class="hljs-constructor">WebFilter(<span class="hljs-string">"/*"</span>)</span>public <span class="hljs-keyword">class</span> CORSFilter implements Filter &#123;    public <span class="hljs-constructor">CORSFilter()</span> &#123;    &#125;    public void destroy<span class="hljs-literal">()</span> &#123;    &#125;    public void <span class="hljs-keyword">do</span><span class="hljs-constructor">Filter(ServletRequest <span class="hljs-params">req</span>, ServletResponse <span class="hljs-params">res</span>, FilterChain <span class="hljs-params">chain</span>)</span> throws IOException, ServletException &#123;        <span class="hljs-comment">//设置跨域请求</span>        response.set<span class="hljs-constructor">Header(<span class="hljs-string">"Access-Control-Allow-Headers"</span>, <span class="hljs-string">"x-requested-with"</span>)</span>;        response.set<span class="hljs-constructor">Header(<span class="hljs-string">"Access-Control-Allow-Method"</span>, <span class="hljs-string">"POST, GET, OPTIONS"</span>)</span>;        response.set<span class="hljs-constructor">Header(<span class="hljs-string">"Access-Control-Allow-Origin"</span>, <span class="hljs-string">"http://localhost:8090"</span>)</span>;        response.set<span class="hljs-constructor">Header(<span class="hljs-string">"Access-Control-Allow-Credentials"</span>, <span class="hljs-string">"true"</span>)</span>;        filterChain.<span class="hljs-keyword">do</span><span class="hljs-constructor">Filter(<span class="hljs-params">request</span>, <span class="hljs-params">response</span>)</span>;        chain.<span class="hljs-keyword">do</span><span class="hljs-constructor">Filter(<span class="hljs-params">req</span>, <span class="hljs-params">response</span>)</span>;    &#125;    public void init(FilterConfig fConfig) throws ServletException &#123;    &#125;&#125;</code></pre><h2 id="重写shiro过滤器"><a href="#重写shiro过滤器" class="headerlink" title="重写shiro过滤器"></a>重写shiro过滤器</h2><p>配置中没有定义自己的shiro过滤器，所以都是默认过滤器</p><table><thead><tr><th>Filter Name</th><th>Class</th></tr></thead><tbody><tr><td>anon</td><td>org.apache.shiro.web.filter.authc.AnonymousFilter</td></tr><tr><td>authc</td><td>org.apache.shiro.web.filter.authc.FormAuthenticationFilter</td></tr><tr><td>authcBasic</td><td>org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter</td></tr><tr><td>perms</td><td>org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter</td></tr><tr><td>port</td><td>org.apache.shiro.web.filter.authz.PortFilter</td></tr><tr><td>rest</td><td>org.apache.shiro.web.filter.authz.HttpMethodPermissionFilter</td></tr><tr><td>roles</td><td>org.apache.shiro.web.filter.authz.RolesAuthorizationFilter</td></tr><tr><td>ssl</td><td>org.apache.shiro.web.filter.authz.SslFilter</td></tr><tr><td>user</td><td>org.apache.shiro.web.filter.authc.UserFilter</td></tr></tbody></table><p>根据以上表格，我们需要重写FormAuthenticationFilter及RolesAuthorizationFilter</p><p>FormAuthenticationFilter</p><pre><code class="hljs reasonml">package com.yaoxx.base.shiro;import java.io.PrintWriter;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.apache.commons.lang3.StringUtils;import org.apache.shiro.web.filter.authc.FormAuthenticationFilter;import org.apache.shiro.web.util.WebUtils;import org.springframework.http.HttpStatus;public <span class="hljs-keyword">class</span> MyAuthenticationFilter extends FormAuthenticationFilter &#123;      @Override   protected boolean is<span class="hljs-constructor">AccessAllowed(ServletRequest <span class="hljs-params">request</span>, ServletResponse <span class="hljs-params">response</span>, Object <span class="hljs-params">mappedValue</span>)</span> &#123;   boolean allowed = super.is<span class="hljs-constructor">AccessAllowed(<span class="hljs-params">request</span>, <span class="hljs-params">response</span>, <span class="hljs-params">mappedValue</span>)</span>;   <span class="hljs-keyword">if</span> (!allowed) &#123;   <span class="hljs-comment">// 判断请求是否是options请求</span>   String <span class="hljs-keyword">method</span> = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">WebUtils</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">Http(<span class="hljs-params">request</span>)</span>.get<span class="hljs-constructor">Method()</span>;   <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">StringUtils</span>.</span></span>equals<span class="hljs-constructor">IgnoreCase(<span class="hljs-string">"OPTIONS"</span>, <span class="hljs-params">method</span>)</span>) &#123;   return <span class="hljs-literal">true</span>;   &#125;   &#125;   return allowed;   &#125;   @Override   protected boolean on<span class="hljs-constructor">AccessDenied(ServletRequest <span class="hljs-params">request</span>, ServletResponse <span class="hljs-params">response</span>)</span> throws Exception &#123;   <span class="hljs-comment">// 判断是否登录</span>   <span class="hljs-keyword">if</span> (is<span class="hljs-constructor">LoginRequest(<span class="hljs-params">request</span>, <span class="hljs-params">response</span>)</span>) &#123;      <span class="hljs-comment">// 判断是否为post访问</span>   <span class="hljs-keyword">if</span> (is<span class="hljs-constructor">LoginSubmission(<span class="hljs-params">request</span>, <span class="hljs-params">response</span>)</span>) &#123;    return execute<span class="hljs-constructor">Login(<span class="hljs-params">request</span>, <span class="hljs-params">response</span>)</span>;   &#125; <span class="hljs-keyword">else</span> &#123;   <span class="hljs-comment">// sessionID已经注册,但是并没有使用post方式提交</span>   return <span class="hljs-literal">true</span>;   &#125;   &#125; <span class="hljs-keyword">else</span> &#123;   HttpServletRequest req = (HttpServletRequest) request;   HttpServletResponse resp = (HttpServletResponse) response;   String ajaxHeader = req.get<span class="hljs-constructor">Header(CustomSessionManager.AUTHORIZATION)</span>;   <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">StringUtils</span>.</span></span>is<span class="hljs-constructor">NotBlank(<span class="hljs-params">ajaxHeader</span>)</span>) &#123;   <span class="hljs-comment">// 前端Ajax请求，则不会重定向</span>   resp.set<span class="hljs-constructor">Header(<span class="hljs-string">"Access-Control-Allow-Origin"</span>, <span class="hljs-params">req</span>.<span class="hljs-params">getHeader</span>(<span class="hljs-string">"Origin"</span>)</span>);   resp.set<span class="hljs-constructor">Header(<span class="hljs-string">"Access-Control-Allow-Credentials"</span>, <span class="hljs-string">"true"</span>)</span>;   resp.set<span class="hljs-constructor">ContentType(<span class="hljs-string">"application/json; charset=utf-8"</span>)</span>;   resp.set<span class="hljs-constructor">CharacterEncoding(<span class="hljs-string">"UTF-8"</span>)</span>;   <span class="hljs-comment">//设置未登录状态码</span>   resp.set<span class="hljs-constructor">Status(HttpStatus.UNAUTHORIZED.<span class="hljs-params">value</span>()</span>);   PrintWriter out = resp.get<span class="hljs-constructor">Writer()</span>;   String result = <span class="hljs-string">"&#123;\"MESSAGE\":\"未登录用户\"&#125;"</span>;   out.println(result);   out.flush<span class="hljs-literal">()</span>;   out.close<span class="hljs-literal">()</span>;   &#125; <span class="hljs-keyword">else</span> &#123;   <span class="hljs-comment">// == 如果是普通访问重定向至shiro配置的登录页面 == //</span>   save<span class="hljs-constructor">RequestAndRedirectToLogin(<span class="hljs-params">request</span>, <span class="hljs-params">response</span>)</span>;   &#125;   &#125;   return <span class="hljs-literal">false</span>;   &#125;&#125;</code></pre><p>RolesAuthorizationFilter</p><pre><code class="hljs reasonml">package com.yaoxx.base.shiro;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.apache.commons.lang3.StringUtils;import org.apache.shiro.web.filter.authz.RolesAuthorizationFilter;import org.apache.shiro.web.util.WebUtils;import org.springframework.http.HttpStatus;import org.springframework.web.bind.annotation.RequestMethod;public <span class="hljs-keyword">class</span> MyAuthorizationFilter extends RolesAuthorizationFilter &#123;   @Override   public boolean is<span class="hljs-constructor">AccessAllowed(ServletRequest <span class="hljs-params">request</span>, ServletResponse <span class="hljs-params">response</span>, Object <span class="hljs-params">mappedValue</span>)</span>throws IOException &#123;   boolean allowed =super.is<span class="hljs-constructor">AccessAllowed(<span class="hljs-params">request</span>, <span class="hljs-params">response</span>, <span class="hljs-params">mappedValue</span>)</span>;   <span class="hljs-keyword">if</span> (!allowed) &#123;   String <span class="hljs-keyword">method</span> = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">WebUtils</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">Http(<span class="hljs-params">request</span>)</span>.get<span class="hljs-constructor">Method()</span>;   <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">StringUtils</span>.</span></span>equals<span class="hljs-constructor">IgnoreCase(<span class="hljs-string">"OPTIONS"</span>, <span class="hljs-params">method</span>)</span>) &#123;   return <span class="hljs-literal">true</span>;   &#125;   &#125;   return allowed;   &#125;   @Override   protected boolean on<span class="hljs-constructor">AccessDenied(ServletRequest <span class="hljs-params">request</span>, ServletResponse <span class="hljs-params">response</span>)</span> throws IOException &#123;   HttpServletRequest req = (HttpServletRequest) request;   HttpServletResponse resp = (HttpServletResponse) response;   <span class="hljs-comment">// 前端Ajax请求时requestHeader里面带一些参数，用于判断是否是前端的请求</span>   String ajaxHeader = req.get<span class="hljs-constructor">Header(CustomSessionManager.AUTHORIZATION)</span>;   <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">StringUtils</span>.</span></span>is<span class="hljs-constructor">NotBlank(<span class="hljs-params">ajaxHeader</span>)</span>) &#123;   <span class="hljs-comment">// 前端Ajax请求，则不会重定向</span>   resp.set<span class="hljs-constructor">Header(<span class="hljs-string">"Access-Control-Allow-Origin"</span>, <span class="hljs-params">req</span>.<span class="hljs-params">getHeader</span>(<span class="hljs-string">"Origin"</span>)</span>);   resp.set<span class="hljs-constructor">Header(<span class="hljs-string">"Access-Control-Allow-Credentials"</span>, <span class="hljs-string">"true"</span>)</span>;   resp.set<span class="hljs-constructor">ContentType(<span class="hljs-string">"application/json; charset=utf-8"</span>)</span>;   resp.set<span class="hljs-constructor">CharacterEncoding(<span class="hljs-string">"UTF-8"</span>)</span>;   PrintWriter out = resp.get<span class="hljs-constructor">Writer()</span>;   String result = <span class="hljs-string">"&#123;\"MESSAGE\":\"角色，权限不足\"&#125;"</span>;   out.println(result);   out.flush<span class="hljs-literal">()</span>;   out.close<span class="hljs-literal">()</span>;   return <span class="hljs-literal">false</span>;   &#125;   return super.on<span class="hljs-constructor">AccessDenied(<span class="hljs-params">request</span>, <span class="hljs-params">response</span>)</span>;   &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>shiro</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>shiro</tag>
      
      <tag>bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>summernote文本编辑器的使用</title>
    <link href="/blog/2019/08/26/summernote%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/blog/2019/08/26/summernote%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>summernote是一款Jquery文本编辑器的插件，本文只是简单的实现文本编辑及图片上传下载功能，更多api请参考<a href="https://summernote.org/getting-started/" target="_blank" rel="noopener">summernote官方文档</a></p><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>summernote依赖于bootstrap和jquery所以也需要引入bootstrap和jquery</p><pre><code class="hljs routeros">&lt;link <span class="hljs-attribute">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attribute">type</span>=<span class="hljs-string">"text/css"</span> <span class="hljs-attribute">href</span>=<span class="hljs-string">"/assets/css/lib/bootstrap.min.css"</span> &gt;&lt;link <span class="hljs-attribute">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attribute">type</span>=<span class="hljs-string">"text/css"</span> <span class="hljs-attribute">href</span>=<span class="hljs-string">"/css/summernote.css"</span>&gt;&lt;script <span class="hljs-attribute">src</span>=<span class="hljs-string">"/assets/js/lib/jquery.min.js"</span>&gt;&lt;/script&gt;&lt;script <span class="hljs-attribute">src</span>=<span class="hljs-string">"/assets/js/lib/bootstrap.min.js"</span>&gt;&lt;/script&gt;&lt;script <span class="hljs-attribute">src</span>=<span class="hljs-string">"/js/summernote.js"</span>&gt;&lt;/script&gt;</code></pre><h2 id="html"><a href="#html" class="headerlink" title="html"></a>html</h2><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">id</span>=<span class="hljs-string">"summernote"</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;</code></pre><h2 id="js"><a href="#js" class="headerlink" title="js"></a>js</h2><pre><code class="hljs javascript"><span class="hljs-comment">// summernote的初始化方法</span>$(<span class="hljs-string">"#summernote"</span>).summernote(&#123;    placeholder: <span class="hljs-string">"输入内容"</span>,    tabsize: <span class="hljs-number">2</span>,    height: <span class="hljs-number">300</span>,    lang: <span class="hljs-string">'zh-CN'</span>,    focus: <span class="hljs-literal">true</span>,    callbacks: &#123;        onImageUpload: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">files</span>) </span>&#123;        <span class="hljs-comment">// 上传图片</span>            uploadFile(files[<span class="hljs-number">0</span>]);        &#125;,        onMediaDelete: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">target</span>)</span>&#123;        <span class="hljs-comment">// 删除图片</span>            deleteFile(target);        &#125;    &#125;&#125;);<span class="hljs-comment">// 上传文件</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">uploadFile</span>(<span class="hljs-params">file</span>)</span>&#123;    <span class="hljs-keyword">var</span> imgPath = sendFile(file);    $(<span class="hljs-string">'#summernote'</span>).summernote(<span class="hljs-string">'insertImage'</span>, imgPath);&#125;<span class="hljs-comment">// 用于summernote内容回显</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getContent</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">var</span> content = $(<span class="hljs-string">'#summernote'</span>).summernote(<span class="hljs-string">'code'</span>);    <span class="hljs-keyword">if</span> (content==<span class="hljs-string">"&lt;p&gt;&lt;br&gt;&lt;/p&gt;"</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>;    &#125;    <span class="hljs-keyword">return</span> content;&#125;<span class="hljs-comment">// 获取summernote的内容</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addContent</span>(<span class="hljs-params">content</span>)</span>&#123;    $(<span class="hljs-string">'#summernote'</span>).summernote(<span class="hljs-string">'code'</span>, content);&#125;<span class="hljs-comment">// 上传图片至服务器</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sendFile</span>(<span class="hljs-params">file</span>) </span>&#123;    <span class="hljs-keyword">if</span> (file == <span class="hljs-literal">null</span>||file==<span class="hljs-literal">undefined</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    &#125;    <span class="hljs-keyword">var</span> formData = <span class="hljs-keyword">new</span> FormData();    formData.append(<span class="hljs-string">"file"</span>, file);    <span class="hljs-built_in">console</span>.log(formData);    <span class="hljs-keyword">var</span> filePath = <span class="hljs-string">""</span>;    $.ajax(&#123;        url: <span class="hljs-string">"/file/upload"</span>,        type: <span class="hljs-string">"POST"</span>,        data: formData,        <span class="hljs-keyword">async</span>: <span class="hljs-literal">false</span>,        contentType: <span class="hljs-literal">false</span>,        processData: <span class="hljs-literal">false</span>,        success: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">result</span>) </span>&#123;            filePath = result.data.filePath;        &#125;    &#125;);    <span class="hljs-keyword">return</span> filePath;&#125;<span class="hljs-comment">// 删除服务器图片</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deleteFile</span>(<span class="hljs-params">filePath</span>) </span>&#123;    $.ajax(&#123;        url: <span class="hljs-string">"/file/delete"</span>,        type: <span class="hljs-string">"POST"</span>,        data: &#123;            <span class="hljs-string">"filePath"</span>: filePath        &#125;,        success: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">result</span>) </span>&#123;            <span class="hljs-built_in">console</span>.log(result);        &#125;    &#125;)&#125;</code></pre><h2 id="java接口"><a href="#java接口" class="headerlink" title="java接口"></a>java接口</h2><pre><code class="hljs reasonml">@<span class="hljs-constructor">RequestMapping(<span class="hljs-string">"/addImg"</span>)</span>public Map add<span class="hljs-constructor">Img(@RequestParam(<span class="hljs-string">"file"</span>)</span> MultipartFile file, HttpServletRequest request) throws IOException &#123;    String fileName = file.get<span class="hljs-constructor">OriginalFilename()</span>;    fileName.split(<span class="hljs-string">"."</span>);    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">"接收到文件:"</span> + fileName);    String fileType = fileName.substring(fileName.last<span class="hljs-constructor">IndexOf(<span class="hljs-string">"."</span>)</span>);    String filePath = <span class="hljs-keyword">new</span> <span class="hljs-constructor">File(<span class="hljs-string">""</span>)</span>.get<span class="hljs-constructor">CanonicalFile()</span>.get<span class="hljs-constructor">Path()</span> + <span class="hljs-string">"/static/images/"</span>;    filePath = filePath + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">UUID</span>.</span></span>random<span class="hljs-constructor">UUID()</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span> + fileType;    File dest = <span class="hljs-keyword">new</span> <span class="hljs-constructor">File(<span class="hljs-params">filePath</span>)</span>;    <span class="hljs-keyword">if</span> (dest.get<span class="hljs-constructor">ParentFile()</span> != null) &#123;        dest.get<span class="hljs-constructor">ParentFile()</span>.mkdirs<span class="hljs-literal">()</span>;    &#125;    <span class="hljs-keyword">try</span> &#123;        file.transfer<span class="hljs-constructor">To(<span class="hljs-params">dest</span>)</span>;    &#125; catch (IOException e) &#123;        log.warning(<span class="hljs-string">"文件上传失败:"</span> + e);        return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ResultMap</span>.</span></span>failed(<span class="hljs-string">"文件上传失败"</span>);    &#125;    String path = request.get<span class="hljs-constructor">Scheme()</span> + <span class="hljs-string">"://"</span> + request.get<span class="hljs-constructor">ServerName()</span> + <span class="hljs-string">":"</span>            + request.get<span class="hljs-constructor">ServerPort()</span> + request.get<span class="hljs-constructor">ContextPath()</span> + <span class="hljs-string">"/images/"</span> + dest.get<span class="hljs-constructor">Name()</span>;    return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ResultMap</span>.</span></span>success(path);&#125;@<span class="hljs-constructor">RequestMapping(<span class="hljs-string">"deleteImg"</span>)</span>public Map delete<span class="hljs-constructor">Img(String <span class="hljs-params">imgSrc</span>)</span> &#123;    String fileName = imgSrc.substring(imgSrc.last<span class="hljs-constructor">IndexOf(<span class="hljs-string">"/"</span>)</span> + <span class="hljs-number">1</span>);    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(fileName);    String filePath = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">ContextClassLoader()</span>.get<span class="hljs-constructor">Resource(<span class="hljs-string">""</span>)</span>.get<span class="hljs-constructor">Path()</span> + <span class="hljs-string">"static/images/"</span>;    filePath = filePath + fileName;    File dest = <span class="hljs-keyword">new</span> <span class="hljs-constructor">File(<span class="hljs-params">filePath</span>)</span>;    return dest.delete<span class="hljs-literal">()</span> ? <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ResultMap</span>.</span></span>success<span class="hljs-literal">()</span> : <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ResultMap</span>.</span></span>failed<span class="hljs-literal">()</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>html插件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
      <tag>富文本编辑器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vim的使用</title>
    <link href="/blog/2018/12/19/vim%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/blog/2018/12/19/vim%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="vim介绍"><a href="#vim介绍" class="headerlink" title="vim介绍"></a>vim介绍</h2><p>Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。 </p><p>简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。 vim 则可以说是程序开发者的一项很好用的工具。 </p><p>连 vim 的官方网站 (<a href="http://www.vim.org/" target="_blank" rel="noopener">http://www.vim.org</a>) 自己也说 vim 是一个程序开发工具而不是文字处理软件。（这段是复制来的，不说点啥的话不好看）</p><h2 id="1-vim模式"><a href="#1-vim模式" class="headerlink" title="1. vim模式"></a>1. vim模式</h2><pre><code class="hljs text">正常模式（按Esc或Ctrl+[进入） 左下角显示文件名或为空插入模式（按i进入） 左下角显示--INSERT--可视模式（按v进入） 左下角显示--VISUAL--替换模式（按r或R开始） 左下角显示 --REPLACE--命令行模式（按:或者&#x2F;或者?开始）ex模式 没用过，有兴趣的同学可以自行了解</code></pre><h2 id="2-打开文件"><a href="#2-打开文件" class="headerlink" title="2. 打开文件"></a>2. 打开文件</h2><pre><code class="hljs text"># 打开单个文件vim file    # 同时打开多个文件vim file1 file2..  # 在vim窗口中打开一个新文件:open [file]       【举个例子】# 当前打开1.txt，做了一些编辑没保存:open!         放弃这些修改，并重新打开未修改的文件# 当前打开1.txt，做了一些编辑并保存:open 2.txt    直接退出对1.txt的编辑，直接打开2.txt编辑，省了退出:wq再重新vim 2.txt的步骤# 打开远程文件，比如ftp或者share folder:e ftp:&#x2F;&#x2F;192.168.10.76&#x2F;abc.txt:e \qadrive\test\1.txt# 以只读形式打开文件，但是仍然可以使用 :wq! 写入vim -R file # 强制性关闭修改功能，无法使用 :wq! 写入vim -M file</code></pre><h2 id="3-插入命令"><a href="#3-插入命令" class="headerlink" title="3. 插入命令"></a>3. 插入命令</h2><pre><code class="hljs text">i 在当前位置生前插入I 在当前行首插入a 在当前位置后插入A 在当前行尾插入o 在当前行之后插入一行O 在当前行之前插入一行</code></pre><h2 id="4-查找命令"><a href="#4-查找命令" class="headerlink" title="4. 查找命令"></a>4. 查找命令</h2><p>最简单的查找</p><pre><code class="hljs text">&#x2F;text　　查找text，按n健查找下一个，按N健查找前一个。?text　　查找text，反向查找，按n健查找下一个，按N健查找前一个。vim中有一些特殊字符在查找时需要转义　　.*[]^%&#x2F;?~$:set ignorecase　　忽略大小写的查找:set noignorecase　　不忽略大小写的查找</code></pre><p>快速查找，不需要手打字符即可查找</p><pre><code class="hljs text">*        向后（下）寻找游标所在处的单词#        向前（上）寻找游标所在处的单词以上两种查找，n,N 的继续查找命令依然可以适用</code></pre><p>精准查找：匹配单词查找</p><p>如果文本中有 <code>hello</code>，<code>helloworld</code>，<code>hellopython</code></p><p>那我使用 /hello ，这三个词都会匹配到。</p><p>有没有办法实现精准查找呢？可以使用</p><pre><code class="hljs text">&#x2F;hello\&gt;</code></pre><p>精准查找：匹配行首、行末</p><pre><code class="hljs text"># hello位于行首&#x2F;^hello# world位于行末&#x2F;world$</code></pre><h2 id="5-替换命令"><a href="#5-替换命令" class="headerlink" title="5. 替换命令"></a>5. 替换命令</h2><pre><code class="hljs text">~  反转游标字母大小写r&lt;字母&gt;           将当前字符替换为所写字母R&lt;字母&gt;&lt;字母&gt;...  连续替换字母cc    替换整行（就是删除当前行，并在下一行插入）cw    替换一个单词（就是删除一个单词，就进入插入模式），前提是游标处于单词第一个字母（可用b定位）C     (大写C)替换至行尾（和D有所区别，D是删除（剪切）至行尾，C是删除至行位并进入插入模式）:s&#x2F;old&#x2F;new&#x2F;    用old替换new，替换当前行的第一个匹配:s&#x2F;old&#x2F;new&#x2F;g   用old替换new，替换当前行的所有匹配:%s&#x2F;old&#x2F;new&#x2F;   用old替换new，替换所有行的第一个匹配:%s&#x2F;old&#x2F;new&#x2F;g  用old替换new，替换整个文件的所有匹配:10,20 s&#x2F;^&#x2F; &#x2F;g 在第10行至第20行每行前面加四个空格，用于缩进。ddp    交换光标所在行和其下紧邻的一行。</code></pre><h2 id="6-撤销与重做"><a href="#6-撤销与重做" class="headerlink" title="6. 撤销与重做"></a>6. 撤销与重做</h2><pre><code class="hljs text">u 撤销（Undo）U 撤销对整行的操作Ctrl + r 重做（Redo），即撤销的撤销。</code></pre><h2 id="7-删除命令"><a href="#7-删除命令" class="headerlink" title="7. 删除命令"></a>7. 删除命令</h2><p>需要说明的是，vim 其实并没有单纯的删除命令，下面你或许理解为剪切更加准确。</p><p>以字符为单位删除</p><pre><code class="hljs text">x   删除当前字符3x  删除当前字符3次X   删除当前字符的前一个字符。3X  删除当前光标向前三个字符dl  删除当前字符， dl&#x3D;xdh  删除前一个字符，X&#x3D;dhD   删除当前字符至行尾。D&#x3D;d$d$  删除当前字符至行尾d^  删除当前字符之前至行首</code></pre><p>以单词为单位删除</p><pre><code class="hljs text">dw  删除当前字符到单词尾daw 删除当前字符所在单词</code></pre><p>以行为单位删除</p><pre><code class="hljs text">dd  删除当前行dj  删除下一行dk  删除上一行dgg  删除当前行至文档首部d1G  删除当前行至文档首部dG   删除当前行至文档尾部kdgg  删除当前行之前所有行（不包括当前行）jdG   删除当前行之后所有行（不包括当前行）10d     删除当前行开始的10行。:1,10d  删除1-10行:11,$d  删除11行及以后所有的行:1,$d   删除所有行J　　   删除两行之间的空行，实际上是合并两行。</code></pre><h2 id="8-复制粘贴"><a href="#8-复制粘贴" class="headerlink" title="8. 复制粘贴"></a>8. 复制粘贴</h2><p>普通模式中使用y复制</p><pre><code class="hljs text">yy   复制游标所在的整行（3yy表示复制3行）y^   复制至行首，或y0。不含光标所在处字符。y$   复制至行尾。含光标所在处字符。yw   复制一个单词。y2w  复制两个单词。yG   复制至文本末。y1G  复制至文本开头。</code></pre><p>普通模式中使用p粘贴</p><pre><code class="hljs text">p(小写)：代表粘贴至光标后（下边，右边）P(大写)：代表粘贴至光标前（上边，左边）</code></pre><h2 id="9-剪切粘贴"><a href="#9-剪切粘贴" class="headerlink" title="9. 剪切粘贴"></a>9. 剪切粘贴</h2><pre><code class="hljs text">dd    其实就是剪切命令，剪切当前行ddp   剪切当前行并粘贴，可实现当前行和下一行调换位置正常模式下按v（逐字）或V（逐行）进入可视模式然后用jklh命令移动即可选择某些行或字符，再按d即可剪切ndd 剪切当前行之后的n行。利用p命令可以对剪切的内容进行粘贴:1,10d 将1-10行剪切。利用p命令可将剪切后的内容进行粘贴。:1, 10 m 20 将第1-10行移动到第20行之后。</code></pre><h2 id="10-退出保存"><a href="#10-退出保存" class="headerlink" title="10. 退出保存"></a>10. 退出保存</h2><pre><code class="hljs text">:wq 保存并退出ZZ 保存并退出:q! 强制退出并忽略所有更改:e! 放弃所有修改，并打开原来文件。ZZ 保存并退出:sav(eas) new.txt  另存为一个新文件，退出原文件的编辑且不会保存:f(ile) new.txt    新开一个文件，并不保存，退出原文件的编辑且不会保存</code></pre><h2 id="11-移动命令"><a href="#11-移动命令" class="headerlink" title="11. 移动命令"></a>11. 移动命令</h2><p>以字符为单位移动</p><pre><code class="hljs text">h   左移一个字符l   右移一个字符k   上移一个字符j   下移一个字符# 【定位字符】f和Ffx    找到光标后第一个为x的字符3fd   找到光标后第三个为d的字符F   同f，反向查找。</code></pre><p>以行为单位移动</p><pre><code class="hljs text"># 10指代所有数字，可任意指定10h  左移10个字符10l  右移10个字符10k  上移10行10j  下移10行$   移动到行尾 3$  移动到下面3行的行尾</code></pre><p>以单词为单位移动</p><pre><code class="hljs text">w  向前移动一个单词（光标停在单词首部）b  向后移动一个单词e，同w，只不过是光标停在单词尾部ge 同b，光标停在单词尾部。</code></pre><p>以句为单位移动</p><pre><code class="hljs text">(   移动到句首)   移动到句尾</code></pre><p>跳转到文件的首尾</p><pre><code class="hljs text">gg  移动到文件头。 &#x3D; [[  &#x3D;&#x3D; &#96;&#96;G   移动到文件尾。 &#x3D; ]]</code></pre><p>其他移动方法</p><pre><code class="hljs text">^   移动到本行第一个非空白字符上。0   移动到本行第一个字符上(可以是空格)</code></pre><p>使用 <code>具名标记</code> 跳转，个人感觉这个很好用，因为可以跨文件。</p><pre><code class="hljs text">使用 ma ，可以将此处标记为 a，使用 &#39;a 进行跳转使用 :marks 可以查看所有的标记使用 :delm！可以删除所有的标记</code></pre><p>当在查看错误日志时，正常的步骤是，vim打开文件，然后使用 <code>shift+g</code> 再跳转到最后一行，这里有个更简单的操作可以在打开文件时立即跳到最后一行。只要在 vim 和 文件 中间加个 <code>+</code>即可。</p><pre><code class="hljs text">vim + you.log</code></pre><p>举一反三，当你想打开文件立即跳转到指定行时，可以这样</p><pre><code class="hljs text"># 打开文件并跳转到 20 行vim you.log +20</code></pre><p>当你使用 <code>/</code> 搜索定位跳转或者使用 <code>:行号</code> 进行精准跳转时，有时我们想返回到上一次的位置，如何实现？</p><p>只要使用 Ctrl+o 即可返回上一次的位置。</p><h2 id="12-排版功能"><a href="#12-排版功能" class="headerlink" title="12. 排版功能"></a>12. 排版功能</h2><p><strong>缩进</strong></p><pre><code class="hljs text">:set shiftwidth?   查看缩进值:set shiftwidth&#x3D;4  设置缩进值为4# 缩进相关 最好写到配置文件中  ~&#x2F;.vimrc:set tabstop&#x3D;4:set softtabstop&#x3D;4:set shiftwidth&#x3D;4:set expandtab&gt;&gt;   向右缩进&lt;&lt;   取消缩进</code></pre><p>如何你要对代码进行缩进，还可以用 <code>==</code> 对当前行缩进，如果要对多行对待缩进，则使用 n<code>==</code>，这种方式要求你所编辑的文件的扩展名是被vim所识别的，比如<code>.py</code>文件。</p><p><strong>排版</strong></p><pre><code class="hljs text">:ce   居中:le   靠左:ri   靠右</code></pre><h2 id="13-注释命令"><a href="#13-注释命令" class="headerlink" title="13. 注释命令"></a>13. 注释命令</h2><p><strong>多行注释</strong></p><pre><code class="hljs text">进入命令行模式，按ctrl + v进入 visual block模式，然后按j, 或者k选中多行，把需要注释的行标记起来按大写字母I，再插入注释符，例如&#x2F;&#x2F;按esc键就会全部注释了</code></pre><p><strong>取消多行注释</strong></p><pre><code class="hljs text">进入命令行模式，按ctrl + v进入 visual block模式，按字母l横向选中列的个数，例如 &#x2F;&#x2F; 需要选中2列按字母j，或者k选中注释符号按d键就可全部取消注释</code></pre><p><strong>复杂注释</strong></p><pre><code class="hljs text">:3,5 s&#x2F;^&#x2F;#&#x2F;g 注释第3-5行:3,5 s&#x2F;^#&#x2F;&#x2F;g 解除3-5行的注释:1,$ s&#x2F;^&#x2F;#&#x2F;g 注释整个文档:1,$ s&#x2F;^#&#x2F;&#x2F;g 取消注释整个文档:%s&#x2F;^&#x2F;#&#x2F;g 注释整个文档，此法更快:%s&#x2F;^#&#x2F;&#x2F;g 取消注释整个文档</code></pre><h2 id="14-调整视野"><a href="#14-调整视野" class="headerlink" title="14. 调整视野"></a>14. 调整视野</h2><pre><code class="hljs text">&quot;zz&quot;：命令会把当前行置为屏幕正中央，&quot;zt&quot;：命令会把当前行置于屏幕顶端&quot;zb&quot;：则把当前行置于屏幕底端.Ctrl + e 向下滚动一行Ctrl + y 向上滚动一行Ctrl + d 向下滚动半屏Ctrl + u 向上滚动半屏Ctrl + f 向下滚动一屏Ctrl + b 向上滚动一屏【跳到指定行】：两种方法可以先把行号打开:set nu  打开行号:20    跳到第20行20G    跳到第20行</code></pre><h2 id="15-区域选择"><a href="#15-区域选择" class="headerlink" title="15. 区域选择"></a>15. 区域选择</h2><pre><code class="hljs text">要进行区域选择，要先进入可视模式v   以字符为单位，上下左右选择V   以行为单位，上下选择选择后可进行操作d   剪切&#x2F;删除y   复制Ctrl+v   如果当前是V(大写)模式，就变成v(小写)         如果当前是v(小写)模式，就变成普通模式。         如果当前是普通模式，就进入v(小写)模式利用这个，可以进行多行缩进。ggVG   选择全文</code></pre><h2 id="16-窗口控制"><a href="#16-窗口控制" class="headerlink" title="16. 窗口控制"></a>16. 窗口控制</h2><p><strong>新建窗口</strong></p><pre><code class="hljs text"># 打开两个文件分属两个窗口vim -o 1.txt 2.txt# 假设现在已经打开了1.txt:sp 2.txt   开启一个横向的窗口，编辑2.txt:vsp 2.txt  开启一个竖向的窗口，编辑2.txt:split        将当前窗口再复制一个窗口出来，内容同步，游标可以不同:split 2.txt  在新窗口打开2.txt的横向窗口# 需要注意：内容同步，但是游标位置是独立的Ctrl-w s    将当前窗口分成水平窗口Ctrl-w v    将当前窗口分成竖直窗口Ctrl-w q    等同:q 结束分割出来的视窗。Ctrl-w q!   等同:q! 结束分割出来的视窗。Ctrl-w o    打开一个视窗并且隐藏之前的所有视窗</code></pre><p><strong>窗口切换</strong></p><pre><code class="hljs text"># 特别说明：Ctrl w &lt;字母&gt; 不需要同时按Ctrl-w h    切换到左边窗口Ctrl-w l    切换到右边窗口Ctrl-w j    切换到下边窗口Ctrl-w k    切换到上边窗口# 特别说明：全屏模式下:n    切换下一个窗口:N    切换上一个窗口:bp   切换上一个窗口# 特别说明：非全屏模式:bn    切换下一个窗口，就当前位置的窗口的内容变了，其他窗口不变:bN    切换上一个窗口，就当前位置的窗口的内容变了，其他窗口不变</code></pre><p><strong>窗口移动</strong></p><pre><code class="hljs text"># 特别说明：Ctrl w &lt;字母&gt; 不需要同时按Ctrl-w J   将当前视窗移至最下面Ctrl-w K   将当前视窗移最上面Ctrl-w H   将当前视窗移至最左边Ctrl-w L   将当前视窗移至最右边Ctrl-ww    按顺序切换窗口</code></pre><p><strong>调整尺寸</strong></p><pre><code class="hljs text"># 友情提示：键盘切记不要处于中文状态Ctrl-w +   增加窗口高度Ctrl-w -   减少窗口高度</code></pre><p><strong>退出窗口</strong></p><pre><code class="hljs text">:close    关闭当前窗口:close!   强制关闭当前窗口:q       退出，不保存:q!      强制退出，不保存:x       保存退出:wq      保存退出:wq!     强制保存退出:w &lt;[路径&#x2F;]文件名&gt;        另存为:savesa &lt;[路径&#x2F;]文件名&gt;   另存为ZZ 保存并退出。:only    关闭所有窗口，只保留当前窗口(前提：其他窗口内容有改变的话都要先保存):only!   关闭所有窗口，只保留当前窗口:qall 放弃所有操作并退出:wall 保存所有，:wqall 保存所有并退出。</code></pre><h2 id="17-文档加密"><a href="#17-文档加密" class="headerlink" title="17. 文档加密"></a>17. 文档加密</h2><pre><code class="hljs text">vim -x file_name然后输入密码：确认密码：如果不修改内容也要保存。:wq，不然密码设定不会生效。</code></pre><h2 id="18-录制宏"><a href="#18-录制宏" class="headerlink" title="18. 录制宏"></a>18. 录制宏</h2><p>按q键加任意字母开始录制，再按q键结束录制（这意味着vim中的宏不可嵌套），使用的时候@加宏名，比如qa。。。q录制名为a的宏，@a使用这个宏。</p><h2 id="19-执行命令"><a href="#19-执行命令" class="headerlink" title="19. 执行命令"></a>19. 执行命令</h2><pre><code class="hljs text"># 重复前一次命令. # 执行shell命令:!command# 比如列出当前目录下文件:!ls # 执行脚本:!perl -c script.pl 检查perl脚本语法，可以不用退出vim，非常方便。:!perl script.pl 执行perl脚本，可以不用退出vim，非常方便。:suspend或Ctrl - Z 挂起vim，回到shell，按fg可以返回vim。</code></pre><h2 id="20-帮助命令"><a href="#20-帮助命令" class="headerlink" title="20. 帮助命令"></a>20. 帮助命令</h2><pre><code class="hljs text">在Unix&#x2F;Linux系统上$ vimtutor# 普通模式下键盘输入vim或F1# 命令行模式下:help     显示整个帮助:help xxx 显示xxx的帮助，比如 :help i, :help CTRL-[（即Ctrl+[的帮助）。:help &#39;number&#39; Vim选项的帮助用单引号括起在Windows系统上:help tutor</code></pre><h2 id="21-配置命令"><a href="#21-配置命令" class="headerlink" title="21. 配置命令"></a>21. 配置命令</h2><p>显示当前设定</p><pre><code class="hljs text">:set或者:se显示所有修改过的配置:set all 显示所有的设定值:set option? 显示option的设定值:set nooption 取消当期设定值:ver   显示vim的所有信息（包括版本和参数等）# 需要注意：全屏模式下:args   查看当前打开的文件列表，当前正在编辑的文件会用[]括起来</code></pre><p>更改设定</p><pre><code class="hljs text">:set nu   显示行号set autoindent(ai)   设置自动缩进set autowrite(aw)    设置自动存档，默认未打开set backup(bk) 设置自动备份，默认未打开set background&#x3D;dark或light，设置背景风格set cindent(cin) 设置C语言风格缩进:set ts&#x3D;4   设置tab键转换为4个空格:set ff&#x3D;unix   # 修改文件dos文件为unix:set shiftwidth?   查看缩进值:set shiftwidth&#x3D;4  设置缩进值为4:set ignorecase　　忽略大小写的查找:set noignorecase　　不忽略大小写的查找:set paste  # insert模式下，粘贴格式不会乱掉:set ruler?　　查看是否设置了ruler，在.vimrc中，使用set命令设制的选项都可以通过这个命令查看:scriptnames　　查看vim脚本文件的位置，比如.vimrc文件，语法文件及plugin等。:set list 显示非打印字符，如tab，空格，行尾等。如果tab无法显示，请确定用set lcs&#x3D;tab:&gt;-命令设置了.vimrc文件，并确保你的文件中的确有tab，如果开启了expendtab，那么tab将被扩展为空格。:syntax        列出已经定义的语法项:syntax clear  清除已定义的语法规则:syntax case match    大小写敏感，int和Int将视为不同的语法元素:syntax case ignore   大小写无关，int和Int将视为相同的语法元素，并使用同样的配色方案</code></pre><img src="/blog/2018/12/19/vim%E7%9A%84%E4%BD%BF%E7%94%A8/pic1.png" srcset="/blog/img/loading.gif" class><img src="/blog/2018/12/19/vim%E7%9A%84%E4%BD%BF%E7%94%A8/pic2.png" srcset="/blog/img/loading.gif" class><img src="/blog/2018/12/19/vim%E7%9A%84%E4%BD%BF%E7%94%A8/pic3.png" srcset="/blog/img/loading.gif" class><img src="/blog/2018/12/19/vim%E7%9A%84%E4%BD%BF%E7%94%A8/pic4.png" srcset="/blog/img/loading.gif" class>]]></content>
    
    
    <categories>
      
      <category>快速开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
