<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Tomcat性能优化</title>
    <link href="undefined2020/01/10/tomcat%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <url>2020/01/10/tomcat%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="Tomcat内存优化"><a href="#Tomcat内存优化" class="headerlink" title="Tomcat内存优化"></a>Tomcat内存优化</h2><p>tomcat默认参数是为开发环境制定，而非适合生产环境，尤其是内存和线程的配置，默认都很低，容易成为性能瓶颈。</p><p>TOMCAT_HOME/bin/catalina.sh，在前面加入</p><pre><code>JAVA_OPTS=&quot;-XX:PermSize=64M -XX:MaxPermSize=128m -Xms512m -Xmx1024m -Duser.timezone=Asia/Shanghai&quot;</code></pre><p>此设置将最大堆内存改为1024m，实际调整时还是按照服务器的具体配置优化。</p><ul><li>JVM初始化堆大小：Xms</li><li>JVM堆的最大值：Xmx</li><li>JVM初始分配的非堆内存：PermSize</li><li>JVM最大允许分配的非堆内存：MaxPermSize</li></ul><h2 id="Tomcat线程优化"><a href="#Tomcat线程优化" class="headerlink" title="Tomcat线程优化"></a>Tomcat线程优化</h2><p>在TOMCAT_HOME/conf/server.xml中设置</p><pre><code>&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; maxThreads=&quot;600&quot; minSpareThreads=&quot;100&quot; maxSpareThreads=&quot;500&quot; acceptCount=&quot;700&quot;connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt;</code></pre><ul><li>maxThreads：最大线程数</li><li>minSpareThreads：最小空闲线程数（tomcat初始化时创建的线程数）</li><li>maxSpareThreads：最大空闲线程数（超过这个值之后，tomcat会关闭多余的socket线程）</li><li>acceptCount：等待队列长度。超过这个数的请求将不予处理，http请求将返回502状态码</li></ul><p>如果使用apache和tomcat做集群的负载均衡，并且使用ajp协议做apache和tomcat的协议转发，那么还需要优化ajp connector。</p><pre><code>&lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; maxThreads=&quot;600&quot; minSpareThreads=&quot;100&quot; maxSpareThreads=&quot;500&quot; acceptCount=&quot;700&quot;connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt;</code></pre><p>由于tomcat有多个connector，所以tomcat线程的配置可以支持多个connector共享一个线程池。</p><pre><code>&lt;Executor name=&quot;tomcatThreadPool&quot; namePrefix=&quot;catalina-exec-&quot; maxThreads=&quot;500&quot; minSpareThreads=&quot;20&quot; maxIdleTime=&quot;60000&quot; /&gt;</code></pre><p>修改Connector节点，增加executor属性设置为线程池的名字</p><pre><code>&lt;Connector executor=&quot;tomcatThreadPool&quot; port=&quot;80&quot; protocol=&quot;HTTP/1.1&quot;  connectionTimeout=&quot;60000&quot; keepAliveTimeout=&quot;15000&quot; maxKeepAliveRequests=&quot;1&quot;  redirectPort=&quot;443&quot; /&gt;</code></pre><p>可以多个connector公用1个线程池，所以ajp connector也同样可以设置使用tomcatThreadPool线程池。</p><h2 id="Tomcat的连接器优化"><a href="#Tomcat的连接器优化" class="headerlink" title="Tomcat的连接器优化"></a>Tomcat的连接器优化</h2><p>Tomcat Connector(Tomcat连接器)有bio、nio、apr三种运行模式</p><h3 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h3><p>bio（blocking I/O，阻塞式I/O操作），表示Tomcat使用的是传统的Java I/O操作(即java.io包及其子包)。<br><strong>默认的模式，性能最差，没有经过任何优化处理和支持。</strong></p><h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><p>nio(non-blocking I/O，非阻塞式I/O操作)，也被看成是<code>non-blocking I/O</code>的缩写，是Java SE 1.4及后续版本提供的一种新的I/O操作方式(即java.nio包及其子包)。Java nio是一个基于缓冲区、并能提供非阻塞I/O操作的Java API。拥有比传统I/O操作(bio)更好的并发运行性能。 tomcat在8.0之后已经将nio作为默认运行模式，在8.0之前要让tomcat以nio方式来运行也比较简单，只需要修改tomcat目录下的/conf/servcer.xml中的protocol设置为<code>org.apache.coyote.http11.Http11NioProtocol</code>即可</p><pre><code>&lt;Connector port=&quot;8080&quot; protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot;connectionTimeout=&quot;20000&quot;redirectPort=&quot;8443&quot; /&gt;</code></pre><p>点击tomcat管理页面的server status之后就可以看到当前的运行模式</p><img src="/2020/01/10/tomcat%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/pic1.png" srcset="/img/loading.gif" class=""><h3 id="APR"><a href="#APR" class="headerlink" title="APR"></a>APR</h3><p>apr(Apache Portable Runtime/Apache可移植运行时库)，Tomcat将以JNI(Java Native Interface)的形式调用Apache HTTP服务器的核心动态链接库来处理文件读取或网络传输操作，从而大大地提高Tomcat对静态文件的处理性能。使用操作系统的部分本地操作，解决异步的IO问题，大幅度的提高性能。 Tomcat apr也是在Tomcat上运行高并发应用的首选模式。</p><p>Tomcat apr运行模式的配置是三种运行模式之中相对比较麻烦的一种。据官方文档所述，Tomcat apr需要以下三个组件的支持：</p><ul><li>APR library[APR库]</li><li>JNI wrappers for APR used by Tomcat (libtcnative)[简单地说，如果是在Windows操作系统上，就是一个名为tcnative-1.dll的动态链接库文件]</li><li>OpenSSL libraries[OpenSSL库]</li></ul><h3 id="centos7下tomcat8开启APR步骤"><a href="#centos7下tomcat8开启APR步骤" class="headerlink" title="centos7下tomcat8开启APR步骤"></a>centos7下tomcat8开启APR步骤</h3><ol><li>下载APR组件依赖</li></ol><img src="/2020/01/10/tomcat%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/pic2.png" srcset="/img/loading.gif" class=""><ol start="2"><li>安装apr</li></ol><pre><code>tar zxvf apr-1.6.5.tar.gzcd apr-1.6.5./configure --prefix=/usr/local/aprmake &amp;&amp; make install</code></pre><ol start="3"><li>安装apr-iconv</li></ol><pre><code>tar zxvf apr-iconv.1.2.2.tar.gzcd apr-iconv-1.2.2./configure --prefix=/usr/local/apr-iconv --with-apr=/usr/local/aprmake &amp;&amp; make install</code></pre><ol start="4"><li>安装apr-util</li></ol><pre><code>tar zxvf apr-util.1.6.1.tar.gzcd apr-util-1.6.1./configure --prefix=/usr/local/apr-util --with-apr=/usr/local/apr --with-apr-iconv=/usr/local/apr-iconv/bin/apriconvmake &amp;&amp; make install</code></pre><ol start="5"><li>安装tomcat的bin目录下的tomcat-native-1.2.21-src.tar.gz</li></ol><pre><code>tar zxf tomcat-native-1.2.21-src.tar.gzcd tomcat-native-1.2.21cd native./configure --with-apr=/usr/local/apr --with-java-home=/usr/java/jdk1.8.0_65make &amp;&amp; make install</code></pre><ol start="6"><li>在tomcat的bin目录下的catalina.sh的最后一行添加变量</li></ol><pre><code>JAVA_OPTS=”$JAVA_OPTS -Djava.library.path=/usr/local/apr/lib”</code></pre><ol start="7"><li>重启tomcat启动日志中出现以下内容证明APR模式启动</li></ol><pre><code>10-Jan-2020 17:23:29.744 信息 [main] org.apache.coyote.AbstractProtocol.init Initializing ProtocolHandler [&quot;http-apr-9080&quot;]</code></pre><p>同理，通过tomcat的启动日志也可以判断出其运行状态</p><ul><li>bio</li></ul><pre><code>INFO: Initializing ProtocolHandler [&quot;http-bio-8080&quot;]Aug 04, 2015 10:20:35 PM org.apache.coyote.AbstractProtocol init</code></pre><ul><li>nio</li></ul><pre><code>INFO: Initializing ProtocolHandler [&quot;http-nio-8080&quot;]Aug 04, 2015 10:27:58 PM org.apache.coyote.AbstractProtocol init</code></pre><ul><li>apr</li></ul><pre><code>INFO: Initializing ProtocolHandler [&quot;http-apr-8080&quot;]Aug 04, 2015 10:33:45 PM org.apache.coyote.AbstractProtocol init</code></pre><h2 id="禁用DNS查询"><a href="#禁用DNS查询" class="headerlink" title="禁用DNS查询"></a>禁用DNS查询</h2><p>当web应用程序向要记录客户端的信息时，它也会记录客户端的IP地址或者通过域名服务器查找机器名 转换为IP地址。</p><p>DNS查询需要占用网络，并且包括可能从很多很远的服务器或者不起作用的服务器上去获取对应的IP的过程，这样会消耗一定的时间。</p><p>修改server.xml文件中的Connector元素，修改属性enableLookups参数值: enableLookups=”false”</p><p>如果为true，则可以通过调用request.getRemoteHost()进行DNS查询来得到远程客户端的实际主机名，若为false则不进行DNS查询，而是返回其ip地址</p><h2 id="设置session过期时间"><a href="#设置session过期时间" class="headerlink" title="设置session过期时间"></a>设置session过期时间</h2><p>在tomcat目录下的conf\web.xml中通过参数指定，单位为分钟。</p><pre><code>&lt;session-config&gt;       &lt;session-timeout&gt;180&lt;/session-timeout&gt;     &lt;/session-config&gt;</code></pre><h2 id="Maven项目远程部署到Tomcat"><a href="#Maven项目远程部署到Tomcat" class="headerlink" title="Maven项目远程部署到Tomcat"></a>Maven项目远程部署到Tomcat</h2><p>其实本节内容并不属于tomcat性能调优，但内容较少不足以再开一篇文章，凑合凑合塞到这吧。</p><ol><li>在tomcat根目录下的/conf/tomcat-users.xml添加用户</li></ol><pre><code>&lt;tomcat-users version=&quot;1.0&quot; xmlns=&quot;http://tomcat.apache.org/xml&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://tomcat.apache.org/xml tomcat-users.xsd&quot;&gt;&lt;role rolename=&quot;manager-gui&quot; /&gt;&lt;role rolename=&quot;manager-script&quot; /&gt;&lt;role rolename=&quot;admin-gui&quot; /&gt;&lt;role rolename=&quot;admin-script&quot; /&gt;&lt;user username=&quot;admin&quot; password=&quot;tomcat&quot; roles=&quot;manager-gui,manager-script,admin-gui,admin-script&quot; /&gt;&lt;/tomcat-users&gt;</code></pre><ol start="2"><li>pom文件中加入maven插件</li></ol><pre><code>&lt;plugin&gt;    &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;    &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;    &lt;version&gt;2.2&lt;/version&gt;    &lt;configuration&gt;        &lt;charset&gt;utf-8&lt;/charset&gt;        &lt;update&gt;true&lt;/update&gt;        &lt;url&gt;http://192.168.0.13:9080/manager/text&lt;/url&gt;        &lt;mode&gt;war&lt;/mode&gt;        &lt;username&gt;admin&lt;/username&gt;        &lt;password&gt;tomcat&lt;/password&gt;        &lt;path&gt;/MintelJunior&lt;/path&gt;    &lt;/configuration&gt;&lt;/plugin&gt;</code></pre><p>tomcat7-maven-plugin是很久以前的插件版本，默认支持到Tomcat7，但是对于目前最新的Tomcat9同样可以使用该插件</p><p>官方介绍文档为：<code>http://tomcat.apache.org/maven-plugin-2.1/index.html</code></p><p>参数说明：</p><p>以下参数必选，但是可以在pom中空缺，空缺时将采用默认值</p><table><thead><tr><th>名称</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td>charset</td><td>在与Tomcat Manager通信是的URL编 码字符集</td><td>ISO-8859-1</td></tr><tr><td>mode</td><td>部署的模式，值可为：war,context,both</td><td>war</td></tr><tr><td>path</td><td>应用程序运行的上下文路径，必须以’/‘开始</td><td>/${project.artifactId}</td></tr><tr><td>update</td><td>当部署已存在的应用时，是否自动 undeploy该应用</td><td>false</td></tr><tr><td>url</td><td>Tomcat Manager实例使用的全路径</td><td>tomcat的根路径/manager/text</td></tr><tr><td>warFile</td><td>部署warFile的路径</td><td>${project.build.directory} ${project.build.finalName}.war</td></tr></tbody></table><p>对于个性化的需求，tomcat7插件提供了可配置的参数</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>contextFile</td><td>Tomcat的context的XML路径，对于mode=war不适用，默认为 ${project.build.directory}/${project.build.finalName}/ META-INF/context.xml</td></tr><tr><td>ignorePackaging</td><td>如果设置为true，忽略类型不是war的项目</td></tr><tr><td>username</td><td>部署到Tomcat的username</td></tr><tr><td>password</td><td>部署到Tomcat的password</td></tr><tr><td>server</td><td>指定Maven的setting.xml中配置的server id用于Tomcat认证</td></tr><tr><td>tag</td><td>应用程序在Tomcat中使用的标签的名字</td></tr></tbody></table><p>还可以在maven目录中的conf/setting.xml中添加tomcat的用户名和密码</p><pre><code>&lt;servers&gt;    &lt;server&gt;        &lt;id&gt;tomcatServer&lt;/id&gt;        &lt;username&gt;username&lt;/username&gt;        &lt;password&gt;password&lt;/password&gt;    &lt;/server&gt;&lt;/servers&gt;</code></pre><p>之后在pom文件中指定server的id即可，不在需要用户名密码</p><pre><code>&lt;plugin&gt;    &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;    &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;    &lt;version&gt;2.2&lt;/version&gt;    &lt;configuration&gt;        &lt;url&gt;http://{yourIP}:8080/manager/text&lt;/url&gt;        &lt;server&gt;tomcatServer&lt;/server&gt;        &lt;update&gt;true&lt;/update&gt;        &lt;path&gt;/${project.artifactId}&lt;/path&gt;    &lt;/configuration&gt;        &lt;/plugin&gt;</code></pre><ol start="3"><li>idea部署项目</li></ol><p>idea可以直接在右侧边栏中的plugins中找到tomcat7，第一次部署时选择deploy之后选择redeploy就可以了</p><p>mvn命令</p><pre><code>mvn tomcat7:deploymvn tomcat7:redeploymvn tomcat7:undeploy</code></pre>]]></content>
    
    
    <categories>
      
      <category>性能优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tomcat</tag>
      
      <tag>性能优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发容器</title>
    <link href="undefined2020/01/06/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/"/>
    <url>2020/01/06/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="Hash算法"><a href="#Hash算法" class="headerlink" title="Hash算法"></a>Hash算法</h2><p>Hash一般译做“散列”，就是把任意长度的输入（又叫做预映射， pre-image），通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来确定唯一的输入值（不可逆）。简单的说Hash算法就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。因为其不可逆的特性，Hash算法也可以用来作为加密算法。</p><img src="/2020/01/06/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/pic1.png" srcset="/img/loading.gif" class=""><p>处理冲突方法:</p><ol><li>开放寻址法：出现hash冲突时，从当前地址向后寻找</li><li>再散列法：出现hash冲突时，再次进行hash运算</li><li>链地址法(拉链法)：将有hash冲突的元素存储在链表或其他数据结构中</li></ol><p>常用hash算法的介绍：</p><ol><li>MD4 </li><li>MD5（常被用为加密算法）</li><li>SHA-1及其他。</li></ol><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><h3 id="常用位运算"><a href="#常用位运算" class="headerlink" title="常用位运算"></a>常用位运算</h3><ul><li><p>位与 &amp; (1&amp;1=1 0&amp;0=0 1&amp;0=0)</p></li><li><p>位或 | (1|1=1 0|0=0 1|0=1)</p></li><li><p>位非 <del>(</del>1=0 ~0=1)</p></li><li><p>位异或 ^ (1^1=0 1^0=1 0^0=0)</p></li><li><p>有符号右移&gt;&gt;(若正数,高位补0,负数,高位补1)</p></li><li><p>有符号左移&lt;&lt;(低位补0)</p></li><li><p>无符号右移&gt;&gt;&gt;(不论正负,高位均补0)</p></li></ul><p>有趣的取模性质：取模a % (2^n) 等价于 a &amp; (2^n - 1)，所以在map里的数组个数一定是2的乘方数，计算key值在哪个元素中的时候，就用位运算来快速定位。</p><pre><code>public class IntToBinary {    public static void main(String[] args) throws UnsupportedEncodingException {        System.out.println(&quot;the 4 is : &quot; + Integer.toBinaryString(4));        System.out.println(&quot;the 6 is : &quot; + Integer.toBinaryString(6));        //位与&amp;(真真为真 真假为假 假假为假)        System.out.println(&quot;the 4&amp;6 is : &quot; + Integer.toBinaryString(6&amp;4));        //位或|(真真为真 真假为真 假假为假)        System.out.println(&quot;the 4|6 is : &quot; + Integer.toBinaryString(6|4));        //位非~        System.out.println(&quot;the ~4 is : &quot; + Integer.toBinaryString(~4));        //位异或^(真真为假 真假为真 假假为假)        System.out.println(&quot;the 4^6 is : &quot; + Integer.toBinaryString(6^4));        //有符号右移&gt;&gt;(若正数,高位补0,负数,高位补1)        System.out.println(&quot;the 4&gt;&gt;1 is : &quot; + Integer.toBinaryString(4&gt;&gt;1));        //有符号左移&lt;&lt;(若正数,高位补0,负数,高位补1)        System.out.println(&quot;the 4&lt;&lt;1 is : &quot; + Integer.toBinaryString(4&lt;&lt;1));        //无符号右移&gt;&gt;&gt;(不论正负,高位均补0)        System.out.println(&quot;the 234567 is : &quot; + Integer.toBinaryString(234567));        System.out.println(&quot;the 234567&gt;&gt;&gt;4 is : &quot; + Integer.toBinaryString(234567&gt;&gt;&gt;4));        //无符号右移&gt;&gt;&gt;(不论正负,高位均补0)        System.out.println(&quot;the -4 is : &quot; + Integer.toBinaryString(-4));        System.out.println(&quot;the -4&gt;&gt;&gt;4 is : &quot; + Integer.toBinaryString(-4&gt;&gt;&gt;4));        System.out.println(Integer.parseInt(Integer.toBinaryString(-4&gt;&gt;&gt;4), 2));        //取模a % (2^n) 等价于 a &amp; (2^n - 1)         System.out.println(&quot;the 345 % 16 is : &quot; + (345%16)+&quot; or &quot;+(345&amp;(16-1)));        System.out.println(&quot;Mark hashCode is : &quot;+&quot;Mark&quot;.hashCode()+&quot;=&quot;              +Integer.toBinaryString(&quot;Mark&quot;.hashCode()));        System.out.println(&quot;Bill hashCode is : &quot;+&quot;Bill&quot;.hashCode()+&quot;=&quot;              +Integer.toBinaryString(&quot;Bill&quot;.hashCode()));            } }</code></pre><h3 id="位运算运用场景"><a href="#位运算运用场景" class="headerlink" title="位运算运用场景"></a>位运算运用场景</h3><ul><li><p>Java中的类修饰符、成员变量修饰符、方法修饰符，比如Class类中</p></li><li><p>Java容器中的HashMap和ConcurrentHashMap的实现</p></li><li><p>权限控制或者商品属性</p></li><li><p>简单可逆加密，比如异或运算(1^1=0 ; 0^1=1 )</p></li></ul><p>实战：权限控制</p><pre><code>public class Permission {    private static final int ALLOW_SELECT = 1 &lt;&lt; 0;    private static final int ALLOW_INSERT = 1 &lt;&lt; 1;    private static final int ALLOW_UPDATE = 1 &lt;&lt; 2;    private static final int ALLOW_DELETE = 1 &lt;&lt; 3;    // 当前状态    private int flag;    public void setPermission(int permission) {        this.flag = permission;    }    // 增加权限，可以一项或者多项    public void addPermission(int permission) {        this.flag = flag | permission;    }    // 删除权限，可以一项或者多项    public void disablePermission(int permission) {        this.flag = flag &amp; ~permission;    }    // 是否拥有权限    public boolean isAllow(int permission) {        return (this.flag &amp; permission) == permission;    }    // 是否不拥有权限    public boolean isNotAllow(int permission) {        return (this.flag &amp; permission) == 0;    }    public static void main(String[] args) {      int flag = 15;      Permission permission = new Permission();      permission.setPermission(flag);      permission.disablePermission(ALLOW_DELETE|ALLOW_INSERT);      System.out.println(&quot;ALLOW_SELECT=&quot;+permission.isAllow(ALLOW_SELECT));      System.out.println(&quot;ALLOW_INSERT=&quot;+permission.isAllow(ALLOW_INSERT));      System.out.println(&quot;ALLOW_UPDATE=&quot;+permission.isAllow(ALLOW_UPDATE));      System.out.println(&quot;ALLOW_DELETE=&quot;+permission.isAllow(ALLOW_DELETE));    }</code></pre><p>使用位运算的优劣势：</p><p>节省很多代码量、效率高、属性变动影响小、不直观</p><h2 id="JDK1-7中HashMap死循环分析"><a href="#JDK1-7中HashMap死循环分析" class="headerlink" title="JDK1.7中HashMap死循环分析"></a>JDK1.7中HashMap死循环分析</h2><p>在多线程环境下，HashMap在并发执行put操作时会导致HashMap的Entry链表形成环形数据结构，一旦形成环形数据结构，Entry的next节点永远不为空，就会产生死循环获取Entry，导致CPU利用率接近100%。</p><h3 id="HashMap扩容流程"><a href="#HashMap扩容流程" class="headerlink" title="HashMap扩容流程"></a>HashMap扩容流程</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>正常的扩容操作是这个流程。HashMap的扩容在put操作中会触发扩容，主要是三个方法：</p><img src="/2020/01/06/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/pic2.png" srcset="/img/loading.gif" class=""><p>综合来说，HashMap一次扩容的过程：</p><ol><li><p>取当前table的2倍作为新table的大小</p></li><li><p>根据算出的新table的大小new出一个新的Entry数组来，名为newTable</p></li><li><p>轮询原table的每一个位置，将每个位置上连接的Entry，算出在新table上的位置，并以链表形式连接</p></li><li><p>原table上的所有Entry全部轮询完毕之后，意味着原table上面的所有Entry已经移到了新的table上，HashMap中的table指向newTable</p></li></ol><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>现在hashmap中有三个元素，key分别为3、7、5，Hash表的size=2, 通过hash计算后这三个元素都将分配到table[1]。</p><img src="/2020/01/06/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/pic3.png" srcset="/img/loading.gif" class=""><p>按照方法中的代码</p><img src="/2020/01/06/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/pic4.png" srcset="/img/loading.gif" class=""><p>对table[1]中的链表来说，进入while循环，此时e=key(3)，那么next=key(7)，经过计算重新定位e=key(3)在新表中的位置，并把e=key(3)分配newTable[3]的位置</p><img src="/2020/01/06/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/pic5.png" srcset="/img/loading.gif" class=""><p>这样循环下去，将table[1]中的链表循环完成后，于是HashMap就完成了扩容</p><img src="/2020/01/06/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/pic6.png" srcset="/img/loading.gif" class=""><img src="/2020/01/06/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/pic7.png" srcset="/img/loading.gif" class=""><p>HashMap在hash冲突插入元素时采用的是头插法，先将新的元素的next指向当前table[i]，之后再将table[i]指向当前元素</p><img src="/2020/01/06/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/pic8.png" srcset="/img/loading.gif" class=""><h3 id="并发下的扩容"><a href="#并发下的扩容" class="headerlink" title="并发下的扩容"></a>并发下的扩容</h3><p>初始的HashMap还是：</p><img src="/2020/01/06/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/pic9.png" srcset="/img/loading.gif" class=""><p>现在假设有两个线程并发操作，都进入了扩容操作线程1执行到Entry&lt;K,V&gt; next = e.next;时被操作系统调度挂起了，而线程2执行完成了扩容操作:</p><img src="/2020/01/06/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/pic10.png" srcset="/img/loading.gif" class=""><p>于是，在线程1,2看来，就应该是这个样子</p><img src="/2020/01/06/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/pic11.png" srcset="/img/loading.gif" class=""><p>接下来，线程1被调度回来执行： </p><ol><li><img src="/2020/01/06/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/pic12.png" srcset="/img/loading.gif" class=""></li><li><img src="/2020/01/06/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/pic13.png" srcset="/img/loading.gif" class=""></li><li><img src="/2020/01/06/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/pic14.png" srcset="/img/loading.gif" class=""></li><li><img src="/2020/01/06/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/pic15.png" srcset="/img/loading.gif" class=""></li><li><img src="/2020/01/06/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/pic16.png" srcset="/img/loading.gif" class=""></li><li><img src="/2020/01/06/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/pic17.png" srcset="/img/loading.gif" class=""></li><li><img src="/2020/01/06/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/pic18.png" srcset="/img/loading.gif" class=""></li></ol><p>循环列表产生后，一旦线程1调用get（11,15之类的元素）时，就会进入一个死循环的情况，将CPU的消耗到100%。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>HashMap之所以在并发下的扩容造成死循环，是因为多个线程并发进行时，一个线程先期完成了扩容，将原Map的链表重新散列到自己的表中，并将链表变成了倒序，后一个线程再扩容时，又进行自己的散列，再次将倒序链表变为正序链表，于是形成了一个环形链表，当get表中不存在的元素时，会去遍历链表造成死循环。</p><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>除了Map系列应该有的线程安全的get，put等方法外，ConcurrentHashMap还提供了一个在并发下比较有用的方法 putIfAbsent，如果传入key对应的value已经存在，就返回存在的value，不进行替换。如果不存在，就添加key和value，返回null。在代码层面它的作用类似于：</p><pre><code>synchronized(map){    if (map.get(key) == null){         return map.put(key, value);    } else{         return map.get(key);    }}</code></pre><p>它让上述代码的整个操作是线程安全的。</p><h3 id="ConcurrentHashMap实现分析"><a href="#ConcurrentHashMap实现分析" class="headerlink" title="ConcurrentHashMap实现分析"></a>ConcurrentHashMap实现分析</h3><h4 id="在1-7下的实现"><a href="#在1-7下的实现" class="headerlink" title="在1.7下的实现"></a>在1.7下的实现</h4><h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5><img src="/2020/01/06/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/pic19.png" srcset="/img/loading.gif" class=""><p>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁（ReentrantLock），在ConcurrentHashMap里扮演锁的角色；HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组。Segment的结构和HashMap类似，是一种数组和链表结构。一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素，每个Segment守护着一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得与它对应的Segment锁。Segment数组初始化之后大小不再改变，当需要扩容时Segment下的table数组进行扩容。</p><h5 id="初始化方法"><a href="#初始化方法" class="headerlink" title="初始化方法"></a>初始化方法</h5><p>ConcurrentHashMap初始化方法是通过initialCapacity（初始化容量）、loadFactor（负载因子）和concurrencyLevel（并发级别）来初始化segment数组、段偏移量segmentShift、段掩码segmentMask和每个segment里的HashEntry数组来实现的。</p><p>参数concurrencyLevel（并发度）可以理解为程序运行时能够同时更新ConccurentHashMap且不产生锁竞争的最大线程数，实际上就是ConcurrentHashMap中的分段锁个数，即Segment[]的数组长度。ConcurrentHashMap默认的并发度为16，用户也可以在构造函数中设置并发度，设置之后将不再改变。当用户设置并发度时，ConcurrentHashMap会使用大于等于该值的最小2幂指数作为实际并发度（假如用户设置并发度为17，实际并发度则为32）。如果设置的过小，会带来严重的锁竞争问题；如果设置的过大，原本位于同一个Segment内的访问会扩散到不同的Segment中，CPU cache命中率会下降，从而引起程序性能下降。大小可以通过cpu核心数或实际使用该Map的线程数量来确定。</p><img src="/2020/01/06/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/pic20.png" srcset="/img/loading.gif" class=""><p>参数initialCapacity是ConcurrentHashMap的初始化容量，loadfactor是每个Segment的负载因子，在构造方法里需要通过这两个参数来初始化数组中的每个Segment。上面代码中的变量cap就是Segment里HashEntry数组的长度，它等于initialCapacity除以ssize的倍数c，如果c大于1，就会取大于等于c的2的N次方值，所以segment里HashEntry数组的长度不是1，就是2的N次方。</p><p>在默认情况下， ssize = 16，initialCapacity = 16，loadFactor = 0.75f，那么cap = 1，threshold = (int) cap * loadFactor = 0。</p><p>在初始化时，默认只初始化Segment[0]中的table，其他Segment中的table在put时再进行初始化。</p><p>初始化segmentShift和segmentMask（了解即可，无需深究）这两个全局变量需要在定位segment时的散列算法里使用，shift等于size从1向左移位的次数，在默认情况下concurrencyLevel等于16，1需要向左移位移动4次，所以sshift等于4。segmentShift用于定位参与散列运算的位数，segmentShift等于32减sshift，所以等于28，这里之所以用<em>32</em>是因为ConcurrentHashMap里的hash()方法输出的最大数是<em>32</em>位的。segmentMask是散列运算的掩码，等于ssize减1，即15，掩码的二进制各个位的值都是<em>1</em>。因为ssize的最大长度是65536，所以segmentShift最大值是16，segmentMask最大值是65535，对应的二进制是16位，每个位都是1。</p><h5 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h5><img src="/2020/01/06/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/pic21.png" srcset="/img/loading.gif" class=""><p>既然ConcurrentHashMap使用分段锁Segment来保护不同段的数据，那么在插入和获取元素的时候，必须先通过散列算法定位到Segment。get操作先获取hash值，然后使用这个hash值通过hash运算定位到Segment(使用了hash值的高位部分)，再通过hash算法定位到table(使用了散列值的全部)。</p><img src="/2020/01/06/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/pic22.png" srcset="/img/loading.gif" class=""><p>整个get过程没有加锁，而是通过volatile保证get总是可以拿到最新值。</p><p>ConcurrentHashMap中使用的hash算法为Wang/Jenkins hash的变种算法，其产生的hash的值更加均匀，减少了hash冲突</p><h5 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h5><img src="/2020/01/06/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/pic24.png" srcset="/img/loading.gif" class=""><p>put方法首先会根据key计算出所在的Segment，然后调用ensureSegment()方法获取Segment。因为ConcurrentHashMap初始化时只会初始化第一个槽 segment[0]，所以其他槽在插入第一个值时会在ensureSegment()方法中进行初始化。</p><img src="/2020/01/06/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/pic25.png" srcset="/img/loading.gif" class=""><p>ensureSegment方法考虑了并发情况，当多个线程同时进入初始化同一个槽 segment[k]会进行循环CAS操作保证只有一个线程成功。</p><img src="/2020/01/06/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/pic26.png" srcset="/img/loading.gif" class=""><p>put方法在获取到Segment之后会调用Segment中的put方法，Segment中的put方法会通过tryLock()方法尝试获得锁，如果成功获得锁会将node置为null然后进入try语句块，如果没有获得锁会调用scanAndLockForPut()方法自旋等待获得锁。</p><img src="/2020/01/06/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/pic27.png" srcset="/img/loading.gif" class=""><p>scanAndLockForPut方法里在尝试获得锁的过程中会对对应HashEntity链表进行遍历，如果遍历完毕仍然找不到与key相同的HashEntry节点，则为后续的put操作提前创建一个HashEntry。当tryLock一定次数（当cpu可用核心数大于1时重试64次，否则只重试1次）后仍无法获得锁，则通过lock()阻塞式申请锁。</p><img src="/2020/01/06/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/pic28.png" srcset="/img/loading.gif" class=""><p>在获得锁之后，Segment对链表进行遍历，如果某个HashEntry节点具有相同的key，则更新该HashEntry的value值</p><img src="/2020/01/06/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/pic29.png" srcset="/img/loading.gif" class=""><p>否则新建一个HashEntry节点，采用头插法，将它设置为链表的新head节点并将原头节点设为新head的下一个节点。新建过程中如果节点总数（含新建的HashEntry）超过threshold，则调用rehash()方法对Segment进行扩容，最后将新建HashEntry写入到数组中。</p><h5 id="rehash方法"><a href="#rehash方法" class="headerlink" title="rehash方法"></a>rehash方法</h5><p>rehash方法扩容时会先创建数组newTable，然后进行将table中的节点迁移至newTable，最后用newTable取代table。</p><p>由于扩容是基于2的幂指来操作，假设扩容前某HashEntry对应到Segment中数组的index为i，数组的容量为capacity，那么扩容后该HashEntry对应到新数组中的index只可能为i或者i+capacity，因此很多HashEntry节点在扩容前后index可以保持不变，避免让所有的节点都进行复制操作。</p><p>假设原来table长度为4，那么元素在table中的分布是这样的</p><table><thead><tr><th>Hash值</th><th>15</th><th>23</th><th>34</th><th>56</th><th>77</th></tr></thead><tbody><tr><td>在table中的下标</td><td>3 = 15%4</td><td>3=23%4</td><td>2 = 34%4</td><td>0= 56%4</td><td>1 =77 %4</td></tr></tbody></table><p>扩容后table长度变为8，那么元素在table中的分布变成：</p><table><thead><tr><th>Hash值</th><th>15</th><th>23</th><th>34</th><th>56</th><th>77</th></tr></thead><tbody><tr><td>在table中的下标</td><td>7</td><td>7</td><td>2</td><td>0</td><td>5</td></tr></tbody></table><p>可以看见 hash值为34和56的下标保持不变，而15,23,77的下标都是在原来下标的基础上+4即可，可以快速定位和减少重排次数。</p><p>该方法没有考虑并发，因为执行该方法之前已经获取了锁。</p><h5 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h5><p>与put方法类似，都是在操作前需要拿到锁，以保证操作的线程安全性。</p><h5 id="size、containsValue方法"><a href="#size、containsValue方法" class="headerlink" title="size、containsValue方法"></a>size、containsValue方法</h5><p>这些方法都是基于整个ConcurrentHashMap来进行操作的，他们的原理也基本类似：首先不加锁循环执行以下操作：循环所有的Segment，获得对应的值以及所有Segment的modcount之和。在 put、remove 和 clean 方法里操作元素前都会将变量 modCount 进行变动，如果连续两次所有Segment的modcount和相等，则过程中没有发生其他线程修改ConcurrentHashMap的情况，返回获得的值。</p><p>当循环次数超过预定义的值时，这时需要对所有的Segment依次进行加锁，获取返回值后再依次解锁。所以一般来说，应该避免在多线程环境下使用size和containsValue方法。</p><h5 id="ConcurrentHashMap的弱一致性"><a href="#ConcurrentHashMap的弱一致性" class="headerlink" title="ConcurrentHashMap的弱一致性"></a>ConcurrentHashMap的弱一致性</h5><p>ConcurrentHashMap的get()和containsKey()方法并没有加锁，在遍历链表节点判断key是否相同以及获得该节点的value时，其他线程对链表结构做的调整（put新的key或者remove操作）会由于HashEntity数组并不是volita修饰的导致返回的可能是过时的数据。如果要求强一致性，那么必须使用Collections.synchronizedMap()方法。</p><h4 id="在1-8下的实现"><a href="#在1-8下的实现" class="headerlink" title="在1.8下的实现"></a>在1.8下的实现</h4><h5 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h5><ol><li>取消segments字段，直接采用transient volatile HashEntry&lt;K,V&gt;[] table保存数据，使用table数组元素作为锁，由于table是可以扩容的，数据的增加时锁的粒度也会缩小以减少并发冲突的概率，同时大量使用了使用 CAS + synchronized 来保证并发安全性。</li><li>将原本的table数组＋单向链表的数据结构，变更为table数组＋单向链表＋红黑树的结构。hash表最核心的能力在于将key hash之后能均匀的分布在数组中，理想的情况下table数组中的每个队列长度主要为0或者1，但实际情况并非如此。在数据量过大的情况下，即使ConcurrentHashMap类会依据默认的加载因子0.75进行扩容、增加table数组长度，但是如果hash结果不均匀，也会使数据集中在某个队列导致队列过长。此时查询某个节点的时间复杂度为O(n)。所以对于个数超过8(默认值)的列表jdk1.8中采用了红黑树的结构，查询的时间复杂度可以降低到O(logN)，从而改进性能。</li><li>使用 Node（jdk1.7 为 HashEntry）作为链表的数据结点，仍然包含 key，value，hash 和 next 四个属性。 红黑树中使用的是 TreeNode（extends Node）。所以根据数组元素中第一个结点数据类型是 Node 还是 TreeNode 可以判断该位置下是链表还是红黑树。</li></ol><img src="/2020/01/06/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/pic30.png" srcset="/img/loading.gif" class=""><p>当链表的长度大于8时会转为红黑树</p><p>当红黑树的大小小于6时会转为链表</p><h5 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h5><p>Node是最核心的内部类，它包装了key-value键值对。</p><img src="/2020/01/06/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/pic31.png" srcset="/img/loading.gif" class=""><p>定义基本和1.7中的HashEntry相同。Map本身所持有的也是一个Node型的数组</p><img src="/2020/01/06/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/pic32.png" srcset="/img/loading.gif" class=""><p>增加了一个find方法来用以辅助map.get()方法。其实就是遍历链表，子类中会覆盖这个方法。</p><img src="/2020/01/06/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/pic35.png" srcset="/img/loading.gif" class=""><p>在map中还定义了Segment这个类，不过只是为了向前兼容而已，不做过多考虑。</p><h5 id="TreeNode"><a href="#TreeNode" class="headerlink" title="TreeNode"></a>TreeNode</h5><p>树节点类，另外一个核心的数据结构。当链表长度过长的时候，会转换为TreeNode。</p><img src="/2020/01/06/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/pic33.png" srcset="/img/loading.gif" class=""><p>与1.8中HashMap不同点：</p><ol><li><p>它并不是直接转换为红黑树，而是把这些结点放在TreeBin对象中，由TreeBin完成对红黑树的包装。</p></li><li><p>TreeNode在ConcurrentHashMap继承Node类，HashMap中的继承LinkedHashMap.Entry&lt;K,V&gt;类，ConcurrentHashMap中的TreeNode带有next指针。</p></li></ol><h5 id="TreeBin"><a href="#TreeBin" class="headerlink" title="TreeBin"></a>TreeBin</h5><p>负责TreeNode节点。它代替了TreeNode的根节点，也就是说在实际ConcurrentHashMap的table数组中存放的是TreeBin对象，而不是TreeNode对象。另外这个类还带有了读写锁机制。</p><h5 id="特殊的ForwardingNode"><a href="#特殊的ForwardingNode" class="headerlink" title="特殊的ForwardingNode"></a>特殊的ForwardingNode</h5><p>ForwardingNode是一个特殊的 Node 结点，hash 值为 -1，内部存储nextTable的引用。在table发生扩容的时作为一个占位符放在 table 中表示当前结点为 null 或者已经被移动。</p><h5 id="sizeCtl"><a href="#sizeCtl" class="headerlink" title="sizeCtl"></a>sizeCtl</h5><p>用来控制 table 的初始化和扩容操作。</p><p>负数代表正在进行初始化或扩容操作：-1代表正在初始化，-N 表示有N-1个线程正在进行扩容操作，0为默认值，代表当时的table还没有被初始化。</p><p>正数表示初始化大小或Map中的元素达到这个数量时，需要进行扩容了。</p><h5 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h5><img src="/2020/01/06/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/pic36.png" srcset="/img/loading.gif" class=""><h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><img src="/2020/01/06/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/pic37.png" srcset="/img/loading.gif" class=""><p>可以发现，在new出一个map的实例时，并不会创建其中的数组等等相关的部件，只是进行简单的属性设置而已。同样的，table的大小也被规定为必须是2的乘方数。</p><p>真正的初始化在放在了是在向ConcurrentHashMap中插入元素的时候发生的。如调用put()、computeIfAbsent()、compute()、merge()等方法的时候，调用时机是检查table==null。</p><h5 id="get操作"><a href="#get操作" class="headerlink" title="get操作"></a>get操作</h5><p>get方法比较简单，给定一个key来确定value的时候，必须满足两个条件 key相同 hash值相同，对于节点可能在链表或树上的情况，需要分别去查找。</p><img src="/2020/01/06/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/pic38.png" srcset="/img/loading.gif" class=""><h5 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h5><img src="/2020/01/06/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/pic40.png" srcset="/img/loading.gif" class=""><p>总结来说，put方法也继续沿用HashMap的put方法的思想，首先不允许key或value为null的情况放入，对于每一个放入的值，利用spread方法对key的hashcode进行一次hash计算，由此来确定这个值在table中的位置i，如果i位置是空的，直接放进去且不需要加锁操作，否则对i位置节点进行加锁，然后对节点进行判断，如果是树节点则按照树的方式插入新的节点，如果是链表节点，则得到的结点就是由hash值相同的节点组成的链表的头节点。此时需要向后遍历链表，如果遇到key值一致的情况，则需要更新其value值，否则依次向后遍历，到链表尾插入这个结点（尾插法）。如果加入这个节点以后链表长度大于8，就把这个链表转换成红黑树。</p><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><img src="/2020/01/06/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/pic39.png" srcset="/img/loading.gif" class=""><p>前面说过，构造方法中并没有真正初始化，真正的初始化在放在了是在向ConcurrentHashMap中插入元素的时候发生的。具体实现的方法就是initTable</p><h5 id="transfer"><a href="#transfer" class="headerlink" title="transfer"></a>transfer</h5><p>当ConcurrentHashMap容量不足的时需要对table进行扩容。这个方法的基本思想跟HashMap是很像的，但是由于它是支持并发扩容的，所以要复杂的多。我们不深入源码去讲述，只讲述其大概原理。</p><p>扩容的时总是会涉及到从一个“数组”到另一个“数组”拷贝的操作，并发扩容就是使这个操作能够并发进行，利用并发处理去减少扩容带来的时间影响。transfer中的并发扩容就是将数据迁移任务根据变量stride作为步长拆分成多个小迁移任务，每个线程每次负责迁移其中的一部分。</p><p>整个扩容操作分为两个部分：</p><img src="/2020/01/06/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/pic41.png" srcset="/img/loading.gif" class=""><p>第一部分是构建一个nextTable,它的容量是原来的2倍。</p><p>第二个部分就是将原来table中的元素复制到nextTable中，这里允许多线程进行操作。</p><p>整个扩容流程就是遍历和复制：</p><p>为null或者已经处理过的节点，会被设置为forwardNode节点，当线程准备扩容时，发现节点是forwardNode节点，跳过这个节点，继续寻找未处理的节点，找到之后对节点上锁。</p><p>如果这个位置是Node节点（fh&gt;=0），说明它是一个链表，就构造一个反序链表，把他们分别放在nextTable的i和i+n的位置上</p><p>如果这个位置是TreeBin节点（fh&lt;0），也做一个反序处理，并且判断是否需要红黑树转链表，把处理的结果分别放在nextTable的i和i+n的位置上</p><p>遍历过所有的节点以后就完成了复制工作，这时让nextTable作为新的table，并且更新sizeCtl为新容量的0.75倍 ，完成扩容。</p><h5 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h5><p>移除方法的基本流程和put方法很类似，只不过操作由插入数据变为移除数据而已，而且如果存在红黑树的情况下，会检查是否需要将红黑树转为链表的步骤。不再重复讲述。</p><h5 id="treeifyBin"><a href="#treeifyBin" class="headerlink" title="treeifyBin"></a>treeifyBin</h5><p>用于将过长的链表转换为TreeBin对象。但是他并不是直接转换，而是进行一次容量判断，没有达到转换的要求，直接进行扩容操作并返回；如果满足条件才将链表的结构转换为TreeBin ，这与HashMap不同的是，它并没有把TreeNode直接放入红黑树，而是利用了TreeBin这个小容器来封装所有的TreeNode。</p><h5 id="size"><a href="#size" class="headerlink" title="size"></a>size</h5><p>JDK1.8中，调用put()方法时就会调用addCount()方法计算size的数量，扩容过程也会修改size的数量，因此在调用size()方法时可以直接返回，JDK1.7是调用size()方法时才会去计算。</p><p>调用addCount()方法时，会使用CAS更新baseCount，因为CAS只允许一个线程做修改，如果修改失败就会使用counterCells，大致的流程就是：</p><ol><li><p>对 baseCount 做 CAS 自增操作。</p></li><li><p>如果并发导致 baseCount CAS 失败了，则使用 counterCells。</p></li><li><p>如果counterCells CAS 失败了，在 fullAddCount 方法中，会继续死循环操作，直到成功。</p></li></ol><p>在具体实现上，计算大小的核心方法都是 sumCount()</p><p>JDK1.8中sumCount()会获取baseCount和CounterCell数组然后遍历CounterCell数组，将baseCount与CounterCell的值累加后返回。</p><img src="/2020/01/06/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/pic42.png" srcset="/img/loading.gif" class=""><p>其实去计算并发集合中实时在变的size是没有多大的意义的，但Doug Lea仍花费了很多心思去优化他的性能。</p><h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><p>HashTable容器使用synchronized来保证线程安全，这会导致在线程竞争激烈的情况下HashTable的效率非常低下。当一个线程访问HashTable的同步方法，其他线程也访问HashTable的同步方法时，会进入阻塞或轮询状态。如线程1使用put进行元素添加，线程2不但不能使用put方法添加元素，也不能使用get方法来获取元素，所以竞争越激烈效率越低。</p><h2 id="并发下的Map常见面试题汇总"><a href="#并发下的Map常见面试题汇总" class="headerlink" title="并发下的Map常见面试题汇总"></a>并发下的Map常见面试题汇总</h2><h3 id="HashMap-和-HashTable-有什么区别？"><a href="#HashMap-和-HashTable-有什么区别？" class="headerlink" title="HashMap 和 HashTable 有什么区别？"></a>HashMap 和 HashTable 有什么区别？</h3><ol><li><p>HashMap 是线程不安全的，HashTable 是线程安全的；</p></li><li><p>由于线程安全，所以 HashTable 的效率比不上 HashMap；</p></li><li><p>HashMap是允许key为value的，HashTable是不允许的，ConcurrentHashMap也是不允许的。</p></li><li><p>HashMap最多只允许一条记录的键为null，允许多条记录的值为null，而 HashTable 不允许；</p></li><li><p>HashMap 默认初始化数组的大小为16，HashTable 为 11，前者扩容时，扩大两倍，后者扩大两倍+1；</p></li><li><p>HashMap 需要重新计算 hash 值，而 HashTable 直接使用对象的 hashCode</p></li></ol><h3 id="Java-中的另一个线程安全的与-HashMap-极其类似的类是什么？同样是线程安全，它与-HashTable-在线程同步上有什么不同？"><a href="#Java-中的另一个线程安全的与-HashMap-极其类似的类是什么？同样是线程安全，它与-HashTable-在线程同步上有什么不同？" class="headerlink" title="Java 中的另一个线程安全的与 HashMap 极其类似的类是什么？同样是线程安全，它与 HashTable 在线程同步上有什么不同？"></a>Java 中的另一个线程安全的与 HashMap 极其类似的类是什么？同样是线程安全，它与 HashTable 在线程同步上有什么不同？</h3><p>ConcurrentHashMap 类（是 Java并发包 java.util.concurrent 中提供的一个线程安全且高效的 HashMap 实现）。</p><p>HashTable 是使用 synchronize 关键字加锁的原理（就是对对象加锁）；</p><p>而针对 ConcurrentHashMap，在 JDK 1.7 中采用Segment分段锁的方式；JDK 1.8 中直接采用了CAS（无锁算法）+ synchronized，也采用分段锁的方式但1.8中的分段锁是使用synchronized锁住table中的节点来实现的，缩小了锁的粒度。</p><h3 id="HashMap-amp-ConcurrentHashMap-的区别？"><a href="#HashMap-amp-ConcurrentHashMap-的区别？" class="headerlink" title="HashMap &amp; ConcurrentHashMap 的区别？"></a>HashMap &amp; ConcurrentHashMap 的区别？</h3><p>除了加锁，原理上无太大区别。</p><p>另外，HashMap 的键值对允许有null，但是ConCurrentHashMap 都不允许。</p><p>在数据结构上，红黑树相关的节点类不同继承的类不同</p><h3 id="为什么ConcurrentHashMap比HashTable效率要高？"><a href="#为什么ConcurrentHashMap比HashTable效率要高？" class="headerlink" title="为什么ConcurrentHashMap比HashTable效率要高？"></a>为什么ConcurrentHashMap比HashTable效率要高？</h3><p>HashTable 使用一把锁（锁住整个链表结构）处理并发问题，多个线程竞争一把锁，容易阻塞ConcurrentHashMap在JDK 1.7 中使用分段锁（ReentrantLock + Segment + HashEntry），相当于把一个 HashMap 分成多个段，每段分配一把锁，这样支持多线程访问。锁粒度基于 Segment，Segment中包含多个 HashEntry。JDK 1.8 中使用 CAS + synchronized + Node + 红黑树。锁粒度基于Node（首结点）（实现 Map.Entry&lt;K,V&gt;），锁粒度相对1.7降低了。</p><h3 id="针对ConcurrentHashMap-锁机制具体分析？"><a href="#针对ConcurrentHashMap-锁机制具体分析？" class="headerlink" title="针对ConcurrentHashMap 锁机制具体分析？"></a>针对ConcurrentHashMap 锁机制具体分析？</h3><p>JDK 1.7 中，采用分段锁的机制，实现并发的更新操作，底层采用数组+链表的存储结构，包括两个核心静态内部类 Segment 和 HashEntry。Segment 继承 ReentrantLock（重入锁） 用来充当锁的角色，每个 Segment 对象守护每个散列映射表的若干个桶；HashEntry 用来封装映射表的键-值对；每个桶是由若干个 HashEntry 对象链接起来的链表。</p><p>JDK 1.8 中，采用Node + CAS + Synchronized来保证并发安全。取消类 Segment，当需要锁时直接用synchronized锁住table数组中的对象，键值对直接存储在table中；当 Node 对象组成的链表长度超过 TREEIFY_THRESHOLD 时，链表转换为红黑树，Node对象被包装为TreeNode，以提升检索性能。此时底层变更为数组 + 链表 + 红黑树。</p><h3 id="ConcurrentHashMap在JDK-1-8中，为什么要使用内置锁-synchronized-来代替重入锁-ReentrantLock？"><a href="#ConcurrentHashMap在JDK-1-8中，为什么要使用内置锁-synchronized-来代替重入锁-ReentrantLock？" class="headerlink" title="ConcurrentHashMap在JDK 1.8中，为什么要使用内置锁 synchronized 来代替重入锁 ReentrantLock？"></a>ConcurrentHashMap在JDK 1.8中，为什么要使用内置锁 synchronized 来代替重入锁 ReentrantLock？</h3><ol><li><p>JVM 开发团队在1.8中对 synchronized做了大量性能上的优化，而且基于 JVM 的 synchronized 优化空间更大，更加自然。</p></li><li><p>在大量的数据操作下，对于 JVM 的内存压力，基于 API 的 ReentrantLock 会开销更多的内存。</p></li></ol><h3 id="ConcurrentHashMap简单介绍？"><a href="#ConcurrentHashMap简单介绍？" class="headerlink" title="ConcurrentHashMap简单介绍？"></a>ConcurrentHashMap简单介绍？</h3><ol><li><p>重要的常量：<strong>private transient volatile int sizeCtl</strong>，当为负数时，-1 表示正在初始化，-N 表示 N - 1 个线程正在进行扩容；当为 0 时，表示 table 还没有初始化；当为其他正数时，表示初始化或者下一次进行扩容的大小。</p></li><li><p>数据结构：<strong>Node 是存储结构的基本单元</strong>，继承 HashMap 中的 Entry，用于存储数据；TreeNode 继承 Node，但是数据结构换成了二叉树结构，是红黑树的存储结构，用于红黑树中存储数据；TreeBin 是封装 TreeNode 的容器，提供转换红黑树的一些条件和锁的控制。</p></li><li><p>put()方法：如果没有初始化，就调用 initTable() 方法来进行初始化；如果没有 hash 冲突就直接 CAS 无锁插入；如果需要扩容，就先进行扩容；如果存在 hash 冲突，就加锁来保证线程安全，两种情况：一种是链表形式就直接遍历到尾端插入，一种是红黑树就按照红黑树结构插入；如果该链表的数量大于阀值 8，就要先转换成红黑树的结构，break 再一次进入循环如果添加成功就调用 addCount() 方法统计 size，并且检查是否需要扩容。</p></li><li><p>扩容方法 transfer()：默认容量为 16，扩容时，容量变为原来的两倍。helpTransfer()：调用多个工作线程一起帮助进行扩容，这样的效率就会更高。</p></li><li><p>get()方法：计算 hash 值，定位到该 table 索引位置，如果是首结点符合就返回；如果遇到扩容时，会调用标记正在扩容结点 ForwardingNode.find()方法，查找该结点，匹配就返回；以上都不符合的话，就往下遍历结点，匹配就返回，否则最后就返回 null。</p></li></ol><h3 id="ConcurrentHashMap的并发度是什么？"><a href="#ConcurrentHashMap的并发度是什么？" class="headerlink" title="ConcurrentHashMap的并发度是什么？"></a>ConcurrentHashMap的并发度是什么？</h3><p>1.7中程序运行时能够同时更新 ConccurentHashMap 且不产生锁竞争的最大线程数。默认为 16即Segment的数量，可以在构造函数中设置。当用户设置并发度时，ConcurrentHashMap 会使用大于等于该值的最小2幂指数作为实际并发度（假如用户设置并发度为17，实际并发度则为32）。1.8中由于直接使用table中的节点数量作为分段锁的数量，并发度已经没有太大的实际意义了，主要用处就是当设置的初始容量小于并发度，将初始容量提升至并发度大小。 </p><h2 id="ConcurrentSkipListMap和ConcurrentSkipListSet"><a href="#ConcurrentSkipListMap和ConcurrentSkipListSet" class="headerlink" title="ConcurrentSkipListMap和ConcurrentSkipListSet"></a>ConcurrentSkipListMap和ConcurrentSkipListSet</h2><p>TreeMap和TreeSet使用红黑树按照key的顺序（自然顺序、自定义顺序）来使得键值对有序存储，但是只能在单线程下安全使用；多线程下想要使键值对按照key的顺序来存储，则需要使用ConcurrentSkipListMap和ConcurrentSkipListSet，分别用以代替TreeMap和TreeSet，存入的数据按key排序。在实现上，ConcurrentSkipListSet 本质上就是ConcurrentSkipListMap，ConcurrentSkipListMap实际上就是一个跳表的实现。</p><p>ConcurrentSkipListMap和ConcurrentHashMap都是线程安全的Map实现，ConcurrentHashMap的性能和存储空间要优于ConcurrentSkipListMap，但是ConcurrentSkipListMap有一个功能： 它会按照键的顺序进行排序。</p><h3 id="二分查找和AVL树查找"><a href="#二分查找和AVL树查找" class="headerlink" title="二分查找和AVL树查找"></a>二分查找和AVL树查找</h3><p>二分查找要求元素可以随机访问，所以决定了需要把元素存储在连续内存。这样查找确实很快，但是插入和删除元素的时候，为了保证元素的有序性，就需要大量的移动元素了。</p><p>如果需要的是一个能够进行二分查找，又能快速添加和删除元素的数据结构，首先就是二叉查找树，二叉查找树在最坏情况下可能变成一个链表。</p><p>于是，就出现了平衡二叉树，根据平衡算法的不同有AVL树，B-Tree，B+Tree，红黑树等，但是AVL树实现起来比较复杂，平衡操作较难理解，这时候就可以用SkipList跳跃表结构。</p><h3 id="跳表（SkipList）"><a href="#跳表（SkipList）" class="headerlink" title="跳表（SkipList）"></a>跳表（SkipList）</h3><p>传统意义的单链表是一个线性结构，向有序的链表中插入一个节点需要O(n)的时间，查找操作需要O(n)的时间。</p><img src="/2020/01/06/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/pic43.png" srcset="/img/loading.gif" class=""><p>如果我们使用上图所示的跳跃表，就可以减少查找所需时间为O(n/2)，因为我们可以先通过每个节点的最上面的指针先进行查找，这样子就能跳过一半的节点。</p><p>比如我们想查找50，首先和20比较，大于20之后，在和40进行比较，然后在和70进行比较，发现70大于50，说明查找的点在40和50之间，从这个过程中，我们可以看出，查找的时候跳过了30。</p><p>跳跃表其实也是一种通过“空间来换取时间”的一个算法，令链表的每个结点不仅记录next结点位置，还可以按照level层级分别记录后继第level个结点。此法使用的就是“<strong>先大步查找确定范围，再逐渐缩小迫近</strong>”的思想进行的查找。跳跃表在算法效率上很接近红黑树。</p><p>跳跃表又被称为概率，或者说是随机化的数据结构，目前开源软件 Redis 和 lucence都有用到它。</p><h2 id="CopyOnWriteArrayList和CopyOnWriteArraySet"><a href="#CopyOnWriteArrayList和CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArrayList和CopyOnWriteArraySet"></a>CopyOnWriteArrayList和CopyOnWriteArraySet</h2><h3 id="什么是写时复制容器"><a href="#什么是写时复制容器" class="headerlink" title="什么是写时复制容器"></a>什么是写时复制容器</h3><p>CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。</p><p>这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。如果读的时候有多个线程正在向CopyOnWriteArrayList添加数据，读还是会读到旧的数据，因为写的时候不会锁住旧的CopyOnWriteArrayList。</p><p>CopyOnWrite容器用于对于绝大部分访问都是读，且只是偶尔写的并发场景。比如白名单，黑名单，商品类目的访问和更新场景，假如我们有一个搜索网站，用户在这个网站的搜索框中，输入关键字搜索内容，但是某些关键字不允许被搜索。这些不能被搜索的关键字会被放在一个黑名单当中，黑名单每天晚上更新一次。当用户搜索时，会检查当前关键字在不在黑名单当中，如果在，则提示不能搜索。</p><h3 id="使用CopyOnWriteMap需要注意两件事情："><a href="#使用CopyOnWriteMap需要注意两件事情：" class="headerlink" title="使用CopyOnWriteMap需要注意两件事情："></a>使用CopyOnWriteMap需要注意两件事情：</h3><ol><li><p>减少扩容开销。根据实际需要，初始化CopyOnWriteMap的大小，避免写时CopyOnWriteMap扩容的开销。</p></li><li><p>使用批量添加。因为每次添加，容器每次都会进行复制，所以减少添加次数，可以减少容器的复制次数。</p></li></ol><h3 id="写时复制容器的问题："><a href="#写时复制容器的问题：" class="headerlink" title="写时复制容器的问题："></a>写时复制容器的问题：</h3><ol><li><p>性能问题：每次修改都创建一个新数组，然后复制所有内容，如果数组比较大，修改操作又比较频繁，可以想象，性能是很低的，而且内存开销会很大。</p></li><li><p>数据一致性问题：CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，不要使用CopyOnWrite容器。</p></li></ol><h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><img src="/2020/01/06/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/pic44.png" srcset="/img/loading.gif" class=""><p>队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。</p><p>在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为先进先出（FIFO—first in first out）线性表。</p><h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><table><thead><tr><th>方法/处理方式</th><th>抛出异常</th><th>返回特殊值</th><th>一直阻塞</th><th>超时退出</th></tr></thead><tbody><tr><td><strong>插入方法</strong></td><td>add(e)</td><td>offer(e)</td><td>put(e)</td><td>offer(e,time,unit)</td></tr><tr><td><strong>移除方法</strong></td><td>remove()</td><td>poll()</td><td>take()</td><td>poll(time, unit)</td></tr><tr><td><strong>检查方法</strong></td><td>element()</td><td>peek()</td><td>不可用</td><td>不可用</td></tr></tbody></table><ul><li><p>支持阻塞的插入方法：当队列满时，队列会阻塞插入元素的线程直到队列不满。</p></li><li><p>支持阻塞的移除方法：在队列为空时，获取元素的线程会被阻塞直到队列变为非空。</p></li><li><p>抛出异常：当队列满时，如果再往队列里插入元素，会抛出IllegalStateException（”Queuefull”）异常。当队列空时，从队列里获取元素会抛出NoSuchElementException异常。</p></li><li><p>返回特殊值：当往队列插入元素时，会返回元素是否插入成功，成功返回true。如果是移除方法，则是从队列里取出一个元素，如果没有则返回null。</p></li><li><p>一直阻塞：当阻塞队列满时，如果线程往队列里put元素，队列会一直阻塞线程，直到队列可用或者响应中断退出。当队列空时，如果线程从队列里take元素，队列会阻塞住消费者线程，直到队列不为空。</p></li><li><p>超时退出：当阻塞队列满时，如果线程往队列里插入元素，队列会阻塞生产者线程一段时间，如果超过了指定的时间，线程就会退出。</p></li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>在并发编程中使用生产者和消费者模式能够解决绝大多数并发问题。该模式通过平衡生产线程和消费线程的工作能力来提高程序整体处理数据的速度。</p><p>在线程世界里，生产者就是生产数据的线程，消费者就是消费数据的线程。在多线程开发中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据。同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。</p><p>为了解决这种生产消费能力不均衡的问题，便有了生产者和消费者模式。生产者和消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通信，而是通过阻塞队列来进行通信，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。</p><p>阻塞队列常用于生产者和消费者的场景，生产者是向队列里添加元素的线程，消费者是从队列里取元素的线程。阻塞队列就是生产者用来存放元素、消费者用来获取元素的容器。</p><h3 id="有界无界"><a href="#有界无界" class="headerlink" title="有界无界"></a>有界无界</h3><p>有限队列就是长度有限，满了以后生产者会阻塞，无界队列就是里面能放无数的东西而不会因为队列长度限制被阻塞，当然空间限制来源于系统资源的限制，如果处理不及时，导致队列越来越大越来越大，超出一定的限制致使内存超限，操作系统或者JVM帮你解决烦恼，直接把你 OOM kill 省事了。</p><h3 id="阻塞队列的实现原理"><a href="#阻塞队列的实现原理" class="headerlink" title="阻塞队列的实现原理"></a>阻塞队列的实现原理</h3><p>使用了等待通知模式实现。所谓通知模式，就是当生产者往满的队列里添加元素时会阻塞住生产者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用。通过查看JDK源码发现ArrayBlockingQueue使用了Condition来实现。其余队列的实现，大家可以自行查看，队列的实现的代码总体来说，并不复杂。</p><h3 id="常用阻塞队列"><a href="#常用阻塞队列" class="headerlink" title="常用阻塞队列"></a>常用阻塞队列</h3><ul><li><p>ArrayBlockingQueue：是一个用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序。默认情况下不保证线程公平的访问队列，所谓公平访问队列是指阻塞的线程，可以按照阻塞的先后顺序访问队列，即先阻塞线程先访问队列。非公平性是对先等待的线程是非公平的，当队列可用时，阻塞的线程都可以争夺访问队列的资格，有可能先阻塞的线程最后才访问队列。初始化时有参数可以设置</p></li><li><p>LinkedBlockingQueue：是一个用链表实现的有界阻塞队列。此队列的默认和最大长度为Integer.MAX_VALUE，按照先进先出的原则对元素进行排序。和ArrayBlockingQueue实现的区别：</p><ol><li><p>队列中锁的实现不同ArrayBlockingQueue实现的队列中的锁是没有分离的，即生产和消费用的是同一个锁；LinkedBlockingQueue实现的队列中的锁是分离的，即生产用的是putLock，消费是takeLock。</p></li><li><p>在生产或消费时操作不同：ArrayBlockingQueue实现的队列中在生产和消费的时候，是直接将枚举对象插入或移除的；LinkedBlockingQueue实现的队列中在生产和消费的时候，需要把枚举对象转换为Node<E>进行插入或移除，会影响性能。</p></li><li><p>队列大小初始化方式不同：ArrayBlockingQueue实现的队列中必须指定队列的大小LinkedBlockingQueue实现的队列中可以不指定队列的大小，但是默认是Integer.MAX_VALUE（20来个亿）一般的服务器是扛不住的，所以在使用LinkedBlockingQueue时还是尽量指定大小。</p></li></ol></li><li><p>PriorityBlockingQueue：是一个支持优先级的无界阻塞队列。默认情况下元素采取自然顺序升序排列。也可以自定义类实现compareTo()方法来指定元素排序规则，或者初始化PriorityBlockingQueue时，指定构造参数Comparator来对元素进行排序。需要注意的是不能保证同优先级元素的顺序。</p></li><li><p>DelayQueue：是一个支持延时获取元素的无界阻塞队列。队列使用PriorityQueue来实现。队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。DelayQueue非常有用，可以将DelayQueue运用在以下应用场景。缓存系统的设计：可以用DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelayQueue中获取元素时，表示缓存有效期到了。还有订单到期，限时支付等等</p></li><li><p>SynchronousQueue：是一个不存储元素的阻塞队列。每一个put操作必须等待一个take操作，否则不能继续添加元素。SynchronousQueue可以看成是一个传球手，负责把生产者线程处理的数据直接传递给消费者线程。队列本身并不存储任何元素，非常适合传递性场景。SynchronousQueue的吞吐量高于LinkedBlockingQueue和ArrayBlockingQueue。</p></li><li><p>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列，多了tryTransfer和transfer方法。如果当前有消费者正在等待接收元素（消费者使用take()方法或带时间限制的poll()方法时），transfer方法可以把生产者传入的元素立刻transfer（传输）给消费者。如果没有消费者在等待接收元素，transfer方法会将元素存放在队列的tail节点，并等到该元素被消费者消费了才返回。tryTransfer方法是用来试探生产者传入的元素是否能直接传给消费者。如果没有消费者等待接收元素，则返回false。和transfer方法的区别是tryTransfer方法无论消费者是否接收，方法立即返回，而transfer方法是必须等到消费者消费了才返回。</p></li><li><p>LinkedBlockingDeque：是一个由链表结构组成的双向阻塞队列。所谓双向队列指的是可以从队列的两端插入和移出元素。双向队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。多了addFirst、addLast、offerFirst、offerLast、peekFirst和peekLast等方法，以First单词结尾的方法，表示插入、获取（peek）或移除双端队列的第一个元素。以Last单词结尾的方法，表示插入、获取或移除双端队列的最后一个元素。另外，插入方法add等同于addLast，移除方法remove等效于removeFirst。但是take方法却等同于takeFirst，不知道是不是JDK的bug，使用时还是用带有First和Last后缀的方法更清楚。在初始化LinkedBlockingDeque时可以设置容量防止其过度膨胀。另外，双向阻塞队列可以运用在“工作窃取”模式中。</p></li></ul><h2 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h2><p>ConcurrentLinkedQueue是一个无界非阻塞队列，它是基于链表的无界线程安全队列。该队列的元素遵循先进先出的原则。头是最先加入的，尾是最近加入的。插入元素是追加到尾上，提取一个元素是从头提取。</p><p>可以看成是LinkedList的并发版本，常用方法：</p><ul><li><p>add(e):插入指定元素</p></li><li><p>offer(e):将指定元素插入到此队列的尾部。  </p></li><li><p>peek():检索此队列的头但并不移除，如果此队列为空，则返回 null。  </p></li><li><p>poll(): 检索并移除此队列的头，如果此队列为空，则返回 null。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>并发编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>显式锁和AQS</title>
    <link href="undefined2019/12/30/%E6%98%BE%E5%BC%8F%E9%94%81%E5%92%8CAQS/"/>
    <url>2019/12/30/%E6%98%BE%E5%BC%8F%E9%94%81%E5%92%8CAQS/</url>
    
    <content type="html"><![CDATA[<h2 id="显式锁"><a href="#显式锁" class="headerlink" title="显式锁"></a>显式锁</h2><p>Java程序是靠synchronized关键字实现锁功能的，synchronized关键字将会隐式地获取和释放锁，而且获取和释放锁的过程是固化的，也被称为内置锁。Lock是手动的获取和释放锁，这就是显式锁名称的由来。</p><h3 id="Lock接口和synchronized的比较"><a href="#Lock接口和synchronized的比较" class="headerlink" title="Lock接口和synchronized的比较"></a>Lock接口和synchronized的比较</h3><p>synchronized获取锁时会一直等待直到获取锁为止。Lock提供lockInterruptibly()方法可以在等待获取到锁的过程中能够响应中断，tryLock()方法尝试获取锁时如果失败会返回false，然后线程可以做其他的事，之后再进行tryLock()，tryLock()方法还可以接收long类型及TimeUnit类型的参数超时的获取锁。</p><p>如果尝试取锁及中断取锁尽量使用synchronized关键字，在目前的发展趋势jdk一直在对synchronized进行优化，synchronized的开销要比Lock接口更少。</p><h3 id="Lock的标准用法"><a href="#Lock的标准用法" class="headerlink" title="Lock的标准用法"></a>Lock的标准用法</h3><pre><code>lock.lock()try{    count++;}finally{    lock.unlock();}</code></pre><p>在finally块中释放锁，目的是保证在获取到锁之后，最终能够被释放。</p><p>不能将获取锁的过程写在try块中，如果在获取锁（自定义锁的实现）时发生了异常，异常抛出的同时会导致锁的无故释放。</p><h3 id="可重入锁ReentrantLock、锁的公平和非公平"><a href="#可重入锁ReentrantLock、锁的公平和非公平" class="headerlink" title="可重入锁ReentrantLock、锁的公平和非公平"></a>可重入锁ReentrantLock、锁的公平和非公平</h3><h4 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h4><p>同一个线程对于已经获得到的锁，可以多次继续申请到该锁的使用权。synchronized关键字也支持隐式的支持重进入，比如一个synchronized修饰的递归方法，在方法执行时，执行线程在获取了锁之后仍能连续多次地获得该锁。ReentrantLock在调用lock()方法时，如果当前线程已经获取到锁就能够再次调用lock()方法获取锁而不被阻塞。</p><h4 id="公平和非公平"><a href="#公平和非公平" class="headerlink" title="公平和非公平"></a>公平和非公平</h4><p>如果在时间上，先对锁进行获取的线程即等待时间最长的线程一定先获取到锁，那么这个锁是公平的，也可以说锁获取是顺序的，反之就是不公平的。 ReentrantLock提供了一个构造函数，能够控制锁是否是公平的，synchronized也是非公平锁。事实上，公平的锁机制往往没有非公平的效率高。  </p><p>线程被唤醒的上下文切换时间周期在5000-10000之间，在激烈竞争的情况下，非公平锁的性能高于公平锁的性能的一个原因是：在恢复一个被挂起的线程与该线程真正开始运行之间存在着严重的延迟。假设线程A持有一个锁，并且线程B请求这个锁。由于这个锁已被线程A持有，因此B将被挂起。当A释放锁时，B将被唤醒，B完全唤醒后会再次尝试获取锁。与此同时，如果C也请求这个锁，那么C很可能会在B被完全唤醒之前获得、使用以及释放这个锁。这样的情况是一种“双赢”的局面：B获得锁的时刻并没有推迟，C更早地获得了锁，并且吞吐量也获得了提高。</p><h3 id="读写锁ReentrantReadWriteLock"><a href="#读写锁ReentrantReadWriteLock" class="headerlink" title="读写锁ReentrantReadWriteLock"></a>读写锁ReentrantReadWriteLock</h3><p>之前提到锁（如synchronized和ReentrantLock）基本都是排他锁即独占锁，这些锁在同一时刻只允许一个线程进行访问，而读写锁在同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其他写线程均被阻塞。读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大提升。写锁为独占锁，读锁为共享锁，但读写之前相互排斥。</p><p>除了保证写操作对读操作的可见性以及并发性的提升之外，读写锁能够简化读写交互场景的编程方式。假设在程序中定义一个共享的用作缓存数据结构，它大部分时间提供读服务（例如查询和搜索），而写操作占有的时间很少，但是写操作完成之后的更新需要对后续的读服务可见。</p><p>ReentrantReadWriteLock实现的为ReadAndWriteLock接口，ReadAndWriteLock接口提供了readLock()方法获取读锁，writeLock()方法获取写锁。在没有读写锁支持的（Java 5之前）时候，如果需要完成上述工作就要使用Java的等待通知机制，就是当写操作开始时，所有晚于写操作的读操作均会进入等待状态，只有写操作完成并进行通知之后，所有等待的读操作才能继续执行（写操作之间依靠synchronized关键进行同步），这样做的目的是使读操作能读取到正确的数据，不会出现脏读。改用读写锁实现上述功能，只需要在读操作时获取读锁，写操作时获取写锁即可。当写锁被获取到时，后续（非当前写操作线程）的读写操作都会被阻塞，写锁释放之后，所有操作继续执行，编程方式相对于使用等待通知机制的实现方式而言，变得简单明了。 </p><p>一般情况下，读写锁的性能都会比排它锁好，因为大多数场景读是多于写的，读写的比例约为10:1。在读多于写的情况下，读写锁能够提供比排它锁更好的并发性和吞吐量。</p><h3 id="Condition接口"><a href="#Condition接口" class="headerlink" title="Condition接口"></a>Condition接口</h3><p>任意一个Java对象，都拥有一组监视器方法（定义在java.lang.Object上），主要包括wait()、wait(long timeout)、notify()以及notifyAll()方法，这些方法与synchronized同步关键字配合，可以实现等待/通知模式。Condition接口也提供了类似Object的监视器方法await()，signal()，与Lock配合可以实现等待/通知模式。</p><h3 id="用Lock和Condition实现等待通知"><a href="#用Lock和Condition实现等待通知" class="headerlink" title="用Lock和Condition实现等待通知"></a>用Lock和Condition实现等待通知</h3><pre><code>/** * 类说明： */public class ExpressCond {    public final static String CITY = &quot;ShangHai&quot;;    /**     * 快递运输里程数     */    private int km;    /**     * 快递到达地点     */    private String site;    private Lock kmLock = new ReentrantLock();    private Lock siteLock = new ReentrantLock();    private Condition kmCondition = kmLock.newCondition();    private Condition siteCondition = siteLock.newCondition();    public ExpressCond(int km, String site) {        this.km = km;        this.site = site;    }    /**     * 变化公里数，然后通知处于wait状态并需要处理公里数的线程进行业务处理     */    public void changeKm() {        kmLock.lock();        try {            this.km = 101;            kmCondition.signal();        } finally {            kmLock.unlock();        }    }    /**     * 变化地点，然后通知处于wait状态并需要处理地点的线程进行业务处理     */    public void changeSite() {        siteLock.lock();        try {            this.site = &quot;BeiJing&quot;;            siteCondition.signal();        } finally {            siteLock.unlock();        }    }    /**     * 当快递的里程数大于100时更新数据库     */    public void waitKm() {        kmLock.lock();        try {            while (this.km &lt; 100) {                try {                    kmCondition.await();                    System.out.println(&quot;check Site thread[&quot; + Thread.currentThread().getId()                            + &quot;] is be notified&quot;);                } catch (InterruptedException e) {                    e.printStackTrace();                }            }        } finally {            kmLock.unlock();        }        System.out.println(&quot;the Km is &quot; + this.km + &quot;,I will change db&quot;);    }    /**     * 当快递到达目的地时通知用户     */    public void waitSite() {        siteLock.lock();        try {            while (this.site.equals(CITY)) {                try {                    siteCondition.await();//当前线程进行等待                    System.out.println(&quot;check Site thread[&quot; + Thread.currentThread().getName()                            + &quot;] is be notify&quot;);                } catch (InterruptedException e) {                    e.printStackTrace();                }            }        } finally {            siteLock.unlock();        }        System.out.println(&quot;the site is &quot; + this.site + &quot;,I will call user&quot;);    }    private static ExpressCond express = new ExpressCond(0, ExpressCond.CITY);    /**     * 检查里程数变化的线程,不满足条件，线程一直等待     */    private static class CheckKm extends Thread {        @Override        public void run() {            express.waitKm();        }    }    /**     * 检查地点变化的线程,不满足条件，线程一直等待     */    private static class CheckSite extends Thread {        @Override        public void run() {            express.waitSite();        }    }    public static void main(String[] args) throws InterruptedException {        for (int i = 0; i &lt; 3; i++) {            new ExpressCond.CheckSite().start();        }        for (int i = 0; i &lt; 3; i++) {            new ExpressCond.CheckKm().start();        }        Thread.sleep(1000);        express.changeKm();//快递里程变化    }}    </code></pre><h2 id="了解LockSupport工具"><a href="#了解LockSupport工具" class="headerlink" title="了解LockSupport工具"></a>了解LockSupport工具</h2><p>LockSupport定义了一组的公共静态方法，这些方法提供了最基本的线程阻塞和唤醒功能，而LockSupport也成为构建同步组件的基础工具。</p><p>LockSupport定义了一组以park开头的方法用来阻塞当前线程，以及unpark(Thread thread)方法来唤醒一个被阻塞的线程。在JDK1.6之后LockSupport增加了park(Object blocker)、parkNanos(Object blocker,long nanos)和parkUntil(Object blocker,long deadline)3个方法，便于问题排查和系统监控，其中参数blocker是用来标识当前线程在等待的对象即被阻塞对象。</p><h2 id="CLH队列锁"><a href="#CLH队列锁" class="headerlink" title="CLH队列锁"></a>CLH队列锁</h2><p>CLH队列锁即Craig, Landin, and Hagersten (CLH) locks。</p><p>CLH队列锁也是一种基于链表的可扩展、高性能、公平的自旋锁，申请线程仅仅在本地变量上自旋，它不断轮询前驱的状态，假设发现前驱释放了锁就结束自旋。</p><p>当一个线程需要获取锁时会创建一个的QNode，将其中的locked设置为true表示需要获取锁，myPred表示对其前驱结点的引用</p><img src="/2019/12/30/%E6%98%BE%E5%BC%8F%E9%94%81%E5%92%8CAQS/pic1.png" srcset="/img/loading.gif" class=""><p>线程A对tail域调用getAndSet方法，使自己成为队列的尾部，同时获取一个指向其前驱结点的引用myPred</p><img src="/2019/12/30/%E6%98%BE%E5%BC%8F%E9%94%81%E5%92%8CAQS/pic2.png" srcset="/img/loading.gif" class=""><p>线程B需要获得锁，同样的流程再来一遍</p><img src="/2019/12/30/%E6%98%BE%E5%BC%8F%E9%94%81%E5%92%8CAQS/pic3.png" srcset="/img/loading.gif" class=""><p>线程就在前驱结点的locked字段上旋转，直到前驱结点释放锁(前驱节点的锁值 locked == false)</p><p>当一个线程需要释放锁时，将当前结点的locked域设置为false，同时回收前驱结点</p><img src="/2019/12/30/%E6%98%BE%E5%BC%8F%E9%94%81%E5%92%8CAQS/pic4.png" srcset="/img/loading.gif" class=""><p>如上图所示，前驱结点释放锁，线程A的myPred所指向的前驱结点的locked字段变为false，线程A就可以获取到锁。</p><p>CLH队列锁的优点是空间复杂度低（如果有n个线程，L个锁，每个线程每次只获取一个锁，那么需要的存储空间是O（L+n），n个线程有n个myNode，L个锁有L个tail）。CLH队列锁常用在SMP体系结构下。</p><p>Java中的AQS是CLH队列锁的一种变体实现。</p><p><strong>扩展知识点</strong></p><p>SMP(Symmetric Multi-Processor)。即对称多处理器结构，指server中多个CPU对称工作，每一个CPU访问内存地址所需时间同样。其主要特征是共享，包括对CPU，内存，I/O等进行共享。SMP的长处是可以保证内存一致性。缺点是这些共享的资源非常可能成为性能瓶颈。随着CPU数量的添加，每一个CPU都要访问同样的内存资源，可能导致内存访问冲突，可能会导致CPU资源的浪费。经常使用的PC机就属于这样的。</p><img src="/2019/12/30/%E6%98%BE%E5%BC%8F%E9%94%81%E5%92%8CAQS/pic5.png" srcset="/img/loading.gif" class=""><p>非一致存储访问，将CPU分为CPU模块，每个CPU模块由多个<em>CPU*组成，并且具有独立的本地内存、I/O槽口等，模块之间可以通过互联模块相互访问，访问本地内存（本CPU模块的内存）的速度将远远高于访问远地内存</em>(<em>其他CPU模块的内存</em>)*的速度，这也是非一致存储访问的由来。NUMA较好地解决SMP的扩展问题，当CPU数量增加时，因为访问远地内存的延时远远超过本地内存，系统性能无法线性增加。</p><img src="/2019/12/30/%E6%98%BE%E5%BC%8F%E9%94%81%E5%92%8CAQS/pic6.png" srcset="/img/loading.gif" class=""><p>CLH唯一的缺点是在NUMA系统结构下性能很差，但是在SMP系统结构下该法还是非常有效的。解决NUMA系统结构的思路是MCS队列锁。</p><h2 id="AbstractQueuedSynchronizer深入分析"><a href="#AbstractQueuedSynchronizer深入分析" class="headerlink" title="AbstractQueuedSynchronizer深入分析"></a>AbstractQueuedSynchronizer深入分析</h2><h3 id="学习AQS的必要性"><a href="#学习AQS的必要性" class="headerlink" title="学习AQS的必要性"></a>学习AQS的必要性</h3><p>队列同步器AbstractQueuedSynchronizer（以下简称同步器或AQS），是用来构建锁或者其他同步组件的基础框架，它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。并发包的大师（Doug Lea）期望它能够成为实现大部分同步需求的基础。</p><h3 id="AQS使用方式和其中的设计模式"><a href="#AQS使用方式和其中的设计模式" class="headerlink" title="AQS使用方式和其中的设计模式"></a>AQS使用方式和其中的设计模式</h3><p>AQS的主要使用方式是继承，子类通过继承AQS并实现它的抽象方法来管理同步状态，在AQS里由一个int型的state来代表这个状态，在抽象方法的实现过程中免不了要对同步状态进行更改，这时就需要使用同步器提供的3个方法（getState()、setState(int newState)和compareAndSetState(int expect,int update)）来进行操作，因为它们能够保证状态的改变是安全的。</p><p>AQS自身没有实现任何同步接口，它仅仅是定义了若干同步状态获取和释放的方法来供自定义同步组件使用，同步器既可以支持独占式地获取同步状态，也可以支持共享式地获取同步状态，这样就可以方便实现不同类型的同步组件（ReentrantLock、ReentrantReadWriteLock和CountDownLatch等）。</p><p>同步器是实现锁（也可以是任意同步组件）的关键，在锁的实现中聚合同步器。可以这样理解二者之间的关系：锁是面向使用者的，它定义了使用者与锁交互的接口（比如可以允许两个线程并行访问），隐藏了实现细节；同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。锁和同步器很好地隔离了使用者和实现者所需关注的领域。</p><p>实现者需要继承同步器并重写指定的方法，随后将同步器组合在自定义同步组件的实现中，并调用同步器提供的模板方法，而这些模板方法将会调用使用者重写的方法。</p><h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><p>同步器的设计基于模板方法模式。模板方法模式的意图是，定义一个操作中的算法的骨架，而将一些步骤的实现延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。我们最常见的就是Spring框架里的各种Template。</p><p>实际例子</p><p>假设蛋糕店中奶油蛋糕，芝士蛋糕和慕斯蛋糕。这三种蛋糕在制作方式上一样，都包括造型，烘焙和涂抹蛋糕上的东西。所以可以定义一个抽象蛋糕模型</p><pre><code>/** * 类说明：抽象蛋糕模型 */public abstract class AbstractCake {    protected abstract void shape();    protected abstract void apply();    protected abstract void brake();    /*模板方法*/    public final void run(){        this.shape();        this.apply();        this.brake();    }    protected boolean shouldApply(){        return true;    }}</code></pre><p>然后就可以批量生产三种蛋糕</p><pre><code>/** * 类说明：芝士蛋糕 */public class CheeseCake  extends AbstractCake {    @Override    protected void shape() {        System.out.println(&quot;芝士蛋糕造型&quot;);    }    @Override    protected void apply() {        System.out.println(&quot;芝士蛋糕涂抹&quot;);    }    @Override    protected void brake() {        System.out.println(&quot;芝士蛋糕烘焙&quot;);    }}</code></pre><p>这样一来，不但可以批量生产三种蛋糕，而且如果日后有扩展，只需要继承抽象蛋糕方法就可以了，突然有一天，我们发现市面有一种最简单的小蛋糕销量很好，这种蛋糕就是简单烘烤成型就可以卖，并不需要涂抹什么食材，于是我们也想要生产这种蛋糕。但是我们发现了一个问题，抽象蛋糕是定义了抽象的涂抹方法的，也就是说扩展的这种蛋糕是必须要实现涂抹方法，这时可以将原来的模板修改为带钩子的模板。</p><pre><code>/** * 类说明：抽象蛋糕模型 */public abstract class AbstractCake {    protected abstract void shape();    protected abstract void apply();    protected abstract void brake();    /*模板方法*/    public final void run() {        this.shape();        if (shouldApply()) {            this.apply();        }        this.brake();    }    protected boolean shouldApply(){        return true;    }}</code></pre><p>做小蛋糕的时候通过flag来控制是否涂抹，其余已有的蛋糕制作不需要任何修改可以照常进行。</p><pre><code>/** * 类说明：小蛋糕 */public class SmallCake extends AbstractCake {    private boolean flag = false;    public void setFlag(boolean shouldApply){        flag = shouldApply;    }    @Override    protected boolean shouldApply() {        return this.flag;    }    @Override    protected void shape() {        System.out.println(&quot;小蛋糕造型&quot;);    }    @Override    protected void apply() {        System.out.println(&quot;小蛋糕涂抹&quot;);    }    @Override    protected void brake() {        System.out.println(&quot;小蛋糕烘焙&quot;);    }}</code></pre><h3 id="AQS中的方法"><a href="#AQS中的方法" class="headerlink" title="AQS中的方法"></a>AQS中的方法</h3><h4 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h4><p>实现自定义同步组件时，将会调用同步器提供的模板方法，</p><table><thead><tr><th align="center">方法名称</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">void acquire(int arg)</td><td align="center">独占式获取同步状态，如果当前线程获取同步状态成功，则由该方法返回，否则，将会进人同步队列等待，该方法将会调用重写的tryAcquire(int  arg)方法</td></tr><tr><td align="center">void acquireInterruptibly(int arg)</td><td align="center">与acquire(int arg)相同，但是该方法响应中断，当前线程未获取到同步状态而进入同步队列中，如果当前线程被中断，则该方法会抛出InterruptedException并返回</td></tr><tr><td align="center">boolean tryAcquireNanos(int arg,long nanos)</td><td align="center">在acquireInterruptibly(int arg)基础上增加了超时限制，如果当前线程在超时时间内没有获取到同步状态，那么将会返回false.如果获取到了返回true</td></tr><tr><td align="center">void acquireShared(int arg)</td><td align="center">共享式的获取同步状态，如果当前线程未获取到同步状态,将会进人同步队列等待，与独占式获取的主要区别是在同一时刻可以有多个线程获取到同步状态</td></tr><tr><td align="center">void acquireSharedInteruptibly(int arg)</td><td align="center">与acquireShared(int arg)相同，该方法响应中断</td></tr><tr><td align="center">boolean tryAcquireSharedNanos(int arg, long nanos)</td><td align="center">在acquireSharedInterruptibly(int arg)基础上增加了超时限制</td></tr><tr><td align="center">boolean release(int arg)</td><td align="center">独占式的释放同步状态，该方法会在释放同步状态之后，将同步队列中第一个节点包含的线程唤醒</td></tr><tr><td align="center">boolean releaseShared(int arg)</td><td align="center">共享式的释放同步状态</td></tr><tr><td align="center">Collection&lt; Thread&gt; getQueuedThreads()</td><td align="center">获取等待在同步队列上的线程集合</td></tr></tbody></table><p>这些模板方法同步器提供的模板方法基本上分为3类：独占式获取与释放同步状态、共享式获取与释放、同步状态和查询同步队列中的等待线程情况。</p><h4 id="可重写的方法"><a href="#可重写的方法" class="headerlink" title="可重写的方法"></a>可重写的方法</h4><table><thead><tr><th align="center">方法名称</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">protected boolean tryAcquire(int arg)</td><td align="center">独占式获取同步状态，实现该方法需要查询当前状态并判断同步状态是否符合预期，然后再进行CAS设置同步状态</td></tr><tr><td align="center">protected boolean tryRelease(int arg)</td><td align="center">独占式释放同步状态，等待获取同步状态的线程将有机会获取同步状态</td></tr><tr><td align="center">protected int tryAcquireShared(int arg)</td><td align="center">共享式获取同步状态，返回大于等于0的值，表示获取成功，反之，获取失败</td></tr><tr><td align="center">protected boolean tryReleaseShared(int arg)</td><td align="center">共享式释放同步状态</td></tr><tr><td align="center">protected boolean isHeldExclusively()</td><td align="center">当前同步器是否在独占模式下被线程占用，一般该方法表示是否被当前线程所独占</td></tr></tbody></table><h4 id="访问或修改同步状态的方法"><a href="#访问或修改同步状态的方法" class="headerlink" title="访问或修改同步状态的方法"></a>访问或修改同步状态的方法</h4><p>重写同步器指定的方法时，需要使用同步器提供的如下3个方法来访问或修改同步状态。</p><ul><li><p>getState()：获取当前同步状态。</p></li><li><p>setState(int newState)：设置当前同步状态。</p></li><li><p>compareAndSetState(int expect,int update)：使用CAS设置当前状态，该方法能够保证状态设置的原子性。 </p></li></ul><h3 id="实现一个自己的独占锁"><a href="#实现一个自己的独占锁" class="headerlink" title="实现一个自己的独占锁"></a>实现一个自己的独占锁</h3><pre><code>public class SelfLock implements Lock {    /**     * 静态内部类，自定义同步器     */    private static class Sync extends AbstractQueuedSynchronizer {        //private static final long serialVersionUID = -4387327721959839431L;        /**         * 是否处于占用状态         */        @Override        protected boolean isHeldExclusively() {            return getState() == 1;        }        /**         * 获得锁         */        @Override        protected boolean tryAcquire(int arg) {            if (compareAndSetState(0, 1)) {                setExclusiveOwnerThread(Thread.currentThread());                return true;            }            return false;        }        /**         * 释放锁         */        @Override        protected boolean tryRelease(int arg) {            if (getState() == 0) {                throw new IllegalMonitorStateException();            }            setExclusiveOwnerThread(null);            setState(0);            return true;        }        /**         * 返回一个Condition，每个condition都包含了一个condition队列         */        Condition newCondition() {            return new ConditionObject();        }    }    /**     * 仅需要将操作代理到Sync上即可     */    private final Sync sync = new Sync();    @Override    public void lock() {        System.out.println(Thread.currentThread().getName() + &quot; ready get lock&quot;);        sync.acquire(1);        System.out.println(Thread.currentThread().getName() + &quot; already got lock&quot;);    }    @Override    public boolean tryLock() {        return sync.tryAcquire(1);    }    @Override    public void unlock() {        System.out.println(Thread.currentThread().getName() + &quot; ready release lock&quot;);        sync.release(1);        System.out.println(Thread.currentThread().getName() + &quot; already released lock&quot;);    }    @Override    public Condition newCondition() {        return sync.newCondition();    }    public boolean isLocked() {        return sync.isHeldExclusively();    }    public boolean hasQueuedThreads() {        return sync.hasQueuedThreads();    }    @Override    public void lockInterruptibly() throws InterruptedException {        sync.acquireInterruptibly(1);    }    @Override    public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException {        return sync.tryAcquireNanos(1, unit.toNanos(timeout));    }}</code></pre><p><strong>测试类</strong></p><pre><code>public class TestMyLock {    public void test() {        final Lock lock = new SelfLock();        class Worker extends Thread {         @Override            public void run() {                lock.lock();                System.out.println(Thread.currentThread().getName());                try {                    SleepTools.second(1);                } finally {                    lock.unlock();                }            }        }        // 启动4个子线程        for (int i = 0; i &lt; 4; i++) {            Worker w = new Worker();            //w.setDaemon(true);            w.start();        }        // 主线程每隔1秒换行        for (int i = 0; i &lt; 10; i++) {           SleepTools.second(1);            //System.out.println();        }    }    public static void main(String[] args) {        TestMyLock testMyLock = new TestMyLock();        testMyLock.test();    }}</code></pre><h3 id="AQS中的数据结构节点和同步队列"><a href="#AQS中的数据结构节点和同步队列" class="headerlink" title="AQS中的数据结构节点和同步队列"></a>AQS中的数据结构节点和同步队列</h3><img src="/2019/12/30/%E6%98%BE%E5%BC%8F%E9%94%81%E5%92%8CAQS/pic8.png" srcset="/img/loading.gif" class=""><h4 id="节点Node"><a href="#节点Node" class="headerlink" title="节点Node"></a>节点Node</h4><p>既然说Java中的AQS是CLH队列锁的一种变体实现，毫无疑问，作为队列来说，必然要有一个节点的数据结构来保存我们前面所说的各种域，比如前驱节点，节点的状态等，这个数据结构就是AQS中的内部类Node。作为这个数据结构应该保存的信息：</p><ol><li>前驱和后继线程，因为是一个等待队列，那么也就需要知道当前线程前面的是哪个线程，当前线程后面的是哪个线程（因为当前线程释放锁以后，理当立马通知后继线程去获取锁）。</li><li>线程信息</li><li>队列中线程状态，是取消了“获锁”请求，还是在“”等待中”，或者说“即将得到锁”</li></ol><h4 id="Node类的设计"><a href="#Node类的设计" class="headerlink" title="Node类的设计"></a>Node类的设计</h4><img src="/2019/12/30/%E6%98%BE%E5%BC%8F%E9%94%81%E5%92%8CAQS/pic7.png" srcset="/img/loading.gif" class=""><p>线程的2种等待模式：</p><ul><li><p>SHARED：表示线程以共享的模式等待锁（如ReadLock）</p></li><li><p>EXCLUSIVE：表示线程以互斥的模式等待锁（如ReetrantLock）</p></li></ul><p>线程在队列中的状态枚举：</p><ul><li><p>CANCELLED：值为1，表示线程已经取消获取锁的请求</p></li><li><p>SIGNAL：值为-1，表示该线程已经准备就绪，等待获取锁</p></li><li><p>CONDITION：值为-2，表示线程等待某一个条件（Condition）被满足</p></li><li><p>PROPAGATE：值为-3，表示下一个的acquireShared值应该被无条件的传播下去，在线程处于SHARED模式时才会被用到。</p></li></ul><p>成员变量：</p><ul><li><p>waitStatus：该int变量表示线程在队列中的状态，其值就是上述提到的CANCELLED、SIGNAL、CONDITION、PROPAGATE</p></li><li><p>prev：该变量类型为Node对象，表示该节点的前一个Node节点（前驱）</p></li><li><p>next：该变量类型为Node对象，表示该节点的后一个Node节点（后继）</p></li><li><p>thread：该变量类型为Thread对象，表示该节点的代表的线程</p></li><li><p>nextWaiter：该变量类型为Node对象，表示等待condition条件的Node节点</p></li></ul><p>当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成为一个节点（Node）并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步状态。同步队列中的节点（Node）用来保存获取同步状态失败的线程引用、等待状态以及前驱和后继节点。</p><h4 id="head和tail"><a href="#head和tail" class="headerlink" title="head和tail"></a>head和tail</h4><p>AQS还拥有首节点（head）和尾节点（tail）两个引用，一个指向队列头节点，而另一个指向队列尾节点。</p><p>注意 ：因为首节点<em>head</em>是不保存线程信息的节点，仅仅是因为数据结构设计上的需要，在数据结构上，这种做法往往叫做“空头节点链表”，对应的就有“非空头结点链表”。</p><h4 id="节点在同步队列中的增加和移出"><a href="#节点在同步队列中的增加和移出" class="headerlink" title="节点在同步队列中的增加和移出"></a>节点在同步队列中的增加和移出</h4><h5 id="节点加入到同步队列"><a href="#节点加入到同步队列" class="headerlink" title="节点加入到同步队列"></a>节点加入到同步队列</h5><p>当一个线程成功地获取了同步状态（或者锁），其他线程将无法获取到同步状态，也就是获取同步状态失败，AQS会通过addWaiter()方法将这个线程以及等待状态等信息构造成为一个节点（Node）并将其加入同步队列的尾部。而这个加入队列的过程必须要保证线程安全，因此同步器提供了一个基于CAS的设置尾节点的方法：compareAndSetTail(Node expect,Nodeupdate)，AQS它需要传递当前线程“认为”的尾节点和当前节点，只有设置成功后，当前节点才正式与之前的尾节点建立关联。</p><img src="/2019/12/30/%E6%98%BE%E5%BC%8F%E9%94%81%E5%92%8CAQS/pic9.png" srcset="/img/loading.gif" class=""><h5 id="首节点的变化"><a href="#首节点的变化" class="headerlink" title="首节点的变化"></a>首节点的变化</h5><p>首节点是获取同步状态成功的节点，首节点的线程在释放同步状态时，将会唤醒后继节点，而后继节点将会在获取同步状态成功时将自己设置为首节点。设置首节点是通过获取同步状态成功的线程来完成的，由于只有一个线程能够成功获取到同步状态，因此设置头节点的方法并不需要使用CAS来保证，它只需要将首节点设置成为原首节点的后继节点并断开原首节点的next引用即可。</p><img src="/2019/12/30/%E6%98%BE%E5%BC%8F%E9%94%81%E5%92%8CAQS/pic10.png" srcset="/img/loading.gif" class=""><h5 id="独占式同步状态获取与释放"><a href="#独占式同步状态获取与释放" class="headerlink" title="独占式同步状态获取与释放"></a>独占式同步状态获取与释放</h5><img src="/2019/12/30/%E6%98%BE%E5%BC%8F%E9%94%81%E5%92%8CAQS/pic11.png" srcset="/img/loading.gif" class=""><h6 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h6><p>通过调用同步器的acquire(int arg)方法可以获取同步状态，主要完成了同步状态获取、节点构造、加入同步队列以及在同步队列中自旋等待的相关工作，其主要逻辑是：</p><p>首先调用自定义同步器实现的tryAcquire(int arg)方法，该方法需要保证线程安全的获取同步状态。</p><p>如果同步状态获取失败（tryAcquire返回false），则构造同步节点（独占式Node.EXCLUSIVE，同一时刻只能有一个线程成功获取同步状态）并通过addWaiter(Node node)方法将该节点加入到同步队列的尾部，在addWaiter()方法中会尝试通过compareAndSetTail()方法设置首尾节点关系，如果设置不成功才会进入enq()方法循环尝试设置节点关系。</p><p>最后调用acquireQueued(Node node,int arg)方法，使得该节点以“死循环”的方式获取同步状态。如果获取不到则阻塞节点中的线程，而被阻塞线程的唤醒主要依靠前驱节点的出队或阻塞线程被中断来实现。</p><p>addWaiter(Node node)方法中</p><img src="/2019/12/30/%E6%98%BE%E5%BC%8F%E9%94%81%E5%92%8CAQS/pic12.png" srcset="/img/loading.gif" class=""><p>将当前线程包装成Node后，队列不为空的情况下，先尝试把当前节点加入队列并成为尾节点，如果不成功或者队列为空进入enq(final Node node)方法。</p><img src="/2019/12/30/%E6%98%BE%E5%BC%8F%E9%94%81%E5%92%8CAQS/pic13.png" srcset="/img/loading.gif" class=""><p>在enq(final Node node)方法中，同步器通过“死循环”来保证节点的正确添加，这个死循环中，做了两件事，第一件，如果队列为空，初始化队列，new出一个空节点，并让<strong>首节点</strong>（head）和<strong>尾节点</strong>（tail）两个引用都指向这个空节点；第二件事，把当前节点加入队列。</p><p>在“死循环”中只有通过CAS将节点设置成为尾节点之后，当前线程才能从该方法返回，否则，当前线程不断地尝试设置。</p><p>节点进入同步队列之后，观察acquireQueued(Node node,int arg)方法</p><img src="/2019/12/30/%E6%98%BE%E5%BC%8F%E9%94%81%E5%92%8CAQS/pic14.png" srcset="/img/loading.gif" class=""><p>其实就是一个自旋的过程，每个节点（或者说每个线程）都在自省地观察，当条件满足，获取到了同步状态，就可以从这个自旋过程中退出，否则依旧留在这个自旋过程中（并会阻塞节点的线程）。</p><p>在acquireQueued(final Node node,int arg)方法中，当前线程在“死循环”中尝试获取同步状态，而只有前驱节点是头节点才能够尝试获取同步状态，这是为什么？原因有两个。</p><p>第一，头节点是成功获取到同步状态的节点，而头节点的线程释放了同步状态之后，将会唤醒其后继节点，后继节点的线程被唤醒后需要检查自己的前驱节点是否是头节点。</p><p>第二，维护同步队列的FIFO原则。</p><p>当前线程获取到同步状态后，让<strong>首节点</strong>（head）这个引用指向自己所在节点。当同步状态获取成功后，当前线程就从acquire方法返回了。如果同步器实现的是锁，那就代表当前线程获得了锁。</p><h6 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h6><p>当前线程获取同步状态并执行了相应逻辑之后，就需要释放同步状态，使得后续节点能够继续获取同步状态。通过调用同步器的release(int arg)方法可以释放同步状态，该方法在释放了同步状态之后，会唤醒其后继节点（进而使后继节点重新尝试获取同步状态）。</p><img src="/2019/12/30/%E6%98%BE%E5%BC%8F%E9%94%81%E5%92%8CAQS/pic15.png" srcset="/img/loading.gif" class=""><p>该方法执行时，会唤醒<strong>首节点</strong>（head）所指向节点的后继节点线程，unparkSuccessor(Node node)方法使用LockSupport来唤醒处于等待状态的线程。</p><p>而在unparkSuccessor中， </p><img src="/2019/12/30/%E6%98%BE%E5%BC%8F%E9%94%81%E5%92%8CAQS/pic16.png" srcset="/img/loading.gif" class=""><p>这段代码的意思，一般情况下，被唤醒的是head指向节点的后继节点线程，如果这个后继节点处于被cancel状态，（我推测开发者的思路这样的：后继节点处于被cancel状态，意味着当锁竞争激烈时，队列的第一个节点等了很久（一直被还未加入队列的节点抢走锁），包括后续的节点cancel的几率都比较大，所以）先从尾开始遍历，找到最前面且没有被cancel的节点。</p><h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><p>在获取同步状态时，同步器维护一个同步队列，获取状态失败的线程都会被加入到队列中并在队列中进行自旋；移出队列（或停止自旋）的条件是前驱节点为头节点且成功获取了同步状态。在释放同步状态时，同步器调用tryRelease(int arg)方法释放同步状态，然后唤醒head指向节点的后继节点。</p><h5 id="共享式同步状态获取与释放"><a href="#共享式同步状态获取与释放" class="headerlink" title="共享式同步状态获取与释放"></a>共享式同步状态获取与释放</h5><p>共享式获取与独占式获取最主要的区别在于同一时刻能否有多个线程同时获取到同步状态。以读写为例，如果一个程序在进行读操作，那么这一时刻写操作均被阻塞，而读操作能够同时进行。写操作要求对资源的独占式访问，而读操作可以是共享式访问。</p><p>在acquireShared(int arg)方法中，同步器调用tryAcquireShared(int arg)方法尝试获取同步状态，tryAcquireShared(int arg)方法返回值为int类型，当返回值大于等于0时，表示能够获取到同步状态。因此，在共享式获取的自旋过程中，成功获取到同步状态并退出自旋的条件就是tryAcquireShared(int arg)方法返回值大于等于0。可以看到，在doAcquireShared(int arg)方法的自旋过程中，如果当前节点的前驱为头节点时，尝试获取同步状态，如果返回值大于等于0，表示该次获取同步状态成功并从自旋过程中退出。</p><p>该方法在释放同步状态之后，将会唤醒后续处于等待状态的节点。对于能够支持多个线程同时访问的并发组件（比如Semaphore），它和独占式主要区别在于tryReleaseShared(int arg)方法必须确保同步状态（或者资源数）线程安全释放，一般是通过循环和CAS来保证的，因为释放同步状态的操作会同时来自多个线程。</p><h5 id="共享式的同步工具类"><a href="#共享式的同步工具类" class="headerlink" title="共享式的同步工具类"></a>共享式的同步工具类</h5><p>设计一个同步工具：该工具在同一时刻，只允许至多3个线程同时访问，超过3个线程的访问将被阻塞。</p><p>首先，确定访问模式。TrinityLock能够在同一时刻支持多个线程的访问，这显然是共享式访问，因此，需要使用同步器提供的acquireShared(int args)方法等和Shared相关的方法，这就要求TwinsLock必须重写tryAcquireShared(int args)方法和tryReleaseShared(int args)方法，这样才能保证同步器的共享式同步状态的获取与释放方法得以执行。</p><p>其次，定义资源数。TrinityLock在同一时刻允许至多三个线程的同时访问，表明同步资源数为3，这样可以设置初始状态status为3，当一个线程进行获取，status减1，该线程释放，则status加1，状态的合法范围为0、1和2,3，其中0表示当前已经有3个线程获取了同步资源，此时再有其他线程对同步状态进行获取，该线程只能被阻塞。在同步状态变更时，需要使用compareAndSet(int expect,int update)方法做原子性保障。</p><p>最后，组合自定义同步器。前面的章节提到，自定义同步组件通过组合自定义同步器来完成同步功能，一般情况下自定义同步器会被定义为自定义同步组件的内部类。</p><pre><code>/** *类说明：共享同步工具类 */public class TrinityLock  implements Lock {    //为n表示允许n个线程同时获得锁    private final Sync sync = new Sync(4);    private static final class Sync extends AbstractQueuedSynchronizer {        //private static final long serialVersionUID = -7889272986162341211L;        Sync(int count) {            if (count &lt;= 0) {                throw new IllegalArgumentException(&quot;count must large than zero.&quot;);            }            setState(count);        }        /**         *         * @param reduceCount  扣减个数         * @return  返回小于0，表示当前线程获得同步状态失败         * 大于0，表示当前线程获得同步状态成功         */        public int tryAcquireShared(int reduceCount) {            for (;;) {                int current = getState();                int newCount = current - reduceCount;                if (newCount &lt; 0 || compareAndSetState(current, newCount)) {                    return newCount;                }            }        }        /**         *         * @param returnCount 归还个数         * @return         */        public boolean tryReleaseShared(int returnCount) {            for (;;) {                int current = getState();                int newCount = current + returnCount;                if (compareAndSetState(current, newCount)) {                    return true;                }            }        }        final ConditionObject newCondition() {            return new ConditionObject();        }    }    public void lock() {        sync.acquireShared(1);    }    public void unlock() {        sync.releaseShared(1);    }    public void lockInterruptibly() throws InterruptedException {        sync.acquireSharedInterruptibly(1);    }    public boolean tryLock() {        return sync.tryAcquireShared(1) &gt;= 0;    }    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {        return sync.tryAcquireSharedNanos(1, unit.toNanos(time));    }    @Override    public Condition newCondition() {        return sync.newCondition();    }}</code></pre><h3 id="Condition分析"><a href="#Condition分析" class="headerlink" title="Condition分析"></a>Condition分析</h3><h4 id="Condition的数据结构"><a href="#Condition的数据结构" class="headerlink" title="Condition的数据结构"></a>Condition的数据结构</h4><p>等待队列是一个FIFO的队列，在队列中的每个节点都包含了一个线程引用，该线程就是在Condition对象上等待的线程，如果一个线程调用了Condition.await()方法，那么该线程将会释放锁、构造成节点加入等待队列并进入等待状态。事实上，节点的定义复用了同步器中节点的定义，也就是说，同步队列和等待队列中节点类型都是同步器的静态内部类。</p><img src="/2019/12/30/%E6%98%BE%E5%BC%8F%E9%94%81%E5%92%8CAQS/pic17.png" srcset="/img/loading.gif" class=""><p>一个Condition包含一个等待队列，Condition拥有首节点（firstWaiter）和尾节点（lastWaiter）。当前线程调用Condition.await()方法，将会以当前线程构造节点，并将节点从尾部加入等待队列。Condition拥有首尾节点的引用，而新增节点只需要将原有的尾节点nextWaiter指向它，并且更新尾节点即可。上述节点引用更新的过程并没有使用CAS保证，原因在于调用await()方法的线程必定是获取了锁的线程，也就是说该过程是由锁来保证线程安全的。</p><p>Lock（更确切地说是同步器）拥有一个同步队列和多个等待队列。</p><img src="/2019/12/30/%E6%98%BE%E5%BC%8F%E9%94%81%E5%92%8CAQS/pic18.png" srcset="/img/loading.gif" class=""><p>调用Condition的await()方法（或者以await开头的方法），会使当前线程进入等待队列并释放锁，同时线程状态变为等待状态。当从await()方法返回时，当前线程一定获取了Condition相关联的锁。</p><p>如果从队列（同步队列和等待队列）的角度看await()方法，当调用await()方法时，相当于同步队列的首节点（获取了锁的节点）移动到Condition的等待队列中。调用该方法的线程成功获取了锁的线程，也就是同步队列中的首节点，该方法会将当前线程构造成节点并加入等待队列中，然后释放同步状态，唤醒同步队列中的后继节点，然后当前线程会进入等待状态。当等待队列中的节点被唤醒，则唤醒节点的线程开始尝试获取同步状态。如果不是通过其他线程调用Condition.signal()方法唤醒，而是对等待线程进行中断，则会抛出InterruptedException。</p><img src="/2019/12/30/%E6%98%BE%E5%BC%8F%E9%94%81%E5%92%8CAQS/pic19.png" srcset="/img/loading.gif" class=""><p>如图所示，同步队列的首节点并不会直接加入等待队列，而是通过addConditionWaiter()方法把当前线程构造成一个新的节点并将其加入等待队列中。</p><img src="/2019/12/30/%E6%98%BE%E5%BC%8F%E9%94%81%E5%92%8CAQS/pic20.png" srcset="/img/loading.gif" class=""><p>调用Condition的signal()方法，将会唤醒在等待队列中等待时间最长的节点（首节点），在唤醒节点之前，会将节点移到同步队列中。</p><p>调用该方法的前置条件是当前线程必须获取了锁，可以看到signal()方法进行了isHeldExclusively()检查，也就是当前线程必须是获取了锁的线程。接着获取等待队列的首节点，将其移动到同步队列并使用LockSupport唤醒节点中的线程。</p><p>通过调用同步器的enq(Node node)方法，等待队列中的头节点线程安全地移动到同步队列。当节点移动到同步队列后，当前线程再使用LockSupport唤醒该节点的线程。</p><p>被唤醒后的线程，将从await()方法中的while循环中退出（isOnSyncQueue(Node node)方法返回true，节点已经在同步队列中），进而调用同步器的acquireQueued()方法加入到获取同步状态的竞争中。</p><p>成功获取同步状态（或者说锁）之后，被唤醒的线程将从先前调用的await()方法返回，此时该线程已经成功地获取了锁。</p><p>Condition的signalAll()方法，相当于对等待队列中的每个节点均执行一次signal()方法，效果就是将等待队列中所有节点全部移动到同步队列中，并唤醒每个节点的线程。</p><h2 id="Lock的实现"><a href="#Lock的实现" class="headerlink" title="Lock的实现"></a>Lock的实现</h2><h3 id="ReentrantLock的实现"><a href="#ReentrantLock的实现" class="headerlink" title="ReentrantLock的实现"></a>ReentrantLock的实现</h3><h4 id="锁的可重入"><a href="#锁的可重入" class="headerlink" title="锁的可重入"></a>锁的可重入</h4><p>重进入是指任意线程在获取到锁之后能够再次获取该锁而不会被锁所阻塞，该特性的实现需要解决以下两个问题。</p><ol><li><p>线程再次获取锁。锁需要去识别获取锁的线程是否为当前占据锁的线程，如果是，则再次成功获取。</p></li><li><p>锁的最终释放。线程重复n次获取了锁，随后在第n次释放该锁后，其他线程能够获取到该锁。锁的最终释放要求锁对于获取进行计数自增，计数表示当前锁被重复获取的次数，而锁被释放时，计数自减，当计数等于0时表示锁已经成功释放。</p></li></ol><p>nonfairTryAcquire方法增加了再次获取同步状态的处理逻辑：通过判断当前线程是否为获取锁的线程来决定获取操作是否成功，如果是获取锁的线程再次请求，则将同步状态值进行增加并返回true，表示获取同步状态成功。同步状态表示锁被一个线程重复获取的次数。</p><p>如果该锁被获取了n次，那么前(n-1)次tryRelease(int releases)方法必须返回false，而只有同步状态完全释放了，才能返回true。可以看到，该方法将同步状态是否为0作为最终释放的条件，当同步状态为0时，将占有线程设置为null，并返回true，表示释放成功。</p><h4 id="公平和非公平锁"><a href="#公平和非公平锁" class="headerlink" title="公平和非公平锁"></a>公平和非公平锁</h4><p>ReentrantLock的构造函数中，默认的无参构造函数将会把Sync对象创建为NonfairSync对象，这是一个“非公平锁”；而另一个构造函数ReentrantLock(boolean fair)传入参数为true时将会把Sync对象创建为“公平锁”FairSync。公平锁的tryAcquire()方法与非公平锁的nonfairTryAcquire(int acquires)相比，唯一不同的位置为判断条件多了hasQueuedPredecessors()方法，即加入了同步队列中当前节点是否有前驱节点的判断，如果该方法返回true，则表示有线程比当前线程更早地请求获取锁，因此需要等待前驱线程获取并释放锁之后才能继续获取锁，而非公平锁只要CAS设置同步状态成功，则表示当前线程获取了锁。</p><h4 id="改造之前的独占锁为可重入"><a href="#改造之前的独占锁为可重入" class="headerlink" title="改造之前的独占锁为可重入"></a>改造之前的独占锁为可重入</h4><pre><code>/** *类说明：实现我们自己独占锁,可重入 */public class ReenterSelfLock implements Lock {    // 静态内部类，自定义同步器    private static class Sync extends AbstractQueuedSynchronizer {        // 是否处于占用状态        protected boolean isHeldExclusively() {            return getState() &gt; 0;        }        // 当状态为0的时候获取锁        public boolean tryAcquire(int acquires) {            if (compareAndSetState(0, 1)) {                setExclusiveOwnerThread(Thread.currentThread());                return true;            }else if(getExclusiveOwnerThread()==Thread.currentThread()){                setState(getState()+1);                return  true;            }            return false;        }        // 释放锁，将状态设置为0        protected boolean tryRelease(int releases) {            if(getExclusiveOwnerThread()!=Thread.currentThread()){                throw new IllegalMonitorStateException();            }            if (getState() == 0)                throw new IllegalMonitorStateException();            setState(getState()-1);            if(getState()==0){                setExclusiveOwnerThread(null);            }            return true;        }        // 返回一个Condition，每个condition都包含了一个condition队列        Condition newCondition() {            return new ConditionObject();        }    }    // 仅需要将操作代理到Sync上即可    private final Sync sync = new Sync();    public void lock() {       System.out.println(Thread.currentThread().getName()+&quot; ready get lock&quot;);        sync.acquire(1);        System.out.println(Thread.currentThread().getName()+&quot; already got lock&quot;);    }    public boolean tryLock() {        return sync.tryAcquire(1);    }    public void unlock() {       System.out.println(Thread.currentThread().getName()+&quot; ready release lock&quot;);        sync.release(1);        System.out.println(Thread.currentThread().getName()+&quot; already released lock&quot;);    }    public Condition newCondition() {        return sync.newCondition();    }    public boolean isLocked() {        return sync.isHeldExclusively();    }    public boolean hasQueuedThreads() {        return sync.hasQueuedThreads();    }    public void lockInterruptibly() throws InterruptedException {        sync.acquireInterruptibly(1);    }    public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException {        return sync.tryAcquireNanos(1, unit.toNanos(timeout));    }}</code></pre><p>测试类</p><pre><code>/** *类说明： */public class TestReenterSelfLock {    static final Lock lock = new ReenterSelfLock();    public void reenter(int x){        lock.lock();        try {            System.out.println(Thread.currentThread().getName()+&quot;:递归层级:&quot;+x);            int y = x - 1;            if (y==0) return;            else{                reenter(y);            }        } finally {            lock.unlock();        }    }    public void test() {        class Worker extends Thread {            public void run() {                System.out.println(Thread.currentThread().getName());                SleepTools.second(1);                reenter(3);            }        }        // 启动3个子线程        for (int i = 0; i &lt; 3; i++) {            Worker w = new Worker();            w.start();        }        // 主线程每隔1秒换行        for (int i = 0; i &lt; 100; i++) {            SleepTools.second(1);        }    }    public static void main(String[] args) {        TestReenterSelfLock testMyLock = new TestReenterSelfLock();        testMyLock.test();    }}</code></pre><h3 id="ReentrantReadWriteLock的实现"><a href="#ReentrantReadWriteLock的实现" class="headerlink" title="ReentrantReadWriteLock的实现"></a>ReentrantReadWriteLock的实现</h3><h4 id="读写状态的设计"><a href="#读写状态的设计" class="headerlink" title="读写状态的设计"></a>读写状态的设计</h4><p>读写锁同样依赖自定义同步器来实现同步功能，而读写状态就是其同步器的同步状态。</p><p>回想ReentrantLock中自定义同步器的实现，同步状态表示锁被一个线程重复获取的次数，而读写锁的自定义同步器需要在同步状态（一个整型变量）上维护多个读线程和一个写线程的状态，使得该状态的设计成为读写锁实现的关键。</p><p>如果在一个整型变量上维护多种状态，就一定需要“按位切割使用”这个变量，读写锁将变量切分成了两个部分，高16位表示读，低16位表示写，读写锁通过位运算来维护各自的运算。假设当前同步状态值为S，写状态等于S&amp;0x0000FFFF（将高16位全部抹去），读状态等于S&gt;&gt;&gt;16（无符号补0右移16位）。当写状态增加1时，等于S+1，当读状态增加1时，等于S+(1&lt;&lt;16)，也就是S+0x00010000。根据状态的划分能得出一个推论：S不等于0时，当写状态（S&amp;0x0000FFFF）等于0时，则读状态（S&gt;&gt;&gt;16）大于0，即读锁已被获取。</p><h4 id="写锁的获取与释放"><a href="#写锁的获取与释放" class="headerlink" title="写锁的获取与释放"></a>写锁的获取与释放</h4><p>写锁是一个支持重进入的排它锁。如果当前线程已经获取了写锁，则增加写状态。读写锁在内部有一个ThreadLocal记录写状态。如果当前线程在获取写锁时，读锁已经被获取（读状态不为0）或者该线程不是已经获取写锁的线程，则当前线程进入等待状态。</p><p>该方法除了重入条件（当前线程为获取了写锁的线程）之外，增加了一个读锁是否存在的判断。如果存在读锁，则写锁不能被获取，原因在于：读写锁要确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。因此，只有等待其他读线程都释放了读锁，写锁才能被当前线程获取，而写锁一旦被获取，则其他读写线程的后续访问均被阻塞。</p><p>写锁的释放与ReentrantLock的释放过程基本类似，每次释放均减少写状态，当写状态为0时表示写锁已被释放，从而等待的读写线程能够继续访问读写锁，同时前次写线程的修改对后续读写线程可见。</p><h4 id="读锁的获取与释放"><a href="#读锁的获取与释放" class="headerlink" title="读锁的获取与释放"></a>读锁的获取与释放</h4><p>读锁是一个支持重进入的共享锁，它能够被多个线程同时获取，在没有其他写线程访问（或者写状态为0）时，读锁总会被成功地获取，而所做的也只是（线程安全的）增加读状态。如果当前线程已经获取了读锁，则增加读状态。</p><p>如果当前线程在获取读锁时，写锁已被其他线程获取，则进入等待状态。读状态是所有线程获取读锁次数的总和，而每个线程各自获取读锁的次数只能选择保存在ThreadLocal中，由线程自身维护。在tryAcquireShared(int unused)方法中，如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，依靠CAS保证）增加读状态，成功获取读锁。读锁的每次释放（线程安全的，可能有多个读线程同时释放读锁）均减少读状态。</p><h4 id="锁的升降级"><a href="#锁的升降级" class="headerlink" title="锁的升降级"></a>锁的升降级</h4><p>锁降级指的是写锁降级成为读锁。如果当前线程拥有写锁，然后将其释放，最后再获取读锁，这种分段完成的过程不能称之为锁降级。</p><p>锁降级是指把持住（当前拥有的）写锁，再获取到读锁，随后释放（先前拥有的）写锁的过程。</p><p>RentrantReadWriteLock不支持锁升级（把持读锁、获取写锁，最后释放读锁的过程）。目的是保证数据可见性，如果读锁已被多个线程获取，其中任意线程成功获取了写锁并更新了数据，则其更新对其他获取到读锁的线程是不可见的。</p>]]></content>
    
    
    <categories>
      
      <category>并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>并发编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原子操作CAS(Compare And Swap)</title>
    <link href="undefined2019/12/24/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9CCAS/"/>
    <url>2019/12/24/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9CCAS/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是原子操作，如何实现？"><a href="#什么是原子操作，如何实现？" class="headerlink" title="什么是原子操作，如何实现？"></a>什么是原子操作，如何实现？</h2><p>假定有两个操作A和B，如果从执行A的线程来看，当另一个线程执行B时，要么将B全部执行完，要么完全不执行B，那么A和B对彼此来说是原子的。</p><p>实现原子操作可以使用锁机制即synchronized关键字来实现，但synchronized关键字是基于阻塞的锁机制，也就是说当一个线程拥有锁的时候，访问同一资源的其它线程需要等待该线程执行完毕释放锁。显然，这种机制不是很灵活。比如被阻塞的线程优先级比较高，或者获得锁的线程一直不释放锁，还有大量的线程来竞争资源CPU将会花费更多的时间和资源来处理这些竞争，还可能出现一些例如死锁之类的情况，这些都会严重影响程序的性能。其实锁机制是一种比较粗糙，粒度比较大的机制，相对于像计数器这样的需求过于笨重。</p><p>CAS是利用CPU的多处理能力，实现硬件层面的阻塞，再加上volatile变量的特性即可实现基于原子操作的线程安全。当前的处理器基本都支持CAS指令，只不过每个厂家所实现的算法并不一样，每一个CAS操作过程都包含三个运算符：一个内存地址V，一个期望的值A和一个新值B，操作的时候如果这个地址上存放的值等于这个期望的值A，则将地址上的值赋为新值B，否则将循环这个指令直到成功为止。</p><img src="/2019/12/24/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9CCAS/pic1.png" srcset="/img/loading.gif" class=""><h2 id="CAS实现原子操作的三大问题"><a href="#CAS实现原子操作的三大问题" class="headerlink" title="CAS实现原子操作的三大问题"></a>CAS实现原子操作的三大问题</h2><h3 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h3><p>因为CAS需要在操作值的时候，检查值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。</p><p>ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加1，那么A→B→A就会变成1A→2B→3A。</p><h3 id="循环时间长开销大"><a href="#循环时间长开销大" class="headerlink" title="循环时间长开销大"></a>循环时间长开销大</h3><p>多个线程争夺同一个资源时，如果自旋一直不成功，将会一直占用CPU。</p><p>解决方法：破坏掉for死循环，当超过一定时间或者一定次数时，return退出。JDK8新增的LongAddr,和ConcurrentHashMap类似的方法。当多个线程竞争时，将粒度变小，将一个变量拆分为多个变量，达到多个线程访问多个资源的效果，最后再调用sum把它合起来。</p><h3 id="只能保证一个共享变量的原子操作"><a href="#只能保证一个共享变量的原子操作" class="headerlink" title="只能保证一个共享变量的原子操作"></a>只能保证一个共享变量的原子操作</h3><p>CAS指令同时刻只能保证对一个地址是原子的，当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。还有一个取巧的办法，就是把多个共享变量合并成一个共享变量或者封装为对象来操作。比如，有两个共享变量i＝2，j=a，合并一下ij=2a，然后用CAS来操作ij。从Java 1.5开始，JDK提供了AtomicReference类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行CAS操作。</p><h2 id="Jdk中相关原子操作类的使用"><a href="#Jdk中相关原子操作类的使用" class="headerlink" title="Jdk中相关原子操作类的使用"></a>Jdk中相关原子操作类的使用</h2><h3 id="jdk中提供的原子操作类"><a href="#jdk中提供的原子操作类" class="headerlink" title="jdk中提供的原子操作类"></a>jdk中提供的原子操作类</h3><ul><li>更新基本类型：AtomicBoolean,AtomicInteger,AtomicLong</li><li>更新数组类型：AtomicIntegerArray,AtomicLongArray,AtomicReferenceArray</li><li>更新基本引用类型：AtomicReference,AtomicMarkableReference,AtomicStampedReference</li><li>更新字段类型：AtomicReferenceFieldUpdater,AtomicIntegerFieldUpdater,AtomicLongFieldUpdater</li></ul><h3 id="更新基本类型"><a href="#更新基本类型" class="headerlink" title="更新基本类型"></a>更新基本类型</h3><p><strong>AtomicInteger</strong></p><ul><li><p>int addAndGet(int delta)：以原子方式将输入的数值与实例中的值相加，并返回结果。</p></li><li><p>Int  (int delta)：返回实例中的值之后，以原子操作与输入的值相加。</p></li><li><p>int getAndIncrement()：返回实例中的值之后以原子方式加1</p></li><li><p>int incrementAndGet()：以原子操作将实例中的值加1之后返回</p></li><li><p>int getAndDecrement()：返回实例中的值之后以原子方式减1</p></li><li><p>int decrementAndGet()：以原子操作将实例中的值减1之后返回</p></li><li><p>int getAndSet(int newValue)：返回实例中的值之后以原子方式设置为newValue的值。</p></li><li><p>boolean compareAndSet(int expect，int update)：如果实例中的值等于expect值，则以原子方式设置为update的值。</p></li></ul><h3 id="更新数组类型"><a href="#更新数组类型" class="headerlink" title="更新数组类型"></a>更新数组类型</h3><p><strong>AtomicIntegerArray</strong></p><p>主要是提供原子的方式更新数组里的整型，其常用方法如下。</p><ul><li><p>int addAndGet(int i，int delta)：以原子方式将输入值与实例中索引i的元素相加后返回。</p></li><li><p>boolean compareAndSet(int i，int expect，int update)：如果实例中索引i的元素等于预期值，则以原子方式将实例中索引i的元素设置成update值。</p></li><li><p>int getAndAccumulate(int i, int x,IntBinaryOperator accumulatorFunction)：将实例中索引i的元素返回之后以原子方式设置为accumulatorFunction中的操作返回的值，accumulatorFunction的left为原始值，left为传入的值。</p></li></ul><p>需要注意的是，AtomicIntegerArray中存储的数组是复制之后的原数组，当使用AtomicIntegerArray对内部的数组元素进行修改时，不会影响原数组。</p><h3 id="更新引用类型"><a href="#更新引用类型" class="headerlink" title="更新引用类型"></a>更新引用类型</h3><p>原子更新基本类型的AtomicInteger，只能更新一个变量，如果要原子更新多个变量，就需要使用这个原子更新引用类型提供的类。Atomic包提供了以下3个类。</p><p><strong>AtomicReference</strong></p><p>原子更新引用类型（不能解决ABA问题）。</p><ul><li>boolean compareAndSet(V expect，V update)：如果实例中对象等于预期值，则以原子方式将实例中对象替换为输入的对象</li></ul><p><strong>AtomicMarkableReference</strong></p><p>可以解决ABA问题，  可以记录更新过程中有没有变化</p><ul><li>AtomicMarkableReference(V initialRef, boolean initialMark)：initialRef（要关联的对象），initialMark（版本戳）</li></ul><p>AtomicStampedReference利用版本戳的形式记录了每次改变以后的版本号，版本戳为boolean类型，可以记录值是否被修改过。</p><p><strong>AtomicStampedReference</strong></p><p>能够解决ABA问题，并且可以记录变化次数</p><ul><li>AtpmicStampedReference(V initialRef,int initialStamp)：构造函数，initialRef（要关联的对象），initialStamp（版本戳）</li><li>V getStamp()：获取当前版本号</li><li>V getReference()：获取当前对象</li><li>boolean compareAndSet(V   expectedReference,V   newReference,int expectedStamp,int newStamp) ：更新当前对象及版本号</li></ul><p>AtomicStampedReference跟AtomicMarkableReference差不多， AtomicStampedReference是使用int类型的值作为版本戳，AtomicMarkableReference使用boolean mark作为版本戳。 </p><h3 id="原子更新字段类"><a href="#原子更新字段类" class="headerlink" title="原子更新字段类"></a>原子更新字段类</h3><p>如果需原子地更新某个类里的某个字段时，就需要使用原子更新字段类，Atomic包提供了以下3个类进行原子字段更新。</p><ul><li><p>AtomicIntegerFieldUpdater：原子更新整型的字段的更新器。</p></li><li><p>AtomicLongFieldUpdater：原子更新长整型字段的更新器。</p></li><li><p>AtomicReferenceFieldUpdater：原子更新引用类型里的字段。</p></li></ul><p>要想原子地更新字段类需要两步。第一步，因为原子更新字段类都是抽象类，每次使用的时候必须使用静态方法newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。第二步，更新类的字段（属性）必须使用public volatile修饰符。</p>]]></content>
    
    
    <categories>
      
      <category>并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>并发编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程的并发工具类</title>
    <link href="undefined2019/12/20/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <url>2019/12/20/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="Fork-Join"><a href="#Fork-Join" class="headerlink" title="Fork-Join"></a>Fork-Join</h1><p>forkjoin体现了分而治之的策略，java下多线程的开发可以我们自己启用多线程，线程池，还可以使用forkjoin，forkjoin可以让我们不去了解诸如Thread，Runnable等相关的知识，只要遵循forkjoin的开发模式，就可以写出很好的多线程并发程序。</p><h3 id="分而治之"><a href="#分而治之" class="headerlink" title="分而治之"></a>分而治之</h3><p>分治策略是：对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同（子问题相互之间有联系就会变为动态规范算法），递归地解这些子问题，然后将各子问题的解合并得到原问题的解，这种算法设计策略叫做分治法。</p><p>归并排序，快速排序，二分查找及大数据中M/R都体现了分而治之的策略。</p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>若将两个有序表合并成一个有序表，称为2-路归并，与之对应的还有多路归并。</p><p>对于给定的一组数据，利用递归与分治技术将数据序列划分成为越来越小的半子表，在对半子表排序后，再用递归方法将排好序的半子表合并成为越来越大的有序序列。</p><p>为了提升性能，有时我们在半子表的个数小于某个数（比如15）的情况下，对半子表的排序采用其他排序算法，比如插入排序。</p><h3 id="归并排序（降序）示例"><a href="#归并排序（降序）示例" class="headerlink" title="归并排序（降序）示例"></a>归并排序（降序）示例</h3><img src="/2019/12/20/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/pic1.png" srcset="/img/loading.gif" class=""><p>先讲数组划分为左右两个子表：</p><img src="/2019/12/20/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/pic2.png" srcset="/img/loading.gif" class=""> <img src="/2019/12/20/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/pic3.png" srcset="/img/loading.gif" class=""><p>然后继续左右两个子表拆分：</p><img src="/2019/12/20/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/pic4.png" srcset="/img/loading.gif" class=""><p>对最后的拆分的子表，两两进行排序</p><img src="/2019/12/20/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/pic5.png" srcset="/img/loading.gif" class=""><p>对有序的子表进行排序和比较合并</p><img src="/2019/12/20/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/pic6.png" srcset="/img/loading.gif" class=""><p>对合并后的子表继续比较合并</p><img src="/2019/12/20/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/pic7.png" srcset="/img/loading.gif" class=""><h2 id="Fork-Join原理"><a href="#Fork-Join原理" class="headerlink" title="Fork-Join原理"></a>Fork-Join原理</h2><p>Fork/Join框架：就是在必要的情况下，讲一个大任务，进行拆分（fork）成若干个小任务（拆到不可在拆时），再将一个个小任务进行join汇总。</p><img src="/2019/12/20/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/pic8.png" srcset="/img/loading.gif" class=""><h3 id="工作密取"><a href="#工作密取" class="headerlink" title="工作密取"></a>工作密取</h3><p>即当前线程的Task已经全被执行完毕，则自动取到其他线程的Task池中取出Task继续执行。</p><p>ForkJoinPool中维护着多个线程（一般为CPU核数）在不断地执行Task，每个线程除了执行自己职务内的Task之外，还会根据自己工作线程的闲置情况去获取其他繁忙的工作线程的Task，如此一来就能能够减少线程阻塞或是闲置的时间，提高CPU利用率。</p><img src="/2019/12/20/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/pic9.png" srcset="/img/loading.gif" class=""><h2 id="Fork-Join实战"><a href="#Fork-Join实战" class="headerlink" title="Fork-Join实战"></a>Fork-Join实战</h2><h3 id="Fork-Join使用的标准范式"><a href="#Fork-Join使用的标准范式" class="headerlink" title="Fork/Join使用的标准范式"></a>Fork/Join使用的标准范式</h3><img src="/2019/12/20/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/pic10.png" srcset="/img/loading.gif" class=""><p>要使用ForkJoin框架，必须首先创建一个ForkJoin任务，创建方式为继承ForkJoin的子类：RecursiveAction或RecursiveTask，然后实现其中的compute方法。ForkJoin框架将compute()中的逻辑来进行fork或join操作。</p><ol><li><p><strong>RecursiveAction：</strong>没有返回结果的任务</p></li><li><p><strong>RecursiveTask：</strong>有返回值的任务</p></li></ol><p>在compute方法里，首先需要判断任务是否足够小，如果足够小就直接执行任务。如果不足够小，就必须分割成两个并创建子任务，然后调用invokeAll()方法将创建的子任务提交，如果子任务有返回值，则调用join()方法获取子任务的执行结果之后需要将执行结果合并并返回，提交之后的子任务会再次进入compute，判断子任务是否需要继续拆分，如果不需要继续分割，则执行当前子任务并返回结果。</p><p> 继承之后的子类要提交到ForkJoinPool中执行，可以使用invoke()，submit()，execture()提交，区别是：invoke()是同步执行，调用之后当前线程阻塞，等待任务完成；submit()和execture()是异步执行不会阻塞当前线程，submit()可以返回结果值，execute()不会返回结果值。之后可以通过join()或get()方法获取执行结果，如果是异步执行，join()和get()方法会阻塞当前线程直到所有任务执行完毕。</p><h3 id="实现数组排序"><a href="#实现数组排序" class="headerlink" title="实现数组排序"></a>实现数组排序</h3><pre><code>public class MergeSort {    //数组长度    public static final int ARRAY_LENGTH  = 40000000;    public final static int THRESHOLD = 47;    public static int[] makeArray() {        //new一个随机数发生器        Random r = new Random();        int[] result = new int[ARRAY_LENGTH];        for(int i=0;i&lt;ARRAY_LENGTH;i++){            //用随机数填充数组            result[i] =  r.nextInt(ARRAY_LENGTH*3);        }        return result;    }    /**     * 归并排序——将两段排序好的数组结合成一个排序数组     *     * @param left     * @param right     * @return     */    public static int[] merge(int[] left, int[] right) {        int[] result = new int[left.length + right.length];        for (int index = 0, i = 0, j = 0; index &lt; result.length; index++) {            if (i &gt;= left.length)/*左边数组已经取完，完全取右边数组的值即可*/                result[index] = right[j++];            else if (j &gt;= right.length)/*右边数组已经取完，完全取左边数组的值即可*/                result[index] = left[i++];            else if (left[i] &gt; right[j])/*左边数组的元素值大于右边数组，取右边数组的值*/                result[index] = right[j++];            else/*右边数组的元素值大于左边数组，取左边数组的值*/                result[index] = left[i++];        }        return result;    }     /**     * 插入排序     *     * @param array     * @return     */    public static int[] sort(int[] array) {        if (array.length == 0)            return array;        int currentValue;/*当前待排序数据，该元素之前的元素均已被排序过*/        for (int i = 0; i &lt; array.length - 1; i++) {            int preIndex = i;/*已被排序数据的索引*/            currentValue = array[preIndex + 1];            /*在已被排序过数据中倒序寻找合适的位置，如果当前待排序数据比比较的元素要小，            将比较的元素元素后移一位*/            while (preIndex &gt;= 0 &amp;&amp; currentValue &lt; array[preIndex]) {                //将当前元素后移一位                array[preIndex + 1] = array[preIndex];                preIndex--;            }            /*while循环结束时，说明已经找到了当前待排序数据的合适位置，插入*/            array[preIndex + 1] = currentValue;        }        return array;    }    public static void main(String[] args) {        System.out.println(&quot;============================================&quot;);        long start = System.currentTimeMillis();        ForkJoinPool forkJoinPool = new ForkJoinPool();        MergeSortTask sortTask = new MergeSortTask(MakeArray.makeArray());        forkJoinPool.invoke(sortTask);        //forkJoinPool.submit(sortTask);        //int[] array = sortTask.join();        System.out.println(&quot; spend time:&quot;+(System.currentTimeMillis()-start)+&quot;ms&quot;);        System.out.println(&quot;============================================&quot;);    }    private static class MergeSortTask extends RecursiveTask&lt;int[]&gt;{        private int[] array;        public MergeSortTask(int[] array){            this.array = array;        }        @Override        protected int[] compute() {            if (array.length&lt;= THRESHOLD) {                return sort(array);            }else{                int mid = array.length / 2;                int[] leftArray = Arrays.copyOfRange(array, 0, mid);                int[] rightArray = Arrays.copyOfRange(array, mid, array.length);                MergeSortTask leftTask = new MergeSortTask(leftArray);                MergeSortTask rightTask = new MergeSortTask(rightArray);                invokeAll(leftTask, rightTask);                return merge(leftTask.join(), rightTask.join());            }        }    }}</code></pre><h3 id="异步寻找目录下的文件"><a href="#异步寻找目录下的文件" class="headerlink" title="异步寻找目录下的文件"></a>异步寻找目录下的文件</h3><pre><code>public class FindDirsFiles extends RecursiveAction {    private File path;    public FindDirsFiles(File path) {        this.path = path;    }    @Override    protected void compute() {        List&lt;FindDirsFiles&gt; subTasks = new ArrayList&lt;&gt;();        File[] files = path.listFiles();        if (files!=null){            for (File file : files) {                if (file.isDirectory()) {                    // 对每个子目录都新建一个子任务。                    subTasks.add(new FindDirsFiles(file));                } else {                    // 遇到文件，检查。                    if (file.getAbsolutePath().endsWith(&quot;txt&quot;)){                        System.out.println(&quot;文件:&quot; + file.getAbsolutePath());                    }                }            }            if (!subTasks.isEmpty()) {                // 在当前的 ForkJoinPool 上调度所有的子任务。                for (FindDirsFiles subTask : invokeAll(subTasks)) {                    subTask.join();                }            }        }    }    public static void main(String [] args){        try {            // 用一个 ForkJoinPool 实例调度总任务            ForkJoinPool pool = new ForkJoinPool();            FindDirsFiles task = new FindDirsFiles(new File(&quot;./&quot;));            /*异步提交*/            pool.execute(task);            /*主线程做自己的业务工作*/            System.out.println(&quot;Task is Running......&quot;);            Thread.sleep(1);            int otherWork = 0;            for(int i=0;i&lt;100;i++){                otherWork = otherWork+i;            }            System.out.println(&quot;Main Thread done sth......,otherWork=&quot;                    +otherWork);            task.join();//阻塞方法            System.out.println(&quot;Task end&quot;);        } catch (Exception e) {            // TODO Auto-generated catch block            e.printStackTrace();        }    }}</code></pre><h1 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h1><p>闭锁，CountDownLatch这个类能够使一个线程或多个线程等待其他线程完成后再执行。例如，应用程序的主线程希望在负责启动框架服务的线程已经完成之后再执行。</p><p>CountDownLatch是通过一个计数器来实现的，计数器的初始值为初始任务的数量（也可以大于线程数即线程中可以多次执行countDown()，线程执行countDown()之后也可以继续执行）。每当完成了一个任务后，计数器的值就会减1（CountDownLatch.countDown()方法）。当计数器值到达0时，它表示所有的已经完成了任务，然后在闭锁上等待CountDownLatch.await()方法的线程就可以继续执行。</p><img src="/2019/12/20/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/pic11.png" srcset="/img/loading.gif" class=""><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>实现最大的并行性：有时我们想同时启动多个线程，实现最大程度的并行性。例如，我们想测试一个单例类。如果我们创建一个初始计数为1的CountDownLatch，并让所有线程都在这个锁上等待，那么我们可以很轻松地完成测试。我们只需调用 一次countDown()方法就可以让所有的等待线程同时恢复执行。</p><p>开始执行前等待n个线程完成各自任务：例如应用程序启动类要确保在处理用户请求前，所有N个外部系统已经启动和运行了，例如处理excel中多个表单。</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><pre><code>/** *类说明：演示CountDownLatch用法， * 共5个初始化子线程，6个闭锁扣除点，扣除完毕后，主线程和业务线程才能继续执行 */public class UseCountDownLatch {    static CountDownLatch latch = new CountDownLatch(6);    /*初始化线程*/    private static class InitThread implements Runnable{        public void run() {            System.out.println(&quot;Thread_&quot;+Thread.currentThread().getId()                    +&quot; ready init work......&quot;);            latch.countDown();            for(int i =0;i&lt;2;i++) {                System.out.println(&quot;Thread_&quot;+Thread.currentThread().getId()                        +&quot; ........continue do its work&quot;);            }        }    }    /*业务线程等待latch的计数器为0完成*/    private static class BusiThread implements Runnable{        public void run() {            try {                latch.await();            } catch (InterruptedException e) {                e.printStackTrace();            }            for(int i =0;i&lt;3;i++) {                System.out.println(&quot;BusiThread_&quot;+Thread.currentThread().getId()                        +&quot; do business-----&quot;);            }        }    }    public static void main(String[] args) throws InterruptedException {        new Thread(new Runnable() {            public void run() {                SleepTools.ms(1);                System.out.println(&quot;Thread_&quot;+Thread.currentThread().getId()                        +&quot; ready init work step 1st......&quot;);                latch.countDown();                System.out.println(&quot;begin step 2nd.......&quot;);                SleepTools.ms(1);                System.out.println(&quot;Thread_&quot;+Thread.currentThread().getId()                        +&quot; ready init work step 2nd......&quot;);                latch.countDown();            }        }).start();        new Thread(new BusiThread()).start();        for(int i=0;i&lt;=3;i++){            Thread thread = new Thread(new InitThread());            thread.start();        }        latch.await();        System.out.println(&quot;Main do ites work........&quot;);    }}</code></pre><h1 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h1><p>CyclicBarrier的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到所有线程到达屏障时，解除屏障，所有被屏障拦截的线程才会继续运行。CyclicBarrier默认的构造方法是CyclicBarrier（int parties），其参数表示屏障拦截的线程数量，每个线程调用await()方法告诉CyclicBarrier当前线程已经到达了屏障，然后这个线程被阻塞。</p><p>CyclicBarrier还提供一个更高级的构造函数CyclicBarrier（int parties，Runnable barrierAction），用于在线程到达屏障时，执行barrierAction，方便处理更复杂的业务场景。</p><p>await()方法可以执行多次，当满足条件屏障解除之后，CyclicBarrier就会被复位。</p><img src="/2019/12/20/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/pic12.png" srcset="/img/loading.gif" class=""><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><p>CyclicBarrier可以用于多线程计算数据，最后合并计算结果的场景。</p><h3 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h3><pre><code>/** * 类说明：演示CyclicBarrier用法,共4个子线程，他们全部完成工作后，交出自己结果， * 再被统一释放去做自己的事情，而交出的结果被另外的线程拿来拼接字符串 */public class UseCyclicBarrier {    private static CyclicBarrier barrier = new CyclicBarrier(4, new CollectThread());    //存放子线程工作结果的容器    private static ConcurrentHashMap&lt;String, Long&gt; resultMap            = new ConcurrentHashMap&lt;&gt;();    public static void main(String[] args) {        for (int i = 0; i &lt; 4; i++) {            Thread thread = new Thread(new SubThread());            thread.start();        }    }    /*汇总的任务*/    private static class CollectThread implements Runnable {        @Override        public void run() {            StringBuilder result = new StringBuilder();            for (Map.Entry&lt;String, Long&gt; workResult : resultMap.entrySet()) {                result.append(&quot;[&quot; + workResult.getValue() + &quot;]&quot;);            }            System.out.println(&quot; the result = &quot; + result);            System.out.println(&quot;do other business........&quot;);        }    }    /*相互等待的子线程*/    private static class SubThread implements Runnable {        @Override        public void run() {            long id = Thread.currentThread().getId();            resultMap.put(Thread.currentThread().getId() + &quot;&quot;, id);            try {                Thread.sleep(1000 + id);                System.out.println(&quot;Thread_&quot; + id + &quot; ....do something &quot;);                barrier.await();                Thread.sleep(1000 + id);                System.out.println(&quot;Thread_&quot; + id + &quot; ....do its business &quot;);            } catch (Exception e) {                e.printStackTrace();            }        }    }}</code></pre><h3 id="CountDownLatch和CyclicBarrier辨析"><a href="#CountDownLatch和CyclicBarrier辨析" class="headerlink" title="CountDownLatch和CyclicBarrier辨析"></a>CountDownLatch和CyclicBarrier辨析</h3><ul><li><p>CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以反复使用。</p></li><li><p>CountDownLatch.await()会阻塞当前线程，等待所有工作线程执行countDown()之后继续执行，而CyclicBarrier通过线程调用await()阻塞工作线程，直到所有工作线程达到指定屏障，所有工作线程再继续执行。</p></li><li><p>在控制多个线程同时运行上，CountDownLatch可以不限线程数量，而CyclicBarrier是固定线程数。</p></li><li><p>CyclicBarrier还可以提供一个barrierAction，用于进行到达屏障后的工作，如：合并多线程计算结果。</p></li></ul><h1 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h1><p>Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。应用场景Semaphore可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接。假如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程并发地读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这时我们必须控制只有10个线程同时获取数据库连接保存数据，否则会报错无法获取数据库连接。这个时候，就可以使用Semaphore来做流量控制。Semaphore的构造方法Semaphore（int permits）接受一个整型的数字，表示可用的许可证数量。Semaphore的用法也很简单，首先线程使用Semaphore的acquire()方法获取一个许可证 ，使用完之后调用release()方法归还许可证。还可以用tryAcquire()方法尝试获取许可证。</p><p>Semaphore还提供一些其他方法，具体如下。</p><ul><li><p><strong>int availablePermits()：</strong>返回此信号量中当前可用的许可证数。</p></li><li><p><strong>int getQueueLength()：</strong>返回正在等待获取许可证的线程数。</p></li><li><p><strong>boolean hasQueuedThreads()：</strong>是否有线程正在等待获取许可证。</p></li><li><p><strong>void reducePermits(int reduction)：</strong>减少reduction个许可证，是个protected方法。</p></li><li><p><strong>Collection getQueuedThreads()</strong>：返回所有等待获取许可证的线程集合，是个protected方法。</p></li></ul><img src="/2019/12/20/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/pic13.png" srcset="/img/loading.gif" class=""><h3 id="用Semaphore实现数据库连接池"><a href="#用Semaphore实现数据库连接池" class="headerlink" title="用Semaphore实现数据库连接池"></a>用Semaphore实现数据库连接池</h3><pre><code>/** *类说明：演示Semaphore用法，一个数据库连接池的实现 */public class DBPoolSemaphore {    private final static int POOL_SIZE = 10;    //两个指示器，分别表示池子还有可用连接和已用连接    private final Semaphore useful, useless;    //存放数据库连接的容器    private static LinkedList&lt;Connection&gt; pool = new LinkedList&lt;Connection&gt;();    //初始化池    static {        for (int i = 0; i &lt; POOL_SIZE; i++) {            pool.addLast(SqlConnectImpl.fetchConnection());        }    }    public DBPoolSemaphore() {        this.useful = new Semaphore(10);        this.useless = new Semaphore(10);    }    /*归还连接*/    public void returnConnect(Connection connection) throws InterruptedException {        if(connection!=null) {            System.out.println(&quot;当前有&quot;+useful.getQueueLength()+&quot;个线程等待数据库连接!!&quot;                    +&quot;可用连接数：&quot;+useful.availablePermits());            useless.acquire();            synchronized (pool) {                pool.addLast(connection);            }            useful.release();        }    }    /*从池子拿连接*/    public Connection takeConnect() throws InterruptedException {        useful.acquire();        Connection connection;        synchronized (pool) {            connection = pool.removeFirst();        }        useless.release();        return connection;    }    private static DBPoolSemaphore dbPool = new DBPoolSemaphore();    private static class BusiThread extends Thread{        @Override        public void run() {            Random r = new Random();//让每个线程持有连接的时间不一样            long start = System.currentTimeMillis();            try {                Connection connect = dbPool.takeConnect();                System.out.println(&quot;Thread_&quot;+Thread.currentThread().getId()                        +&quot;_获取数据库连接共耗时【&quot;+(System.currentTimeMillis()-start)+&quot;】ms.&quot;);                SleepTools.ms(100+r.nextInt(100));//模拟业务操作，线程持有连接查询数据                System.out.println(&quot;查询数据完成，归还连接！&quot;);                dbPool.returnConnect(connect);            } catch (InterruptedException e) {            }        }    }    public static void main(String[] args) {        for (int i = 0; i &lt; 50; i++) {            Thread thread = new BusiThread();            thread.start();        }    }}</code></pre><h3 id="Semaphore注意事项"><a href="#Semaphore注意事项" class="headerlink" title="Semaphore注意事项"></a>Semaphore注意事项</h3><p>当只有不使用userless控制可归还链接数，在归还链接时，Semaphore允许归还并不是通过线程池获取而是通过其他方式创建的链接，这就会导致Semaphore的数量增加。</p><pre><code>/** *类说明：演示Semaphore用法，一个数据库连接池的实现 */public class DBPoolNoUseless {    private final static int POOL_SIZE = 10;    private final Semaphore useful;    //存放数据库连接的容器    private static LinkedList&lt;Connection&gt; pool = new LinkedList&lt;Connection&gt;();    //初始化池    static {        for (int i = 0; i &lt; POOL_SIZE; i++) {            pool.addLast(SqlConnectImpl.fetchConnection());        }    }    public DBPoolNoUseless() {        this.useful = new Semaphore(10);    }    /*归还连接*/    public void returnConnect(Connection connection) throws InterruptedException {        if(connection!=null) {            System.out.println(&quot;当前有&quot;+useful.getQueueLength()+&quot;个线程等待数据库连接!!&quot;                    +&quot;可用连接数：&quot;+useful.availablePermits());            synchronized (pool) {                pool.addLast(connection);            }            useful.release();        }    }    /*从池子拿连接*/    public Connection takeConnect() throws InterruptedException {        useful.acquire();        Connection connection;        synchronized (pool) {            connection = pool.removeFirst();        }        return connection;    }    private static DBPoolNoUseless dbPoolNoUseless = new DBPoolNoUseless();    private static class BusiThread extends Thread{        @Override        public void run() {            Random r = new Random();//让每个线程持有连接的时间不一样            long start = System.currentTimeMillis();            try {                System.out.println(&quot;Thread_&quot;+Thread.currentThread().getId()                        +&quot;_获取数据库连接共耗时【&quot;+(System.currentTimeMillis()-start)+&quot;】ms.&quot;);                SleepTools.ms(100+r.nextInt(100));//模拟业务操作，线程持有连接查询数据                System.out.println(&quot;查询数据完成，归还连接！&quot;);                dbPoolNoUseless.returnConnect(new SqlConnectImpl());            } catch (InterruptedException e) {            }        }    }    public static void main(String[] args) {        for (int i = 0; i &lt; 50; i++) {            Thread thread = new BusiThread();            thread.start();        }    }}</code></pre><h1 id="Exchange"><a href="#Exchange" class="headerlink" title="Exchange"></a>Exchange</h1><p>Exchanger（交换者）是一个用于线程间协作的工具类。Exchanger用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。这两个线程通过exchange方法交换数据，如果第一个线程先执行exchange()方法，它会一直等待第二个线程也执行exchange()方法，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。交换过程由jdk保证线程安全。</p><img src="/2019/12/20/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/pic14.png" srcset="/img/loading.gif" class=""><h3 id="用法-2"><a href="#用法-2" class="headerlink" title="用法"></a>用法</h3><pre><code>/** * 类说明：演示CyclicExchange用法 */public class UseExchange {    private static final Exchanger&lt;Set&lt;String&gt;&gt; exchange = new Exchanger&lt;Set&lt;String&gt;&gt;();    public static void main(String[] args) {        new Thread(new Runnable() {            @Override            public void run() {                Set&lt;String&gt; setA = new HashSet&lt;String&gt;();//存放数据的容器                try {                    setA.add(&quot;A&quot;);                    setA = exchange.exchange(setA);//交换set                    System.out.println(&quot;A:&quot; + setA);                    /*处理交换后的数据*/                } catch (InterruptedException e) {                }            }        }).start();        new Thread(new Runnable() {            @Override            public void run() {                Set&lt;String&gt; setB = new HashSet&lt;String&gt;();//存放数据的容器                try {                    setB.add(&quot;B&quot;);                    setB = exchange.exchange(setB);//交换set                    System.out.println(&quot;B:&quot; + setB);                    /*处理交换后的数据*/                } catch (InterruptedException e) {                }            }        }).start();    }}</code></pre><h1 id="Callable、Future和FutureTask"><a href="#Callable、Future和FutureTask" class="headerlink" title="Callable、Future和FutureTask"></a>Callable、Future和FutureTask</h1><p>Runnable是一个接口，在它里面只声明了一个run()方法，由于run()方法返回值为void类型，所以在执行完任务之后无法返回任何结果。</p><p>Callable位于java.util.concurrent包下，它也是一个接口，在它里面也只声明了一个call()方法，这是一个泛型接口，call()函数返回的类型就是传递进来的V类型。 但Callable无法直接交给Thread执行，这时就需要一个类来包装Callable使其能够被Thread类执行。</p><p>RunnableFuture继承了Runnable接口和Future接口所以RunnableFuture接口可以被Thread执行，FutureTask类实现了RunnableFuture接口，所以它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。</p><p>Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。但Future只是一个接口，所以是无法直接用来创建对象使用的，就有了上面的FutureTask。</p><img src="/2019/12/20/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/pic15.png" srcset="/img/loading.gif" class=""><p>因此我们通过一个线程运行Callable，但是Thread不支持构造方法中传递Callable的实例，所以我们需要通过FutureTask把一个Callable包装成Runnable，然后再通过这个FutureTask拿到Callable运行后的返回值。</p><h3 id="用法-3"><a href="#用法-3" class="headerlink" title="用法"></a>用法</h3><pre><code>/** * 类说明：演示Future等的使用 */public class UseFuture {    /*实现Callable接口，允许有返回值*/    private static class UseCallable implements Callable&lt;Integer&gt; {        private int sum;        @Override        public Integer call() throws Exception {            System.out.println(&quot;Callable子线程开始计算！&quot;);            for (int i = 0; i &lt; 500; i++) {                if (Thread.currentThread().isInterrupted()) {                    System.out.println(&quot;Callable子线程计算任务中断！&quot;);                    return null;                }                sum = sum + i;            }            System.out.println(&quot;Callable子线程计算结束！结果为: &quot; + sum);            return sum;        }    }    public static void main(String[] args) throws InterruptedException, ExecutionException {        UseCallable useCallable = new UseCallable();        FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(useCallable);        new Thread(futureTask).start();        Random r = new Random();        if (r.nextInt(100) &gt; 50) {            System.out.println(&quot;result = &quot; + futureTask.get());        } else {            System.out.println(&quot;cancel&quot;);            futureTask.cancel(true);        }    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>并发编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程基础、线程之间的共享和合作</title>
    <link href="undefined2019/12/17/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B1%E4%BA%AB%E5%92%8C%E5%90%88%E4%BD%9C/"/>
    <url>2019/12/17/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B1%E4%BA%AB%E5%92%8C%E5%90%88%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><ul><li><strong>CPU核心和线程数的关系</strong>：核心数比线程数一般为1:1，超线程技术1:2</li><li><strong>CPU时间片轮转机制(RR调度)</strong>：古老、简单、公平、应用最广泛的算法。在时间片用完，或线程阻塞，完成式会剥夺线程cpu占用，进行上下文切换，切换时需要保存装入寄存器的值，同时载入下一个线程的值，线程切换大约需要5000-20000个cpu时钟周期。当线程切换需要大量时间时，多线程的效率可能不如单线程。</li><li><strong>进程和线程</strong>：进程是程序进行资源分配的最小单位，一个进程可能会有多个线程会共享这个进程的资源。线程是cpu资源调度的最小单位。</li><li><strong>并行和并发</strong>：并行是指同一时刻的处理能力、并发和事件相关呢，在单位时间内处理事情的能力。</li><li><strong>高并发编程的意义、好处和注意事项</strong>：提高资源利用效率，但由于共享资源，可能存在冲突、死锁，过多的线程还会造成服务器崩溃。</li></ul><h2 id="java中的线程"><a href="#java中的线程" class="headerlink" title="java中的线程"></a>java中的线程</h2><p>java中的程序天生就是多线程的，且线程之间的关系与windwos中不同，windows系统之线程之间是抢占式的，java中是协作式，可以通过虚拟机的线程管理接口查看当前进行的线程。</p><pre><code>public static void main(String[] args) {    ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();    ThreadInfo[] threadInfos=threadMXBean.dumpAllThreads(false, false);    for(ThreadInfo threadInfo:threadInfos){        System.out.println(&quot;[&quot;+threadInfo.getThreadId()+&quot;]&quot;+&quot; &quot;+threadInfo.getThreadName());    }}</code></pre><h3 id="启动线程的方式"><a href="#启动线程的方式" class="headerlink" title="启动线程的方式"></a>启动线程的方式</h3><ol><li>继承Thread类后通过start()方法启动。</li><li>实现Runable接口后通过new Thread(runable).start()启动。</li><li>实现Callable接口之后使用new FutureTask&lt;&gt;(callable)创建task后通过new Thread(runable).start()启动，可以通过futureTask的get方法获取线程返回值，获取返回值时当前线程会阻塞。</li><li>start方法会判断线程时候被启动，如果已经被启动会抛出异常</li><li>Thread是线程的抽象，Runnable是任务的抽象。</li></ol><h3 id="停止线程的方式"><a href="#停止线程的方式" class="headerlink" title="停止线程的方式"></a>停止线程的方式</h3><ol><li>thread中的stop(),resume(),suspend()方法，这三个方法过于强势，stop停止方法无法保证线程资源释放可能导致不可知的错误，suspend挂起线程时不会释放资源可能导致死锁问题。</li><li>interrupt()可以中断一个线程，并不是强行关闭这个线程，调用interrupt()方法后，讲线程的中断标识为置为true，线程是否停止由线程决定，以此确保每个线程有充足的时间做好后续工作。</li><li>isInterrupted()、静态方法interrupted()都是判断当前线程是否处于中断状态，isInterrupted()为判断为判断中断标识为是否为true，interrupted()调用之后将中断标识为改为flase。</li><li>使用自定义标志位在线程被挂起时不会去判断标志位的变化，但调用interrupt()方法会使中断方法抛出InterruptException，抛出异常后interrupt标志位重新设置为false，此时开发者可以释放线程资源，之后再决定线程是否需要终止线程。</li></ol><h3 id="interrupt-的使用示例"><a href="#interrupt-的使用示例" class="headerlink" title="interrupt()的使用示例"></a>interrupt()的使用示例</h3><pre><code>public class Main {    private static class UserThread extends Thread{        public UserThread(String name){            super(name);        }        @Override        public void run() {            String threadName=Thread.currentThread().getName();            while(!isInterrupted()){                System.out.println(threadName);            }            System.out.println(threadName+&quot; interrput flag is &quot;+isInterrupted());        }    }    // 实现Runnable中断的方法    private static class UserThread implements Runnable{        @Override        public void run() {            String threadName=Thread.currentThread().getName();            while(!Thread.currentThread().isInterrupted()){                System.out.println(threadName);            }            System.out.println(threadName+&quot; interrput flag is &quot;+Thread.currentThread().isInterrupted());        }    }    public static void main(String[] args) throws InterruptedException {        Thread endThread=new UserThread(&quot;endThread&quot;);        endThread.start();        Thread.sleep(20L);        endThread.interrupt();    }}</code></pre><p>当线程处于阻塞状态时调用interrupted方法时会抛出InterruptedExcetion异常时，抛出异常后，线程的中断标识为会被复位为false。</p><pre><code>public class Main {    private static class UserThread extends Thread {        public UserThread(String name) {            super(name);        }        @Override        public void run() {            String threadName = Thread.currentThread().getName();            while (!isInterrupted()) {                try {                    Thread.sleep(100);                } catch (InterruptedException e) {                    System.out.println(threadName+&quot; interrput flag is &quot;+isInterrupted());                    interrupt();                    e.printStackTrace();                }                System.out.println(threadName);            }            System.out.println(threadName+&quot; interrput flag is &quot;+isInterrupted());        }    }    public static void main(String[] args) throws InterruptedException {        Thread endThread=new UserThread(&quot;endThread&quot;);        endThread.start();        Thread.sleep(500);        endThread.interrupt();    }}</code></pre><h3 id="线程常用方法和线程的状态"><a href="#线程常用方法和线程的状态" class="headerlink" title="线程常用方法和线程的状态"></a>线程常用方法和线程的状态</h3><img src="/2019/12/17/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B1%E4%BA%AB%E5%92%8C%E5%90%88%E4%BD%9C/pic1.png" srcset="/img/loading.gif" class=""><ol><li>线程处于阻塞态时，系统不会进行资源分配。</li><li>当前线程变为守护线程后，所有非守护线程结束后，守护线程会死亡。</li><li>阻塞态唤醒时，进入就绪态，等待cpu调度。</li><li>interrupt()是改变线程标识位，如果线程不判断interrupt()线程不会死亡。</li><li>yield()方法是让出cpu调度权进入就绪态，所占有的资源不会释放，cpu时间片分配可能会再次分配到yield()方法。 </li><li>join()方法会让出当前线程资源及cpu执行权后进入挂起态，调用join的线程执行完之后继续执行当前线程。</li><li>setPriority()可以设置线程的优先级但不一定会起作用，范围为1-10有些系统范围为1-3，优先级是否发挥作用完全由操作系统决定。 需要休眠或者io操作的优先级高，计算的优先级低，确保处理器时间不会被计算型的线程占据。</li><li><strong>yield()方法和sleep()方法的区别</strong>：yield()方法是让出cpu调度权，重新进入就绪态，sleep()是阻塞线程，sleep()执行之后线程不会获取cpu调度权，yield()执行之后会再去抢夺cpu调度权。</li><li><strong>run()方法和start()方法</strong>：run()方法归属于调用方法所在线程的运行栈，如在main()方法中调用run()方法，此时run()方法会被打包为栈帧在main()方法的运行栈中运行，此时若在run()方法中打印线程名则线程名为main。调用start()方法后，虚拟机会将run()方法与线程映射为run()方法开启单独线程。</li><li>守护线程大多用来支持程序，可以用线程的setDaemon()方法设置，当用户线程停止后，所有的守护线程也将停止，守护线程中的finally不一定会执行。守护线程大多用于资源管理，当用户线程结束后，作为资源管理的守护线程也就没有必要释放资源。操作系统在判定当前线程被结束时就不会分配资源，但也有可能在终止进程关闭时有一段很短的时间使守护线程执行finally中的方法。 用户线程中的finally一定会执行。</li></ol><h2 id="线程间的共享"><a href="#线程间的共享" class="headerlink" title="线程间的共享"></a>线程间的共享</h2><h3 id="synchronized内置锁"><a href="#synchronized内置锁" class="headerlink" title="synchronized内置锁"></a>synchronized内置锁</h3><p>synchronized可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性，又称为内置锁机制。</p><h5 id="对象锁和类锁"><a href="#对象锁和类锁" class="headerlink" title="对象锁和类锁"></a>对象锁和类锁</h5><p>对象锁时用于对象实例，类锁用于类的静态方法或者一个类的class对象上，不同对象实例的对象锁互不干扰。每个类在虚拟机加载时会生成class对象，类锁是将锁加到class类上。类锁与对象锁互不干扰。</p><h5 id="错误的加锁和原因分析"><a href="#错误的加锁和原因分析" class="headerlink" title="错误的加锁和原因分析"></a>错误的加锁和原因分析</h5><p>通常是在线程执行过程中改变了锁住的对象导致加锁的对象并不是同一个。</p><h4 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h4><p>volatile是<strong>最轻量的同步机制</strong>，volatile保证了不同线程对这个变量进行操作时的可见性，但是volatile不能保证数据在多个线程下同时写时的线程安全，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的，但多个线程同时写时volatile不能保证线程安全。所以volatile最适用的场景为一写多读。</p><h2 id="ThreadLocal辨析"><a href="#ThreadLocal辨析" class="headerlink" title="ThreadLocal辨析"></a>ThreadLocal辨析</h2><h3 id="与Synchronized的比较"><a href="#与Synchronized的比较" class="headerlink" title="与Synchronized的比较"></a>与Synchronized的比较</h3><p>ThreadLocal和Synchonized都用于解决多线程并发访问。可是ThreadLocal与synchronized有本质的差别。synchronized是利用锁的机制，使变量或代码块在某一时该仅仅能被一个线程访问。ThreadLocal为每个线程都提供了变量的副本，使得每个线程在某一时间访问到的并非同一个对象，这样就隔离了多个线程对数据的数据共享。</p><p>jdbc事务是以一个connection的操作为整体，Web容器中，每一个完整的请求周期都会由一个线程处理，spring事务则借助了ThreadLocal类，将connection与当前线程绑定，对数据库所有的操作在一个connection中进行，从而保证事务的边界。</p><h3 id="ThreadLocal的使用"><a href="#ThreadLocal的使用" class="headerlink" title="ThreadLocal的使用"></a>ThreadLocal的使用</h3><p>ThreadLocal类接口很简单，只有4个方法</p><ul><li><p><strong>void set(Object value)</strong> 设置当前线程的线程局部变量的值。</p></li><li><p><strong>public Object get()</strong> 该方法返回当前线程所对应的线程局部变量。</p></li><li><p><strong>public void remove()</strong> 将当前线程局部变量的值删除，目的是为了减少内存的占用，该方法是JDK 5.0新增的方法。需要指出的是，当线程结束后，对应该线程的局部变量将自动被垃圾回收，所以显式调用该方法清除线程的局部变量并不是必须的操作，但它可以加快内存回收的速度。</p></li><li><p><strong>protected Object initialValue()</strong> 返回该线程局部变量的初始值，该方法是一个protected的方法，显然是为了让子类覆盖而设计的。这个方法是一个延迟调用方法，在线程第1次调用get()或set(Object)时才执行，并且仅执行1次。ThreadLocal中的缺省实现直接返回一个null。</p></li><li><p><strong>public final static ThreadLocal<String> RESOURCE = new ThreadLocal<String>();</strong>RESOURCE代表一个能够存放String类型的ThreadLocal对象。此时不论什么一个线程能够并发访问这个变量，对它进行写入、读取操作，都是线程安全的。</p></li></ul><h3 id="实现解析"><a href="#实现解析" class="headerlink" title="实现解析"></a>实现解析</h3><img src="/2019/12/17/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B1%E4%BA%AB%E5%92%8C%E5%90%88%E4%BD%9C/pic2.png" srcset="/img/loading.gif" class=""><p>Thread中有一个ThreadLocalMap对象，ThreadLocalMap是ThreadLocal的静态内部类，存储的对象为Model类型的数组，Model类型的键为ThreadLocal对象，值为ThreadLocal对象的值，ThreadLocal的get方法会获取当前Thread，然后调用getMap()获取当前Thread的ThreadLocalMap，再从ThreadLocalMap中通过ThreadLocal找到对应的值。</p><h3 id="引发的内存泄露分析"><a href="#引发的内存泄露分析" class="headerlink" title="引发的内存泄露分析"></a>引发的内存泄露分析</h3><h4 id="jvm中的引用类型"><a href="#jvm中的引用类型" class="headerlink" title="jvm中的引用类型"></a>jvm中的引用类型</h4><p><strong>强引用：</strong>常用的Object o = new Object()就是强引用，在线程中执行方法时， 方法会被打包为栈帧在栈上运行，方法中创建的对象实例存储在在堆上，而方法中对象的命名指向堆上的实例，这就是引用（类似于c++的指针）。当强引用存在时即栈上有一个引用指向堆中的对象实例，gc就不会回收该对象实例。</p><p><strong>软引用：</strong>用来描述一些还有用但并非必需的对象。将要发生内存溢出时，会把软引用对象实例列入回收范围，进入第二次回收。如果回收之后还是没有足够的内存才会抛出内存溢出异常。在JDK 1.2之后，提供了SoftReference类来实现软引用。</p><p><strong>弱饮用</strong>：用来描述非必需对象的，强度低于软引用，只要发生垃圾回收，弱引用指向的对象实例就一定会被回收掉，不管是否将要发生内存溢出。在JDK 1.2之后，提供了WeakReference类来实现弱引用。</p><p><strong>虚引用</strong>：也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象实例是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象实例被收集器回收时收到一个系统通知。在JDK 1.2之后，提供了PhantomReference类来实现虚引用。</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><img src="/2019/12/17/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B1%E4%BA%AB%E5%92%8C%E5%90%88%E4%BD%9C/pic3.png" srcset="/img/loading.gif" class=""><p>Thread维护的ThreadLocalMap中的Model的key使用的是ThreadLocal的的弱引用 ，方法执行完出栈后，threadLocal变量会被置为null，此时强引用消失，没有强引用指向ThreadLocal实例，ThreadLocal会被gc回收即model中的key被回收，但Thread对ThreadLocalMap的应用是强引用，所以model中的value会依然存在，这就有可能造成内存泄漏。只有当前thread结束以后，thread就不会存在栈中，强引用断开，thread、threadLocalMap将全部被GC回收。最好的做法是不在需要使用threadLocal变量后，都调用它的remove()方法，清除数据。</p><p>jdk提供了相应的补偿机制，ThreadLocal的get()，set()有可能会去调用expungeStaleEntry()，replaceStaleEntry()方法去清除key为null即ThreadLocal为null的value值。</p><p>如果对key的引用为强引用的话，set()，get()方法中对Model的释放就一定不会触发，必然会造成内存泄漏。</p><h3 id="ThreadLocal线程不安全"><a href="#ThreadLocal线程不安全" class="headerlink" title="ThreadLocal线程不安全"></a>ThreadLocal线程不安全</h3><p> 当多个线程的ThreadLocalMap的value保存的是同一个对象实例的引用时，线程通过这个引用对对象实例做修改，也同样会影响了其他线程中引用的这个对象实例。显然要避免ThreadLocal线程不安全就应该让每个线程中的ThreadLocal都应该持有一个新的对象。</p><h2 id="线程间的协作"><a href="#线程间的协作" class="headerlink" title="线程间的协作"></a>线程间的协作</h2><p>线程之间相互配合，完成某项工作，如一个线程对对象做了初步处理，另一个线程感知到初步处理完成，然后进行之后的再处理，整个过程开始于一个线程，而继续执行又是另一个线程。相对而言，前者是生产者，后者就是消费者，简单的办法是让消费者线程轮训检查变量是否符合预期，如果条件满足则退出循环，从而完成消费者的工作。却存在以下问题：</p><ol><li>及时性。</li><li>开销。</li></ol><p>如果要确保及时性就要缩短轮询的间隔就会不可避免的消耗更多资源。</p><h3 id="等待和通知"><a href="#等待和通知" class="headerlink" title="等待和通知"></a>等待和通知</h3><p> 是指一个线程调用Object的wait()方法后，释放占有的资源进入阻塞态，另一个线程调用Object的notify()或者notifyAll()之后阻塞的线程被唤醒，但notify()和notifyAll()不会立即释放锁，而是等待之后的业务代码执行完之后才会释放锁，阻塞的线程被唤醒之后继续执行后续操作。上述两个线程必须通过一个Object进行操作完成交互，而wait()和notify()用来构建等待方和通知方的通信。</p><ul><li><p>notify()：随机通知一个在对象上等待的线程，使其从wait()中返回，而返回的前提是该线程获取到了对象的锁，没有获得锁的线程重新进入阻塞态。</p></li><li><p>notifyAll()：通知所有等待在该对象上的线程</p></li><li><p>wait()：调用该方法的线程进入阻塞态，只有线程调用notify()或被中断才会返回。调用wait()方法后,会释放对象的锁</p></li><li><p>wait(long)：超时等待一段时间,这里的参数时间是毫秒,也就是等待长达n毫秒,如果没有通知就超时返回</p></li><li><p>wait (long,int)：对于超时时间更细粒度的控制,可以达到纳秒</p></li></ul><h4 id="等待标准范式"><a href="#等待标准范式" class="headerlink" title="等待标准范式"></a>等待标准范式</h4><pre><code>synchronized(对象){    while(预期不满足){        对象.wait();    }}</code></pre><h4 id="通知标准范式"><a href="#通知标准范式" class="headerlink" title="通知标准范式"></a>通知标准范式</h4><pre><code>synchronized(对象){    //业务逻辑，改变条件    对象.notify()/notifyAll();}</code></pre><p>在调用wait()、notify()系列方法之前，线程必须要获得该对象的对象级别锁，即只能在同步方法或同步块中调用wait()、notify()。进入wait()方法后，当前线程释放锁，在从wait()返回前，线程与其他线程竞争重新获得锁。执行notify()系列方法的线程退出后，释放对象锁，其他线程就回去竞争对象锁。如果其中一个线程获得了该对象锁，它就会继续往下执行，在它退出synchronized代码块，释放锁后，其他的已经被唤醒的线程将会继续竞争获取该锁，一直进行下去，直到所有被唤醒的线程都执行完毕。</p><h4 id="notify和notifyAll应该用谁"><a href="#notify和notifyAll应该用谁" class="headerlink" title="notify和notifyAll应该用谁"></a>notify和notifyAll应该用谁</h4><p>尽可能用notifyall()，谨慎使用notify()，因为notify()只会唤醒一个线程，我们无法确保被唤醒的这个线程一定就是需要唤醒的线程</p><h4 id="等待超时模式实现-一个连接池"><a href="#等待超时模式实现-一个连接池" class="headerlink" title="等待超时模式实现 一个连接池"></a>等待超时模式实现 一个连接池</h4><p>DBPool.java</p><pre><code>package cn.enjoyedu.ch1.pool;import java.sql.Connection;import java.util.LinkedList;/** *类说明：连接池的实现 */public class DBPool {    /*容器，存放连接*/    private static LinkedList&lt;Connection&gt; pool = new LinkedList&lt;Connection&gt;();    /*限制了池的大小=20*/    public DBPool(int initialSize) {        if (initialSize &gt; 0) {            for (int i = 0; i &lt; initialSize; i++) {                pool.addLast(SqlConnectImpl.fetchConnection());            }        }    }    /*释放连接,通知其他的等待连接的线程*/    public void releaseConnection(Connection connection) {        if (connection != null) {            synchronized (pool){                pool.addLast(connection);                //通知其他等待连接的线程                pool.notifyAll();            }        }    }    /*获取*/    // 在mills内无法获取到连接，将会返回null 1S    public Connection fetchConnection(long mills)            throws InterruptedException {        synchronized (pool){            //永不超时            if(mills&lt;=0){                while(pool.isEmpty()){                    pool.wait();                }                return pool.removeFirst();            }else{                /*超时时刻*/                long future = System.currentTimeMillis()+mills;                /*等待时长*/                long remaining = mills;                while(pool.isEmpty()&amp;&amp;remaining&gt;0){                    pool.wait(remaining);                    /*唤醒一次，重新计算等待时长*/                    remaining = future-System.currentTimeMillis();                }                Connection connection = null;                if(!pool.isEmpty()){                    connection = pool.removeFirst();                }                return connection;            }        }    }}</code></pre><p>DBPoolTest.java</p><pre><code>package cn.enjoyedu.ch1.pool;import java.sql.Connection;import java.util.concurrent.CountDownLatch;import java.util.concurrent.atomic.AtomicInteger;/** *类说明： */public class DBPoolTest {    static DBPool pool  = new DBPool(10);    // 控制器:控制main线程将会等待所有Woker结束后才能继续执行    static CountDownLatch end;    public static void main(String[] args) throws Exception {        // 线程数量        int threadCount = 50;        end = new CountDownLatch(threadCount);        int count = 20;//每个线程的操作次数        AtomicInteger got = new AtomicInteger();//计数器：统计可以拿到连接的线程        AtomicInteger notGot = new AtomicInteger();//计数器：统计没有拿到连接的线程        for (int i = 0; i &lt; threadCount; i++) {            Thread thread = new Thread(new Worker(count, got, notGot),                     &quot;worker_&quot;+i);            thread.start();        }        end.await();// main线程在此处等待        System.out.println(&quot;总共尝试了: &quot; + (threadCount * count));        System.out.println(&quot;拿到连接的次数：  &quot; + got);        System.out.println(&quot;没能连接的次数： &quot; + notGot);    }    static class Worker implements Runnable {        int           count;        AtomicInteger got;        AtomicInteger notGot;        public Worker(int count, AtomicInteger got,                               AtomicInteger notGot) {            this.count = count;            this.got = got;            this.notGot = notGot;        }        public void run() {            while (count &gt; 0) {                try {                    // 从线程池中获取连接，如果1000ms内无法获取到，将会返回null                    // 分别统计连接获取的数量got和未获取到的数量notGot                    Connection connection = pool.fetchConnection(1000);                    if (connection != null) {                        try {                            connection.createStatement();//                            PreparedStatement preparedStatement//                                    = connection.prepareStatement(&quot;&quot;);//                            preparedStatement.execute();                            connection.commit();                        } finally {                            pool.releaseConnection(connection);                            got.incrementAndGet();                        }                    } else {                        notGot.incrementAndGet();                        System.out.println(Thread.currentThread().getName()                                +&quot;等待超时!&quot;);                    }                } catch (Exception ex) {                } finally {                    count--;                }            }            end.countDown();        }    }}</code></pre><h4 id="调用yield-，sleep-，wait-，notify-notifyAll-方法对锁的影响"><a href="#调用yield-，sleep-，wait-，notify-notifyAll-方法对锁的影响" class="headerlink" title="调用yield()，sleep()，wait()，notify()/notifyAll()方法对锁的影响"></a>调用yield()，sleep()，wait()，notify()/notifyAll()方法对锁的影响</h4><p>yield()调用之后会让出cpu执行权参入下次RR调度，sleep()在休眠结束之后需要继续执行之后的代码，所以yield()跟notify()都不会释放资源即不会释放锁，wait()方法被调用之后会释放当前线程所持有的锁进入阻塞态，等待唤醒，当线程被唤醒之后会去竞争锁，竞争到锁之后才会去继续执行。notify()也不会释放锁，而是等notify()/notifyAll()所在的同步代码块执行完之后才会释放锁，所以notify()/notifyAll()通常在同步代码块的最后一行。</p>]]></content>
    
    
    <categories>
      
      <category>并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>并发编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springboot2+shiro+token认证</title>
    <link href="undefined2019/12/13/springboot2-shiro-token%E8%AE%A4%E8%AF%81/"/>
    <url>2019/12/13/springboot2-shiro-token%E8%AE%A4%E8%AF%81/</url>
    
    <content type="html"><![CDATA[<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>从shiro过滤器的源码中可以看到，shiro过滤器拦截请求之后会调用isAccessAllowed()和onAccessDenied()方法，只要其中一个方法返回true，这次请求就会被放行。本文的实现方法是在onAccessDenied()中的执行登录验证即执行executeLogin()方法，这个方法会去执行AuthorizingRealm中的doGetAuthenticationInfo()方法，所以我们只需要在doGetAuthenticationInfo()里实现token的合法性检查，而doGetAuthenticationInfo()中需要AuthenticationToken类，这个类一般是存用户的用户名和密码，所以要重写这个类，把等待验证的token放入这个类，在executeLogin()方法会调用shiro过滤器中的createToken()方法创建AuthenticationToken实例，所以我们只需要重写createToken()方法创建带有token的重写之后的AuthenticationToken类即可。如果验证失败，因为我们是在executeLogin()方法中执行的登录，所以登录失败后会进入shiro过滤器中的onLoginFailure()方法，我们再重写这个方法，将验证失败的结果写入response就可以实现返回json而不是shiro默认的重定向到登录页。</p><p>多点登录限制是借助于redis实现，在用户登录时会将用户id作为键，当前token作为值存入redis中，在验证时获取token中的用户id，然后根据用户id去取redis中的token后对比，如果不同则当前token已经失效，提醒用户重新登录。</p><h2 id="pom文件"><a href="#pom文件" class="headerlink" title="pom文件"></a>pom文件</h2><pre><code>        &lt;!--shiro--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;            &lt;artifactId&gt;shiro-core&lt;/artifactId&gt;            &lt;version&gt;1.4.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;            &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt;            &lt;version&gt;1.4.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--jwt--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.auth0&lt;/groupId&gt;            &lt;artifactId&gt;java-jwt&lt;/artifactId&gt;            &lt;version&gt;3.3.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--redis--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;        &lt;/dependency&gt;</code></pre><h2 id="重写shiro过滤器"><a href="#重写shiro过滤器" class="headerlink" title="重写shiro过滤器"></a>重写shiro过滤器</h2><pre><code>import com.alibaba.fastjson.JSON;import com.minte.english.security.common.utils.JwtUtil;import com.minte.english.security.common.utils.R;import org.apache.commons.lang3.StringUtils;import org.apache.shiro.authc.AuthenticationException;import org.apache.shiro.authc.AuthenticationToken;import org.apache.shiro.web.filter.authc.AuthenticatingFilter;import org.springframework.web.bind.annotation.RequestMethod;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class OAuth2Filter extends AuthenticatingFilter {    @Override    protected AuthenticationToken createToken(ServletRequest request, ServletResponse response) throws Exception {        //获取请求token        String token = JwtUtil.getRequestToken((HttpServletRequest) request);        if(StringUtils.isBlank(token)){            return null;        }        return new OAuth2Token(token);    }    @Override    protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) {        if(((HttpServletRequest) request).getMethod().equals(RequestMethod.OPTIONS.name())){            return true;        }        return false;    }    @Override    protected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception {        //获取请求token，如果token不存在，直接返回401        String token = JwtUtil.getRequestToken((HttpServletRequest) request);        if(StringUtils.isBlank(token)){            HttpServletResponse httpResponse = (HttpServletResponse) response;            httpResponse.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;);            String json = JSON.toJSONString(R.failed(&quot;false&quot;, &quot;获取token信息失败&quot;));            httpResponse.getWriter().print(json);            return false;        }        return executeLogin(request, response);    }    @Override    protected boolean onLoginFailure(AuthenticationToken token, AuthenticationException e, ServletRequest request, ServletResponse response) {        HttpServletResponse httpResponse = (HttpServletResponse) response;        httpResponse.setContentType(&quot;application/json;charset=utf-8&quot;);        try {            //处理登录失败的异常            Throwable throwable = e.getCause() == null ? e : e.getCause();            R r = R.reLogin(throwable.getMessage());            String json = JSON.toJSONString(r);            httpResponse.getWriter().print(json);        } catch (IOException e1) {        }        return false;    }}</code></pre><h2 id="重写AuthorizingRealm"><a href="#重写AuthorizingRealm" class="headerlink" title="重写AuthorizingRealm"></a>重写AuthorizingRealm</h2><pre><code>import com.auth0.jwt.exceptions.TokenExpiredException;import com.minte.english.security.common.utils.JwtUtil;import com.minte.english.security.module.sys.redis.UserRedis;import com.minte.english.security.module.user.pojo.Role;import com.minte.english.security.module.user.pojo.User;import com.minte.english.security.module.user.service.IRoleService;import com.minte.english.security.module.user.service.IUserRoleService;import org.apache.shiro.authc.*;import org.apache.shiro.authc.pam.UnsupportedTokenException;import org.apache.shiro.authz.AuthorizationInfo;import org.apache.shiro.authz.SimpleAuthorizationInfo;import org.apache.shiro.authz.UnauthenticatedException;import org.apache.shiro.realm.AuthorizingRealm;import org.apache.shiro.subject.PrincipalCollection;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;import java.io.UnsupportedEncodingException;import java.util.Arrays;import java.util.HashSet;import java.util.Set;@Componentpublic class OAuth2Realm extends AuthorizingRealm {    @Autowired    private IUserRoleService userRoleService;    @Autowired    private IRoleService roleService;    @Autowired    private UserRedis userRedis;    @Override    public boolean supports(AuthenticationToken token) {        return token instanceof OAuth2Token;    }    /**     * 授权(验证权限时调用)     */    @Override    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {        User user = (User) principals.getPrimaryPrincipal();        Long userId = user.getId();        Integer roleId = userRoleService.getRoleIdByUserId(userId);        Role role = roleService.getById(roleId);        //用户权限列表        Set&lt;String&gt; permsSet = new HashSet&lt;&gt;(Arrays.asList(role.getPermissions().split(&quot;,&quot;)));        SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();        info.setStringPermissions(permsSet);        return info;    }    /**     * 认证(登录时调用)     */    @Override    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {        String accessToken = (String) token.getPrincipal();        // 验证token信息        try {            JwtUtil.verify(accessToken);        } catch (TokenExpiredException e) {            throw new ExpiredCredentialsException();        } catch (UnsupportedEncodingException e) {            throw new UnsupportedTokenException(&quot;token已失效&quot;);        }        // 检测是否在其他设备登录        Long userId = JwtUtil.getUserId(accessToken);        String onlineToken = userRedis.getOnlineUserToken(userId);        if (!onlineToken.equals(accessToken)) {            throw new ConcurrentAccessException(&quot;该账号已在其他设备登录&quot;);        }        // 检查用户授权天数，是否被冻结        User user = userRedis.get(accessToken);        if (user.getValidityDays() &lt;= 0) {            throw new UnauthenticatedException(&quot;授权天数不足&quot;);        }        //账号锁定        if (!user.getEnabled()) {            throw new DisabledAccountException(&quot;该账号已被禁用&quot;);        }        SimpleAuthenticationInfo info = new SimpleAuthenticationInfo(user, accessToken, getName());        return info;    }}</code></pre><h2 id="Config类"><a href="#Config类" class="headerlink" title="Config类"></a>Config类</h2><pre><code>@Configurationpublic class ShiroConfig {    @Bean(&quot;securityManager&quot;)    public SecurityManager securityManager(OAuth2Realm oAuth2Realm) {        DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();        securityManager.setRealm(oAuth2Realm);        securityManager.setRememberMeManager(null);        return securityManager;    }    /**     * setUsePrefix(false)用于解决一个奇怪的bug。在引入spring aop的情况下。     * 在@Controller注解的类的方法中加入@RequiresRole注解，会导致该方法无法映射请求，导致返回404。 加入这项配置能解决这个bug     * 在使用@Transaction注解时出现无法注入bug解决     *     * @return     */    @Bean    public static DefaultAdvisorAutoProxyCreator getDefaultAdvisorAutoProxyCreator() {        DefaultAdvisorAutoProxyCreator creator = new DefaultAdvisorAutoProxyCreator();        creator.setProxyTargetClass(true);        creator.setUsePrefix(false);        return creator;    }    @Bean(&quot;shiroFilter&quot;)    public ShiroFilterFactoryBean shirFilter(SecurityManager manager) {        ShiroFilterFactoryBean shiroFilterFactory = new ShiroFilterFactoryBean();        shiroFilterFactory.setSecurityManager(manager);        Map&lt;String, Filter&gt; filterMap = shiroFilterFactory.getFilters();        filterMap.put(&quot;oauth2&quot;, new OAuth2Filter());        shiroFilterFactory.setFilters(filterMap);        Map&lt;String, String&gt; filterChainDefinitionMap = new LinkedHashMap&lt;&gt;();        filterChainDefinitionMap.put(&quot;/login&quot;, &quot;anon&quot;);        filterChainDefinitionMap.put(&quot;/actuator&quot;, &quot;anon&quot;);        filterChainDefinitionMap.put(&quot;/actuator/**&quot;, &quot;anon&quot;);        filterChainDefinitionMap.put(&quot;/validate/**&quot;, &quot;anon&quot;);        filterChainDefinitionMap.put(&quot;/user/getByUsername&quot;, &quot;anon&quot;);        filterChainDefinitionMap.put(&quot;/**&quot;, &quot;oauth2&quot;);        shiroFilterFactory.setFilterChainDefinitionMap(filterChainDefinitionMap);        return shiroFilterFactory;    }    @Bean(&quot;lifecycleBeanPostProcessor&quot;)    public LifecycleBeanPostProcessor lifecycleBeanPostProcessor() {        return new LifecycleBeanPostProcessor();    }    @Bean    public AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor(SecurityManager securityManager) {        AuthorizationAttributeSourceAdvisor advisor = new AuthorizationAttributeSourceAdvisor();        advisor.setSecurityManager(securityManager);        return advisor;    }}</code></pre><h2 id="重写AuthenticationToken类"><a href="#重写AuthenticationToken类" class="headerlink" title="重写AuthenticationToken类"></a>重写AuthenticationToken类</h2><pre><code>import org.apache.shiro.authc.AuthenticationToken;/** * token * * @author Mark sunlightcs@gmail.com */public class OAuth2Token implements AuthenticationToken {    private String token;    public OAuth2Token(String token){        this.token = token;    }    @Override    public String getPrincipal() {        return token;    }    @Override    public Object getCredentials() {        return token;    }}</code></pre><h2 id="userRedis的配置"><a href="#userRedis的配置" class="headerlink" title="userRedis的配置"></a>userRedis的配置</h2><pre><code>import com.minte.english.security.common.utils.JwtUtil;import com.minte.english.security.common.utils.RedisKeys;import com.minte.english.security.common.utils.RedisUtil;import com.minte.english.security.module.sys.service.ISysConfigService;import com.minte.english.security.module.user.pojo.User;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;/** * @author zgc * @since 2019/12/5 */@Componentpublic class UserRedis {    @Autowired    private RedisUtil redisUtil;    @Autowired    private ISysConfigService sysConfigService;    public void saveOrUpdate(User user, String token) {        String imgPath = sysConfigService.getValue(&quot;ICON_PATH&quot;) + user.getImagePath();        user.setImagePath(imgPath);        redisUtil.set(RedisKeys.getUserKey(token), user, JwtUtil.getExpiresTime(token));    }    public void delete(String token) {        redisUtil.delete(RedisKeys.getUserKey(token));    }    public User get(String token) {        return redisUtil.get(RedisKeys.getUserKey(token), User.class);    }    public void saveOrUpdateOnlineUser(Long userId, String token) {        redisUtil.set(RedisKeys.getOnlineUserKey(userId), token, JwtUtil.getExpiresTime(token));    }    public String getOnlineUserToken(Long userId) {        return redisUtil.get(RedisKeys.getOnlineUserKey(userId), String.class);    }    public void deleteOnlineUser(Long userId, String token) {        if (getOnlineUserToken(userId).equals(token)) {            redisUtil.delete(RedisKeys.getOnlineUserKey(userId));        }    }    public boolean isOnline(Long userId) {        return userId == null ? false : redisUtil.containsKey(RedisKeys.getOnlineUserKey(userId));    }    public void update(User user) {        Long userId = user.getId();        if (isOnline(userId)) {            String token = getOnlineUserToken(userId);            saveOrUpdate(user, token);        }    }}</code></pre><h2 id="Shiro的异常"><a href="#Shiro的异常" class="headerlink" title="Shiro的异常"></a>Shiro的异常</h2><ul><li>AuthenticationException:身份验证异常<ul><li>CredentitalsException:凭证异常<ul><li>IncorrectCredentialsException:不支持的凭证</li><li>ExpiredCredentialsException:凭证过期</li></ul></li><li>AccountException:账号异常<ul><li>ConcurrentAccessException:并发访问异常</li><li>UnknownAccountException:未知的账号</li><li>ExcessiveAttemptsException:认证次数超限</li><li>DisabledAccountException:账号被禁用</li><li>LockedAccountException:账号被锁定</li></ul></li><li>UnsupportedTokenException:Token异常</li></ul></li><li>AuthorizationException:授权异常<ul><li>UnauthorizedException:抛出以指示请求的操作或对请求的资源的访问是不允许的</li><li>UnanthenticatedException:当尚未完成成功认证时，尝试执行授权操作时引发异常</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>shiro</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>shiro</tag>
      
      <tag>token</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ajax跨域访问shiro问题</title>
    <link href="undefined2019/12/06/ajax%E8%B7%A8%E5%9F%9F%E8%AE%BF%E9%97%AEshiro%E9%97%AE%E9%A2%98/"/>
    <url>2019/12/06/ajax%E8%B7%A8%E5%9F%9F%E8%AE%BF%E9%97%AEshiro%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="ajax跨域访问shiro问题"><a href="#ajax跨域访问shiro问题" class="headerlink" title="ajax跨域访问shiro问题"></a>ajax跨域访问shiro问题</h1><p>因为之前的ssm项目要做一次迭代，将前后端不分离改为前后端分离，但是做了跨域设置之后登录可以成功，但其他接口仍然访问不到，前端控制台报错为跨域错误：预请求被重定向。既然登录访问可以成功，说明跨域已经成功，但依然访问不到登录其他接口应该是shiro的问题。查看代码后发现，之前的shiro并没有对预请求进行处理，而且也没有做cookie的跨域，因为shiro所需要的sessionId依赖于cookie或url中的sessionId，但前端没有对sessionId进行处理，cookie也不允许跨域，shiro依然会对登录成功之后的请求进行拦截。所以这次要解决两个问题</p><ol><li>shiro过滤器中放行预请求</li><li>做关于cookie跨域的设置</li></ol><h2 id="ajax参考"><a href="#ajax参考" class="headerlink" title="ajax参考"></a>ajax参考</h2><pre><code>$.ajax({    url:url,    data:{        unitId:&quot;801&quot;    },    // 允许携带cookie跨域    crossDomain: true,     xhrFields:{              withCredentials:true          },    type:&quot;GET&quot;,    success:function(data){        console.log(data);    }})</code></pre><h2 id="后端跨域处理"><a href="#后端跨域处理" class="headerlink" title="后端跨域处理"></a>后端跨域处理</h2><p>因为项目为ssm项目，所以跨域的处理使用filter实现</p><ol><li>添加跨域cookie后，Allow-Origin不能设置为*</li><li>Allow-Method根据情况而定</li></ol><pre><code>@WebFilter(&quot;/*&quot;)public class CORSFilter implements Filter {    public CORSFilter() {    }    public void destroy() {    }    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException {        //设置跨域请求        response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;x-requested-with&quot;);        response.setHeader(&quot;Access-Control-Allow-Method&quot;, &quot;POST, GET, OPTIONS&quot;);        response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;http://localhost:8090&quot;);        response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;);        filterChain.doFilter(request, response);        chain.doFilter(req, response);    }    public void init(FilterConfig fConfig) throws ServletException {    }}</code></pre><h2 id="重写shiro过滤器"><a href="#重写shiro过滤器" class="headerlink" title="重写shiro过滤器"></a>重写shiro过滤器</h2><p>配置中没有定义自己的shiro过滤器，所以都是默认过滤器</p><table><thead><tr><th>Filter Name</th><th>Class</th></tr></thead><tbody><tr><td>anon</td><td>org.apache.shiro.web.filter.authc.AnonymousFilter</td></tr><tr><td>authc</td><td>org.apache.shiro.web.filter.authc.FormAuthenticationFilter</td></tr><tr><td>authcBasic</td><td>org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter</td></tr><tr><td>perms</td><td>org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter</td></tr><tr><td>port</td><td>org.apache.shiro.web.filter.authz.PortFilter</td></tr><tr><td>rest</td><td>org.apache.shiro.web.filter.authz.HttpMethodPermissionFilter</td></tr><tr><td>roles</td><td>org.apache.shiro.web.filter.authz.RolesAuthorizationFilter</td></tr><tr><td>ssl</td><td>org.apache.shiro.web.filter.authz.SslFilter</td></tr><tr><td>user</td><td>org.apache.shiro.web.filter.authc.UserFilter</td></tr></tbody></table><p>根据以上表格，我们需要重写FormAuthenticationFilter及RolesAuthorizationFilter</p><p>FormAuthenticationFilter</p><pre><code>package com.yaoxx.base.shiro;import java.io.PrintWriter;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.apache.commons.lang3.StringUtils;import org.apache.shiro.web.filter.authc.FormAuthenticationFilter;import org.apache.shiro.web.util.WebUtils;import org.springframework.http.HttpStatus;public class MyAuthenticationFilter extends FormAuthenticationFilter {   @Override   protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) {       boolean allowed = super.isAccessAllowed(request, response, mappedValue);       if (!allowed) {           // 判断请求是否是options请求           String method = WebUtils.toHttp(request).getMethod();           if (StringUtils.equalsIgnoreCase(&quot;OPTIONS&quot;, method)) {               return true;           }       }       return allowed;   }   @Override   protected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception {   // 判断是否登录       if (isLoginRequest(request, response)) {          // 判断是否为post访问           if (isLoginSubmission(request, response)) {                return executeLogin(request, response);           } else {               // sessionID已经注册,但是并没有使用post方式提交               return true;           }       } else {           HttpServletRequest req = (HttpServletRequest) request;           HttpServletResponse resp = (HttpServletResponse) response;           String ajaxHeader = req.getHeader(CustomSessionManager.AUTHORIZATION);           if (StringUtils.isNotBlank(ajaxHeader)) {               // 前端Ajax请求，则不会重定向               resp.setHeader(&quot;Access-Control-Allow-Origin&quot;, req.getHeader(&quot;Origin&quot;));               resp.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;);               resp.setContentType(&quot;application/json; charset=utf-8&quot;);               resp.setCharacterEncoding(&quot;UTF-8&quot;);               //设置未登录状态码               resp.setStatus(HttpStatus.UNAUTHORIZED.value());               PrintWriter out = resp.getWriter();               String result = &quot;{\&quot;MESSAGE\&quot;:\&quot;未登录用户\&quot;}&quot;;               out.println(result);               out.flush();               out.close();           } else {               // == 如果是普通访问重定向至shiro配置的登录页面 == //               saveRequestAndRedirectToLogin(request, response);           }       }       return false;   }}</code></pre><p>RolesAuthorizationFilter</p><pre><code>package com.yaoxx.base.shiro;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.apache.commons.lang3.StringUtils;import org.apache.shiro.web.filter.authz.RolesAuthorizationFilter;import org.apache.shiro.web.util.WebUtils;import org.springframework.http.HttpStatus;import org.springframework.web.bind.annotation.RequestMethod;public class MyAuthorizationFilter extends RolesAuthorizationFilter {   @Override   public boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue)throws IOException {       boolean allowed =super.isAccessAllowed(request, response, mappedValue);       if (!allowed) {           String method = WebUtils.toHttp(request).getMethod();           if (StringUtils.equalsIgnoreCase(&quot;OPTIONS&quot;, method)) {               return true;           }       }       return allowed;   }   @Override   protected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws IOException {       HttpServletRequest req = (HttpServletRequest) request;       HttpServletResponse resp = (HttpServletResponse) response;       // 前端Ajax请求时requestHeader里面带一些参数，用于判断是否是前端的请求       String ajaxHeader = req.getHeader(CustomSessionManager.AUTHORIZATION);       if (StringUtils.isNotBlank(ajaxHeader)) {           // 前端Ajax请求，则不会重定向           resp.setHeader(&quot;Access-Control-Allow-Origin&quot;, req.getHeader(&quot;Origin&quot;));           resp.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;);           resp.setContentType(&quot;application/json; charset=utf-8&quot;);           resp.setCharacterEncoding(&quot;UTF-8&quot;);           PrintWriter out = resp.getWriter();           String result = &quot;{\&quot;MESSAGE\&quot;:\&quot;角色，权限不足\&quot;}&quot;;           out.println(result);           out.flush();           out.close();           return false;       }       return super.onAccessDenied(request, response);   }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>shiro</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>shiro</tag>
      
      <tag>bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>summernote文本编辑器的使用</title>
    <link href="undefined2019/08/26/summernote%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>2019/08/26/summernote%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>summernote是一款Jquery文本编辑器的插件，本文只是简单的实现文本编辑及图片上传下载功能，更多api请参考<a href="https://summernote.org/getting-started/" target="_blank" rel="noopener">summernote官方文档</a></p><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>summernote依赖于bootstrap和jquery所以也需要引入bootstrap和jquery</p><pre><code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/lib/bootstrap.min.css&quot; &gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/css/summernote.css&quot;&gt;&lt;script src=&quot;/assets/js/lib/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;/assets/js/lib/bootstrap.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;/js/summernote.js&quot;&gt;&lt;/script&gt;</code></pre><h2 id="html"><a href="#html" class="headerlink" title="html"></a>html</h2><pre><code>&lt;div id=&quot;summernote&quot;&gt;&lt;/div&gt;</code></pre><h2 id="js"><a href="#js" class="headerlink" title="js"></a>js</h2><pre><code>// summernote的初始化方法$(&quot;#summernote&quot;).summernote({    placeholder: &quot;输入内容&quot;,    tabsize: 2,    height: 300,    lang: &#39;zh-CN&#39;,    focus: true,    callbacks: {        onImageUpload: function (files) {                // 上传图片            uploadFile(files[0]);        },        onMediaDelete: function (target){                // 删除图片            deleteFile(target);        }    }});// 上传文件function uploadFile(file){    var imgPath = sendFile(file);    $(&#39;#summernote&#39;).summernote(&#39;insertImage&#39;, imgPath);}// 用于summernote内容回显function getContent(){    var content = $(&#39;#summernote&#39;).summernote(&#39;code&#39;);    if (content==&quot;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&quot;){        return &#39;&#39;;    }    return content;}// 获取summernote的内容function addContent(content){    $(&#39;#summernote&#39;).summernote(&#39;code&#39;, content);}// 上传图片至服务器function sendFile(file) {    if (file == null||file==undefined) {        return null;    }    var formData = new FormData();    formData.append(&quot;file&quot;, file);    console.log(formData);    var filePath = &quot;&quot;;    $.ajax({        url: &quot;/file/upload&quot;,        type: &quot;POST&quot;,        data: formData,        async: false,        contentType: false,        processData: false,        success: function (result) {            filePath = result.data.filePath;        }    });    return filePath;}// 删除服务器图片function deleteFile(filePath) {    $.ajax({        url: &quot;/file/delete&quot;,        type: &quot;POST&quot;,        data: {            &quot;filePath&quot;: filePath        },        success: function (result) {            console.log(result);        }    })}</code></pre><h2 id="java接口"><a href="#java接口" class="headerlink" title="java接口"></a>java接口</h2><pre><code>    @RequestMapping(&quot;/addImg&quot;)    public Map addImg(@RequestParam(&quot;file&quot;) MultipartFile file, HttpServletRequest request) throws IOException {        String fileName = file.getOriginalFilename();        fileName.split(&quot;.&quot;);        System.out.println(&quot;接收到文件:&quot; + fileName);        String fileType = fileName.substring(fileName.lastIndexOf(&quot;.&quot;));        String filePath = new File(&quot;&quot;).getCanonicalFile().getPath() + &quot;/static/images/&quot;;        filePath = filePath + UUID.randomUUID().toString() + fileType;        File dest = new File(filePath);        if (dest.getParentFile() != null) {            dest.getParentFile().mkdirs();        }        try {            file.transferTo(dest);        } catch (IOException e) {            log.warning(&quot;文件上传失败:&quot; + e);            return ResultMap.failed(&quot;文件上传失败&quot;);        }        String path = request.getScheme() + &quot;://&quot; + request.getServerName() + &quot;:&quot;                + request.getServerPort() + request.getContextPath() + &quot;/images/&quot; + dest.getName();        return ResultMap.success(path);    }    @RequestMapping(&quot;deleteImg&quot;)    public Map deleteImg(String imgSrc) {        String fileName = imgSrc.substring(imgSrc.lastIndexOf(&quot;/&quot;) + 1);        System.out.println(fileName);        String filePath = Thread.currentThread().getContextClassLoader().getResource(&quot;&quot;).getPath() + &quot;static/images/&quot;;        filePath = filePath + fileName;        File dest = new File(filePath);        return dest.delete() ? ResultMap.success() : ResultMap.failed();    }</code></pre>]]></content>
    
    
    <categories>
      
      <category>html插件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
      <tag>富文本编辑器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vim的使用</title>
    <link href="undefined2018/12/19/vim%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>2018/12/19/vim%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="vim介绍"><a href="#vim介绍" class="headerlink" title="vim介绍"></a>vim介绍</h2><p>Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。 </p><p>简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。 vim 则可以说是程序开发者的一项很好用的工具。 </p><p>连 vim 的官方网站 (<a href="http://www.vim.org/" target="_blank" rel="noopener">http://www.vim.org</a>) 自己也说 vim 是一个程序开发工具而不是文字处理软件。（这段是复制来的，不说点啥的话不好看）</p><h2 id="1-vim模式"><a href="#1-vim模式" class="headerlink" title="1. vim模式"></a>1. vim模式</h2><pre><code class="text">正常模式（按Esc或Ctrl+[进入） 左下角显示文件名或为空插入模式（按i进入） 左下角显示--INSERT--可视模式（按v进入） 左下角显示--VISUAL--替换模式（按r或R开始） 左下角显示 --REPLACE--命令行模式（按:或者/或者?开始）ex模式 没用过，有兴趣的同学可以自行了解</code></pre><h2 id="2-打开文件"><a href="#2-打开文件" class="headerlink" title="2. 打开文件"></a>2. 打开文件</h2><pre><code class="text"># 打开单个文件vim file    # 同时打开多个文件vim file1 file2..  # 在vim窗口中打开一个新文件:open [file]       【举个例子】# 当前打开1.txt，做了一些编辑没保存:open!         放弃这些修改，并重新打开未修改的文件# 当前打开1.txt，做了一些编辑并保存:open 2.txt    直接退出对1.txt的编辑，直接打开2.txt编辑，省了退出:wq再重新vim 2.txt的步骤# 打开远程文件，比如ftp或者share folder:e ftp://192.168.10.76/abc.txt:e \qadrive\test\1.txt# 以只读形式打开文件，但是仍然可以使用 :wq! 写入vim -R file # 强制性关闭修改功能，无法使用 :wq! 写入vim -M file</code></pre><h2 id="3-插入命令"><a href="#3-插入命令" class="headerlink" title="3. 插入命令"></a>3. 插入命令</h2><pre><code class="text">i 在当前位置生前插入I 在当前行首插入a 在当前位置后插入A 在当前行尾插入o 在当前行之后插入一行O 在当前行之前插入一行</code></pre><h2 id="4-查找命令"><a href="#4-查找命令" class="headerlink" title="4. 查找命令"></a>4. 查找命令</h2><p>最简单的查找</p><pre><code class="text">/text　　查找text，按n健查找下一个，按N健查找前一个。?text　　查找text，反向查找，按n健查找下一个，按N健查找前一个。vim中有一些特殊字符在查找时需要转义　　.*[]^%/?~$:set ignorecase　　忽略大小写的查找:set noignorecase　　不忽略大小写的查找</code></pre><p>快速查找，不需要手打字符即可查找</p><pre><code class="text">*        向后（下）寻找游标所在处的单词#        向前（上）寻找游标所在处的单词以上两种查找，n,N 的继续查找命令依然可以适用</code></pre><p>精准查找：匹配单词查找</p><p>如果文本中有 <code>hello</code>，<code>helloworld</code>，<code>hellopython</code></p><p>那我使用 /hello ，这三个词都会匹配到。</p><p>有没有办法实现精准查找呢？可以使用</p><pre><code class="text">/hello\&gt;</code></pre><p>精准查找：匹配行首、行末</p><pre><code class="text"># hello位于行首/^hello# world位于行末/world$</code></pre><h2 id="5-替换命令"><a href="#5-替换命令" class="headerlink" title="5. 替换命令"></a>5. 替换命令</h2><pre><code class="text">~  反转游标字母大小写r&lt;字母&gt;           将当前字符替换为所写字母R&lt;字母&gt;&lt;字母&gt;...  连续替换字母cc    替换整行（就是删除当前行，并在下一行插入）cw    替换一个单词（就是删除一个单词，就进入插入模式），前提是游标处于单词第一个字母（可用b定位）C     (大写C)替换至行尾（和D有所区别，D是删除（剪切）至行尾，C是删除至行位并进入插入模式）:s/old/new/    用old替换new，替换当前行的第一个匹配:s/old/new/g   用old替换new，替换当前行的所有匹配:%s/old/new/   用old替换new，替换所有行的第一个匹配:%s/old/new/g  用old替换new，替换整个文件的所有匹配:10,20 s/^/ /g 在第10行至第20行每行前面加四个空格，用于缩进。ddp    交换光标所在行和其下紧邻的一行。</code></pre><h2 id="6-撤销与重做"><a href="#6-撤销与重做" class="headerlink" title="6. 撤销与重做"></a>6. 撤销与重做</h2><pre><code class="text">u 撤销（Undo）U 撤销对整行的操作Ctrl + r 重做（Redo），即撤销的撤销。</code></pre><h2 id="7-删除命令"><a href="#7-删除命令" class="headerlink" title="7. 删除命令"></a>7. 删除命令</h2><p>需要说明的是，vim 其实并没有单纯的删除命令，下面你或许理解为剪切更加准确。</p><p>以字符为单位删除</p><pre><code class="text">x   删除当前字符3x  删除当前字符3次X   删除当前字符的前一个字符。3X  删除当前光标向前三个字符dl  删除当前字符， dl=xdh  删除前一个字符，X=dhD   删除当前字符至行尾。D=d$d$  删除当前字符至行尾d^  删除当前字符之前至行首</code></pre><p>以单词为单位删除</p><pre><code class="text">dw  删除当前字符到单词尾daw 删除当前字符所在单词</code></pre><p>以行为单位删除</p><pre><code class="text">dd  删除当前行dj  删除下一行dk  删除上一行dgg  删除当前行至文档首部d1G  删除当前行至文档首部dG   删除当前行至文档尾部kdgg  删除当前行之前所有行（不包括当前行）jdG   删除当前行之后所有行（不包括当前行）10d     删除当前行开始的10行。:1,10d  删除1-10行:11,$d  删除11行及以后所有的行:1,$d   删除所有行J　　   删除两行之间的空行，实际上是合并两行。</code></pre><h2 id="8-复制粘贴"><a href="#8-复制粘贴" class="headerlink" title="8. 复制粘贴"></a>8. 复制粘贴</h2><p>普通模式中使用y复制</p><pre><code class="text">yy   复制游标所在的整行（3yy表示复制3行）y^   复制至行首，或y0。不含光标所在处字符。y$   复制至行尾。含光标所在处字符。yw   复制一个单词。y2w  复制两个单词。yG   复制至文本末。y1G  复制至文本开头。</code></pre><p>普通模式中使用p粘贴</p><pre><code class="text">p(小写)：代表粘贴至光标后（下边，右边）P(大写)：代表粘贴至光标前（上边，左边）</code></pre><h2 id="9-剪切粘贴"><a href="#9-剪切粘贴" class="headerlink" title="9. 剪切粘贴"></a>9. 剪切粘贴</h2><pre><code class="text">dd    其实就是剪切命令，剪切当前行ddp   剪切当前行并粘贴，可实现当前行和下一行调换位置正常模式下按v（逐字）或V（逐行）进入可视模式然后用jklh命令移动即可选择某些行或字符，再按d即可剪切ndd 剪切当前行之后的n行。利用p命令可以对剪切的内容进行粘贴:1,10d 将1-10行剪切。利用p命令可将剪切后的内容进行粘贴。:1, 10 m 20 将第1-10行移动到第20行之后。</code></pre><h2 id="10-退出保存"><a href="#10-退出保存" class="headerlink" title="10. 退出保存"></a>10. 退出保存</h2><pre><code class="text">:wq 保存并退出ZZ 保存并退出:q! 强制退出并忽略所有更改:e! 放弃所有修改，并打开原来文件。ZZ 保存并退出:sav(eas) new.txt  另存为一个新文件，退出原文件的编辑且不会保存:f(ile) new.txt    新开一个文件，并不保存，退出原文件的编辑且不会保存</code></pre><h2 id="11-移动命令"><a href="#11-移动命令" class="headerlink" title="11. 移动命令"></a>11. 移动命令</h2><p>以字符为单位移动</p><pre><code class="text">h   左移一个字符l   右移一个字符k   上移一个字符j   下移一个字符# 【定位字符】f和Ffx    找到光标后第一个为x的字符3fd   找到光标后第三个为d的字符F   同f，反向查找。</code></pre><p>以行为单位移动</p><pre><code class="text"># 10指代所有数字，可任意指定10h  左移10个字符10l  右移10个字符10k  上移10行10j  下移10行$   移动到行尾 3$  移动到下面3行的行尾</code></pre><p>以单词为单位移动</p><pre><code class="text">w  向前移动一个单词（光标停在单词首部）b  向后移动一个单词e，同w，只不过是光标停在单词尾部ge 同b，光标停在单词尾部。</code></pre><p>以句为单位移动</p><pre><code class="text">(   移动到句首)   移动到句尾</code></pre><p>跳转到文件的首尾</p><pre><code class="text">gg  移动到文件头。 = [[  == ``G   移动到文件尾。 = ]]</code></pre><p>其他移动方法</p><pre><code class="text">^   移动到本行第一个非空白字符上。0   移动到本行第一个字符上(可以是空格)</code></pre><p>使用 <code>具名标记</code> 跳转，个人感觉这个很好用，因为可以跨文件。</p><pre><code class="text">使用 ma ，可以将此处标记为 a，使用 &#39;a 进行跳转使用 :marks 可以查看所有的标记使用 :delm！可以删除所有的标记</code></pre><p>当在查看错误日志时，正常的步骤是，vim打开文件，然后使用 <code>shift+g</code> 再跳转到最后一行，这里有个更简单的操作可以在打开文件时立即跳到最后一行。只要在 vim 和 文件 中间加个 <code>+</code>即可。</p><pre><code class="text">vim + you.log</code></pre><p>举一反三，当你想打开文件立即跳转到指定行时，可以这样</p><pre><code class="text"># 打开文件并跳转到 20 行vim you.log +20</code></pre><p>当你使用 <code>/</code> 搜索定位跳转或者使用 <code>:行号</code> 进行精准跳转时，有时我们想返回到上一次的位置，如何实现？</p><p>只要使用 Ctrl+o 即可返回上一次的位置。</p><h2 id="12-排版功能"><a href="#12-排版功能" class="headerlink" title="12. 排版功能"></a>12. 排版功能</h2><p><strong>缩进</strong></p><pre><code class="text">:set shiftwidth?   查看缩进值:set shiftwidth=4  设置缩进值为4# 缩进相关 最好写到配置文件中  ~/.vimrc:set tabstop=4:set softtabstop=4:set shiftwidth=4:set expandtab&gt;&gt;   向右缩进&lt;&lt;   取消缩进</code></pre><p>如何你要对代码进行缩进，还可以用 <code>==</code> 对当前行缩进，如果要对多行对待缩进，则使用 n<code>==</code>，这种方式要求你所编辑的文件的扩展名是被vim所识别的，比如<code>.py</code>文件。</p><p><strong>排版</strong></p><pre><code class="text">:ce   居中:le   靠左:ri   靠右</code></pre><h2 id="13-注释命令"><a href="#13-注释命令" class="headerlink" title="13. 注释命令"></a>13. 注释命令</h2><p><strong>多行注释</strong></p><pre><code class="text">进入命令行模式，按ctrl + v进入 visual block模式，然后按j, 或者k选中多行，把需要注释的行标记起来按大写字母I，再插入注释符，例如//按esc键就会全部注释了</code></pre><p><strong>取消多行注释</strong></p><pre><code class="text">进入命令行模式，按ctrl + v进入 visual block模式，按字母l横向选中列的个数，例如 // 需要选中2列按字母j，或者k选中注释符号按d键就可全部取消注释</code></pre><p><strong>复杂注释</strong></p><pre><code class="text">:3,5 s/^/#/g 注释第3-5行:3,5 s/^#//g 解除3-5行的注释:1,$ s/^/#/g 注释整个文档:1,$ s/^#//g 取消注释整个文档:%s/^/#/g 注释整个文档，此法更快:%s/^#//g 取消注释整个文档</code></pre><h2 id="14-调整视野"><a href="#14-调整视野" class="headerlink" title="14. 调整视野"></a>14. 调整视野</h2><pre><code class="text">&quot;zz&quot;：命令会把当前行置为屏幕正中央，&quot;zt&quot;：命令会把当前行置于屏幕顶端&quot;zb&quot;：则把当前行置于屏幕底端.Ctrl + e 向下滚动一行Ctrl + y 向上滚动一行Ctrl + d 向下滚动半屏Ctrl + u 向上滚动半屏Ctrl + f 向下滚动一屏Ctrl + b 向上滚动一屏【跳到指定行】：两种方法可以先把行号打开:set nu  打开行号:20    跳到第20行20G    跳到第20行</code></pre><h2 id="15-区域选择"><a href="#15-区域选择" class="headerlink" title="15. 区域选择"></a>15. 区域选择</h2><pre><code class="text">要进行区域选择，要先进入可视模式v   以字符为单位，上下左右选择V   以行为单位，上下选择选择后可进行操作d   剪切/删除y   复制Ctrl+v   如果当前是V(大写)模式，就变成v(小写)         如果当前是v(小写)模式，就变成普通模式。         如果当前是普通模式，就进入v(小写)模式利用这个，可以进行多行缩进。ggVG   选择全文</code></pre><h2 id="16-窗口控制"><a href="#16-窗口控制" class="headerlink" title="16. 窗口控制"></a>16. 窗口控制</h2><p><strong>新建窗口</strong></p><pre><code class="text"># 打开两个文件分属两个窗口vim -o 1.txt 2.txt# 假设现在已经打开了1.txt:sp 2.txt   开启一个横向的窗口，编辑2.txt:vsp 2.txt  开启一个竖向的窗口，编辑2.txt:split        将当前窗口再复制一个窗口出来，内容同步，游标可以不同:split 2.txt  在新窗口打开2.txt的横向窗口# 需要注意：内容同步，但是游标位置是独立的Ctrl-w s    将当前窗口分成水平窗口Ctrl-w v    将当前窗口分成竖直窗口Ctrl-w q    等同:q 结束分割出来的视窗。Ctrl-w q!   等同:q! 结束分割出来的视窗。Ctrl-w o    打开一个视窗并且隐藏之前的所有视窗</code></pre><p><strong>窗口切换</strong></p><pre><code class="text"># 特别说明：Ctrl w &lt;字母&gt; 不需要同时按Ctrl-w h    切换到左边窗口Ctrl-w l    切换到右边窗口Ctrl-w j    切换到下边窗口Ctrl-w k    切换到上边窗口# 特别说明：全屏模式下:n    切换下一个窗口:N    切换上一个窗口:bp   切换上一个窗口# 特别说明：非全屏模式:bn    切换下一个窗口，就当前位置的窗口的内容变了，其他窗口不变:bN    切换上一个窗口，就当前位置的窗口的内容变了，其他窗口不变</code></pre><p><strong>窗口移动</strong></p><pre><code class="text"># 特别说明：Ctrl w &lt;字母&gt; 不需要同时按Ctrl-w J   将当前视窗移至最下面Ctrl-w K   将当前视窗移最上面Ctrl-w H   将当前视窗移至最左边Ctrl-w L   将当前视窗移至最右边Ctrl-ww    按顺序切换窗口</code></pre><p><strong>调整尺寸</strong></p><pre><code class="text"># 友情提示：键盘切记不要处于中文状态Ctrl-w +   增加窗口高度Ctrl-w -   减少窗口高度</code></pre><p><strong>退出窗口</strong></p><pre><code class="text">:close    关闭当前窗口:close!   强制关闭当前窗口:q       退出，不保存:q!      强制退出，不保存:x       保存退出:wq      保存退出:wq!     强制保存退出:w &lt;[路径/]文件名&gt;        另存为:savesa &lt;[路径/]文件名&gt;   另存为ZZ 保存并退出。:only    关闭所有窗口，只保留当前窗口(前提：其他窗口内容有改变的话都要先保存):only!   关闭所有窗口，只保留当前窗口:qall 放弃所有操作并退出:wall 保存所有，:wqall 保存所有并退出。</code></pre><h2 id="17-文档加密"><a href="#17-文档加密" class="headerlink" title="17. 文档加密"></a>17. 文档加密</h2><pre><code class="text">vim -x file_name然后输入密码：确认密码：如果不修改内容也要保存。:wq，不然密码设定不会生效。</code></pre><h2 id="18-录制宏"><a href="#18-录制宏" class="headerlink" title="18. 录制宏"></a>18. 录制宏</h2><p>按q键加任意字母开始录制，再按q键结束录制（这意味着vim中的宏不可嵌套），使用的时候@加宏名，比如qa。。。q录制名为a的宏，@a使用这个宏。</p><h2 id="19-执行命令"><a href="#19-执行命令" class="headerlink" title="19. 执行命令"></a>19. 执行命令</h2><pre><code class="text"># 重复前一次命令. # 执行shell命令:!command# 比如列出当前目录下文件:!ls # 执行脚本:!perl -c script.pl 检查perl脚本语法，可以不用退出vim，非常方便。:!perl script.pl 执行perl脚本，可以不用退出vim，非常方便。:suspend或Ctrl - Z 挂起vim，回到shell，按fg可以返回vim。</code></pre><h2 id="20-帮助命令"><a href="#20-帮助命令" class="headerlink" title="20. 帮助命令"></a>20. 帮助命令</h2><pre><code class="text">在Unix/Linux系统上$ vimtutor# 普通模式下键盘输入vim或F1# 命令行模式下:help     显示整个帮助:help xxx 显示xxx的帮助，比如 :help i, :help CTRL-[（即Ctrl+[的帮助）。:help &#39;number&#39; Vim选项的帮助用单引号括起在Windows系统上:help tutor</code></pre><h2 id="21-配置命令"><a href="#21-配置命令" class="headerlink" title="21. 配置命令"></a>21. 配置命令</h2><p>显示当前设定</p><pre><code class="text">:set或者:se显示所有修改过的配置:set all 显示所有的设定值:set option? 显示option的设定值:set nooption 取消当期设定值:ver   显示vim的所有信息（包括版本和参数等）# 需要注意：全屏模式下:args   查看当前打开的文件列表，当前正在编辑的文件会用[]括起来</code></pre><p>更改设定</p><pre><code class="text">:set nu   显示行号set autoindent(ai)   设置自动缩进set autowrite(aw)    设置自动存档，默认未打开set backup(bk) 设置自动备份，默认未打开set background=dark或light，设置背景风格set cindent(cin) 设置C语言风格缩进:set ts=4   设置tab键转换为4个空格:set ff=unix   # 修改文件dos文件为unix:set shiftwidth?   查看缩进值:set shiftwidth=4  设置缩进值为4:set ignorecase　　忽略大小写的查找:set noignorecase　　不忽略大小写的查找:set paste  # insert模式下，粘贴格式不会乱掉:set ruler?　　查看是否设置了ruler，在.vimrc中，使用set命令设制的选项都可以通过这个命令查看:scriptnames　　查看vim脚本文件的位置，比如.vimrc文件，语法文件及plugin等。:set list 显示非打印字符，如tab，空格，行尾等。如果tab无法显示，请确定用set lcs=tab:&gt;-命令设置了.vimrc文件，并确保你的文件中的确有tab，如果开启了expendtab，那么tab将被扩展为空格。:syntax        列出已经定义的语法项:syntax clear  清除已定义的语法规则:syntax case match    大小写敏感，int和Int将视为不同的语法元素:syntax case ignore   大小写无关，int和Int将视为相同的语法元素，并使用同样的配色方案</code></pre><img src="/2018/12/19/vim%E7%9A%84%E4%BD%BF%E7%94%A8/pic1.png" srcset="/img/loading.gif" class=""><img src="/2018/12/19/vim%E7%9A%84%E4%BD%BF%E7%94%A8/pic2.png" srcset="/img/loading.gif" class=""><img src="/2018/12/19/vim%E7%9A%84%E4%BD%BF%E7%94%A8/pic3.png" srcset="/img/loading.gif" class=""><img src="/2018/12/19/vim%E7%9A%84%E4%BD%BF%E7%94%A8/pic4.png" srcset="/img/loading.gif" class="">]]></content>
    
    
    <categories>
      
      <category>快速开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>