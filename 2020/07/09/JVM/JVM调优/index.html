

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/blog/img/favicon.png">
  <link rel="icon" href="/blog/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="">
  <meta name="keywords" content="">
  
  <title>JVM调优 - 萤火的博客</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/blog/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.1.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/blog/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"zhaoguocheng.gitee.io","root":"/blog/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":200}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/blog/js/utils.js" ></script>
  <script  src="/blog/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/blog/">&nbsp;<strong>萤火的博客</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/">
                <i class="iconfont icon-home-fill"></i>
                主页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/blog/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="JVM调优">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-07-09 17:51" pubdate>
        2020年7月9日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      6.7k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      77
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">JVM调优</h1>
            
            <div class="markdown-body">
              <h3 id="JVM的运行时参数"><a href="#JVM的运行时参数" class="headerlink" title="JVM的运行时参数"></a>JVM的运行时参数</h3><p>jvm的参数类型分为三类：</p>
<ul>
<li>标准参数：-help、-version</li>
<li>-X参数（非标准参数）：-Xint、-Xcomp</li>
<li>-XX参数（使用率较高）：-XX:newSize、-XX:+UseSerialGC</li>
</ul>
<h4 id="标准参数"><a href="#标准参数" class="headerlink" title="标准参数"></a>标准参数</h4><p>jvm的标准参数，一般都是很稳定的，在未来的JVM版本中不会改变，可以使用java -help检索出所有的标准参数。</p>
<p>通过-D设置系统属性参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestJVM</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    String str = System.getProperty(<span class="hljs-string">&quot;str&quot;</span>);<br>    <span class="hljs-keyword">if</span> (str == <span class="hljs-keyword">null</span>) &#123;<br>      System.out.println(<span class="hljs-string">&quot;itcast&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      System.out.println(str); <br>    &#125; <br>  &#125; <br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">F:\t&gt;javac TestJVM.java<br>F:\t&gt;java TestJVM itcast<br>F:\t&gt;java -Dstr=123 TestJVM 123<br></code></pre></td></tr></table></figure>

<h5 id="server与-client参数"><a href="#server与-client参数" class="headerlink" title="-server与-client参数"></a>-server与-client参数</h5><p>可以通过-server或-client设置jvm的运行参数。它们的区别是Server VM的初始堆空间会大一些，默认使用的是并行垃圾回收器，启动慢运行快。Client VM相对来讲会保守一些，初始堆空间会小一些，使用串行的垃圾回收器，它的目标是为了让JVM的启动速度更快，但运行速度会比Server模式慢些。</p>
<p>JVM在启动的时候会根据硬件和操作系统自动选择使用Server还是Client类型的JVM。</p>
<p>32位操作系统</p>
<ul>
<li><p>如果是Windows系统，不论硬件配置如何，都默认使用Client类型的JVM。</p>
</li>
<li><p>如果是其他操作系统上，机器配置有2GB以上的内存同时有2个以上CPU的话默认使用server模式，否则使用client模式。</p>
</li>
</ul>
<p>64位操作系统</p>
<ul>
<li>只有server类型，不支持client类型。</li>
</ul>
<h4 id="X参数"><a href="#X参数" class="headerlink" title="-X参数"></a>-X参数</h4><p>jvm的-X参数是非标准参数，在不同版本的jvm中，参数可能会有所不同，可以通过java -X查看非标准参数。</p>
<h5 id="Xint、-Xcomp、-Xmixed"><a href="#Xint、-Xcomp、-Xmixed" class="headerlink" title="-Xint、-Xcomp、-Xmixed"></a>-Xint、-Xcomp、-Xmixed</h5><ul>
<li><p>在解释模式(interpreted mode)下，-Xint标记会强制JVM执行所有的字节码，当然这会降低运行速度，通常低10倍或更多。</p>
</li>
<li><p>-Xcomp参数与它（-Xint）正好相反，JVM在第一次使用时会把所有的字节码编译成本地代码，从而带来最大程度的优化。</p>
<blockquote>
<p>然而，很多应用在使用-Xcomp也会有一些性能损失，当然这比使用-Xint损失的少，原因是- xcomp没有让JVM启用JIT编译器的全部功能。JIT编译器可以对是否需要编译做判断，如果所有代码都进行编译的话，对于一些只执行一次的代码就没有意义了。</p>
</blockquote>
</li>
<li><p>-Xmixed是混合模式，将解释模式与编译模式进行混合使用，由jvm自己决定，这是jvm默认的模</p>
<p>式，也是推荐使用的模式。</p>
</li>
</ul>
<h5 id="Xms与-Xmx参数"><a href="#Xms与-Xmx参数" class="headerlink" title="-Xms与-Xmx参数"></a>-Xms与-Xmx参数</h5><p>-Xms与-Xmx分别是设置jvm的堆内存的初始大小和最大大小。</p>
<p>-Xmx2048m：等价于-XX:MaxHeapSize，设置JVM最大堆内存为2048M。</p>
<p>-Xms512m：等价于-XX:InitialHeapSize，设置JVM初始堆内存为512M。</p>
<h4 id="XX参数"><a href="#XX参数" class="headerlink" title="-XX参数"></a>-XX参数</h4><p>-XX参数也是非标准参数，主要用于jvm的调优和debug操作。</p>
<p>-XX参数的使用有2种方式，一种是boolean类型，一种是非boolean类型：</p>
<ul>
<li>boolean类型<ul>
<li>格式：-XX:[+-]&lt;name&gt; 表示启用或禁用&lt;name&gt;属性</li>
<li>如：-XX:+DisableExplicitGC 表示禁用手动调用gc操作，也就是说调用System.gc()无效</li>
</ul>
</li>
<li>非boolean类型<ul>
<li>格式：-XX:&lt;name&gt;=&lt;value&gt; 表示&lt;name&gt;属性的值为&lt;value&gt;</li>
<li>如：-XX:NewRatio=4 表示新生代和老年代的比值为1:4</li>
</ul>
</li>
</ul>
<h4 id="JVM调优相关参数"><a href="#JVM调优相关参数" class="headerlink" title="JVM调优相关参数"></a>JVM调优相关参数</h4><ul>
<li>-Xms：Java堆内存初始大小</li>
<li>-Xmx：Java堆内存最大大小</li>
<li>-Xmn：Java堆内存中的新生代大小</li>
<li>-XX:PermSize：永久代初始大小</li>
<li>-XX:MaxPermSize：永久代最大大小</li>
<li>-Xss：每个线程的栈内存大小</li>
<li>-XX:SurvivorRatio：Eden区比例</li>
<li>-XX:MaxTenuringThreshold：对象进入老年代的年龄阈值</li>
<li>-XX:PretenureSizeThreshold：对象直接进入老年代的大小阈值</li>
<li>-XX:+UseParNewGC：使用ParNew垃圾回收器对新生代进行回收</li>
<li>-XX:ParallelGCThreads：ParNew GC的线程数量</li>
<li>-XX:+UseConcMarkSweepGC：使用CMS垃圾回收器对老年代进行回收</li>
<li>-XX:CMSInitiatingOccupancyFaction：老年代空间占用多少比例时，进行回收</li>
<li>-XX:UseCMSCompactAtFullCollection：在Full GC之后要再次进行STW，默认开启</li>
<li>-XX:CMSFullGCsBeforeCompaction：执行多少次Full GC之后，进行内存碎片整理的工作，默认为0，每次都会执行</li>
</ul>
<h4 id="查看正在运行的jvm参数"><a href="#查看正在运行的jvm参数" class="headerlink" title="查看正在运行的jvm参数"></a>查看正在运行的jvm参数</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">//查找应用进程编号<br>jps -l<br>//查看运行参数<br>jinfo -flags [进程编号]<br></code></pre></td></tr></table></figure>

<h3 id="JVM优化案例"><a href="#JVM优化案例" class="headerlink" title="JVM优化案例"></a>JVM优化案例</h3><h4 id="日处理上亿数据的计算系统"><a href="#日处理上亿数据的计算系统" class="headerlink" title="日处理上亿数据的计算系统"></a>日处理上亿数据的计算系统</h4><p>这个系统会不同的从MySQL数据库以及其他数据源里提取大量数据，加载到自己的JVM内存来进行计算，每分钟大概需要执行500次数据提取和计算任，每台机器每分钟大概100次任务，每次提取1万条数据加载到内存中，每条数据大概20个字段，每条数据平均1KB左右，相当于每次提取10MB数据。每次计算大概耗费10s左右，每台机器是4核8G的配置，JVM内存是4G，新生代和老年代都是1.5G空间。</p>
<p>如果按照8:1:1的比例分配内存，Eden区大小为1.2GB，每块Survivor区域在150MB左右，按照这个内存计算，每一次计算任务都会在Eden区分配10MB左右的对象，不到一分钟就会占满Eden区。</p>
<p>Minor GC时，首先检查老年代大小，发现老年代有1.5G空间，可以进行Minor GC，此时大约由30个计算任务还在继续，就有300MB对象不能被回收掉，然后需要回收掉900MB对象，此时300MB的对象超过了Survivor To区域的大小，会全部直接进入老年代，之后每次Minor GC都会有300MB的对象进入到老年代。在下次Minor GC时，老年代已经有300MB对象，剩余空间1.2GB，不足以容纳新生代全部对象，就会检查空间分配担保参数的验证，此时就会发现老年代空间可以允许Minor GC后平均300MB的数据进入的，所以又进行一次Minor GC，300MB对象进入老年代，大概2分钟过后，又有600MB的对象进入到老年代，老年代剩余空间不足300MB。在下一次Minor GC之前的空间分配担保就会验证失败，触发一次Full GC。</p>
<p>FullGC会把老年代里的垃圾对象全部回收，老年代对象几乎会被全部清空，紧接着Minor GC又会有300MB对象进入到老年代，按照这个运行模型，平均五六分钟就会进行一次Full GC，频率比较高。</p>
<p>这就需要对Survivor的大小进行调整，使得Survivor可以容纳正在进行的任务大小，等到下次Minor GC时，Survivor中存放的计算任务已经结束，就会被清空掉，就足够容纳当前进行的任务，这样基本很少有对象会进入老年代，降低FullGC的频率。</p>
<p>调整Survivor区域大小时需要注意，如果Survivor区域中的同龄对象大小，已经占用了超过Survivor区域的内存大小，就会直接升入老年代。可以调整-XX:SurvivorRatio、-Xmn以及这两个参数，对Survivor区大小进行调整。</p>
<p>参数调整为：jvm内存区6g，新生代大小6g，新生代区域比例,6:2:2</p>
<h4 id="上亿请求的电商系统"><a href="#上亿请求的电商系统" class="headerlink" title="上亿请求的电商系统"></a>上亿请求的电商系统</h4><p>按照每个用户20次计算，上亿请求需要有500万日活用户，500万日活用户按照10%的付费转化率，每天大概有50万人会下订单，每天会有50万订单，50万订单集中在4小时的高峰期内，每秒钟大概几十个订单。</p>
<p>但是在双十一期间，零点的十分钟内，大概会有50万订单，每秒会有接近1000的下单请求，按照每台机器每秒300请求来计算，大概需要3太服务器，每台服务器4核8g，从CPU和内存资源的角度，完全可以支撑每秒钟300的访问。问题就在于对JVM内存资源的分配和优化。让GC次数尽可能最少，尽量避免full gc，减少JVM的GC对高峰期系统的影响。</p>
<p>假设订单对象中包含30个实例变量，int类型4字节，long类型8字节，引用类型8字节，按照每个订单1kb的带下来计算，300个订单会有300kb的开销。然后加上一系列连带的对象，单个对象内存占用需要放大10-20倍，除此之外还会有很多订单相关的其他操作，连带起来大概需要再扩大10倍。这样的话大概每秒钟300kb*20*10=60mb的开销，但是这60mb的对象只有一秒钟的存活时间。</p>
<p>一般来说4核8G的机器，会给到JVM4G的内存空间，剩下的空间留给操作系统以及其他应用，堆内存可以给到3G，新生代1.5G，老年代1.5G，这样每个线程的虚拟机栈就有1M，JVM如果几百个线程大概会有几百M。</p>
<p>jvm参数设置</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">-Xms3072M -Xmx3072M -Xmn1536M -Xss1M -XX:<span class="hljs-attribute">PermSize</span>=256M -XX:<span class="hljs-attribute">MaxPermSize</span>=256M<br></code></pre></td></tr></table></figure>

<p>由于-XX:HandlePromotionFailure再jdk1.6之后废弃了，只要判断老年代可用空间大于新生代对象总和或老年代空间大于历次Minor GC升入老年代对象的平均大小，两个条件只要满足一个，就可以直接进行Minor GC，不需要提前触发Full GC了。</p>
<p>那么新生代1.5G大概在25秒后就会占满，此时进行Minor GC，这次老年代空间的检查是一定会通过的，此时99%的对象被回收，存活对象大概在100MB左右。接下来在运行20秒，Eden区占满，再次回收Eden区对象核Survivor区对象，存活对象还是100MB左右。</p>
<p>在进行JVM优化的时候，第一个需要考虑的就是Survivor区是否够用，如果出现Minor GC过后，存活对象大于Survivor区域大小，对象就会直接进入老年代，即使Survivor空间足够，如果一批同龄对象进入Survivor区，直接超过Survivor区的50%，也会直接进入老年代。</p>
<p>显然Survivor区的大小是不足的。对于这种普通业务对象，大部分对象都是短生存周期的，不应该频繁进入老年代，老年代空间可以适量缩小，让新生代对象尽量留在新生代。所以可以把新生代调整为2G，老年代为1G，此时Eden为1.6G，Survivor为200MB，这样就降低了Minor GC过后，存活对象在Survivor里放不下的问题，或是同龄对象超过Survivor 50%的问题。JVM参数如下：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">-Xms3072M -Xmx3072M -Xmn2048M -Xss1M -XX:<span class="hljs-attribute">PermSize</span>=256M -XX:<span class="hljs-attribute">MaxPermSize</span>=256M XX:<span class="hljs-attribute">SurvivorRatio</span>=8<br></code></pre></td></tr></table></figure>

<p>对于-XX:MaxTenuringThreshold参数，表示对象年龄在多少之后，进入老年代。这个参数的设置要结合实际情况，像之前分析的大约半分钟进行一次Minor GC，这样的话对象存活超过七分钟，才会进入老年代，一般这样的对象都是Spring管理的Bean，调大这个参数是没有必要的。但如果Minor GC的特别频繁，或者一些对象存活时间比较久，就需要适当的进行增加。也可以尝试调小参数，比如现在的场景，一般对象的存活时间很长，可以将-XX:MaxTenuringThreshold设置为5，让长期对象直接进入老年代，避免占用Survivor区域，以及来回移动产生的开销。JVM参数如下：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">-Xms3072M -Xmx3072M -Xmn2048M -Xss1M -XX:<span class="hljs-attribute">PermSize</span>=256M -XX:<span class="hljs-attribute">MaxPermSize</span>=256M XX:<span class="hljs-attribute">SurvivorRatio</span>=8 -XX:<span class="hljs-attribute">MaxTenuringThreshold</span>=5<br></code></pre></td></tr></table></figure>

<p>大对象直接进入老年代，一般来说对大象都是要长期存活使用的，一般来说很少有超过1MB的对象，可以设置为1MB，JVM参数如下：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">-Xms3072M -Xmx3072M -Xmn2048M -Xss1M -XX:<span class="hljs-attribute">PermSize</span>=256M -XX:<span class="hljs-attribute">MaxPermSize</span>=256M XX:<span class="hljs-attribute">SurvivorRatio</span>=8 -XX:<span class="hljs-attribute">MaxTenuringThreshold</span>=5 -XX:<span class="hljs-attribute">PretenureSizeThreshold</span>=1M<br></code></pre></td></tr></table></figure>

<p>指定JVM垃圾回收器</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">-Xms3072M -Xmx3072M -Xmn2048M -Xss1M -XX:<span class="hljs-attribute">PermSize</span>=256M -XX:<span class="hljs-attribute">MaxPermSize</span>=256M XX:<span class="hljs-attribute">SurvivorRatio</span>=8 -XX:<span class="hljs-attribute">MaxTenuringThreshold</span>=5 -XX:<span class="hljs-attribute">PretenureSizeThreshold</span>=1M -XX:+UseConcMarkSweepGC -XX:+UseParNewGC<br></code></pre></td></tr></table></figure>

<p>假设系统负载并不是很均衡，高峰可能创建出来的对象过多，每隔5分钟会在Minor GC之后，有200MB对象进入老年代。首先检查老年代空间是否大于新生代总空间，以及历次Minor GC之后升入老年代的平均大小，如果这次检查通过，就会继续检查-XX:CMSInitiatingOccupancyFaction的比例，比如设定为92%，那么老年代空间使用超过92%就会自行触发Full GC。按照每十分钟200mb对象进入的比例，老年代的增加速度是很慢的，可能在系统运行半小时~1小时之后，才会有1GB的数据进入老年代。这时大促进期间的高峰期已经过了，才会触发Full GC。JVM参数</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">-Xms3072M -Xmx3072M -Xmn2048M -Xss1M -XX:<span class="hljs-attribute">PermSize</span>=256M -XX:<span class="hljs-attribute">MaxPermSize</span>=256M XX:<span class="hljs-attribute">SurvivorRatio</span>=8 -XX:<span class="hljs-attribute">MaxTenuringThreshold</span>=5 -XX:<span class="hljs-attribute">PretenureSizeThreshold</span>=1M -XX:+UseConcMarkSweepGC -XX:+UseParNewGC -XX:<span class="hljs-attribute">CMSInitiationgOccupancyFaction</span>=92 -XX:<span class="hljs-attribute">CMSFullGCsBeforeCompaction</span>=0<br></code></pre></td></tr></table></figure>

<p>如果在CMS在进行老年代的并发回收前，Minor GC触发，有200MB的对象要进入老年代，这时候就会触发Concurrent Mode Failure，然后切换CMS为Serial Old，进行STW，然后单线程回收老年代。不过这种概率是比较小的，没必要专门优化参数。内存碎片整理次数保持默认即可，每次Full GC之后对进行内存整理。</p>
<h3 id="JVM工具"><a href="#JVM工具" class="headerlink" title="JVM工具"></a>JVM工具</h3><h4 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h4><p>jstat命令可以查看堆内存各部分的使用量，以及加载类的数量。命令的格式如下：</p>
<p>jstat -[命令选项] [vmid] [间隔时间/毫秒] [查询次数]</p>
<h5 id="class加载统计"><a href="#class加载统计" class="headerlink" title="class加载统计"></a>class加载统计</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">MacBookPro:~ zhaoguocheng$ jstat -class 10730<br>Loaded  Bytes  Unloaded  Bytes     Time   <br> 60210 125331.7      953   983.7      47.72<br></code></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li><p>Loaded：加载class的数量</p>
</li>
<li><p>Bytes：所占用空间大小</p>
</li>
<li><p>Unloaded：未加载数量</p>
</li>
<li><p>Bytes：未加载占用空间</p>
</li>
<li><p>Time：时间</p>
</li>
</ul>
<h5 id="垃圾回收统计"><a href="#垃圾回收统计" class="headerlink" title="垃圾回收统计"></a>垃圾回收统计</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">MacBookPro:~ zhaoguocheng$ jstat -gc 10730<br> S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT   <br>17472.0 17472.0 14212.5  0.0   139776.0 101291.8  508884.0   274618.0  403292.0 385091.1 52184.0 45738.3    196    1.968   0      0.000    1.968<br><span class="hljs-meta">#</span><span class="bash">指定每秒钟打印一次，总共打印五次</span><br>MacBookPro:~ zhaoguocheng$ jstat -gc 10730<br><span class="hljs-meta">#</span><span class="bash">说明</span><br><span class="hljs-meta">#</span><span class="bash">S0C：第一个Survivor区的大小（KB）</span><br><span class="hljs-meta">#</span><span class="bash">S1C：第二个Survivor区的大小（KB）</span><br><span class="hljs-meta">#</span><span class="bash">S0U：第一个Survivor区的使用大小（KB）</span><br><span class="hljs-meta">#</span><span class="bash">S1U：第二个Survivor区的使用大小（KB）</span><br><span class="hljs-meta">#</span><span class="bash">EC：Eden区的大小（KB）</span><br><span class="hljs-meta">#</span><span class="bash">EU：Eden区的使用大小（KB）</span><br><span class="hljs-meta">#</span><span class="bash">OC：Old区大小（KB）</span><br><span class="hljs-meta">#</span><span class="bash">OU：Old使用大小（KB）</span><br><span class="hljs-meta">#</span><span class="bash">MC：方法区大小（KB）</span><br><span class="hljs-meta">#</span><span class="bash">MU：方法区使用大小（KB） CCSC：压缩类空间大小（KB） CCSU：压缩类空间使用大小（KB） YGC：年轻代垃圾回收次数</span><br><span class="hljs-meta">#</span><span class="bash">YGCT：年轻代垃圾回收消耗时间</span><br><span class="hljs-meta">#</span><span class="bash">FGC：老年代垃圾回收次数</span><br><span class="hljs-meta">#</span><span class="bash">FGCT：老年代垃圾回收消耗时</span><br></code></pre></td></tr></table></figure>

<h3 id="GC-Easy可视化工具"><a href="#GC-Easy可视化工具" class="headerlink" title="GC Easy可视化工具"></a>GC Easy可视化工具</h3><h4 id="GC日志输出参数"><a href="#GC日志输出参数" class="headerlink" title="GC日志输出参数"></a>GC日志输出参数</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">-XX</span><span class="hljs-selector-pseudo">:+PrintGC</span> 输出<span class="hljs-selector-tag">GC</span>日志<br><span class="hljs-selector-tag">-XX</span><span class="hljs-selector-pseudo">:+PrintGCDetails</span> 输出<span class="hljs-selector-tag">GC</span>的详细日志<br><span class="hljs-selector-tag">-XX</span><span class="hljs-selector-pseudo">:+PrintGCTimeStamps</span> 输出<span class="hljs-selector-tag">GC</span>的时间戳（以基准时间的形式） <br><span class="hljs-selector-tag">-XX</span><span class="hljs-selector-pseudo">:+PrintGCDateStamps</span> 输出<span class="hljs-selector-tag">GC</span>的时间戳（以日期的形式，如 2013<span class="hljs-selector-tag">-05-</span> 04<span class="hljs-selector-tag">T21</span><span class="hljs-selector-pseudo">:53</span><span class="hljs-selector-pseudo">:59.234+0800</span>） <br><span class="hljs-selector-tag">-XX</span><span class="hljs-selector-pseudo">:+PrintHeapAtGC</span> 在进行<span class="hljs-selector-tag">GC</span>的前后打印出堆的信息 <br><span class="hljs-selector-tag">-Xloggc</span><span class="hljs-selector-pseudo">:..</span>/<span class="hljs-selector-tag">logs</span>/<span class="hljs-selector-tag">gc</span><span class="hljs-selector-class">.log</span> 日志文件的输出路径<br></code></pre></td></tr></table></figure>

<p>GC Easy是一款在线的可视化工具，易用、功能强大，地址：<a target="_blank" rel="noopener" href="http://gceasy.io/">http://gceasy.io/</a></p>
<p><img src="/blog/2020/07/09/JVM/JVM%E8%B0%83%E4%BC%98/pic1.png" srcset="/blog/img/loading.gif" lazyload></p>
<p>上传后，点击Analyze按钮，即可查看报告。</p>
<h4 id="JVM内存统计"><a href="#JVM内存统计" class="headerlink" title="JVM内存统计"></a>JVM内存统计</h4><p><img src="/blog/2020/07/09/JVM/JVM%E8%B0%83%E4%BC%98/pic2.png" srcset="/blog/img/loading.gif" lazyload></p>
<p>上图中的年轻代与老年代在高峰时，可用空间基本都占满了，说明内存空间不足，需要调整内存大小。</p>
<p><img src="/blog/2020/07/09/JVM/JVM%E8%B0%83%E4%BC%98/pic5.png" srcset="/blog/img/loading.gif" lazyload></p>
<p>调整内存区域后，基本符合需求</p>
<h4 id="关键指标"><a href="#关键指标" class="headerlink" title="关键指标"></a>关键指标</h4><p><img src="/blog/2020/07/09/JVM/JVM%E8%B0%83%E4%BC%98/pic6.png" srcset="/blog/img/loading.gif" lazyload></p>
<p>关键指标中，吞吐量为98.694%，gc平均停顿时间为8.19ms，最大停顿时间为180ms。</p>
<p>可以看出，在初始状态时，吞吐量并不高，最大停顿时间较长，平均停顿时间表现不错。</p>
<h4 id="图表"><a href="#图表" class="headerlink" title="图表"></a>图表</h4><p><img src="/blog/2020/07/09/JVM/JVM%E8%B0%83%E4%BC%98/pic3.png" srcset="/blog/img/loading.gif" lazyload></p>
<p>在图表中可以看出，gc之后堆内存的使用基本是在60m ~ 80m之间。</p>
<p><img src="/blog/2020/07/09/JVM/JVM%E8%B0%83%E4%BC%98/pic7.png" srcset="/blog/img/loading.gif" lazyload></p>
<p>在图表中可以看出，gc之前的堆内存的使用在高峰时，将占用到80m ~ 120m之间。</p>
<p><img src="/blog/2020/07/09/JVM/JVM%E8%B0%83%E4%BC%98/pic8.png" srcset="/blog/img/loading.gif" lazyload></p>
<p>在gc持续时间统计中，可以看出full gc的时间要远高于young gc的时间，在调优时应当尽量的减少full gc。</p>
<p><img src="/blog/2020/07/09/JVM/JVM%E8%B0%83%E4%BC%98/pic9.png" srcset="/blog/img/loading.gif" lazyload></p>
<p>在清理垃圾的统计中，可以看出gc清理的垃圾基本维持在40m左右，最多的一次是发生在full gc，可以推断此次是内存即将耗尽，发生了full gc，释放了大量的内存空间，这可能是之前由于年轻代空间不足，年轻代对象有部分进入到老年代，在此次full gc时被清理了。</p>
<p><img src="/blog/2020/07/09/JVM/JVM%E8%B0%83%E4%BC%98/pic10.png" srcset="/blog/img/loading.gif" lazyload></p>
<p>从年轻代的gc情况来看，gc之前与gc之后差较大，说明垃圾对象在年轻代被清理的比较多，就是说临时性的对象居多。</p>
<p><img src="/blog/2020/07/09/JVM/JVM%E8%B0%83%E4%BC%98/pic11.png" srcset="/blog/img/loading.gif" lazyload></p>
<p>从老年代的gc情况来看，gc之前与之后的差并不大，说明老年代的垃圾对象并不是很多。</p>
<p><img src="/blog/2020/07/09/JVM/JVM%E8%B0%83%E4%BC%98/pic12.png" srcset="/blog/img/loading.gif" lazyload></p>
<p>Meta Space空间充足，基本没有变化，占用空间40m左右。</p>
<p><img src="/blog/2020/07/09/JVM/JVM%E8%B0%83%E4%BC%98/pic13.png" srcset="/blog/img/loading.gif" lazyload></p>
<p>从该图中看出，晋升到老年代的对象与可以分配对象相比，非常的少，也说明了上面我们看到的，对象主要集中在young区。</p>
<h4 id="GC统计"><a href="#GC统计" class="headerlink" title="GC统计"></a>GC统计</h4><p><img src="/blog/2020/07/09/JVM/JVM%E8%B0%83%E4%BC%98/pic4.png" srcset="/blog/img/loading.gif" lazyload></p>
<ul>
<li>Minor GC清理掉的垃圾对象合计24.13gb，说明产生的临时对象非常的多</li>
<li>Minor GC的执行间隔为636ms，说明发生gc的行为是比较频繁的</li>
<li>Full GC发生了10次，较为频繁</li>
<li>Full GC的平均持续时间为90ms，时间较长</li>
<li>GC的暂停次数为690次，暂停次数将影响到服务的响应时间</li>
</ul>
<h4 id="对象统计"><a href="#对象统计" class="headerlink" title="对象统计"></a>对象统计</h4><p><img src="/blog/2020/07/09/JVM/JVM%E8%B0%83%E4%BC%98/pic14.png" srcset="/blog/img/loading.gif" lazyload></p>
<p>在对象的统计中，可以看出对象的平均生成率：57.85m/s，平均的晋升率：610kb/s。</p>
<h4 id="调优建议"><a href="#调优建议" class="headerlink" title="调优建议"></a>调优建议</h4><ul>
<li><p>生产环境的JVM一定要进行参数设定，不能全部默认上生产。</p>
</li>
<li><p>对于参数的设定，不能拍脑袋，需要通过实际并发情况或压力测试得出结论。</p>
</li>
<li><p>对于内存中对象临时存在居多的情况，将年轻代调大一些。如果是G1或ZGC，不需要设定。</p>
</li>
<li><p>仔细分析gc easy给出的报告，从中分析原因，找出问题。</p>
</li>
<li><p>对于低延迟的应用建议使用G1或ZGC垃圾收集器。</p>
</li>
<li><p>不要将焦点全部聚焦jvm参数上，影响性能的因素有很多，比如：操作系统、tomcat本身的参数等。</p>
</li>
</ul>
<h3 id="PerfMa"><a href="#PerfMa" class="headerlink" title="PerfMa"></a>PerfMa</h3><p>PerfMa提供了JVM参数分析、线程分析、堆内存分析功能，界面美观，功能强大，我们在做jvm调优时，可以作为一个辅助工具。官网：<a target="_blank" rel="noopener" href="https://www.perfma.com/">https://www.perfma.com/</a></p>
<p><img src="/blog/2020/07/09/JVM/JVM%E8%B0%83%E4%BC%98/pic16.png" srcset="/blog/img/loading.gif" lazyload></p>
<h4 id="XXFox"><a href="#XXFox" class="headerlink" title="XXFox"></a>XXFox</h4><p>XXFox是Java虚拟机参数分析工具，可以对JVM参数进行查询、检查、优化等。</p>
<p>参数优化：</p>
<p><img src="/blog/2020/07/09/JVM/JVM%E8%B0%83%E4%BC%98/pic17.png" srcset="/blog/img/loading.gif" lazyload></p>
<p>参数生成：</p>
<p><img src="/blog/2020/07/09/JVM/JVM%E8%B0%83%E4%BC%98/pic18.png" srcset="/blog/img/loading.gif" lazyload></p>
<h4 id="XSheepdog"><a href="#XSheepdog" class="headerlink" title="XSheepdog"></a>XSheepdog</h4><p>XSheepdog是Java线程Dump分析工具，通过jstack生成线程的dump文件，进行分析。</p>
<p><img src="/blog/2020/07/09/JVM/JVM%E8%B0%83%E4%BC%98/pic19.png" srcset="/blog/img/loading.gif" lazyload></p>
<h4 id="XElephant"><a href="#XElephant" class="headerlink" title="XElephant"></a>XElephant</h4><p>XElephant是Java内存Dump分析工具。</p>
<p>获取内存 Dump 文件的命令：<code>jmap -dump:format=b,file=[生成的文件名] [进程号]</code></p>
<p>生成 Dump 文件后，就可以通过控制台 &gt; Java内存Dump分析 ，选择合适的途径上传到服务器进行分析。</p>
<p><img src="/blog/2020/07/09/JVM/JVM%E8%B0%83%E4%BC%98/pic20.png" srcset="/blog/img/loading.gif" lazyload></p>
<h3 id="高并发系统下的调优思路"><a href="#高并发系统下的调优思路" class="headerlink" title="高并发系统下的调优思路"></a>高并发系统下的调优思路</h3><p><img src="/blog/2020/07/09/JVM/JVM%E8%B0%83%E4%BC%98/pic21.png" srcset="/blog/img/loading.gif" lazyload></p>
<ul>
<li><p>百亿流量的电商网站，一般日活跃用户可能在1亿左右，大促期间的参与人较平常会增加很多，比如5亿左右。</p>
</li>
<li><p>电商系统的业务线非常多，大促期间压力最大的属订单、支付业务，我们聚焦到订单系统。</p>
</li>
<li><p>假设，部署了订单系统的微服务数量为100，每台机器4核8G内存。</p>
</li>
<li><p>一般情况下，电商网站的付费转化率为10%左右，所以，1亿的活跃用户会产生1000w订单。</p>
<ul>
<li>一天24小时，以12小时下单时间计算，每小时产生83w订单，每秒钟产生230左右个订单。</li>
<li>平均到100台机器，每台机器2~3个订单/秒，可以说毫无压力。</li>
</ul>
</li>
<li><p>大促期间，转化量会提升，假设提升到50%左右，所以，5亿活跃用户会产生2.5亿订单。</p>
<ul>
<li>大促期间的用户下单与平常的有所不同，这里我们假设，一天下单时间以20小时计算，前1小时，下单30%，其它时间段产生70%的订单。</li>
<li>前一小时产生30%订单，也就是7千500万订单，每秒钟将会产生20833个订单，分摊到100台服务器，每台服务器208个/秒订单的产生。</li>
<li>其它时间段产生70%的订单，也就是1亿7千5百万个订单，每小时产生920万订单，每秒产生2558个订单，分摊到100台机器，每天机器26个/秒订单的产生。</li>
</ul>
</li>
<li><p>通过上面的分析，一般情况和大促的非集中时间段，产生的订单量较少，每台机器的压力并不大，所以我们只需要关注大促开始的1小时的压力即可。</p>
</li>
<li><p>假设每个订单对象的大小为1KB，考虑到每个订单的产生会有复杂的业务流程，我们将订单对象大小扩大100倍，也就是，每产生一个订单对象，会占用100KB的内存空间。</p>
</li>
<li><p>也就是说，在大促期间，前一小时，每秒钟占用的内存空间为：100KB * 208 = 20800KB 也就是20M左右空间。</p>
</li>
<li><p>每台机器的内存是8G，除去操作系统、监控等内存开销，配置到jvm虚拟机的堆内存空间为6G。</p>
</li>
<li><p>考虑到订单对象在内存中创建后，会很快被持久化到数据库，随后就会GC回收，所以属于短暂性存活对象，尽可能的让其待在年轻代，避免过多的对象进入老年代，从而导致Full GC。 </p>
</li>
<li><p>在JDK8中，建议使用G1垃圾收集器，下面是给出的jvm主要参数建议：</p>
<ul>
<li><p><code>-XX:+UnlockExperimentalVMOptions -XX:+UseG1GC -Xmx6G - XX:MetaspaceSize=128m -XX:MaxGCPauseMillis=100 - XX:G1NewSizePercent=50 -XX:G1MaxNewSizePercent=80</code></p>
</li>
<li><p>-XX:G1NewSizePercent</p>
</li>
<li><p>设置要用作年轻代大小最小值的堆百分比。默认值是 Java 堆的 5%。（实验性质参数）</p>
</li>
<li><p>-XX:G1MaxNewSizePercent</p>
<ul>
<li>设置要用作年轻代大小最大值的堆大小百分比。默认值是 Java 堆的 60%。（实验性质参数）</li>
</ul>
</li>
<li><p>该参数仅供参考，需根据实际环境配置</p>
</li>
</ul>
</li>
</ul>
<h3 id="MAT工具"><a href="#MAT工具" class="headerlink" title="MAT工具"></a>MAT工具</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>MAT(Memory Analyzer Tool)，是基于Eclipse的内存分析工具，是一个快速、功能丰富的JAVA heap<br>分析工具，它可以帮助我们查找内存泄漏和减少内存消耗。使用内存分析工具从众多的对象中进行分<br>析，快速的计算出在内存中对象的占用大小，看看是谁阻止了垃圾收集器的回收工作，并可以通过报表<br>直观的查看到可能造成这种结果的对象。官网地址：<a target="_blank" rel="noopener" href="https://www.eclipse.org/mat/%E3%80%82">https://www.eclipse.org/mat/。</a></p>
<h4 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h4><p>下载地址：<a target="_blank" rel="noopener" href="https://www.eclipse.org/mat/downloads.php">https://www.eclipse.org/mat/downloads.php</a></p>
<p>将下载得到的MemoryAnalyzer-1.8.0.20180604-win32.win32.x86_64.zip进行解压后即可</p>
<p>增加JVM运行参数<code>-XX:+HeapDumpOnOutOfMemoryError</code>，当发生内存溢出时，会dump内存到后缀为.hprof的文件中，该文件在项目的根目录下。</p>
<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p><img src="/blog/2020/07/09/JVM/JVM%E8%B0%83%E4%BC%98/pic1.png" srcset="/blog/img/loading.gif" lazyload></p>
<p><img src="/blog/2020/07/09/JVM/JVM%E8%B0%83%E4%BC%98/pic2.png" srcset="/blog/img/loading.gif" lazyload></p>
<p><img src="/blog/2020/07/09/JVM/JVM%E8%B0%83%E4%BC%98/pic3.png" srcset="/blog/img/loading.gif" lazyload></p>
<p><img src="/blog/2020/07/09/JVM/JVM%E8%B0%83%E4%BC%98/pic4.png" srcset="/blog/img/loading.gif" lazyload></p>
<p>查看对象及其依赖：</p>
<p><img src="/blog/2020/07/09/JVM/JVM%E8%B0%83%E4%BC%98/pic5.png" srcset="/blog/img/loading.gif" lazyload></p>
<p>查看可能存在内存泄漏的分析</p>
<p><img src="/blog/2020/07/09/JVM/JVM%E8%B0%83%E4%BC%98/pic6.png" srcset="/blog/img/loading.gif" lazyload></p>
<h3 id="查看线程状态"><a href="#查看线程状态" class="headerlink" title="查看线程状态"></a>查看线程状态</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">jstack [pid]<br></code></pre></td></tr></table></figure>

<p>如果有死锁会显示</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">Found one <span class="hljs-keyword">Java-level </span>deadlock: <br>============================= <br><span class="hljs-string">&quot;Thread-1&quot;</span>:<br>  <span class="hljs-keyword">waiting </span>to lock monitor <span class="hljs-number">0x00000000026c3ee8</span> (object <span class="hljs-number">0x0000000780198bb0</span>, a <span class="hljs-keyword">java.lang.Object),</span><br><span class="hljs-keyword"> </span> which is held <span class="hljs-keyword">by </span><span class="hljs-string">&quot;Thread-0&quot;</span><br><span class="hljs-string">&quot;Thread-0&quot;</span>:<br>  <span class="hljs-keyword">waiting </span>to lock monitor <span class="hljs-number">0x00000000026c40f8</span> (object <span class="hljs-number">0x0000000780198bc0</span>, a <span class="hljs-keyword">java.lang.Object),</span><br><span class="hljs-keyword"> </span> which is held <span class="hljs-keyword">by </span><span class="hljs-string">&quot;Thread-1&quot;</span><br><br><span class="hljs-keyword">Java </span>stack information for the threads listed above: <br>=================================================== <br><span class="hljs-string">&quot;Thread-1&quot;</span>:<br>    <span class="hljs-built_in">at</span> cn.itcast.<span class="hljs-keyword">jvm.TestDeadLock$Thread2.run(TestDeadLock.java:49)</span><br><span class="hljs-keyword"> </span>   - <span class="hljs-keyword">waiting </span>to lock &lt;<span class="hljs-number">0x0000000780198bb0</span>&gt; (a <span class="hljs-keyword">java.lang.Object)</span><br><span class="hljs-keyword"> </span>   - locked &lt;<span class="hljs-number">0x0000000780198bc0</span>&gt; (a <span class="hljs-keyword">java.lang.Object) </span><br>    <span class="hljs-built_in">at</span> <span class="hljs-keyword">java.lang.Thread.run(Thread.java:748) </span><br><span class="hljs-string">&quot;Thread-0&quot;</span>: <br>    <span class="hljs-built_in">at</span> cn.itcast.<span class="hljs-keyword">jvm.TestDeadLock$Thread1.run(TestDeadLock.java:29)</span><br><span class="hljs-keyword"> </span>   - <span class="hljs-keyword">waiting </span>to lock &lt;<span class="hljs-number">0x0000000780198bc0</span>&gt; (a <span class="hljs-keyword">java.lang.Object) </span><br>    - locked &lt;<span class="hljs-number">0x0000000780198bb0</span>&gt; (a <span class="hljs-keyword">java.lang.Object) </span><br>    <span class="hljs-built_in">at</span> <span class="hljs-keyword">java.lang.Thread.run(Thread.java:748) </span><br>Found <span class="hljs-number">1</span> deadlock.<br></code></pre></td></tr></table></figure>

<p>可以清晰的看到：</p>
<ul>
<li><p>Thread2获取了 &lt;0x0000000780198bc0&gt; 的锁，等待获取 &lt;0x0000000780198bb0&gt; 这个锁</p>
</li>
<li><p>Thread1获取了 &lt;0x0000000780198bb0&gt; 的锁，等待获取 &lt;0x0000000780198bc0&gt; 这个锁</p>
</li>
</ul>
<p>由此可见，发生了死锁。</p>
<h3 id="VisualVM"><a href="#VisualVM" class="headerlink" title="VisualVM"></a>VisualVM</h3><p>VisualVM，能够监控线程，内存情况，查看方法的CPU时间和内存中的对 象，已被GC的对象，反向查</p>
<p>看分配的堆栈(如100个String对象分别由哪几个对象分配出来的)。</p>
<p>VisualVM使用简单，几乎0配置，功能还是比较丰富的，几乎囊括了其它JDK自带命令的所有功能。</p>
<ul>
<li><p>内存信息</p>
</li>
<li><p>线程信息</p>
</li>
<li><p>Dump堆（本地进程）</p>
</li>
<li><p>Dump线程（本地进程）</p>
</li>
<li><p>打开堆Dump。堆Dump可以用jmap来生成。</p>
</li>
<li><p>打开线程Dump</p>
</li>
<li><p>生成应用快照（包含内存信息、线程信息等等）</p>
</li>
<li><p>性能分析。CPU分析（各个方法调用时间，检查哪些方法耗时多），内存分析（各类对象占用的内</p>
</li>
</ul>
<p>存，检查哪些类占用内存多）</p>
<p>VisualVM在jdk的bin目录下，找到jvisualvm打开即可。</p>
<h4 id="jvm基本信息"><a href="#jvm基本信息" class="headerlink" title="jvm基本信息"></a>jvm基本信息</h4><p><img src="/blog/2020/07/09/JVM/JVM%E8%B0%83%E4%BC%98/pic7.png" srcset="/blog/img/loading.gif" lazyload></p>
<h4 id="CPU、内存、类线程运行信息"><a href="#CPU、内存、类线程运行信息" class="headerlink" title="CPU、内存、类线程运行信息"></a>CPU、内存、类线程运行信息</h4><p><img src="/blog/2020/07/09/JVM/JVM%E8%B0%83%E4%BC%98/pic8.png" srcset="/blog/img/loading.gif" lazyload></p>
<h4 id="线程详情"><a href="#线程详情" class="headerlink" title="线程详情"></a>线程详情</h4><p><img src="/blog/2020/07/09/JVM/JVM%E8%B0%83%E4%BC%98/pic9.png" srcset="/blog/img/loading.gif" lazyload></p>
<p>右上角的Dump按钮可以到处线程信息，与jstack相同</p>
<p><img src="/blog/2020/07/09/JVM/JVM%E8%B0%83%E4%BC%98/pic10.png" srcset="/blog/img/loading.gif" lazyload></p>
<h4 id="抽样器"><a href="#抽样器" class="headerlink" title="抽样器"></a>抽样器</h4><p>抽样器可以对CPU、内存在一段时间内进行抽样，以供分析。</p>
<p><img src="/blog/2020/07/09/JVM/JVM%E8%B0%83%E4%BC%98/pic11.png" srcset="/blog/img/loading.gif" lazyload></p>
<h4 id="监控远程jvm"><a href="#监控远程jvm" class="headerlink" title="监控远程jvm"></a>监控远程jvm</h4><p>VisualJVM可以借助于JMX技术监控远程的jvm进程。</p>
<p>JMX（Java Management Extensions，即Java管理扩展）是一个为应用程序、设备、系统等植入管理功能的框架。JMX可以跨越一系列异构操作系统平台、系统体系结构和网络传输协议，灵活的开发无缝集成的系统、网络和服务管理应用。</p>
<h5 id="监控远程tomcat"><a href="#监控远程tomcat" class="headerlink" title="监控远程tomcat"></a>监控远程tomcat</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">在tomcat的bin目录下，修改catalina.sh，添加如下的参数</span> <br>JAVA_OPTS=&quot;-Dcom.sun.management.jmxremote - <br>Dcom.sun.management.jmxremote.port=9999 - <br>Dcom.sun.management.jmxremote.authenticate=false - <br>Dcom.sun.management.jmxremote.ssl=false&quot; <br><span class="hljs-meta">#</span><span class="bash">这几个参数的意思是：</span> <br><span class="hljs-meta">#</span><span class="bash">-Dcom.sun.management.jmxremote ：允许使用JMX远程管理</span> <br><span class="hljs-meta">#</span><span class="bash">-Dcom.sun.management.jmxremote.port=9999 ：JMX远程连接端口</span> <br><span class="hljs-meta">#</span><span class="bash">-Dcom.sun.management.jmxremote.authenticate=<span class="hljs-literal">false</span> ：不进行身份认证，任何用户都可 以连接</span> <br><span class="hljs-meta">#</span><span class="bash">-Dcom.sun.management.jmxremote.ssl=<span class="hljs-literal">false</span> ：不使用ssl</span><br></code></pre></td></tr></table></figure>

<h5 id="连接远程tomcat"><a href="#连接远程tomcat" class="headerlink" title="连接远程tomcat"></a>连接远程tomcat</h5><p>添加远程主机：</p>
<p><img src="/blog/2020/07/09/JVM/JVM%E8%B0%83%E4%BC%98/pic12.png" srcset="/blog/img/loading.gif" lazyload></p>
<p>在一个主机下可能会有很多的jvm需要监控，所以接下来要在该主机上添加需要监控的jvm：</p>
<p><img src="/blog/2020/07/09/JVM/JVM%E8%B0%83%E4%BC%98/pic13.png" srcset="/blog/img/loading.gif" lazyload></p>
<p><img src="/blog/2020/07/09/JVM/JVM%E8%B0%83%E4%BC%98/pic14.png" srcset="/blog/img/loading.gif" lazyload></p>
<h4 id="检查死锁"><a href="#检查死锁" class="headerlink" title="检查死锁"></a>检查死锁</h4><p><img src="/blog/2020/07/09/JVM/JVM%E8%B0%83%E4%BC%98/pic15.png" srcset="/blog/img/loading.gif" lazyload></p>
<h4 id="检测堆内存"><a href="#检测堆内存" class="headerlink" title="检测堆内存"></a>检测堆内存</h4><p>检测堆内存的具体使用情况，需要安装插件Visual GC进行检测：</p>
<p><img src="/blog/2020/07/09/JVM/JVM%E8%B0%83%E4%BC%98/pic16.png" srcset="/blog/img/loading.gif" lazyload></p>
<p>可以看到，年轻代、老年代中的内存使用情况</p>
<p><img src="/blog/2020/07/09/JVM/JVM%E8%B0%83%E4%BC%98/pic17.png" srcset="/blog/img/loading.gif" lazyload></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/blog/categories/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/">JVM虚拟机</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/blog/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">性能优化</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/blog/2020/07/13/JVM/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">JVM的垃圾收集</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/blog/2020/07/09/JVM/JVM%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">
                        <span class="hidden-mobile">JVM内存管理</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":200})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.staticfile.org/jquery/3.5.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/js/bootstrap.min.js" ></script>
<script  src="/blog/js/events.js" ></script>
<script  src="/blog/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/blog/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.staticfile.org/tocbot/4.12.0/tocbot.min.js" ></script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>






  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/blog/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/blog/local-search.xml";
      jQuery('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      jQuery('#modalSearch').on('shown.bs.modal', function() {
        jQuery('#local-search-input').focus();
      });
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/blog/js/boot.js" ></script>


</body>
</html>
