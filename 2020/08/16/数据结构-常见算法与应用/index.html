

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/blog/img/favicon.png">
  <link rel="icon" type="image/png" href="/blog/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="">
  <meta name="keywords" content="">
  <title>常见算法与应用 - 🍎🍊&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/blog/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.1.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/blog/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"zhaoguocheng.gitee.io","root":"/blog/","version":"1.8.5","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"copy_btn":true,"image_zoom":{"enable":true},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/blog/js/utils.js" ></script>
  <script  src="/blog/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/blog/">&nbsp;<strong>Fluid</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/">
                <i class="iconfont icon-home-fill"></i>
                主页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/blog/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="常见算法与应用">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-08-16 18:10" pubdate>
        2020年8月16日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      20.2k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      283
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">常见算法与应用</h1>
            
            <div class="markdown-body">
              <h3 id="失效算法与应用"><a href="#失效算法与应用" class="headerlink" title="失效算法与应用"></a>失效算法与应用</h3><p>失效算法常见于缓存系统中。因为缓存往往占据大量内存，而内存空间是相对昂贵，且空间有限的，那么针对一部分值，就要依据相应的算法进行失效或移除操作。 </p>
<h4 id="先来先淘汰（FIFO）"><a href="#先来先淘汰（FIFO）" class="headerlink" title="先来先淘汰（FIFO）"></a>先来先淘汰（FIFO）</h4><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p>First In First Out，先来先淘汰。这种算法在每一次新数据插入时，如果队列已满，则将最早插入的数据移除。 </p>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p>可以方便的借助LinkedList来实现</p>
<pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test;

<span class="hljs-keyword">import</span> java.util.Iterator;
<span class="hljs-keyword">import</span> java.util.LinkedList;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FIFO</span> </span>&#123;
    LinkedList&lt;Integer&gt; fifo = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();
    <span class="hljs-keyword">int</span> size = <span class="hljs-number">3</span>;

    <span class="hljs-comment">//添加元素</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;
        fifo.addFirst(i);
        <span class="hljs-keyword">if</span> (fifo.size() &gt; size) &#123;
            fifo.removeLast();
        &#125;
        print();
    &#125;

    <span class="hljs-comment">//缓存命中</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;
        Iterator&lt;Integer&gt; iterator = fifo.iterator();
        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;
            <span class="hljs-keyword">int</span> j = iterator.next();
            <span class="hljs-keyword">if</span> (i == j) &#123;
                System.out.println(<span class="hljs-string">&quot;find it!&quot;</span>);
                print();
                <span class="hljs-keyword">return</span>;
            &#125;
        &#125;
        System.out.println(<span class="hljs-string">&quot;not found!&quot;</span>);
        print();
    &#125;

    <span class="hljs-comment">//打印缓存</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-keyword">this</span>.fifo);
    &#125;

    <span class="hljs-comment">//测试</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        FIFO fifo = <span class="hljs-keyword">new</span> FIFO();
        System.out.println(<span class="hljs-string">&quot;add 1‐3:&quot;</span>);
        fifo.add(<span class="hljs-number">1</span>);
        fifo.add(<span class="hljs-number">2</span>);
        fifo.add(<span class="hljs-number">3</span>);
        System.out.println(<span class="hljs-string">&quot;add 4:&quot;</span>);
        fifo.add(<span class="hljs-number">4</span>);
        System.out.println(<span class="hljs-string">&quot;read 2:&quot;</span>);
        fifo.read(<span class="hljs-number">2</span>);
        System.out.println(<span class="hljs-string">&quot;read 100:&quot;</span>);
        fifo.read(<span class="hljs-number">100</span>);
        System.out.println(<span class="hljs-string">&quot;add 5:&quot;</span>);
        fifo.add(<span class="hljs-number">5</span>);
    &#125;
&#125;</code></pre>

<h5 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h5><pre><code class="hljs"><span class="hljs-attribute">add</span> <span class="hljs-number">1</span>‐<span class="hljs-number">3</span>:
[1]
[2, 1]
[3, 2, 1]
<span class="hljs-attribute">add</span> <span class="hljs-number">4</span>:
[4, 3, 2]
<span class="hljs-attribute">read</span> <span class="hljs-number">2</span>:
<span class="hljs-attribute">find</span> it!
[4, 3, 2]
<span class="hljs-attribute">read</span> <span class="hljs-number">100</span>:
<span class="hljs-attribute">not</span> found!
[4, 3, 2]
<span class="hljs-attribute">add</span> <span class="hljs-number">5</span>:
[5, 4, 3]</code></pre>

<ul>
<li><p>1-3按顺序放入，没有问题 </p>
</li>
<li><p>4放入，那么1最早放入，被挤掉 </p>
</li>
<li><p>读取2，读到，但是不会影响队列顺序（2依然是时间最老的） </p>
</li>
<li><p>读取100，读不到，也不会产生任何影响 </p>
</li>
<li><p>5加入，踢掉了2，而不管2之前有没有被使用（不够理性） </p>
</li>
</ul>
<h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><ul>
<li>实现非常简单</li>
<li>不管元素的使用情况，哪怕有些数据会被频繁用到，时间最久也会被踢掉</li>
</ul>
<h4 id="最久未用淘汰（LRU）"><a href="#最久未用淘汰（LRU）" class="headerlink" title="最久未用淘汰（LRU）"></a>最久未用淘汰（<strong>LRU</strong>）</h4><h5 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h5><p>LRU全称是Least Recently Used，即淘汰最后一次使用时间最久远的数值。FIFO非常的粗暴，不管有没有用到，直接踢掉时间久的元素。而LRU认为，最近频繁使用过的数据，将来也很大程度上会被频繁用到，故而淘汰那些懒惰的数据。LinkedHashMap，数组，链表均可实现LRU，下面仍然以链表为例：新加入的数据放在头部，最近访问的，也移到头部，空间满时，将尾部元素删除。 </p>
<h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.release;

<span class="hljs-keyword">import</span> java.util.Iterator;
<span class="hljs-keyword">import</span> java.util.LinkedList;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRU</span> </span>&#123;
    LinkedList&lt;Integer&gt; lru = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();
    <span class="hljs-keyword">int</span> size = <span class="hljs-number">3</span>;

    <span class="hljs-comment">//添加元素 </span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;
        lru.addFirst(i);
        <span class="hljs-keyword">if</span> (lru.size() &gt; size) &#123;
            lru.removeLast();
        &#125;
        print();
    &#125;

    <span class="hljs-comment">//缓存命中 </span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;
        Iterator&lt;Integer&gt; iterator = lru.iterator();
        <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;
            <span class="hljs-keyword">int</span> j = iterator.next();
            <span class="hljs-keyword">if</span> (i == j) &#123;
                System.out.println(<span class="hljs-string">&quot;find it!&quot;</span>);
                lru.remove(index);
                lru.addFirst(j);
                print();
                <span class="hljs-keyword">return</span>;
            &#125;
            index++;
        &#125;
        System.out.println(<span class="hljs-string">&quot;not found!&quot;</span>);
        print();
    &#125;

    <span class="hljs-comment">//打印缓存 </span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-keyword">this</span>.lru);
    &#125;

    <span class="hljs-comment">//测试 </span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        LRU lru = <span class="hljs-keyword">new</span> LRU();
        System.out.println(<span class="hljs-string">&quot;add 1‐3:&quot;</span>);
        lru.add(<span class="hljs-number">1</span>);
        lru.add(<span class="hljs-number">2</span>);
        lru.add(<span class="hljs-number">3</span>);
        System.out.println(<span class="hljs-string">&quot;add 4:&quot;</span>);
        lru.add(<span class="hljs-number">4</span>);
        System.out.println(<span class="hljs-string">&quot;read 2:&quot;</span>);
        lru.read(<span class="hljs-number">2</span>);
        System.out.println(<span class="hljs-string">&quot;read 100:&quot;</span>);
        lru.read(<span class="hljs-number">100</span>);
        System.out.println(<span class="hljs-string">&quot;add 5:&quot;</span>);
        lru.add(<span class="hljs-number">5</span>);
    &#125;
&#125;</code></pre>

<h5 id="结果分析-1"><a href="#结果分析-1" class="headerlink" title="结果分析"></a>结果分析</h5><pre><code class="hljs"><span class="hljs-attribute">add</span> <span class="hljs-number">1</span>‐<span class="hljs-number">3</span>:
[1]
[2, 1]
[3, 2, 1]
<span class="hljs-attribute">add</span> <span class="hljs-number">4</span>:
[4, 3, 2]
<span class="hljs-attribute">read</span> <span class="hljs-number">2</span>:
<span class="hljs-attribute">find</span> it!
[2, 4, 3]
<span class="hljs-attribute">read</span> <span class="hljs-number">100</span>:
<span class="hljs-attribute">not</span> found!
[2, 4, 3]
<span class="hljs-attribute">add</span> <span class="hljs-number">5</span>:
[5, 2, 4]</code></pre>

<ul>
<li><p>1-3加入，没有问题 </p>
</li>
<li><p>4加入，踢掉1，没问题 </p>
</li>
<li><p>读取2，读到，注意，2被移到了队首！ </p>
</li>
<li><p>读取100，读不到，没影响 </p>
</li>
<li><p>5加入，因为2之前被用到，不会被剔除，3和4都没人用，但是3更久，被剔除</p>
</li>
</ul>
<h4 id="最近最少使用（LFU）"><a href="#最近最少使用（LFU）" class="headerlink" title="最近最少使用（LFU）"></a>最近最少使用（<strong>LFU</strong>）</h4><h5 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h5><p>Least Frequently Used，即最近最少使用。它要淘汰的是最近一段时间内，使用次数最少的值。可以认为比LRU多了一重判断。LFU需要时间和次数两个维度的参考指标。需要注意的是，两个维度就可能涉及到同一时间段内，访问次数相同的情况，就必须内置一个计数器和一个队列，计数器算数，队列放置相同计数时的访问时间。 </p>
<h5 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h5><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.release;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dto</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Dto</span>&gt; </span>&#123;
    <span class="hljs-keyword">private</span> Integer key;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> lastTime;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Dto</span><span class="hljs-params">(Integer key, <span class="hljs-keyword">int</span> count, <span class="hljs-keyword">long</span> lastTime)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.key = key;
        <span class="hljs-keyword">this</span>.count = count;
        <span class="hljs-keyword">this</span>.lastTime = lastTime;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Dto o)</span> </span>&#123;
        <span class="hljs-keyword">int</span> compare = Integer.compare(<span class="hljs-keyword">this</span>.count, o.count);
        <span class="hljs-keyword">return</span> compare == <span class="hljs-number">0</span> ? Long.compare(<span class="hljs-keyword">this</span>.lastTime, o.lastTime) : compare;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">&quot;[key=%s,count=%s,lastTime=%s]&quot;</span>, key, count, lastTime);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getKey</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> key;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setKey</span><span class="hljs-params">(Integer key)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.key = key;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> count;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> count)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.count = count;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getLastTime</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> lastTime;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLastTime</span><span class="hljs-params">(<span class="hljs-keyword">long</span> lastTime)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.lastTime = lastTime;
    &#125;
&#125;</code></pre>

<pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.release;

<span class="hljs-keyword">import</span> java.util.Collections;
<span class="hljs-keyword">import</span> java.util.HashMap;
<span class="hljs-keyword">import</span> java.util.Map;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LFU</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> size = <span class="hljs-number">3</span>;
    <span class="hljs-keyword">private</span> Map&lt;Integer, Integer&gt; cache = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
    <span class="hljs-keyword">private</span> Map&lt;Integer, Dto&gt; count = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();

    <span class="hljs-comment">//投放</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(Integer key, Integer value)</span> </span>&#123;
        Integer v = cache.get(key);
        <span class="hljs-keyword">if</span> (v == <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">if</span> (cache.size() == size) &#123;
                removeElement();
            &#125;
            count.put(key, <span class="hljs-keyword">new</span> Dto(key, <span class="hljs-number">1</span>, System.currentTimeMillis()));
        &#125; <span class="hljs-keyword">else</span> &#123;
            addCount(key);
        &#125;
        cache.put(key, value);
    &#125;

    <span class="hljs-comment">//读取</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">get</span><span class="hljs-params">(Integer key)</span> </span>&#123;
        Integer value = cache.get(key);
        <span class="hljs-keyword">if</span> (value != <span class="hljs-keyword">null</span>) &#123;
            addCount(key);
            <span class="hljs-keyword">return</span> value;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    &#125;

    <span class="hljs-comment">//淘汰元素</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeElement</span><span class="hljs-params">()</span> </span>&#123;
        Dto dto = Collections.min(count.values());
        cache.remove(dto.getKey());
        count.remove(dto.getKey());
    &#125;

    <span class="hljs-comment">//更新计数器</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addCount</span><span class="hljs-params">(Integer key)</span> </span>&#123;
        Dto Dto = count.get(key);
        Dto.setCount(Dto.getCount() + <span class="hljs-number">1</span>);
        Dto.setLastTime(System.currentTimeMillis());
    &#125;

    <span class="hljs-comment">//打印缓存结构和计数器结构</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;cache=&quot;</span> + cache);
        System.out.println(<span class="hljs-string">&quot;count=&quot;</span> + count);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        LFU lfu = <span class="hljs-keyword">new</span> LFU();
        <span class="hljs-comment">//前3个容量没满，1,2,3均加入 </span>
        System.out.println(<span class="hljs-string">&quot;add 1‐3:&quot;</span>);
        lfu.put(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
        lfu.put(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);
        lfu.put(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>);
        lfu.print();
        <span class="hljs-comment">//1,2有访问，3没有，加入4，淘汰3 </span>
        System.out.println(<span class="hljs-string">&quot;read 1,2&quot;</span>);
        lfu.get(<span class="hljs-number">1</span>);
        lfu.get(<span class="hljs-number">2</span>);
        lfu.print();
        System.out.println(<span class="hljs-string">&quot;add 4:&quot;</span>);
        lfu.put(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>);
        lfu.print();
        <span class="hljs-comment">//2=3次，1,4=2次，但是4加入较晚，再加入5时淘汰1 </span>
        System.out.println(<span class="hljs-string">&quot;read 2,4&quot;</span>);
        lfu.get(<span class="hljs-number">2</span>);
        lfu.get(<span class="hljs-number">4</span>);
        lfu.print();
        System.out.println(<span class="hljs-string">&quot;add 5:&quot;</span>);
        lfu.put(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>);
        lfu.print();
    &#125;
&#125;</code></pre>

<h5 id="结果分析-2"><a href="#结果分析-2" class="headerlink" title="结果分析"></a>结果分析</h5><pre><code class="hljs apache"><span class="hljs-attribute">add</span> <span class="hljs-number">1</span>‐<span class="hljs-number">3</span>:
<span class="hljs-attribute">cache</span>=&#123;<span class="hljs-number">1</span>=<span class="hljs-number">1</span>, <span class="hljs-number">2</span>=<span class="hljs-number">2</span>, <span class="hljs-number">3</span>=<span class="hljs-number">3</span>&#125;
<span class="hljs-attribute">count</span>=&#123;<span class="hljs-number">1</span>=[key=<span class="hljs-number">1</span>,count=<span class="hljs-number">1</span>,lastTime=<span class="hljs-number">1598000803514</span>], <span class="hljs-number">2</span>=[key=<span class="hljs-number">2</span>,count=<span class="hljs-number">1</span>,lastTime=<span class="hljs-number">1598000803514</span>], <span class="hljs-number">3</span>=[key=<span class="hljs-number">3</span>,count=<span class="hljs-number">1</span>,lastTime=<span class="hljs-number">1598000803514</span>]&#125;
<span class="hljs-attribute">read</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>
<span class="hljs-attribute">cache</span>=&#123;<span class="hljs-number">1</span>=<span class="hljs-number">1</span>, <span class="hljs-number">2</span>=<span class="hljs-number">2</span>, <span class="hljs-number">3</span>=<span class="hljs-number">3</span>&#125;
<span class="hljs-attribute">count</span>=&#123;<span class="hljs-number">1</span>=[key=<span class="hljs-number">1</span>,count=<span class="hljs-number">2</span>,lastTime=<span class="hljs-number">1598000803535</span>], <span class="hljs-number">2</span>=[key=<span class="hljs-number">2</span>,count=<span class="hljs-number">2</span>,lastTime=<span class="hljs-number">1598000803535</span>], <span class="hljs-number">3</span>=[key=<span class="hljs-number">3</span>,count=<span class="hljs-number">1</span>,lastTime=<span class="hljs-number">1598000803514</span>]&#125;
<span class="hljs-attribute">add</span> <span class="hljs-number">4</span>:
<span class="hljs-attribute">cache</span>=&#123;<span class="hljs-number">1</span>=<span class="hljs-number">1</span>, <span class="hljs-number">2</span>=<span class="hljs-number">2</span>, <span class="hljs-number">4</span>=<span class="hljs-number">4</span>&#125;
<span class="hljs-attribute">count</span>=&#123;<span class="hljs-number">1</span>=[key=<span class="hljs-number">1</span>,count=<span class="hljs-number">2</span>,lastTime=<span class="hljs-number">1598000803535</span>], <span class="hljs-number">2</span>=[key=<span class="hljs-number">2</span>,count=<span class="hljs-number">2</span>,lastTime=<span class="hljs-number">1598000803535</span>], <span class="hljs-number">4</span>=[key=<span class="hljs-number">4</span>,count=<span class="hljs-number">1</span>,lastTime=<span class="hljs-number">1598000803535</span>]&#125;
<span class="hljs-attribute">read</span> <span class="hljs-number">2</span>,<span class="hljs-number">4</span>
<span class="hljs-attribute">cache</span>=&#123;<span class="hljs-number">1</span>=<span class="hljs-number">1</span>, <span class="hljs-number">2</span>=<span class="hljs-number">2</span>, <span class="hljs-number">4</span>=<span class="hljs-number">4</span>&#125;
<span class="hljs-attribute">count</span>=&#123;<span class="hljs-number">1</span>=[key=<span class="hljs-number">1</span>,count=<span class="hljs-number">2</span>,lastTime=<span class="hljs-number">1598000803535</span>], <span class="hljs-number">2</span>=[key=<span class="hljs-number">2</span>,count=<span class="hljs-number">3</span>,lastTime=<span class="hljs-number">1598000803536</span>], <span class="hljs-number">4</span>=[key=<span class="hljs-number">4</span>,count=<span class="hljs-number">2</span>,lastTime=<span class="hljs-number">1598000803536</span>]&#125;
<span class="hljs-attribute">add</span> <span class="hljs-number">5</span>:
<span class="hljs-attribute">cache</span>=&#123;<span class="hljs-number">2</span>=<span class="hljs-number">2</span>, <span class="hljs-number">4</span>=<span class="hljs-number">4</span>, <span class="hljs-number">5</span>=<span class="hljs-number">5</span>&#125;
<span class="hljs-attribute">count</span>=&#123;<span class="hljs-number">2</span>=[key=<span class="hljs-number">2</span>,count=<span class="hljs-number">3</span>,lastTime=<span class="hljs-number">1598000803536</span>], <span class="hljs-number">4</span>=[key=<span class="hljs-number">4</span>,count=<span class="hljs-number">2</span>,lastTime=<span class="hljs-number">1598000803536</span>], <span class="hljs-number">5</span>=[key=<span class="hljs-number">5</span>,count=<span class="hljs-number">1</span>,lastTime=<span class="hljs-number">1598000803536</span>]&#125;</code></pre>

<ul>
<li><p>1-3加入，没问题，计数器为1次 </p>
</li>
<li><p>访问1，2，使用次数计数器上升为2次，3没有访问，仍然为1 </p>
</li>
<li><p>4加入，3的访问次数最少（1次），所以踢掉3，剩下124</p>
</li>
<li><p>访问2，4，计数器上升，2=3次，1，4=2次，但是1时间久 </p>
</li>
<li><p>5加入，踢掉1，最后剩下2，4，5 </p>
</li>
</ul>
<h5 id="应用案例"><a href="#应用案例" class="headerlink" title="应用案例"></a>应用案例</h5><p>redis属于缓存失效的典型应用场景，常见策略如下： </p>
<ul>
<li><p>noeviction: 不删除策略, 达到最大内存限制时, 如果需要更多内存, 直接返回错误信息（ 比较危险）。 </p>
</li>
<li><p>allkeys-lru：对所有key，优先删除最近最少使用的 key (LRU)。 </p>
</li>
<li><p>allkeys-random： 对所有key， 随机删除一部分（听起来毫无道理）。 </p>
</li>
<li><p>volatile-lru：只限于设置了 expire 的key，优先删除最近最少使用的key (LRU)。 </p>
</li>
<li><p>volatile-random：只限于设置了 expire 的key，随机删除一部分。 </p>
</li>
<li><p>volatile-ttl：只限于设置了 expire 的key，优先删除剩余时间(TTL) 短的key。</p>
</li>
</ul>
<h3 id="限流算法与应用"><a href="#限流算法与应用" class="headerlink" title="限流算法与应用"></a>限流算法与应用</h3><p>限流是对系统的一种保护措施。即限制流量请求的频率（每秒处理多少个请求）。一般来说，当请求流量超过系统的瓶颈，则丢弃掉多余的请求流量，保证系统的可用性。即要么不放进来，放进来的就保证提供服务。</p>
<h4 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h4><h5 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h5><p>计数器采用简单的计数操作，到一段时间节点后自动清零 </p>
<h5 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h5><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.release;

<span class="hljs-keyword">import</span> java.util.concurrent.*;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-comment">//计数器，这里用信号量实现 </span>
        <span class="hljs-keyword">final</span> Semaphore semaphore = <span class="hljs-keyword">new</span> Semaphore(<span class="hljs-number">3</span>);
        <span class="hljs-comment">//定时器，到点清零 </span>
        ScheduledExecutorService service = Executors.newScheduledThreadPool(<span class="hljs-number">1</span>);
        service.scheduleAtFixedRate(<span class="hljs-keyword">new</span> Runnable() &#123;
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
                semaphore.release(<span class="hljs-number">3</span>);
            &#125;
        &#125;, <span class="hljs-number">3000</span>, <span class="hljs-number">3000</span>, TimeUnit.MILLISECONDS);
        <span class="hljs-comment">//模拟无数个请求从天而降 </span>
        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;
            <span class="hljs-keyword">try</span> &#123;
                <span class="hljs-comment">//判断计数器</span>
                semaphore.acquire();
            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            <span class="hljs-comment">//如果准许响应，打印一个ok </span>
            System.out.println(<span class="hljs-string">&quot;ok&quot;</span>);
        &#125;
    &#125;
&#125;</code></pre>

<h5 id="结果分析-3"><a href="#结果分析-3" class="headerlink" title="结果分析"></a>结果分析</h5><p>3个ok一组呈现，到下一个计数周期之前被阻断 </p>
<h5 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h5><p>实现起来非常简单。 </p>
<p>控制力度太过于简略，假如1s内限制3次，那么如果3次在前100ms内已经用完，后面的900ms将只能处于阻塞状态，白白浪费掉。 </p>
<h5 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h5><p>使用计数器限流的场景较少，因为它的处理逻辑不够灵活。最常见的可能在web的登录密码验证，输入错误次数冻结一段时间的场景。如果网站请求使用计数器，那么恶意攻击者前100ms吃掉流量计数，使得后续正常的请求被全部阻断，整个服务很容易被搞垮。 </p>
<h4 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h4><h5 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h5><p>漏桶算法将请求缓存在桶中，服务流程匀速处理。超出桶容量的部分丢弃。漏桶算法主要用于保护内部的处理业务，保障其稳定有节奏的处理请求，但是无法根据流量的波动弹性调整响应能力。现实中，类似容纳人数有限的服务大厅开启了固定的服务窗口。</p>
<img src="/blog/2020/08/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E4%B8%8E%E5%BA%94%E7%94%A8/pic1.png" srcset="/blog/img/loading.gif" class>

<h5 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h5><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.release;

<span class="hljs-keyword">import</span> java.util.concurrent.*;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Barrel</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-comment">//桶，用阻塞队列实现，容量为3 </span>
        <span class="hljs-keyword">final</span> LinkedBlockingQueue&lt;Integer&gt; que = <span class="hljs-keyword">new</span> LinkedBlockingQueue(<span class="hljs-number">3</span>);
        <span class="hljs-comment">//定时器，相当于服务的窗口，2s处理一个</span>
        ScheduledExecutorService service = Executors.newScheduledThreadPool(<span class="hljs-number">1</span>);
        service.scheduleAtFixedRate(<span class="hljs-keyword">new</span> Runnable() &#123;
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
                <span class="hljs-keyword">int</span> v = que.poll();
                System.out.println(<span class="hljs-string">&quot;处理：&quot;</span> + v);
            &#125;
        &#125;, <span class="hljs-number">2000</span>, <span class="hljs-number">2000</span>, TimeUnit.MILLISECONDS);
        <span class="hljs-comment">//无数个请求，i 可以理解为请求的编号</span>
        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;
            i++;
            <span class="hljs-keyword">try</span> &#123;
                System.out.println(<span class="hljs-string">&quot;put:&quot;</span> + i);
                <span class="hljs-comment">//如果是put，会一直等待桶中有空闲位置，不会丢弃 </span>
                <span class="hljs-comment">//que.put(i);</span>
                <span class="hljs-comment">//等待1s如果进不了桶，就溢出丢弃 </span>
                que.offer(i, <span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS);
            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
&#125;</code></pre>

<h5 id="结果分析-4"><a href="#结果分析-4" class="headerlink" title="结果分析"></a>结果分析</h5><pre><code class="hljs vim"><span class="hljs-keyword">pu</span><span class="hljs-variable">t:1</span>
<span class="hljs-keyword">pu</span><span class="hljs-variable">t:2</span>
<span class="hljs-keyword">pu</span><span class="hljs-variable">t:3</span>
<span class="hljs-keyword">pu</span><span class="hljs-variable">t:4</span>
<span class="hljs-keyword">pu</span><span class="hljs-variable">t:5</span>
处理：<span class="hljs-number">1</span>
<span class="hljs-keyword">pu</span><span class="hljs-variable">t:6</span>
<span class="hljs-keyword">pu</span><span class="hljs-variable">t:7</span>
处理：<span class="hljs-number">2</span>
<span class="hljs-keyword">pu</span><span class="hljs-variable">t:8</span></code></pre>

<p>put任务号按照顺序入桶 </p>
<p>执行任务匀速的1s一个被处理 </p>
<p>因为桶的容量只有3，所以1-3完美执行，4被溢出丢弃，5正常执行 </p>
<h5 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h5><p>有效的挡住了外部的请求，保护了内部的服务不会过载 </p>
<p>内部服务匀速执行，无法应对流量洪峰，无法做到弹性处理突发任务</p>
<p>任务超时溢出时被丢弃。现实中可能需要缓存队列辅助保持一段时间 </p>
<h5 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h5><p>nginx中的限流是漏桶算法的典型应用，配置案例如下： </p>
<pre><code class="hljs yaml"><span class="hljs-string">http</span> &#123;
	<span class="hljs-comment">#$binary_remote_addr 表示通过remote_addr这个标识来做key，也就是限制同一客户端ip地址。</span>
  <span class="hljs-comment">#zone=one:10m 表示生成一个大小为10M，名字为one的内存区域，用来存储访问的频次信息。 </span>
  <span class="hljs-comment">#rate=1r/s 表示允许相同标识的客户端每秒1次访问</span>
  <span class="hljs-string">limit_req_zone</span> <span class="hljs-string">$binary_remote_addr</span> <span class="hljs-string">zone=one:10m</span> <span class="hljs-string">rate=1r/s;</span>
  <span class="hljs-string">server</span> &#123; 
  	<span class="hljs-string">location</span> <span class="hljs-string">/limited/</span> &#123; 
  	<span class="hljs-comment">#zone=one 与上面limit_req_zone 里的name对应。 </span>
  	<span class="hljs-comment">#burst=5 缓冲区，超过了访问频次限制的请求可以先放到这个缓冲区内，类似代码中的队列长度。</span>
    <span class="hljs-comment">#nodelay 如果设置，超过访问频次而且缓冲区也满了的时候就会直接返回503，如果没有设置，则所有请求 会等待排队，类似代码中的put还是offer。</span>
    <span class="hljs-string">limit_req</span> <span class="hljs-string">zone=one</span> <span class="hljs-string">burst=5</span> <span class="hljs-string">nodelay;</span>
  &#125; 
&#125;</code></pre>

<h4 id="令牌桶"><a href="#令牌桶" class="headerlink" title="令牌桶"></a>令牌桶</h4><h5 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h5><p>令牌桶算法可以认为是漏桶算法的一种升级，它不但可以将流量做一步限制，还可以解决漏桶中无法弹性伸缩处理请求的问题。体现在现实中，类似服务大厅的门口设置门禁卡发放。发放是匀速的，请求较少时，令牌可以缓存起来，供流量爆发时一次性批量获取使用。而内部服务窗口不设限。 </p>
<img src="/blog/2020/08/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E4%B8%8E%E5%BA%94%E7%94%A8/pic2.png" srcset="/blog/img/loading.gif" class>

<h5 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h5><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.release;

<span class="hljs-keyword">import</span> java.util.concurrent.*;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Token</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
        <span class="hljs-comment">//令牌桶，信号量实现，容量为3</span>
        <span class="hljs-keyword">final</span> Semaphore semaphore = <span class="hljs-keyword">new</span> Semaphore(<span class="hljs-number">3</span>);
        <span class="hljs-comment">//定时器，1s一个，匀速颁发令牌</span>
        ScheduledExecutorService service = Executors.newScheduledThreadPool(<span class="hljs-number">1</span>);
        service.scheduleAtFixedRate(<span class="hljs-keyword">new</span> Runnable() &#123;
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
                <span class="hljs-keyword">if</span> (semaphore.availablePermits() &lt; <span class="hljs-number">3</span>) &#123;
                    semaphore.release();
                &#125;
                <span class="hljs-comment">// System.out.println(&quot;令牌数：&quot;+semaphore.availablePermits());</span>
            &#125;
        &#125;, <span class="hljs-number">1000</span>, <span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS);
        <span class="hljs-comment">//等待，等候令牌桶储存</span>
        Thread.sleep(<span class="hljs-number">5</span>);
        <span class="hljs-comment">//模拟洪峰5个请求，前3个迅速响应，后两个排队 </span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;
            semaphore.acquire();
            System.out.println(<span class="hljs-string">&quot;洪峰：&quot;</span> + i);
        &#125;
        <span class="hljs-comment">//模拟日常请求，2s一个 </span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;
            Thread.sleep(<span class="hljs-number">1000</span>);
            semaphore.acquire();
            System.out.println(<span class="hljs-string">&quot;日常：&quot;</span> + i);
            Thread.sleep(<span class="hljs-number">1000</span>);
        &#125;
        <span class="hljs-comment">//再次洪峰</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;
            semaphore.acquire();
            System.out.println(<span class="hljs-string">&quot;洪峰：&quot;</span> + i);
        &#125;
        <span class="hljs-comment">//检查令牌桶的数量</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;
            Thread.sleep(<span class="hljs-number">2000</span>);
            System.out.println(<span class="hljs-string">&quot;令牌剩余：&quot;</span> + semaphore.availablePermits());
        &#125;
    &#125;
&#125;</code></pre>

<h5 id="结果分析-5"><a href="#结果分析-5" class="headerlink" title="结果分析"></a>结果分析</h5><pre><code class="hljs plain">洪峰：0
洪峰：1
洪峰：2
洪峰：3
洪峰：4
日常：0
日常：1
日常：2
洪峰：0
洪峰：1
洪峰：2
洪峰：3
洪峰：4
令牌剩余：2
令牌剩余：3
令牌剩余：3</code></pre>

<ul>
<li><p>洪峰0-2迅速被执行，说明桶中暂存了3个令牌，有效应对了洪峰 </p>
</li>
<li><p>洪峰3，4被间隔性执行，得到了有效的限流 </p>
</li>
<li><p>日常请求被匀速执行，间隔均匀 </p>
</li>
<li><p>第二波洪峰来临，和第一次一样 </p>
</li>
<li><p>请求过去后，令牌最终被均匀颁发，积累到3个后不再上升 </p>
</li>
</ul>
<h5 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h5><p>springcloud中gateway可以配置令牌桶实现限流控制，案例如下： </p>
<pre><code class="hljs yml"><span class="hljs-attr">cloud:</span> 
	<span class="hljs-attr">gateway:</span> 
		<span class="hljs-attr">routes:</span> 
			<span class="hljs-attr">id:</span> <span class="hljs-string">limit_route</span> 
			<span class="hljs-attr">uri:</span> <span class="hljs-string">http://localhost:8080/test</span> 
			<span class="hljs-attr">filters:</span> 
				<span class="hljs-attr">name:</span> <span class="hljs-string">RequestRateLimiter</span> 
				<span class="hljs-attr">args:</span> <span class="hljs-comment">#限流的key，ipKeyResolver为spring中托管的Bean，需要扩展KeyResolver接口 </span>
				<span class="hljs-string">key‐resolver:</span> <span class="hljs-string">&#x27;#&#123;@ipResolver&#125;&#x27;</span> 
				<span class="hljs-comment">#令牌桶每秒填充平均速率，相当于代码中的发放频率 </span>
				<span class="hljs-string">redis‐rate‐limiter.replenishRate:</span> <span class="hljs-number">1</span> 
				<span class="hljs-comment">#令牌桶总容量，相当于代码中，信号量的容量 </span>
				<span class="hljs-string">redis‐rate‐limiter.burstCapacity:</span> <span class="hljs-number">3</span></code></pre>

<h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><h5 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h5><p>滑动窗口可以理解为细分之后的计数器，计数器粗暴的限定1分钟内的访问次数，而滑动窗口限流将1分钟拆为多个段，不但要求整个1分钟内请求数小于上限，而且要求每个片段请求数也要小于上限。相当于将原来的计数周期做了多个片段拆分。更为精细。 </p>
<img src="/blog/2020/08/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E4%B8%8E%E5%BA%94%E7%94%A8/pic3.png" srcset="/blog/img/loading.gif" class>

<h5 id="实现-6"><a href="#实现-6" class="headerlink" title="实现"></a>实现</h5><img src="/blog/2020/08/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E4%B8%8E%E5%BA%94%E7%94%A8/pic4.png" srcset="/blog/img/loading.gif" class>

<pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.release;

<span class="hljs-keyword">import</span> java.util.LinkedList;
<span class="hljs-keyword">import</span> java.util.Map;
<span class="hljs-keyword">import</span> java.util.TreeMap;
<span class="hljs-keyword">import</span> java.util.concurrent.Executors;
<span class="hljs-keyword">import</span> java.util.concurrent.ScheduledExecutorService;
<span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;
<span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Window</span> </span>&#123;
    <span class="hljs-comment">//整个窗口的流量上限，超出会被限流 </span>
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> totalMax = <span class="hljs-number">5</span>;
    <span class="hljs-comment">//每片的流量上限，超出同样会被拒绝，可以设置不同的值 </span>
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> sliceMax = <span class="hljs-number">5</span>;
    <span class="hljs-comment">//分多少片 </span>
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> slice = <span class="hljs-number">3</span>;
    <span class="hljs-comment">//窗口，分3段，每段1s，也就是总长度3s </span>
    <span class="hljs-keyword">final</span> LinkedList&lt;Long&gt; linkedList = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();
    <span class="hljs-comment">//计数器，每片一个key，可以使用HashMap，这里为了控制台保持有序性和可读性，采用TreeMap </span>
    Map&lt;Long, AtomicInteger&gt; map = <span class="hljs-keyword">new</span> TreeMap();
    <span class="hljs-comment">//心跳，每1s跳动1次，滑动窗口向前滑动一步，实际业务中可能需要手动控制滑动窗口的时机。</span>
    ScheduledExecutorService service = Executors.newScheduledThreadPool(<span class="hljs-number">1</span>);

    <span class="hljs-comment">//获取key值，这里即是时间戳（秒）</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> Long <span class="hljs-title">getKey</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> System.currentTimeMillis() / <span class="hljs-number">1000</span>;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Window</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-comment">//初始化窗口，当前时间指向的是最末端，前两片其实是过去的2s </span>
        Long key = getKey();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; slice; i++) &#123;
            linkedList.addFirst(key - i);
            map.put(key - i, <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>));
        &#125;
        <span class="hljs-comment">//启动心跳任务，窗口根据时间，自动向前滑动，每秒1步 </span>
        service.scheduleAtFixedRate(<span class="hljs-keyword">new</span> Runnable() &#123;
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
                Long key = getKey();
                <span class="hljs-comment">//队尾添加最新的片</span>
                linkedList.addLast(key);
                map.put(key, <span class="hljs-keyword">new</span> AtomicInteger());
                <span class="hljs-comment">//将最老的片移除</span>
                map.remove(linkedList.getFirst());
                linkedList.removeFirst();
                System.out.println(<span class="hljs-string">&quot;step:&quot;</span> + key + <span class="hljs-string">&quot;:&quot;</span> + map);
                ;
            &#125;
        &#125;, <span class="hljs-number">1000</span>, <span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS);
    &#125;

    <span class="hljs-comment">//检查当前时间所在的片是否达到上限</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkCurrentSlice</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">long</span> key = getKey();
        AtomicInteger integer = map.get(key);
        <span class="hljs-keyword">if</span> (integer != <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">return</span> integer.get() &lt; sliceMax;
        &#125;
        <span class="hljs-comment">//默认允许访问 </span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    &#125;

    <span class="hljs-comment">//检查整个窗口所有片的计数之和是否达到上限</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkAllCount</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> map.values().stream().mapToInt(value -&gt; value.get()).sum() &lt; totalMax;
    &#125;

    <span class="hljs-comment">//请求来临.... </span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">req</span><span class="hljs-params">()</span> </span>&#123;
        Long key = getKey();
        <span class="hljs-comment">//如果时间窗口未到达当前时间片，稍微等待一下 </span>
        <span class="hljs-comment">// 其实是一个保护措施，放置心跳对滑动窗口的推动滞后于当前请求</span>
        <span class="hljs-keyword">while</span> (linkedList.getLast() &lt; key) &#123;
            <span class="hljs-keyword">try</span> &#123;
                Thread.sleep(<span class="hljs-number">200</span>);
            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
        <span class="hljs-comment">//开始检查，如果未达到上限，返回ok，计数器增加1 </span>
        <span class="hljs-comment">// 如果任意一项达到上限，拒绝请求，达到限流的目的 </span>
        <span class="hljs-comment">// 这里是直接拒绝。现实中可能会设置缓冲池，将请求放入缓冲队列暂存 </span>
        <span class="hljs-keyword">if</span> (checkCurrentSlice() &amp;&amp; checkAllCount()) &#123;
            map.get(key).incrementAndGet();
            System.out.println(key + <span class="hljs-string">&quot;=ok:&quot;</span> + map);
        &#125; <span class="hljs-keyword">else</span> &#123;
            System.out.println(key + <span class="hljs-string">&quot;=reject:&quot;</span> + map);
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
        Window window = <span class="hljs-keyword">new</span> Window();
        <span class="hljs-comment">//模拟10个离散的请求，相对之间有200ms间隔。会造成总数达到上限而被限流 </span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;
            Thread.sleep(<span class="hljs-number">200</span>);
            window.req();
        &#125;
        <span class="hljs-comment">//等待一下窗口滑动，让各个片的计数器都置零</span>
        Thread.sleep(<span class="hljs-number">3000</span>);
        <span class="hljs-comment">//模拟突发请求，单个片的计数器达到上限而被限流</span>
        System.out.println(<span class="hljs-string">&quot;‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐&quot;</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;
            window.req();
        &#125;
    &#125;
&#125;</code></pre>

<h5 id="结果分析-6"><a href="#结果分析-6" class="headerlink" title="结果分析"></a>结果分析</h5><pre><code class="hljs routeros"><span class="hljs-attribute">1598005699</span>=ok:&#123;<span class="hljs-attribute">1598005697</span>=0, <span class="hljs-attribute">1598005698</span>=0, <span class="hljs-attribute">1598005699</span>=1&#125;
<span class="hljs-attribute">1598005699</span>=ok:&#123;<span class="hljs-attribute">1598005697</span>=0, <span class="hljs-attribute">1598005698</span>=0, <span class="hljs-attribute">1598005699</span>=2&#125;
<span class="hljs-keyword">step</span>:1598005700:&#123;<span class="hljs-attribute">1598005698</span>=0, <span class="hljs-attribute">1598005699</span>=2, <span class="hljs-attribute">1598005700</span>=0&#125;
<span class="hljs-attribute">1598005700</span>=ok:&#123;<span class="hljs-attribute">1598005698</span>=0, <span class="hljs-attribute">1598005699</span>=2, <span class="hljs-attribute">1598005700</span>=1&#125;
<span class="hljs-attribute">1598005700</span>=ok:&#123;<span class="hljs-attribute">1598005698</span>=0, <span class="hljs-attribute">1598005699</span>=2, <span class="hljs-attribute">1598005700</span>=2&#125;
<span class="hljs-attribute">1598005700</span>=ok:&#123;<span class="hljs-attribute">1598005698</span>=0, <span class="hljs-attribute">1598005699</span>=2, <span class="hljs-attribute">1598005700</span>=3&#125;</code></pre>

<p>模拟零零散散的请求，会造成每个片里均有计数，总数达到上限后，不再响应，限流生效</p>
<p>再模拟突发的流量请求，会造成单片流量计数达到上限，不再响应而被限流</p>
<pre><code class="hljs routeros"><span class="hljs-attribute">1598005705</span>=reject:&#123;<span class="hljs-attribute">1598005703</span>=0, <span class="hljs-attribute">1598005704</span>=0, <span class="hljs-attribute">1598005705</span>=5&#125;
<span class="hljs-attribute">1598005705</span>=reject:&#123;<span class="hljs-attribute">1598005703</span>=0, <span class="hljs-attribute">1598005704</span>=0, <span class="hljs-attribute">1598005705</span>=5&#125;
<span class="hljs-attribute">1598005705</span>=reject:&#123;<span class="hljs-attribute">1598005703</span>=0, <span class="hljs-attribute">1598005704</span>=0, <span class="hljs-attribute">1598005705</span>=5&#125;
<span class="hljs-attribute">1598005705</span>=reject:&#123;<span class="hljs-attribute">1598005703</span>=0, <span class="hljs-attribute">1598005704</span>=0, <span class="hljs-attribute">1598005705</span>=5&#125;
<span class="hljs-attribute">1598005705</span>=reject:&#123;<span class="hljs-attribute">1598005703</span>=0, <span class="hljs-attribute">1598005704</span>=0, <span class="hljs-attribute">1598005705</span>=5&#125;</code></pre>

<h5 id="应用-3"><a href="#应用-3" class="headerlink" title="应用"></a>应用</h5><p>滑动窗口算法，在tcp协议发包过程中被使用。在web现实场景中，可以将流量控制做更细化处理，解决计数器模型控制力度太粗暴的问题。 </p>
<h3 id="调度算法与应用"><a href="#调度算法与应用" class="headerlink" title="调度算法与应用"></a>调度算法与应用</h3><p>调度算法常见于操作系统中，因为系统资源有限，当有多个进程（或多个进程发出的请求）要使用这些资源时，就 必须按照一定的原则选择进程（请求）来占用资源。这就是所谓的调度。在现实生活中也是一样，比如会议室的占用。</p>
<h4 id="先来先服务（FCFS）"><a href="#先来先服务（FCFS）" class="headerlink" title="先来先服务（FCFS）"></a>先来先服务（FCFS）</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>先来先服务，很好理解，就是按照服务提交申请的顺序，依次执行。讲究先来后到。 </p>
<h5 id="实现-7"><a href="#实现-7" class="headerlink" title="实现"></a>实现</h5><p>定义一个Task类作为任务实例，BlockingQueue作为服务队列 </p>
<pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.schedule;

<span class="hljs-comment">/*** 任务类 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Task</span> </span>&#123;
    <span class="hljs-comment">//任务名称</span>
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-comment">//任务提交的时间 </span>
    <span class="hljs-keyword">private</span> Long addTime;
    <span class="hljs-comment">//任务的执行时间长短 </span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> servTime;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Task</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> servTime)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.name = name;
        <span class="hljs-keyword">this</span>.servTime = servTime;
        <span class="hljs-keyword">this</span>.addTime = System.currentTimeMillis();
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-comment">// ！重点：执行时睡眠，表示该任务耗时servTime毫秒</span>
            Thread.currentThread().sleep(servTime);
        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        System.out.println(String.format(<span class="hljs-string">&quot;execute:name=%s,addTime=%s,servTime=%s&quot;</span>, name, addTime, servTime));
    &#125;
&#125;</code></pre>

<pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.schedule;

<span class="hljs-keyword">import</span> java.util.Random;
<span class="hljs-keyword">import</span> java.util.concurrent.LinkedBlockingQueue;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FCFS</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
        <span class="hljs-comment">//阻塞队列，FCFS的基础 </span>
        <span class="hljs-keyword">final</span> LinkedBlockingQueue&lt;Task&gt; queue = <span class="hljs-keyword">new</span> LinkedBlockingQueue(<span class="hljs-number">5</span>);
        <span class="hljs-comment">//服务线程，任务由该线程获取和执行 </span>
        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
                <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;
                    <span class="hljs-keyword">try</span> &#123;
                        queue.take().execute();
                    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
                        e.printStackTrace();
                    &#125;
                &#125;
            &#125;
        &#125;).start();
        <span class="hljs-comment">//向队列中放入一个任务 </span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;
            System.out.println(<span class="hljs-string">&quot;add task:&quot;</span> + i);
            queue.put(<span class="hljs-keyword">new</span> Task(<span class="hljs-string">&quot;task&quot;</span> + i, <span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">1000</span>)));
        &#125;
    &#125;
&#125;</code></pre>

<h5 id="结果分析-7"><a href="#结果分析-7" class="headerlink" title="结果分析"></a>结果分析</h5><pre><code class="hljs apache"><span class="hljs-attribute">add</span> task:<span class="hljs-number">0</span>
<span class="hljs-attribute">add</span> task:<span class="hljs-number">1</span>
<span class="hljs-attribute">add</span> task:<span class="hljs-number">2</span>
<span class="hljs-attribute">add</span> task:<span class="hljs-number">3</span>
<span class="hljs-attribute">add</span> task:<span class="hljs-number">4</span>
<span class="hljs-attribute">execute</span>:name=task<span class="hljs-number">0</span>,addTime=<span class="hljs-number">1598006103935</span>,servTime=<span class="hljs-number">690</span>
<span class="hljs-attribute">execute</span>:name=task<span class="hljs-number">1</span>,addTime=<span class="hljs-number">1598006103935</span>,servTime=<span class="hljs-number">951</span>
<span class="hljs-attribute">execute</span>:name=task<span class="hljs-number">2</span>,addTime=<span class="hljs-number">1598006103935</span>,servTime=<span class="hljs-number">437</span>
<span class="hljs-attribute">execute</span>:name=task<span class="hljs-number">3</span>,addTime=<span class="hljs-number">1598006103935</span>,servTime=<span class="hljs-number">692</span>
<span class="hljs-attribute">execute</span>:name=task<span class="hljs-number">4</span>,addTime=<span class="hljs-number">1598006103935</span>,servTime=<span class="hljs-number">446</span></code></pre>

<ul>
<li><p>add按顺序放入，时间有序 </p>
</li>
<li><p>execute也按时间顺序执行，而不管后面的servTime，也就是不管执行任务长短，先来先执行 </p>
</li>
</ul>
<h5 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h5><ul>
<li><p>多应用于cpu密集型任务场景，对io密集型的不利。 </p>
</li>
<li><p>时间相对均衡的业务可以排队处理，比如现实中排队打卡进站。 </p>
</li>
<li><p>如果业务需要依赖大量的外部因素，执行时间片长短不一，FCFS算法不利于任务的整体处理进度，可能会因为一个长时间业务的阻塞而造成大量等待。 </p>
</li>
</ul>
<h4 id="短作业优先（SJF）"><a href="#短作业优先（SJF）" class="headerlink" title="短作业优先（SJF）"></a>短作业优先（SJF）</h4><h5 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h5><p>执行时间短的优先得到资源。即执行前申报一个我需要占据cpu的时间，根据时间长短，短的优先被调度。我不占时间所以我先来。 </p>
<h5 id="实现-8"><a href="#实现-8" class="headerlink" title="实现"></a>实现</h5><p>使用TreeMap可以实现优先级的任务排序。</p>
<pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.schedule;

<span class="hljs-keyword">import</span> java.util.Map;
<span class="hljs-keyword">import</span> java.util.Random;
<span class="hljs-keyword">import</span> java.util.TreeMap;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SJF</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
        <span class="hljs-comment">//有序Map，将服务时间作为key排序</span>
        <span class="hljs-keyword">final</span> TreeMap&lt;Integer, Task&gt; treeMap = <span class="hljs-keyword">new</span> TreeMap();
        <span class="hljs-comment">//向队列中放入5个任务 </span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;
            System.out.println(<span class="hljs-string">&quot;add task:&quot;</span> + i);
            <span class="hljs-keyword">int</span> servTime = <span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">1000</span>);
            <span class="hljs-comment">//注意，key是servTime，即执行预估时间</span>
            treeMap.put(servTime, <span class="hljs-keyword">new</span> Task(<span class="hljs-string">&quot;task&quot;</span> + i, servTime));
        &#125;
        <span class="hljs-comment">//服务线程，任务由该线程获取和执行 </span>
        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
                <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;
                    <span class="hljs-keyword">try</span> &#123;
                        <span class="hljs-comment">//有序Map中，服务时间短的，置于顶部，那么自然就会优先被取出 </span>
                        Map.Entry&lt;Integer, Task&gt; entry = treeMap.pollFirstEntry();
                        <span class="hljs-keyword">if</span> (entry == <span class="hljs-keyword">null</span>) &#123;
                            Thread.currentThread().sleep(<span class="hljs-number">100</span>);
                        &#125; <span class="hljs-keyword">else</span> &#123;
                            entry.getValue().execute();
                        &#125;
                    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
                        e.printStackTrace();
                    &#125;
                &#125;
            &#125;
        &#125;).start();
    &#125;
&#125;</code></pre>

<h5 id="结果分析-8"><a href="#结果分析-8" class="headerlink" title="结果分析"></a>结果分析</h5><pre><code class="hljs apache"><span class="hljs-attribute">add</span> task:<span class="hljs-number">0</span>
<span class="hljs-attribute">add</span> task:<span class="hljs-number">1</span>
<span class="hljs-attribute">add</span> task:<span class="hljs-number">2</span>
<span class="hljs-attribute">add</span> task:<span class="hljs-number">3</span>
<span class="hljs-attribute">add</span> task:<span class="hljs-number">4</span>
<span class="hljs-attribute">execute</span>:name=task<span class="hljs-number">4</span>,addTime=<span class="hljs-number">1598006336903</span>,servTime=<span class="hljs-number">116</span>
<span class="hljs-attribute">execute</span>:name=task<span class="hljs-number">2</span>,addTime=<span class="hljs-number">1598006336902</span>,servTime=<span class="hljs-number">117</span>
<span class="hljs-attribute">execute</span>:name=task<span class="hljs-number">0</span>,addTime=<span class="hljs-number">1598006336902</span>,servTime=<span class="hljs-number">575</span>
<span class="hljs-attribute">execute</span>:name=task<span class="hljs-number">3</span>,addTime=<span class="hljs-number">1598006336902</span>,servTime=<span class="hljs-number">689</span>
<span class="hljs-attribute">execute</span>:name=task<span class="hljs-number">1</span>,addTime=<span class="hljs-number">1598006336902</span>,servTime=<span class="hljs-number">935</span></code></pre>

<p>add任务有序，确实按照从前往后顺序提交的 </p>
<p>execute任务无序，按servtime排序，说明执行时间段的得到了优先执行 </p>
<h5 id="优缺点-4"><a href="#优缺点-4" class="headerlink" title="优缺点"></a>优缺点</h5><ul>
<li><p>适用于任务时间差别较大的场景，仍然以进站为例，拿出公交卡的优先刷卡，还没办卡的让一让。 </p>
</li>
<li><p>解决了FCFS整体处理时间长的问题，降低平均等待时间，提高了系统吞吐量。 </p>
</li>
<li><p>未考虑作业的紧迫程度，因而不能保证紧迫性作业（进程）的及时处理 </p>
</li>
<li><p>对长作业的不利，可能等待很久而得不到执行 </p>
</li>
<li><p>时间基于预估和申报，主观性因素在内，无法做到100%的精准</p>
</li>
</ul>
<h4 id="时间片轮转（RR）"><a href="#时间片轮转（RR）" class="headerlink" title="时间片轮转（RR）"></a>时间片轮转（RR）</h4><h5 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h5><p>时间片逐个扫描轮询，轮到谁谁执行。大家公平裁决来者有份，谁也别插队。像是棋牌游戏中的发牌操作，做到了时间和机会上的平均性。 </p>
<h5 id="实现-9"><a href="#实现-9" class="headerlink" title="实现"></a>实现</h5><p>基于数组做为数据插槽方式实现。</p>
<pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.schedule;

<span class="hljs-keyword">import</span> java.util.Random;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RR</span> </span>&#123;
    <span class="hljs-comment">//定义数组作为插槽，每个插槽中可以放入任务</span>
    Integer[] integers;

    <span class="hljs-comment">//length插槽的个数 </span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RR</span><span class="hljs-params">(<span class="hljs-keyword">int</span> length)</span> </span>&#123;
        integers = <span class="hljs-keyword">new</span> Integer[length];
    &#125;

    <span class="hljs-comment">//将任务放入插槽</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addTask</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;
        <span class="hljs-keyword">int</span> slot = <span class="hljs-number">0</span>;
        <span class="hljs-comment">//不停查找空的插槽</span>
        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;
            <span class="hljs-comment">//发现空位，将当前任务放入 </span>
            <span class="hljs-keyword">if</span> (integers[slot] == <span class="hljs-keyword">null</span>) &#123;
                integers[slot] = value;
                System.out.println(String.format(<span class="hljs-string">&quot;‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐&gt;add task index=%s,value=%s&quot;</span>, slot, value));
                <span class="hljs-keyword">break</span>;
            &#125;
            <span class="hljs-comment">//如果当前位置有任务占用，看下一个位置</span>
            slot++;
            <span class="hljs-comment">//如果插槽遍历完还是没有空位置，那么从头开始再找，继续下一个轮回</span>
            <span class="hljs-keyword">if</span> (slot == integers.length) &#123;
                slot = <span class="hljs-number">0</span>;
            &#125;
        &#125;
    &#125;

    <span class="hljs-comment">//执行任务。轮询的策略就在这里 </span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-comment">//开启一个线程处理任务。在现实中可能有多个消费者来处理 </span>
        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
                <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;
                <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;
                    <span class="hljs-comment">//指针轮询，如果到达尾部，下一步重新转向开头 </span>
                    <span class="hljs-comment">// 数据物理结构是一个数组，逻辑上是一个环 </span>
                    <span class="hljs-keyword">if</span> (index == integers.length) &#123;
                        index = <span class="hljs-number">0</span>;
                    &#125;
                    <span class="hljs-comment">//如果当前位置没有任务，轮询到下一个插槽</span>
                    <span class="hljs-keyword">if</span> (integers[index] == <span class="hljs-keyword">null</span>) &#123;
                        index++;
                        <span class="hljs-keyword">continue</span>;
                    &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//随机等待，表示模拟当前任务有一个执行时间</span>
                        <span class="hljs-keyword">try</span> &#123;
                            Thread.currentThread().sleep(<span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">1000</span>));
                        &#125; <span class="hljs-keyword">catch</span> (
                                InterruptedException e) &#123;
                            e.printStackTrace();
                        &#125;<span class="hljs-comment">//模拟任务执行的内容，也就是打印一下当前插槽和里面的值 </span>
                        System.out.println(String.format(<span class="hljs-string">&quot;execute index=%s,value=%s&quot;</span>, index, integers[index]));
                        <span class="hljs-comment">//执行完，将当前插槽清空，腾出位置来给后续任务使用 </span>
                        integers[index] = <span class="hljs-keyword">null</span>;
                    &#125;
                &#125;
            &#125;
        &#125;).start();
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-comment">//测试开始，定义3个插槽 </span>
        RR rr = <span class="hljs-keyword">new</span> RR(<span class="hljs-number">3</span>);
        <span class="hljs-comment">//唤起执行者线程，开始轮询</span>
        rr.execute();
        <span class="hljs-comment">//放置10个任务</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;
            rr.addTask(i);
        &#125;
    &#125;
&#125;</code></pre>

<h5 id="结果分析-9"><a href="#结果分析-9" class="headerlink" title="结果分析"></a>结果分析</h5><pre><code class="hljs smali">‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐&gt;add task index=0,value=0
‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐&gt;add task index=1,value=1
‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐&gt;add task index=2,value=2
execute index=0,value=0
‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐&gt;add task index=0,value=3
execute index=1,value=1
‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐&gt;add task index=1,value=4
execute index=2,value=2
‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐&gt;add task index=2,value=5
execute index=0,value=3
execute index=1,value=4
‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐&gt;add task index=1,value=6
‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐&gt;add task index=0,value=7
execute index=2,value=5
‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐&gt;add task index=2,value=8
execute index=0,value=7
execute index=1,value=6
‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐&gt;add task index=1,value=9
execute index=2,value=8
execute index=1,value=9</code></pre>

<p>add任务index无序，value有序，说明是按顺序提交的，但是插槽无序，哪里有空放哪里 </p>
<p>execute执行index有序value无序，说明任务是轮询执行的，每个插槽里的任务不一定是谁 </p>
<h5 id="优缺点-5"><a href="#优缺点-5" class="headerlink" title="优缺点"></a>优缺点</h5><p>做到了机会的相对平均，不会因为某个任务执行时间超长而永远得不到执行 </p>
<p>缺乏任务主次的处理。重要的任务无法得到优先执行，必须等到时间片轮到自己，着急也没用</p>
<h4 id="优先级调度（HPF）"><a href="#优先级调度（HPF）" class="headerlink" title="优先级调度（HPF）"></a>优先级调度（HPF）</h4><h5 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a>概述</h5><p>进程调度每次将处理机分配给具有最高优先级的就绪进程。最高优先级算法可与不同的CPU方式结合形成可抢占式最高优先级算法和不可抢占式最高优先级算法。 </p>
<h5 id="实现-10"><a href="#实现-10" class="headerlink" title="实现"></a>实现</h5><p>在Task类中新增一个属性level作为优先级标识</p>
<pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.schedule;

<span class="hljs-comment">/*** 任务类 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Task</span> </span>&#123;
    <span class="hljs-comment">//任务名称</span>
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-comment">//任务提交的时间</span>
    <span class="hljs-keyword">private</span> Long addTime;
    <span class="hljs-comment">//任务的执行时间长短</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> servTime;
    <span class="hljs-comment">//任务优先级</span>
     <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> level;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Task</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> servTime)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.name = name;
        <span class="hljs-keyword">this</span>.servTime = servTime;
        <span class="hljs-keyword">this</span>.addTime = System.currentTimeMillis();
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Task</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> servTime,<span class="hljs-keyword">int</span> level)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.name = name;
        <span class="hljs-keyword">this</span>.servTime = servTime;
        <span class="hljs-keyword">this</span>.addTime = System.currentTimeMillis();
        <span class="hljs-keyword">this</span>.level = level;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-comment">// ！重点：执行时睡眠，表示该任务耗时servTime毫秒</span>
            Thread.currentThread().sleep(servTime);
        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        System.out.println(String.format(<span class="hljs-string">&quot;execute:name=%s,addTime=%s,servTime=%s&quot;</span>, name, addTime, servTime));
    &#125;
&#125;</code></pre>

<p>依然使用TreeMap实现排序，注意的是，key要取优先级</p>
<pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.schedule;

<span class="hljs-keyword">import</span> java.util.Map;
<span class="hljs-keyword">import</span> java.util.Random;
<span class="hljs-keyword">import</span> java.util.TreeMap;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HPF</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
        <span class="hljs-comment">//有序Map，将服务优先级作为key排序 </span>
        <span class="hljs-keyword">final</span> TreeMap&lt;Integer, Task&gt; treeMap = <span class="hljs-keyword">new</span> TreeMap();
        <span class="hljs-comment">//向队列中放入5个任务 </span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;
            System.out.println(<span class="hljs-string">&quot;add task:&quot;</span> + i);
            <span class="hljs-keyword">int</span> servTime = <span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">1000</span>);
            <span class="hljs-comment">//注意放入的key，是优先级，这里用i标识 </span>
            treeMap.put(i, <span class="hljs-keyword">new</span> Task(<span class="hljs-string">&quot;task&quot;</span> + i, servTime, i));
        &#125;
        <span class="hljs-comment">//服务线程，任务由该线程获取和执行 </span>
        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
                <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;
                    <span class="hljs-keyword">try</span> &#123;
                        <span class="hljs-comment">//有序Map中，优先级最高的，在底部部，那么自然就会优先被取出 </span>
                        Map.Entry&lt;Integer, Task&gt; entry = treeMap.pollLastEntry();
                        <span class="hljs-keyword">if</span> (entry == <span class="hljs-keyword">null</span>) &#123;
                            Thread.currentThread().sleep(<span class="hljs-number">100</span>);
                        &#125; <span class="hljs-keyword">else</span> &#123;
                            entry.getValue().execute();
                        &#125;
                    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
                        e.printStackTrace();
                    &#125;
                &#125;
            &#125;
        &#125;).start();
    &#125;
&#125;</code></pre>

<h5 id="结果分析-10"><a href="#结果分析-10" class="headerlink" title="结果分析"></a>结果分析</h5><pre><code class="hljs apache"><span class="hljs-attribute">add</span> task:<span class="hljs-number">0</span>
<span class="hljs-attribute">add</span> task:<span class="hljs-number">1</span>
<span class="hljs-attribute">add</span> task:<span class="hljs-number">2</span>
<span class="hljs-attribute">add</span> task:<span class="hljs-number">3</span>
<span class="hljs-attribute">add</span> task:<span class="hljs-number">4</span>
<span class="hljs-attribute">execute</span>:name=task<span class="hljs-number">4</span>,addTime=<span class="hljs-number">1598006945022</span>,servTime=<span class="hljs-number">591</span>
<span class="hljs-attribute">execute</span>:name=task<span class="hljs-number">3</span>,addTime=<span class="hljs-number">1598006945022</span>,servTime=<span class="hljs-number">974</span>
<span class="hljs-attribute">execute</span>:name=task<span class="hljs-number">2</span>,addTime=<span class="hljs-number">1598006945022</span>,servTime=<span class="hljs-number">52</span>
<span class="hljs-attribute">execute</span>:name=task<span class="hljs-number">1</span>,addTime=<span class="hljs-number">1598006945022</span>,servTime=<span class="hljs-number">281</span>
<span class="hljs-attribute">execute</span>:name=task<span class="hljs-number">0</span>,addTime=<span class="hljs-number">1598006945022</span>,servTime=<span class="hljs-number">609</span></code></pre>

<p>按0-4顺序加入task </p>
<p>执行时，按4-0，优先级高的先得到执行，而与服务时间，加入的时间无关 </p>
<h4 id="应用案例-1"><a href="#应用案例-1" class="headerlink" title="应用案例"></a>应用案例</h4><p>CPU资源调度 </p>
<p>云计算资源调度 </p>
<p>容器化Docker编排与调度 </p>
<h3 id="定时算法与应用"><a href="#定时算法与应用" class="headerlink" title="定时算法与应用"></a>定时算法与应用</h3><p>系统或者项目中难免会遇到各种需要自动去执行的任务，实现这些任务的手段也多种多样，如操作系统的crontab，spring框架的quartz，java的Timer和ScheduledThreadPool都是定时任务中的典型手段。 </p>
<h4 id="最小堆"><a href="#最小堆" class="headerlink" title="最小堆"></a>最小堆</h4><h5 id="概述-8"><a href="#概述-8" class="headerlink" title="概述"></a>概述</h5><p>Timer是java中最典型的基于优先级队列+最小堆实现的定时器，内部维护一个存放定时任务的优先级队列，该优先级队列使用了最小堆排序。当我们调用schedule方法的时候，一个新的任务被加入queue，堆重排，始终保持堆顶是执行时间最小（即最近马上要执行）的。同时，内部相当于起了一个线程不断扫描队列，从队列中依次获取堆顶元素执行，任务得到调度。 </p>
<p>下面以Timer为例，介绍优先级队列+最小堆算法的实现原理： </p>
<h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.schedule;

<span class="hljs-keyword">import</span> java.util.Timer;
<span class="hljs-keyword">import</span> java.util.TimerTask;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Task</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TimerTask</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;running...&quot;</span>);
    &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TimerDemo</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        Timer t = <span class="hljs-keyword">new</span> Timer();
        <span class="hljs-comment">//在1秒后执行,以后每2秒跑一次 </span>
        t.schedule(<span class="hljs-keyword">new</span> Task(), <span class="hljs-number">1000</span>, <span class="hljs-number">2000</span>);
    &#125;
&#125;</code></pre>

<h5 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h5><p>新加任务时，t.schedule方法会add到队列 </p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(TimerTask task)</span> </span>&#123;
    <span class="hljs-comment">// Grow backing store if necessary</span>
    <span class="hljs-keyword">if</span> (size + <span class="hljs-number">1</span> == queue.length) 
        queue = Arrays.copyOf(queue, <span class="hljs-number">2</span> * queue.length);
    queue[++size] = task;
    fixUp(size);
&#125;</code></pre>

<p>add实现了容量维护，不足时扩容，同时将新任务追加到队列队尾，触发堆排序，始终保持堆顶元素最小</p>
<pre><code class="hljs java"><span class="hljs-comment">//最小堆排序</span>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fixUp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span> </span>&#123;
    <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">1</span>) &#123;
        <span class="hljs-comment">//k指针指向当前新加入的节点，也就是队列的末尾节点，j为其父节点 </span>
        <span class="hljs-keyword">int</span> j = k &gt;&gt; <span class="hljs-number">1</span>;
        <span class="hljs-comment">//如果新加入的执行时间比父节点晚，那不需要动</span>
        <span class="hljs-keyword">if</span> (queue[j].nextExecutionTime &lt;= queue[k].nextExecutionTime)
            <span class="hljs-keyword">break</span>;
        <span class="hljs-comment">//如果大于其父节点，父子交换 </span>
        TimerTask tmp = queue[j];
        queue[j] = queue[k];
        queue[k] = tmp;
        <span class="hljs-comment">//交换后，当前指针继续指向新加入的节点，继续循环，知道堆重排合格 </span>
        k = j;
    &#125;
&#125;</code></pre>

<p>线程调度中的run，主要调用内部mainLoop()方法，使用while循环</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mainLoop</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;
        <span class="hljs-keyword">try</span> &#123;
            TimerTask task;
            <span class="hljs-keyword">boolean</span> taskFired;
            <span class="hljs-keyword">synchronized</span> (queue) &#123;
                <span class="hljs-comment">//... </span>
                <span class="hljs-comment">// Queue nonempty; look at first evt and do the right thing long currentTime, </span>
                executionTime;
                task = queue.getMin();
                <span class="hljs-keyword">synchronized</span> (task.lock) &#123;
                    <span class="hljs-comment">//... </span>
                    <span class="hljs-comment">// 当前时间 </span>
                    currentTime = System.currentTimeMillis();
                    <span class="hljs-comment">//要执行的时间 </span>
                    executionTime = task.nextExecutionTime;
                    <span class="hljs-comment">//判断是否到了执行时间</span>
                    <span class="hljs-keyword">if</span> (taskFired = (executionTime &lt;= currentTime)) &#123;
                        <span class="hljs-comment">//判断下一次执行时间，单次的执行完移除 </span>
                        <span class="hljs-comment">// 循环的修改下次执行时间 </span>
                        <span class="hljs-keyword">if</span> (task.period == <span class="hljs-number">0</span>) &#123;
                            <span class="hljs-comment">// Non‐repeating, remove </span>
                            queue.removeMin();
                            task.state = TimerTask.EXECUTED;
                        &#125; <span class="hljs-keyword">else</span> &#123;
                            <span class="hljs-comment">// Repeating task, reschedule </span>
                            <span class="hljs-comment">// 下次时间的计算有两种策略 </span>
                            <span class="hljs-comment">// 1.period是负数,那下一次的执行时间就是当前时间‐period </span>
                            <span class="hljs-comment">// 2.period是正数,那下一次就是该任务本次的执行时间+period </span>
                            <span class="hljs-comment">// 注意！这两种策略大不相同。因为Timer是单线程的 </span>
                            <span class="hljs-comment">// 如果是1，那么currentTime是当前时间，就受任务执行长短影响 </span>
                            <span class="hljs-comment">// 如果是2，那么executionTime是绝对时间戳，与任务长短无关 </span>
                            queue.rescheduleMin(task.period &lt; <span class="hljs-number">0</span> ? currentTime ‐ task.period :
                            executionTime + task.period);
                        &#125;
                    &#125;
                &#125;
                <span class="hljs-comment">//不到执行时间，等待 </span>
                <span class="hljs-keyword">if</span> (!taskFired)
                    <span class="hljs-comment">// Task hasn&#x27;t yet fired; wait </span>
                    queue.wait(executionTime - currentTime);
            &#125;
            <span class="hljs-comment">//到达执行时间，run！</span>
            <span class="hljs-keyword">if</span> (taskFired)
                <span class="hljs-comment">// Task fired; run it, holding no locks </span>
                task.run();
        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
        &#125;
    &#125;
&#125;</code></pre>

<h5 id="应用-4"><a href="#应用-4" class="headerlink" title="应用"></a>应用</h5><p>本节使用Timer为了介绍算法原理，但是Timer已过时，实际应用中推荐使用ScheduledThreadPoolExecutor（同样内部使用DelayedWorkQueue和最小堆排序）</p>
<p>Timer是单线程，一旦一个失败或出现异常，将打断全部任务队列，线程池不会</p>
<p>Timer在jdk1.3+，而线程池需要jdk1.5+ </p>
<h4 id="时间轮"><a href="#时间轮" class="headerlink" title="时间轮"></a>时间轮</h4><h5 id="概述-9"><a href="#概述-9" class="headerlink" title="概述"></a>概述</h5><p>时间轮是一种更为常见的定时调度算法，各种操作系统的定时任务调度，linux crontab，基于java的通信框架Netty等。其灵感来源于我们生活中的时钟。 </p>
<p>轮盘实际上是一个头尾相接的环状数组，数组的个数即是插槽数，每个插槽中可以放置任务。 </p>
<p>以1天为例，将任务的执行时间%12，根据得到的数值，放置在时间轮上，小时指针沿着轮盘扫描，扫到的点取出任务执行： </p>
<img src="/blog/2020/08/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E4%B8%8E%E5%BA%94%E7%94%A8/pic5.png" srcset="/blog/img/loading.gif" class>

<p>同时在每个槽上设置一个队列，队列可以无限追加，解决时间点冲突问题（类似HashMap结构）</p>
<img src="/blog/2020/08/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E4%B8%8E%E5%BA%94%E7%94%A8/pic6.png" srcset="/blog/img/loading.gif" class>

<p>问题：每个轮盘的时间有限，比如1个月后的第3天的5点怎么办？ </p>
<p>方案一：加长时间刻度，扩充到1年 </p>
<p>优缺点：简单，占据大量内存，即使插槽没有任务也要空轮询，白白的资源浪费，时间、空间复杂度都高 </p>
<p>方案二：每个任务记录一个计数器，表示转多少圈后才会执行。没当指针过来后，计数器减1，减到0的再执行 </p>
<p>优缺点：每到一个指针都需要取出链表遍历判断，时间复杂度高，但是空间复杂度低</p>
<p>方案三：设置多个时间轮，年轮，月轮，天轮。1天内的放入天轮，1年后的则放入年轮，当年轮指针读到后，将任务取出，放入下一级的月轮对应的插槽，月轮再到天轮，直到最小精度取到，任务被执行。 </p>
<p>优缺点：不需要额外的遍历时间，但是占据了多个轮的空间。空间复杂度升高，但是时间复杂度降低 </p>
<h5 id="实现-11"><a href="#实现-11" class="headerlink" title="实现"></a>实现</h5><p>定义Task类</p>
<pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.timer;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RoundTask</span> </span>&#123;
    <span class="hljs-comment">//延迟多少秒后执行 </span>
    <span class="hljs-keyword">int</span> delay;
    <span class="hljs-comment">//加入的序列号，只是标记一下加入的顺序 </span>
    <span class="hljs-keyword">int</span> index;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RoundTask</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> delay)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.index = index;
        <span class="hljs-keyword">this</span>.delay = delay;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;task &quot;</span> + index + <span class="hljs-string">&quot; start , delay = &quot;</span> + delay);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> String.valueOf(index + <span class="hljs-string">&quot;=&quot;</span> + delay);
    &#125;
&#125;</code></pre>

<p>时间轮算法</p>
<pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.timer;

<span class="hljs-keyword">import</span> java.util.LinkedList;
<span class="hljs-keyword">import</span> java.util.Random;
<span class="hljs-keyword">import</span> java.util.concurrent.Executors;
<span class="hljs-keyword">import</span> java.util.concurrent.ScheduledExecutorService;
<span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;
<span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RoundDemo</span> </span>&#123;
    <span class="hljs-comment">//小轮槽数</span>
    <span class="hljs-keyword">int</span> size1 = <span class="hljs-number">10</span>;
    <span class="hljs-comment">//大轮槽数</span>
    <span class="hljs-keyword">int</span> size2 = <span class="hljs-number">5</span>;
    <span class="hljs-comment">//小轮，数组，每个元素是一个链表</span>
    LinkedList&lt;RoundTask&gt;[] t1 = <span class="hljs-keyword">new</span> LinkedList[size1];
    <span class="hljs-comment">//大轮</span>
    LinkedList&lt;RoundTask&gt;[] t2 = <span class="hljs-keyword">new</span> LinkedList[size2];
    <span class="hljs-comment">//小轮计数器，指针跳动的格数，每秒加1</span>
    <span class="hljs-keyword">final</span> AtomicInteger flag1 = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);
    <span class="hljs-comment">//大轮计数器，指针跳动个格数，即每10s加1</span>
    <span class="hljs-keyword">final</span> AtomicInteger flag2 = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);
    <span class="hljs-comment">//调度器，拖动指针跳动</span>
    ScheduledExecutorService service = Executors.newScheduledThreadPool(<span class="hljs-number">2</span>);

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RoundDemo</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-comment">//初始化时间轮</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size1; i++) &#123;
            t1[i] = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();
        &#125;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size2; i++) &#123;
            t2[i] = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();
        &#125;
    &#125;

    <span class="hljs-comment">//打印时间轮的结构，数组+链表</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;t1:&quot;</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; t1.length; i++) &#123;
            System.out.println(t1[i]);
        &#125;
        System.out.println(<span class="hljs-string">&quot;t2:&quot;</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; t2.length; i++) &#123;
            System.out.println(t2[i]);
        &#125;
    &#125;

    <span class="hljs-comment">//添加任务到时间轮</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(RoundTask task)</span> </span>&#123;
        <span class="hljs-keyword">int</span> delay = task.delay;
        <span class="hljs-keyword">if</span> (delay &lt; size1) &#123; <span class="hljs-comment">//10以内的，在小轮 t1[delay].addLast(task);</span>
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-comment">//超过小轮的放入大轮，槽除以小轮的长度</span>
            t2[delay / size1].addLast(task);
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">startT1</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-comment">//每秒执行一次，推动时间轮旋转，取到任务立马执行</span>
        service.scheduleAtFixedRate(<span class="hljs-keyword">new</span> Runnable() &#123;
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
                <span class="hljs-keyword">int</span> point = flag1.getAndIncrement() % size1;
                System.out.println(<span class="hljs-string">&quot;t1 ‐‐‐‐‐&gt; slot &quot;</span> + point);
                LinkedList&lt;RoundTask&gt; list = t1[point];
                <span class="hljs-keyword">if</span> (!list.isEmpty()) &#123;
                    <span class="hljs-comment">//如果当前槽内有任务，取出来，依次执行，执行完移除</span>
                    <span class="hljs-keyword">while</span> (list.size() != <span class="hljs-number">0</span>) &#123;
                        list.getFirst().run();
                        list.removeFirst();
                    &#125;
                &#125;
            &#125;
        &#125;, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">startT2</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-comment">//每10秒执行一次，推动时间轮旋转，取到任务下方到t1</span>
        service.scheduleAtFixedRate(<span class="hljs-keyword">new</span> Runnable() &#123;
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
                <span class="hljs-keyword">int</span> point = flag2.getAndIncrement() % size2;
                System.out.println(<span class="hljs-string">&quot;t2 =====&gt; slot &quot;</span> + point);
                LinkedList&lt;RoundTask&gt; list = t2[point];
                <span class="hljs-keyword">if</span> (!list.isEmpty()) &#123;
                    <span class="hljs-comment">//如果当前槽内有任务，取出，放到定义的小轮</span>
                    <span class="hljs-keyword">while</span> (list.size() != <span class="hljs-number">0</span>) &#123;
                        RoundTask task = list.getFirst();
                        <span class="hljs-comment">//放入小轮哪个槽呢？小轮的槽按10取余数 </span>
                        t1[task.delay % size1].addLast(task);
                        <span class="hljs-comment">//从大轮中移除</span>
                        list.removeFirst();
                    &#125;
                &#125;
            &#125;
        &#125;, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>, TimeUnit.SECONDS);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        RoundDemo roundDemo = <span class="hljs-keyword">new</span> RoundDemo();
        <span class="hljs-comment">//生成100个任务，每个任务的延迟时间随机 </span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;
            roundDemo.add(<span class="hljs-keyword">new</span> RoundTask(i, <span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">50</span>)));
        &#125;
        <span class="hljs-comment">//打印，查看时间轮任务布局 </span>
        roundDemo.print();
        <span class="hljs-comment">//启动大轮</span>
        roundDemo.startT2();
        <span class="hljs-comment">//小轮启动</span>
        roundDemo.startT1();
    &#125;
&#125;</code></pre>

<h5 id="结果分析-11"><a href="#结果分析-11" class="headerlink" title="结果分析"></a>结果分析</h5><pre><code class="hljs routeros">Connected <span class="hljs-keyword">to</span> the target VM, address: <span class="hljs-string">&#x27;127.0.0.1:50971&#x27;</span>, transport: <span class="hljs-string">&#x27;socket&#x27;</span>
<span class="hljs-attribute">1598005699</span>=ok:&#123;<span class="hljs-attribute">1598005697</span>=0, <span class="hljs-attribute">1598005698</span>=0, <span class="hljs-attribute">1598005699</span>=1&#125;
<span class="hljs-attribute">1598005699</span>=ok:&#123;<span class="hljs-attribute">1598005697</span>=0, <span class="hljs-attribute">1598005698</span>=0, <span class="hljs-attribute">1598005699</span>=2&#125;
<span class="hljs-keyword">step</span>:1598005700:&#123;<span class="hljs-attribute">1598005698</span>=0, <span class="hljs-attribute">1598005699</span>=2, <span class="hljs-attribute">1598005700</span>=0&#125;
<span class="hljs-attribute">1598005700</span>=ok:&#123;<span class="hljs-attribute">1598005698</span>=0, <span class="hljs-attribute">1598005699</span>=2, <span class="hljs-attribute">1598005700</span>=1&#125;
<span class="hljs-attribute">1598005700</span>=ok:&#123;<span class="hljs-attribute">1598005698</span>=0, <span class="hljs-attribute">1598005699</span>=2, <span class="hljs-attribute">1598005700</span>=2&#125;
<span class="hljs-attribute">1598005700</span>=ok:&#123;<span class="hljs-attribute">1598005698</span>=0, <span class="hljs-attribute">1598005699</span>=2, <span class="hljs-attribute">1598005700</span>=3&#125;
<span class="hljs-keyword">step</span>:1598005701:&#123;<span class="hljs-attribute">1598005699</span>=2, <span class="hljs-attribute">1598005700</span>=3, <span class="hljs-attribute">1598005701</span>=0&#125;
<span class="hljs-attribute">1598005701</span>=reject:&#123;<span class="hljs-attribute">1598005699</span>=2, <span class="hljs-attribute">1598005700</span>=3, <span class="hljs-attribute">1598005701</span>=0&#125;
<span class="hljs-attribute">1598005701</span>=reject:&#123;<span class="hljs-attribute">1598005699</span>=2, <span class="hljs-attribute">1598005700</span>=3, <span class="hljs-attribute">1598005701</span>=0&#125;
<span class="hljs-attribute">1598005701</span>=reject:&#123;<span class="hljs-attribute">1598005699</span>=2, <span class="hljs-attribute">1598005700</span>=3, <span class="hljs-attribute">1598005701</span>=0&#125;
<span class="hljs-keyword">step</span>:1598005702:&#123;<span class="hljs-attribute">1598005700</span>=3, <span class="hljs-attribute">1598005701</span>=0, <span class="hljs-attribute">1598005702</span>=0&#125;
<span class="hljs-attribute">1598005702</span>=ok:&#123;<span class="hljs-attribute">1598005700</span>=3, <span class="hljs-attribute">1598005701</span>=0, <span class="hljs-attribute">1598005702</span>=1&#125;
<span class="hljs-attribute">1598005702</span>=ok:&#123;<span class="hljs-attribute">1598005700</span>=3, <span class="hljs-attribute">1598005701</span>=0, <span class="hljs-attribute">1598005702</span>=2&#125;
<span class="hljs-keyword">step</span>:1598005703:&#123;<span class="hljs-attribute">1598005701</span>=0, <span class="hljs-attribute">1598005702</span>=2, <span class="hljs-attribute">1598005703</span>=0&#125;
<span class="hljs-keyword">step</span>:1598005704:&#123;<span class="hljs-attribute">1598005702</span>=2, <span class="hljs-attribute">1598005703</span>=0, <span class="hljs-attribute">1598005704</span>=0&#125;
<span class="hljs-keyword">step</span>:1598005705:&#123;<span class="hljs-attribute">1598005703</span>=0, <span class="hljs-attribute">1598005704</span>=0, <span class="hljs-attribute">1598005705</span>=0&#125;
‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
<span class="hljs-attribute">1598005705</span>=ok:&#123;<span class="hljs-attribute">1598005703</span>=0, <span class="hljs-attribute">1598005704</span>=0, <span class="hljs-attribute">1598005705</span>=1&#125;
<span class="hljs-attribute">1598005705</span>=ok:&#123;<span class="hljs-attribute">1598005703</span>=0, <span class="hljs-attribute">1598005704</span>=0, <span class="hljs-attribute">1598005705</span>=2&#125;
<span class="hljs-attribute">1598005705</span>=ok:&#123;<span class="hljs-attribute">1598005703</span>=0, <span class="hljs-attribute">1598005704</span>=0, <span class="hljs-attribute">1598005705</span>=3&#125;
<span class="hljs-attribute">1598005705</span>=ok:&#123;<span class="hljs-attribute">1598005703</span>=0, <span class="hljs-attribute">1598005704</span>=0, <span class="hljs-attribute">1598005705</span>=4&#125;
<span class="hljs-attribute">1598005705</span>=ok:&#123;<span class="hljs-attribute">1598005703</span>=0, <span class="hljs-attribute">1598005704</span>=0, <span class="hljs-attribute">1598005705</span>=5&#125;
<span class="hljs-attribute">1598005705</span>=reject:&#123;<span class="hljs-attribute">1598005703</span>=0, <span class="hljs-attribute">1598005704</span>=0, <span class="hljs-attribute">1598005705</span>=5&#125;
<span class="hljs-attribute">1598005705</span>=reject:&#123;<span class="hljs-attribute">1598005703</span>=0, <span class="hljs-attribute">1598005704</span>=0, <span class="hljs-attribute">1598005705</span>=5&#125;
<span class="hljs-attribute">1598005705</span>=reject:&#123;<span class="hljs-attribute">1598005703</span>=0, <span class="hljs-attribute">1598005704</span>=0, <span class="hljs-attribute">1598005705</span>=5&#125;
<span class="hljs-attribute">1598005705</span>=reject:&#123;<span class="hljs-attribute">1598005703</span>=0, <span class="hljs-attribute">1598005704</span>=0, <span class="hljs-attribute">1598005705</span>=5&#125;
<span class="hljs-attribute">1598005705</span>=reject:&#123;<span class="hljs-attribute">1598005703</span>=0, <span class="hljs-attribute">1598005704</span>=0, <span class="hljs-attribute">1598005705</span>=5&#125;
<span class="hljs-keyword">step</span>:1598005709:&#123;<span class="hljs-attribute">1598005704</span>=0, <span class="hljs-attribute">1598005705</span>=5, <span class="hljs-attribute">1598005709</span>=0&#125;
<span class="hljs-keyword">step</span>:1598005709:&#123;<span class="hljs-attribute">1598005705</span>=5, <span class="hljs-attribute">1598005709</span>=0&#125;
<span class="hljs-keyword">step</span>:1598005709:&#123;<span class="hljs-attribute">1598005709</span>=0&#125;
<span class="hljs-keyword">step</span>:1598005709:&#123;&#125;
<span class="hljs-keyword">step</span>:1598005710:&#123;<span class="hljs-attribute">1598005710</span>=0&#125;
<span class="hljs-keyword">step</span>:1598005711:&#123;<span class="hljs-attribute">1598005710</span>=0, <span class="hljs-attribute">1598005711</span>=0&#125;
<span class="hljs-keyword">step</span>:1598005712:&#123;<span class="hljs-attribute">1598005710</span>=0, <span class="hljs-attribute">1598005711</span>=0, <span class="hljs-attribute">1598005712</span>=0&#125;</code></pre>

<p>输出结果严格按delay顺序执行，而不管index是何时被提交的 </p>
<p>t1为小轮，10个槽，每个1s，10s一轮回 </p>
<p>t2为大轮，5个槽，每个10s，50s一轮回 </p>
<p>t1循环到每个槽时，打印槽内的任务数据，如 t1–&gt;slot9 ， 打印了3个9s执行的数据 </p>
<p>t2循环到每个槽时，将槽内的任务delay时间取余10后，放入对应的t1槽中，如 t2==&gt;slot1 </p>
<p>那么t1旋转对应的圈数后，可以取到t2下放过来的任务并执行，如10,11…. </p>
<h3 id="负载均衡算法与应用"><a href="#负载均衡算法与应用" class="headerlink" title="负载均衡算法与应用"></a>负载均衡算法与应用</h3><p>负载均衡，英文名称为Load Balance，其含义就是指将负载（工作任务）进行平衡、分摊到多个操作单元上进行运行，例如FTP服务器、Web服务器、企业核心应用服务器和其它主要任务服务器等，从而协同完成工作任务。既然涉及到多个机器，就涉及到任务如何分发，这就是负载均衡算法问题。 </p>
<h4 id="轮询（RoundRobin）"><a href="#轮询（RoundRobin）" class="headerlink" title="轮询（RoundRobin）"></a>轮询（RoundRobin）</h4><h5 id="概述-10"><a href="#概述-10" class="headerlink" title="概述"></a>概述</h5><p>轮询即排好队，一个接一个。前面调度算法中用到的时间片轮转，就是一种典型的轮询。但是前面使用数组和下标轮询实现。这里尝试手动写一个双向链表形式实现服务器列表的请求轮询算法。 </p>
<h5 id="实现-12"><a href="#实现-12" class="headerlink" title="实现"></a>实现</h5><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.balance;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RR</span> </span>&#123;
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Server</span> </span>&#123;
        Server prev;
        Server next;
        String name;

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Server</span><span class="hljs-params">(String name)</span> </span>&#123;
            <span class="hljs-keyword">this</span>.name = name;
        &#125;
    &#125;

    <span class="hljs-comment">//当前服务节点</span>
    Server current;

    <span class="hljs-comment">//初始化轮询类，多个服务器ip用逗号隔开</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RR</span><span class="hljs-params">(String serverName)</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;init server list : &quot;</span> + serverName);
        String[] names = serverName.split(<span class="hljs-string">&quot;,&quot;</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; names.length; i++) &#123;
            Server server = <span class="hljs-keyword">new</span> Server(names[i]);
            <span class="hljs-keyword">if</span> (current == <span class="hljs-keyword">null</span>) &#123;
                <span class="hljs-comment">//如果当前服务器为空，说明是第一台机器，current就指向新创建的server </span>
                <span class="hljs-keyword">this</span>.current = server;
                <span class="hljs-comment">//同时，server的前后均指向自己。 </span>
                current.prev = current;
                current.next = current;
            &#125; <span class="hljs-keyword">else</span> &#123;
                <span class="hljs-comment">//否则说明已经有机器了，按新加处理。</span>
                addServer(names[i]);
            &#125;
        &#125;
    &#125;

    <span class="hljs-comment">//添加机器</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addServer</span><span class="hljs-params">(String serverName)</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;add server : &quot;</span> + serverName);
        Server server = <span class="hljs-keyword">new</span> Server(serverName);
        Server next = <span class="hljs-keyword">this</span>.current.next;
        <span class="hljs-comment">//在当前节点后插入新节点</span>
        <span class="hljs-keyword">this</span>.current.next = server;
        server.prev = <span class="hljs-keyword">this</span>.current;
        <span class="hljs-comment">//修改下一节点的prev指针 </span>
        server.next = next;
        next.prev = server;
    &#125;

    <span class="hljs-comment">//将当前服务器移除，同时修改前后节点的指针，让其直接关联 </span>
    <span class="hljs-comment">// 移除的current会被回收器回收掉</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;remove current = &quot;</span> + current.name);
        <span class="hljs-keyword">this</span>.current.prev.next = <span class="hljs-keyword">this</span>.current.next;
        <span class="hljs-keyword">this</span>.current.next.prev = <span class="hljs-keyword">this</span>.current.prev;
        <span class="hljs-keyword">this</span>.current = current.next;
    &#125;

    <span class="hljs-comment">//请求。由当前节点处理即可 </span>
    <span class="hljs-comment">// 注意：处理完成后，current指针后移 </span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-keyword">this</span>.current.name);
        <span class="hljs-keyword">this</span>.current = current.next;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
        <span class="hljs-comment">//初始化两台机器</span>
        RR rr = <span class="hljs-keyword">new</span> RR(<span class="hljs-string">&quot;192.168.0.1,192.168.0.2&quot;</span>);
        <span class="hljs-comment">//启动一个额外线程，模拟不停的请求 </span>
        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
                <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;
                    <span class="hljs-keyword">try</span> &#123;
                        Thread.sleep(<span class="hljs-number">500</span>);
                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                        e.printStackTrace();
                    &#125;
                    rr.request();
                &#125;
            &#125;
        &#125;).start();
        <span class="hljs-comment">//3s后，3号机器加入清单 </span>
        Thread.currentThread().sleep(<span class="hljs-number">3000</span>);
        rr.addServer(<span class="hljs-string">&quot;192.168.0.3&quot;</span>);
        <span class="hljs-comment">//3s后，当前服务节点被移除 </span>
        Thread.currentThread().sleep(<span class="hljs-number">3000</span>);
        rr.remove();
    &#125;
&#125;</code></pre>

<h5 id="结果分析-12"><a href="#结果分析-12" class="headerlink" title="结果分析"></a>结果分析</h5><pre><code class="hljs accesslog">init server list : <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>,<span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">2</span>
add server : <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">2</span>
<span class="hljs-number">192.168.0.1</span>
<span class="hljs-number">192.168.0.2</span>
<span class="hljs-number">192.168.0.1</span>
<span class="hljs-number">192.168.0.2</span>
<span class="hljs-number">192.168.0.1</span>
add server : <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">3</span>
<span class="hljs-number">192.168.0.2</span>
<span class="hljs-number">192.168.0.3</span>
<span class="hljs-number">192.168.0.1</span>
<span class="hljs-number">192.168.0.2</span>
<span class="hljs-number">192.168.0.3</span>
<span class="hljs-number">192.168.0.1</span>
remove current = <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">2</span>
<span class="hljs-number">192.168.0.3</span>
<span class="hljs-number">192.168.0.1</span></code></pre>

<ul>
<li><p>初始化后，只有1，2，两者轮询 </p>
</li>
<li><p>3加入后，1，2，3，三者轮询 </p>
</li>
<li><p>移除2后，只剩1和3轮询</p>
</li>
</ul>
<h5 id="优缺点-6"><a href="#优缺点-6" class="headerlink" title="优缺点"></a>优缺点</h5><ul>
<li><p>实现简单，机器列表可以自由加减，且时间复杂度为o(1) </p>
</li>
<li><p>无法针对节点做偏向性定制，节点处理能力的强弱无法区分对待</p>
</li>
</ul>
<h4 id="随机（Random）"><a href="#随机（Random）" class="headerlink" title="随机（Random）"></a>随机（Random）</h4><h5 id="概述-11"><a href="#概述-11" class="headerlink" title="概述"></a>概述</h5><p>从可服务的列表中随机取一个提供响应。随机存取的场景下，适合使用数组更高效的实现下标随机读取。 </p>
<h5 id="实现-13"><a href="#实现-13" class="headerlink" title="实现"></a>实现</h5><p>定义一个数组，在数组长度内取随机数，作为其下标即可。非常简单</p>
<pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.balance;

<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.Random;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rand</span> </span>&#123;
    ArrayList&lt;String&gt; ips;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Rand</span><span class="hljs-params">(String nodeNames)</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;init list : &quot;</span> + nodeNames);
        String[] nodes = nodeNames.split(<span class="hljs-string">&quot;,&quot;</span>);
        <span class="hljs-comment">//初始化服务器列表，长度取机器数</span>
        ips = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(nodes.length);
        <span class="hljs-keyword">for</span> (String node : nodes) &#123;
            ips.add(node);
        &#125;
    &#125;

    <span class="hljs-comment">//请求</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-comment">//下标，随机数，注意因子</span>
        <span class="hljs-keyword">int</span> i = <span class="hljs-keyword">new</span> Random().nextInt(ips.size());
        System.out.println(ips.get(i));
    &#125;

    <span class="hljs-comment">//添加节点，注意，添加节点会造成内部数组扩容</span>
    <span class="hljs-comment">// 可以根据实际情况初始化时预留一定空间</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addnode</span><span class="hljs-params">(String nodeName)</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;add node : &quot;</span> + nodeName);
        ips.add(nodeName);
    &#125;

    <span class="hljs-comment">//移除</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(String nodeName)</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;remove node : &quot;</span> + nodeName);
        ips.remove(nodeName);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
        Rand rd = <span class="hljs-keyword">new</span> Rand(<span class="hljs-string">&quot;192.168.0.1,192.168.0.2&quot;</span>);
        <span class="hljs-comment">//启动一个额外线程，模拟不停的请求</span>
        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
                <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;
                    <span class="hljs-keyword">try</span> &#123;
                        Thread.sleep(<span class="hljs-number">500</span>);
                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                        e.printStackTrace();
                    &#125;
                    rd.request();
                &#125;
            &#125;
        &#125;).start();
        <span class="hljs-comment">//3s后，3号机器加入清单</span>
        Thread.currentThread().sleep(<span class="hljs-number">3000</span>);
        rd.addnode(<span class="hljs-string">&quot;192.168.0.3&quot;</span>);
        <span class="hljs-comment">//3s后，当前服务节点被移除</span>
        Thread.currentThread().sleep(<span class="hljs-number">3000</span>);
        rd.remove(<span class="hljs-string">&quot;192.168.0.2&quot;</span>);
    &#125;
&#125;</code></pre>

<h5 id="结果分析-13"><a href="#结果分析-13" class="headerlink" title="结果分析"></a>结果分析</h5><pre><code class="hljs accesslog">init list : <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>,<span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">2</span>
<span class="hljs-number">192.168.0.2</span>
<span class="hljs-number">192.168.0.1</span>
<span class="hljs-number">192.168.0.1</span>
<span class="hljs-number">192.168.0.2</span>
<span class="hljs-number">192.168.0.1</span>
add node : <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">3</span>
<span class="hljs-number">192.168.0.3</span>
<span class="hljs-number">192.168.0.2</span>
<span class="hljs-number">192.168.0.2</span>
<span class="hljs-number">192.168.0.2</span>
<span class="hljs-number">192.168.0.1</span>
<span class="hljs-number">192.168.0.1</span>
remove node : <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">2</span>
<span class="hljs-number">192.168.0.3</span>
<span class="hljs-number">192.168.0.3</span>
<span class="hljs-number">192.168.0.1</span>
<span class="hljs-number">192.168.0.1</span>
<span class="hljs-number">192.168.0.3</span></code></pre>

<ul>
<li><p>初始化为1，2，两者不按顺序轮询，而是随机出现 </p>
</li>
<li><p>3加入服务节点列表 </p>
</li>
<li><p>移除2后，只剩1，3，依然是两者随机，无序 </p>
</li>
</ul>
<h4 id="源地址哈希（Hash）"><a href="#源地址哈希（Hash）" class="headerlink" title="源地址哈希（Hash）"></a>源地址哈希（Hash）</h4><h5 id="概述-12"><a href="#概述-12" class="headerlink" title="概述"></a>概述</h5><p>对当前访问的ip地址做一个hash值，相同的key被路由到同一台机器去。场景常见于分布式集群环境下，用户登录时的请求路由和会话保持。 </p>
<h5 id="实现-14"><a href="#实现-14" class="headerlink" title="实现"></a>实现</h5><p>使用HashMap可以实现请求值到对应节点的服务，其查找时的时间复杂度为o(1)。固定一种算法，将请求映射到key上即可。举例，将请求的来源ip末尾，按机器数取余作为key：</p>
<pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.balance;

<span class="hljs-keyword">import</span> java.util.ArrayList;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hash</span> </span>&#123;
    ArrayList&lt;String&gt; ips;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Hash</span><span class="hljs-params">(String nodeNames)</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;init list : &quot;</span> + nodeNames);
        String[] nodes = nodeNames.split(<span class="hljs-string">&quot;,&quot;</span>);
        <span class="hljs-comment">//初始化服务器列表，长度取机器数</span>
        ips = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(nodes.length);
        <span class="hljs-keyword">for</span> (String node : nodes) &#123;
            ips.add(node);
        &#125;
    &#125;

    <span class="hljs-comment">//添加节点，注意，添加节点会造成内部Hash重排，思考为什么呢？？？ </span>
    <span class="hljs-comment">// 这是个问题！在一致性hash中会进入详细探讨</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addnode</span><span class="hljs-params">(String nodeName)</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;add node : &quot;</span> + nodeName);
        ips.add(nodeName);
    &#125;

    <span class="hljs-comment">//移除</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(String nodeName)</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;remove node : &quot;</span> + nodeName);
        ips.remove(nodeName);
    &#125;

    <span class="hljs-comment">//映射到key的算法，这里取余数做下标 </span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(String ip)</span> </span>&#123;
        <span class="hljs-keyword">int</span> last = Integer.valueOf(ip.substring(ip.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>) + <span class="hljs-number">1</span>, ip.length()));
        <span class="hljs-keyword">return</span> last % ips.size();
    &#125;

    <span class="hljs-comment">//请求 </span>
    <span class="hljs-comment">// 注意，这里和来访ip是有关系的，采用一个参数，表示当前的来访ip </span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">(String ip)</span> </span>&#123;
        <span class="hljs-comment">//下标</span>
        <span class="hljs-keyword">int</span> i = hash(ip);
        System.out.println(ip + <span class="hljs-string">&quot;‐‐&gt;&quot;</span> + ips.get(i));
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        Hash hash = <span class="hljs-keyword">new</span> Hash(<span class="hljs-string">&quot;192.168.0.1,192.168.0.2&quot;</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;
            <span class="hljs-comment">//模拟请求的来源ip</span>
            String ip = <span class="hljs-string">&quot;192.168.1.&quot;</span> + i;
            hash.request(ip);
        &#125;
        hash.addnode(<span class="hljs-string">&quot;192.168.0.3&quot;</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;
            <span class="hljs-comment">//模拟请求的来源ip </span>
            String ip = <span class="hljs-string">&quot;192.168.1.&quot;</span> + i;
            hash.request(ip);
        &#125;
    &#125;
&#125;</code></pre>

<h5 id="结果分析-14"><a href="#结果分析-14" class="headerlink" title="结果分析"></a>结果分析</h5><pre><code class="hljs accesslog">init list : <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>,<span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">2</span>
<span class="hljs-number">192.168.1.1</span>‐‐&gt;<span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">2</span>
<span class="hljs-number">192.168.1.2</span>‐‐&gt;<span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>
<span class="hljs-number">192.168.1.3</span>‐‐&gt;<span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">2</span>
<span class="hljs-number">192.168.1.4</span>‐‐&gt;<span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>
<span class="hljs-number">192.168.1.5</span>‐‐&gt;<span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">2</span>
<span class="hljs-number">192.168.1.6</span>‐‐&gt;<span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>
<span class="hljs-number">192.168.1.7</span>‐‐&gt;<span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">2</span>
<span class="hljs-number">192.168.1.8</span>‐‐&gt;<span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>
<span class="hljs-number">192.168.1.9</span>‐‐&gt;<span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">2</span>
add node : <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">3</span>
<span class="hljs-number">192.168.1.1</span>‐‐&gt;<span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">2</span>
<span class="hljs-number">192.168.1.2</span>‐‐&gt;<span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">3</span>
<span class="hljs-number">192.168.1.3</span>‐‐&gt;<span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>
<span class="hljs-number">192.168.1.4</span>‐‐&gt;<span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">2</span>
<span class="hljs-number">192.168.1.5</span>‐‐&gt;<span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">3</span>
<span class="hljs-number">192.168.1.6</span>‐‐&gt;<span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>
<span class="hljs-number">192.168.1.7</span>‐‐&gt;<span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">2</span>
<span class="hljs-number">192.168.1.8</span>‐‐&gt;<span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">3</span>
<span class="hljs-number">192.168.1.9</span>‐‐&gt;<span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span></code></pre>

<ul>
<li><p>初始化后，只有1，2，下标为末尾ip取余数，多次运行，响应的机器不变，实现了会话保持 </p>
</li>
<li><p>3加入后，重新hash，机器分布发生变化 </p>
</li>
<li><p>2被移除后，原来hash到2的请求被重新定位给3响应 </p>
</li>
</ul>
<h4 id="加权轮询（WRR）"><a href="#加权轮询（WRR）" class="headerlink" title="加权轮询（WRR）"></a>加权轮询（WRR）</h4><h5 id="概述-13"><a href="#概述-13" class="headerlink" title="概述"></a>概述</h5><p>WeightRoundRobin，轮询只是机械的旋转，加权轮询弥补了所有机器一视同仁的缺点。在轮询的基础上，初始化时，机器携带一个比重。 </p>
<h5 id="实现-15"><a href="#实现-15" class="headerlink" title="实现"></a>实现</h5><p>维护一个链表，每个机器根据权重不同，占据的个数不同。轮询时权重大的，个数多，自然取到的次数变大。举个例子：a，b，c 三台机器，权重分别为4，2，1，排位后会是a,a,a,a,b,b,c，每次请求时，从列表中依次取节点，下次请求再取下一个。到末尾时，再从头开始。 </p>
<p>但是这样有一个问题：机器分布不够均匀，扎堆出现了…. </p>
<p>解决：为解决机器平滑出现的问题，nginx的源码中使用了一种平滑的加权轮询的算法，规则如下：</p>
<ul>
<li><p>每个节点两个权重，weight和currentWeight，weight永远不变是配置时的值，current不停变化</p>
</li>
<li><p>变化规律如下：选择前所有current+=weight，选current最大的响应，响应后让它的current-=total</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>次数</th>
<th>响应前</th>
<th>被选中</th>
<th>响应后</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>4，2，1</td>
<td>a</td>
<td>-3，2，1</td>
</tr>
<tr>
<td>2</td>
<td>1，4，2</td>
<td>b</td>
<td>1，-3，2</td>
</tr>
<tr>
<td>3</td>
<td>5，-1，3</td>
<td>a</td>
<td>-2，-1，3</td>
</tr>
<tr>
<td>4</td>
<td>2，1，4</td>
<td>c</td>
<td>2，1，-3</td>
</tr>
<tr>
<td>5</td>
<td>6，3，-2</td>
<td>a</td>
<td>-1，3，-2</td>
</tr>
<tr>
<td>6</td>
<td>3，5，-1</td>
<td>b</td>
<td>3，-2，-1</td>
</tr>
<tr>
<td>7</td>
<td>7，0，0</td>
<td>a</td>
<td>0，0，0</td>
</tr>
</tbody></table>
<p>统计：a=4，b=2，c=1 且分布平滑均衡</p>
<pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.balance;

<span class="hljs-keyword">import</span> java.util.ArrayList;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WRR</span> </span>&#123;
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;
        <span class="hljs-keyword">int</span> weight, currentWeight;
        String name;

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> weight)</span> </span>&#123;
            <span class="hljs-keyword">this</span>.name = name;
            <span class="hljs-keyword">this</span>.weight = weight;
            <span class="hljs-keyword">this</span>.currentWeight = <span class="hljs-number">0</span>;
        &#125;

        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;
            <span class="hljs-keyword">return</span> String.valueOf(currentWeight);
        &#125;
    &#125;

    <span class="hljs-comment">//所有节点的列表</span>
    ArrayList&lt;Node&gt; list;
    <span class="hljs-comment">//总权重</span>
    <span class="hljs-keyword">int</span> total;

    <span class="hljs-comment">//初始化节点列表，格式：a#4,b#2,c#1</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WRR</span><span class="hljs-params">(String nodes)</span> </span>&#123;
        String[] ns = nodes.split(<span class="hljs-string">&quot;,&quot;</span>);
        list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(ns.length);
        <span class="hljs-keyword">for</span> (String n : ns) &#123;
            String[] n1 = n.split(<span class="hljs-string">&quot;#&quot;</span>);
            <span class="hljs-keyword">int</span> weight = Integer.valueOf(n1[<span class="hljs-number">1</span>]);
            list.add(<span class="hljs-keyword">new</span> Node(n1[<span class="hljs-number">0</span>], weight));
            total += weight;
        &#125;
    &#125;

    <span class="hljs-comment">//获取当前节点</span>
    <span class="hljs-function">Node <span class="hljs-title">getCurrent</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-comment">//执行前，current加权重 </span>
        <span class="hljs-keyword">for</span> (Node node : list) &#123;
            node.currentWeight += node.weight;
        &#125;
        <span class="hljs-comment">//遍历，取权重最高的返回</span>
        Node current = list.get(<span class="hljs-number">0</span>);
        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (Node node : list) &#123;
            <span class="hljs-keyword">if</span> (node.currentWeight &gt; i) &#123;
                i = node.currentWeight;
                current = node;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> current;
    &#125;

    <span class="hljs-comment">//响应 </span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-comment">//获取当前节点 </span>
        Node node = <span class="hljs-keyword">this</span>.getCurrent();
        <span class="hljs-comment">//第一列，执行前的current</span>
        System.out.print(list.toString() + <span class="hljs-string">&quot;‐‐‐&quot;</span>);
        <span class="hljs-comment">//第二列，选中的节点开始响应</span>
        System.out.print(node.name + <span class="hljs-string">&quot;‐‐‐&quot;</span>);
        <span class="hljs-comment">//响应后，current减掉total</span>
        node.currentWeight -= total;
        <span class="hljs-comment">//第三列，执行后的current</span>
        System.out.println(list);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        WRR wrr = <span class="hljs-keyword">new</span> WRR(<span class="hljs-string">&quot;a#4,b#2,c#1&quot;</span>);
        <span class="hljs-comment">//7次执行请求，看结果</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">7</span>; i++) &#123;
            wrr.request();
        &#125;
    &#125;
&#125;</code></pre>

<h5 id="结果分析-15"><a href="#结果分析-15" class="headerlink" title="结果分析"></a>结果分析</h5><pre><code class="hljs java">[<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]‐‐‐a‐‐‐[-<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]
[<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>]‐‐‐b‐‐‐[<span class="hljs-number">1</span>, -<span class="hljs-number">3</span>, <span class="hljs-number">2</span>]
[<span class="hljs-number">5</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">3</span>]‐‐‐a‐‐‐[-<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">3</span>]
[<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>]‐‐‐c‐‐‐[<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">3</span>]
[<span class="hljs-number">6</span>, <span class="hljs-number">3</span>, -<span class="hljs-number">2</span>]‐‐‐a‐‐‐[-<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, -<span class="hljs-number">2</span>]
[<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, -<span class="hljs-number">1</span>]‐‐‐b‐‐‐[<span class="hljs-number">3</span>, -<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>]
[<span class="hljs-number">7</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]‐‐‐a‐‐‐[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]</code></pre>

<h4 id="加权随机（WR）"><a href="#加权随机（WR）" class="headerlink" title="加权随机（WR）"></a>加权随机（WR）</h4><h5 id="概述-14"><a href="#概述-14" class="headerlink" title="概述"></a>概述</h5><p>WeightRandom，机器随机被筛选，但是做一组加权值，根据权值不同，选中的概率不同。在这个概念上，可以认为随机是一种等权值的特殊情况。</p>
<h5 id="实现-16"><a href="#实现-16" class="headerlink" title="实现"></a>实现</h5><p>设计思路依然相同，根据权值大小，生成不同数量的节点，节点排队后，随机获取。这里的数据结构主要涉及到随机的读取，所以优选为数组。 </p>
<p>与随机相同的是，同样为数组随机筛选，不同在于，随机只是每台机器1个，加权后变为多个。</p>
<pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.balance;

<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.Random;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WR</span> </span>&#123;
    <span class="hljs-comment">//所有节点的列表 </span>
    ArrayList&lt;String&gt; list;

    <span class="hljs-comment">//初始化节点列表</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WR</span><span class="hljs-params">(String nodes)</span> </span>&#123;
        String[] ns = nodes.split(<span class="hljs-string">&quot;,&quot;</span>);
        list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        <span class="hljs-keyword">for</span> (String n : ns) &#123;
            String[] n1 = n.split(<span class="hljs-string">&quot;#&quot;</span>);
            <span class="hljs-keyword">int</span> weight = Integer.valueOf(n1[<span class="hljs-number">1</span>]);
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; weight; i++) &#123;
                list.add(n1[<span class="hljs-number">0</span>]);
            &#125;
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-comment">//下标，随机数，注意因子</span>
        <span class="hljs-keyword">int</span> i = <span class="hljs-keyword">new</span> Random().nextInt(list.size());
        System.out.println(list.get(i));
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        WR wr = <span class="hljs-keyword">new</span> WR(<span class="hljs-string">&quot;a#2,b#1&quot;</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;
            wr.request();
        &#125;
    &#125;
&#125;</code></pre>

<h5 id="结果分析-16"><a href="#结果分析-16" class="headerlink" title="结果分析"></a>结果分析</h5><pre><code class="hljs stylus">a
a
b
a
a
a
b
a
a</code></pre>

<ul>
<li><p>运行9次，a，b交替出现，a=6,b=3,满足2:1比例</p>
</li>
<li><p>注意！既然是随机，就存在随机性，不见得每次执行都会严格比例。样本趋向无穷时，比例约准确</p>
</li>
</ul>
<h4 id="最小连接数（LC）"><a href="#最小连接数（LC）" class="headerlink" title="最小连接数（LC）"></a>最小连接数（LC）</h4><h5 id="概述-15"><a href="#概述-15" class="headerlink" title="概述"></a>概述</h5><p>LeastConnections，即统计当前机器的连接数，选最少的去响应新的请求。前面的算法是站在请求维度，而最小连接数是站在机器的维度。</p>
<h5 id="实现-17"><a href="#实现-17" class="headerlink" title="实现"></a>实现</h5><p>定义一个链接表记录机器的节点id和机器连接数量的计数器。内部采用最小堆做排序处理，响应时取堆顶节点即是最小连接数。</p>
<pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.balance;

<span class="hljs-keyword">import</span> java.util.Arrays;
<span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LC</span> </span>&#123;
    <span class="hljs-comment">//节点列表</span>
    Node[] nodes;

    <span class="hljs-comment">//初始化节点，创建堆 </span>
    <span class="hljs-comment">// 因为开始时各节点连接数都为0，所以直接填充数组即可</span>
    LC(String ns) &#123;
        String[] ns1 = ns.split(<span class="hljs-string">&quot;,&quot;</span>);
        nodes = <span class="hljs-keyword">new</span> Node[ns1.length + <span class="hljs-number">1</span>];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ns1.length; i++) &#123;
            nodes[i + <span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> Node(ns1[i]);
        &#125;
    &#125;

    <span class="hljs-comment">//节点下沉，与左右子节点比对，选里面最小的交换 </span>
    <span class="hljs-comment">// 目的是始终保持最小堆的顶点元素值最小 </span>
    <span class="hljs-comment">// i:要下沉的顶点序号 </span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;
        <span class="hljs-comment">//顶点序号遍历，只要到1半即可，时间复杂度为O(log2n) </span>
        <span class="hljs-keyword">while</span> (i &lt;&lt; <span class="hljs-number">1</span> &lt; nodes.length) &#123;
            <span class="hljs-comment">//左子，为何左移1位？回顾一下二叉树序号 </span>
            <span class="hljs-keyword">int</span> left = i &lt;&lt; <span class="hljs-number">1</span>;
            <span class="hljs-comment">//右子，左+1即可 </span>
            <span class="hljs-keyword">int</span> right = left + <span class="hljs-number">1</span>;
            <span class="hljs-comment">//标记，指向 本节点，左、右子节点里最小的，一开始取i自己 </span>
            <span class="hljs-keyword">int</span> flag = i;
            <span class="hljs-comment">//判断左子是否小于本节点</span>
            <span class="hljs-keyword">if</span> (nodes[left].get() &lt; nodes[i].get()) &#123;
                flag = left;
            &#125;
            <span class="hljs-comment">//判断右子</span>
            <span class="hljs-keyword">if</span> (right &lt; nodes.length &amp;&amp; nodes[flag].get() &gt; nodes[right].get()) &#123;
                flag = right;
            &#125;
            <span class="hljs-comment">//两者中最小的与本节点不相等，则交换</span>
            <span class="hljs-keyword">if</span> (flag != i) &#123;
                Node temp = nodes[i];
                nodes[i] = nodes[flag];
                nodes[flag] = temp;
                i = flag;
            &#125; <span class="hljs-keyword">else</span> &#123;
                <span class="hljs-comment">//否则相等，堆排序完成，退出循环即可</span>
                <span class="hljs-keyword">break</span>;
            &#125;
        &#125;
    &#125;

    <span class="hljs-comment">//请求。非常简单，直接取最小堆的堆顶元素就是连接数最少的机器</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐&quot;</span>);
        <span class="hljs-comment">//取堆顶元素响应请求</span>
        Node node = nodes[<span class="hljs-number">1</span>];
        System.out.println(node.name + <span class="hljs-string">&quot; accept&quot;</span>);
        <span class="hljs-comment">//连接数加1</span>
        node.inc();
        <span class="hljs-comment">//排序前的堆 </span>
        System.out.println(<span class="hljs-string">&quot;before:&quot;</span> + Arrays.toString(nodes));
        <span class="hljs-comment">//堆顶下沉</span>
        down(<span class="hljs-number">1</span>);
        <span class="hljs-comment">//排序后的堆 </span>
        System.out.println(<span class="hljs-string">&quot;after:&quot;</span> + Arrays.toString(nodes));
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-comment">//假设有7台机器</span>
        LC lc = <span class="hljs-keyword">new</span> LC(<span class="hljs-string">&quot;a,b,c,d,e,f,g&quot;</span>);
        <span class="hljs-comment">//模拟10个请求连接</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;
            lc.request();
        &#125;
    &#125;

    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;
        <span class="hljs-comment">//节点标识</span>
        String name;
        <span class="hljs-comment">// 计数器 </span>
        AtomicInteger count = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(String name)</span> </span>&#123;
            <span class="hljs-keyword">this</span>.name = name;
        &#125;

        <span class="hljs-comment">//计数器增加 </span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inc</span><span class="hljs-params">()</span> </span>&#123;
            count.getAndIncrement();
        &#125;

        <span class="hljs-comment">//获取连接数 </span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;
            <span class="hljs-keyword">return</span> count.get();
        &#125;

        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;
            <span class="hljs-keyword">return</span> name + <span class="hljs-string">&quot;=&quot;</span> + count;
        &#125;
    &#125;
&#125;</code></pre>

<h5 id="结果分析-17"><a href="#结果分析-17" class="headerlink" title="结果分析"></a>结果分析</h5><pre><code class="hljs routeros">‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
a accept
before:[<span class="hljs-literal">null</span>, <span class="hljs-attribute">a</span>=1, <span class="hljs-attribute">b</span>=0, <span class="hljs-attribute">c</span>=0, <span class="hljs-attribute">d</span>=0, <span class="hljs-attribute">e</span>=0, <span class="hljs-attribute">f</span>=0, <span class="hljs-attribute">g</span>=0]
after:[<span class="hljs-literal">null</span>, <span class="hljs-attribute">b</span>=0, <span class="hljs-attribute">d</span>=0, <span class="hljs-attribute">c</span>=0, <span class="hljs-attribute">a</span>=1, <span class="hljs-attribute">e</span>=0, <span class="hljs-attribute">f</span>=0, <span class="hljs-attribute">g</span>=0]
‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
b accept
before:[<span class="hljs-literal">null</span>, <span class="hljs-attribute">b</span>=1, <span class="hljs-attribute">d</span>=0, <span class="hljs-attribute">c</span>=0, <span class="hljs-attribute">a</span>=1, <span class="hljs-attribute">e</span>=0, <span class="hljs-attribute">f</span>=0, <span class="hljs-attribute">g</span>=0]
after:[<span class="hljs-literal">null</span>, <span class="hljs-attribute">d</span>=0, <span class="hljs-attribute">e</span>=0, <span class="hljs-attribute">c</span>=0, <span class="hljs-attribute">a</span>=1, <span class="hljs-attribute">b</span>=1, <span class="hljs-attribute">f</span>=0, <span class="hljs-attribute">g</span>=0]
‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
d accept
before:[<span class="hljs-literal">null</span>, <span class="hljs-attribute">d</span>=1, <span class="hljs-attribute">e</span>=0, <span class="hljs-attribute">c</span>=0, <span class="hljs-attribute">a</span>=1, <span class="hljs-attribute">b</span>=1, <span class="hljs-attribute">f</span>=0, <span class="hljs-attribute">g</span>=0]
after:[<span class="hljs-literal">null</span>, <span class="hljs-attribute">e</span>=0, <span class="hljs-attribute">d</span>=1, <span class="hljs-attribute">c</span>=0, <span class="hljs-attribute">a</span>=1, <span class="hljs-attribute">b</span>=1, <span class="hljs-attribute">f</span>=0, <span class="hljs-attribute">g</span>=0]
‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
e accept
before:[<span class="hljs-literal">null</span>, <span class="hljs-attribute">e</span>=1, <span class="hljs-attribute">d</span>=1, <span class="hljs-attribute">c</span>=0, <span class="hljs-attribute">a</span>=1, <span class="hljs-attribute">b</span>=1, <span class="hljs-attribute">f</span>=0, <span class="hljs-attribute">g</span>=0]
after:[<span class="hljs-literal">null</span>, <span class="hljs-attribute">c</span>=0, <span class="hljs-attribute">d</span>=1, <span class="hljs-attribute">f</span>=0, <span class="hljs-attribute">a</span>=1, <span class="hljs-attribute">b</span>=1, <span class="hljs-attribute">e</span>=1, <span class="hljs-attribute">g</span>=0]
‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐</code></pre>

<ul>
<li><p>初始化后，堆节点值都为0，即每个机器连接数都为0 </p>
</li>
<li><p>堆顶连接后，下沉，堆重新排序，最小堆规则保持成立 </p>
</li>
</ul>
<h4 id="应用案例-2"><a href="#应用案例-2" class="headerlink" title="应用案例"></a>应用案例</h4><h5 id="nginx-upstream"><a href="#nginx-upstream" class="headerlink" title="nginx upstream"></a>nginx upstream</h5><pre><code class="hljs yaml"><span class="hljs-string">upstream</span> <span class="hljs-string">frontend</span> &#123; 
	<span class="hljs-comment">#源地址hash </span>
	<span class="hljs-string">ip_hash;</span>
  <span class="hljs-string">server</span> <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:8081;</span> 
  <span class="hljs-string">server</span> <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.2</span><span class="hljs-string">:8082</span> <span class="hljs-string">weight=1</span> <span class="hljs-string">down;</span> 
  <span class="hljs-string">server</span> <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.3</span><span class="hljs-string">:8083</span> <span class="hljs-string">weight=2;</span> 
  <span class="hljs-string">server</span> <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.4</span><span class="hljs-string">:8084</span> <span class="hljs-string">weight=3</span> <span class="hljs-string">backup;</span>
  <span class="hljs-string">server</span> <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.5</span><span class="hljs-string">:8085</span> <span class="hljs-string">weight=4</span> <span class="hljs-string">max_fails=3</span> <span class="hljs-string">fail_timeout=30s;</span> 
&#125;</code></pre>

<ul>
<li><p>ip_hash：即源地址hash算法 </p>
</li>
<li><p>down：表示当前的server暂时不参与负载 </p>
</li>
<li><p>weight：即加权算法，默认为1，weight越大，负载的权重就越大。 </p>
</li>
<li><p>backup：备份机器，只有其它所有的非backup机器down或者忙的时候，再请求backup机器。 </p>
</li>
<li><p>max_fails：最大失败次数，默认值为1，这里为3，也就是最多进行3次尝试 </p>
</li>
<li><p>fail_timeout：超时时间为30秒，默认值是10s。 </p>
</li>
</ul>
<p>注意！weight和backup不能和ip_hash关键字一起使用。 </p>
<h5 id="springcloud-ribbon-IRule"><a href="#springcloud-ribbon-IRule" class="headerlink" title="springcloud ribbon IRule"></a>springcloud ribbon IRule</h5><pre><code class="hljs routeros"><span class="hljs-comment">#设置负载均衡策略 eureka‐application‐service为调用的服务的名称 </span>
eureka‐application‐ service.ribbon.<span class="hljs-attribute">NFLoadBalancerRuleClassName</span>=com.netflix.loadbalancer.RandomRule</code></pre>

<ul>
<li><p>RoundRobinRule：轮询 </p>
</li>
<li><p>RandomRule：随机 </p>
</li>
<li><p>AvailabilityFilteringRule：先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，还有并发的连接数量超过阈值的服务，然后对剩余的服务轮询 </p>
</li>
<li><p>WeightedResponseTimeRule：根据平均响应时间计算所有服务的权重，响应时间越快服务权重越大。刚启动时如果统计信息不足，则使用RoundRobinRule策略，等统计信息足够，会切换到该策略 </p>
</li>
<li><p>RetryRule：先按照RoundRobinRule的策略，如果获取服务失败则在指定时间内重试，获取可用的服务 </p>
</li>
<li><p>BestAvailableRule：会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择一个并发量最小的服务 </p>
</li>
<li><p>ZoneAvoidanceRule：默认规则，综合判断server所在区域的性能和server的可用性 </p>
</li>
</ul>
<h5 id="dubbo负载均衡"><a href="#dubbo负载均衡" class="headerlink" title="dubbo负载均衡"></a>dubbo负载均衡</h5><p>使用Service注解 </p>
<p><code>@Service(loadbalance = &quot;roundrobin&quot;,weight = 100) </code></p>
<ul>
<li><p>RandomLoadBalance: 随机，这种方式是dubbo默认的负载均衡策略 </p>
</li>
<li><p>RoundRobinLoadBalance：轮询 </p>
</li>
<li><p>LeastActiveLoadBalance：最少活跃次数，dubbo框架自定义了一个Filter，用于计算服务被调用的次数 </p>
</li>
<li><p>ConsistentHashLoadBalance：一致性hash </p>
</li>
</ul>
<h3 id="加密算法与应用"><a href="#加密算法与应用" class="headerlink" title="加密算法与应用"></a>加密算法与应用</h3><h4 id="散列"><a href="#散列" class="headerlink" title="散列"></a>散列</h4><h5 id="概述-16"><a href="#概述-16" class="headerlink" title="概述"></a>概述</h5><p>严格来讲这不算是一种加密，而应该叫做信息摘要算法。该算法使用散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。通过数据打乱混合，重新创建一个叫做散列值 </p>
<h5 id="常见算法"><a href="#常见算法" class="headerlink" title="常见算法"></a>常见算法</h5><p>MD5、SHA（128、256）系列</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>安全性</th>
<th>速度</th>
</tr>
</thead>
<tbody><tr>
<td>SHA-1</td>
<td>高</td>
<td>🈵️</td>
</tr>
<tr>
<td>MD5</td>
<td>中</td>
<td>快</td>
</tr>
</tbody></table>
<h5 id="应用-5"><a href="#应用-5" class="headerlink" title="应用"></a>应用</h5><p>常用于密码存储，或文件指纹校验。</p>
<p>网站用户注册后，密码经过MD5加密后的值，存储进DB。再次登录时，将用户输入的密码按同样的方式加密，与数据库中的密文比对。这样即使数据库被破解，或者开发人员可见，基于MD5的不可逆性，仍然不知道密码是什么。</p>
<p>其次是文件校验场景。例如从某站下载的文件（尤其是大文件，比如系统镜像iso），官方网站都会放置一个签名（可能是MD5，或者SHA），当用户拿到文件后，可以本地执行散列算法与官网签名比对是否一致，来判断文件是否被篡改。如ubuntu20.04的镜像： </p>
<img src="/blog/2020/08/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E4%B8%8E%E5%BA%94%E7%94%A8/pic7.png" srcset="/blog/img/loading.gif" class>

<h5 id="实现-18"><a href="#实现-18" class="headerlink" title="实现"></a>实现</h5><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.pwd;

<span class="hljs-keyword">import</span> org.apache.commons.codec.digest.DigestUtils;

<span class="hljs-keyword">import</span> java.math.BigInteger;
<span class="hljs-keyword">import</span> java.security.MessageDigest;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hash</span> </span>&#123;
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * jdk的security实现md5</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">md5</span><span class="hljs-params">(String src)</span> </span>&#123;
        <span class="hljs-keyword">byte</span>[] pwd = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">try</span> &#123;
            pwd = MessageDigest.getInstance(<span class="hljs-string">&quot;md5&quot;</span>).digest(src.getBytes(<span class="hljs-string">&quot;utf‐8&quot;</span>));
        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
        &#125;
        String code = <span class="hljs-keyword">new</span> BigInteger(<span class="hljs-number">1</span>, pwd).toString(<span class="hljs-number">16</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span> - code.length();
             i++) &#123;
            code = <span class="hljs-string">&quot;0&quot;</span> + code;
        &#125;
        <span class="hljs-keyword">return</span> code;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">commonsMd5</span><span class="hljs-params">(String src)</span> </span>&#123;
        <span class="hljs-keyword">return</span> DigestUtils.md5Hex(src);
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * jdk实现sha算法</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">sha</span><span class="hljs-params">(String src)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        MessageDigest sha = MessageDigest.getInstance(<span class="hljs-string">&quot;sha&quot;</span>);
        <span class="hljs-keyword">byte</span>[] shaByte = sha.digest(src.getBytes(<span class="hljs-string">&quot;utf‐8&quot;</span>));
        StringBuffer code = <span class="hljs-keyword">new</span> StringBuffer();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; shaByte.length; i++) &#123;
            <span class="hljs-keyword">int</span> val = ((<span class="hljs-keyword">int</span>) shaByte[i]) &amp; <span class="hljs-number">0xff</span>;
            <span class="hljs-keyword">if</span> (val &lt; <span class="hljs-number">16</span>) &#123;
                code.append(<span class="hljs-string">&quot;0&quot;</span>);
            &#125;
            code.append(Integer.toHexString(val));
        &#125;
        <span class="hljs-keyword">return</span> code.toString();
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">commonsSha</span><span class="hljs-params">(String src)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        <span class="hljs-keyword">return</span> DigestUtils.sha1Hex(src);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        String name = <span class="hljs-string">&quot;架构师训练营&quot;</span>;
        System.out.println(name);
        System.out.println(md5(name));
        System.out.println(commonsMd5(name));
        System.out.println(sha(name));
        System.out.println(commonsSha(name));
    &#125;
&#125;</code></pre>

<h5 id="结果分析-18"><a href="#结果分析-18" class="headerlink" title="结果分析"></a>结果分析</h5><pre><code class="hljs llvm">架构师训练营
d<span class="hljs-number">98</span><span class="hljs-keyword">c</span><span class="hljs-number">9e606978909</span>dd<span class="hljs-number">8</span>cbeda<span class="hljs-number">3409</span>b<span class="hljs-number">38</span>ba
d<span class="hljs-number">98</span><span class="hljs-keyword">c</span><span class="hljs-number">9e606978909</span>dd<span class="hljs-number">8</span>cbeda<span class="hljs-number">3409</span>b<span class="hljs-number">38</span>ba
a<span class="hljs-number">74474</span>a<span class="hljs-number">705</span>b<span class="hljs-number">01</span>a<span class="hljs-number">8</span>ed<span class="hljs-number">1</span>bfae<span class="hljs-number">76</span>f<span class="hljs-number">4</span>b<span class="hljs-number">8</span><span class="hljs-keyword">c</span><span class="hljs-number">36518341959</span>
a<span class="hljs-number">74474</span>a<span class="hljs-number">705</span>b<span class="hljs-number">01</span>a<span class="hljs-number">8</span>ed<span class="hljs-number">1</span>bfae<span class="hljs-number">76</span>f<span class="hljs-number">4</span>b<span class="hljs-number">8</span><span class="hljs-keyword">c</span><span class="hljs-number">36518341959</span></code></pre>

<ul>
<li><p>jdk与commons均生成了相同的散列值 </p>
</li>
<li><p>多次运行，依然生成固定值 </p>
</li>
<li><p>commons-codec还有很多可用方法，如：sha256，sha512… </p>
</li>
</ul>
<h4 id="对称"><a href="#对称" class="headerlink" title="对称"></a>对称</h4><h5 id="概述-17"><a href="#概述-17" class="headerlink" title="概述"></a>概述</h5><p>加密与解密用的都是同一个秘钥，性能比非对称加密高很多。 </p>
<h5 id="常见算法-1"><a href="#常见算法-1" class="headerlink" title="常见算法"></a>常见算法</h5><p>常见的对称加密算法有 DES、3DES、AES </p>
<p>DES算法在POS、ATM、磁卡及智能卡（IC卡）、加油站、高速公路收费站等领域被广泛应用，以此来实现关键数据的保密，如信用卡持卡人的PIN的加密传输，IC卡与POS间的双向认证、金融交易数据包的MAC校验等</p>
<p>3DES是DES加密算法的一种模式，是DES的一个更安全的变形。从DES向AES的过渡算法</p>
<p>AES，是下一代的加密算法标准，速度快，安全级别更高。 </p>
<table>
<thead>
<tr>
<th>名称</th>
<th>密钥名称</th>
<th>运行速度</th>
<th>安全性</th>
<th>资源消耗</th>
</tr>
</thead>
<tbody><tr>
<td>DES</td>
<td>56位</td>
<td>较快</td>
<td>低</td>
<td>中</td>
</tr>
<tr>
<td>3DES</td>
<td>112位或168位</td>
<td>慢</td>
<td>中</td>
<td>高</td>
</tr>
<tr>
<td>AES</td>
<td>128、192、256位</td>
<td>快</td>
<td>高</td>
<td>低</td>
</tr>
</tbody></table>
<h5 id="应用-6"><a href="#应用-6" class="headerlink" title="应用"></a>应用</h5><p>常用于对效率要求较高的实时数据加密通信。 </p>
<h5 id="实现-19"><a href="#实现-19" class="headerlink" title="实现"></a>实现</h5><p>以AES为例： </p>
<pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.pwd;

<span class="hljs-keyword">import</span> org.apache.commons.codec.binary.Base64;

<span class="hljs-keyword">import</span> javax.crypto.Cipher;
<span class="hljs-keyword">import</span> javax.crypto.KeyGenerator;
<span class="hljs-keyword">import</span> javax.crypto.spec.SecretKeySpec;
<span class="hljs-keyword">import</span> java.security.Key;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AES</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        <span class="hljs-comment">//生成KEY </span>
        KeyGenerator keyGenerator = KeyGenerator.getInstance(<span class="hljs-string">&quot;AES&quot;</span>);
        keyGenerator.init(<span class="hljs-number">128</span>);
        <span class="hljs-comment">//key转换</span>
        Key key = <span class="hljs-keyword">new</span> SecretKeySpec(keyGenerator.generateKey().getEncoded(), <span class="hljs-string">&quot;AES&quot;</span>);
        Cipher cipher = Cipher.getInstance(<span class="hljs-string">&quot;AES/ECB/PKCS5Padding&quot;</span>);
        String src = <span class="hljs-string">&quot;架构师训练营&quot;</span>;
        System.out.println(<span class="hljs-string">&quot;明文：&quot;</span> + src);
        <span class="hljs-comment">//加密</span>
        cipher.init(Cipher.ENCRYPT_MODE, key);
        <span class="hljs-keyword">byte</span>[] result = cipher.doFinal(src.getBytes());
        System.out.println(<span class="hljs-string">&quot;加密：&quot;</span> + Base64.encodeBase64String(result));
        <span class="hljs-comment">//解密 </span>
        cipher.init(Cipher.DECRYPT_MODE, key);
        result = cipher.doFinal(result);
        System.out.println(<span class="hljs-string">&quot;解密：&quot;</span> + <span class="hljs-keyword">new</span> String(result));
    &#125;
&#125;</code></pre>

<h5 id="结果分析-19"><a href="#结果分析-19" class="headerlink" title="结果分析"></a>结果分析</h5><pre><code class="hljs gcode">明文：架构师训练营
加密：ea<span class="hljs-number">4</span>/<span class="hljs-symbol">nl4</span>a<span class="hljs-number">7</span>MadH<span class="hljs-symbol">nixqbKVHdBLJ6</span>kDpXle<span class="hljs-symbol">n0</span>Q<span class="hljs-number">4</span>bzH<span class="hljs-number">2</span>ZXk=
解密：架构师训练营</code></pre>

<h4 id="非对称"><a href="#非对称" class="headerlink" title="非对称"></a>非对称</h4><h5 id="概述-18"><a href="#概述-18" class="headerlink" title="概述"></a>概述</h5><p>非对称即加密与解密不是同一把钥匙，而是分成公钥和私钥。私钥在个人手里，公钥公开。这一对钥匙一个用于加密，另一个用于解密。使用其中一个加密后，则原始明文只能用对应的另一个密钥解密，即使最初用于加密的密钥也不能用作解密。正是因为这种特性，所以称为非对称加密。</p>
<h5 id="常见算法-2"><a href="#常见算法-2" class="headerlink" title="常见算法"></a>常见算法</h5><p>RSA、ElGamal、背包算法、Rabin（RSA的特例）、迪菲－赫尔曼密钥交换协议中的公钥加密算法、椭圆曲线加密算法（英语：Elliptic Curve Cryptography, ECC）。使用最广泛的是RSA算法（发明者Rivest、Shmir和Adleman姓氏首字母缩写）</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>成熟度</th>
<th>运行速度</th>
<th>运行速度</th>
<th>资源消耗</th>
</tr>
</thead>
<tbody><tr>
<td>RAS</td>
<td>高</td>
<td>高</td>
<td>中</td>
<td>中</td>
</tr>
<tr>
<td>ECC</td>
<td>高</td>
<td>高</td>
<td>慢</td>
<td>高</td>
</tr>
</tbody></table>
<h5 id="应用-7"><a href="#应用-7" class="headerlink" title="应用"></a>应用</h5><p>最常见的，两点：https和数字签名。 </p>
<p>严格意义上讲，https并非所有请求都使用非对称。基于性能考虑，https先使用非对称约定一个key，后期使用该key进行对称加密和数据传输。 </p>
<img src="/blog/2020/08/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E4%B8%8E%E5%BA%94%E7%94%A8/pic8.png" srcset="/blog/img/loading.gif" class>

<p>数字签名则是用于验证报文是否为服务器发出的，用于防伪和认证。过程如下：</p>
<p>签发：</p>
<ul>
<li><p>服务器外发布公钥，私钥保密 </p>
</li>
<li><p>服务器对消息M计算摘要（如MD5等公开算法），得到摘要D </p>
</li>
<li><p>服务器使用私钥对D进行签名，得到签名S </p>
</li>
<li><p>将M和S一起发给客户 </p>
</li>
</ul>
<p>验证：</p>
<ul>
<li><p>客户端对M使用同一摘要算法计算摘要，得到摘要D </p>
</li>
<li><p>使用服务器公钥对S进行解密，得到摘要D’ </p>
</li>
<li><p>如果D和D’相同，那么证明M确实是服务器发出的</p>
</li>
</ul>
<h5 id="实现-20"><a href="#实现-20" class="headerlink" title="实现"></a>实现</h5><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.pwd;

<span class="hljs-keyword">import</span> org.apache.commons.codec.binary.Base64;

<span class="hljs-keyword">import</span> javax.crypto.Cipher;
<span class="hljs-keyword">import</span> java.nio.charset.StandardCharsets;
<span class="hljs-keyword">import</span> java.security.*;
<span class="hljs-keyword">import</span> java.security.interfaces.RSAPrivateKey;
<span class="hljs-keyword">import</span> java.security.interfaces.RSAPublicKey;
<span class="hljs-keyword">import</span> java.security.spec.PKCS8EncodedKeySpec;
<span class="hljs-keyword">import</span> java.security.spec.X509EncodedKeySpec;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RSAUtil</span> </span>&#123;
    <span class="hljs-keyword">static</span> String privKey;
    <span class="hljs-keyword">static</span> String publicKey;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        <span class="hljs-comment">//生成公钥和私钥 </span>
        genKeyPair();
        <span class="hljs-comment">//加密字符串 </span>
        String message = <span class="hljs-string">&quot;架构师训练营&quot;</span>;
        System.out.println(<span class="hljs-string">&quot;明文：&quot;</span> + message);
        System.out.println(<span class="hljs-string">&quot;随机公钥为:&quot;</span> + publicKey);
        System.out.println(<span class="hljs-string">&quot;随机私钥为:&quot;</span> + privKey);
        String messageEn = encrypt(message, publicKey);
        System.out.println(<span class="hljs-string">&quot;公钥加密:&quot;</span> + messageEn);
        String messageDe = decrypt(messageEn, privKey);
        System.out.println(<span class="hljs-string">&quot;私钥解密:&quot;</span> + messageDe);
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 随机生成密钥对</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">genKeyPair</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> NoSuchAlgorithmException </span>&#123;
        <span class="hljs-comment">// KeyPairGenerator类用于生成公钥和私钥对，基于RSA算法生成对象</span>
        KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance(<span class="hljs-string">&quot;RSA&quot;</span>);
        <span class="hljs-comment">// 初始化密钥对生成器，密钥大小为96‐1024位</span>
        keyPairGen.initialize(<span class="hljs-number">1024</span>, <span class="hljs-keyword">new</span> SecureRandom());
        <span class="hljs-comment">// 生成一个密钥对，保存在keyPair中</span>
        KeyPair keyPair = keyPairGen.generateKeyPair();
        privKey = <span class="hljs-keyword">new</span> String(Base64.encodeBase64((keyPair.getPrivate().getEncoded())));
        publicKey = <span class="hljs-keyword">new</span> String(Base64.encodeBase64(keyPair.getPublic().getEncoded()));
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * RSA公钥加密</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">encrypt</span><span class="hljs-params">(String str, String publicKey)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        <span class="hljs-comment">//base64编码的公钥 </span>
        <span class="hljs-keyword">byte</span>[] decoded = Base64.decodeBase64(publicKey);
        RSAPublicKey pubKey = (RSAPublicKey) KeyFactory.getInstance(<span class="hljs-string">&quot;RSA&quot;</span>).generatePublic(<span class="hljs-keyword">new</span> X509EncodedKeySpec(decoded));
        <span class="hljs-comment">//RSA加密</span>
        Cipher cipher = Cipher.getInstance(<span class="hljs-string">&quot;RSA&quot;</span>);
        cipher.init(Cipher.ENCRYPT_MODE, pubKey);
        String outStr = Base64.encodeBase64String(cipher.doFinal(str.getBytes(StandardCharsets.UTF_8)));
        <span class="hljs-keyword">return</span> outStr;
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * RSA私钥解密</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">decrypt</span><span class="hljs-params">(String str, String privateKey)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        <span class="hljs-comment">//64位解码加密后的字符串 </span>
        <span class="hljs-keyword">byte</span>[] inputByte = Base64.decodeBase64(str.getBytes(StandardCharsets.UTF_8));
        <span class="hljs-keyword">byte</span>[] decoded = Base64.decodeBase64(privateKey);
        RSAPrivateKey priKey = (RSAPrivateKey) KeyFactory.getInstance(<span class="hljs-string">&quot;RSA&quot;</span>).generatePrivate(<span class="hljs-keyword">new</span> PKCS8EncodedKeySpec(decoded));
        Cipher cipher = Cipher.getInstance(<span class="hljs-string">&quot;RSA&quot;</span>);
        cipher.init(Cipher.DECRYPT_MODE, priKey);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(cipher.doFinal(inputByte));
    &#125;
&#125;</code></pre>

<h5 id="结果分析-20"><a href="#结果分析-20" class="headerlink" title="结果分析"></a>结果分析</h5><pre><code class="hljs awk">明文：架构师训练营
随机公钥为:MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCbuScdNarQtGJJMf9lGZ9KsD1ArYX7BFMxXDok7Wk75ItYkYJHJaOz2+EpGstXQb5XzBXUlT9pZTXsPHafhxFdLp3v9twc8clU890Wi7vxC755qcEp6Lr6uTT6t9hT295OkLjDwaE+OCAZBLKo8WDl7Z7oL05kxkPc0Id5SaBi7wIDAQAB
随机私钥为:MIICdQIBADANBgkqhkiG9w0BAQEFAASCAl8wggJbAgEAAoGBAJu5Jx01qtC0Ykkx<span class="hljs-regexp">/2UZn0qwPUCthfsEUzFcOiTtaTvki1iRgkclo7Pb4Skay1dBvlfMFdSVP2llNew8dp+HEV0une/</span><span class="hljs-number">23</span>BzxyVTz3RaLu<span class="hljs-regexp">/ELvnmpwSnouvq5NPq32FPb3k6QuMPBoT44IBkEsqjxYOXtnugvTmTGQ9zQh3lJoGLvAgMBAAECgYAXGSKlIYXByU/</span>e3YyteVx4XqXnRxXdgum4I574RULbwG2u6H5zgTDEB<span class="hljs-regexp">/Rg/</span>Xl16umJ6lq+mpi6UGnsLZfG1+kKNuTSLNkmXxk0UO1nIfAYC67BgL+bP21<span class="hljs-regexp">/wEBu5T9cpessLdyZDtx4LK6ORRBWLWA2UhRg+e/u</span>wDOIO+<span class="hljs-number">4</span>ezto3WQJBANkEOTSnkMTnvr3umpV290+Eh3ve4bR<span class="hljs-regexp">/eKBQxO3P+3CRvJq9AgBCGNszwhM/</span><span class="hljs-number">7</span>GQxJBZi9<span class="hljs-regexp">/7W6t/</span>M7hIPkEtSsJsCQQC3skhLCDGuv7xXA<span class="hljs-regexp">/IJuY9SjN6FLkIDtEZML8l02/</span>leowZHz7NxiYSBpBQQHLiOYz<span class="hljs-regexp">/lwKM0XdxWAtZsxMnC1so9AkB1h7EHkDx6N1v49xEnI0/</span>a89aAQnwQSfzlLfkJJltxYqw3TWeZBjL5<span class="hljs-regexp">/DT+Qd9ff7GgoibXEEQRwqWoiF9IO9dDAkBKqXbCsGDpItsdDuh4VWhQaBslTGjeco5D9wRNr/</span><span class="hljs-number">7</span>KHT63P08y7W7i9lqFNfc5QFO<span class="hljs-regexp">/QS3UYfXlK6AVc2KCA6UNAkBHEtQVQK4hr0bsTERt6t+FGFGsM2lc6PuBKMHt6phPTS0P5hCZZJM/</span>E/LBkPD4ZuP7zORK7ZEbff9mZj+c+<span class="hljs-number">61</span>J
公钥加密:bDB0sRUj2rISKIklqNAq+EPn2ptp1zxvuWdtU<span class="hljs-regexp">/eH4frYVw98SqNEq3fC3HLTzNRc4B2KozykgUWWR1tlBzAnhOy1/</span>xuzzcwjFKonjZH0XR7mUzzz2glKN66vEdnFRngoleB9BpXk2nCuUCTmq6MJ2bxgc7pfAeCSFecDFixGcig=
私钥解密:架构师训练营</code></pre>

<ul>
<li><p>加密解密实现完整还原 </p>
</li>
<li><p>必须用另一把钥匙解密，如果用公钥加密后再使用公钥解密，则失败 </p>
</li>
</ul>
<h3 id="一致性hash及其应用"><a href="#一致性hash及其应用" class="headerlink" title="一致性hash及其应用"></a>一致性<strong>hash</strong>及其应用</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>负载均衡策略中，我们提到过源地址hash算法，让某些请求固定的落在对应的服务器上。这样可以解决会话信息保留的问题。 </p>
<p>如果机器节点数发生变更。那么请求会被重新hash，打破了原始的设计初衷，这时就需要一致性hash来解决。</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>以4台机器为例，一致性hash的算法如下：</p>
<ul>
<li><p>首先求出各个服务器的哈希值，并将其配置到0～232的圆上 </p>
</li>
<li><p>然后采用同样的方法求出存储数据的键的哈希值，也映射圆上 </p>
</li>
<li><p>从数据映射到的位置开始顺时针查找，将数据保存到找到的第一个服务器上 </p>
</li>
<li><p>如果到最大值仍然找不到，就取第一个。这就是为啥形象的称之为环 </p>
</li>
</ul>
<img src="/blog/2020/08/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E4%B8%8E%E5%BA%94%E7%94%A8/pic9.png" srcset="/blog/img/loading.gif" class>

<p>添加节点：</p>
<img src="/blog/2020/08/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E4%B8%8E%E5%BA%94%E7%94%A8/pic10.png" srcset="/blog/img/loading.gif" class>

<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul>
<li><p>单调性(Monotonicity)：单调性是指如果已经有一些请求通过哈希分派到了相应的服务器进行处理，又有新的服务器加入到系统中时候，应保证原有的请求可以被映射到原有的或者新的服务器中去，而不会被映射到原来的其它服务器上去。 </p>
</li>
<li><p>分散性(Spread)：分布式环境中，客户端请求时可能只知道其中一部分服务器，那么两个客户端看到不同的部分，并且认为自己看到的都是完整的hash环，那么问题来了，相同的key可能被路由到不同服务器上去。以上图为例，加入client1看到的是1,4；client2看到的是2,3；那么2-4之间的key会被俩客户端重复映射到3,4上去。分散性反应的是这种问题的严重程度。 </p>
</li>
<li><p>平衡性(Balance)：平衡性是指客户端hash后的请求应该能够分散到不同的服务器上去。一致性hash可以做到尽量分散，但是不能保证每个服务器处理的请求的数量完全相同。这种偏差称为hash倾斜。如果节点的分布算法设计不合理，那么平衡性就会收到很大的影响。 </p>
</li>
</ul>
<p>优化</p>
<p>增加虚拟节点可以优化hash算法，使得切段和分布更细化。即实际有m台机器，但是扩充n倍，在环上放置m*n个，那么均分后，key的段会分布更细化。</p>
<img src="/blog/2020/08/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E4%B8%8E%E5%BA%94%E7%94%A8/pic11.png" srcset="/blog/img/loading.gif" class>

<h3 id="实现-21"><a href="#实现-21" class="headerlink" title="实现"></a>实现</h3><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.hash;

<span class="hljs-keyword">import</span> java.util.SortedMap;
<span class="hljs-keyword">import</span> java.util.TreeMap;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 一致性Hash算法</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hash</span> </span>&#123;
    <span class="hljs-comment">//服务器列表</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String[] servers = &#123;<span class="hljs-string">&quot;192.168.0.1&quot;</span>, <span class="hljs-string">&quot;192.168.0.2&quot;</span>, <span class="hljs-string">&quot;192.168.0.3&quot;</span>, <span class="hljs-string">&quot;192.168.0.4&quot;</span>&#125;;
    <span class="hljs-comment">//key表示服务器的hash值，value表示服务器</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SortedMap&lt;Integer, String&gt; serverMap = <span class="hljs-keyword">new</span> TreeMap&lt;Integer, String&gt;();

    <span class="hljs-keyword">static</span> &#123;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; servers.length; i++) &#123;
            <span class="hljs-keyword">int</span> hash = getHash(servers[i]);
            <span class="hljs-comment">//理论上，hash环的最大值为2^32</span>
            <span class="hljs-comment">// 这里为做实例，将ip末尾作为上限也就是254</span>
            <span class="hljs-comment">// 那么服务器是0‐4，乘以60后可以均匀分布到 0‐254 的环上去</span>
            <span class="hljs-comment">// 实际的请求ip到来时，在环上查找即可</span>
            hash *= <span class="hljs-number">60</span>;
            System.out.println(<span class="hljs-string">&quot;add &quot;</span> + servers[i] + <span class="hljs-string">&quot;, hash=&quot;</span> + hash);
            serverMap.put(hash, servers[i]);
        &#125;
    &#125;

    <span class="hljs-comment">//查找节点</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getServer</span><span class="hljs-params">(String key)</span> </span>&#123;
        <span class="hljs-keyword">int</span> hash = getHash(key);
        <span class="hljs-comment">//得到大于该Hash值的所有server</span>
        SortedMap&lt;Integer, String&gt; subMap = serverMap.tailMap(hash);
        <span class="hljs-keyword">if</span> (subMap.isEmpty()) &#123;
            <span class="hljs-comment">//如果没有比该key的hash值大的，则从第一个node开始</span>
            Integer i = serverMap.firstKey();
            <span class="hljs-comment">//返回对应的服务器</span>
            <span class="hljs-keyword">return</span> serverMap.get(i);
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-comment">//第一个Key就是顺时针过去离node最近的那个结点</span>
            Integer i = subMap.firstKey();
            <span class="hljs-comment">//返回对应的服务器</span>
            <span class="hljs-keyword">return</span> subMap.get(i);
        &#125;
    &#125;

    <span class="hljs-comment">//运算hash值</span>
    <span class="hljs-comment">// 该函数可以自由定义，只要做到取值离散即可</span>
    <span class="hljs-comment">// 这里取ip地址的最后一节</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getHash</span><span class="hljs-params">(String str)</span> </span>&#123;


        String last = str.substring(str.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>) + <span class="hljs-number">1</span>, str.length());
        <span class="hljs-keyword">return</span> Integer.valueOf(last);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-comment">//模拟5个随机ip请求 </span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">8</span>; i++) &#123;
            String ip = <span class="hljs-string">&quot;192.168.1.&quot;</span> + i * <span class="hljs-number">30</span>;
            System.out.println(ip + <span class="hljs-string">&quot; ‐‐‐&gt; &quot;</span> + getServer(ip));
        &#125;
        <span class="hljs-comment">//将5号服务器加到2‐3之间，取中间位置，150 </span>
        System.out.println(<span class="hljs-string">&quot;add 192.168.0.5，hash=150&quot;</span>);
        serverMap.put(<span class="hljs-number">150</span>, <span class="hljs-string">&quot;192.168.0.5&quot;</span>);
        <span class="hljs-comment">//再次发起5个请求 </span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">8</span>; i++) &#123;
            String ip = <span class="hljs-string">&quot;192.168.1.&quot;</span> + i * <span class="hljs-number">30</span>;
            System.out.println(ip + <span class="hljs-string">&quot; ‐‐‐&gt; &quot;</span> + getServer(ip));
        &#125;
    &#125;
&#125;</code></pre>

<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><pre><code class="hljs accesslog">add <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>, hash=<span class="hljs-number">60</span>
add <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">2</span>, hash=<span class="hljs-number">120</span>
add <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">3</span>, hash=<span class="hljs-number">180</span>
add <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">4</span>, hash=<span class="hljs-number">240</span>
<span class="hljs-number">192.168.1.30</span> ‐‐‐&gt; <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>
<span class="hljs-number">192.168.1.60</span> ‐‐‐&gt; <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>
<span class="hljs-number">192.168.1.90</span> ‐‐‐&gt; <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">2</span>
<span class="hljs-number">192.168.1.120</span> ‐‐‐&gt; <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">2</span>
<span class="hljs-number">192.168.1.150</span> ‐‐‐&gt; <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">3</span>
<span class="hljs-number">192.168.1.180</span> ‐‐‐&gt; <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">3</span>
<span class="hljs-number">192.168.1.210</span> ‐‐‐&gt; <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">4</span>
add <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">5</span>，hash=<span class="hljs-number">150</span>
<span class="hljs-number">192.168.1.30</span> ‐‐‐&gt; <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>
<span class="hljs-number">192.168.1.60</span> ‐‐‐&gt; <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>
<span class="hljs-number">192.168.1.90</span> ‐‐‐&gt; <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">2</span>
<span class="hljs-number">192.168.1.120</span> ‐‐‐&gt; <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">2</span>
<span class="hljs-number">192.168.1.150</span> ‐‐‐&gt; <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">5</span>
<span class="hljs-number">192.168.1.180</span> ‐‐‐&gt; <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">3</span>
<span class="hljs-number">192.168.1.210</span> ‐‐‐&gt; <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">4</span></code></pre>

<ul>
<li><p>4台机器加入hash环 </p>
</li>
<li><p>模拟请求，根据hash值，准确调度到下游节点 </p>
</li>
<li><p>添加节点5，key取150 </p>
</li>
<li><p>再次发起请求 </p>
</li>
</ul>
<h3 id="典型业务场景应用"><a href="#典型业务场景应用" class="headerlink" title="典型业务场景应用"></a>典型业务场景应用</h3><h4 id="网站敏感词过滤"><a href="#网站敏感词过滤" class="headerlink" title="网站敏感词过滤"></a>网站敏感词过滤</h4><h5 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h5><p>敏感词、文字过滤是一个网站必不可少的功能，高效的过滤算法是非常有必要的。针对过滤首先想到的可能是这样：</p>
<p>方案一、使用java里的String contains，逐个遍历敏感词： </p>
<pre><code class="hljs java">String[] s = <span class="hljs-string">&quot;广告,广告词,中奖&quot;</span>.split(<span class="hljs-string">&quot;,&quot;</span>);
String text = <span class="hljs-string">&quot;讨厌的广告词&quot;</span>;
<span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>;
<span class="hljs-keyword">for</span> (String s1 : s) &#123;
    <span class="hljs-keyword">if</span> (text.contains(s1)) &#123;
        flag = <span class="hljs-keyword">true</span>;
        <span class="hljs-keyword">break</span>;
    &#125;
&#125;
System.out.println(flag);</code></pre>

<p>方案二、正则表达式： </p>
<pre><code class="hljs java">System.out.println(text.matches(<span class="hljs-string">&quot;.*(广告|广告词|中奖).*&quot;</span>));</code></pre>

<p>其实无论采取哪个方法，基本是换汤不换药。都是整体字符匹配，效率值得商榷。 </p>
<p>那怎么办呢？DFA算法出场。</p>
<h5 id="概述-19"><a href="#概述-19" class="headerlink" title="概述"></a>概述</h5><p>DFA即Deterministic Finite Automaton，也就是确定有穷自动机，它是是通过event和当前的state得到下一个state，即event+state=nextstate。 </p>
<p>对照到以上案例，查找和停止查找是动作，找没找到是状态，每一步的查找和结果决定下一步要不要继续。DFA算法在敏感词上应用的关键是构建敏感词库，如果我们把以上案例翻译成json表达如下：</p>
<pre><code class="hljs json">&#123;
	<span class="hljs-attr">&quot;isEnd&quot;</span>: <span class="hljs-number">0</span>,
	<span class="hljs-attr">&quot;广&quot;</span>: &#123;
		<span class="hljs-attr">&quot;isEnd&quot;</span>: <span class="hljs-number">0</span>,
		<span class="hljs-attr">&quot;告&quot;</span>: &#123;
			<span class="hljs-attr">&quot;isEnd&quot;</span>: <span class="hljs-number">1</span>,
			<span class="hljs-attr">&quot;词&quot;</span>: &#123;
				<span class="hljs-attr">&quot;isEnd&quot;</span>: <span class="hljs-number">1</span>
			&#125;
		&#125;
	&#125;,
	<span class="hljs-attr">&quot;中&quot;</span>: &#123;
		<span class="hljs-attr">&quot;isEnd&quot;</span>: <span class="hljs-number">0</span>,
		<span class="hljs-attr">&quot;奖&quot;</span>: &#123;
			<span class="hljs-attr">&quot;isEnd&quot;</span>: <span class="hljs-number">1</span>
		&#125;
	&#125;
&#125;</code></pre>

<p>查找过程如下：首先把text按字拆分，逐个字查找词库的key，先从“讨”开始，没有就下一个字“厌”，直到“广”，找到就判断isEnd，如果为1，说明匹配成功包含敏感词，如果为0，那就继续匹配“告”，直到isEnd=1为止。 </p>
<p>匹配策略上，有两种。最小和最大匹配。最小则匹配【广告】，最大则需要匹配到底【广告词】 </p>
<h5 id="实现-22"><a href="#实现-22" class="headerlink" title="实现"></a>实现</h5><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.hash;

<span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;

<span class="hljs-keyword">import</span> java.util.HashMap;
<span class="hljs-keyword">import</span> java.util.HashSet;
<span class="hljs-keyword">import</span> java.util.Map;
<span class="hljs-keyword">import</span> java.util.Set;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 敏感词处理DFA算法</span>
<span class="hljs-comment"> */</span>

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SensitiveWordUtil</span> </span>&#123;
    <span class="hljs-comment">//短匹配规则，如：敏感词库[&quot;广告&quot;,&quot;广告词&quot;]，语句：&quot;我是广告词&quot;，匹配结果：我是[广告]</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SHORT_MATCH = <span class="hljs-number">1</span>;
    <span class="hljs-comment">//长匹配规则，如：敏感词库[&quot;广告&quot;,&quot;广告词&quot;]，语句：&quot;我是广告词&quot;，匹配结果：我是[广告词]</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> LONG_MATCH = <span class="hljs-number">2</span>;
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 敏感词库</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> HashMap sensitiveWordMap;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 初始化敏感词库</span>
<span class="hljs-comment">     * words:敏感词，多个用英文逗号分隔</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initSensitiveWordMap</span><span class="hljs-params">(String words)</span> </span>&#123;
        String[] w = words.split(<span class="hljs-string">&quot;,&quot;</span>);
        sensitiveWordMap = <span class="hljs-keyword">new</span> HashMap(w.length);
        Map nowMap;
        <span class="hljs-keyword">for</span> (String key : w) &#123;
            nowMap = sensitiveWordMap;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; key.length(); i++) &#123;
                <span class="hljs-comment">//转换成char型</span>
                <span class="hljs-keyword">char</span> keyChar = key.charAt(i);
                <span class="hljs-comment">//库中获取关键字</span>
                Map wordMap = (Map) nowMap.get(keyChar);
                <span class="hljs-comment">//如果不存在新建一个，并加入词库</span>
                <span class="hljs-keyword">if</span> (wordMap == <span class="hljs-keyword">null</span>) &#123;
                    wordMap = <span class="hljs-keyword">new</span> HashMap();
                    wordMap.put(<span class="hljs-string">&quot;isEnd&quot;</span>, <span class="hljs-string">&quot;0&quot;</span>);
                    nowMap.put(keyChar, wordMap);
                &#125;
                nowMap = wordMap;
                <span class="hljs-keyword">if</span> (i == key.length() - <span class="hljs-number">1</span>) &#123;
                    <span class="hljs-comment">//最后一个</span>
                    nowMap.put(<span class="hljs-string">&quot;isEnd&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>);
                &#125;
            &#125;
        &#125;
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 判断文字是否包含敏感字符 *<span class="hljs-doctag">@return</span> 若包含返回true，否则返回false</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(String txt, <span class="hljs-keyword">int</span> matchType)</span> </span>&#123;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; txt.length(); i++) &#123;
            <span class="hljs-keyword">int</span> matchFlag = checkSensitiveWord(txt, i, matchType);
            <span class="hljs-comment">//判断是否包含敏感字符</span>
            <span class="hljs-keyword">if</span> (matchFlag &gt; <span class="hljs-number">0</span>) &#123;
                <span class="hljs-comment">//大于0存在，返回true</span>
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    &#125;

    <span class="hljs-comment">/*** 沿着文本字符挨个往后检索文字中的敏感词 */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Set&lt;String&gt; <span class="hljs-title">getSensitiveWord</span><span class="hljs-params">(String txt, <span class="hljs-keyword">int</span> matchType)</span> </span>&#123;
        Set&lt;String&gt; sensitiveWordList = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; txt.length(); i++) &#123;
            <span class="hljs-comment">//判断是否包含敏感字符</span>
            <span class="hljs-keyword">int</span> length = checkSensitiveWord(txt, i, matchType);
            <span class="hljs-keyword">if</span> (length &gt; <span class="hljs-number">0</span>) &#123;
                <span class="hljs-comment">//存在,加入list中</span>
                sensitiveWordList.add(txt.substring(i, i + length));
                <span class="hljs-comment">//指针沿着文本往后移动敏感词的长度</span>
                <span class="hljs-comment">// 也就是一旦找到敏感词，加到列表后，越过这个词的字符，继续往下搜索</span>
                <span class="hljs-comment">// 但是必须减1，因为for循环会自增，如果不减会造成下次循环跳格而忽略字符</span>
                <span class="hljs-comment">// 这会造成严重误差</span>
                i = i + length - <span class="hljs-number">1</span>;
            &#125;
            <span class="hljs-comment">//如果找不到，i就老老实实一个字一个字的往后移动，作为begin进行下一轮</span>
        &#125;
        <span class="hljs-keyword">return</span> sensitiveWordList;
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 从第beginIndex个字符的位置，往后查找敏感词</span>
<span class="hljs-comment">     * 如果找到，返回敏感词字符的长度，不存在返回0</span>
<span class="hljs-comment">     * 这个长度用于找到后提取敏感词和后移指针，是个性能关注点</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">checkSensitiveWord</span><span class="hljs-params">(String txt, <span class="hljs-keyword">int</span> beginIndex, <span class="hljs-keyword">int</span> matchType)</span> </span>&#123;
        <span class="hljs-comment">//敏感词结束标识位：用于敏感词只有1位的情况</span>
        <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>;
        <span class="hljs-comment">//匹配到的敏感字的个数，也就是敏感词长度</span>
        <span class="hljs-keyword">int</span> length = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">char</span> word;
        <span class="hljs-comment">//从根Map开始查找</span>
        Map nowMap = sensitiveWordMap;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = beginIndex; i &lt; txt.length(); i++) &#123;
            <span class="hljs-comment">//被判断语句的第i个字符开始</span>
            word = txt.charAt(i);

            <span class="hljs-comment">//获取指定key，并且将敏感库指针指向下级</span>
            nowMap = (Map) nowMap.get(word);
            <span class="hljs-keyword">if</span> (nowMap != <span class="hljs-keyword">null</span>) &#123;
                <span class="hljs-comment">//存在，则判断是否为最后一个</span>
                <span class="hljs-comment">// 找到相应key，匹配长度+1</span>
                length++;
                <span class="hljs-comment">//如果为最后一个匹配规则,结束循环，返回匹配标识数</span>
                <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;1&quot;</span>.equals(nowMap.get(<span class="hljs-string">&quot;isEnd&quot;</span>))) &#123;
                    <span class="hljs-comment">//结束标志位为true</span>
                    flag = <span class="hljs-keyword">true</span>;
                    <span class="hljs-comment">//短匹配，直接返回,长匹配还需继续查找</span>
                    <span class="hljs-keyword">if</span> (SHORT_MATCH == matchType) &#123;
                        <span class="hljs-keyword">break</span>;
                    &#125;
                &#125;
            &#125; <span class="hljs-keyword">else</span> &#123;
                <span class="hljs-comment">//敏感库不存在，直接中断</span>
                <span class="hljs-keyword">break</span>;
            &#125;
        &#125;
        <span class="hljs-keyword">if</span> (length &lt; <span class="hljs-number">2</span> || !flag) &#123;
            <span class="hljs-comment">//长度必须大于等于1才算是词，字的话就不必这么折腾了</span>
            length = <span class="hljs-number">0</span>;
        &#125;
        <span class="hljs-keyword">return</span> length;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-comment">//初始化敏感词库</span>
        SensitiveWordUtil.initSensitiveWordMap(<span class="hljs-string">&quot;广告,广告词,中奖&quot;</span>);
        System.out.println(<span class="hljs-string">&quot;敏感词库结构：&quot;</span> + JSON.toJSONString(sensitiveWordMap));
        String string = <span class="hljs-string">&quot;关于中奖广告的广告词筛选&quot;</span>;
        System.out.println(<span class="hljs-string">&quot;被检测文本：&quot;</span> + string);
        System.out.println(<span class="hljs-string">&quot;待检测字数：&quot;</span> + string.length());
        <span class="hljs-comment">//是否含有关键字</span>
        <span class="hljs-keyword">boolean</span> result = SensitiveWordUtil.contains(string, SensitiveWordUtil.LONG_MATCH);
        System.out.println(<span class="hljs-string">&quot;长匹配：&quot;</span> + result);
        result = SensitiveWordUtil.contains(string, SensitiveWordUtil.SHORT_MATCH);
        System.out.println(<span class="hljs-string">&quot;短匹配：&quot;</span> + result);
        <span class="hljs-comment">//获取语句中的敏感词</span>
        Set&lt;String&gt; set = SensitiveWordUtil.getSensitiveWord(string, SensitiveWordUtil.LONG_MATCH);
        System.out.println(<span class="hljs-string">&quot;长匹配到：&quot;</span> + set);
        set = SensitiveWordUtil.getSensitiveWord(string, SensitiveWordUtil.SHORT_MATCH);
        System.out.println(<span class="hljs-string">&quot;短匹配到：&quot;</span> + set);
    &#125;
&#125;</code></pre>

<h5 id="结果分析-21"><a href="#结果分析-21" class="headerlink" title="结果分析"></a>结果分析</h5><pre><code class="hljs actionscript">敏感词库结构：&#123;<span class="hljs-string">&quot;中&quot;</span>:&#123;<span class="hljs-string">&quot;奖&quot;</span>:&#123;<span class="hljs-string">&quot;isEnd&quot;</span>:<span class="hljs-string">&quot;1&quot;</span>&#125;,<span class="hljs-string">&quot;isEnd&quot;</span>:<span class="hljs-string">&quot;0&quot;</span>&#125;,<span class="hljs-string">&quot;广&quot;</span>:&#123;<span class="hljs-string">&quot;告&quot;</span>:&#123;<span class="hljs-string">&quot;isEnd&quot;</span>:<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;词&quot;</span>:&#123;<span class="hljs-string">&quot;isEnd&quot;</span>:<span class="hljs-string">&quot;1&quot;</span>&#125;&#125;,<span class="hljs-string">&quot;isEnd&quot;</span>:<span class="hljs-string">&quot;0&quot;</span>&#125;&#125;
被检测文本：关于中奖广告的广告词筛选
待检测字数：<span class="hljs-number">12</span>
长匹配：<span class="hljs-literal">true</span>
短匹配：<span class="hljs-literal">true</span>
长匹配到：[中奖, 广告, 广告词]
短匹配到：[中奖, 广告]</code></pre>

<ul>
<li><p>敏感词结构初始化后符合预期 </p>
</li>
<li><p>检测和长短匹配有结果 </p>
</li>
<li><p>匹配的敏感词列表正确 </p>
</li>
</ul>
<h4 id="最优商品topk"><a href="#最优商品topk" class="headerlink" title="最优商品topk"></a>最优商品topk</h4><h5 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h5><p>topk是一个典型的业务场景，除了最优商品，包括推荐排名、积分排名所有涉及到排名前k的地方都是该算法的应用场合。 </p>
<p>topk即得到一个集合后，筛选里面排名前k个数值。问题看似简单，但是里面的数据结构和算法体现着对解决方案性能的思索和深度挖掘。到底有几种方法，这些方案里蕴含的优化思路究竟是怎么样的？这节来讨论 </p>
<h5 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h5><p>方案一： </p>
<p>全局排序，将集合整体排序后，取出最大的k个值就是需要的结果。 </p>
<p>这种方案最糟糕，我只需要排名前k的元素，其他n-k个的顺序我并不关心，但是运算过程中，都得跟着做了没用的排序操作。 </p>
<p>方案二： </p>
<p>局部排序，既然全局没必要，那我只取前k个，后面的就没必要理会了。 </p>
<p>冒泡排序在排序算法中可以胜任该操作。我们按最大值往上冒泡为例，只要执行k次冒泡，那前k名就可以确定。 </p>
<p>但是这种方案依然不是最优办法。因为我们需要的是前k名，那至于这k个，谁大谁小并不需要关心，排序依然是个浪费。 </p>
<p>方案三： </p>
<p>最小堆，既然没必要排序，那我们就不排序。 </p>
<p>先将前k个元素形成一个最小堆，后面的n-k个元素依次与堆顶比较，小则丢弃大则替换堆顶并调整堆。直到n个全部完成为止。最小堆是topk的经典解决方案。 </p>
<h5 id="实现-23"><a href="#实现-23" class="headerlink" title="实现"></a>实现</h5><p>下面就用最小堆实现topk</p>
<pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.hash;

<span class="hljs-keyword">import</span> java.util.Arrays;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Topk</span> </span>&#123;
    <span class="hljs-comment">//堆元素下沉，形成最小堆，序号从i开始 </span>
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nodes, <span class="hljs-keyword">int</span> i)</span> </span>&#123;
        <span class="hljs-comment">//顶点序号遍历，只要到1半即可，时间复杂度为O(log2n)</span>
        <span class="hljs-keyword">while</span> (i &lt;&lt; <span class="hljs-number">1</span> &lt; nodes.length) &#123;
            <span class="hljs-comment">//左子，为何左移1位？回顾一下二叉树序号 </span>
            <span class="hljs-keyword">int</span> left = i &lt;&lt; <span class="hljs-number">1</span>;
            <span class="hljs-comment">//右子，左+1即可 </span>
            <span class="hljs-keyword">int</span> right = left + <span class="hljs-number">1</span>;
            <span class="hljs-comment">//标记，指向 本节点，左、右子节点里最小的，一开始取i自己 </span>
            <span class="hljs-keyword">int</span> flag = i;
            <span class="hljs-comment">//判断左子是否小于本节点 </span>
            <span class="hljs-keyword">if</span> (nodes[left] &lt; nodes[i]) &#123;
                flag = left;
            &#125;
            <span class="hljs-comment">//判断右子 </span>
            <span class="hljs-keyword">if</span> (right &lt; nodes.length &amp;&amp; nodes[flag] &gt; nodes[right]) &#123;
                flag = right;
            &#125;
            <span class="hljs-comment">//两者中最小的与本节点不相等，则交换 </span>
            <span class="hljs-keyword">if</span> (flag != i) &#123;
                <span class="hljs-keyword">int</span> temp = nodes[i];
                nodes[i] = nodes[flag];
                nodes[flag] = temp;
                i = flag;
            &#125; <span class="hljs-keyword">else</span> &#123;
                <span class="hljs-comment">//否则相等，堆排序完成，退出循环即可 </span>
                <span class="hljs-keyword">break</span>;
            &#125;
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-comment">//原始数据 </span>
        <span class="hljs-keyword">int</span>[] src = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>&#125;;
        <span class="hljs-comment">//要取几个 </span>
        <span class="hljs-keyword">int</span> k = <span class="hljs-number">5</span>;
        <span class="hljs-comment">//堆，为啥是k+1？请注意，最小堆的0是无用的，序号从1开始 </span>
        <span class="hljs-keyword">int</span>[] nodes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[k + <span class="hljs-number">1</span>];
        <span class="hljs-comment">//取前k个数，注意这里只是个二叉树，还不满足最小堆的要求</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;
            nodes[i + <span class="hljs-number">1</span>] = src[i];
        &#125;
        System.out.println(<span class="hljs-string">&quot;before:&quot;</span> + Arrays.toString(nodes));
        <span class="hljs-comment">//从最底的子树开始，堆顶下沉 </span>
        <span class="hljs-comment">// 这里才真正的形成最小堆</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = k &gt;&gt; <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">1</span>; i--) &#123;
            down(nodes, i);
        &#125;
        System.out.println(<span class="hljs-string">&quot;create:&quot;</span> + Arrays.toString(nodes));
        <span class="hljs-comment">//把余下的n‐k个数，放到堆顶，依次下沉，topk堆算法的开始 </span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = src.length - k; i &lt; src.length; i++) &#123;
            <span class="hljs-keyword">if</span> (nodes[<span class="hljs-number">1</span>] &lt; src[i]) &#123;
                nodes[<span class="hljs-number">1</span>] = src[i];
                down(nodes, <span class="hljs-number">1</span>);
            &#125;
        &#125;
        System.out.println(<span class="hljs-string">&quot;topk:&quot;</span> + Arrays.toString(nodes));
    &#125;
&#125;</code></pre>

<h5 id="结果分析-22"><a href="#结果分析-22" class="headerlink" title="结果分析"></a>结果分析</h5><pre><code class="hljs apache"><span class="hljs-attribute">before</span>:[<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>]
<span class="hljs-attribute">create</span>:[<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>]
<span class="hljs-attribute">topk</span>:[<span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>]</code></pre>

<p>最终获取k个值成功，符合要求 </p>
<p>中间不涉及排序问题</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/blog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/blog/tags/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/">加密算法</a>
                    
                      <a class="hover-with-bg" href="/blog/tags/%E5%A4%B1%E6%95%88%E7%AE%97%E6%B3%95/">失效算法</a>
                    
                      <a class="hover-with-bg" href="/blog/tags/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/">限流算法</a>
                    
                      <a class="hover-with-bg" href="/blog/tags/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/">调度算法</a>
                    
                      <a class="hover-with-bg" href="/blog/tags/%E5%AE%9A%E6%97%B6%E7%AE%97%E6%B3%95/">定时算法</a>
                    
                      <a class="hover-with-bg" href="/blog/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95/">负载均衡算法</a>
                    
                      <a class="hover-with-bg" href="/blog/tags/%E4%B8%80%E8%87%B4%E6%80%A7Hash/">一致性Hash</a>
                    
                      <a class="hover-with-bg" href="/blog/tags/%E7%AE%97%E6%B3%95/">算法</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/blog/2020/08/22/%E7%BC%93%E5%AD%98-Redis%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Redis的基本介绍</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/blog/2020/08/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/">
                        <span class="hidden-mobile">数据结构和算法基础</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":200})
    NProgress.start()
    document.addEventListener('DOMContentLoaded', function() {
      window.NProgress && window.NProgress.inc();
    })
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.staticfile.org/jquery/3.5.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/js/bootstrap.min.js" ></script>
<script  src="/blog/js/debouncer.js" ></script>
<script  src="/blog/js/events.js" ></script>
<script  src="/blog/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/blog/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.staticfile.org/tocbot/4.12.0/tocbot.min.js" ></script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>





  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/blog/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/blog/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/blog/js/boot.js" ></script>



</body>
</html>
