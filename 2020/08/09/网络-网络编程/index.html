

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/blog/img/favicon.png">
  <link rel="icon" type="image/png" href="/blog/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="">
  <meta name="keywords" content="">
  <title>网络编程 - 🍎🍊&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/blog/lib/hint/hint.min.css" />

  
    
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_6peoq002giu.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/blog/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/blog/js/utils.js" ></script>
  <script  src="/blog/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/blog/">&nbsp;<strong>🍎🍊's blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/">
                <i class="iconfont icon-home-fill"></i>
                主页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/blog/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container page-header text-center fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-08-09 15:03" pubdate>
      2020年8月9日 下午
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      6.9k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      78
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" id="post">
            <!-- SEO header -->
            <h1 style="display: none">网络编程</h1>
            
            <div class="markdown-body" id="post-body">
              <h3 id="网络编程概述"><a href="#网络编程概述" class="headerlink" title="网络编程概述"></a>网络编程概述</h3><p>网络编程就是直接或间接地通过网络协议与其他计算机进行通信，网络编程有时我们也将其称之为套接字 (Socket)编程。</p>
<img src="/blog/2020/08/09/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/pic1.png" srcset="/blog/img/loading.gif" class>

<h4 id="网络编程三要素"><a href="#网络编程三要素" class="headerlink" title="网络编程三要素"></a>网络编程三要素</h4><ul>
<li><p>ip地址 </p>
</li>
<li><p>端口号 </p>
</li>
<li><p>网络协议 </p>
</li>
</ul>
<h4 id="ip地址"><a href="#ip地址" class="headerlink" title="ip地址"></a>ip地址</h4><p>IP地址是分配给网络中每台机器的数字标识符，它指出了设备在网络中的具体位置。 </p>
<p>ip地址可以分为两个版本：ipv4以及ipv6</p>
<p>IPv4地址（二进制）</p>
<pre><code class="hljs dns"><span class="hljs-number">01100100</span>.<span class="hljs-number">00000100</span>.<span class="hljs-number">00000101</span>.<span class="hljs-number">00000110</span></code></pre>

<p>IP地址（十进制） </p>
<pre><code class="hljs accesslog"><span class="hljs-number">100.4.5.6</span></code></pre>

<p>IPv6采用128位的地址，而IPv4使用的是32位，ipv6版的ip地址支持2^128(3.4 * 10 ^ 38)个ip地址。</p>
<p>IPv6二进位制下为128位长度，以16位为一组，每组以冒号”:”隔开，可以分为8组，每组以4位十六进制方式表示。例如： </p>
<pre><code class="hljs angelscript"><span class="hljs-number">2001</span>:<span class="hljs-number">0</span>db8:<span class="hljs-number">85</span>a3:<span class="hljs-number">08</span>d3:<span class="hljs-number">1319</span>:<span class="hljs-number">8</span>a2e:<span class="hljs-number">0370</span>:<span class="hljs-number">7344</span></code></pre>

<p>类似于IPv4的点分十进制，同样也存在点分十六进制的写法，将8组4位十六进制地址的冒号去除后，每位以点号”.”分组，例如： </p>
<pre><code class="hljs angelscript"><span class="hljs-number">2001</span>:<span class="hljs-number">0</span>db8:<span class="hljs-number">85</span>a3:<span class="hljs-number">08</span>d3:<span class="hljs-number">1319</span>:<span class="hljs-number">8</span>a2e:<span class="hljs-number">0370</span>:<span class="hljs-number">7344</span></code></pre>

<p>可以标记为 </p>
<pre><code class="hljs css">2<span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.1</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.d</span><span class="hljs-selector-class">.b</span><span class="hljs-selector-class">.8</span><span class="hljs-selector-class">.8</span><span class="hljs-selector-class">.5</span><span class="hljs-selector-class">.a</span><span class="hljs-selector-class">.3</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.8</span><span class="hljs-selector-class">.d</span><span class="hljs-selector-class">.3</span><span class="hljs-selector-class">.1</span><span class="hljs-selector-class">.3</span><span class="hljs-selector-class">.1</span><span class="hljs-selector-class">.9</span><span class="hljs-selector-class">.8</span><span class="hljs-selector-class">.a</span><span class="hljs-selector-class">.2</span><span class="hljs-selector-class">.e</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.3</span><span class="hljs-selector-class">.7</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.7</span><span class="hljs-selector-class">.3</span><span class="hljs-selector-class">.4</span><span class="hljs-selector-class">.4</span></code></pre>

<p>同时IPv6在某些条件下可以省略 </p>
<ol>
<li><p>每项数字前导的0可以省略，省略后前导数字仍是0则继续，例如下组IPv6是等价的。 </p>
<pre><code class="hljs css">2001<span class="hljs-selector-pseudo">:0DB8</span><span class="hljs-selector-pseudo">:02de</span><span class="hljs-selector-pseudo">:0000</span><span class="hljs-selector-pseudo">:0000</span><span class="hljs-selector-pseudo">:0000</span><span class="hljs-selector-pseudo">:0000</span><span class="hljs-selector-pseudo">:0e13</span>
2001<span class="hljs-selector-pseudo">:DB8</span><span class="hljs-selector-pseudo">:2de</span><span class="hljs-selector-pseudo">:000</span><span class="hljs-selector-pseudo">:000</span><span class="hljs-selector-pseudo">:000</span><span class="hljs-selector-pseudo">:000</span><span class="hljs-selector-pseudo">:e13</span>
2001<span class="hljs-selector-pseudo">:DB8</span><span class="hljs-selector-pseudo">:2de</span><span class="hljs-selector-pseudo">:00</span><span class="hljs-selector-pseudo">:00</span><span class="hljs-selector-pseudo">:00</span><span class="hljs-selector-pseudo">:00</span><span class="hljs-selector-pseudo">:e13</span>
2001<span class="hljs-selector-pseudo">:DB8</span><span class="hljs-selector-pseudo">:2de</span><span class="hljs-selector-pseudo">:0</span><span class="hljs-selector-pseudo">:0</span><span class="hljs-selector-pseudo">:0</span><span class="hljs-selector-pseudo">:0</span><span class="hljs-selector-pseudo">:e13</span></code></pre>
</li>
<li><p>可以用双冒号”::”表示一组0或多组连续的0，但只能出现一次，如果四组数字都是零，可以被省略。遵照以上省略规则，下面这两组IPv6都是相等的(使用”::”表示多组连续的0)。</p>
<pre><code class="hljs css">2001<span class="hljs-selector-pseudo">:DB8</span><span class="hljs-selector-pseudo">:wde</span><span class="hljs-selector-pseudo">:0</span><span class="hljs-selector-pseudo">:0</span><span class="hljs-selector-pseudo">:0</span><span class="hljs-selector-pseudo">:0</span><span class="hljs-selector-pseudo">:e13</span>
2001<span class="hljs-selector-pseudo">:DB8</span><span class="hljs-selector-pseudo">:2de</span><span class="hljs-selector-pseudo">::e13</span></code></pre>

<p>2001::25de::cade 是非法的，因为双冒号出现了两次。它有可能是下种情形之一，造成无法推断。 </p>
<pre><code class="hljs angelscript"><span class="hljs-number">2001</span>:<span class="hljs-number">0000</span>:<span class="hljs-number">0000</span>:<span class="hljs-number">0000</span>:<span class="hljs-number">0000</span>:<span class="hljs-number">25</span>de:<span class="hljs-number">0000</span>:cade 
<span class="hljs-number">2001</span>:<span class="hljs-number">0000</span>:<span class="hljs-number">0000</span>:<span class="hljs-number">0000</span>:<span class="hljs-number">25</span>de:<span class="hljs-number">0000</span>:<span class="hljs-number">0000</span>:cade 
<span class="hljs-number">2001</span>:<span class="hljs-number">0000</span>:<span class="hljs-number">0000</span>:<span class="hljs-number">25</span>de:<span class="hljs-number">0000</span>:<span class="hljs-number">0000</span>:<span class="hljs-number">0000</span>:cade 
<span class="hljs-number">2001</span>:<span class="hljs-number">0000</span>:<span class="hljs-number">25</span>de:<span class="hljs-number">0000</span>:<span class="hljs-number">0000</span>:<span class="hljs-number">0000</span>:<span class="hljs-number">0000</span>:cade</code></pre>

</li>
</ol>
<h4 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h4><p>通过IP地址可以在网络中找到指定计算机，但如果想访问目标计算机中的某个应用程序，还需要指定端口号。</p>
<p>在计算机中，不同的应用程序是通过端口号区分的。端口号是用两个字节（16位的二进制数）表示的，它的取值范围是0<del>65535，其中，0</del>1023之间的端口号用于一些知名的网络服务和应用(一般都是系统服务和应用)，用户的普通应用程序需要使用1024以上的端口号， 从而避免端口号被另外一个应用或服务所占用。 </p>
<img src="/blog/2020/08/09/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/pic4.png" srcset="/blog/img/loading.gif" class>

<h4 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h4><img src="/blog/2020/08/09/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/pic5.png" srcset="/blog/img/loading.gif" class>

<h3 id="网络分层模型通信"><a href="#网络分层模型通信" class="headerlink" title="网络分层模型通信"></a>网络分层模型通信</h3><h4 id="站点间数据传输过程"><a href="#站点间数据传输过程" class="headerlink" title="站点间数据传输过程"></a>站点间数据传输过程</h4><img src="/blog/2020/08/09/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/pic6.png" srcset="/blog/img/loading.gif" class>

<h4 id="网络分层模型与协议族"><a href="#网络分层模型与协议族" class="headerlink" title="网络分层模型与协议族"></a>网络分层模型与协议族</h4><p>OSI（Open System Interconnect），即开放式系统互联。 一般都叫OSI参考模型，是ISO国际标准化组织在1985年研究的网络互联模型。该体系结构标准定义了网络互联的七层框架（物理层、数据链路层、网络层、传输层、会话层、表示层和应用层），即OSI开放系统互连参考模型。</p>
<p>TCP/IP协议族里的协议最早发源于美国国防部（缩写为DoD）的ARPA网项目，因此也被称作DoD模型（DoD Model）。 </p>
<img src="/blog/2020/08/09/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/pic7.png" srcset="/blog/img/loading.gif" class>

<ul>
<li><p>网络层</p>
<ul>
<li>ip协议：网络互连协议，将多个包在网络中联系起来，传输数据包（不可靠传输），最基本功能就是寻址和分段功能，不提供端到端，路由到路由的确认，不提供重发和流量控制。是计算机网络能够互相通信的基本规则。出错 则像ICMP报告，ICMP在IP模块中实现。 </li>
<li>ICMP协议：面向无连接协议，用户传输错误报告控制信息（控制信息是指网络不通畅，主机是否到达，路由是否可用的这些网络本身的消息，不涉及用户传输的数据）。 </li>
<li>ARP协议：地址解析协议，根据IP地址获取物理地址的协议（即MAC地址）。在同一子网内通过ARP协议可以实现数据包的互相传递。不在一个子网内则无法获得MAC地址，只有通过网关去处理。 </li>
<li>RAPP协议：反转地址协议，将主机的物理地址转换成IP地址。 </li>
<li>BOOTP协议：引导程序协议，用于无盘工作站的局域网中，可以无盘工作站从一个中心服务器上获得IP地址。</li>
</ul>
</li>
<li><p>传输层：提供两台主机间端到端的通信</p>
<ul>
<li>TCP协议：传输控制协议，主要用于网间传输的协议，分割处理报文并把结果包传到IP层，并接受处理IP曾传到的数据包。 </li>
<li>UDP：用户数据协议，主要用于需要在计算器之间传输数据的应用，将网络数据流量压缩成数据包。 </li>
</ul>
</li>
<li><p>应用层：用于不同的应用程序</p>
<ul>
<li>NET协议：网络地址转换协议，实现内网IP地址和公司地址之间的相互转换。将大量的内网IP转换成一个或者少量的公网IP。 </li>
<li>FTP协议：文件传输协议 ，通过FTP协议在FTP客户端访问FTP服务端，默认使用20和21端口，20用于传输数据，21用于传输控制信息。 </li>
<li>HTTP协议：超文本协议，是用于从WWW服务端传输超文本到本地浏览器的传输协议。是客户端浏览器或其他程序与WEB服务器之间的应用层通信协议。 </li>
<li>TELNET协议：是Internet远程登录服务的标准协议和主要方式，为用户提供了在本地计算机上完成远程主机工作的能力。 </li>
<li>SMTP：简单邮件传输协议，控制邮件传输的规则，以及邮件的中转方式。 </li>
<li>DNS协议：定义域名规则，将域名和IP相互映射。 </li>
</ul>
</li>
</ul>
<img src="/blog/2020/08/09/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/pic8.png" srcset="/blog/img/loading.gif" class>

<h4 id="网络传输层剖析"><a href="#网络传输层剖析" class="headerlink" title="网络传输层剖析"></a>网络传输层剖析</h4><h5 id="网络套接字剖析"><a href="#网络套接字剖析" class="headerlink" title="网络套接字剖析"></a>网络套接字剖析</h5><img src="/blog/2020/08/09/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/pic9.png" srcset="/blog/img/loading.gif" class>

<p>Socket其实并不是一个协议，而是为了方便使用TCP或UDP而抽象出来的一层，是位于应用层和传输控制层之间的一组接口。提供一套调用TCP/IP协议的API。 </p>
<p>在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。 </p>
<p>当两台主机通信时，必须通过Socket连接，Socket则利用TCP/IP协议建立TCP连接。TCP连接则更依靠于底层的IP协议，IP协议的连接则依赖于链路层等更低层次 </p>
<img src="/blog/2020/08/09/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/pic19.png" srcset="/blog/img/loading.gif" class>

<h5 id="Socket通信流程"><a href="#Socket通信流程" class="headerlink" title="Socket通信流程"></a>Socket通信流程</h5><img src="/blog/2020/08/09/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/pic10.png" srcset="/blog/img/loading.gif" class>

<h5 id="网络传输报头格式"><a href="#网络传输报头格式" class="headerlink" title="网络传输报头格式"></a>网络传输报头格式</h5><p>TCP是Transmission Control Protocol的简称,中文名称为传输控制协议。它具有几下几个特点： </p>
<ol>
<li><p>TCP协议是一种面向连接的协议。 数据传输之前必须先建立连接，数据传输完成之后，必须释放连接。</p>
</li>
<li><p>TCP协议是一种可靠的协议。 传送的数据无差错、不丢失、不重复且顺序与与源数据一致。</p>
</li>
<li><p>TCP协议是基于IO流进行数据传输,传输数据无大小限制。 将数据拆分成不同大小的的段，也就是segment进行传输。</p>
</li>
<li><p>TCP协议的它的通信效率比较低。 TCP是面向连接的协议，传输数据之前需要建立连接,因此它的通信效率比较低。</p>
</li>
</ol>
<img src="/blog/2020/08/09/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/pic11.png" srcset="/blog/img/loading.gif" class>

<p>每部分的含义和作用 </p>
<ul>
<li><p>源端口号/目的端口号：表示数据从哪个进程来，到哪个进程去。</p>
</li>
<li><p>序号和确认号：是TCP可靠传输的关键部分。序号是本报文段发送的数据组的第一个字节的序号。 </p>
</li>
<li><p>在TCP传送的流中，每一个字节一个序号:。</p>
</li>
<li><p>TCP首部长度：由于TCP首部包含一个长度可变的选项部分，所以需要这么一个值来指定这个TCP报文段到底有多长。</p>
</li>
<li><p>URG：表示本报文段中发送的数据是否包含紧急数据。URG=1，表示有紧急数据。后面的紧急指针字段只有当URG=1时才有效。 </p>
</li>
<li><p>ACK：表示是否前面的确认号字段是否有效。ACK=1，表示有效。只有当ACK=1时，前面的确认号字段才有效。TCP规定，连接建立后，ACK必须为1。 </p>
</li>
<li><p>PSH：告诉对方收到该报文段后是否应该立即把数据推送给上层。如果为1，则表示对方应当立即把数据提交给上层，而不是缓存起来。 </p>
</li>
<li><p>RST：只有当RST=1时才有用。如果你收到一个RST=1的报文，说明你与主机的连接出现了严重错误（如主机崩溃），必须释放连接，然后再重新建立连接。或者说明你上次发送给主机的数据有问题，主机拒绝响应。 </p>
</li>
<li><p>SYN：在建立连接时使用，用来同步序号。当SYN=1，ACK=0时，表示这是一个请求建立连接的报文段；当SYN=1，ACK=1时，表示对方同意建立连接。SYN=1，说明这是一个请求建立连接或同意建立连接的报文。只有在前两次握手中SYN才置为1。 </p>
</li>
<li><p>FIN：标记数据是否发送完毕。如果FIN=1，就相当于告诉对方：“我的数据已经发送完毕，你可以释放连接了“。</p>
</li>
<li><p>窗口：滑动窗口大小，用来告知发送端接受端的缓存大小，以此控制发送端发送数据的速率，从而达到流量控制。</p>
</li>
<li><p>选项和填充：最常见的可选字段是最长报文大小，又称为MSS（Maximum Segment Size），每个连接方通常都在通信的第一个报文段（为建立连接而设置SYN标志为1的那个段）中指明这个选项，它表示本端所能接受的最大报文段的长度。选项长度不一定是32位的整数倍，所以要加填充位，即在这个字段中加入额外的零，以保证TCP头是32的整数倍。</p>
</li>
<li><p>数据部分： TCP 报文段中的数据部分是可选的。在一个连接建立和一个连接终止时，双方交换的报文段仅有 TCP 首部。如果一方没有数据要发送，也使用没有任何数据的首部来确认收到的数据。在处理超时的许多情况中，也会发送不带任何数据的报文段。 </p>
</li>
</ul>
<h5 id="TCP连接断开原理剖析"><a href="#TCP连接断开原理剖析" class="headerlink" title="TCP连接断开原理剖析"></a>TCP连接断开原理剖析</h5><ul>
<li><p>TCP连接三次握手</p>
<p>TCP协议在双方建立连接的时候需要三次握手， 所谓的三次握手即TCP连接的建立。这个连接必须是一方主动打开，另一方被动打开的。以下为客户端主动发起连接的图解：</p>
<img src="/blog/2020/08/09/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/pic12.png" srcset="/blog/img/loading.gif" class>

<p>其中比较重要的字段有： </p>
<p>SYN(synchronous建立连接)、ACK(acknowledgement 确认)、PSH(push传送)、FIN(fifinish结束)、RST(reset重置)、URG(urgent紧急)</p>
<img src="/blog/2020/08/09/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/pic13.png" srcset="/blog/img/loading.gif" class>

<p>第三次握手是为了防止服务器端开启一些无用的连接增加服务器开销以及防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。 </p>
</li>
<li><p>TCP的四次挥手</p>
<p>所谓的四次挥手即TCP连接的释放(解除)。连接的释放必须是一方主动释放，另一方被动释放。以下为客户端 </p>
<p>主动发起释放连接的图解：</p>
<img src="/blog/2020/08/09/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/pic20.png" srcset="/blog/img/loading.gif" class>

<p>其中比较重要的字段有： </p>
<p>SYN(synchronous建立连接)、ACK(acknowledgement 确认)、PSH(push传送)、FIN(fifinish结束)、RST(reset重置)、URG(urgent紧急) </p>
<img src="/blog/2020/08/09/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/pic14.png" srcset="/blog/img/loading.gif" class>

<p>客户端在TIME-WAIT阶段等待2MSL的原因：MSL指的是Maximum Segment Lifetime，一段TCP报文在传输过程中的最大生命周期。2MSL即是服务器端发出为FIN报文和客户端发出的ACK确认报文所能保持有效的最大时长</p>
</li>
</ul>
<h3 id="Socket编程与实战"><a href="#Socket编程与实战" class="headerlink" title="Socket编程与实战"></a>Socket编程与实战</h3><h4 id="从传统网络编程看BIO并发问题"><a href="#从传统网络编程看BIO并发问题" class="headerlink" title="从传统网络编程看BIO并发问题"></a>从传统网络编程看BIO并发问题</h4><h5 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h5><p>JDK提供的ServerSocket类表示我们的服务端，使用该类可以接收客户端的连接请求进而实现两端的通信。</p>
<p>ServerSocket常用方法 </p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ServerSocket</span><span class="hljs-params">()</span> <span class="hljs-comment">// 无参构造方,系统自动分配一个可用端口 (匿名端口)，服务端一般不使用 </span></span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ServerSocket</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port)</span> <span class="hljs-comment">// 构造方法,用于创建服务端对象接收客户 端连接(默认连接数为50); port指定服务端程序所占用的端口 </span></span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ServerSocket</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port, <span class="hljs-keyword">int</span> backlog)</span> <span class="hljs-comment">// 构造方法,用于创建服务端对象; port 指定服务端程序所占用的端口,backlog指定可接收的客户端数量 </span></span>
<span class="hljs-function"><span class="hljs-keyword">public</span> Socket <span class="hljs-title">accept</span><span class="hljs-params">()</span> <span class="hljs-comment">// 接收客户端连接请求(监听客户端)，如果没有客户端连接该方法阻塞。</span></span></code></pre>

<p>服务端代码实现步骤： </p>
<ol>
<li><p>创建ServerSocket对象，用于客户端连接 </p>
</li>
<li><p>调用accept方法(监听客户端)，该方法是一个阻塞方法 </p>
</li>
<li><p>调用Socket对象的方法获取输入流对象 </p>
</li>
<li><p>使用输入流对象读取数据 </p>
</li>
<li><p>释放资源 </p>
</li>
</ol>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
    <span class="hljs-comment">// 创建ServerSocket对象，用于客户端连接 </span>
    ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">8080</span>);
    <span class="hljs-comment">// 使用输入流对象读取数据</span>
    <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];
    <span class="hljs-keyword">try</span> &#123;
        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;
            <span class="hljs-comment">// 调用accept方法(监听客户端)，该方法是一个阻塞方法 </span>
            Socket accept = serverSocket.accept();
            <span class="hljs-comment">// 调用Socket对象的方法获取输入流对象</span>
            InputStream inputStream = accept.getInputStream();
            <span class="hljs-keyword">int</span> read = inputStream.read(bytes);
            System.out.println(<span class="hljs-keyword">new</span> String(bytes, <span class="hljs-number">0</span>, read));
            <span class="hljs-comment">//关闭资源 </span>
            accept.close();
        &#125;
    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
        e.printStackTrace();
    &#125; <span class="hljs-keyword">finally</span> &#123;
        <span class="hljs-keyword">if</span> (serverSocket != <span class="hljs-keyword">null</span> &amp;&amp; !serverSocket.isClosed()) &#123;
            <span class="hljs-keyword">try</span> &#123;
                serverSocket.close();
            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
                e.printStackTrace();
            &#125;

        &#125;
    &#125;
&#125;</code></pre>

<h5 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h5><p>JDK为了TCP通信提供了两个核心类：Socket(客户端)，ServerSocket(服务端)。使用Socket可以与服务端建立连接，实现数据的发送与接收。 </p>
<p>Socket中的常用方法</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Socket</span><span class="hljs-params">(String host, <span class="hljs-keyword">int</span> port)</span> <span class="hljs-comment">// 构造方法，用于和服务端建立连接;address：表示要连接的主机地址，port表示端口号</span></span>
<span class="hljs-function"><span class="hljs-keyword">public</span> OutputStream <span class="hljs-title">getOutputStream</span><span class="hljs-params">()</span> <span class="hljs-comment">// 获取输出流对象，写数据 </span></span>
<span class="hljs-function"><span class="hljs-keyword">public</span> InputStream <span class="hljs-title">getInputStream</span><span class="hljs-params">()</span> <span class="hljs-comment">// 获取输入流对象，读数据</span></span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> <span class="hljs-comment">// 释放资源</span></span></code></pre>

<p>客户端代码实现步骤： </p>
<ol>
<li><p>创建Socket对象，与服务端建立连接 </p>
</li>
<li><p>获取输出流对象 </p>
</li>
<li><p>使用输出流对象写数据 </p>
</li>
<li><p>释放资源 </p>
</li>
</ol>
<p>代码实现</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
    <span class="hljs-comment">// 创建Socket对象，与服务端建立连接</span>
    Socket socket = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-number">8080</span>);
    <span class="hljs-comment">// 获取输出流对象</span>
    OutputStream outputStream = socket.getOutputStream();
    <span class="hljs-comment">// 使用输出流对象写数据</span>
    outputStream.write(<span class="hljs-string">"itheima-TCP"</span>.getBytes());
    <span class="hljs-comment">// 释放资源</span>
    socket.close();
&#125;</code></pre>

<h5 id="三次握手剖析"><a href="#三次握手剖析" class="headerlink" title="三次握手剖析"></a>三次握手剖析</h5><p>TCP协议是面向连接的通信协议，即传输数据之前，在客户端和服务端需要建立逻辑连接，然后再传输数据。</p>
<p>客户端与服务端在进行连接建立的时候，需要经过三个步骤，这个3个步骤相当于3次握手。 </p>
<ol>
<li><p>客户端到服务端: 我要连接 </p>
</li>
<li><p>服务端到客户端: 好的，已经连接上了 </p>
</li>
<li><p>客户端到服务端: 收到，确认已连接上了 </p>
</li>
</ol>
<p>我们可以借助于一个工具wireshark来抓取TCP客户端与服务端建立连接时数据传输的过程。</p>
<p>客户端代码</p>
<pre><code class="hljs java"><span class="hljs-comment">// 创建Socket对象</span>
Socket socket = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-number">8080</span>);
<span class="hljs-comment">// 让线程休眠60s </span>
TimeUnit.SECONDS.sleep(<span class="hljs-number">60</span>);</code></pre>

<p>服务端代码</p>
<pre><code class="hljs java"><span class="hljs-comment">// 创建ServerSocket对象</span>
ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">9999</span>);
<span class="hljs-comment">// 让线程休眠60s </span>
TimeUnit.SECONDS.sleep(<span class="hljs-number">60</span>);</code></pre>

<p>首先运行服务端，然后在运行客户端，在wireshark工具中捕获完整的通信过程，结果如下图所示：</p>
<img src="/blog/2020/08/09/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/pic15.png" srcset="/blog/img/loading.gif" class>

<p>第一次”握手”如下图所示</p>
<img src="/blog/2020/08/09/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/pic16.png" srcset="/blog/img/loading.gif" class>

<p>在第一次”握手”时，客户端向服务端发送SYN标志位，目的是与服务端建立连接。Seq代表sequence number(发送数据流序号), 例如：Seq的值是5,说明在数据流中曾经一共发送了 1, 2, 3，4 这4次数据。 </p>
<p>而在本次”握手”中, Seq的值是0，代表客户端曾经没有给服务端发送数据。另外Len=0也可以看出来是没有数据可供发送的，客户端仅仅发送一个SYN标志位到服端代表要进行连接。</p>
<p>第二次”握手”如下图所示</p>
<img src="/blog/2020/08/09/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/pic17.png" srcset="/blog/img/loading.gif" class>

<p>第二次”握手”时，服务端向客户端发送 SYN ACK 标志位，其中ACK标志位表示是对收到的数据包的确认，说明服务端接收到了客户端的连接。ACK的值是1，表示服务端期待下一次从客户端发送数据流的序列号是1，而Seq=0代表服务端曾经并没有给客户端发送数据，而本次也没有发送数据，因为Len=0也证明了这一点。 </p>
<p>第三次”握手”如下图所示</p>
<img src="/blog/2020/08/09/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/pic18.png" srcset="/blog/img/loading.gif" class>

<p>第三次“握手”时，客户端向服务端发送的ACK标志位为1, Seq的值是1。Seq=l代表这正是服务端所期望的Ack=1。Len=0说明客户端这次还是没有向服务端传递数据，而客户端向服务端发送ACK 标志位为1的信息，说明客户端期待服务端下一次传送的Seq的值是1。 </p>
<h5 id="四次握手剖析"><a href="#四次握手剖析" class="headerlink" title="四次握手剖析"></a>四次握手剖析</h5><p>客户端与服务端在断开连接的时候需要进行4次”挥手”，4次”挥手”的过程如下： </p>
<ol>
<li><p>客户端到服务端：我关了 </p>
</li>
<li><p>服务端到客户端：好的，收到 </p>
</li>
<li><p>服务端到客户端：我也关了 </p>
</li>
<li><p>客户端到服务端：好的，收到 </p>
</li>
</ol>
<p>我们也可以借助于wireshark这个抓包工具来抓取连接断开的整个数据传输的过程。</p>
<p>客户端代码 </p>
<pre><code class="hljs java"><span class="hljs-comment">// 创建Socket对象</span>
Socket socket = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-number">8080</span>); 
<span class="hljs-comment">// 线程休眠 </span>
TimeUnit.SECONDS.sleep(<span class="hljs-number">10</span>); 
<span class="hljs-comment">// 关闭连接 </span>
socket.close();</code></pre>

<p>服务端代码</p>
<pre><code class="hljs java"><span class="hljs-comment">// 创建ServerSocket对象 </span>
ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">8080</span>); 
<span class="hljs-comment">// 获取连接对象 </span>
Socket socket = serverSocket.accept(); 
<span class="hljs-comment">// 线程休眠 </span>
TimeUnit.SECONDS.sleep(<span class="hljs-number">10</span>); 
<span class="hljs-comment">// 释放资源 </span>
socket.close(); 
serverSocket.close();</code></pre>

<p>首先运行服务端，然后在运行客户端，在wireshark工具中捕获完整的通信过程，结果如下图所示：</p>
<img src="/blog/2020/08/09/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/pic21.png" srcset="/blog/img/loading.gif" class>

<p>第一次”挥手”如下图所示</p>
<img src="/blog/2020/08/09/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/pic22.png" srcset="/blog/img/loading.gif" class>

<p>在第一次”挥手”时，客户端到服务器发送标志位FIN ACK,告知服务端客户端关闭了。Seq=1表示本次数据流的序号为1，Ack=1表示客户端期望服务端下一次发送的数据流的序号为1。len=0，说明没有数据传输到服务端。 </p>
<p>第二次”挥手”如下图所示</p>
<img src="/blog/2020/08/09/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/pic23.png" srcset="/blog/img/loading.gif" class>

<p>在第二次”挥手”时,服务端向客户端发送标志位ACK,Seq=1代表的正是客户端想看的Ack=1。Ack=2表示服务端期望下一次客户端发送的数据流的序号为2。len=0,说明没有数据传输到客户端。 </p>
<p>第三次”挥手”如下图所示</p>
<img src="/blog/2020/08/09/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/pic24.png" srcset="/blog/img/loading.gif" class>

<p>在第三次”挥手”时,服务端向客户端发送标志位FIN ACK,告知客户端服务端关闭了。Seq=1代表的正是客户端想看的Ack=1。Ack=2表示服务端期望下一次客户端发送的数据流的序号为2。 len=0，说明没有数据传输到客户端。 </p>
<p>第四次”挥手”如下图所示 </p>
<img src="/blog/2020/08/09/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/pic25.png" srcset="/blog/img/loading.gif" class>

<p>在第四次”挥手”时,客户端向服务端发送标志位ACK，告知服务端客户端已经收到服务端关闭信息。Seq=2代表的正是服务端想看的Ack=2，ACK=2表示客户端期望下一次服务端发送的数据流的序号为2。 </p>
<h5 id="传统网络编程延迟消息发送"><a href="#传统网络编程延迟消息发送" class="headerlink" title="传统网络编程延迟消息发送"></a>传统网络编程延迟消息发送</h5><p>服务端</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
    <span class="hljs-comment">// 创建ServerSocket对象，用于客户端连接</span>
    ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">8080</span>);
    <span class="hljs-comment">// 使用输入流对象读取数据 </span>
    <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];
    <span class="hljs-keyword">try</span> &#123;
        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;
            System.out.println(<span class="hljs-string">"发生阻塞，等待客户端连接....."</span>);
            <span class="hljs-comment">// 调用accept方法(监听客户端)，该方法是一个阻塞方法 </span>
            Socket accept = serverSocket.accept();
            <span class="hljs-comment">// 调用Socket对象的方法获取输入流对象 </span>
            InputStream inputStream = accept.getInputStream();
            System.out.println(<span class="hljs-string">"发生阻塞，等待客户端传输数据....."</span>);
            <span class="hljs-keyword">int</span> read = inputStream.read(bytes);
            System.out.println(<span class="hljs-keyword">new</span> String(bytes, <span class="hljs-number">0</span>, read));
            <span class="hljs-comment">//关闭资源 </span>
            accept.close();
        &#125;
    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
        e.printStackTrace();
    &#125; <span class="hljs-keyword">finally</span> &#123;
        <span class="hljs-keyword">if</span> (serverSocket != <span class="hljs-keyword">null</span> &amp;&amp; !serverSocket.isClosed()) &#123;
            <span class="hljs-keyword">try</span> &#123;
                serverSocket.close();
            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
&#125;</code></pre>

<p>客户端</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
    <span class="hljs-comment">// 创建Socket对象，与服务端建立连接</span>
    Socket socket = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-number">8080</span>);
    <span class="hljs-comment">// 获取输出流对象 </span>
    OutputStream outputStream = socket.getOutputStream();
    System.out.println(<span class="hljs-string">"客户端阻塞,接受键盘录入..."</span>);
    <span class="hljs-comment">//接受键盘输入，模拟延迟发送消息 </span>
    Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);
    String scannerString = scanner.next();
    <span class="hljs-comment">// 使用输出流对象写数据 </span>
    outputStream.write(scannerString.getBytes());
    System.out.println(<span class="hljs-string">"客户端完成录入..."</span>);
    <span class="hljs-comment">// 释放资源 </span>
    socket.close();
&#125;</code></pre>

<p>存在的问题： 如果客户端已经连接服务端，但尚未发送数据，read阻塞会阻塞当前线程，新的客户端将无法正常连接。</p>
<p>解决方法</p>
<ol>
<li><p>线程解决</p>
</li>
<li><p>线程池解决</p>
</li>
<li><p>NIO解决 </p>
</li>
<li><p>websocket解决</p>
</li>
</ol>
<h4 id="基于NIO多路复用解决并发问题"><a href="#基于NIO多路复用解决并发问题" class="headerlink" title="基于NIO多路复用解决并发问题"></a>基于NIO多路复用解决并发问题</h4><h5 id="NIO简述"><a href="#NIO简述" class="headerlink" title="NIO简述"></a>NIO简述</h5><p>特点： </p>
<ol>
<li><p>NIO是New IO的简称，是JDK1.4提出的一种新的IO模型，NIO所提供的类是在java.nio包中。 </p>
</li>
<li><p>JAVA API中提供了两套NIO: 一套是针对文件操作的NIO，另一套就是网络编程的NIO </p>
</li>
<li><p>NIO是一种非阻塞式IO </p>
</li>
</ol>
<p>核心的部分 </p>
<p>JAVA NIO中最为核心的部分：Buffer(缓冲区) ， Channel(通道) 。在网络编程的NIO模型中，还有一个核心部分：Selector（选择器） </p>
<ol>
<li><p>Buffer(缓冲区)</p>
<p>缓冲区分为直接缓冲区和堆字节缓冲区。 </p>
<p>我们既可以从Buffer中读取数据，也可以向Buffer中写数据，因此， Buffer分为两种模式：写模式和读模式。为了理解Buffer的工作原理，需要熟悉它的三个属性： </p>
<ul>
<li>capacity（容量）</li>
<li>position（位置）</li>
<li>limit（限制）</li>
</ul>
<p>写模式</p>
<img src="/blog/2020/08/09/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/pic26.png" srcset="/blog/img/loading.gif" class>

<ul>
<li>capacity：数组中可以存储元素的个数。</li>
<li>position：下一次可插入元素的位置，默认值为0，每添加一次元素向后移动一位。最大值：capacity - 1</li>
<li>limit：在写模式下，limit表示第一个不可写的位置（默认第一个不可写的位置，应该是数组容量值的下一个位置，limit是从0开始计算，因此默认值等于capacity的值）。</li>
</ul>
<p>读模式</p>
<img src="/blog/2020/08/09/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/pic27.png" srcset="/blog/img/loading.gif" class>

<ul>
<li>capacity：数组中可以存储元素的个数</li>
<li>position：当读取数据时，也是从某个特定位置读。当将Buffer从写模式切换到读模式（一般情况下我们在进行读取数据之前都需要对Buffer做一个读写转换），position会被重置为0。当从Buffer的position处读取数据时，position向前移动到下一个可读的位置。 </li>
<li>limit：在读模式下，limit表示第一个不可读的位置，从0开始进行计算。当切换Buffer到读模式 时，limit会被设置成写模式下的position值。换句话说，你能读到之前写入的所有数据；</li>
</ul>
</li>
<li><p>Channel(通道) </p>
<p>Java NIO的通道类似流(用于进行数据传输)，但和流是不同的。 </p>
<p>区别：通道是双向的，而流是单向的(大部分流对象的功能都是比较单一，要么进行读数据要么进行写数据)。 </p>
<p>通道使用的时候需要结合Buffffer。要将操作的数据从源打包到缓冲区中，而缓冲区中的数据想要传输到目的地是要依赖于通道的。NIO 技术中的数据要放在缓区中进行管理，再使用通道将缓冲区中的数据传输到目的地。通道中的数据总是要先读到一个Buffffer(从通道读取数据到缓冲区)，或者总是要从一个Buffffer中写入(从缓冲区写入数据到通道)。如下图所示： </p>
<img src="/blog/2020/08/09/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/pic28.png" srcset="/blog/img/loading.gif" class>
</li>
<li><p>Selector(选择器) </p>
<p>每一个通道都存在一个线程对其进行处理。如果在高并发环境下，就会存在很多个通道，那么就会创建很多的线程对象，造成内存占用率升高，增加CPU在多个线程之间切换的时间，因此，此种设计就不适用于高并发的场景。如下图所示：</p>
<img src="/blog/2020/08/09/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/pic29.png" srcset="/blog/img/loading.gif" class>

<img src="/blog/2020/08/09/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/pic30.png" srcset="/blog/img/loading.gif" class>

<p>这种通过一个线程来处理多个通道任务的机制，在NIO技术中称为”IO多路复用”。 </p>
<p>使用了I/O多路复用后，只需要使用1个线程就可操作多个通道，这对高并发高频段处理的业务环境有非常重要的优势。注：线程数会随着通道的多少动态地增减以进行适配，在内部其实并不永远是一个线程，多路复用的核心目的就是使用最少的线程去操作更多的通道JDK的源代码中，创建线程的个数是根据通道的数量来决定的，每注册1023个通道就创建1个新的线程。</p>
</li>
</ol>
<h5 id="NIO多路复用解决BIO并发"><a href="#NIO多路复用解决BIO并发" class="headerlink" title="NIO多路复用解决BIO并发"></a>NIO多路复用解决BIO并发</h5><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
    <span class="hljs-comment">// 打开一个ServerSocketChannel通道</span>
    ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
    <span class="hljs-comment">// 为ServerSocketChannel绑定地址信息(主机地址和端口号)</span>
    serverSocketChannel.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-number">8080</span>));
    <span class="hljs-comment">// 设置ServerSocketChannel为非阻塞</span>
    serverSocketChannel.configureBlocking(<span class="hljs-keyword">false</span>);
    <span class="hljs-comment">// 开启一个选择器</span>
    Selector selector = Selector.open();
    <span class="hljs-comment">// 将ServerSocketChannel通道注册到选择器上</span>
    <span class="hljs-comment">// SelectionKey.OP_ACCEPT接收连接进行事件，表示服务器监听到了客户连接，那么服务器可 以接收这个连接了</span>
    serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
    <span class="hljs-comment">// 需要不断的进行选择操作，选择哪些具有就绪任务的通道信息</span>
    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;
        System.out.println(<span class="hljs-string">"等待连接，阻塞中...."</span>);
        <span class="hljs-comment">// 调用选择器select()方法进行选择操作</span>
        <span class="hljs-keyword">int</span> count = selector.select();
        <span class="hljs-comment">// 此方法是一个阻塞方法，如果没有就绪 任务的通道此方法阻塞</span>
        <span class="hljs-keyword">if</span> (count != <span class="hljs-number">0</span>) &#123;
            <span class="hljs-comment">// 调用Selector的selectedKeys()方法，获取"已选择的键的集合"</span>
            Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();
            <span class="hljs-comment">// 遍历集合</span>
            Iterator&lt;SelectionKey&gt; iterator = selectedKeys.iterator();
            <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;
                <span class="hljs-comment">// 获取每一个SelectionKey</span>
                SelectionKey selectionKey = iterator.next();
                <span class="hljs-comment">// 判断每一个SelectionKey的就绪任务类型，针对不同的任务给出不同的处理 方案</span>
                <span class="hljs-keyword">if</span> (selectionKey.isAcceptable()) &#123;
                    <span class="hljs-comment">// 可接收连接任务就绪 </span>
                    System.out.println(<span class="hljs-string">"客户端连接成功，但尚未发送数据"</span>);
                    <span class="hljs-comment">// 获取该SelectionKey所关联的通道</span>
                    ServerSocketChannel ssc = (ServerSocketChannel) selectionKey.channel();
                    SocketChannel socketChannel = ssc.accept();
                    <span class="hljs-comment">// 获取一个连接 </span>
                    socketChannel.configureBlocking(<span class="hljs-keyword">false</span>);
                    <span class="hljs-comment">// 将其设置为非阻塞 </span>
                    <span class="hljs-comment">// 将该通道注册到选择器上，读就绪事件，表示通道中已经有了可读的数 据，可以执行读操作了 </span>
                    socketChannel.register(selector, SelectionKey.OP_READ);
                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (selectionKey.isReadable()) &#123;
                    <span class="hljs-comment">// 可读取数据的任务就 绪 </span>
                    System.out.println(<span class="hljs-string">"客户端成功发送数据"</span>);
                    <span class="hljs-comment">// 获取该SelectionKey所关联的通道 </span>
                    SocketChannel socketChannel = (SocketChannel) selectionKey.channel();
                    <span class="hljs-comment">// 读取通道中的数据</span>
                    ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);
                    <span class="hljs-keyword">int</span> read = socketChannel.read(buffer);
                    <span class="hljs-keyword">while</span> (read &gt; <span class="hljs-number">0</span>) &#123;
                        <span class="hljs-comment">// 将Buffer从写模式切换到读模式 </span>
                        buffer.flip();
                        System.out.print(<span class="hljs-keyword">new</span> String(buffer.array(), <span class="hljs-number">0</span>, read));
                        <span class="hljs-comment">//清除此缓冲区(数据还在)。位置设置为零，限制设置为容量</span>
                        buffer.clear();
                        read = socketChannel.read(buffer);
                    &#125;
                    <span class="hljs-comment">// 释放资源 </span>
                    socketChannel.close();
                &#125;
                <span class="hljs-comment">// 任务处理完毕以后，将SelectionKey从"已选择的键的集合"移除掉</span>
                iterator.remove();
            &#125;
        &#125;
    &#125;
&#125;</code></pre>
            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/blog/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">网络编程</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/blog/tags/TCP-IP/">TCP/IP</a>
                    
                      <a class="hover-with-bg" href="/blog/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">网络协议</a>
                    
                      <a class="hover-with-bg" href="/blog/tags/NIO/">NIO</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/blog/2020/08/14/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">网络安全</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/blog/2020/08/08/netty-%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">
                        <span class="hidden-mobile">Netty源码剖析</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/blog/js/debouncer.js" ></script>
<script  src="/blog/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/blog/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/blog/js/clipboard-use.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '#post-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "网络编程&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/blog/js/local-search.js" ></script>
  <script>
    var path = "/blog/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>







  
  
    <script type="text/javascript">
      //定义获取词语下标
      var a_idx = 0;
      jQuery(document).ready(function ($) {
        //点击body时触发事件
        $("body").click(function (e) {
          //需要显示的词语
          var a = new Array("富强", "民主", "文明", "和谐", "自由", "平等", "公正", "法治", "爱国", "敬业", "诚信", "友善");
          //设置词语给span标签
          var $i = $("<span/>").text(a[a_idx]);
          //下标等于原来下标+1  余 词语总数
          a_idx = (a_idx + 1) % a.length;
          //获取鼠标指针的位置，分别相对于文档的左和右边缘。
          //获取x和y的指针坐标
          var x = e.pageX, y = e.pageY;
          //在鼠标的指针的位置给$i定义的span标签添加css样式
          $i.css({
            "z-index": 999,
            "top": y - 20,
            "left": x,
            "position": "absolute",
            "font-weight": "bold",
            "color": rand_color()
          });
          // 随机颜色
          function rand_color() {
            return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"
          }
          //在body添加这个标签
          $("body").append($i);
          //animate() 方法执行 CSS 属性集的自定义动画。
          //该方法通过CSS样式将元素从一个状态改变为另一个状态。CSS属性值是逐渐改变的，这样就可以创建动画效果。
          //详情请看http://www.w3school.com.cn/jquery/effect_animate.asp
          $i.animate({
            //将原来的位置向上移动180
            "top": y - 180,
            "opacity": 0
            //1500动画的速度
          }, 1500, function () {
            //时间到了自动删除
            $i.remove();
          });
        });
      })
      ;
    </script>
  














</body>
</html>
