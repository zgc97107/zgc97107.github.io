

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/blog/img/favicon.png">
  <link rel="icon" type="image/png" href="/blog/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="">
  <meta name="keywords" content="">
  <title>网络安全 - 🍎🍊&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/blog/lib/hint/hint.min.css" />

  
    
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_6peoq002giu.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/blog/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/blog/js/utils.js" ></script>
  <script  src="/blog/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/blog/">&nbsp;<strong>🍎🍊's blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/">
                <i class="iconfont icon-home-fill"></i>
                主页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/blog/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container page-header text-center fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-08-14 15:03" pubdate>
      2020年8月14日 下午
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      4.3k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      48
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" id="post">
            <!-- SEO header -->
            <h1 style="display: none">网络安全</h1>
            
            <div class="markdown-body" id="post-body">
              <h3 id="HTTPS超文本传输安全协议"><a href="#HTTPS超文本传输安全协议" class="headerlink" title="HTTPS超文本传输安全协议"></a>HTTPS超文本传输安全协议</h3><h4 id="HTTP协议回顾"><a href="#HTTP协议回顾" class="headerlink" title="HTTP协议回顾"></a>HTTP协议回顾</h4><p>HTTP 协议于 1991 年引入，至今已有近 30 年的历史。自第一个文档化版本 (后来称为 0.9) 以来，它已经经历了一段相当长的历程（5年）。 HTTP 的第一个版本只能传输超文本标记语言 (HTML) 文件，因此我们称之为超文本传输协议。 </p>
<p>超文本传输协议是一个基于请求与响应，无状态的，应用层的协议 。基于TCP/IP协议传输（明文）数据，互联网上应用最为广泛的一种网络协议,所有的WWW都必须遵守这个标准。 </p>
<p>我们使用浏览器访问一个网站页面，在浏览器的地址栏中我们会看到一串URL，域名地址都很好理解，不同的域名地址表示网站中不同的页面，而通信协议，简单来说就是浏览器和服务器之间沟通的语言。 </p>
<h4 id="HTTP发展历程"><a href="#HTTP发展历程" class="headerlink" title="HTTP发展历程"></a>HTTP发展历程</h4><p>1997 年发布的 HTTP/1.1 引入了一些其它的改进。除了添加像 OPTIONS 这样的方法外，它还引入了Keep-Alive 头。它允许一个连接对多个 HTTP 请求保持打开状态。因为这点，连接不必在每次请求之后关闭，然后再重新打开。 </p>
<p>HTTP 2.0拥有更优异的表现，现在网络变得的复杂，甚至演变成了独有的应用，媒体的播放量，增进交互的脚本大小也增加了许多，更多的数据通过HTTP请求被传输，由此HTTP 2.0为网络效率做了大量的优化。</p>
<img src="/blog/2020/08/14/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/pic1.png" srcset="/blog/img/loading.gif" class>

<blockquote>
<p>tips： </p>
<p>HTTP 3.0 目前处于制订和测试阶段，是未来的全新的 HTTP 协议， HTTP 3.0 协议运行在 QUIC 协议之上，是在 UDP 的基础上实现了可靠传输</p>
<p>HTTP 3.0 不是 HTTP 2.0 的拓展， HTTP 3.0 将会是一个全新的协议 </p>
</blockquote>
<p>总结</p>
<ol>
<li><p>HTTP协议始于1989年蒂姆·伯纳斯-李的一篇论文 </p>
</li>
<li><p>HTTP/0.9是个简单的文本协议,只能获取文本资源(get获取纯文本) </p>
</li>
<li><p>HTTP/1.0确立了现在使用的大部分技术,但不是正式标准 </p>
</li>
<li><p>HTTP/1.1是目前互联网使用最为广泛的协议,功能也非常完善(第一个标准文档). </p>
</li>
<li><p>HTTP/2基于Google的SPDY协议,注重性能改善,但还未普及 </p>
</li>
<li><p>HTTP/3基于Google的QUIC协议,是将来的发展方向 </p>
</li>
</ol>
<img src="/blog/2020/08/14/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/pic2.png" srcset="/blog/img/loading.gif" class>

<img src="/blog/2020/08/14/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/pic4.png" srcset="/blog/img/loading.gif" class>

<h4 id="HTTPS与HTTP的区别"><a href="#HTTPS与HTTP的区别" class="headerlink" title="HTTPS与HTTP的区别"></a>HTTPS与HTTP的区别</h4><p>HTTPS协议可以理解为HTTP协议的升级，就是在HTTP的基础上增加了数据加密。在数据进行传输之前，对数 </p>
<p>据进行加密，然后再发送到服务器。这样，就算数据被第三者所截获，但是由于数据是加密的，所以你的个人 </p>
<p>信息让然是安全的。 </p>
<p>这就是HTTP和HTTPS的最大区别。 </p>
<img src="/blog/2020/08/14/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/pic3.png" srcset="/blog/img/loading.gif" class>

<p>其他区别：</p>
<ol>
<li><p>https协议需要申请CA,证书,http不需要证书 </p>
</li>
<li><p>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl/tls加密传输协议。 </p>
</li>
<li><p>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 </p>
</li>
<li><p>http的连接很简单，是无状态的；HTTPS协议是由SSL/TLS+HTTP协议构建的加密传输 </p>
</li>
<li><p>http直接与四层交互，https先给安全层交互，然后在与四层交互 </p>
</li>
</ol>
<h3 id="加密原理与算法剖析"><a href="#加密原理与算法剖析" class="headerlink" title="加密原理与算法剖析"></a>加密原理与算法剖析</h3><h4 id="加密原理介绍"><a href="#加密原理介绍" class="headerlink" title="加密原理介绍"></a>加密原理介绍</h4><img src="/blog/2020/08/14/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/pic5.png" srcset="/blog/img/loading.gif" class>

<p>简单理解</p>
<img src="/blog/2020/08/14/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/pic6.png" srcset="/blog/img/loading.gif" class>

<p>如上图所示 HTTPS 相比 HTTP 多了一层 SSL/TLS</p>
<img src="/blog/2020/08/14/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/pic7.png" srcset="/blog/img/loading.gif" class>

<p><strong>TLS（Transport Layer Security，传输层安全）：</strong> </p>
<p>其前身是 SSL，它最初的几个版本（SSL 1.0、SSL 2.0、SSL 3.0）由网景公司开发1999年从 3.1 开始被 IETF 标准化并改名，发展至今已经有 TLS 1.0、TLS 1.1、TLS 1.2 三个版本。 </p>
<p>TLS 1.3 改动会比较大，目前还未大规模推广，目前使用最广泛的是TLS 1.2 </p>
<h4 id="加密后通信流程"><a href="#加密后通信流程" class="headerlink" title="加密后通信流程"></a>加密后通信流程</h4><p>客户端在使用HTTPS方式与Web服务器通信时的步骤 </p>
<p>访问<a href="http://www.taobao.com" target="_blank" rel="noopener">www.taobao.com</a></p>
<img src="/blog/2020/08/14/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/pic8.png" srcset="/blog/img/loading.gif" class>

<h4 id="加密算法剖析"><a href="#加密算法剖析" class="headerlink" title="加密算法剖析"></a>加密算法剖析</h4><p>要建立一个密码体制，需要由五个空间组成，分别是： </p>
<ul>
<li><p>明文M：加密前或解密后的信息； </p>
</li>
<li><p>密文C：明文加密后的信息； </p>
</li>
<li><p>密钥K：由加密密钥和解密密钥组成； </p>
</li>
<li><p>加密E：从明文到密文的变换； </p>
</li>
<li><p>解密D：从密文到明文的变换 </p>
</li>
</ul>
<img src="/blog/2020/08/14/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/pic9.png" srcset="/blog/img/loading.gif" class>

<h5 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h5><p>也叫单钥加密，是指加密密钥和解密密钥相同的加密方式。 </p>
<p>对称加密的主要优势是：加密、解密运算速度快，效率高； </p>
<p>代表算法：AES算法、DES算法、RC4，3DES 、Triple-DES, RC2等； </p>
<p>特点： </p>
<ol>
<li><p>发送端和接收端共享相同的密钥才能通信，一定程度上保证了安全。 </p>
</li>
<li><p>对于枚举攻击，密码长度越长越难以破解 </p>
</li>
</ol>
<p>对称加密经典应用： </p>
<p>0010101010101010 明文 </p>
<p>0001010001001011 秘钥 </p>
<p>0011111011100001 密文（异或后） </p>
<p>0010101010101010 明文（解密后）</p>
<h5 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h5><p>加密使用的密钥和解密使用的密钥是不相同的，分别称为：公钥、私钥，公钥和算法都是公开的，私钥是保密的。 </p>
<p>非对称加密算法性能较低，但是安全性超强，由于其加密特性，非对称加密算法能加密的数据长度也是有限的。 </p>
<p>例如：RSA、DSA、ECDSA、 DH、ECDHE </p>
<p>局限性：加密、解密运算效率较低； </p>
<p>非对称加密算法：RSA，DSA（有一个公匙和一个私匙） </p>
<p>特点： </p>
<ol>
<li><p>编码密钥众所周知，但只有特定主机才知道私有解码密钥，解码密钥保密，保证了传输安全。 </p>
</li>
<li><p>所有的想向主机发送报文的人都可以使用相同的编码密钥，解决了对称加密密钥数量多管理不便的问题。 </p>
</li>
</ol>
<h5 id="对称、非对称区别"><a href="#对称、非对称区别" class="headerlink" title="对称、非对称区别"></a>对称、非对称区别</h5><p>对称加密算法相比非对称加密算法来说，加解密的效率要高得多。但是缺陷在于对于秘钥的管理上，以及在非安全信道中通讯时，密钥交换的安全性不能保障。所以在实际的网络环境中，会将两者混合使用. </p>
<img src="/blog/2020/08/14/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/pic10.png" srcset="/blog/img/loading.gif" class>

<h5 id="散列算法（或音译为哈希）"><a href="#散列算法（或音译为哈希）" class="headerlink" title="散列算法（或音译为哈希）"></a>散列算法（或音译为哈希）</h5><p>Hash算法特别的地方在于它是一种单向（输出不依赖于输入）算法，用户可以通过hash算法对目标信息生成一段特定长度的唯一hash值，却不能通过这个hash值重新获得目标信息。 </p>
<p>因此Hash算法常用在不可还原的密码存储、信息完整性校验等。 </p>
<p>将任意长度的信息转换为较短的固定长度的值，通常其长度要比信息小得多，且算法不可逆。 例如：MD5、SHA-1、SHA-2、SHA-256 等 </p>
<p>信息-摘要算法 </p>
<p>MD5 (“ADSFASFA”)=SSSSSS </p>
<p>把一个不定长的数据通过摘要算法处理成一个定长的数据</p>
<h4 id="HTTPS协议SSL加密解密流程"><a href="#HTTPS协议SSL加密解密流程" class="headerlink" title="HTTPS协议SSL加密解密流程"></a>HTTPS协议SSL加密解密流程</h4><h5 id="加密解密流程"><a href="#加密解密流程" class="headerlink" title="加密解密流程"></a>加密解密流程</h5><img src="/blog/2020/08/14/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/pic11.png" srcset="/blog/img/loading.gif" class>

<h5 id="会话密钥生成流程详解（重要）"><a href="#会话密钥生成流程详解（重要）" class="headerlink" title="会话密钥生成流程详解（重要）"></a>会话密钥生成流程详解（重要）</h5><p>以上第1、2、4部分【生成的key或者随机值】是核心中的核心 </p>
<p>也就是3次随机数生成会话秘钥的的过程 </p>
<p>重点在说下</p>
<img src="/blog/2020/08/14/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/pic12.png" srcset="/blog/img/loading.gif" class>

<p>三个随机数： </p>
<ol>
<li><p>客户端给出协议版本号，一个随机数（client random），以及客户端支持的加密方式 </p>
</li>
<li><p>服务端确认双方使用的加密方式，并给出数字证书，以及一个服务器生成的随机数（server random） </p>
</li>
<li><p>客户端确认证书有效，然后生成一个新的46字节随机数（称为预备主密钥premaster secret），使用数字证书的公钥加密这个随机数，发送给服务端 </p>
</li>
</ol>
<p>总结：</p>
<p>服务端用非对称加密算法RSA生成公钥和私钥，把公钥放在证书里发送给客户端，私钥自己保存。</p>
<p>客户端接收到公钥后，首先向一个权威的服务器检查证书的合法性，如果证书合法，客户端产生一段随机数，这个随机数就作为通信的密钥，我们称之为对称密钥，用公钥加密这段随机数，然后发送到服务器。</p>
<p>服务器用密钥解密获取对称密钥，然后，双方就已对称密钥进行加密解密通信了 </p>
<h5 id="CA证书"><a href="#CA证书" class="headerlink" title="CA证书"></a>CA证书</h5><p>CA证书顾名思义就是由CA（Certifification Authority，也叫“证书授权中心”）机构发布的数字证书 。</p>
<p>X.509规范中一般推荐使用PEM格式来存储证书相关的文件。证书文件的文件名后缀一般为.crt或.cer对应私钥文件的文件名后缀一般为.key。证书请求文件的文件名后綴为.csr。有时候也统一用pem作为文件名后缀。</p>
<p>编码格式总结: </p>
<ul>
<li><p>X.509 标准DER(Distinguished Encoding Rules)编码，后缀为：.der .cer .crt </p>
</li>
<li><p>X.509 BASE64编码(PEM格式)，后缀为：.pem .cer .crt </p>
</li>
</ul>
<p>CA证书具体包括以下内容 </p>
<ul>
<li><p>颁发者 </p>
</li>
<li><p>使用者 </p>
</li>
<li><p>版本</p>
</li>
<li><p>签名算法 </p>
</li>
<li><p>签名哈希算法 </p>
</li>
<li><p>使用者 </p>
</li>
<li><p>公钥</p>
</li>
<li><p>指纹</p>
</li>
<li><p>指纹算法 </p>
</li>
<li><p>….. </p>
</li>
</ul>
<p>证书策略 </p>
<p>由对象标识符和限定符组成，这些对象标识符说明证书的颁发和使用策略有关</p>
<p>X509v3 Certifificate Policies: </p>
<p>​    Policy: 1.3.6.1.4.1.4146.1.20 </p>
<p>​    CPS: <a href="https://www.globalsign.com/repository/" target="_blank" rel="noopener">https://www.globalsign.com/repository/</a> </p>
<p>​    Policy: 2.23.140.1.2.2</p>
<img src="/blog/2020/08/14/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/pic13.png" srcset="/blog/img/loading.gif" class>

<p>版本号（Version Number）：CA证书一个规范的版本号，目前为版本3，值为0x2； </p>
<p>序列号（Serial Number）：由CA维护的，为它所发的每个证书分配一个序列号，用来追踪和撤销证书。只要拥有签发者信息和序列号，就可以唯一标识一个证书，最大不能过20个字节； </p>
<p>签名算法（Signature Algorithm）：数字签名所采用的算法，如： </p>
<ul>
<li><p>sha256-with-RSA-Encryption </p>
</li>
<li><p>ccdsa-with-SHA2S6； </p>
</li>
</ul>
<p>颁发者（Issuer）：发证书单位的标识信息，如 ” C=CN，ST=Beijing, L=Beijing, O=org.example.com，CN=ca.org。example.com ”； </p>
<p>有效期（Validity）：证书的有效期很，包括起止时间。</p>
<img src="/blog/2020/08/14/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/pic14.png" srcset="/blog/img/loading.gif" class>

<img src="/blog/2020/08/14/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/pic15.png" srcset="/blog/img/loading.gif" class>

<img src="/blog/2020/08/14/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/pic16.png" srcset="/blog/img/loading.gif" class>

<p>服务器提供服务器的公钥给ca机构，生成证书，证书一般包含以下内容：</p>
<ul>
<li><p>Issuer (证书的发布机构)</p>
</li>
<li><p>Valid from , Valid to (证书的有效期)</p>
</li>
<li><p>Public key (公钥)</p>
</li>
<li><p>Subject (主题，使用者)</p>
</li>
<li><p>Signature algorithm (签名所使用的算法)</p>
</li>
<li><p>Thumbprint, Thumbprint algorithm (指纹以及指纹算法) </p>
</li>
</ul>
<p>生成证书的过程一般是：把Issuer (证书的发布机构),Public key (公钥),Subject (主题),Valid from,Valid to(证书的有效期)等信息以明文的形式写到证书里面作为内容，然后用一个指纹算法（淘宝是sha1）计算出这些数字证书内容的一个指纹（也就是签名），并把指纹和指纹算法用自己的私钥进行加密，然后生成证书。</p>
<h3 id="SSL-TLS实战与开发"><a href="#SSL-TLS实战与开发" class="headerlink" title="SSL/TLS实战与开发"></a>SSL/TLS实战与开发</h3><h4 id="WebSocket实战与应用"><a href="#WebSocket实战与应用" class="headerlink" title="WebSocket实战与应用"></a>WebSocket实战与应用</h4><h5 id="websocket通信"><a href="#websocket通信" class="headerlink" title="websocket通信"></a>websocket通信</h5><img src="/blog/2020/08/14/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/pic17.png" srcset="/blog/img/loading.gif" class>

<ol>
<li><p>发送连接请求 </p>
<p>客户端通过一个格式为：ws://host:port/的请求地址发起WebSocket连接请求，并由JavaScript实现WebSocket API与服务器建立WebSocket连接，其中host为服务器主机IP地址或域名，port为端口。 </p>
</li>
<li><p>握手</p>
<p>当服务器收到请求后，会解析请求头信息，根据升级后的协议判断该请求为WebSocket请求，并取出请求信息中的Sec-WebSocket-Key字段的数据按照某种算法重新生成一个新的字符串序列放入响应头Sec-WebSocket-Accept中</p>
<p>Sec-WebSocket-Accept：服务器接受客户端HTTP协议升级的证明</p>
</li>
<li><p>WebSocket建立连接客户端接收服务器的响应后，同样会解析请求头信息，取出请求信息中的Sec-WebSocket-Accept字段，并用服务器内部处理Sec-WebSocket-Key字段的算法处理之前发送的Sec-WebSocket-Key，把处理得到的结果与Sec-WebSocket-Accept进行对比，数据相同则表示客户端与服务器成功建立WebSocket连接，反之失败 </p>
</li>
</ol>
<p>传统HTTP客户端与服务器请求响应模式如下图所示</p>
<img src="/blog/2020/08/14/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/pic18.png" srcset="/blog/img/loading.gif" class>

<p>上图对比可以看出，相对于传统HTTP每次请求-应答都需要客户端与服务端建立连接的模式，WebSocket是类似Socket的TCP长连接通讯模式。一旦WebSocket连接建立后，后续数据都以帧序列的形式传输。 </p>
<h5 id="WebSocket与HTTP的关系"><a href="#WebSocket与HTTP的关系" class="headerlink" title="WebSocket与HTTP的关系"></a>WebSocket与HTTP的关系</h5><p>WebSocket就像HTTP一样，是一个典型的应用层协议。 </p>
<p>Socket是传输控制层接口，WebSocket是应用层协议。 </p>
<p>相同点： </p>
<ol>
<li><p>都是一样基于TCP的，都是可靠性传输协议。 </p>
</li>
<li><p>都是应用层协议。 </p>
</li>
</ol>
<p>不同点： </p>
<ol>
<li><p>WebSocket是双向通信协议，模拟Socket协议，可以双向发送或接受信息。HTTP是单向的。 </p>
</li>
<li><p>WebSocket是需要浏览器和服务器握手进行建立连接的。而http是浏览器发起向服务器的连接，服务器预先并不知道这个连接。 </p>
</li>
<li><p>WebSocket在建立握手时，数据是通过HTTP传输的。但是建立之后，在真正传输时候是不需要HTTP协议的。 </p>
</li>
<li><p>在WebSocket中，只需要服务器和浏览器通过HTTP协议进行一个握手的动作，然后单独建立一条TCP的通信通道进行数据的传送。</p>
</li>
</ol>
<h5 id="ws请求"><a href="#ws请求" class="headerlink" title="ws请求"></a>ws请求</h5><p>WebSocket利用了HTTP协议来建立连接，它的目的是在浏览器和服务器之间建立一个不受限的双向通信的通道，比如说，服务器可以在任意时刻发送消息给浏览器。</p>
<p>WebSocket连接必须由浏览器发起，因为请求协议是一个标准的HTTP请求， 比如下面的请求头，但比http请求多了几个字段</p>
<img src="/blog/2020/08/14/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/pic20.png" srcset="/blog/img/loading.gif" class>

<p>该请求和普通的HTTP请求有几点不同： </p>
<ol>
<li><p>GET请求的地址不是类似/http/，而是以ws://开头的地址； </p>
</li>
<li><p>请求头Upgrade:websocket和Connection: Upgrade表示这个连接将要被转换为WebSocket连接； </p>
</li>
<li><p>Sec-WebSocket-Key是由浏览器随机生成的，是用于标识这个连接，并非用于加密数据； </p>
</li>
<li><p>Sec-WebSocket-Version指定了WebSocket的协议版本 </p>
</li>
<li><p>Sec-WebSocket-Extensions请求扩展 </p>
</li>
</ol>
<img src="/blog/2020/08/14/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/pic19.png" srcset="/blog/img/loading.gif" class>

<h5 id="ws响应"><a href="#ws响应" class="headerlink" title="ws响应"></a>ws响应</h5><p>General是一个 http 请求以及响应，这里的 general 可以理解成为 http 请求和响应的请始行的一个公共部分</p>
<p>101 状态码表示服务器已经理解了客户端的请求，并将通过 Upgrade 消息头通知客户端采用不同的协议来完成这个请求； </p>
<img src="/blog/2020/08/14/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/pic21.png" srcset="/blog/img/loading.gif" class>

<img src="/blog/2020/08/14/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/pic22.png" srcset="/blog/img/loading.gif" class>

<p>响应代码101表示本次连接的HTTP协议即将被更改，更改后的协议就是Upgrade: websocket指定的WebSocket协议。 </p>
<p>版本号和子协议规定了双方能理解的数据格式，以及是否支持压缩等等。如果仅使用WebSocket的API，就不需关心这些。</p>
<h4 id="自签名证书HTTPS开发"><a href="#自签名证书HTTPS开发" class="headerlink" title="自签名证书HTTPS开发"></a>自签名证书HTTPS开发</h4><h5 id="SSL证书生成"><a href="#SSL证书生成" class="headerlink" title="SSL证书生成"></a>SSL证书生成</h5><p>JDK中keytool是一个证书管理工具，可以生成自签名证书</p>
<p><code>keytool -genkey -alias czbk -keypass 123456 -keyalg RSA -keysize 1024 -validity 365 -keystore c:/czbk.keystore -storepass 123456</code></p>
<p>下面内容可以全部一样</p>
<img src="/blog/2020/08/14/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/pic23.png" srcset="/blog/img/loading.gif" class>

<p>查看生成结果 </p>
<img src="/blog/2020/08/14/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/pic24.png" srcset="/blog/img/loading.gif" class>

<p>后续使用，将生成文件复制到spring boot项目中的resources目录中</p>
<p>命令解释：</p>
<pre><code class="hljs sh">keytool
-genkey 
-<span class="hljs-built_in">alias</span> tomcat(别名) 
-keypass 123456(别名密码) 
-keyalg RSA(生证书的算法名称，RSA是一种非对称加密算法) 
-keysize 1024(密钥长度,证书大小) 
-validity 365(证书有效期，天单位) 
-keystore c:/czbk.keystore(指定生成证书的位置和证书名称) 
-storepass 123456(获取keystore信息的密码) 
- storetype (指定密钥仓库类型)</code></pre>

<h5 id="springboot集成SSL"><a href="#springboot集成SSL" class="headerlink" title="springboot集成SSL"></a>springboot集成SSL</h5><p>将xxx.keystore拷贝到项目src/java/resources目录下.配置application.properties</p>
<pre><code class="hljs properties"><span class="hljs-comment"># 端口 </span>
<span class="hljs-meta">http.port</span>=<span class="hljs-string">7777 </span>
<span class="hljs-meta">server.port</span>=<span class="hljs-string">8888 </span>
<span class="hljs-comment"># 指定签名文件，对应生成的密钥库文件 </span>
<span class="hljs-meta">server.ssl.key-store</span>=<span class="hljs-string">classpath:czbk.keystore </span>
<span class="hljs-comment"># 指定签名密码，设置的密钥库指令 </span>
<span class="hljs-meta">server.ssl.key-store-password</span>=<span class="hljs-string">123456 </span>
<span class="hljs-comment"># 指定密钥仓库类型，JKS </span>
<span class="hljs-meta">server.ssl.key-store-type</span>=<span class="hljs-string">JKS </span>
<span class="hljs-comment"># 指定别名，生成密钥库的时候进行了设定 </span>
<span class="hljs-meta">server.ssl.key-alias</span>=<span class="hljs-string">czbk</span></code></pre>

<p>将czbk.keystore放到classpath下面 </p>
<img src="/blog/2020/08/14/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/pic25.png" srcset="/blog/img/loading.gif" class>

<p>增加配置类</p>
<pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.http;

<span class="hljs-keyword">import</span> com.sun.jdi.connect.Connector;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@Class</span>: HttpRedirectHttps</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@Package</span> com.itheima.websocket.config</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>: http访问重定向https * <span class="hljs-doctag">@Company</span>: http://www.itheima.com/</span>
<span class="hljs-comment"> */</span>
<span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpRedirectHttps</span> </span>&#123;
    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;http.port&#125;"</span>)
    Integer httpPort;
    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;server.port&#125;"</span>)
    Integer httpsPort;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@Description</span>: 配置一个TomcatServletWebServerFactory 的BEAN</span>
<span class="hljs-comment">     * 然后添加一个Tomcat中的Connector（监听80端口）,并将请求转发到80端口</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@Method</span>: tomcatServletWebServerFactory</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@Param</span>: []</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@Update</span>:</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@since</span>: 1.0.0</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@Return</span>: org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory</span>
<span class="hljs-comment">     **/</span>
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> TomcatServletWebServerFactory <span class="hljs-title">servletContainer</span><span class="hljs-params">()</span> </span>&#123;
        TomcatServletWebServerFactory tomcat = <span class="hljs-keyword">new</span> TomcatServletWebServerFactory() &#123;
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessContext</span><span class="hljs-params">(Context context)</span> </span>&#123;
                SecurityConstraint securityConstraint = <span class="hljs-keyword">new</span> SecurityConstraint();
                securityConstraint.setUserConstraint(<span class="hljs-string">"CONFIDENTIAL"</span>);
                SecurityCollection collection = <span class="hljs-keyword">new</span> SecurityCollection();
                collection.addPattern(<span class="hljs-string">"/*"</span>);
                securityConstraint.addCollection(collection);
                context.addConstraint(securityConstraint);
            &#125;
        &#125;;
        tomcat.addAdditionalTomcatConnectors(createTomcatConnector());
        <span class="hljs-keyword">return</span> tomcat;
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@Description</span>: CONFIDENTIAL:要求用使SSL</span>
<span class="hljs-comment">     * Spring Boot 不支持同时启动 HTTP 和 HTTPS ，为了解决这个问题，我们这里可以配置一个请 求转发，当用户发起 HTTP 调用时，自动转发到 HTTPS 上</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@Method</span>: createTomcatConnector *</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@Param</span>: []</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@Update</span>:</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@since</span>: 1.0.0</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@Return</span>: org.apache.catalina.connector.Connector</span>
<span class="hljs-comment">     **/</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Connector <span class="hljs-title">createTomcatConnector</span><span class="hljs-params">()</span> </span>&#123;
        Connector connector = <span class="hljs-keyword">new</span> Connector(<span class="hljs-string">"org.apache.coyote.http11.Http11NioProtocol"</span>);
        connector.setScheme(<span class="hljs-string">"http"</span>);
        <span class="hljs-comment">//Connector监听的http的默认端口号</span>
        connector.setPort(httpPort);
        connector.setSecure(<span class="hljs-keyword">false</span>);
        <span class="hljs-comment">//监听到http的端口号后转向到的https的端口号,也就是项目配置的port</span>
        connector.setRedirectPort(httpsPort);
        <span class="hljs-keyword">return</span> connector;
    &#125;
&#125;</code></pre>




            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/blog/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">网络编程</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/blog/tags/HTTPS/">HTTPS</a>
                    
                      <a class="hover-with-bg" href="/blog/tags/WebSocket/">WebSocket</a>
                    
                      <a class="hover-with-bg" href="/blog/tags/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/">加密算法</a>
                    
                      <a class="hover-with-bg" href="/blog/tags/SSL-TLS/">SSL/TLS</a>
                    
                      <a class="hover-with-bg" href="/blog/tags/CA%E8%AF%81%E4%B9%A6/">CA证书</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/blog/2020/08/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">数据结构和算法基础</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/blog/2020/08/09/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">
                        <span class="hidden-mobile">网络编程</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/blog/js/debouncer.js" ></script>
<script  src="/blog/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/blog/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/blog/js/clipboard-use.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '#post-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "网络安全&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/blog/js/local-search.js" ></script>
  <script>
    var path = "/blog/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>







  
  
    <script type="text/javascript">
      //定义获取词语下标
      var a_idx = 0;
      jQuery(document).ready(function ($) {
        //点击body时触发事件
        $("body").click(function (e) {
          //需要显示的词语
          var a = new Array("富强", "民主", "文明", "和谐", "自由", "平等", "公正", "法治", "爱国", "敬业", "诚信", "友善");
          //设置词语给span标签
          var $i = $("<span/>").text(a[a_idx]);
          //下标等于原来下标+1  余 词语总数
          a_idx = (a_idx + 1) % a.length;
          //获取鼠标指针的位置，分别相对于文档的左和右边缘。
          //获取x和y的指针坐标
          var x = e.pageX, y = e.pageY;
          //在鼠标的指针的位置给$i定义的span标签添加css样式
          $i.css({
            "z-index": 999,
            "top": y - 20,
            "left": x,
            "position": "absolute",
            "font-weight": "bold",
            "color": rand_color()
          });
          // 随机颜色
          function rand_color() {
            return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"
          }
          //在body添加这个标签
          $("body").append($i);
          //animate() 方法执行 CSS 属性集的自定义动画。
          //该方法通过CSS样式将元素从一个状态改变为另一个状态。CSS属性值是逐渐改变的，这样就可以创建动画效果。
          //详情请看http://www.w3school.com.cn/jquery/effect_animate.asp
          $i.animate({
            //将原来的位置向上移动180
            "top": y - 180,
            "opacity": 0
            //1500动画的速度
          }, 1500, function () {
            //时间到了自动删除
            $i.remove();
          });
        });
      })
      ;
    </script>
  














</body>
</html>
