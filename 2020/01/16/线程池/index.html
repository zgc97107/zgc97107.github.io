<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="">
  <meta name="keywords" content="">
  <title>线程池 - zgcheng&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/5.12.1/css/all.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/mdbootstrap/4.13.0/css/mdb.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/3.0.1/github-markdown.min.css" />

<link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">



  <link  rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css" />

<link  rel="stylesheet" href="/css/main.css" />


  <link defer rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />


<!-- 自定义样式保持在最底部 -->


<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>zgcheng's blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">归档</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/">分类</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">标签</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about">关于</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
                <p class="mt-3 post-meta">
                  <i class="fas fa-calendar-alt" aria-hidden="true"></i>
                  星期四, 一月 16日 2020, 3:27 下午
                </p>
              

              <p class="mt-1">
                
                  
                  <span class="post-meta">
                    <i class="far fa-chart-bar"></i>
                    5.6k 字
                  </span>
                

                
                  
                  <span class="post-meta">
                      <i class="far fa-clock"></i>
                      21 分钟
                  </span>
                

                
                  <!-- 不蒜子统计文章PV -->
                  
                  <span id="busuanzi_container_page_pv" class="post-meta" style="display: none">
                    <i class="far fa-eye" aria-hidden="true"></i>
                    <span id="busuanzi_value_page_pv"></span> 次
                  </span>
                
              </p>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5 z-depth-3" id="board">
          <div class="post-content mx-auto" id="post">
            
              <p
                class="note note-warning">本文最后更新于：星期五, 四月 10日 2020, 4:56 下午</p>
            
            <div class="markdown-body">
              <h2 id="使用线程池的优势"><a href="#使用线程池的优势" class="headerlink" title="使用线程池的优势"></a>使用线程池的优势</h2><ol>
<li><p>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</p>
</li>
<li><p>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。假设一个服务器完成一项任务所需时间为：T1 创建线程时间，T2 在线程中执行任务的时间，T3 销毁线程时间。  如果：T1 + T3 远大于 T2，使用线程池就能显著服务器的性能。线程池技术正是关注如何缩短或调整T1,T3时间的技术，从而提高服务器程序性能的。它把T1，T3分别安排在服务器程序的启动和结束的时间段或者一些空闲的时间段，这样在服务器程序处理客户请求时，不会有T1，T3的开销了。</p>
</li>
<li><p>提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。</p>
</li>
</ol>
<p>假设一个服务器一天要处理50000个请求，并且每个请求需要一个单独的线程完成。线程池中的线程数一般是固定的，产生线程总数不会超过线程池中线程的数目。如果服务器不利用线程池来处理这些请求，则需要创建50000个线程，一般线程池大小是远小于50000，利用线程池去处理请求就可以减少线程创建的时间，从而提高效率。</p>
<h2 id="自定义线程池的实现"><a href="#自定义线程池的实现" class="headerlink" title="自定义线程池的实现"></a>自定义线程池的实现</h2><pre><code>/**
 *类说明：自定义线程池实现
 */
public class MyThreadPool2 {

    /*缺省线程数据量*/
    private static int WORK_COUNT = 5;

    /*存放任务*/
    private final BlockingQueue&lt;Runnable&gt; taskQueue;

    /*工作线程*/
    private WorkThread[] workThreads;

    private final int work_number;

    public MyThreadPool2(){
        this(100,WORK_COUNT);
    }

    /*任务数，线程的数量*/
    public MyThreadPool2(int task_count,
                         int work_number) {
        if (work_number&lt;=0) work_number = WORK_COUNT;
        if(task_count&lt;=0) task_count = 100;
        this.taskQueue = new ArrayBlockingQueue&lt;&gt;(task_count);
        this.work_number = work_number;
        workThreads = new WorkThread[work_number];
        /*工作线程准备好了*/
        for(int i=0;i&lt;work_number;i++){
            workThreads[i] = new WorkThread();
            workThreads[i].start();
        }
    }

    /*销毁线程池*/
    public void destroy(){
        System.out.println(&quot;ready close pool....&quot;);
        for(int i=0;i&lt;work_number;i++){
            workThreads[i].stopWorker();
            workThreads[i] = null;//help gc
        }
        taskQueue.clear();
    }

    /*放入任务，但是只是加入队列*/
    public void execute(Runnable task){
        try {
            taskQueue.put(task);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

    }

    @Override
    public String toString() {
        return &quot;WorkThread number:&quot;+work_number
                +&quot; wait task number:&quot;+taskQueue.size();
    }

    /*内部类，工作线程的实现*/
    private class WorkThread extends Thread{
        @Override
        public void run() {
            Runnable r = null;
            try {
                while(!isInterrupted()){
                    r = taskQueue.take();
                    if(r!=null){
                        System.out.println(getId()+&quot; ready execute&quot;
                                +((TestMyThreadPool.MyTask)r).getName());
                        r.run();
                    }
                   r = null;
                }
            } catch (InterruptedException e) {
                //e.printStackTrace();
            }

        }

        /*停止工作*/
        public void stopWorker() {
            interrupt();
        }
    }

}</code></pre><p>测试类</p>
<pre><code>/**
 *类说明：测试自定义线程池实现
 */
public class TestMyThreadPool {
    public static void main(String[] args) throws InterruptedException {
//         创建3个线程的线程池
        MyThreadPool2 t = new MyThreadPool2(0,3);
        t.execute(new MyTask(&quot;testA&quot;));
        t.execute(new MyTask(&quot;testB&quot;));
        t.execute(new MyTask(&quot;testC&quot;));
        t.execute(new MyTask(&quot;testD&quot;));
        t.execute(new MyTask(&quot;testE&quot;));
        System.out.println(t);
        Thread.sleep(10000);
        t.destroy();// 所有线程都执行完成才destory
        System.out.println(t);
    }

    // 任务类
    static class MyTask implements Runnable {

        private String name;
        private Random r = new Random();

        public MyTask(String name) {
            this.name = name;
        }

        public String getName() {
            return name;
        }

        @Override
        public void run() {// 执行任务
            try {
                Thread.sleep(r.nextInt(1000)+2000);
            } catch (InterruptedException e) {
                System.out.println(Thread.currentThread().getId()+&quot; sleep InterruptedException:&quot;
                        +Thread.currentThread().isInterrupted());
            }
            System.out.println(&quot;任务 &quot; + name + &quot; 完成&quot;);
        }
    }
}</code></pre><h2 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h2><img src="/2020/01/16/%E7%BA%BF%E7%A8%8B%E6%B1%A0/01/16/%E7%BA%BF%E7%A8%8B%E6%B1%A0/pic1.png" srcset="/img/loading.gif" class>

<p>Executor接口是Executor框架的基础，其中只有一个execute()方法，主要作用是将任务的提交与任务的执行分离开来；</p>
<p>ExecutorService接口继承了Executor接口，在其上做了一些shutdown()、submit()的扩展，可以说是真正的线程池接口；</p>
<p>AbstractExecutorService抽象类实现了ExecutorService接口中的大部分方法；</p>
<p>ThreadPoolExecutor类是线程池的核心实现类，用来执行被提交的任务。</p>
<p>ScheduledExecutorService接口继承了ExecutorService接口，提供了带周期执行功能ExecutorService；</p>
<p>ScheduledThreadPoolExecutor类继承ThreadPoolExecutor类、实现ScheduledExecutorService接口，可以在给定的延迟后执行任务，或者定期执行任务。ScheduledThreadPoolExecutor比Timer更灵活，功能更强大。</p>
<h2 id="线程池的创建各个参数含义"><a href="#线程池的创建各个参数含义" class="headerlink" title="线程池的创建各个参数含义"></a>线程池的创建各个参数含义</h2><p>public ThreadPoolExecutor(int <strong>corePoolSize</strong>,int <strong>maximumPoolSize</strong>,long <strong>keepAliveTime</strong>,TimeUnit <strong>unit</strong>,BlockingQueue&lt;Runnable&gt; <strong>workQueue</strong>,ThreadFactory <strong>threadFactory</strong>,RejectedExecutionHandler <strong>handler</strong>)</p>
<ul>
<li><p><strong>corePoolSize</strong>：线程池中的核心线程数。当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize；如果当前线程数已经达到corePoolSize，继续提交的任务会被保存到阻塞队列中，等待被执行；如果执行了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程。</p>
</li>
<li><p><strong>maximumPoolSize</strong>：线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于maximumPoolSize</p>
</li>
<li><p><strong>keepAliveTime</strong>：线程空闲时的存活时间，即当线程没有任务执行时，继续存活的时间。默认情况下，该参数只在线程数大于corePoolSize时才有用</p>
</li>
<li><p><strong>unit</strong>：keepAliveTime的时间单位</p>
</li>
<li><p><strong>workQueue</strong>：workQueue必须是BlockingQueue阻塞队列，通过workQueue，线程池实现了阻塞功能。当线程池中的线程数超过它的corePoolSize的时候，线程会进入阻塞队列进行阻塞等待。一般来说，我们应该尽量使用有界队列，因为使用无界队列作为工作队列会对线程池带来如下影响：</p>
<ol>
<li>当线程池中的线程数达到corePoolSize后，新任务将在无界队列中等待，因此线程池中的线程数不会超过corePoolSize。</li>
<li>由于1，使用无界队列时maximumPoolSize将是一个无效参数。</li>
<li>由于1和2，使用无界队列时keepAliveTime将是一个无效参数。</li>
<li>更重要的，使用无界queue可能会耗尽系统资源，有界队列则有助于防止资源耗尽，同时即使使用有界队列，也要尽量控制队列的大小在一个合适的范围。</li>
</ol>
<p>所以我们一般会使用，ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue、PriorityBlockingQueue。</p>
</li>
<li><p><strong>threadFactory</strong>：创建线程的工厂，通过自定义的线程工厂可以给每个新建的线程设置一个具有识别度的线程名，当然还可以更加自由的对线程做更多的设置，比如设置所有的线程为守护线程。Executors静态工厂里默认的threadFactory，线程的命名规则是“pool-数字-thread-数字”。</p>
</li>
<li><p><strong>handler</strong>：线程池的饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了4种策略：</p>
<ol>
<li>AbortPolicy：默认策略直接抛出异常；</li>
<li>CallerRunsPolicy：用调用者所在的线程来执行任务；</li>
<li>DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；</li>
<li>DiscardPolicy：直接丢弃任务；</li>
</ol>
<p>当然也可以根据应用场景实现RejectedExecutionHandler接口，自定义饱和策略，如记录日志或持久化存储不能处理的任务。</p>
</li>
</ul>
<h2 id="扩展线程池"><a href="#扩展线程池" class="headerlink" title="扩展线程池"></a>扩展线程池</h2><p>在JDK的线程池核心方法中预留出了三个空的方法，分别为任务执行前的方法、执行后的方法、线程池退出时执行的方法，我们可以通过这些方法执行我们自己的逻辑。如果要对Runnable任务做调整，如修改线程名字、设置线程为守护线程，则可以通过实现ThreadFactory接口，在newThread()方法中对runnable进行调整。</p>
<pre><code>/**
 * 类说明：扩展线程池的使用范例
 */
public class ThreadPoolExt {
    static class Worker implements Runnable {
        private String taskName;
        private Random r = new Random();

        public Worker(String taskName) {
            this.taskName = taskName;
        }

        public String getName() {
            return taskName;
        }

        @Override
        public void run() {
            System.out.println(Thread.currentThread().getName()
                    + &quot; process the task : &quot; + taskName);
            SleepTools.ms(r.nextInt(100) * 5);
        }
    }

    public static void main(String[] args) throws InterruptedException, ExecutionException {
        ExecutorService threadPool = new ThreadPoolExecutor(2, 4, 3,
                TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(10),
                new ThreadPoolExecutor.DiscardOldestPolicy()) {
            @Override
            protected void beforeExecute(Thread t, Runnable r) {
                System.out.println(&quot;Ready Execute &quot; + ((Worker) r).getName());
            }

            @Override
            protected void afterExecute(Runnable r, Throwable t) {
                System.out.println(&quot;Complete Execute &quot; + ((Worker) r).getName());
            }

            @Override
            protected void terminated() {
                System.out.println(&quot;线程池退出&quot;);
            }
        };

        for (int i = 0; i &lt;= 6; i++) {
            Worker worker = new Worker(&quot;worker &quot; + i);
            System.out.println(&quot;A new task has been added : &quot; + worker.getName());
            threadPool.execute(worker);
        }
        threadPool.shutdown();
    }
}</code></pre><p>可以看到，每个任务执行前后都会调用 beforeExecute和 afterExecute方法。相当于执行了一个切面。而在调用shutdown 方法后则会调用 terminated 方法。</p>
<h2 id="线程池的工作机制"><a href="#线程池的工作机制" class="headerlink" title="线程池的工作机制"></a>线程池的工作机制</h2><ol>
<li>如果当前运行的线程少于corePoolSize，则创建新线程来执行任务（注意，执行这一步骤需要获取全局锁）。</li>
<li>如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue。</li>
<li>如果无法将任务加入BlockingQueue（队列已满），则创建新的线程来处理任务。</li>
<li>如果继续添加任务导致当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用RejectedExecutionHandler.rejectedExecution()方法。</li>
</ol>
<img src="/2020/01/16/%E7%BA%BF%E7%A8%8B%E6%B1%A0/01/16/%E7%BA%BF%E7%A8%8B%E6%B1%A0/pic2.png" srcset="/img/loading.gif" class>

<p>内存资源相比线程资源要廉价一下，所以优先使用阻塞队列容纳多余线程数，在阻塞队列容纳不下的情况下才会创建新的线程（个人猜测）。</p>
<h2 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h2><p>execute()方法用于提交不需要返回值的任务（Runnable），所以无法判断任务是否被线程池执行成功。</p>
<p>submit()方法用于提交需要返回值的任务（Callable）。线程池会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用get(long timeout，TimeUnit unit)方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</p>
<h2 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h2><p>可以通过调用线程池的shutdown()或shutdownNow()方法来关闭线程池。它们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt()方法来中断线程，所以无法响应中断的任务可能永远无法终止。但是它们存在一定的区别，shutdownNow()首先将线程池的状态设置成STOP，然后尝试停止所有的<strong>正在或暂停执行任务的线程</strong>，并返回等待执行任务的列表，而shutdown()只是将线程池的状态设置成SHUTDOWN状态，然后中断所有<strong>没有正在执行任务的线程</strong>。</p>
<p>只要调用了这两个关闭方法中的任意一个，isShutdown方法就会返回true。当所有的任务都已关闭后，线程池关闭成功，这时调用isTerminaed方法会返回true。至于应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调用shutdown()方法来关闭线程池，如果任务不一定要执行完，则可以调用shutdownNow()方法。</p>
<h2 id="合理地配置线程池"><a href="#合理地配置线程池" class="headerlink" title="合理地配置线程池"></a>合理地配置线程池</h2><p>要想合理地配置线程池，就必须首先分析任务特性，可以从以下几个角度来分析：</p>
<ul>
<li><p>任务的性质：CPU密集型任务、IO密集型任务和混合型任务。</p>
</li>
<li><p>任务的优先级：高、中和低。</p>
</li>
<li><p>任务的执行时间：长、中和短。</p>
</li>
<li><p>任务的依赖性：是否依赖其他系统资源，如数据库连接。</p>
</li>
</ul>
<p>性质不同的任务可以用不同规模的线程池分开处理：</p>
<ul>
<li><p>CPU密集型任务（字符串的正则匹配、加密解密，数据的计算）应配置尽可能小的线程，如配置Ncpu+1个线程的线程池。</p>
</li>
<li><p>IO密集型任务（读写文件，数据库，http请求）线程并不是一直在执行任务，则应配置尽可能多的线程，如Ncpu*2，如果此时CPU占用率比较低的话可以尝试Ncpu*3。</p>
</li>
<li><p>混合型的任务（包括CPU密集及IO密集），如果将其拆分成一个CPU密集型任务和一个IO密集型任务，这两个任务执行的时间相差不是太大，那么分解后执行的吞吐量将高于串行执行的吞吐量，如果这两个任务执行时间相差太大，则没必要进行分解。</p>
</li>
</ul>
<p>可以通过Runtime.getRuntime().availableProcessors()方法获得当前设备的CPU个数。</p>
<p>优先级不同的任务可以使用优先级队列PriorityBlockingQueue来处理。它可以让优先级高的任务先执行。</p>
<p>执行时间不同的任务可以交给不同规模的线程池来处理，或者可以使用优先级队列，让执行时间短的任务先执行。</p>
<p>依赖数据库连接池的任务，因为线程提交SQL后需要等待数据库返回结果，等待的时间越长，则CPU空闲时间就越长，那么线程数应该设置得越大，这样才能更好地利用CPU。</p>
<p>在有界队列和无界队列的选择上，建议使用有界队列。有界队列能增加系统的稳定性和预警能力，队列的长度可以设置的大一些，比如几千。假设，我们现在有一个Web系统，里面使用了线程池来处理业务，在某些情况下，系统里后台任务线程池的队列和线程池全满了，不断抛出抛弃任务的异常，通过排查发现是数据库出现了问题，导致执行SQL变得非常缓慢，因为后台任务线程池里的任务全是需要向数据库查询和插入数据的，所以导致线程池里的工作线程全部阻塞，任务积压在线程池里。如果当时我们设置成无界队列，那么线程池的队列就会越来越多，有可能会撑满内存，导致整个系统不可用，而不只是后台任务出现问题。</p>
<h2 id="预定义线程池"><a href="#预定义线程池" class="headerlink" title="预定义线程池"></a>预定义线程池</h2><p>JDK在Executor中为我们提供了一些预定义的线程池，可以通过Executors.newFixedThreadPool()等方法来获取，但尽量还是自己通过构造方法根据当前场景创建。</p>
<h3 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h3><p>创建使用固定线程数的FixedThreadPool的API。适用于为了满足资源管理的需求，而需要限制当前线程数量的应用场景，它适用于负载比较重的服务器。FixedThreadPool的corePoolSize和maximumPoolSize都被设置为创建FixedThreadPool时指定的参数nThreads。</p>
<p>当线程池中的线程数大于corePoolSize时，keepAliveTime为多余的空闲线程等待新任务的最长时间，超过这个时间后多余的线程将被终止。这里把keepAliveTime设置为0L，意味着多余的空闲线程会被立即终止。</p>
<p>FixedThreadPool使用有界队列LinkedBlockingQueue作为线程池的工作队列（队列的容量为Integer.MAX_VALUE）。</p>
<h3 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h3><p>创建使用单个线程的SingleThread-Executor的API，于需要保证顺序地执行各个任务；并且在任意时间点，不会有多个线程是活动的应用场景。</p>
<p>corePoolSize和maximumPoolSize被设置为1。其他参数与FixedThreadPool相同。SingleThreadExecutor使用有界队列LinkedBlockingQueue作为线程池的工作队列（队列的容量为Integer.MAX_VALUE）。</p>
<h3 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h3><p>创建一个为所有任务创建新线程的CachedThreadPool的API。大小无界的线程池，适用于执行很多的短期异步任务的小程序，或者是负载较轻的服务器。</p>
<p>corePoolSize被设置为0，即corePool为空；maximumPoolSize被设置为Integer.MAX_VALUE。这里把keepAliveTime设置为60L，意味着CachedThreadPool中的空闲线程等待新任务的最长时间为60秒，空闲线程超过60秒后将会被终止。</p>
<p>FixedThreadPool和SingleThreadExecutor使用有界队列LinkedBlockingQueue作为线程池的工作队列。CachedThreadPool使用没有容量的SynchronousQueue作为线程池的工作队列，但CachedThreadPool的maximumPool是无界的。这意味着，如果主线程提交任务的速度高于maximumPool中线程处理任务的速度时，CachedThreadPool会不断创建新线程。极端情况下，CachedThreadPool会因为创建过多线程而耗尽CPU和内存资源。</p>
<h3 id="WorkStealingPool"><a href="#WorkStealingPool" class="headerlink" title="WorkStealingPool"></a>WorkStealingPool</h3><p>利用所有运行的处理器数目来创建一个工作窃取的线程池，使用forkjoin实现</p>
<h3 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h3><p>使用工厂类Executors来创建。Executors可以创建2种类型的ScheduledThreadPoolExecutor，如下。</p>
<ul>
<li><p>ScheduledThreadPoolExecutor。包含若干个线程的ScheduledThreadPoolExecutor。</p>
</li>
<li><p>SingleThreadScheduledExecutor。只包含一个线程的ScheduledThreadPoolExecutor。</p>
</li>
</ul>
<p>ScheduledThreadPoolExecutor适用于需要多个后台线程执行周期任务，同时为了满足资源管理的需求而需要限制后台线程的数量的应用场景。</p>
<p>SingleThreadScheduledExecutor适用于需要单个后台线程执行周期任务，同时需要保证顺序地执行各个任务的应用场景。</p>
<p>提交定时任务：</p>
<ul>
<li><p>public ScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit)：向定时任务线程池提交一个延时Runnable任务（仅执行一次）</p>
</li>
<li><p>public <V> ScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit unit)：向定时任务线程池提交一个延时的Callable任务（仅执行一次）</V></V></V></p>
</li>
<li><p>public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay,   long period, TimeUnit unit)：向定时任务线程池提交一个固定时间间隔执行的任务</p>
</li>
<li><p>public ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)：向定时任务线程池提交一个固定延时间隔执行的任务</p>
</li>
</ul>
<p>固定延时间隔的任务是指每次执行完任务以后都延时一个固定的时间。由于操作系统调度以及每次任务执行的语句可能不同，所以每次任务执行所花费的时间是不确定的，也就导致了每次任务的执行周期存在一定的波动。</p>
<p>固定时间间隔的任务不论每次任务花费多少时间，下次任务开始执行时间从理论上讲是确定的，当然执行任务的时间不能超过执行周期。</p>
<p>定时任务异常问题：</p>
<p>如果任务在执行过程中出现了异常而且不进行捕捉的话，next周期将不会运行。</p>
<p>定时任务超时问题：</p>
<p>scheduleAtFixedRate中，若任务处理时长超出设置的定时频率时长，本次任务执行完才开始下次任务，下次任务已经处于超时状态，会马上开始执行。若任务处理时长小于定时频率时长，任务执行完后，定时器等待，下次任务会在定时器等待频率时长后执行。</p>
<p>如下例子：</p>
<p>设置定时任务每60s执行一次，那么从理论上应该第一次任务在第0s开始,第二次任务在第60s开始，第三次任务在120s开始，但实际运行时第一次任务时长80s，第二次任务时长30s，第三次任务时长50s，则实际运行结果为：</p>
<p>第一次任务第0s开始,第80s结束；</p>
<p>第二次任务第80s开始,第110s结束(上次任务已超时,本次不会再等待60s,会马上开始)；</p>
<p>第三次任务第120s开始,第170s结束.</p>
<p>第四次任务第180s开始…..</p>
<h2 id="Executor框架的基本使用流程"><a href="#Executor框架的基本使用流程" class="headerlink" title="Executor框架的基本使用流程"></a>Executor框架的基本使用流程</h2><img src="/2020/01/16/%E7%BA%BF%E7%A8%8B%E6%B1%A0/01/16/%E7%BA%BF%E7%A8%8B%E6%B1%A0/pic3.png" srcset="/img/loading.gif" class>

<h3 id="了解CompletionService"><a href="#了解CompletionService" class="headerlink" title="了解CompletionService"></a>了解CompletionService</h3><p>CompletionService实际上可以看做是Executor和BlockingQueue的结合体。CompletionService在接收到要执行的任务时，把任务交给Executor来完成，再通过类似BlockingQueue的put()和take()来存入和获得任务执行的结果。</p>
<p>CompletionService的一个实现是ExecutorCompletionService，ExecutorCompletionService的构造函数可以接收一个Executor类型的executor和一个BlockingQueue&lt;Future&lt;V&gt;&gt;类型的completionQueue，completionQueue的作用是保存Executor执行的结果。当只传入executor时，构造函数中会创建一个LinkedBlockingQueue作为completionQueue。</p>
<p>当提交一个任务到ExecutorCompletionService时，首先将任务包装成QueueingFuture，它是FutureTask的一个子类，改写了FutureTask中的done方法，使QueueingFuture在结束时把Executor执行的计算结果放入completionQueue中。所以只有当QueueingFuture对象结束时，才会加入到completionQueue中，completionQueue的类型是BlockingQueue，其中的take()方法类似于Producer-Consumer模式中的Consumer。当从Queue中取出Future对象时，如果Queue是空的就会阻塞，直到有完成的Future对象加入到Queue中。所以先完成的必定先被取出，这样就减少了不必要的等待时间。</p>
<p>测试一：不使用CompletionService，自己创建一个集合来保存Future，并循环通过get()方法获取其返回结果。这时获取的结果与加入线程池时的顺序相同。因为get()方法是阻塞方法，如果后面的任务已经完成，前面的任务没有完成，获取结果的线程就会被阻塞直到前面的任务完成，才能得到后面任务的返回结果。</p>
<p>测试二：使用CompletionService来维护处理线程的返回结果，这时获取的结果与任务完成顺序相同，因为只有在Future完成是才会被加入completionQueue，所以completionQueue的Future的顺序与任务完成的顺序相同。</p>
<pre><code>/**
 *类说明：
 */
public class CompletionCase {
    private final int POOL_SIZE = Runtime.getRuntime().availableProcessors();
    private final int TOTAL_TASK = Runtime.getRuntime().availableProcessors()*10;

    // 方法一，自己写集合来实现获取线程池中任务的返回结果
    public void testByQueue() throws Exception {
       long start = System.currentTimeMillis();
       AtomicInteger count = new AtomicInteger(0);
        // 创建线程池
        ExecutorService pool = Executors.newFixedThreadPool(POOL_SIZE);
        // 拿任务的执行结果
        BlockingQueue&lt;Future&lt;Integer&gt;&gt; queue =
              new LinkedBlockingQueue&lt;Future&lt;Integer&gt;&gt;();

        // 向里面扔任务
        for (int i = 0; i &lt; TOTAL_TASK; i++) {
            Future&lt;Integer&gt; future = pool.submit(new WorkTask(&quot;ExecTask&quot; + i));
            queue.add(future);
        }

        // 检查线程池任务执行结果
        for (int i = 0; i &lt; TOTAL_TASK; i++) {
           int sleptTime = queue.take().get();
           //System.out.println(&quot; slept &quot;+sleptTime+&quot; ms ...&quot;);
           count.addAndGet(sleptTime);
        }

        // 关闭线程池
        pool.shutdown();
        System.out.println(&quot;-------------tasks sleep time &quot;+count.get()
              +&quot;ms,and spend time &quot;
              +(System.currentTimeMillis()-start)+&quot; ms&quot;);
    }

    public void testByCompletion() throws InterruptedException, ExecutionException {
        long start = System.currentTimeMillis();
        AtomicInteger count = new AtomicInteger(0);
        // 创建线程池
        ExecutorService pool = Executors.newFixedThreadPool(POOL_SIZE);
        CompletionService&lt;Integer&gt; cService = new ExecutorCompletionService&lt;&gt;(pool);
        // 向里面扔任务
        for (int i = 0; i &lt; TOTAL_TASK; i++) {
            cService.submit(new WorkTask(&quot;ExecTask&quot; + i));
        }

        // 检查线程池任务执行结果
        for (int i = 0; i &lt; TOTAL_TASK; i++) {
            int sleptTime = cService.take().get();
            //System.out.println(&quot; slept &quot;+sleptTime+&quot; ms ...&quot;);
            count.addAndGet(sleptTime);
        }

        // 关闭线程池
        pool.shutdown();
        System.out.println(&quot;-------------tasks sleep time &quot;+count.get()
                +&quot;ms,and spend time &quot;
                +(System.currentTimeMillis()-start)+&quot; ms&quot;);
    }

    public static void main(String[] args) throws Exception {
        CompletionCase t = new CompletionCase();
        t.testByQueue();
        t.testByCompletion();
    }
}</code></pre><p>两种方法对比</p>
<pre><code>-------------tasks sleep time 38314ms,and spend time 5136 ms
-------------tasks sleep time 40876ms,and spend time 5707 ms</code></pre>
            </div>
            <hr>
            <div>
              <p>
                
                  <span>
                <i class="iconfont icon-inbox"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a>
                      &nbsp;
                    
                  </span>&nbsp;&nbsp;
                
                
                  <span>
                <i class="iconfont icon-tag"></i>
                    
                      <a class="hover-with-bg" href="/tags/java/">java</a>
                    
                      <a class="hover-with-bg" href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a>
                    
                  </span>
                
              </p>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2020/01/23/%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8/">
                        <i class="fa fa-chevron-left"></i>
                        <span class="hidden-mobile">并发安全</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/01/10/tomcat%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">
                        <span class="hidden-mobile">Tomcat性能优化</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="fa fa-chevron-right"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

              
                <!-- Comments -->
                <div class="comments" id="comments">
                  
                  

                </div>
              
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc-start"></div>
<div id="toc">
  <p class="h5"><i class="far fa-list-alt"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a class="z-depth-1" id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"> <b>Fluid</b></a>
    </div>
    
  <div>
    
      <!-- 不蒜子统计PV -->
      
      <span id="busuanzi_container_site_pv" style="display: none">
      总访问量 <span id="busuanzi_value_site_pv"></span> 次
    </span>
    
    
      <!-- 不蒜子统计UV -->
      
      <span id="busuanzi_container_site_uv" style="display: none">
      总访客数 <span id="busuanzi_value_site_uv"></span> 人
    </span>
    
  </div>


    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/popper.js/1.16.1/umd/popper.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="https://cdn.staticfile.org/mdbootstrap/4.13.0/js/mdb.min.js" ></script>
<script  src="/js/main.js" ></script>


  <script  src="/js/lazyload.js" ></script>



  
  <script  src="https://cdn.staticfile.org/tocbot/4.10.0/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var navHeight = $('#navbar').height();
      var toc = $('#toc');
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;
      var tocLimMax = 2 * boardTop + boardCtn.height();

      $(window).scroll(function () {
        var tocLimMin = $('#toc-start').offset().top - navHeight;
        var scroH = document.body.scrollTop + document.documentElement.scrollTop;

        if (tocLimMin <= scroH && scroH <= tocLimMax) {
          toc.css({
            'display': 'block',
            'position': 'fixed',
            'top': navHeight,
          });
        } else if (scroH <= tocLimMin) {
          toc.css({
            'position': '',
            'top': '',
          });
        } else if (scroH > tocLimMax) {
          toc.css('display', 'none');
        }
      });
      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '.post-content',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc > p').css('visibility', 'visible');
      }
      var offset = boardCtn.css('margin-right')
      $('#toc-ctn').css({
        'right': offset
      })
    });
  </script>





  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>



  <script defer src="https://cdn.staticfile.org/smoothscroll/1.4.10/SmoothScroll.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




<!-- Plugins -->


  

  

  

  

  

  



  <script  src="https://cdn.staticfile.org/prettify/188.0.0/prettify.min.js" ></script>
  <script>
    $(document).ready(function () {
      $('pre').addClass('prettyprint  linenums');
      prettyPrint();
    })
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "线程池&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script defer src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <script>
    $("#post img:not(.no-zoom img, img[no-zoom])").each(
      function () {
        var element = document.createElement("a");
        $(element).attr("data-fancybox", "images");
        $(element).attr("href", $(this).attr("src"));
        $(this).wrap(element);
      }
    );
  </script>





  
  
    <script type="text/javascript">
      //定义获取词语下标
      var a_idx = 0;
      jQuery(document).ready(function ($) {
        //点击body时触发事件
        $("body").click(function (e) {
          //需要显示的词语
          var a = new Array("富强", "民主", "文明", "和谐", "自由", "平等", "公正", "法治", "爱国", "敬业", "诚信", "友善");
          //设置词语给span标签
          var $i = $("<span/>").text(a[a_idx]);
          //下标等于原来下标+1  余 词语总数
          a_idx = (a_idx + 1) % a.length;
          //获取鼠标指针的位置，分别相对于文档的左和右边缘。
          //获取x和y的指针坐标
          var x = e.pageX, y = e.pageY;
          //在鼠标的指针的位置给$i定义的span标签添加css样式
          $i.css({
            "z-index": 999,
            "top": y - 20,
            "left": x,
            "position": "absolute",
            "font-weight": "bold",
            "color": rand_color()
          });
          // 随机颜色
          function rand_color() {
            return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"
          }
          //在body添加这个标签
          $("body").append($i);
          //animate() 方法执行 CSS 属性集的自定义动画。
          //该方法通过CSS样式将元素从一个状态改变为另一个状态。CSS属性值是逐渐改变的，这样就可以创建动画效果。
          //详情请看http://www.w3school.com.cn/jquery/effect_animate.asp
          $i.animate({
            //将原来的位置向上移动180
            "top": y - 180,
            "opacity": 0
            //1500动画的速度
          }, 1500, function () {
            //时间到了自动删除
            $i.remove();
          });
        });
      })
      ;
    </script>
  








</body>
</html>
