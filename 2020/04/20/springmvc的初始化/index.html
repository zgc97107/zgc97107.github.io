<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="">
  <meta name="keywords" content="">
  <title>springmvc的初始化 - 🍎🍊&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/5.12.1/css/all.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/mdbootstrap/4.13.0/css/mdb.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/3.0.1/github-markdown.min.css" />

<link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">



  <link  rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css" />

<link  rel="stylesheet" href="/css/main.css" />


  <link defer rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />


<!-- 自定义样式保持在最底部 -->


<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>🍎🍊's blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">归档</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/">分类</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">标签</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about">关于</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
                <p class="mt-3 post-meta">
                  <i class="fas fa-calendar-alt" aria-hidden="true"></i>
                  星期一, 四月 20日 2020, 8:10 晚上
                </p>
              

              <p class="mt-1">
                
                  
                  <span class="post-meta">
                    <i class="far fa-chart-bar"></i>
                    3.2k 字
                  </span>
                

                
                  
                  <span class="post-meta">
                      <i class="far fa-clock"></i>
                      15 分钟
                  </span>
                

                
                  <!-- 不蒜子统计文章PV -->
                  
                  <span id="busuanzi_container_page_pv" class="post-meta" style="display: none">
                    <i class="far fa-eye" aria-hidden="true"></i>
                    <span id="busuanzi_value_page_pv"></span> 次
                  </span>
                
              </p>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5 z-depth-3" id="board">
          <div class="post-content mx-auto" id="post">
            
              <p
                class="note note-warning">本文最后更新于：星期日, 五月 24日 2020, 8:29 晚上</p>
            
            <div class="markdown-body">
              <h2 id="初始化入口"><a href="#初始化入口" class="headerlink" title="初始化入口"></a>初始化入口</h2><p>springmvc是基于servlet规范来完成的一个请求响应模块，也是spring中比较大的一个模块，现在已经支持零配置的方式整合，不再需要web.xml和springmvc.xml文件。</p>
<h3 id="web-xml的替换"><a href="#web-xml的替换" class="headerlink" title="web.xml的替换"></a>web.xml的替换</h3><p>servlet规范中规定当servlet容器启动的时会加载META-INF/services/javax.servlet.ServletContainerInitializer文件中的类。这个类必须实现javax.servlet.ServletContainerInitializer接口，servlet容器在启动后会收集实现@HandlesTypes注解中的接口的实现类，然后传递给onStartup()方法。springmvc就是通过这个规范完成容器初始化。</p>
<pre><code class="xml">org.springframework.web.SpringServletContainerInitializer</code></pre>
<p>spring中定义一个了WebApplicationInitializer接口，然后在onStartup()方法中通过反射调用onStart()方法。这里我们着重分析下这个接口的实现类AbstractContextLoaderInitializer跟AbstractDispatcherServletInitializer类。</p>
<pre><code class="java">@HandlesTypes(WebApplicationInitializer.class)
public class SpringServletContainerInitializer implements ServletContainerInitializer {

    @Override
    public void onStartup(@Nullable Set&lt;Class&lt;?&gt;&gt; webAppInitializerClasses, ServletContext servletContext)
            throws ServletException {

        List&lt;WebApplicationInitializer&gt; initializers = new LinkedList&lt;&gt;();

        if (webAppInitializerClasses != null) {
            for (Class&lt;?&gt; waiClass : webAppInitializerClasses) {
                // Be defensive: Some servlet containers provide us with invalid classes,
                // no matter what @HandlesTypes says...
                if (!waiClass.isInterface() &amp;&amp; !Modifier.isAbstract(waiClass.getModifiers()) &amp;&amp;
                        WebApplicationInitializer.class.isAssignableFrom(waiClass)) {
                    try {
                        initializers.add((WebApplicationInitializer)
                                ReflectionUtils.accessibleConstructor(waiClass).newInstance());
                    }
                    catch (Throwable ex) {
                        throw new ServletException(&quot;Failed to instantiate WebApplicationInitializer class&quot;, ex);
                    }
                }
            }
        }

        if (initializers.isEmpty()) {
            servletContext.log(&quot;No Spring WebApplicationInitializer types detected on classpath&quot;);
            return;
        }

        servletContext.log(initializers.size() + &quot; Spring WebApplicationInitializers detected on classpath&quot;);
        AnnotationAwareOrderComparator.sort(initializers);
        for (WebApplicationInitializer initializer : initializers) {
            initializer.onStartup(servletContext);
        }
    }
}</code></pre>
<h4 id="AbstractContextLoaderInitializer类"><a href="#AbstractContextLoaderInitializer类" class="headerlink" title="AbstractContextLoaderInitializer类"></a>AbstractContextLoaderInitializer类</h4><p>AbstractContextLoaderInitializer中的onStartup()方法会调用registerContextLoaderListener()方法，该方法中会调用createRootApplicationContext()方法创建spring上下文，并注册ContextLoaderListener。spring上下文的refresh()方法将由ContextLoaderListener来调用</p>
<pre><code class="java">public abstract class AbstractContextLoaderInitializer implements WebApplicationInitializer {

    /** Logger available to subclasses. */
    protected final Log logger = LogFactory.getLog(getClass());


    @Override
    public void onStartup(ServletContext servletContext) throws ServletException {
        registerContextLoaderListener(servletContext);
    }

    protected void registerContextLoaderListener(ServletContext servletContext) {

        //创建spring上下文，注册了SpringContainer
        WebApplicationContext rootAppContext = createRootApplicationContext();
        if (rootAppContext != null) {
            //创建监听器
            /*
                形如这种配置
            * &lt;listener&gt;
                  &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
                &lt;!--&lt;listener-class&gt;org.springframework.web.context.request.RequestContextListener&lt;/listener-class&gt;--&gt;
              &lt;/listener&gt;
            *
            * */
            ContextLoaderListener listener = new ContextLoaderListener(rootAppContext);
            listener.setContextInitializers(getRootApplicationContextInitializers());
            servletContext.addListener(listener);
        }
        else {
            logger.debug(&quot;No ContextLoaderListener registered, as &quot; +
                    &quot;createRootApplicationContext() did not return an application context&quot;);
        }
    }

    @Nullable
    protected abstract WebApplicationContext createRootApplicationContext();

    @Nullable
    protected ApplicationContextInitializer&lt;?&gt;[] getRootApplicationContextInitializers() {
        return null;
    }
}</code></pre>
<p>AbstractAnnotationConfigDispatcherServletInitializer中的createRootApplicationContext()方法会调用getRootConfigClasses()方法获取一个configClasses对象，然后创建一个AnnotationConfigWebApplicationContext上下文对象，并向这个上下文对象中注册configClasses对象。这个过程类似于与注解启动spring容器过程相同。getRootConfigClasses()方法会由开发者自己实现，主要作用是将有@CompoentScan注解的类传递给spring用来创建上下文。要注意的是这个上下文对象是spring的上下文对象，不是sprngmvc的上下文，所以应该排除controller对象。</p>
<pre><code class="java">public abstract class AbstractAnnotationConfigDispatcherServletInitializer
        extends AbstractDispatcherServletInitializer {

    @Override
    @Nullable
    protected WebApplicationContext createRootApplicationContext() {
        Class&lt;?&gt;[] configClasses = getRootConfigClasses();
        if (!ObjectUtils.isEmpty(configClasses)) {
            AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext();
            context.register(configClasses);
            return context;
        }
        else {
            return null;
        }
    }

    @Override
    protected WebApplicationContext createServletApplicationContext() {
        AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext();
        Class&lt;?&gt;[] configClasses = getServletConfigClasses();
        if (!ObjectUtils.isEmpty(configClasses)) {
            context.register(configClasses);
        }
        return context;
    }

    @Nullable
    protected abstract Class&lt;?&gt;[] getRootConfigClasses();

    @Nullable
    protected abstract Class&lt;?&gt;[] getServletConfigClasses();

}</code></pre>
<p>ContextLoaderListener的contextInitialized()方法会在servlet容器启动时调用。contextInitialized()将调用initWebApplicationContext()调用spring上下文加载的核心方法refresh()。</p>
<pre><code class="java">public class ContextLoaderListener extends ContextLoader implements ServletContextListener {

    public ContextLoaderListener() {
    }

    public ContextLoaderListener(WebApplicationContext context) {
        super(context);
    }

    @Override
    public void contextInitialized(ServletContextEvent event) {
        initWebApplicationContext(event.getServletContext());
    }

    @Override
    public void contextDestroyed(ServletContextEvent event) {
        closeWebApplicationContext(event.getServletContext());
        ContextCleanupListener.cleanupAttributes(event.getServletContext());
    }
}</code></pre>
<h4 id="AbstractDispatcherServletInitializer类"><a href="#AbstractDispatcherServletInitializer类" class="headerlink" title="AbstractDispatcherServletInitializer类"></a>AbstractDispatcherServletInitializer类</h4><p>AbstractDispatcherServletInitializer的onStartup()方法中，会创建sprngmvc的上下文对象跟DispatcherServlet对象。Serlvet容器在启动时会调用DispatcherServlet的init()方法，该方法继承自父类HttpServletBean，init()方法最终会调用到springmvc上下文的refresh()方法。springmvc上下文对象初始化时会先获取spring的上下文对象，然后将其设置为父容器，之后getBean()操作中会优先从父容器中获取bean。</p>
<pre><code class="java">public abstract class AbstractDispatcherServletInitializer extends AbstractContextLoaderInitializer {

   public static final String DEFAULT_SERVLET_NAME = &quot;dispatcher&quot;;

   @Override
   public void onStartup(ServletContext servletContext) throws ServletException {
      super.onStartup(servletContext);
      //注册DispatcherServlet
      registerDispatcherServlet(servletContext);
   }

   protected void registerDispatcherServlet(ServletContext servletContext) {
      String servletName = getServletName();
      Assert.hasLength(servletName, &quot;getServletName() must not return null or empty&quot;);

      //创建springmvc的上下文，注册了MvcContainer类
      WebApplicationContext servletAppContext = createServletApplicationContext();
      Assert.notNull(servletAppContext, &quot;createServletApplicationContext() must not return null&quot;);

      //创建DispatcherServlet
      FrameworkServlet dispatcherServlet = createDispatcherServlet(servletAppContext);
      Assert.notNull(dispatcherServlet, &quot;createDispatcherServlet(WebApplicationContext) must not return null&quot;);
      dispatcherServlet.setContextInitializers(getServletApplicationContextInitializers());

      ServletRegistration.Dynamic registration = servletContext.addServlet(servletName, dispatcherServlet);
      if (registration == null) {
         throw new IllegalStateException(&quot;Failed to register servlet with name &#39;&quot; + servletName + &quot;&#39;. &quot; +
               &quot;Check if there is another servlet registered under the same name.&quot;);
      }

      /*
      * 如果该元素的值为负数或者没有设置，则容器会当Servlet被请求时再加载。
         如果值为正整数或者0时，表示容器在应用启动时就加载并初始化这个servlet，
         值越小，servlet的优先级越高，就越先被加载
      * */
      registration.setLoadOnStartup(1);
      registration.addMapping(getServletMappings());
      registration.setAsyncSupported(isAsyncSupported());

      Filter[] filters = getServletFilters();
      if (!ObjectUtils.isEmpty(filters)) {
         for (Filter filter : filters) {
            registerServletFilter(servletContext, filter);
         }
      }

      customizeRegistration(registration);
   }

   protected String getServletName() {
      return DEFAULT_SERVLET_NAME;
   }

   protected abstract WebApplicationContext createServletApplicationContext();

   protected FrameworkServlet createDispatcherServlet(WebApplicationContext servletAppContext) {
      return new DispatcherServlet(servletAppContext);
   }

   @Nullable
   protected ApplicationContextInitializer&lt;?&gt;[] getServletApplicationContextInitializers() {
      return null;
   }

   protected abstract String[] getServletMappings();

   @Nullable
   protected Filter[] getServletFilters() {
      return null;
   }

   protected FilterRegistration.Dynamic registerServletFilter(ServletContext servletContext, Filter filter) {
      String filterName = Conventions.getVariableName(filter);
      Dynamic registration = servletContext.addFilter(filterName, filter);

      if (registration == null) {
         int counter = 0;
         while (registration == null) {
            if (counter == 100) {
               throw new IllegalStateException(&quot;Failed to register filter with name &#39;&quot; + filterName + &quot;&#39;. &quot; +
                     &quot;Check if there is another filter registered under the same name.&quot;);
            }
            registration = servletContext.addFilter(filterName + &quot;#&quot; + counter, filter);
            counter++;
         }
      }

      registration.setAsyncSupported(isAsyncSupported());
      registration.addMappingForServletNames(getDispatcherTypes(), false, getServletName());
      return registration;
   }

   private EnumSet&lt;DispatcherType&gt; getDispatcherTypes() {
      return (isAsyncSupported() ?
            EnumSet.of(DispatcherType.REQUEST, DispatcherType.FORWARD, DispatcherType.INCLUDE, DispatcherType.ASYNC) :
            EnumSet.of(DispatcherType.REQUEST, DispatcherType.FORWARD, DispatcherType.INCLUDE));
   }

   protected boolean isAsyncSupported() {
      return true;
   }

   protected void customizeRegistration(ServletRegistration.Dynamic registration) {
   }
}</code></pre>
<h3 id="springmvc-xml的替换"><a href="#springmvc-xml的替换" class="headerlink" title="springmvc.xml的替换"></a>springmvc.xml的替换</h3><pre><code class="xml">&lt;mvc:annotation-driven&gt;
    &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt;
        &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;
            &lt;property name=&quot;supportedMediaTypes&quot; value = &quot;text/plain;charset=UTF-8&quot; /&gt;
        &lt;/bean&gt;
    &lt;/mvc:message-converters&gt;
&lt;/mvc:annotation-driven&gt;</code></pre>
<p>这个标签总过做了三件事情：</p>
<ol>
<li>创建HandlerMapping对象</li>
<li>创建HandlerAdapter对象</li>
<li>创建消息转换器加入到HandlerAdapter中</li>
</ol>
<p>@EnableWebMvc标签可以完成springmvc.xml中的所有工作。</p>
<p>该注解中会引入DelegatingWebMvcConfiguration类，该类会通过@Autowired获取到所有WebMvcConfigurer接口的实现类。该类的父类WebMvcConfigurationSupport类就是比较核心的类，会替代xml进行完成所有组件的注册。该类十分庞大，主要是通过@Bean的方式将组件注册到上下文对象中。此处我们只分析RequestMappingHandlerMapping的注册，其他组件的注册的流程也基本相同。</p>
<p>该类的requestMappingHandleMapping()方法进行RequestMappingHandlerMapping的注册，该方法会通过调用getInterceptors()方法获取拦截器，然后设置进去，之后设置的属性还包括跨域等属性，这里着重分析getInterceptors()方法，其他属性的获取方式也基本相同。</p>
<pre><code class="java">@Bean
public RequestMappingHandlerMapping requestMappingHandlerMapping() {
   RequestMappingHandlerMapping mapping = createRequestMappingHandlerMapping();
   mapping.setOrder(0);
   mapping.setInterceptors(getInterceptors());
   mapping.setContentNegotiationManager(mvcContentNegotiationManager());
   mapping.setCorsConfigurations(getCorsConfigurations());

   PathMatchConfigurer configurer = getPathMatchConfigurer();

   Boolean useSuffixPatternMatch = configurer.isUseSuffixPatternMatch();
   if (useSuffixPatternMatch != null) {
      mapping.setUseSuffixPatternMatch(useSuffixPatternMatch);
   }
   Boolean useRegisteredSuffixPatternMatch = configurer.isUseRegisteredSuffixPatternMatch();
   if (useRegisteredSuffixPatternMatch != null) {
      mapping.setUseRegisteredSuffixPatternMatch(useRegisteredSuffixPatternMatch);
   }
   Boolean useTrailingSlashMatch = configurer.isUseTrailingSlashMatch();
   if (useTrailingSlashMatch != null) {
      mapping.setUseTrailingSlashMatch(useTrailingSlashMatch);
   }

   UrlPathHelper pathHelper = configurer.getUrlPathHelper();
   if (pathHelper != null) {
      mapping.setUrlPathHelper(pathHelper);
   }
   PathMatcher pathMatcher = configurer.getPathMatcher();
   if (pathMatcher != null) {
      mapping.setPathMatcher(pathMatcher);
   }
   Map&lt;String, Predicate&lt;Class&lt;?&gt;&gt;&gt; pathPrefixes = configurer.getPathPrefixes();
   if (pathPrefixes != null) {
      mapping.setPathPrefixes(pathPrefixes);
   }

   return mapping;
}</code></pre>
<p>getInterceptors()方法</p>
<p>该方法会调用子类DelegatingWebMvcConfiguration的addInterceptors()方法，该类中会通过依赖注入的方式获取到所有实现WebMvcConfigurer接口的类，然后调用其addInterceptors()方法把我们自己定义的Interceptor传递进去。</p>
<pre><code class="java">@Autowired(required = false)
public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) {
   if (!CollectionUtils.isEmpty(configurers)) {
      this.configurers.addWebMvcConfigurers(configurers);
   }
}

protected void addInterceptors(InterceptorRegistry registry) {
   this.configurers.addInterceptors(registry);
}</code></pre>
<h2 id="DispatcherServlet中的组件初始化"><a href="#DispatcherServlet中的组件初始化" class="headerlink" title="DispatcherServlet中的组件初始化"></a>DispatcherServlet中的组件初始化</h2><p>DispatcherServlet的父类FrameworkServlet中有一个私有类ContextRefreshListener，这个私有类继承了spring的监听器ApplicationListener&lt;ContextRefreshedEvent&gt;，spring完成初始化会发布一个ContextRefreshedEvent类型的事件来触发这个监听器，监听器监听到这个事件后会在线程中调用私有类的onApplicationEvent()方法。</p>
<p>onApplicationEvent()方法会再调用FrameworkServlet类中的onApplicationEvent()方法，在这个方法中会调用onRefresh()方法。</p>
<pre><code class="java">private class ContextRefreshListener implements ApplicationListener&lt;ContextRefreshedEvent&gt; {

   @Override
   public void onApplicationEvent(ContextRefreshedEvent event) {
      FrameworkServlet.this.onApplicationEvent(event);
   }
}</code></pre>
<p>onRefresh()方法会调用到子类DispatcherServlet中的方法，最终调用到initStrategies()方法。完成DispatcherServlet组件的设置。</p>
<pre><code class="java">protected void initStrategies(ApplicationContext context) {
   initMultipartResolver(context);
   initLocaleResolver(context);
   initThemeResolver(context);
   initHandlerMappings(context);
   initHandlerAdapters(context);
   initHandlerExceptionResolvers(context);
   initRequestToViewNameTranslator(context);
   initViewResolvers(context);
   initFlashMapManager(context);
}</code></pre>
<p>initHandlerMappings()方法会从上下文中获取到HandlerMapping对象，然后进行排序。如果没有配置HandlerMapping对象，就会加载默认的HandlerMappinig对象。最后设置到handlerMappings属性中。</p>
<pre><code class="java">private void initHandlerMappings(ApplicationContext context) {
   this.handlerMappings = null;

   if (this.detectAllHandlerMappings) {
      // Find all HandlerMappings in the ApplicationContext, including ancestor contexts.
      Map&lt;String, HandlerMapping&gt; matchingBeans =
            BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping.class, true, false);
      if (!matchingBeans.isEmpty()) {
         this.handlerMappings = new ArrayList&lt;&gt;(matchingBeans.values());
         // We keep HandlerMappings in sorted order.
         AnnotationAwareOrderComparator.sort(this.handlerMappings);
      }
   }
   else {
      try {
         HandlerMapping hm = context.getBean(HANDLER_MAPPING_BEAN_NAME, HandlerMapping.class);
         this.handlerMappings = Collections.singletonList(hm);
      }
      catch (NoSuchBeanDefinitionException ex) {
         // Ignore, we&#39;ll add a default HandlerMapping later.
      }
   }

   // Ensure we have at least one HandlerMapping, by registering
   // a default HandlerMapping if no other mappings are found.
   if (this.handlerMappings == null) {
      this.handlerMappings = getDefaultStrategies(context, HandlerMapping.class);
      if (logger.isTraceEnabled()) {
         logger.trace(&quot;No HandlerMappings declared for servlet &#39;&quot; + getServletName() +
               &quot;&#39;: using default strategies from DispatcherServlet.properties&quot;);
      }
   }
}</code></pre>
<h2 id="建立路径与方法的映射关系"><a href="#建立路径与方法的映射关系" class="headerlink" title="建立路径与方法的映射关系"></a>建立路径与方法的映射关系</h2><p>springmvc会在初始化时完成路径与方法的映射，具体是通过AbstractHandlerMethodMapping类的initHandlerMethods()方法来完成。AbstractHandlerMethodMapping类实现了InitializingBean接口，spring在Bean实例化并完成IOC、DI之后调用这个接口的afterPropertiesSet()方法。AbstractHandlerMethodMapping类的afterPropertiesSet()方法中调用了initHandlerMethods()方法。initHandlerMethods()方法会调用processCandidateBean()方法创建url跟method的映射关系。</p>
<pre><code class="java">protected void initHandlerMethods() {
   for (String beanName : getCandidateBeanNames()) {
      if (!beanName.startsWith(SCOPED_TARGET_NAME_PREFIX)) {
         processCandidateBean(beanName);
      }
   }
   handlerMethodsInitialized(getHandlerMethods());
}</code></pre>
<p>processCandidateBean()方法会判断类上面是否有@Controller、@RequestMapping注解，如果有会调用detectHandlerMethods()方法建立url跟method的映射关系。</p>
<pre><code class="java">protected void processCandidateBean(String beanName) {
   Class&lt;?&gt; beanType = null;
   try {
      beanType = obtainApplicationContext().getType(beanName);
   }
   catch (Throwable ex) {
      // An unresolvable bean type, probably from a lazy bean - let&#39;s ignore it.
      if (logger.isTraceEnabled()) {
         logger.trace(&quot;Could not resolve type for bean &#39;&quot; + beanName + &quot;&#39;&quot;, ex);
      }
   }
   //如果类上面有@Controller注解或者@RequestMapping注解
   if (beanType != null &amp;&amp; isHandler(beanType)) {
      //建立uri和method的映射关系
      detectHandlerMethods(beanName);
   }
}</code></pre>
<p>detectHandlerMethods()方法首先会获取方法对象和方法上的@RequestMapping注解属性，然后向selectMethods()方法中传入getMappingForMethod()方法用来封装映射关系，Map&lt;Method, T&gt;中的T就是属性的封装对象。最后调用registerHandlerMethod()方法建立映射关系。</p>
<pre><code class="java">protected void detectHandlerMethods(Object handler) {
   Class&lt;?&gt; handlerType = (handler instanceof String ?
         obtainApplicationContext().getType((String) handler) : handler.getClass());

   if (handlerType != null) {
      Class&lt;?&gt; userType = ClassUtils.getUserClass(handlerType);

      //获取方法对象和方法上面的@RequestMapping注解属性封装对象的映射关系
      Map&lt;Method, T&gt; methods = MethodIntrospector.selectMethods(userType,
            (MethodIntrospector.MetadataLookup&lt;T&gt;) method -&gt; {
               try {
                  return getMappingForMethod(method, userType);
               }
               catch (Throwable ex) {
                  throw new IllegalStateException(&quot;Invalid mapping on handler class [&quot; +
                        userType.getName() + &quot;]: &quot; + method, ex);
               }
            });
      if (logger.isTraceEnabled()) {
         logger.trace(formatMappings(userType, methods));
      }
      methods.forEach((method, mapping) -&gt; {
         Method invocableMethod = AopUtils.selectInvocableMethod(method, userType);
         //建立uri和方法的各种映射关系，反正一条，根据uri要能够找到method对象
         registerHandlerMethod(handler, invocableMethod, mapping);
      });
   }
}</code></pre>
<p>selectMethods()方法首先会获取类上的所有method，然后判断method上面是否有@RequestMapping注解，如果有调用外层传入的getMappingForMethod()方法封装成对象返回。</p>
<pre><code class="java">public static &lt;T&gt; Map&lt;Method, T&gt; selectMethods(Class&lt;?&gt; targetType, final MetadataLookup&lt;T&gt; metadataLookup) {
   final Map&lt;Method, T&gt; methodMap = new LinkedHashMap&lt;&gt;();
   Set&lt;Class&lt;?&gt;&gt; handlerTypes = new LinkedHashSet&lt;&gt;();
   Class&lt;?&gt; specificHandlerType = null;

   if (!Proxy.isProxyClass(targetType)) {
      specificHandlerType = ClassUtils.getUserClass(targetType);
      handlerTypes.add(specificHandlerType);
   }
   handlerTypes.addAll(ClassUtils.getAllInterfacesForClassAsSet(targetType));

   for (Class&lt;?&gt; currentHandlerType : handlerTypes) {
      final Class&lt;?&gt; targetClass = (specificHandlerType != null ? specificHandlerType : currentHandlerType);

      //循环currentHandlerType类的所有方法
      ReflectionUtils.doWithMethods(currentHandlerType, method -&gt; {
         Method specificMethod = ClassUtils.getMostSpecificMethod(method, targetClass);
         //判断方法上面是否有@RequestMapping注解，如果有封装对象返回
         T result = metadataLookup.inspect(specificMethod);
         if (result != null) {
            Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(specificMethod);
            if (bridgedMethod == specificMethod || metadataLookup.inspect(bridgedMethod) == null) {
               //建立方法对象和注解封装对象的映射关系
               methodMap.put(specificMethod, result);
            }
         }
      }, ReflectionUtils.USER_DECLARED_METHODS);
   }

   return methodMap;
}</code></pre>
<p>getMappingForMethod()方法首先会调用createRequestMappingInfo()方法封装注解信息，然后将类上的@RequestMapping注解也封装成对象，最后将两个对象结合后返回。</p>
<pre><code class="java">protected RequestMappingInfo getMappingForMethod(Method method, Class&lt;?&gt; handlerType) {
   //寻找有@RequestMapping注解的方法，然后注解里面的内容封装成对象
   RequestMappingInfo info = createRequestMappingInfo(method);
   if (info != null) {
      //类上面的@RequestMapping注解也封装成对象
      RequestMappingInfo typeInfo = createRequestMappingInfo(handlerType);
      if (typeInfo != null) {
         //把方法上面的注解属性结合到类上面的RequestMappingInfo对象中
         info = typeInfo.combine(info);
      }
      String prefix = getPathPrefix(handlerType);
      if (prefix != null) {
         info = RequestMappingInfo.paths(prefix).build().combine(info);
      }
   }
   return info;
}</code></pre>
<p>registerHandlerMethod()方法中的主要方法是register()，该方法首先会调用createHandlerMethod()方法创建HandlerMethod对象，该对象中封装了类跟方法信息，如果此时类还没有被实例化，就会将beanName跟beanFactory一起封装进去，如果类已经实例化就只会封装实例化之后的bean。然后将uri跟HandlerMethod放到mappingLookup中，url跟RequestMappingInfo信息放入urlLookup中。</p>
<pre><code class="java">public void register(T mapping, Object handler, Method method) {
   this.readWriteLock.writeLock().lock();
   try {
      //创建HandlerMethod对象，其实
      HandlerMethod handlerMethod = createHandlerMethod(handler, method);
      //检验是否唯一
      assertUniqueMethodMapping(handlerMethod, mapping);
      //建立RequestMappingInfo对象和handlerMethod的映射关系
      this.mappingLookup.put(mapping, handlerMethod);

      List&lt;String&gt; directUrls = getDirectUrls(mapping);
      for (String url : directUrls) {
         //建立url和RequestMappingInfo映射关系
         this.urlLookup.add(url, mapping);
      }

      String name = null;
      if (getNamingStrategy() != null) {
         name = getNamingStrategy().getName(handlerMethod, mapping);
         addMappingName(name, handlerMethod);
      }

      //判断method上是否有CrossOrigin注解，把注解里面的属性封装成CorsConfiguration，这个是做跨域访问控制的
      CorsConfiguration corsConfig = initCorsConfiguration(handler, method, mapping);
      if (corsConfig != null) {
         //建立映射关系
         this.corsLookup.put(handlerMethod, corsConfig);
      }

      this.registry.put(mapping, new MappingRegistration&lt;&gt;(mapping, handlerMethod, directUrls, name));
   }
   finally {
      this.readWriteLock.writeLock().unlock();
   }
}</code></pre>

            </div>
            <hr>
            <div>
              <p>
                
                  <span>
                <i class="iconfont icon-inbox"></i>
                    
                      <a class="hover-with-bg" href="/categories/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">Spring源码解析</a>
                      &nbsp;
                    
                  </span>&nbsp;&nbsp;
                
                
                  <span>
                <i class="iconfont icon-tag"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">源码解析</a>
                    
                      <a class="hover-with-bg" href="/tags/spring/">spring</a>
                    
                      <a class="hover-with-bg" href="/tags/springmvc/">springmvc</a>
                    
                  </span>
                
              </p>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2020/04/21/springmvc%E7%9A%84%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94/">
                        <i class="fa fa-chevron-left"></i>
                        <span class="hidden-mobile">springmvc的请求响应</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/04/20/spring%E7%9A%84%E7%BC%93%E5%AD%98%E5%88%87%E9%9D%A2%E5%92%8C%E5%BC%82%E6%AD%A5%E5%88%87%E9%9D%A2/">
                        <span class="hidden-mobile">spring的缓存切面和异步切面</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="fa fa-chevron-right"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

              
                <!-- Comments -->
                <div class="comments" id="comments">
                  
                  

                </div>
              
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc-start"></div>
<div id="toc">
  <p class="h5"><i class="far fa-list-alt"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a class="z-depth-1" id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"> <b>Fluid</b></a>
    </div>
    
  <div>
    
      <!-- 不蒜子统计PV -->
      
      <span id="busuanzi_container_site_pv" style="display: none">
      总访问量 <span id="busuanzi_value_site_pv"></span> 次
    </span>
    
    
      <!-- 不蒜子统计UV -->
      
      <span id="busuanzi_container_site_uv" style="display: none">
      总访客数 <span id="busuanzi_value_site_uv"></span> 人
    </span>
    
  </div>


    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/popper.js/1.16.1/umd/popper.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="https://cdn.staticfile.org/mdbootstrap/4.13.0/js/mdb.min.js" ></script>
<script  src="/js/main.js" ></script>


  <script  src="/js/lazyload.js" ></script>



  
  <script  src="https://cdn.staticfile.org/tocbot/4.10.0/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var navHeight = $('#navbar').height();
      var toc = $('#toc');
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;
      var tocLimMax = 2 * boardTop + boardCtn.height();

      $(window).scroll(function () {
        var tocLimMin = $('#toc-start').offset().top - navHeight;
        var scroH = document.body.scrollTop + document.documentElement.scrollTop;

        if (tocLimMin <= scroH && scroH <= tocLimMax) {
          toc.css({
            'display': 'block',
            'position': 'fixed',
            'top': navHeight,
          });
        } else if (scroH <= tocLimMin) {
          toc.css({
            'position': '',
            'top': '',
          });
        } else if (scroH > tocLimMax) {
          toc.css('display', 'none');
        }
      });
      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '.post-content',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc > p').css('visibility', 'visible');
      }
      var offset = boardCtn.css('margin-right')
      $('#toc-ctn').css({
        'right': offset
      })
    });
  </script>





  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>



  <script defer src="https://cdn.staticfile.org/smoothscroll/1.4.10/SmoothScroll.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




<!-- Plugins -->


  

  

  

  

  

  



  <script  src="https://cdn.staticfile.org/prettify/188.0.0/prettify.min.js" ></script>
  <script>
    $(document).ready(function () {
      $('pre').addClass('prettyprint  linenums');
      prettyPrint();
    })
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "springmvc的初始化&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script defer src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <script>
    $("#post img:not(.no-zoom img, img[no-zoom])").each(
      function () {
        var element = document.createElement("a");
        $(element).attr("data-fancybox", "images");
        $(element).attr("href", $(this).attr("src"));
        $(this).wrap(element);
      }
    );
  </script>





  
  
    <script type="text/javascript">
      //定义获取词语下标
      var a_idx = 0;
      jQuery(document).ready(function ($) {
        //点击body时触发事件
        $("body").click(function (e) {
          //需要显示的词语
          var a = new Array("富强", "民主", "文明", "和谐", "自由", "平等", "公正", "法治", "爱国", "敬业", "诚信", "友善");
          //设置词语给span标签
          var $i = $("<span/>").text(a[a_idx]);
          //下标等于原来下标+1  余 词语总数
          a_idx = (a_idx + 1) % a.length;
          //获取鼠标指针的位置，分别相对于文档的左和右边缘。
          //获取x和y的指针坐标
          var x = e.pageX, y = e.pageY;
          //在鼠标的指针的位置给$i定义的span标签添加css样式
          $i.css({
            "z-index": 999,
            "top": y - 20,
            "left": x,
            "position": "absolute",
            "font-weight": "bold",
            "color": rand_color()
          });
          // 随机颜色
          function rand_color() {
            return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"
          }
          //在body添加这个标签
          $("body").append($i);
          //animate() 方法执行 CSS 属性集的自定义动画。
          //该方法通过CSS样式将元素从一个状态改变为另一个状态。CSS属性值是逐渐改变的，这样就可以创建动画效果。
          //详情请看http://www.w3school.com.cn/jquery/effect_animate.asp
          $i.animate({
            //将原来的位置向上移动180
            "top": y - 180,
            "opacity": 0
            //1500动画的速度
          }, 1500, function () {
            //时间到了自动删除
            $i.remove();
          });
        });
      })
      ;
    </script>
  








</body>
</html>
