<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="">
  <meta name="keywords" content="">
  <title>tomcat源码解析 - zgcheng&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/5.12.1/css/all.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/mdbootstrap/4.13.0/css/mdb.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/3.0.1/github-markdown.min.css" />

<link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">



  <link  rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css" />

<link  rel="stylesheet" href="/css/main.css" />


  <link defer rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />


<!-- 自定义样式保持在最底部 -->


<meta name="generator" content="Hexo 4.1.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>zgcheng's blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">归档</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/">分类</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">标签</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about">关于</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
                <p class="mt-3 post-meta">
                  <i class="fas fa-calendar-alt" aria-hidden="true"></i>
                  星期四, 四月 30日 2020, 6:26 晚上
                </p>
              

              <p class="mt-1">
                
                  
                  <span class="post-meta">
                    <i class="far fa-chart-bar"></i>
                    6.9k 字
                  </span>
                

                
                  
                  <span class="post-meta">
                      <i class="far fa-clock"></i>
                      29 分钟
                  </span>
                

                
                  <!-- 不蒜子统计文章PV -->
                  
                  <span id="busuanzi_container_page_pv" class="post-meta" style="display: none">
                    <i class="far fa-eye" aria-hidden="true"></i>
                    <span id="busuanzi_value_page_pv"></span> 次
                  </span>
                
              </p>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5 z-depth-3" id="board">
          <div class="post-content mx-auto" id="post">
            
              <p
                class="note note-warning">本文最后更新于：星期二, 五月 5日 2020, 11:27 晚上</p>
            
            <div class="markdown-body">
              <h2 id="tomcat源码目录"><a href="#tomcat源码目录" class="headerlink" title="tomcat源码目录"></a>tomcat源码目录</h2><ul>
<li><p>catalina目录：catalina包含所有的Servlet容器实现，以及涉及到安全、会话、集群、部署管理Servlet容器的各个方面，同时，它还包含了启动入口。</p>
</li>
<li><p>coyote目录：coyote是Tomcat链接器框架的名称，是Tomcat服务器提供的客户端访问的外部接口，客户端通过Coyote与服务器建立链接、发送请求并接收响应。</p>
</li>
<li><p>El目录，提供java表达式语言</p>
</li>
<li><p>Jasper模块提供JSP引擎</p>
</li>
<li><p>Naming模块提供JNDI的服务</p>
</li>
<li><p>Juli提供服务器日志的服务</p>
</li>
<li><p>tomcat提供外部调用的接口api</p>
</li>
</ul>
<h2 id="tomcat组件的生命周期管理"><a href="#tomcat组件的生命周期管理" class="headerlink" title="tomcat组件的生命周期管理"></a>tomcat组件的生命周期管理</h2><p>tomcat的架构设计是清晰的、模块化、它拥有很多组件，加入在启动Tomcat时一个一个组件启动，很容易遗漏组件，同时还会对后面的动态组件拓展带来麻烦。如果采用我们传统的方式的话，组件在启动过程中如果发生异常，会很难管理，比如你的下一个组件调用了start()方法，但是如果它的上级组件还没有start()甚至还没有init()的话，Tomcat的启动会非常难管理，因此，Tomcat的设计者提出一个解决方案：使用生命周期统一接口Lifecycle定义一些状态常量，然后将启动、停止、关闭及所有与生命周期相关的方法都组织到一起，这样就可以很方便管理tomcat各个容器组件的生命周期。</p>
<p>LifecycleBase实现了Lifecycle接口，在init()方法中初始化之前会进行状态检查：</p>
<pre><code class="java">@Override
public final synchronized void init() throws LifecycleException {
    //防止组件启动时状态不对
    if (!state.equals(LifecycleState.NEW)) {
        invalidTransition(Lifecycle.BEFORE_INIT_EVENT);
    }

    try {
        //设置初始化状态
        setStateInternal(LifecycleState.INITIALIZING, null, false);
        initInternal();
        //设置初始化完成
        setStateInternal(LifecycleState.INITIALIZED, null, false);
    } catch (Throwable t) {
        handleSubClassException(t, &quot;lifecycleBase.initFail&quot;, toString());
    }
}</code></pre>
<p>init()方法中会调用子类的initInternal()方法，这里使用了模版方法设计模式，LifecycleBase为骨架类，initInternal()的具体实现在子类中，spring中也使用了这种设计模式。</p>
<p>start()方法中同样会进行相应的判断。</p>
<pre><code class="java">@Override
public final synchronized void start() throws LifecycleException {
    // 统一进行生命周期的管理
    if (LifecycleState.STARTING_PREP.equals(state) || LifecycleState.STARTING.equals(state) ||
            LifecycleState.STARTED.equals(state)) {
        if (log.isDebugEnabled()) {
            Exception e = new LifecycleException();
            log.debug(sm.getString(&quot;lifecycleBase.alreadyStarted&quot;, toString()), e);
        } else if (log.isInfoEnabled()) {
            log.info(sm.getString(&quot;lifecycleBase.alreadyStarted&quot;, toString()));
        }
        return;
    }
    // 检查组件生命周期状态
    if (state.equals(LifecycleState.NEW)) {
        init();
    } else if (state.equals(LifecycleState.FAILED)) {
        stop();
    } else if (!state.equals(LifecycleState.INITIALIZED) &amp;&amp;
            !state.equals(LifecycleState.STOPPED)) {
        invalidTransition(Lifecycle.BEFORE_START_EVENT);
    }

    try {
        // 设置组件状态
        setStateInternal(LifecycleState.STARTING_PREP, null, false);
        // 调用具体实现类的方法
        startInternal();
        // 统一进行生命周期的管理
        if (state.equals(LifecycleState.FAILED)) {
            // 失败，调用stop()方法完成清理
            stop();
        } else if (!state.equals(LifecycleState.STARTING)) {
            // 不是已经在启动的状态
            invalidTransition(Lifecycle.AFTER_START_EVENT);
        } else {
            // 设置组件状态
            setStateInternal(LifecycleState.STARTED, null, false);
        }
    } catch (Throwable t) {
        // This is an &#39;uncontrolled&#39; failure so put the component into the
        // FAILED state and throw an exception.
        handleSubClassException(t, &quot;lifecycleBase.startFail&quot;, toString());
    }
}</code></pre>
<p>tomcat内部架构中各个核心组件有包含与被包含关系，例如：Server包含了Service，Service又包含了Container和Connector，这个结构有一点像数据结构中的树，树的根结点没有父节点，其他节点有且仅有一个父节点，每一个父节点有0至多个子节点。所以，我们可以通过父容器启动它的子容器，这样只要启动根容器，就可以把其他所有的容器都启动，从而达到了统一的启动，停止、关闭的效果。</p>
<h2 id="tomcat组件分析"><a href="#tomcat组件分析" class="headerlink" title="tomcat组件分析"></a>tomcat组件分析</h2><h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><p>继承结构：</p>
<img src="/2020/04/30/tomcat%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/pic6.png" srcset="/img/loading.gif" class="">

<p>Server是tomcat最顶层的容器，代表整个服务器，Tomcat中的标准实现为StandardServer类。</p>
<h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>继承结构：</p>
<img src="/2020/04/30/tomcat%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/pic7.png" srcset="/img/loading.gif" class="">

<p>其中LifecycleMBeanBase用于监督对象状态。</p>
<p>Service中请求监听和请求处理分开为两个模块：</p>
<img src="/2020/04/30/tomcat%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/pic8.png" srcset="/img/loading.gif" class="">

<p>Connector负责请求监听，Container负责请求处理，一个Service可以有多个Connector，但只能有一个Container。</p>
<h3 id="Connector"><a href="#Connector" class="headerlink" title="Connector"></a>Connector</h3><img src="/2020/04/30/tomcat%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/pic8.png" srcset="/img/loading.gif" class="">

<p>Connector使用ProtocolHandler来处理请求，ProtocolHandler包含三个部件：</p>
<ul>
<li>Endpoint：用来处理底层的Scoket的网络连接。</li>
<li>Processor：用于将Endpoint接收到的Socket封装为Request</li>
<li>Adapter：作为适配器将Reqeust将为ServletRequest交给Container进行具体的处理。</li>
</ul>
<h3 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h3><img src="/2020/04/30/tomcat%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/pic9.png" srcset="/img/loading.gif" class="">

<ul>
<li>Engine：引擎，在servler.xml中定义了一个名为Catalina的Engline，只能有一个。</li>
<li>Host：站点、虚拟主机，一个Engline包含多个Host的设计，使得一个服务器实例可以承担多个域名的服务，是很灵活的设计</li>
<li>Context：应用，默认配置下webapps下的每个目录都是一个应用。</li>
<li>Wrapper：一个Servlet。</li>
</ul>
<h2 id="tomcat启动流程"><a href="#tomcat启动流程" class="headerlink" title="tomcat启动流程"></a>tomcat启动流程</h2><p>tomcat组件的启动流程：</p>
<img src="/2020/04/30/tomcat%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/pic1.png" srcset="/img/loading.gif" class="">

<h3 id="入口类Bootstrap"><a href="#入口类Bootstrap" class="headerlink" title="入口类Bootstrap"></a>入口类Bootstrap</h3><p>start.sh会执行catalina.sh，catalina.sh会调用Bootstrap类中的main()方法。</p>
<pre><code class="java">public static void main(String args[]) {

    //初始化阶段 init()方法
    synchronized (daemonLock) {
        if (daemon == null) {
            // Don&#39;t set daemon until init() has completed
            Bootstrap bootstrap = new Bootstrap();
            try {
                bootstrap.init();
            } catch (Throwable t) {
                handleThrowable(t);
                t.printStackTrace();
                return;
            }
            daemon = bootstrap;
        } else {
            // When running as a service the call to stop will be on a new
            // thread so make sure the correct class loader is used to
            // prevent a range of class not found exceptions.
            Thread.currentThread().setContextClassLoader(daemon.catalinaLoader);
        }
    }

    //运行阶段 start()
    try {
        String command = &quot;start&quot;;
        if (args.length &gt; 0) {
            command = args[args.length - 1];
        }

        if (command.equals(&quot;startd&quot;)) {
            args[args.length - 1] = &quot;start&quot;;
            daemon.load(args);
            daemon.start();
        } else if (command.equals(&quot;stopd&quot;)) {
            args[args.length - 1] = &quot;stop&quot;;
            daemon.stop();
        } else if (command.equals(&quot;start&quot;)) {
            daemon.setAwait(true);
            daemon.load(args);
            daemon.start();
            if (null == daemon.getServer()) {
                System.exit(1);
            }
        } else if (command.equals(&quot;stop&quot;)) {
            daemon.stopServer(args);
        } else if (command.equals(&quot;configtest&quot;)) {
            daemon.load(args);
            if (null == daemon.getServer()) {
                System.exit(1);
            }
            System.exit(0);
        } else {
            log.warn(&quot;Bootstrap: command \&quot;&quot; + command + &quot;\&quot; does not exist.&quot;);
        }
    } catch (Throwable t) {
        // Unwrap the Exception for clearer error reporting
        if (t instanceof InvocationTargetException &amp;&amp;
                t.getCause() != null) {
            t = t.getCause();
        }
        handleThrowable(t);
        t.printStackTrace();
        System.exit(1);
    }
}</code></pre>
<p>main()方法首先会调用init()方法及start()方法，init()方法中会通过反射加载Catalina。</p>
<pre><code class="java">public void init() throws Exception {

    //类加载器初始化
    initClassLoaders();

    //设置线程上下文类加载器，来解决有可能的ClassNotFoundException问题
    Thread.currentThread().setContextClassLoader(catalinaLoader);

    SecurityClassLoad.securityClassLoad(catalinaLoader);

    // 加载启动类Catalina并调用其process()方法
    if (log.isDebugEnabled())
        log.debug(&quot;Loading startup class&quot;);
    Class&lt;?&gt; startupClass = catalinaLoader.loadClass(&quot;org.apache.catalina.startup.Catalina&quot;);
    Object startupInstance = startupClass.getConstructor().newInstance();

    // 设置共享类加载器sharedLoader
    if (log.isDebugEnabled())
        log.debug(&quot;Setting startup class properties&quot;);
    String methodName = &quot;setParentClassLoader&quot;;
    Class&lt;?&gt; paramTypes[] = new Class[1];
    paramTypes[0] = Class.forName(&quot;java.lang.ClassLoader&quot;);
    Object paramValues[] = new Object[1];
    // 把shared加载器传递给catalina
    paramValues[0] = sharedLoader;
    Method method =
        startupInstance.getClass().getMethod(methodName, paramTypes);
    method.invoke(startupInstance, paramValues);

    catalinaDaemon = startupInstance;
}</code></pre>
<p>start()方法中会通过反射调用Catalina的start方法。</p>
<pre><code class="java">public void start() throws Exception {
    if (catalinaDaemon == null) {
        init();
    }

    Method method = catalinaDaemon.getClass().getMethod(&quot;start&quot;, (Class [])null);
    method.invoke(catalinaDaemon, (Object [])null);
}</code></pre>
<h3 id="Catalina"><a href="#Catalina" class="headerlink" title="Catalina"></a>Catalina</h3><p>Bootstrap的init()方法会调用到Catalina的load()方法，load()方法中会通过文件流的方式加载各种文件及配置信息，最后调用Server的init()方法，同样的，start()方法中会调用Servler的start()方法，这里不在进行详细分析。</p>
<h3 id="Server-1"><a href="#Server-1" class="headerlink" title="Server"></a>Server</h3><p>这里使用了模版方法设计模式，start()方法将调用子类中的startInternal()方法。StandardServer中的startInternal()方法会循环调用所有的Service的start()方法，同样的initInternal()方法中也会调用所有Service的init()方法。</p>
<pre><code class="java">protected void startInternal() throws LifecycleException {

    fireLifecycleEvent(CONFIGURE_START_EVENT, null);
    setState(LifecycleState.STARTING);

    globalNamingResources.start();

    // Start our defined Services
    synchronized (servicesLock) {
        for (int i = 0; i &lt; services.length; i++) {
            services[i].start();
        }
    }
}</code></pre>
<h3 id="Service-1"><a href="#Service-1" class="headerlink" title="Service"></a>Service</h3><p>StandardService中的startInternal()方法，该方法首先会启动容器，然后启动线程执行器，自定义连接器。</p>
<pre><code class="java">    @Override
    protected void startInternal() throws LifecycleException {

        if(log.isInfoEnabled())
            log.info(sm.getString(&quot;standardService.start.name&quot;, this.name));
        setState(LifecycleState.STARTING);

        // 首先启动的是容器
        if (engine != null) {
            synchronized (engine) {
                engine.start();
            }
        }
        // 线程执行器
        synchronized (executors) {
            for (Executor executor: executors) {
                executor.start();
            }
        }

        mapperListener.start();

        // 启动自定义的连接器
        synchronized (connectorsLock) {
            for (Connector connector: connectors) {
                try {
                    // If it has already failed, don&#39;t try and start it
                    if (connector.getState() != LifecycleState.FAILED) {
                        connector.start();
                    }
                } catch (Exception e) {
                    log.error(sm.getString(
                            &quot;standardService.connector.startFailed&quot;,
                            connector), e);
                }
            }
        }
    }</code></pre>
<h2 id="tomcat的请求处理过程"><a href="#tomcat的请求处理过程" class="headerlink" title="tomcat的请求处理过程"></a>tomcat的请求处理过程</h2><ol>
<li>用户点击网页内容，请求被发送到本机端口8080，被在那里监听的Coyote HTTP/1.1 Connector获得。</li>
<li>Connector把该请求交给它所在的Service的Engine来处理，并等待Engine的回应。</li>
<li>Engine获得请求localhost/test/index.jsp，匹配所有的虚拟主机Host。</li>
<li>Engine匹配到名为localhost的Host（即使匹配不到也把请求交给该Host处理，因为该Host被定义为该Engine的默认主机），名为localhost的Host获得请求/test/index.jsp，匹配它所拥有的所有的Context。Host匹配到路径为/test的Context（如果匹配不到就把该请求交给路径名为“ ”的Context去处理）。</li>
<li>path=“/test”的Context获得请求/index.jsp，在它的mapping table中寻找出对应的Servlet。Context匹配到URL PATTERN为*.jsp的Servlet,对应于JspServlet类。</li>
<li>构造HttpServletRequest对象和HttpServletResponse对象，作为参数调用JspServlet的doGet()或doPost()。执行业务逻辑、数据存储等程序。</li>
<li>Context把执行完之后的HttpServletResponse对象返回给Host。</li>
<li>Host把HttpServletResponse对象返回给Engine。</li>
<li>Engine把HttpServletResponse对象返回Connector。</li>
<li>Connector把HttpServletResponse对象返回给客户Browser。</li>
</ol>
<h2 id="管道模式"><a href="#管道模式" class="headerlink" title="管道模式"></a>管道模式</h2><h3 id="管道与阀门"><a href="#管道与阀门" class="headerlink" title="管道与阀门"></a>管道与阀门</h3><p>在一个比较复杂的大型系统中，如果一个对象或数据流需要进行繁杂的逻辑处理，我们可以选择在一个大的组件中直接处理这些繁杂的逻辑处理，这个方式虽然达到目的，但是拓展性和可重用性差。因为牵一发而动全身。</p>
<p>管道是就像一条管道把多个对象连接起来，整体看起来就像若干个阀门嵌套在管道中，而处理逻辑放在阀门上。它的结构和实现是非常值得我们学习和借鉴的。</p>
<h3 id="管道的实现"><a href="#管道的实现" class="headerlink" title="管道的实现"></a>管道的实现</h3><p>首先需要定义阀门接口，阀门接口中包含下一个阀门的引用，每个阀门完成自己的逻辑后将调用下一个阀门的方法，直到基础阀门，基础阀门的方法中不再对下一个阀门进行调用。管道接口中保存有第一个阀门及基础阀门的引用，基础阀门的将作为阀门添加时的顺序比较，第一个阀门将用于管道调用的开始，管道调用开始于第一个管道，终止于基础管道。</p>
<p>管道接口：</p>
<pre><code class="java">public interface Pipeline {
    //获取第一个阀门
    public Valve getFirst();
    public Valve getBasic();
    //设置阀门
    public void setBasic(Valve valve);
    //添加阀门
    public void addVave(Valve valve);
}</code></pre>
<p>阀门接口</p>
<pre><code class="java">public interface Valve {
    public Valve getNext();
    public void setNext(Valve valve);
    public void invoke(String handing);
}</code></pre>
<p>管道接口的实现：</p>
<pre><code class="java">public class StandardPipeline implements  Pipeline {
    //阀门（非基础，定义一个first）
    protected Valve first = null;
    //基础阀门
    protected Valve basic = null;

    @Override
    public Valve getBasic() {
        return basic;
    }

    @Override
    public void setBasic(Valve valve) {
        this.basic=valve;
    }

    @Override
    public Valve getFirst() {
        return first;
    }

    //添加阀门，链式构建阀门的执行顺序（先定制、最后基础阀门）
    @Override
    public void addVave(Valve valve) {
        if(first == null){
            first = valve;
            valve.setNext(basic);
        }else{
            Valve current =first;
            while(current !=null){
                if(current.getNext() == basic){
                    current.setNext(valve);
                    valve.setNext(basic);
                }
                current = current.getNext();
            }
        }
    }
}</code></pre>
<p>基础阀门</p>
<pre><code class="java">public class StandardValve implements Valve {
    protected  Valve next =null;
    @Override
    public Valve getNext() {
        return next;
    }

    @Override
    public void setNext(Valve valve) {
        this.next =valve;
    }

    @Override
    public void invoke(String request) {
        System.out.println(&quot;基础阀门处理&quot;);
    }
}</code></pre>
<p>第一个阀门</p>
<pre><code class="java">public class FirstValve implements Valve {
    protected  Valve next =null;
    @Override
    public Valve getNext() {
        return next;
    }

    @Override
    public void setNext(Valve valve) {
        this.next =valve;
    }

    @Override
    public void invoke(String request) {
        System.out.println(&quot;阀门1处理&quot;);
        getNext().invoke(request);
    }
}</code></pre>
<p>第二个阀门</p>
<pre><code class="java">public class SecondValve implements Valve {
    protected  Valve next =null;
    @Override
    public Valve getNext() {
        return next;
    }

    @Override
    public void setNext(Valve valve) {
        this.next =valve;
    }

    @Override
    public void invoke(String request) {
        System.out.println(&quot;阀门2处理&quot;);
        getNext().invoke(request);
    }
}</code></pre>
<p>测试类</p>
<pre><code class="java">public class Demo {
    public static void main(String[] args) {
        String request =&quot;这个是一个Servlet请求&quot;;
        //new出一个管道
        StandardPipeline pipeline = new StandardPipeline();
        //三个阀门(一个基础、2个定制)
        StandardValve standardValve = new StandardValve();
        FirstValve firstValve = new FirstValve();
        SecondValve secondValve = new SecondValve();
        //设置基础阀门(定制阀门)
        pipeline.setBasic(standardValve);
        //设置非基础阀门
        pipeline.addVave(firstValve);
        pipeline.addVave(secondValve);
        //调用对象管道中的第一个阀门
        pipeline.getFirst().invoke(request);
    }
}</code></pre>
<h2 id="tomcat中的管道"><a href="#tomcat中的管道" class="headerlink" title="tomcat中的管道"></a>tomcat中的管道</h2><img src="/2020/04/30/tomcat%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/pic3.png" srcset="/img/loading.gif" class="">

<p>其中的Engine、Host、Context、warpper分别对应StandardEngineValve、StandardHostValve、StandardContextValve、StandardWrapperValve四种阀门。</p>
<h3 id="管道处理流程"><a href="#管道处理流程" class="headerlink" title="管道处理流程"></a>管道处理流程</h3><img src="/2020/04/30/tomcat%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/pic4.png" srcset="/img/loading.gif" class="">

<p>接收到请求后在CoyoteAdapter的service()方法中的<code>connector.getContainer().getPipeline().getFirst().invoke(request, response);</code>将获取管道并开始阀门的调用过程对reqeust、response进行处理。</p>
<p>StandardEngineValue类中的invoke()方法。</p>
<pre><code class="java">@Override
public final void invoke(Request request, Response response)
    throws IOException, ServletException {

    // 拿到Engline中包含的host
    Host host = request.getHost();
    if (host == null) {
        response.sendError
            (HttpServletResponse.SC_BAD_REQUEST,
             sm.getString(&quot;standardEngine.noHost&quot;,
                          request.getServerName()));
        return;
    }
    if (request.isAsyncSupported()) {
        request.setAsyncSupported(host.getPipeline().isAsyncSupported());
    }

    // 将request，response交给下一个阀门
    host.getPipeline().getFirst().invoke(request, response);

}</code></pre>
<p>tomcat的Pipeline处理是这样的：</p>
<ol>
<li><p>在生产线上的第一个工人拿到生产原料后，二话不说就人给下一个工人，下一个工人也是一样直接扔给下一个工人，直到最后一个工人，而最后一个工人被安排为上面提过的StandardValve，他要完成的是把生产资料运给自己所在包含的container的Pipeline上去。 </p>
</li>
<li><p>四个container就相当于有四个生产线（Pipeline），当StandardWrapperValve拿到资源开始调用servlet，返回后，再一步一步按照刚才丢生产原料是的顺序的倒序一次执行。</p>
</li>
</ol>
<h3 id="自定义tomcat阀门"><a href="#自定义tomcat阀门" class="headerlink" title="自定义tomcat阀门"></a>自定义tomcat阀门</h3><p>管道机制给我们带来了更好的拓展性，例如，你要添加一个额外的逻辑处理阀门是很容易的。自定义个阀门PrintIPValve，只要继承ValveBase并重写invoke方法即可。注意在invoke方法中一定要执行调用下一个阀门的操作，否则会出现异常。</p>
<pre><code class="java">public class PrintIPValve extends ValveBase{
    @Override
    public void invoke(Request request, Response response) throws IOException, ServletException {
        System.out.println(&quot;------自定义阀门PrintIPValve:&quot;+request.getRemoteAddr());
        getNext().invoke(request,response);
    }
}</code></pre>
<p>配置Tomcat的核心配置文件server.xml,这里把阀门配置到Engine容器下，作用范围就是整个引擎，也可以根据作用范围配置在Host或者是Context下</p>
<pre><code>&lt;Valve className=&quot;org.apache.catalina.valves.PrintIPValve&quot; /&gt;</code></pre><p>源码中可以直接生效，但是如果是运行版本，可以将这个类导出成一个Jar包放入Tomcat/lib目录下，也可以直接将.class文件打包进catalina.jar包中。</p>
<h3 id="tomcat中提供常用的阀门"><a href="#tomcat中提供常用的阀门" class="headerlink" title="tomcat中提供常用的阀门"></a>tomcat中提供常用的阀门</h3><p>AccessLogValve：请求访问日志阀门，通过此阀门可以记录所有客户端的访问日志，包括远程主机IP，远程主机名，请求方法，请求协议，会话ID，请求时间，处理时长，数据包大小等。它提供任意参数化的配置，可以通过任意组合来定制访问日志的格式。</p>
<p>JDBCAccessLogValve：同样是记录访问日志的阀门，但是它有助于将访问日志通过JDBC持久化到数据库中。</p>
<p>ErrorReportValve：这是一个讲错误以HTML格式输出的阀门。</p>
<p>PersistentValve：这是对每一个请求的会话实现持久化的阀门。</p>
<p>RemoteAddrValve：访问控制阀门。可以通过配置决定哪些IP可以访问WEB应用。</p>
<p>RemoteHostValve：访问控制阀门，通过配置觉得哪些主机名可以访问WEB应用。</p>
<p>RemoteIpValve：针对代理或者负载均衡处理的一个阀门，一般经过代理或者负载均衡转发的请求都将自己的IP添加到请求头”X-Forwarded-For”中，此时，通过阀门可以获取访问者真实的IP。</p>
<p>SemaphoreValve：这个是一个控制容器并发访问的阀门，可以作用在不同容器上。</p>
<h2 id="JVM中的类加载机制"><a href="#JVM中的类加载机制" class="headerlink" title="JVM中的类加载机制"></a>JVM中的类加载机制</h2><p><strong>类加载：</strong>主要是将.class文件中的二进制字节读入到JVM中</p>
<p>我们可以看到因为这个定义，所以并没有规定一定是要磁盘加载文件，可以通过网络，内存什么的加载。只要是二进制流字节数据，JVM就可以加载。</p>
<p><strong>类加载过程：</strong></p>
<ol>
<li><p>通过类的全限定名获取该类的二进制字节流；</p>
</li>
<li><p>将字节流所代表的静态结构转化为方法区的运行时数据结构</p>
</li>
<li><p>在内存中生成一个该类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</p>
</li>
</ol>
<p><strong>类加载器</strong>：</p>
<p>JVM设计者把“类加载”这个动作放到java虚拟机外部去实现，以便让应用程序决定如何获取所需要的类。实现这个动作的代码模块成为“类加载器”</p>
<p><strong>类的唯一性：</strong></p>
<p>对于任何一个类，都需要由加载它的类加载器和这个类来确定其在JVM中的唯一性。也就是说，两个类来源于同一个Class文件，并且被同一个类加载器加载，这两个类才相等。</p>
<p>注意：这里所谓的“相等”，一般使用instanceof关键字做判断。</p>
<p><strong>双亲委派模型：</strong></p>
<ul>
<li><p><strong>定义：</strong>双亲委派模型的工作过程为：如果一个类加载器收到了类请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父加载器去完成，每一层都是如此，因此所有类加载的请求都会传到启动类加载器，只有当父加载器无法完成该请求时，子加载器才去自己加载。</p>
</li>
<li><p><strong>实现方式：</strong>该模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。子类加载器不是以继承的关系来实现，而是通过组合关系来复用父加载器的代码。</p>
</li>
<li><p><strong>意义：</strong>好处双亲委派模型的好处就是java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如：Object,无论那个类加载器去加载该类，最终都是由启动类加载器进行加载的，因此Object类在程序的各种类加载环境中都是一个类。如果不用改模型，那么java.lang.Object类存放在classpath中，那么系统中就会出现多个Object类，程序变得很混乱。</p>
</li>
</ul>
<h5 id="类加载器的分类："><a href="#类加载器的分类：" class="headerlink" title="类加载器的分类："></a>类加载器的分类：</h5><p>从虚拟机的角度来说，有两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader）,该加载器使用C++语言实现，属于虚拟机自身的一部分。另一部分就是所有其它的类加载器，这些类加载器是由Java语言实现，独立于JVM外部，并且全部继承抽象类java.lang.ClassLoader.</p>
<p>  从java开发人员的角度看，大部分java程序会用到以下三种系统提供的类加载器：</p>
<ol>
<li><p>启动类加载器（Bootstrap ClassLoader）:负责加载JAVA_HOME\lib目录中并且能被虚拟机识别的类库加载到JVM内存中，如果名称不符合的类库即使在lib目录中也不会被加载。该类加载器无法被java程序直接引用。</p>
</li>
<li><p>扩展类加载器(Extension ClassLoader):该加载器主要负责加载JAVA_HOME\lib\ext目录中的类库，开发者可以使用扩展加载器。 </p>
</li>
<li><p>应用程序类加载器（Application ClassLoader）:该列加载器也称为系统加载器，它负责加载用户类路径(Classpath)上所指定的类库，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p>
</li>
</ol>
<h2 id="tomcat类加载的特性"><a href="#tomcat类加载的特性" class="headerlink" title="tomcat类加载的特性"></a>tomcat类加载的特性</h2><p><strong>隔离性</strong>：Web应用类库相互隔离，避免依赖库或者应用包相互影响，比如有两个Web应用，一个采用了Spring 4，一个采用了Spring 5，如果采用同一个类加载器，Web应用将会由于jar包覆盖而无法启动成功。</p>
<p><strong>灵活性</strong>：Web应用之间的类加载器相互独立，如果一个Web应用重新部署时，该应用的类加载器重新加载，不能影响其他web应用。</p>
<p><strong>性能</strong>：如果在一个Tomcat部署多个应用，多个应用中都有相同的类库依赖。那么可以把这相同的类库让Common类加载器进行加载。</p>
<h2 id="tomcat中的类加载器"><a href="#tomcat中的类加载器" class="headerlink" title="tomcat中的类加载器"></a>tomcat中的类加载器</h2>{% asset_img pic5.png %}

<p>Tomcat提供3个基础类加载器（common、catalina、shared）和Web应用类加载器。</p>
<ul>
<li><strong>Common Loader</strong>：Tomcat最基本的类加载器，加载<code>/common/*</code>路径中的class可以被Tomcat容器本身以及各个Webapp访问；</li>
<li><strong>Catalina Loader</strong>：Tomcat容器私有的类加载器，加载<code>/server/*</code>路径中的class对于Webapp不可见；</li>
<li><strong>Shared Loader</strong>：各个Webapp共享的类加载器，加载<code>/WebApp/WEB-INF/*</code>路径中的class对于所有Webapp可见，但是对于Tomcat容器不可见；</li>
<li><strong>WebappClass Loader</strong>：各个Webapp私有的类加载器，加载路径中的class只对当前Webapp可见；</li>
</ul>
<p>Tomcat通过Common类加载器实现了Jar包在应用服务器与Web应用之间的共享，通过Shared类加载器实现了Jar包在Web应用之间的共享，再过Catalina类加载器加载服务器依赖的类。</p>
<p>当应用需要到某个类时，则会按照下面的顺序进行类加载</p>
<ol>
<li>使用BootStrap ClassLoader加载</li>
<li>使用system系统类加载器加载</li>
<li>使用Webapp ClassLoader在WEB-INF/classes中加载</li>
<li>使用Webapp ClassLoader在WEB-INF/lib中加载</li>
<li>使用Common ClassLoader在CATALINA_HOME/lib中加载</li>
</ol>
<h3 id="类加载器的创建"><a href="#类加载器的创建" class="headerlink" title="类加载器的创建"></a>类加载器的创建</h3><p>3个基础类加载器的加载路径在catalina.properties配置，默认情况下，3个基础类加载器的实例都是一个。</p>
<pre><code class="java">public void init() throws Exception {

    //类加载器初始化
    initClassLoaders();

    //设置线程上下文类加载器，来解决有可能的ClassNotFoundException问题
    Thread.currentThread().setContextClassLoader(catalinaLoader);

    SecurityClassLoad.securityClassLoad(catalinaLoader);

    // 加载启动类Catalina并调用其process()方法
    if (log.isDebugEnabled())
        log.debug(&quot;Loading startup class&quot;);
    Class&lt;?&gt; startupClass = catalinaLoader.loadClass(&quot;org.apache.catalina.startup.Catalina&quot;);
    Object startupInstance = startupClass.getConstructor().newInstance();

    // 设置共享类加载器sharedLoader
    if (log.isDebugEnabled())
        log.debug(&quot;Setting startup class properties&quot;);
    String methodName = &quot;setParentClassLoader&quot;;
    Class&lt;?&gt; paramTypes[] = new Class[1];
    paramTypes[0] = Class.forName(&quot;java.lang.ClassLoader&quot;);
    Object paramValues[] = new Object[1];
    // 把shared加载器传递给catalina
    paramValues[0] = sharedLoader;
    Method method =
        startupInstance.getClass().getMethod(methodName, paramTypes);
    method.invoke(startupInstance, paramValues);

    catalinaDaemon = startupInstance;
}</code></pre>
<h3 id="类加载器初始化"><a href="#类加载器初始化" class="headerlink" title="类加载器初始化"></a>类加载器初始化</h3><p>Bootstartp的initClassLoaders()方法会在Boostrap的init()方法中调用，初始化三个类加载器以及确定父子关系。</p>
<pre><code class="java">//初始化三个类加载器以及确定父子关系
private void initClassLoaders() {
    try {
        // commonLoader的加载路径为common.loader
        commonLoader = createClassLoader(&quot;common&quot;, null);
        if (commonLoader == null) {
            // no config file, default to this loader - we might be in a &#39;single&#39; env.
            commonLoader = this.getClass().getClassLoader();
        }
        // 加载路径为server.loader，默认为空，父类加载器为commonLoader
        catalinaLoader = createClassLoader(&quot;server&quot;, commonLoader);
        // 加载路径为shared.loader，默认为空，父类加载器为commonLoader
        sharedLoader = createClassLoader(&quot;shared&quot;, commonLoader);
    } catch (Throwable t) {
        handleThrowable(t);
        log.error(&quot;Class loader creation threw exception&quot;, t);
        System.exit(1);
    }
}</code></pre>
<p>initClassLoaders()方法会调用createClassLoader()方法会根据catalina.properties中的内容创建对应的类加载器，如果为空则返回传入的父加载器。</p>
<pre><code class="java">private ClassLoader createClassLoader(String name, ClassLoader parent)
    throws Exception {

    String value = CatalinaProperties.getProperty(name + &quot;.loader&quot;);
    if ((value == null) || (value.equals(&quot;&quot;)))
        return parent;

    value = replace(value);

    List&lt;Repository&gt; repositories = new ArrayList&lt;&gt;();

    String[] repositoryPaths = getPaths(value);

    for (String repository : repositoryPaths) {
        // Check for a JAR URL repository
        try {
            @SuppressWarnings(&quot;unused&quot;)
            URL url = new URL(repository);
            repositories.add(new Repository(repository, RepositoryType.URL));
            continue;
        } catch (MalformedURLException e) {
            // Ignore
        }

        // Local repository
        if (repository.endsWith(&quot;*.jar&quot;)) {
            repository = repository.substring
                (0, repository.length() - &quot;*.jar&quot;.length());
            repositories.add(new Repository(repository, RepositoryType.GLOB));
        } else if (repository.endsWith(&quot;.jar&quot;)) {
            repositories.add(new Repository(repository, RepositoryType.JAR));
        } else {
            repositories.add(new Repository(repository, RepositoryType.DIR));
        }
    }

    return ClassLoaderFactory.createClassLoader(repositories, parent);
}</code></pre>
<p>catalina.properties中的内容</p>
<pre><code class="properties">common.loader=&quot;${catalina.base}/lib&quot;,&quot;${catalina.base}/lib/*.jar&quot;,&quot;${catalina.home}/lib&quot;,&quot;${catalina.home}/lib/*.jar&quot;
server.loader=
shared.loader=</code></pre>
<p>所以默认情况这三个类加载器是同一个实例，可以通过修改配置创建3个不同的类加载机制，使它们各司其职，如果不希望这些包对Web应用可见，因此我们可以配置server.loader，创建独立的Catalina类加载器。</p>
<h3 id="类加载工厂"><a href="#类加载工厂" class="headerlink" title="类加载工厂"></a>类加载工厂</h3><p>因为类加载需要做很多事情，比如读取字节数组、验证、解析、初始化等。Java提供的URLClassLoader类能够方便的将Jar、Class或者网络资源加载到内存中。Tomcat中使用一个工厂类，ClassLoaderFactory把创建类加载器的细节进行封装，可以通过它方便的创建自定义类加载器。</p>
<p>上述createClassLoader()方法中的<code>return ClassLoaderFactory.createClassLoader(repositories, parent);</code>方法就是使用类加载工厂来创建类加载器。</p>
<pre><code class="java">public static ClassLoader createClassLoader(List&lt;Repository&gt; repositories,
                                            final ClassLoader parent)
    throws Exception {

    if (log.isDebugEnabled())
        log.debug(&quot;Creating new class loader&quot;);

    // Construct the &quot;class path&quot; for this class loader
    Set&lt;URL&gt; set = new LinkedHashSet&lt;&gt;();

    if (repositories != null) {
        for (Repository repository : repositories)  {
            if (repository.getType() == RepositoryType.URL) {
                URL url = buildClassLoaderUrl(repository.getLocation());
                if (log.isDebugEnabled())
                    log.debug(&quot;  Including URL &quot; + url);
                set.add(url);
            } else if (repository.getType() == RepositoryType.DIR) {
                File directory = new File(repository.getLocation());
                directory = directory.getCanonicalFile();
                if (!validateFile(directory, RepositoryType.DIR)) {
                    continue;
                }
                URL url = buildClassLoaderUrl(directory);
                if (log.isDebugEnabled())
                    log.debug(&quot;  Including directory &quot; + url);
                set.add(url);
            } else if (repository.getType() == RepositoryType.JAR) {
                File file=new File(repository.getLocation());
                file = file.getCanonicalFile();
                if (!validateFile(file, RepositoryType.JAR)) {
                    continue;
                }
                URL url = buildClassLoaderUrl(file);
                if (log.isDebugEnabled())
                    log.debug(&quot;  Including jar file &quot; + url);
                set.add(url);
            } else if (repository.getType() == RepositoryType.GLOB) {
                File directory=new File(repository.getLocation());
                directory = directory.getCanonicalFile();
                if (!validateFile(directory, RepositoryType.GLOB)) {
                    continue;
                }
                if (log.isDebugEnabled())
                    log.debug(&quot;  Including directory glob &quot;
                        + directory.getAbsolutePath());
                String filenames[] = directory.list();
                if (filenames == null) {
                    continue;
                }
                for (int j = 0; j &lt; filenames.length; j++) {
                    String filename = filenames[j].toLowerCase(Locale.ENGLISH);
                    if (!filename.endsWith(&quot;.jar&quot;))
                        continue;
                    File file = new File(directory, filenames[j]);
                    file = file.getCanonicalFile();
                    if (!validateFile(file, RepositoryType.JAR)) {
                        continue;
                    }
                    if (log.isDebugEnabled())
                        log.debug(&quot;    Including glob jar file &quot;
                            + file.getAbsolutePath());
                    URL url = buildClassLoaderUrl(file);
                    set.add(url);
                }
            }
        }
    }

    // Construct the class loader itself
    final URL[] array = set.toArray(new URL[set.size()]);
    if (log.isDebugEnabled())
        for (int i = 0; i &lt; array.length; i++) {
            log.debug(&quot;  location &quot; + i + &quot; is &quot; + array[i]);
        }

    return AccessController.doPrivileged(
            new PrivilegedAction&lt;URLClassLoader&gt;() {
                @Override
                public URLClassLoader run() {
                    if (parent == null)
                        return new URLClassLoader(array);
                    else
                        return new URLClassLoader(array, parent);
                }
            });
}</code></pre>
<p>createClassLoader()方法会依据RepositoryType来执行不同的创建方法。</p>
<pre><code class="java">public enum RepositoryType {
    DIR, //表示整个目录下的资源，包括所有Class、jar包以及其他类型资源
    GLOB, //表示整个目录下的所有jar包资源
    JAR, //表示单个jar包资源
    URL //表示从URL上获取jar包资源
}</code></pre>
<p>使用加载器工厂的好处</p>
<ol>
<li>ClassLoadFactory有一个内部Repository，它就是表示资源的类，资源的类型用一个RepositoryType的枚举表示。</li>
<li>在检查jar包的时候，如果检查的URL地址有异常就忽略掉，可以确保部分类加载正确。</li>
</ol>
<h3 id="类加载器绑定到线程"><a href="#类加载器绑定到线程" class="headerlink" title="类加载器绑定到线程"></a>类加载器绑定到线程</h3><p>JVM提供了java.lang.Thread类的setContextClassLoader方法来绑定一个线程上下文类加载器（Thread Context ClassLoader），用于在运行时动态载入其他类，如果创建线程时未设置，将会从父线程中继承一个，所以大部分情况下，都是系统默认的ContextClassLoad。</p>
<p>一般在实际的系统上，使用线程上下文类加载器，可以设置不同的加载方式，这个也是Java灵活的类加载方式的体现，也可以很轻松的打破双亲委派模式，同时也会避免类加载的异常。</p>
<p>tomcat也使用了这种方式，来解决Commons ClassLoader需要Webapp ClassLoader中的类的情况。WebappLoader只会加载自己目录下的class文件，不会传递给父容器，所以tomcat将Webapp ClassLoader与线程绑定，使用线程上下文加载器，可以让父类加载器请求子类加载器去完成类加载的动作，不得不说，这是个巧妙的设计。</p>
<h3 id="tomcat的热加载"><a href="#tomcat的热加载" class="headerlink" title="tomcat的热加载"></a>tomcat的热加载</h3><p>StandardContext.startInternal()方法中还会调用threadStart()方法，threadStart()方法将创建一个线程，这个线程的while循环中，不断的调用方法，然后进行睡眠，以这种类似于定时器的方式，来执行任务，如重新加载等。</p>
<pre><code class="java">protected void threadStart() {

    if (thread != null)
        return;
    if (backgroundProcessorDelay &lt;= 0)
        return;

    threadDone = false;
    String threadName = &quot;ContainerBackgroundProcessor[&quot; + toString() + &quot;]&quot;;
    thread = new Thread(new ContainerBackgroundProcessor(), threadName);
    thread.setDaemon(true);
    thread.start();

}</code></pre>
<p>threadStart()方法调用链比较长，这里只分析WebappLoader的backgroudProcess()方法，该方法将完成类的重新加载。</p>
<pre><code class="java">public void backgroundProcess() {
    if (reloadable &amp;&amp; modified()) {
        try {
            //设置线程类加载器的类加载器WebappClassLoader
            Thread.currentThread().setContextClassLoader
                (WebappLoader.class.getClassLoader());
            if (context != null) {
                //重新加载的方法
                context.reload();
            }
        } finally {
            if (context != null &amp;&amp; context.getLoader() != null) {
                Thread.currentThread().setContextClassLoader
                    (context.getLoader().getClassLoader());
            }
        }
    }
}</code></pre>

            </div>
            <hr>
            <div>
              <p>
                
                  <span>
                <i class="iconfont icon-inbox"></i>
                    
                      <a class="hover-with-bg" href="/categories/tomcat/">tomcat</a>
                      &nbsp;
                    
                  </span>&nbsp;&nbsp;
                
                
                  <span>
                <i class="iconfont icon-tag"></i>
                    
                      <a class="hover-with-bg" href="/tags/tomcat/">tomcat</a>
                    
                  </span>
                
              </p>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/04/30/tomcat%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/">
                        <span class="hidden-mobile">tomcat体系架构</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="fa fa-chevron-right"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

              
                <!-- Comments -->
                <div class="comments" id="comments">
                  
                  

                </div>
              
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc-start"></div>
<div id="toc">
  <p class="h5"><i class="far fa-list-alt"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a class="z-depth-1" id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"> <b>Fluid</b></a>
    </div>
    
  <div>
    
      <!-- 不蒜子统计PV -->
      
      <span id="busuanzi_container_site_pv" style="display: none">
      总访问量 <span id="busuanzi_value_site_pv"></span> 次
    </span>
    
    
      <!-- 不蒜子统计UV -->
      
      <span id="busuanzi_container_site_uv" style="display: none">
      总访客数 <span id="busuanzi_value_site_uv"></span> 人
    </span>
    
  </div>


    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/popper.js/1.16.1/umd/popper.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="https://cdn.staticfile.org/mdbootstrap/4.13.0/js/mdb.min.js" ></script>
<script  src="/js/main.js" ></script>


  <script  src="/js/lazyload.js" ></script>



  
  <script  src="https://cdn.staticfile.org/tocbot/4.10.0/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var navHeight = $('#navbar').height();
      var toc = $('#toc');
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;
      var tocLimMax = 2 * boardTop + boardCtn.height();

      $(window).scroll(function () {
        var tocLimMin = $('#toc-start').offset().top - navHeight;
        var scroH = document.body.scrollTop + document.documentElement.scrollTop;

        if (tocLimMin <= scroH && scroH <= tocLimMax) {
          toc.css({
            'display': 'block',
            'position': 'fixed',
            'top': navHeight,
          });
        } else if (scroH <= tocLimMin) {
          toc.css({
            'position': '',
            'top': '',
          });
        } else if (scroH > tocLimMax) {
          toc.css('display', 'none');
        }
      });
      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '.post-content',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc > p').css('visibility', 'visible');
      }
      var offset = boardCtn.css('margin-right')
      $('#toc-ctn').css({
        'right': offset
      })
    });
  </script>





  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>



  <script defer src="https://cdn.staticfile.org/smoothscroll/1.4.10/SmoothScroll.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




<!-- Plugins -->


  

  

  

  

  

  



  <script  src="https://cdn.staticfile.org/prettify/188.0.0/prettify.min.js" ></script>
  <script>
    $(document).ready(function () {
      $('pre').addClass('prettyprint  linenums');
      prettyPrint();
    })
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "tomcat源码解析&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script defer src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <script>
    $("#post img:not(.no-zoom img, img[no-zoom])").each(
      function () {
        var element = document.createElement("a");
        $(element).attr("data-fancybox", "images");
        $(element).attr("href", $(this).attr("src"));
        $(this).wrap(element);
      }
    );
  </script>





  
  
    <script type="text/javascript">
      //定义获取词语下标
      var a_idx = 0;
      jQuery(document).ready(function ($) {
        //点击body时触发事件
        $("body").click(function (e) {
          //需要显示的词语
          var a = new Array("富强", "民主", "文明", "和谐", "自由", "平等", "公正", "法治", "爱国", "敬业", "诚信", "友善");
          //设置词语给span标签
          var $i = $("<span/>").text(a[a_idx]);
          //下标等于原来下标+1  余 词语总数
          a_idx = (a_idx + 1) % a.length;
          //获取鼠标指针的位置，分别相对于文档的左和右边缘。
          //获取x和y的指针坐标
          var x = e.pageX, y = e.pageY;
          //在鼠标的指针的位置给$i定义的span标签添加css样式
          $i.css({
            "z-index": 999,
            "top": y - 20,
            "left": x,
            "position": "absolute",
            "font-weight": "bold",
            "color": rand_color()
          });
          // 随机颜色
          function rand_color() {
            return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"
          }
          //在body添加这个标签
          $("body").append($i);
          //animate() 方法执行 CSS 属性集的自定义动画。
          //该方法通过CSS样式将元素从一个状态改变为另一个状态。CSS属性值是逐渐改变的，这样就可以创建动画效果。
          //详情请看http://www.w3school.com.cn/jquery/effect_animate.asp
          $i.animate({
            //将原来的位置向上移动180
            "top": y - 180,
            "opacity": 0
            //1500动画的速度
          }, 1500, function () {
            //时间到了自动删除
            $i.remove();
          });
        });
      })
      ;
    </script>
  








</body>
</html>
