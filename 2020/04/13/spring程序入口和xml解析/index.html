<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/blog/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/blog/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="">
  <meta name="keywords" content="">
  <title>spring程序入口和xml解析 - 🍎🍊&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/5.12.1/css/all.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/mdbootstrap/4.13.0/css/mdb.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/3.0.1/github-markdown.min.css" />

<link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">



  <link  rel="stylesheet" href="/blog/lib/prettify/tomorrow-night-eighties.min.css" />

<link  rel="stylesheet" href="/blog/css/main.css" />


  <link defer rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />


<!-- 自定义样式保持在最底部 -->


<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/blog/">&nbsp;<strong>🍎🍊's blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/blog/">首页</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/blog/archives/">归档</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/blog/categories/">分类</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/blog/tags/">标签</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/blog/about">关于</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/blog/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
                <p class="mt-3 post-meta">
                  <i class="fas fa-calendar-alt" aria-hidden="true"></i>
                  星期一, 四月 13日 2020, 7:02 晚上
                </p>
              

              <p class="mt-1">
                
                  
                  <span class="post-meta">
                    <i class="far fa-chart-bar"></i>
                    7.4k 字
                  </span>
                

                
                  
                  <span class="post-meta">
                      <i class="far fa-clock"></i>
                      34 分钟
                  </span>
                

                
                  <!-- 不蒜子统计文章PV -->
                  
                  <span id="busuanzi_container_page_pv" class="post-meta" style="display: none">
                    <i class="far fa-eye" aria-hidden="true"></i>
                    <span id="busuanzi_value_page_pv"></span> 次
                  </span>
                
              </p>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5 z-depth-3" id="board">
          <div class="post-content mx-auto" id="post">
            
              <p
                class="note note-warning">本文最后更新于：星期二, 四月 21日 2020, 6:16 晚上</p>
            
            <div class="markdown-body">
              <h2 id="Spring的历史"><a href="#Spring的历史" class="headerlink" title="Spring的历史"></a>Spring的历史</h2><ul>
<li><p>2002年10月，Rod Johnso发布《Expert One-on-One J2EE 设计和开发》一书</p>
</li>
<li><p>2004 年 3 月，Spring1.0 发布</p>
<p>2003 年 6 月，Spring Framework 第一次以 Apache 2.0 许可证下发布 0.9 版 本，2004 年 3 月，Spring1.0 正式发布。对于 Spring1.0，其源码只有一个包，在该包中包含了 aop、beans、context、 core、jdbc、orm 等。对于此时的版本，Spring1.0 仅支持 XML 配置的方式。</p>
</li>
<li><p>2006 年 10 月，Spring2.0 发布<br>对于 2.0，Spring 主要增加了对注解的支持，实现了基于注解的配置。</p>
<p>在 2007 年 11 月，发布 Spring2.5，该版本具备的特性有：</p>
<ul>
<li><p>添加可扩展的 XML 配置功能，用于简化 XML 配置，</p>
</li>
<li><p>支持 Java5</p>
</li>
<li><p>添加额外的 IOC 容器扩展点，支持动态语言(如 groovy，aop 增强功能和新 的 bean 范围 )</p>
</li>
</ul>
</li>
<li><p>2009 年 12 月，Spring3.0 发布</p>
<p>Spring3.0 主要具有的特性有: </p>
<ul>
<li>模块重组系统</li>
<li>支持 Spring 表达式语言(Spring Expression)</li>
<li>基于 Java 的 Bean 配置(JavaConfig) 支持嵌入式数据库:HSQL、H2 等 支持 REST</li>
<li>支持 Java6</li>
</ul>
</li>
<li><p>2013 年 12 月，发布 Spring4.0</p>
<p>对于 Spring4.0 是 Spring 版本历史上的一重大升级。其特性为: </p>
<ul>
<li>全面支持 Java8支持 Lambda 表达式。</li>
<li>支持 Java8 的时间和日期 API</li>
<li>支持重复注解</li>
<li>支持 Java8 的 Optional</li>
<li>核心容器增强</li>
<li>增加泛型依赖注入</li>
<li>增加 Map 依赖注入</li>
<li>增加 List 依赖注入</li>
<li>支持 lazy 注解配置懒加载</li>
<li>支持 Condition 条件注解</li>
<li>CGLIB 动态代理增强</li>
<li>支持基于 GroovyDSL 定义 Bean</li>
<li>Web 增强</li>
<li>增强 SpringMVC，基于 Servlet3.0 开发</li>
<li>提供 RestController 注解</li>
<li>提供 AsyncRestTemplate 支持客户端的异步无阻塞请求</li>
<li>增加对 WebSocket 的支持</li>
</ul>
</li>
<li><p>2017 年 9 月，Spring5.0 发布</p>
<p>Spring5.0 特性如下：</p>
<ul>
<li>升级到 Java8、JavaEE7</li>
<li>废弃低版本，将 Java8、JavaEE 7 作为最低版本要求 兼容 Java9、兼容 JavaEE8</li>
<li>反应式编程模型，增加 WebFlux 模块</li>
<li>升级 SpringMVC，增加对最新的 API(Jackson 等)的支持 增加函数式编程模式</li>
<li>重构源码，部分功能使用 Lambda 表达式实现</li>
</ul>
</li>
</ul>
<h2 id="Spring的子项目"><a href="#Spring的子项目" class="headerlink" title="Spring的子项目"></a>Spring的子项目</h2><ul>
<li>Spring IO Platform : Spring IO 是可集成的、构建现代化应用的版本平台。Spring IO 是模块化的、企业级的分布式系统，包括一系列依赖，是的开发者仅能对自己所需的部分进行完全的部署控制。</li>
<li>Spring Boot:Spring 应用快速开发工具，用来简化 Spring 应用开发过程。 </li>
<li>Spring XD:Spring XD(eXtreme Date，极限数据)是 Pivotal 的大数据产品。它结合了 Spring Boot 和 Grails，组成 Spring IO 平台的执行部分。</li>
<li>Spring Data:Spring Data 是为了简化构建基于 Spring 框架应用的数据访问实现，包括非关系数据库、Map-Reduce 框架、云数据服务等;另外，也包含对关 系数据库的访问支持。</li>
<li>Spring Integration:Spring Integration 为企业数据集成提供了各种适配器，可以通过这些适配器来转换各种消息格式，并帮助 Spring 应用完成与企业应用系统的集成。</li>
<li>Spring Batch:Spring Batch 是一个轻量级的完整批处理框架，旨在帮助应用开发者构建一个健壮、高效的企业级批处理应用(这些应用的特点是不需要与用 户交互，重复的操作量大，对于大容量的批量数据处理而言，这些操作往往要求 较高的可靠性)</li>
<li>Spring Security:Spring Security 是一个能够为基于 Spring 的企业应用系统提 供声明式的安全访问控制解决方案的安全框架。它提供了一组可以在 Spring 应用 上下文配置的 bean，充分利用 Ioc 和 AOP 功能，为应用系统提供声明式的安全 访问控制功能。</li>
<li>Spring Hateoas:Spring Hateoas 是一个用户支持实现超文本驱动的 REST Web 服务的开发库，是 Hateoas 的实现。Hateoas(Hypermedia as the engine of application state)是 REST 架构风格中最复杂的约束，也是构建成熟 REST 服务的核 心。它的重要性在于打破了客户端和服务器之间严格的契约，是的客户端可以更加智能和自适应。</li>
<li>Spring Social:Spring Social 是 Spring 框架的扩展，用来方便开发 Web 社交应用程序，可通过该项目来创建与各种社交网站的交互，如 Facebook，LinkedIn、 Twitter 等。</li>
<li>Spring AMQP:Spring AMQP 是基于 Spring 框架的 AMQP 消息解决方案，提供 模版化的发送和接收消息的抽象层，提供基于消息驱动的 POJO。这个项目支持 Java和.NET连个版本。Spring Source旗下的Rabbit MQ就是一个开源的基于AMQP 的消息服务器。</li>
<li>Spring for Android:Spring for Android 为 Android 终端开发应用提供 Spring 的 支持，它提供了一个在 Android 应用环境中工作、基于 Java的REST 客户端。</li>
<li>Spring Mobile:Spring Mobile 是基于 Spring MVC 构建的，为移动端的服务器 应用开发提供支持。</li>
<li>Spring Web Flow:Spring Web Flow(SWF)一个建立在 Spring MVC 基础上的 Web 页面流引擎。</li>
<li>Spring Web Service:Spring Web Service 是基于 Spring 框架的 Web 服务框架， 主要侧重于基于文档驱动的 Web 服务，提供 SOAP 服务开发，允许通过多种方 式创建 Web 服务。</li>
<li>Spring LDAP:Spring LDAP 是一个用户操作 LDAP 的 Java 框架，类似 Spring JDBC 提供了 JdbcTemplate 方式来操作数据库。这个框架提供了一个 LdapTemplate 操 作模版，可帮助开发人员简化 looking up、closing contexts、encoding/decoding、 filters 等操作。</li>
<li>Spring Session: Spring Session 致力于提供一个公共基础设施会话，支持从任意环境中访问一个会话，在 Web 环境下支持独立于容器的集群会话，支持可插拔策略来确定 Session ID，WebSocket 活跃的时候可以简单地保持 HttpSession。</li>
<li>Spring Shell: Spring Shell 提供交互式的 Shell，用户可以简单的基于 Spring 的编程模型来开发命令。</li>
</ul>
<h2 id="Spring容器的加载方式"><a href="#Spring容器的加载方式" class="headerlink" title="Spring容器的加载方式"></a>Spring容器的加载方式</h2><ul>
<li><p>类路径获取配置文件<br>ApplicationContext applicationContext= new ClassPathXmlApplicationContext(“spring.xml”);</p>
</li>
<li><p>文件系统路径获取配置文件【绝对路径】<br>ApplicationContext applicationContext = new FileSystemXmlApplicationContext(“E:\idea\public\springdemo\src\main\resou rces\spring.xml”);</p>
</li>
<li><p>无配置文件加载容器 ApplicationContext applicationContext = new<br>AnnotationConfigApplicationContext(“com.xx.jack”);</p>
</li>
<li><p>springboot 加载容器 ApplicationContext applicationContext = new<br>EmbeddedWebApplicationContext();</p>
</li>
</ul>
<h2 id="Spring容器加载的核心方法"><a href="#Spring容器加载的核心方法" class="headerlink" title="Spring容器加载的核心方法"></a>Spring容器加载的核心方法</h2><p>AbstractApplicationContext.refresh()方法</p>
<p>refresh()方法是spring容器启动过程中的核心方法，spring容器要加载必须执行该方法。</p>
<pre><code class="java">    @Override
    public void refresh() throws BeansException, IllegalStateException {
        synchronized (this.startupShutdownMonitor) {
            //为容器初始化做准备，重要程度：0
            //Prepare this context for refreshing.
            prepareRefresh();

            /**
            * 重要程度：5
            * 1、创建BeanFactory对象
            * 2、xml解析
            *     传统标签解析：bean、import等
            *     自定义标签解析 如：&lt;context:component-scan base-package=&quot;com.xiangxue.jack&quot;/&gt;
            *     自定义标签解析流程：
            *         a、根据当前解析标签的头信息找到对应的namespaceUri
            *         b、加载spring所以jar中的spring.handlers文件。并建立映射关系
            *         c、根据namespaceUri从映射关系中找到对应的实现了NamespaceHandler接口的类
            *         d、调用类的init方法，init方法是注册了各种自定义标签的解析类
            *         e、根据namespaceUri找到对应的解析类，然后调用paser方法完成标签解析
            *
            * 3、把解析出来的xml标签封装成BeanDefinition对象
            * */
            // Tell the subclass to refresh the internal bean factory.
            ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

            /*
            * 给beanFactory设置一些属性值，可以不看
            * */
            // Prepare the bean factory for use in this context.
            prepareBeanFactory(beanFactory);

            try {
                //TODO
                // Allows post-processing of the bean factory in context subclasses.
                postProcessBeanFactory(beanFactory);

                /*
                * BeanDefinitionRegistryPostProcessor
                * BeanFactoryPostProcessor
                * 完成对这两个接口的调用
                * */
                // Invoke factory processors registered as beans in the context.
                invokeBeanFactoryPostProcessors(beanFactory);

                /*
                * 把实现了BeanPostProcessor接口的类实例化，并且加入到BeanFactory中
                * */
                // Register bean processors that intercept bean creation.
                registerBeanPostProcessors(beanFactory);

                /*
                * 国际化,重要程度2
                * */
                // Initialize message source for this context.
                initMessageSource();

                //初始化事件管理类
                // Initialize event multicaster for this context.
                initApplicationEventMulticaster();

                //这个方法着重理解模板设计模式，因为在springboot中，这个方法是用来做内嵌tomcat启动的
                // Initialize other special beans in specific context subclasses.
                onRefresh();

                /*
                * 往事件管理类中注册事件类
                * */
                // Check for listener beans and register them.
                registerListeners();

                /*
                * 这个方法是spring中最重要的方法，没有之一
                * 所以这个方法一定要理解要具体看
                * 1、bean实例化过程
                * 2、ioc
                * 3、注解支持
                * 4、BeanPostProcessor的执行
                * 5、Aop的入口
                *
                * */
                // Instantiate all remaining (non-lazy-init) singletons.
                finishBeanFactoryInitialization(beanFactory);

                // Last step: publish corresponding event.
                finishRefresh();
            }

            catch (BeansException ex) {
                if (logger.isWarnEnabled()) {
                    logger.warn(&quot;Exception encountered during context initialization - &quot; +
                            &quot;cancelling refresh attempt: &quot; + ex);
                }

                // Destroy already created singletons to avoid dangling resources.
                destroyBeans();

                // Reset &#39;active&#39; flag.
                cancelRefresh(ex);

                // Propagate exception to caller.
                throw ex;
            }

            finally {
                // Reset common introspection caches in Spring&#39;s core, since we
                // might not ever need metadata for singleton beans anymore...
                resetCommonCaches();
            }
        }
    }</code></pre>
<h2 id="设计模式1-模版设计模式"><a href="#设计模式1-模版设计模式" class="headerlink" title="设计模式1-模版设计模式"></a>设计模式1-模版设计模式</h2><p>spring源码中大量使用了模版设计模式，是使用的最多的设计模式。</p>
<p>模版设计模式一般有两种类，抽象的父类，以及具体实现的子类。父类中实现逻辑中不变的部分，将可变的行为定义为抽象方法交给子类实现，但方法的执行顺序由父类决定。</p>
<p>创建一个抽象模版结构</p>
<pre><code class="java">public abstract class AblstractClass {

    //模板方法用来控制子类的顺序 要想有人生必须按老爸的人生顺序来  
    //声明final不让子类覆盖这个方法，防止改变人生顺序
    public final void 人生(){
        学习();
        工作();
        爱情();
    }

    //家里穷更得用工学习
    public void 学习(){
        System.out.println(&quot;每天晚上趴在邻居窗上学习&quot;);
    }

    //工作必须稳定
    public void 工作(){       
        System.out.println(&quot;从一而终&quot;);
    }

    //恋爱自由  让儿子自由恋去
    public abstract void 爱情();
}</code></pre>
<p>创建一个具体模版</p>
<pre><code class="java">public class ConcreteClass extends AblstractClass {

    //儿子不认可父亲的学习方法  考高分影响同学关系
    @Override
    public void 学习() {
        System.out.println(&quot;60分万岁...&quot;);
    }

    //父亲给我爱情自由  一定好好谈恋爱
    @Override
    public void 爱情() {
        System.out.println(&quot;肤白貌美大长腿...&quot;);
    }
}</code></pre>
<p>具体的调用</p>
<pre><code class="java">public class TestMain {

    public static void main(String[] args) {
         ConcreteClass cs  = new ConcreteClass();
         cs.人生();
    }
}</code></pre>
<h2 id="xml解析"><a href="#xml解析" class="headerlink" title="xml解析"></a>xml解析</h2><p>ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</p>
<p>该方法主要进行xml解析工作，流程如下：</p>
<ol>
<li><p>创建XmlBeanDefinitionReader对象</p>
<pre><code class="java">        XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);</code></pre>
</li>
<li><p>通过Reader对象加载配置文件</p>
<pre><code class="java">    protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException {
        Resource[] configResources = getConfigResources();
        if (configResources != null) {
            reader.loadBeanDefinitions(configResources);
        }
        //获取需要加载的xml配置文件
        String[] configLocations = getConfigLocations();
        if (configLocations != null) {
            reader.loadBeanDefinitions(configLocations);
        }
    }</code></pre>
</li>
<li><p>根据加载的配置文件把配置文件封装成document对象</p>
<pre><code class="java">    protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)
            throws BeanDefinitionStoreException {

        try {
            //把inputSource 封装成Document文件对象，这是jdk的API
            Document doc = doLoadDocument(inputSource, resource);

            //主要看这个方法，根据解析出来的document对象，拿到里面的标签元素封装成BeanDefinition
            int count = registerBeanDefinitions(doc, resource);
            if (logger.isDebugEnabled()) {
                logger.debug(&quot;Loaded &quot; + count + &quot; bean definitions from &quot; + resource);
            }
            return count;
        }</code></pre>
</li>
<li><p>创建BeanDefinitionDocumentReader对象，DocumentReader负责对document对象解析</p>
<pre><code class="java">    public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException {
        //又来一记委托模式，BeanDefinitionDocumentReader委托这个类进行document的解析
        BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();
        int countBefore = getRegistry().getBeanDefinitionCount();
        //主要看这个方法，createReaderContext(resource) XmlReaderContext上下文，封装了XmlBeanDefinitionReader对象
        documentReader.registerBeanDefinitions(doc, createReaderContext(resource));
        return getRegistry().getBeanDefinitionCount() - countBefore;
    }</code></pre>
</li>
<li><p>parseDefaultElement(ele,delegate);负责常规标签的解析，delegate.parseCustomElement(ele)负责自定义标签的解析</p>
<pre><code>    protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {
        if (delegate.isDefaultNamespace(root)) {
            NodeList nl = root.getChildNodes();
            for (int i = 0; i &lt; nl.getLength(); i++) {
                Node node = nl.item(i);
                if (node instanceof Element) {
                    Element ele = (Element) node;
                    if (delegate.isDefaultNamespace(ele)) {
                        //默认标签解析
                        parseDefaultElement(ele, delegate);
                    }
                    else {
                        //自定义标签解析
                        delegate.parseCustomElement(ele);
                    }
                }
            }
        }
        else {
            delegate.parseCustomElement(root);
        }
    }</code></pre></li>
<li><p>最终解析的标签封装成BeanDefinition并缓存到容器中。</p>
</li>
<li><p>xml流程分析</p>
</li>
</ol>
<img src="/blog/2020/04/13/spring%E7%A8%8B%E5%BA%8F%E5%85%A5%E5%8F%A3%E5%92%8Cxml%E8%A7%A3%E6%9E%90/pic1.png" srcset="/blog/img/loading.gif" class>

<h2 id="自定义标签解析"><a href="#自定义标签解析" class="headerlink" title="自定义标签解析"></a>自定义标签解析</h2><ol>
<li><p>首先获取自定义标签头的namespace命名空间，例如：<code>http://www.springframework.org/schema/context</code>，然后通过namespace获取到NamespaceHandler处理类，之后再使用NamespaceHandler中的解析类解析标签获得BeanDefinition对象。</p>
<pre><code class="java">    public BeanDefinition parseCustomElement(Element ele, @Nullable BeanDefinition containingBd) {
      // 获取自定义标签的命名空间
        String namespaceUri = getNamespaceURI(ele);
        if (namespaceUri == null) {
            return null;
        }
    // 这里有SPI服务发现的思想，根据配置文件获取namespaceUri对应的处理类
        NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);
        if (handler == null) {
            error(&quot;Unable to locate Spring NamespaceHandler for XML schema namespace [&quot; + namespaceUri + &quot;]&quot;, ele);
            return null;
        }
        return handler.parse(ele, new ParserContext(this.readerContext, this, containingBd));
    }</code></pre>
</li>
<li><p>获取namespace与NamespaceHandler实例的映射关系，然后通过反射创建实例，并调用NamespaceHandler的init()方法完成解析类的注册。</p>
<pre><code class="java">    public NamespaceHandler resolve(String namespaceUri) {
        //获取spring中所有jar包里面的 &quot;META-INF/spring.handlers&quot;文件，并且建立映射关系
        Map&lt;String, Object&gt; handlerMappings = getHandlerMappings();

        //根据namespaceUri：http://www.springframework.org/schema/p，获取到这个命名空间的处理类
        Object handlerOrClassName = handlerMappings.get(namespaceUri);
        if (handlerOrClassName == null) {
            return null;
        }
        else if (handlerOrClassName instanceof NamespaceHandler) {
            return (NamespaceHandler) handlerOrClassName;
        }
        else {
            String className = (String) handlerOrClassName;
            try {
                Class&lt;?&gt; handlerClass = ClassUtils.forName(className, this.classLoader);
                if (!NamespaceHandler.class.isAssignableFrom(handlerClass)) {
                    throw new FatalBeanException(&quot;Class [&quot; + className + &quot;] for namespace [&quot; + namespaceUri +
                            &quot;] does not implement the [&quot; + NamespaceHandler.class.getName() + &quot;] interface&quot;);
                }
                NamespaceHandler namespaceHandler = (NamespaceHandler) BeanUtils.instantiateClass(handlerClass);

                //调用处理类的init方法，在init方法中完成标签元素解析类的注册
                namespaceHandler.init();
                handlerMappings.put(namespaceUri, namespaceHandler);
                return namespaceHandler;
            }
            catch (ClassNotFoundException ex) {
                throw new FatalBeanException(&quot;Could not find NamespaceHandler class [&quot; + className +
                        &quot;] for namespace [&quot; + namespaceUri + &quot;]&quot;, ex);
            }
            catch (LinkageError err) {
                throw new FatalBeanException(&quot;Unresolvable class definition for NamespaceHandler class [&quot; +
                        className + &quot;] for namespace [&quot; + namespaceUri + &quot;]&quot;, err);
            }
        }
    }</code></pre>
</li>
<li><p>获取namespace跟NamespaceHandler映射关系的详细过程。spring在jar包的META-INF/spring.handlers文件中，已经保存了NamespaceUri和NamepsaceHandler之间的映射。此处会加载spring.handlers中的所有内容并保存在map中。</p>
<pre><code class="java">    private Map&lt;String, Object&gt; getHandlerMappings() {
        Map&lt;String, Object&gt; handlerMappings = this.handlerMappings;
        if (handlerMappings == null) {
            synchronized (this) {
                handlerMappings = this.handlerMappings;
                if (handlerMappings == null) {
                    if (logger.isTraceEnabled()) {
                        logger.trace(&quot;Loading NamespaceHandler mappings from [&quot; + this.handlerMappingsLocation + &quot;]&quot;);
                    }
                    try {
                        //加载&quot;META-INF/spring.handlers&quot;文件过程
                        Properties mappings =
                                PropertiesLoaderUtils.loadAllProperties(this.handlerMappingsLocation, this.classLoader);
                        if (logger.isTraceEnabled()) {
                            logger.trace(&quot;Loaded NamespaceHandler mappings: &quot; + mappings);
                        }

                        //所有&quot;META-INF/spring.handlers&quot;文件里面的内容建立映射关系
                        handlerMappings = new ConcurrentHashMap&lt;&gt;(mappings.size());
                        CollectionUtils.mergePropertiesIntoMap(mappings, handlerMappings);
                        this.handlerMappings = handlerMappings;
                    }
                    catch (IOException ex) {
                        throw new IllegalStateException(
                                &quot;Unable to load NamespaceHandler mappings from location [&quot; + this.handlerMappingsLocation + &quot;]&quot;, ex);
                    }
                }
            }
        }
        return handlerMappings;
    }</code></pre>
</li>
</ol>
<h2 id="默认标签的解析"><a href="#默认标签的解析" class="headerlink" title="默认标签的解析"></a>默认标签的解析</h2><ol>
<li><p>默认标签分为四种，import、alias、bean、beans，这里主要看bean标签的解析。</p>
<pre><code class="java">    private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) {
        //import标签解析  重要程度 1 ，可看可不看
        if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) {
            importBeanDefinitionResource(ele);
        }
        //alias标签解析 别名标签  重要程度 1 ，可看可不看
        else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) {
            processAliasRegistration(ele);
        }
        //bean标签，重要程度  5，必须看
        else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {
            processBeanDefinition(ele, delegate);
        }
        else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) {
            // recurse
            doRegisterBeanDefinitions(ele);
        }
    }</code></pre>
</li>
<li><p>先调用parseBeanDefinitionElement(ele)方法首先解析节点属性封装为BeanDefinitionHolder对象，之后再解析BeanDefinitionHolder对象中的自定义属性，并使用装饰者模式将解析后的属性设置到BeanDefinitionHolder中，然后对BeanDefinitionHolder进行注册。</p>
<pre><code class="java">    protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {
        //重点看这个方法，重要程度 5 ，解析ele，封装成BeanDefinition
        BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);
        if (bdHolder != null) {

            //该方法功能不重要，设计模式重点看一下，装饰者设计模式，加上SPI设计思想
            bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);
            try {

                //完成document到BeanDefinition对象转换后，对BeanDefinition对象进行缓存注册
                // Register the final decorated instance.
                //注册过程，重要程度5
                BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());
            }
            catch (BeanDefinitionStoreException ex) {
                getReaderContext().error(&quot;Failed to register bean definition with name &#39;&quot; +
                        bdHolder.getBeanName() + &quot;&#39;&quot;, ele, ex);
            }
            // Send registration event.
            getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));
        }
    }</code></pre>
</li>
<li><p>初次解析标签的过程。这里解析完成后会返回到上层方法，上层方法会将BeanDefinition、beanname、aliases（别名）封装为BeanDefinitionHolder并返回。</p>
<pre><code class="java">    public AbstractBeanDefinition parseBeanDefinitionElement(
            Element ele, String beanName, @Nullable BeanDefinition containingBean) {

        this.parseState.push(new BeanEntry(beanName));

        String className = null;
        if (ele.hasAttribute(CLASS_ATTRIBUTE)) {
            className = ele.getAttribute(CLASS_ATTRIBUTE).trim();
        }
        String parent = null;
        if (ele.hasAttribute(PARENT_ATTRIBUTE)) {
            parent = ele.getAttribute(PARENT_ATTRIBUTE);
        }

        try {
            //创建GenericBeanDefinition对象
            AbstractBeanDefinition bd = createBeanDefinition(className, parent);

            //解析bean标签的属性，并把解析出来的属性设置到BeanDefinition对象中
            parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);
            bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));

            //解析bean中的meta标签
            parseMetaElements(ele, bd);

            //解析bean中的lookup-method标签  重要程度：2，可看可不看
            parseLookupOverrideSubElements(ele, bd.getMethodOverrides());

            //解析bean中的replaced-method标签  重要程度：2，可看可不看
            parseReplacedMethodSubElements(ele, bd.getMethodOverrides());

            //解析bean中的constructor-arg标签  重要程度：2，可看可不看
            parseConstructorArgElements(ele, bd);

            //解析bean中的property标签  重要程度：2，可看可不看
            parsePropertyElements(ele, bd);

            //可以不看，用不到
            parseQualifierElements(ele, bd);

            bd.setResource(this.readerContext.getResource());
            bd.setSource(extractSource(ele));

            return bd;
        }</code></pre>
</li>
<li><p>对标签中的自定义属性再次进行解析，此处用到的SPI思想跟装饰者模式，通过SPI思想获取处理类的方式与自定义标签解析中的方式相同，此处不再赘述。</p>
<pre><code class="java">    public BeanDefinitionHolder decorateIfRequired(
            Node node, BeanDefinitionHolder originalDef, @Nullable BeanDefinition containingBd) {

        //根据node获取到node的命名空间，形如：http://www.springframework.org/schema/p
        String namespaceUri = getNamespaceURI(node);
        if (namespaceUri != null &amp;&amp; !isDefaultNamespace(namespaceUri)) {

            //这里有SPI服务发现的思想，根据配置文件获取namespaceUri对应的处理类
            NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);
            if (handler != null) {

                //调用NamespaceHandler处理类的decorate方法，开始具体装饰过程，并返回装饰完的对象
                BeanDefinitionHolder decorated =
                        handler.decorate(node, originalDef, new ParserContext(this.readerContext, this, containingBd));
                if (decorated != null) {
                    return decorated;
                }
            }
            else if (namespaceUri.startsWith(&quot;http://www.springframework.org/&quot;)) {
                error(&quot;Unable to locate Spring NamespaceHandler for XML schema namespace [&quot; + namespaceUri + &quot;]&quot;, node);
            }
            else {
                // A custom namespace, not to be handled by Spring - maybe &quot;xml:...&quot;.
                if (logger.isDebugEnabled()) {
                    logger.debug(&quot;No Spring NamespaceHandler found for XML schema namespace [&quot; + namespaceUri + &quot;]&quot;);
                }
            }
        }
        return originalDef;
    }</code></pre>
</li>
<li><p>注册过程，此处完成完成BeanDefinition的注册后会将beanname与aliases建立联系。</p>
<pre><code class="java">    public static void registerBeanDefinition(
            BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)
            throws BeanDefinitionStoreException {

        // Register bean definition under primary name.
        String beanName = definitionHolder.getBeanName();

        //完成BeanDefinition的注册，重点看，重要程度 5
        registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());

        //建立别名和 id的映射，这样就可以根据别名获取到id
        // Register aliases for bean name, if any.
        String[] aliases = definitionHolder.getAliases();
        if (aliases != null) {
            for (String alias : aliases) {
                registry.registerAlias(beanName, alias);
            }
        }
    }</code></pre>
</li>
<li><p>BeanDefinition的注册详细过程。将beanname与beanDefinition缓存到map中、beanName放到beanDefinitionNames中，之后将通过beanDefinitionNames实例化bean</p>
<pre><code class="java">    public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)
            throws BeanDefinitionStoreException {

        Assert.hasText(beanName, &quot;Bean name must not be empty&quot;);
        Assert.notNull(beanDefinition, &quot;BeanDefinition must not be null&quot;);

        if (beanDefinition instanceof AbstractBeanDefinition) {
            try {
                ((AbstractBeanDefinition) beanDefinition).validate();
            }
            catch (BeanDefinitionValidationException ex) {
                throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,
                        &quot;Validation of bean definition failed&quot;, ex);
            }
        }

        //先判断BeanDefinition是否已经注册
        BeanDefinition existingDefinition = this.beanDefinitionMap.get(beanName);
        if (existingDefinition != null) {
            if (!isAllowBeanDefinitionOverriding()) {
                throw new BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);
            }
            else if (existingDefinition.getRole() &lt; beanDefinition.getRole()) {
                // e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE
                if (logger.isInfoEnabled()) {
                    logger.info(&quot;Overriding user-defined bean definition for bean &#39;&quot; + beanName +
                            &quot;&#39; with a framework-generated bean definition: replacing [&quot; +
                            existingDefinition + &quot;] with [&quot; + beanDefinition + &quot;]&quot;);
                }
            }
            else if (!beanDefinition.equals(existingDefinition)) {
                if (logger.isDebugEnabled()) {
                    logger.debug(&quot;Overriding bean definition for bean &#39;&quot; + beanName +
                            &quot;&#39; with a different definition: replacing [&quot; + existingDefinition +
                            &quot;] with [&quot; + beanDefinition + &quot;]&quot;);
                }
            }
            else {
                if (logger.isTraceEnabled()) {
                    logger.trace(&quot;Overriding bean definition for bean &#39;&quot; + beanName +
                            &quot;&#39; with an equivalent definition: replacing [&quot; + existingDefinition +
                            &quot;] with [&quot; + beanDefinition + &quot;]&quot;);
                }
            }
            this.beanDefinitionMap.put(beanName, beanDefinition);
        }
        else {
            if (hasBeanCreationStarted()) {
                // Cannot modify startup-time collection elements anymore (for stable iteration)
                synchronized (this.beanDefinitionMap) {
                    this.beanDefinitionMap.put(beanName, beanDefinition);
                    List&lt;String&gt; updatedDefinitions = new ArrayList&lt;&gt;(this.beanDefinitionNames.size() + 1);
                    updatedDefinitions.addAll(this.beanDefinitionNames);
                    updatedDefinitions.add(beanName);
                    this.beanDefinitionNames = updatedDefinitions;
                    if (this.manualSingletonNames.contains(beanName)) {
                        Set&lt;String&gt; updatedSingletons = new LinkedHashSet&lt;&gt;(this.manualSingletonNames);
                        updatedSingletons.remove(beanName);
                        this.manualSingletonNames = updatedSingletons;
                    }
                }
            }
            else {
                //把beanDefinition缓存到map中
                // Still in startup registration phase
                this.beanDefinitionMap.put(beanName, beanDefinition);

                //把beanName放到beanDefinitionNames list中
                this.beanDefinitionNames.add(beanName);
                this.manualSingletonNames.remove(beanName);
            }
            this.frozenBeanDefinitionNames = null;
        }

        if (existingDefinition != null || containsSingleton(beanName)) {
            resetBeanDefinition(beanName);
        }
    }</code></pre>
</li>
</ol>
<h2 id="设计模式2-委托模式"><a href="#设计模式2-委托模式" class="headerlink" title="设计模式2-委托模式"></a>设计模式2-委托模式</h2><p>不属于23种设计模式之一，是面向对象设计模式中常用的一种模式，可以理解为静态代理和策略模式的一种特殊的组合。简单来说就是接受请求的对象将请求委托给另一个对象来处理，在spring中比较常见。</p>
<pre><code class="java">public interface Company{
    void product();
}</code></pre>
<pre><code class="java">public class Sum implements Company{
  @Override
  public void product(){
    System.out.println(&quot;sum product&quot;);
  }
}</code></pre>
<pre><code class="java">public class Boss implemets Company{
    Sun sun = new Sun();

    @Override
    public void product(){
        sun.product();
    }
}</code></pre>
<h2 id="设计模式3-装饰模式"><a href="#设计模式3-装饰模式" class="headerlink" title="设计模式3-装饰模式"></a>设计模式3-装饰模式</h2><p>装饰模式通过创建一个包装对象，包装对象中通常持有真实对象的引用，通常与装饰对象有相同的接口，提供与真实对象相同的交互方式。装饰对象在接收请求时会将请求转发给真实对象，并在转发前后增加一些附加功能。这样就可以在不改变真实对象的前提下，动态扩展真实对象的功能。</p>
<p>创建装饰的公共接口</p>
<pre><code class="java">public interface Person {
    void desc();
}</code></pre>
<p>创建被装饰类</p>
<pre><code class="java">public class FeiZhai implements Person {
    @Override
    public void desc() {
        System.out.println(&quot;这是一个快乐肥宅&quot;);
    }
}</code></pre>
<p>创建装饰器</p>
<pre><code class="java">public class Decorator implements Person {
    Person person;
    public PersonDecorator(Person person) {
        this.person = person;
    }

    @Override
    public void desc() {
        person.desc();
    }
}</code></pre>
<p>创建装饰子类：</p>
<pre><code class="java">public class DecoratorDnfPlayer extends PersonDecorator {
    public HighPerson(Person person) {
        super(person);
    }

    @Override
    public void desc() {
        super.desc();
        System.out.println(&quot;DNF玩家，八百万勇士之一！！！&quot;);
    }
}</code></pre>
<p>具体使用</p>
<pre><code class="java">public class DecorationTest {
    @Test
    public void test(){
        System.out.println(&quot;创建一个肥宅&quot;);
        Person person = new FeiZhai();
        person.desc();
        System.out.println(&quot;使用装饰器，装饰肥宅&quot;);
        person = new DecoratorDnfPlayer(persion);
        person.desc();
    }
}</code></pre>
<h2 id="设计模式4策略模式"><a href="#设计模式4策略模式" class="headerlink" title="设计模式4策略模式"></a>设计模式4策略模式</h2><p>简单来说就是创建不同的处理逻辑，然后根据条件去选择处理逻辑。当代码中出现大量的if时，为了避免修改核心代码，以及增加拓展性就经常需要使用策略模式。</p>
<p>比如，有省份不同省份做不同处理的需求时：</p>
<p>先创建一个接口</p>
<pre><code class="java">public interface Province {
    public boolean support(String flag);
    public String handler();
}</code></pre>
<p>湖北的处理策略</p>
<pre><code class="java">@Component
public class HN implements Province{
    private static String flag = &quot;HN&quot;;

    @Override
    public boolean support(String flag) {
        return HN.flag.equalsIgnoreCase(flag);
    }

    @Override
    public String handler() {
        System.out.println(&quot;======HN处理类处理&quot;);
        return null;
    }
}</code></pre>
<p>湖南的处理策略</p>
<pre><code class="java">@Component
public class HN implements Province{

    private static String flag = &quot;HN&quot;;

    @Override
    public boolean support(String flag) {
        return HN.flag.equalsIgnoreCase(flag);
    }

    @Override
    public String handler() {
        System.out.println(&quot;======HN处理类处理&quot;);
        return null;
    }
}</code></pre>
<p>具体的使用</p>
<pre><code class="java">public void test1() {

    String flag = &quot;CQ&quot;;

    Map&lt;String, Province&gt; beansOfType = applicationContext.getBeansOfType(Province.class);

    beansOfType.forEach((k,v) -&gt; {
        if(v.support(flag)) {
            v.handler();
        }
    });
}</code></pre>
<h2 id="设计模式5建造者模式"><a href="#设计模式5建造者模式" class="headerlink" title="设计模式5建造者模式"></a>设计模式5建造者模式</h2><p>当类的属性过于复杂时，使用构造方法或set()方法设置会让代码变的混乱，这时就可以通过建造者模式对类进行装配。</p>
<pre><code class="java">public class BuilderClass {

    private final int servingSize;
    private final int servings;
    private final int calories;
    private final int fat;
    private final int sodium;
    private final int carbohydrate;

    public static class Builder {
        // 必要参数
        private final int servingSize;
        private final int servings;

        // 可选参数
        private int calories = 0;
        private int fat = 0;
        private int carbohydrate = 0;
        private int sodium = 0;

        public Builder(int servingSize, int servings) {
            this.servingSize = servingSize;
            this.servings = servings;
        }

        public Builder calories(int val) {
            calories = val;
            return this;
        }

        public Builder fat(int val) {
            fat = val;
            return this;
        }

        public Builder carbohydrate(int val) {
            carbohydrate = val;
            return this;
        }

        public Builder sodium(int val) {
            sodium = val;
            return this;
        }

        public BuilderClass build() {
            return new BuilderClass(this);
        }
    }

    private BuilderClass(Builder builder) {
        servingSize = builder.servingSize;
        servings = builder.servings;
        calories = builder.calories;
        fat = builder.fat;
        sodium = builder.sodium;
        carbohydrate = builder.carbohydrate;
    }

    public static void main(String[] args) {
        BuilderClass cocaCola = new BuilderClass.Builder(240, 8)
                .calories(100).sodium(35).carbohydrate(27).build();
    }
}</code></pre>
<h2 id="component-scan标签的解析"><a href="#component-scan标签的解析" class="headerlink" title="component-scan标签的解析"></a>component-scan标签的解析</h2><ol>
<li><p>context属于自定义标签，所以需要先通过namespace命名空间在spring.handlers文件中获取到对应的NamepsaceHandler处理类之后再调用init()方法注册BeanDefinitionParser解析类，然后再获取scan对应的BeanDefinitionParser解析类进行解析。</p>
<pre><code>http\://www.springframework.org/schema/context=org.springframework.context.config.ContextNamespaceHandler
http\://www.springframework.org/schema/jee=org.springframework.ejb.config.JeeNamespaceHandler
http\://www.springframework.org/schema/lang=org.springframework.scripting.config.LangNamespaceHandler
http\://www.springframework.org/schema/task=org.springframework.scheduling.config.TaskNamespaceHandler
http\://www.springframework.org/schema/cache=org.springframework.cache.config.CacheNamespaceHandler</code></pre></li>
<li><p>调用ContextNamespaceHandler的init()方法注册BeanDefinitionParser解析类。</p>
<pre><code class="java">    @Override
    public void init() {
        registerBeanDefinitionParser(&quot;property-placeholder&quot;, new PropertyPlaceholderBeanDefinitionParser());
        registerBeanDefinitionParser(&quot;property-override&quot;, new PropertyOverrideBeanDefinitionParser());
        registerBeanDefinitionParser(&quot;annotation-config&quot;, new AnnotationConfigBeanDefinitionParser());
        registerBeanDefinitionParser(&quot;component-scan&quot;, new ComponentScanBeanDefinitionParser());
        registerBeanDefinitionParser(&quot;load-time-weaver&quot;, new LoadTimeWeaverBeanDefinitionParser());
        registerBeanDefinitionParser(&quot;spring-configured&quot;, new SpringConfiguredBeanDefinitionParser());
        registerBeanDefinitionParser(&quot;mbean-export&quot;, new MBeanExportBeanDefinitionParser());
        registerBeanDefinitionParser(&quot;mbean-server&quot;, new MBeanServerBeanDefinitionParser());
    }</code></pre>
</li>
<li><p>BeanDefinitionParser的parser()方法中的逻辑。在这里将创建扫描器对基础包路径下的类进行扫描，并创建为BeanDefiniton对象，然后通过registerComponents()方法注册BeanPostProcessor。BeanPostProcessor主要是支撑类中其他注解的功能，如@Autowired、@PostConstruct、@PreDestory等。</p>
<pre><code class="java">    public BeanDefinition parse(Element element, ParserContext parserContext) {
        //获取basePackage属性
        String basePackage = element.getAttribute(BASE_PACKAGE_ATTRIBUTE);
        basePackage = parserContext.getReaderContext().getEnvironment().resolvePlaceholders(basePackage);
        //可以用逗号分开
        String[] basePackages = StringUtils.tokenizeToStringArray(basePackage,
                ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);

        //创建注解扫描器
        // Actually scan for bean definitions and register them.
        ClassPathBeanDefinitionScanner scanner = configureScanner(parserContext, element);
        //扫描并把扫描的类封装成beanDefinition对象  核心方法，重要程度 5
        Set&lt;BeanDefinitionHolder&gt; beanDefinitions = scanner.doScan(basePackages);
    //注册BeanPostProcessor
        registerComponents(parserContext.getReaderContext(), beanDefinitions, element);

        return null;
    }</code></pre>
</li>
<li><p>doScan()方法中会扫描到有注解的类并封装成BeanDefinitionHolder对象。在通过findCandidateComponents()获取到BeanDefinition之后，会根据ScopeMetadata对BeanDefinitionHolder的属性再次进行设置，并创建BeanDefinitionHolder对象，最后注册BeanDefinitonHolder。注册过程与默认实例化中相同，此处不再赘述。</p>
<pre><code class="java">    protected Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) {
        Assert.notEmpty(basePackages, &quot;At least one base package must be specified&quot;);
        Set&lt;BeanDefinitionHolder&gt; beanDefinitions = new LinkedHashSet&lt;&gt;();
        for (String basePackage : basePackages) {
            //扫描到有注解的类并封装成BeanDefinition对象
            Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);
            for (BeanDefinition candidate : candidates) {
                ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate);
                candidate.setScope(scopeMetadata.getScopeName());
                String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry);
                if (candidate instanceof AbstractBeanDefinition) {
                    postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);
                }
                if (candidate instanceof AnnotatedBeanDefinition) {
                    //支持了@Lazy @DependOn注解
                    AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);
                }
                if (checkCandidate(beanName, candidate)) {
                    BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);
                    //这里不看
                    definitionHolder =
                            AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
                    beanDefinitions.add(definitionHolder);

                    //BeanDefinition注册
                    registerBeanDefinition(definitionHolder, this.registry);
                }
            }
        }
        return beanDefinitions;
    }</code></pre>
</li>
<li><p>findCandidateComponents()会递寻找包路径下文件，然后将文件封装为MetadataReader对象，之后再根据MetadataReader中的类注解判断是否进行实例化。进行处理并封装为BeanDefinition。MetadataReader中持有一个ClassMetadata，ClassMetadata对象中几乎包括类的所有信息。</p>
<pre><code class="java">    private Set&lt;BeanDefinition&gt; scanCandidateComponents(String basePackage) {
        Set&lt;BeanDefinition&gt; candidates = new LinkedHashSet&lt;&gt;();
        try {
            String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +
                    resolveBasePackage(basePackage) + &#39;/&#39; + this.resourcePattern;

            //这里递归寻找文件
            Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath);
            boolean traceEnabled = logger.isTraceEnabled();
            boolean debugEnabled = logger.isDebugEnabled();
            for (Resource resource : resources) {
                if (traceEnabled) {
                    logger.trace(&quot;Scanning &quot; + resource);
                }
                if (resource.isReadable()) {
                    try {
                        //将文件信息包装为类基本信息的对象
                        MetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(resource);
                        //如果类上面有includeFilters中的注解
                        if (isCandidateComponent(metadataReader)) {
                            ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader);
                            sbd.setResource(resource);
                            sbd.setSource(resource);
                            if (isCandidateComponent(sbd)) {
                                if (debugEnabled) {
                                    logger.debug(&quot;Identified candidate component class: &quot; + resource);
                                }
                                candidates.add(sbd);
                            }
                            else {
                                if (debugEnabled) {
                                    logger.debug(&quot;Ignored because not a concrete top-level class: &quot; + resource);
                                }
                            }
                        }
                        else {
                            if (traceEnabled) {
                                logger.trace(&quot;Ignored because not matching any filter: &quot; + resource);
                            }
                        }
                    }
                    catch (Throwable ex) {
                        throw new BeanDefinitionStoreException(
                                &quot;Failed to read candidate component class: &quot; + resource, ex);
                    }
                }
                else {
                    if (traceEnabled) {
                        logger.trace(&quot;Ignored because not readable: &quot; + resource);
                    }
                }
            }
        }
        catch (IOException ex) {
            throw new BeanDefinitionStoreException(&quot;I/O failure during classpath scanning&quot;, ex);
        }
        return candidates;
    }</code></pre>
</li>
<li><p>递归寻找文件的主要方法</p>
<pre><code class="java">    protected void doRetrieveMatchingFiles(String fullPattern, File dir, Set&lt;File&gt; result) throws IOException {
        if (logger.isTraceEnabled()) {
            logger.trace(&quot;Searching directory [&quot; + dir.getAbsolutePath() +
                    &quot;] for files matching pattern [&quot; + fullPattern + &quot;]&quot;);
        }
        for (File content : listDirectory(dir)) {
            String currPath = StringUtils.replace(content.getAbsolutePath(), File.separator, &quot;/&quot;);
            //如果是一个文件夹，则递归
            if (content.isDirectory() &amp;&amp; getPathMatcher().matchStart(fullPattern, currPath + &quot;/&quot;)) {
                if (!content.canRead()) {
                    if (logger.isDebugEnabled()) {
                        logger.debug(&quot;Skipping subdirectory [&quot; + dir.getAbsolutePath() +
                                &quot;] because the application is not allowed to read the directory&quot;);
                    }
                }
                else {
                    doRetrieveMatchingFiles(fullPattern, content, result);
                }
            }

            //如果是一个文件，则加入到容器
            if (getPathMatcher().match(fullPattern, currPath)) {
                result.add(content);
            }
        }
    }</code></pre>
</li>
<li><p>注册BeanPostProcessor过程</p>
<pre><code class="java">    public static Set&lt;BeanDefinitionHolder&gt; registerAnnotationConfigProcessors(
            BeanDefinitionRegistry registry, @Nullable Object source) {

        DefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry);
        if (beanFactory != null) {
            if (!(beanFactory.getDependencyComparator() instanceof AnnotationAwareOrderComparator)) {
                beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);
            }
            if (!(beanFactory.getAutowireCandidateResolver() instanceof ContextAnnotationAutowireCandidateResolver)) {
                beanFactory.setAutowireCandidateResolver(new ContextAnnotationAutowireCandidateResolver());
            }
        }

        Set&lt;BeanDefinitionHolder&gt; beanDefs = new LinkedHashSet&lt;&gt;(8);

        if (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) {
            RootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class);
            def.setSource(source);
            beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));
        }

        if (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) {
            RootBeanDefinition def = new RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);
            def.setSource(source);
            beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));
        }

        // Check for JSR-250 support, and if present add the CommonAnnotationBeanPostProcessor.
        if (jsr250Present &amp;&amp; !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) {
            RootBeanDefinition def = new RootBeanDefinition(CommonAnnotationBeanPostProcessor.class);
            def.setSource(source);
            beanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME));
        }

        // Check for JPA support, and if present add the PersistenceAnnotationBeanPostProcessor.
        if (jpaPresent &amp;&amp; !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) {
            RootBeanDefinition def = new RootBeanDefinition();
            try {
                def.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME,
                        AnnotationConfigUtils.class.getClassLoader()));
            }
            catch (ClassNotFoundException ex) {
                throw new IllegalStateException(
                        &quot;Cannot load optional framework class: &quot; + PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, ex);
            }
            def.setSource(source);
            beanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME));
        }

        if (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) {
            RootBeanDefinition def = new RootBeanDefinition(EventListenerMethodProcessor.class);
            def.setSource(source);
            beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME));
        }

        if (!registry.containsBeanDefinition(EVENT_LISTENER_FACTORY_BEAN_NAME)) {
            RootBeanDefinition def = new RootBeanDefinition(DefaultEventListenerFactory.class);
            def.setSource(source);
            beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_FACTORY_BEAN_NAME));
        }

        return beanDefs;
    }</code></pre>
</li>
</ol>
<h2 id="简单上手"><a href="#简单上手" class="headerlink" title="简单上手"></a>简单上手</h2><h3 id="使用自定义标签连接redis"><a href="#使用自定义标签连接redis" class="headerlink" title="使用自定义标签连接redis"></a>使用自定义标签连接redis</h3><ol>
<li>创建自定义标签约束文件myMags.xsd，位置为在resources/META-INF/</li>
</ol>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;xsd:schema xmlns=&quot;http://www.test.com/schema/mytags&quot;
            xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; targetNamespace=&quot;http://www.test.com/schema/mytags&quot;
            elementFormDefault=&quot;qualified&quot; attributeFormDefault=&quot;unqualified&quot;&gt;
    &lt;xsd:element name=&quot;redis&quot;&gt;
        &lt;xsd:complexType&gt;
            &lt;xsd:attribute name=&quot;id&quot; type=&quot;xsd:string&quot;&gt;&lt;/xsd:attribute&gt;
            &lt;xsd:attribute name=&quot;ip&quot; type=&quot;xsd:string&quot;&gt;&lt;/xsd:attribute&gt;
            &lt;xsd:attribute name=&quot;port&quot; type=&quot;xsd:string&quot;&gt;&lt;/xsd:attribute&gt;
        &lt;/xsd:complexType&gt;
    &lt;/xsd:element&gt;
&lt;/xsd:schema&gt;</code></pre>
<ol start="2">
<li>在相同位置为xsd文件创建映射文件spring.schemas</li>
</ol>
<pre><code class="scheme">http\://www.test.com/schema/mytags.xsd=META-INF/myTags.xsd</code></pre>
<ol start="3">
<li>在相同位置下创建spring.handlers文件</li>
</ol>
<pre><code>http\://www.test.com/schema/mytags=org.example.tag.TagsNamespaceHandler</code></pre><ol start="4">
<li>创建RedisBeanDefinitionParser类</li>
</ol>
<pre><code class="java">public class RedisBeanDefinitionParser extends AbstractSingleBeanDefinitionParser {
    @Override
    protected Class&lt;?&gt; getBeanClass(Element element) {
        return Jedis.class;
    }

    @Override
    protected void doParse(Element element, BeanDefinitionBuilder builder) {
        String ip = element.getAttribute(&quot;ip&quot;);
        String port = element.getAttribute(&quot;port&quot;);

        builder.addConstructorArgValue(ip);
        builder.addConstructorArgValue(Integer.parseInt(port));
    }
}</code></pre>
<ol start="5">
<li>创建TagsNamespaceHandler类</li>
</ol>
<pre><code class="java">public class TagsNamespaceHandler extends NamespaceHandlerSupport {
    @Override
    public void init() {
        this.registerBeanDefinitionParser(&quot;redis&quot;,new RedisBeanDefinitionParser());
    }

    @Override
    public BeanDefinitionHolder decorate(Node node, BeanDefinitionHolder definition, ParserContext parserContext) {
        return super.decorate(node, definition, parserContext);
    }
}</code></pre>
<ol start="6">
<li>在spring.xml中使用自定义标签</li>
</ol>
<pre><code class="xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:my=&quot;http://www.test.com/schema/mytags&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.test.com/schema/mytags
       http://www.test.com/schema/mytags.xsd&quot;
       default-lazy-init=&quot;false&quot;&gt;
    &lt;!--自定义标签--&gt;
    &lt;my:redis id=&quot;redis&quot; ip=&quot;localhost&quot; port=&quot;6379&quot;/&gt;
&lt;/beans&gt;</code></pre>
<ol start="7">
<li>测试类</li>
</ol>
<pre><code class="java">@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = {&quot;classpath:spring.xml&quot;})
public class MyTest {
    @Autowired
    private Jedis jedis;

    @Test
    public void myTag() {
        jedis.set(&quot;tag&quot;,&quot;test&quot;);
        System.out.println(jedis.get(&quot;tag&quot;));
    }
}</code></pre>
<h3 id="使用自定义注解创建Bean对象"><a href="#使用自定义注解创建Bean对象" class="headerlink" title="使用自定义注解创建Bean对象"></a>使用自定义注解创建Bean对象</h3><ol>
<li>创建MyBeanDefinitionRegistryPostProcessor</li>
</ol>
<pre><code class="java">public class MyBeanDefinitionRegistryPostProcessor implements BeanDefinitionRegistryPostProcessor {

    @Override
    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException {
        GenericBeanDefinition genericBeanDefinition = new GenericBeanDefinition();
        genericBeanDefinition.setBeanClass(BeanClass.class);

        MutablePropertyValues propertyValues = genericBeanDefinition.getPropertyValues();
        propertyValues.addPropertyValue(&quot;username&quot;,&quot;test&quot;);

        registry.registerBeanDefinition(&quot;beanClass&quot;,genericBeanDefinition);

        ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(registry);
        scanner.addIncludeFilter(new AnnotationTypeFilter(MyService.class));
        scanner.scan(&quot;org.example.beanDefinition&quot;);
    }

    @Override
    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {

    }
}</code></pre>
<ol start="2">
<li>创建BeanClass</li>
</ol>
<pre><code class="java">public class BeanClass {
    private String username;

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }
}</code></pre>
<ol start="3">
<li>创建</li>
</ol>
<pre><code class="java">@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface MyService {ßß
    String value() default &quot;&quot;;
}</code></pre>
<ol start="4">
<li>测试类</li>
</ol>
<pre><code class="java">@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = {&quot;classpath:spring.xml&quot;})
public class MyTest {
    @Autowired
    private Jedis jedis;

    @Test
    public void myTag() {
        jedis.set(&quot;tag&quot;,&quot;test&quot;);
        System.out.println(jedis.get(&quot;tag&quot;));
    }

    @Autowired
    private BeanClass beanClass;

    @Test
    public void beanDefinition(){
        System.out.println(beanClass.getUsername());
    }
}</code></pre>

            </div>
            <hr>
            <div>
              <p>
                
                  <span>
                <i class="iconfont icon-inbox"></i>
                    
                      <a class="hover-with-bg" href="/blog/categories/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">Spring源码解析</a>
                      &nbsp;
                    
                  </span>&nbsp;&nbsp;
                
                
                  <span>
                <i class="iconfont icon-tag"></i>
                    
                      <a class="hover-with-bg" href="/blog/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">源码解析</a>
                    
                      <a class="hover-with-bg" href="/blog/tags/spring/">spring</a>
                    
                  </span>
                
              </p>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/blog/2020/04/15/spring%E5%AE%9E%E4%BE%8B%E5%8C%96bean%E7%9A%84%E8%BF%87%E7%A8%8B/">
                        <i class="fa fa-chevron-left"></i>
                        <span class="hidden-mobile">spring实例化bean的过程</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/blog/2020/04/03/MySQL%E7%9A%84%E7%B4%A2%E5%BC%95%E4%B8%8E%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/">
                        <span class="hidden-mobile">MySQL的索引与执行计划</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="fa fa-chevron-right"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

              
                <!-- Comments -->
                <div class="comments" id="comments">
                  
                  

                </div>
              
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc-start"></div>
<div id="toc">
  <p class="h5"><i class="far fa-list-alt"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a class="z-depth-1" id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"> <b>Fluid</b></a>
    </div>
    
  <div>
    
      <!-- 不蒜子统计PV -->
      
      <span id="busuanzi_container_site_pv" style="display: none">
      总访问量 <span id="busuanzi_value_site_pv"></span> 次
    </span>
    
    
      <!-- 不蒜子统计UV -->
      
      <span id="busuanzi_container_site_uv" style="display: none">
      总访客数 <span id="busuanzi_value_site_uv"></span> 人
    </span>
    
  </div>


    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/popper.js/1.16.1/umd/popper.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="https://cdn.staticfile.org/mdbootstrap/4.13.0/js/mdb.min.js" ></script>
<script  src="/blog/js/main.js" ></script>


  <script  src="/blog/js/lazyload.js" ></script>



  
  <script  src="https://cdn.staticfile.org/tocbot/4.10.0/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var navHeight = $('#navbar').height();
      var toc = $('#toc');
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;
      var tocLimMax = 2 * boardTop + boardCtn.height();

      $(window).scroll(function () {
        var tocLimMin = $('#toc-start').offset().top - navHeight;
        var scroH = document.body.scrollTop + document.documentElement.scrollTop;

        if (tocLimMin <= scroH && scroH <= tocLimMax) {
          toc.css({
            'display': 'block',
            'position': 'fixed',
            'top': navHeight,
          });
        } else if (scroH <= tocLimMin) {
          toc.css({
            'position': '',
            'top': '',
          });
        } else if (scroH > tocLimMax) {
          toc.css('display', 'none');
        }
      });
      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '.post-content',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc > p').css('visibility', 'visible');
      }
      var offset = boardCtn.css('margin-right')
      $('#toc-ctn').css({
        'right': offset
      })
    });
  </script>





  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/blog/js/clipboard-use.js" ></script>



  <script defer src="https://cdn.staticfile.org/smoothscroll/1.4.10/SmoothScroll.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




<!-- Plugins -->


  

  

  

  

  

  



  <script  src="https://cdn.staticfile.org/prettify/188.0.0/prettify.min.js" ></script>
  <script>
    $(document).ready(function () {
      $('pre').addClass('prettyprint  linenums');
      prettyPrint();
    })
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "spring程序入口和xml解析&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/blog/js/local-search.js" ></script>
  <script>
    var path = "/blog/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script defer src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <script>
    $("#post img:not(.no-zoom img, img[no-zoom])").each(
      function () {
        var element = document.createElement("a");
        $(element).attr("data-fancybox", "images");
        $(element).attr("href", $(this).attr("src"));
        $(this).wrap(element);
      }
    );
  </script>





  
  
    <script type="text/javascript">
      //定义获取词语下标
      var a_idx = 0;
      jQuery(document).ready(function ($) {
        //点击body时触发事件
        $("body").click(function (e) {
          //需要显示的词语
          var a = new Array("富强", "民主", "文明", "和谐", "自由", "平等", "公正", "法治", "爱国", "敬业", "诚信", "友善");
          //设置词语给span标签
          var $i = $("<span/>").text(a[a_idx]);
          //下标等于原来下标+1  余 词语总数
          a_idx = (a_idx + 1) % a.length;
          //获取鼠标指针的位置，分别相对于文档的左和右边缘。
          //获取x和y的指针坐标
          var x = e.pageX, y = e.pageY;
          //在鼠标的指针的位置给$i定义的span标签添加css样式
          $i.css({
            "z-index": 999,
            "top": y - 20,
            "left": x,
            "position": "absolute",
            "font-weight": "bold",
            "color": rand_color()
          });
          // 随机颜色
          function rand_color() {
            return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"
          }
          //在body添加这个标签
          $("body").append($i);
          //animate() 方法执行 CSS 属性集的自定义动画。
          //该方法通过CSS样式将元素从一个状态改变为另一个状态。CSS属性值是逐渐改变的，这样就可以创建动画效果。
          //详情请看http://www.w3school.com.cn/jquery/effect_animate.asp
          $i.animate({
            //将原来的位置向上移动180
            "top": y - 180,
            "opacity": 0
            //1500动画的速度
          }, 1500, function () {
            //时间到了自动删除
            $i.remove();
          });
        });
      })
      ;
    </script>
  








</body>
</html>
