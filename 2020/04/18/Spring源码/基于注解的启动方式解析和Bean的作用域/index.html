

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/blog/img/favicon.png">
  <link rel="icon" type="image/png" href="/blog/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="">
  <meta name="keywords" content="">
  <title>Spring基于注解的启动方式解析和Bean的作用域 - 萤火的博客</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/blog/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.1.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/blog/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"zhaoguocheng.gitee.io","root":"/blog/","version":"1.8.5","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"copy_btn":true,"image_zoom":{"enable":true},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/blog/js/utils.js" ></script>
  <script  src="/blog/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/blog/">&nbsp;<strong>萤火的博客</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/">
                <i class="iconfont icon-home-fill"></i>
                主页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/blog/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Spring基于注解的启动方式解析和Bean的作用域">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-04-18 11:47" pubdate>
        2020年4月18日 中午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      3.6k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      60
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Spring基于注解的启动方式解析和Bean的作用域</h1>
            
            <div class="markdown-body">
              <h2 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h2><p>@Scope注解可以设置bean的作用域，不同的作用域对bean对象的获取方式不同，spring也允许开发者注册自己的作用域，实现对对象作用域的控制。</p>
<h3 id="doGetBean-的再分析"><a href="#doGetBean-的再分析" class="headerlink" title="doGetBean()的再分析"></a>doGetBean()的再分析</h3><p>如果缓存中获取不到实例且实例作用域不是单例时，spring就会获取到bean的作用域对象，并调用作用域对象的get()方法创建实例。</p>
<pre><code class="hljs java"><span class="hljs-keyword">protected</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">doGetBean</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String name, <span class="hljs-meta">@Nullable</span> <span class="hljs-keyword">final</span> Class&lt;T&gt; requiredType,</span></span>
<span class="hljs-function"><span class="hljs-params">			<span class="hljs-meta">@Nullable</span> <span class="hljs-keyword">final</span> Object[] args, <span class="hljs-keyword">boolean</span> typeCheckOnly)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;	
  
  <span class="hljs-keyword">final</span> String beanName = transformedBeanName(name);
	Object bean;

	<span class="hljs-comment">//从缓存中拿实例</span>
	<span class="hljs-comment">// Eagerly check singleton cache for manually registered singletons.</span>
	Object sharedInstance = getSingleton(beanName);
	<span class="hljs-comment">//如果缓存里面能拿到实例</span>
	<span class="hljs-keyword">if</span> (sharedInstance != <span class="hljs-keyword">null</span> &amp;&amp; args == <span class="hljs-keyword">null</span>) &#123;
		<span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;
			<span class="hljs-keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;
				logger.trace(<span class="hljs-string">&quot;Returning eagerly cached instance of singleton bean &#x27;&quot;</span> + beanName +
						<span class="hljs-string">&quot;&#x27; that is not fully initialized yet - a consequence of a circular reference&quot;</span>);
			&#125;
			<span class="hljs-keyword">else</span> &#123;
				logger.trace(<span class="hljs-string">&quot;Returning cached instance of singleton bean &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27;&quot;</span>);
			&#125;
		&#125;
		<span class="hljs-comment">//改方法是FactoryBean接口的调用入口</span>
		bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="hljs-keyword">null</span>);
	&#125;

	<span class="hljs-keyword">else</span> &#123;

		<span class="hljs-comment">//如果singletonObjects缓存里面没有，则走下来</span>
		<span class="hljs-comment">// Fail if we&#x27;re already creating this bean instance:</span>
		<span class="hljs-comment">// We&#x27;re assumably within a circular reference.</span>

		<span class="hljs-comment">//如果是scope 是Prototype的，校验是否有出现循环依赖，如果有则直接报错</span>
		<span class="hljs-keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;
			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCurrentlyInCreationException(beanName);
		&#125;

		<span class="hljs-comment">// Check if bean definition exists in this factory.</span>
		BeanFactory parentBeanFactory = getParentBeanFactory();
		<span class="hljs-keyword">if</span> (parentBeanFactory != <span class="hljs-keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;
			<span class="hljs-comment">// Not found -&gt; check parent.</span>
			String nameToLookup = originalBeanName(name);
			<span class="hljs-keyword">if</span> (parentBeanFactory <span class="hljs-keyword">instanceof</span> AbstractBeanFactory) &#123;
				<span class="hljs-keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(
						nameToLookup, requiredType, args, typeCheckOnly);
			&#125;
			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (args != <span class="hljs-keyword">null</span>) &#123;
				<span class="hljs-comment">// Delegation to parent with explicit args.</span>
				<span class="hljs-keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);
			&#125;
			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (requiredType != <span class="hljs-keyword">null</span>) &#123;
				<span class="hljs-comment">// No args -&gt; delegate to standard getBean method.</span>
				<span class="hljs-keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);
			&#125;
			<span class="hljs-keyword">else</span> &#123;
				<span class="hljs-keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup);
			&#125;
		&#125;

		<span class="hljs-keyword">if</span> (!typeCheckOnly) &#123;
			markBeanAsCreated(beanName);
		&#125;

		<span class="hljs-keyword">try</span> &#123;
			<span class="hljs-comment">//父子BeanDefinition合并</span>
			<span class="hljs-keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
			checkMergedBeanDefinition(mbd, beanName, args);

			<span class="hljs-comment">//获取依赖对象属性，依赖对象要先实例化</span>
			<span class="hljs-comment">// Guarantee initialization of beans that the current bean depends on.</span>
			String[] dependsOn = mbd.getDependsOn();
			<span class="hljs-keyword">if</span> (dependsOn != <span class="hljs-keyword">null</span>) &#123;
				<span class="hljs-keyword">for</span> (String dep : dependsOn) &#123;
					<span class="hljs-keyword">if</span> (isDependent(beanName, dep)) &#123;
						<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,
								<span class="hljs-string">&quot;Circular depends-on relationship between &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27; and &#x27;&quot;</span> + dep + <span class="hljs-string">&quot;&#x27;&quot;</span>);
					&#125;
					registerDependentBean(dep, beanName);
					<span class="hljs-keyword">try</span> &#123;
						<span class="hljs-comment">//实例化</span>
						getBean(dep);
				&#125;
					<span class="hljs-keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;
						<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,
								<span class="hljs-string">&quot;&#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27; depends on missing bean &#x27;&quot;</span> + dep + <span class="hljs-string">&quot;&#x27;&quot;</span>, ex);
					&#125;
				&#125;
			&#125;

			<span class="hljs-comment">//作用域为单例时的实例化</span>
			<span class="hljs-comment">// Create bean instance.</span>
			<span class="hljs-keyword">if</span> (mbd.isSingleton()) &#123;
				sharedInstance = getSingleton(beanName, () -&gt; &#123;
					<span class="hljs-keyword">try</span> &#123;
						<span class="hljs-keyword">return</span> createBean(beanName, mbd, args);
					&#125;
					<span class="hljs-keyword">catch</span> (BeansException ex) &#123;
						<span class="hljs-comment">// Explicitly remove instance from singleton cache: It might have been put there</span>
						<span class="hljs-comment">// eagerly by the creation process, to allow for circular reference resolution.</span>
						<span class="hljs-comment">// Also remove any beans that received a temporary reference to the bean.</span>
						destroySingleton(beanName);
						<span class="hljs-keyword">throw</span> ex;
					&#125;
				&#125;);
				<span class="hljs-comment">//该方法是FactoryBean接口的调用入口</span>
				bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
			&#125;

			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mbd.isPrototype()) &#123;
				<span class="hljs-comment">// It&#x27;s a prototype -&gt; create a new instance.</span>
				Object prototypeInstance = <span class="hljs-keyword">null</span>;
				<span class="hljs-keyword">try</span> &#123;
					beforePrototypeCreation(beanName);
					prototypeInstance = createBean(beanName, mbd, args);
				&#125;
				<span class="hljs-keyword">finally</span> &#123;
					afterPrototypeCreation(beanName);
				&#125;
				<span class="hljs-comment">//该方法是FactoryBean接口的调用入口</span>
				bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
			&#125;
      <span class="hljs-comment">//其他作用域，如自定义作用域</span>
			<span class="hljs-keyword">else</span> &#123;
				String scopeName = mbd.getScope();
				<span class="hljs-keyword">final</span> Scope scope = <span class="hljs-keyword">this</span>.scopes.get(scopeName);
				<span class="hljs-keyword">if</span> (scope == <span class="hljs-keyword">null</span>) &#123;
					<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;No Scope registered for scope name &#x27;&quot;</span> + scopeName + <span class="hljs-string">&quot;&#x27;&quot;</span>);
				&#125;
				<span class="hljs-keyword">try</span> &#123;
					Object scopedInstance = scope.get(beanName, () -&gt; &#123;
						beforePrototypeCreation(beanName);
						<span class="hljs-keyword">try</span> &#123;
							<span class="hljs-keyword">return</span> createBean(beanName, mbd, args);
						&#125;
						<span class="hljs-keyword">finally</span> &#123;
							afterPrototypeCreation(beanName);
						&#125;
					&#125;);
					<span class="hljs-comment">//改方法是FactoryBean接口的调用入口</span>
					bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
				&#125;
				<span class="hljs-keyword">catch</span> (IllegalStateException ex) &#123;
					<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(beanName,
							<span class="hljs-string">&quot;Scope &#x27;&quot;</span> + scopeName + <span class="hljs-string">&quot;&#x27; is not active for the current thread; consider &quot;</span> +
							<span class="hljs-string">&quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;</span>,
							ex);
				&#125;
			&#125;
		&#125;
		<span class="hljs-keyword">catch</span> (BeansException ex) &#123;
			cleanupAfterBeanCreationFailure(beanName);
			<span class="hljs-keyword">throw</span> ex;
		&#125;
	&#125;

	<span class="hljs-comment">// Check if required type matches the type of the actual bean instance.</span>
	<span class="hljs-keyword">if</span> (requiredType != <span class="hljs-keyword">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;
		<span class="hljs-keyword">try</span> &#123;
			T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);
			<span class="hljs-keyword">if</span> (convertedBean == <span class="hljs-keyword">null</span>) &#123;
				<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
			&#125;
			<span class="hljs-keyword">return</span> convertedBean;
		&#125;
		<span class="hljs-keyword">catch</span> (TypeMismatchException ex) &#123;
			<span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;
				logger.trace(<span class="hljs-string">&quot;Failed to convert bean &#x27;&quot;</span> + name + <span class="hljs-string">&quot;&#x27; to required type &#x27;&quot;</span> +
						ClassUtils.getQualifiedName(requiredType) + <span class="hljs-string">&quot;&#x27;&quot;</span>, ex);
			&#125;
			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
		&#125;
	&#125;
	<span class="hljs-keyword">return</span> (T) bean;
&#125;</code></pre>
<h3 id="自定义作用域的实现"><a href="#自定义作用域的实现" class="headerlink" title="自定义作用域的实现"></a>自定义作用域的实现</h3><p>spring在完成BeanDefinition的实例化及IOC、DI后，会调用BeanFactoryPostProcessor接口的postProcessBeanFactory()方法并将beanFactory传递进去，我们可以在这个方法中调用beanFactory的regtsterScope()方法将自定义作用域添加到spring容器中。</p>
<pre><code class="hljs java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadScopeRegistry</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanDefinitionRegistryPostProcessor</span> </span>&#123;

    <span class="hljs-keyword">private</span> BeanDefinitionRegistry beanDefinitionRegistry;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeanDefinitionRegistry</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;
        <span class="hljs-keyword">this</span>.beanDefinitionRegistry = registry;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;
        beanFactory.registerScope(<span class="hljs-string">&quot;refresh&quot;</span>,<span class="hljs-keyword">new</span> ThreadScope());
    &#125;
&#125;</code></pre>

<p>在创建实例时会调用到Scope对象的get()方法， 并向get()方法中传递beanName跟创建方法factory.getObject()。所以我们可以在Scope中精准的控制bean对象的作用域。比如创建一个线程间共享的作用域。</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadScope</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Scope</span> </span>&#123;
    <span class="hljs-keyword">private</span> ThreadLocal local = <span class="hljs-keyword">new</span> ThreadLocal();

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">get</span><span class="hljs-params">(String name, ObjectFactory&lt;?&gt; objectFactory)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (local.get()!=<span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">return</span> local.get();
        &#125;
        Object bean = objectFactory.getObject();
        local.set(bean);
        <span class="hljs-keyword">return</span> bean;
    &#125;
&#125;</code></pre>

<h3 id="spring的作用域"><a href="#spring的作用域" class="headerlink" title="spring的作用域"></a>spring的作用域</h3><p>singleton：spring的默认作用域，在spring容器中仅存在一个Bean实例，在启动时会实例化并放入一级缓存中，之后都是从一级缓存中获取。</p>
<p>prototype：多实例每次getBean()操作时都会重新创建。启动时不会初始化，只有在getBean()时才会实例化，而且在实例话时不会放入一级缓存，但会放入singletonsCurrentlyInCreation容器，阻断循环依赖。</p>
<p>request：每次http请求都创建一个实例，仅在web容器中存在。如果以xml文件的方式启动会直接报错。原理就是将创建后的Bean实例放在request中。</p>
<p>session：与request基本相同，不同的是Bean实例会放在Session中。</p>
<h2 id="基于注解的启动方式解析"><a href="#基于注解的启动方式解析" class="headerlink" title="基于注解的启动方式解析"></a>基于注解的启动方式解析</h2><h3 id="AnnotationConfigApplicaitonContext类解析"><a href="#AnnotationConfigApplicaitonContext类解析" class="headerlink" title="AnnotationConfigApplicaitonContext类解析"></a>AnnotationConfigApplicaitonContext类解析</h3><p>其构造函数中会创建一个AnnotatedBeanDefinitionReader对象，然后将annotatedClasses对象交给register()方法完成解析</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AnnotationConfigApplicationContext</span><span class="hljs-params">(Class&lt;?&gt;... annotatedClasses)</span> </span>&#123;
	<span class="hljs-keyword">this</span>();
	register(annotatedClasses);
	refresh();
&#125;</code></pre>

<h4 id="register-方法"><a href="#register-方法" class="headerlink" title="register()方法"></a>register()方法</h4><p>register()方法会调用到AnnotatedBeanDefinitionReader的register()方法循环annotatedClasses并调用registerBean()方法进行BeanDefinition的注册。</p>
<p>doRegisterBean()是registerBean()的主要方法。doRegisterBean()方法首会创建一个BeanDefinition对象，然后将收集annotatedClass的信息并包装为Metadata对象，之后使用AnnotationConfigUtils.processCommonDefinitionAnnotations()对Metadata对象的注解和处理并设置到BeanDefinition对象中，之后将BeanDefinition对象封装为BeanDefinitionHolder并注册。</p>
<pre><code class="hljs java">&lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doRegisterBean</span><span class="hljs-params">(Class&lt;T&gt; annotatedClass, <span class="hljs-meta">@Nullable</span> Supplier&lt;T&gt; instanceSupplier, <span class="hljs-meta">@Nullable</span> String name,</span></span>
<span class="hljs-function"><span class="hljs-params">		<span class="hljs-meta">@Nullable</span> Class&lt;? extends Annotation&gt;[] qualifiers, BeanDefinitionCustomizer... definitionCustomizers)</span> </span>&#123;

	AnnotatedGenericBeanDefinition abd = <span class="hljs-keyword">new</span> AnnotatedGenericBeanDefinition(annotatedClass);
	<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.conditionEvaluator.shouldSkip(abd.getMetadata())) &#123;
		<span class="hljs-keyword">return</span>;
	&#125;

	abd.setInstanceSupplier(instanceSupplier);
	ScopeMetadata scopeMetadata = <span class="hljs-keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(abd);
	abd.setScope(scopeMetadata.getScopeName());
	String beanName = (name != <span class="hljs-keyword">null</span> ? name : <span class="hljs-keyword">this</span>.beanNameGenerator.generateBeanName(abd, <span class="hljs-keyword">this</span>.registry));
   <span class="hljs-comment">//对注解进行收集</span>
	AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);
	<span class="hljs-keyword">if</span> (qualifiers != <span class="hljs-keyword">null</span>) &#123;
		<span class="hljs-keyword">for</span> (Class&lt;? extends Annotation&gt; qualifier : qualifiers) &#123;
			<span class="hljs-keyword">if</span> (Primary.class == qualifier) &#123;
				abd.setPrimary(<span class="hljs-keyword">true</span>);
			&#125;
			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Lazy.class == qualifier) &#123;
				abd.setLazyInit(<span class="hljs-keyword">true</span>);
			&#125;
			<span class="hljs-keyword">else</span> &#123;
				abd.addQualifier(<span class="hljs-keyword">new</span> AutowireCandidateQualifier(qualifier));
			&#125;
		&#125;
	&#125;
	<span class="hljs-keyword">for</span> (BeanDefinitionCustomizer customizer : definitionCustomizers) &#123;
		customizer.customize(abd);
	&#125;
   <span class="hljs-comment">//封装并创建BeanDefinitionHolder对象</span>
	BeanDefinitionHolder definitionHolder = <span class="hljs-keyword">new</span> BeanDefinitionHolder(abd, beanName);
	definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="hljs-keyword">this</span>.registry);
	BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, <span class="hljs-keyword">this</span>.registry);
&#125;</code></pre>

<h5 id="processCommonDefinitionAnnotations-方法"><a href="#processCommonDefinitionAnnotations-方法" class="headerlink" title="processCommonDefinitionAnnotations()方法"></a>processCommonDefinitionAnnotations()方法</h5><p>该方法会对注解进行收集并放到BeanDefinition中。</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processCommonDefinitionAnnotations</span><span class="hljs-params">(AnnotatedBeanDefinition abd, AnnotatedTypeMetadata metadata)</span> </span>&#123;
   <span class="hljs-comment">//对@Lazy注解支持</span>
   AnnotationAttributes lazy = attributesFor(metadata, Lazy.class);
   <span class="hljs-keyword">if</span> (lazy != <span class="hljs-keyword">null</span>) &#123;
      abd.setLazyInit(lazy.getBoolean(<span class="hljs-string">&quot;value&quot;</span>));
   &#125;
   <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (abd.getMetadata() != metadata) &#123;
      lazy = attributesFor(abd.getMetadata(), Lazy.class);
      <span class="hljs-keyword">if</span> (lazy != <span class="hljs-keyword">null</span>) &#123;
         abd.setLazyInit(lazy.getBoolean(<span class="hljs-string">&quot;value&quot;</span>));
      &#125;
   &#125;

   <span class="hljs-keyword">if</span> (metadata.isAnnotated(Primary.class.getName())) &#123;
      abd.setPrimary(<span class="hljs-keyword">true</span>);
   &#125;
   <span class="hljs-comment">//对@DependsOn注解支持</span>
   AnnotationAttributes dependsOn = attributesFor(metadata, DependsOn.class);
   <span class="hljs-keyword">if</span> (dependsOn != <span class="hljs-keyword">null</span>) &#123;
      abd.setDependsOn(dependsOn.getStringArray(<span class="hljs-string">&quot;value&quot;</span>));
   &#125;

   AnnotationAttributes role = attributesFor(metadata, Role.class);
   <span class="hljs-keyword">if</span> (role != <span class="hljs-keyword">null</span>) &#123;
      abd.setRole(role.getNumber(<span class="hljs-string">&quot;value&quot;</span>).intValue());
   &#125;
   AnnotationAttributes description = attributesFor(metadata, Description.class);
   <span class="hljs-keyword">if</span> (description != <span class="hljs-keyword">null</span>) &#123;
      abd.setDescription(description.getString(<span class="hljs-string">&quot;value&quot;</span>));
   &#125;
&#125;</code></pre>

<h3 id="AnnotatedBeanDefinitionReader解析"><a href="#AnnotatedBeanDefinitionReader解析" class="headerlink" title="AnnotatedBeanDefinitionReader解析"></a>AnnotatedBeanDefinitionReader解析</h3><p>其构造函数中会调用AnnotationConfigUtils.registerAnnotationConfigProcessors()方法。</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AnnotatedBeanDefinitionReader</span><span class="hljs-params">(BeanDefinitionRegistry registry, Environment environment)</span> </span>&#123;
	Assert.notNull(registry, <span class="hljs-string">&quot;BeanDefinitionRegistry must not be null&quot;</span>);
	Assert.notNull(environment, <span class="hljs-string">&quot;Environment must not be null&quot;</span>);
	<span class="hljs-keyword">this</span>.registry = registry;
	<span class="hljs-keyword">this</span>.conditionEvaluator = <span class="hljs-keyword">new</span> ConditionEvaluator(registry, environment, <span class="hljs-keyword">null</span>);
	AnnotationConfigUtils.registerAnnotationConfigProcessors(<span class="hljs-keyword">this</span>.registry);
&#125;</code></pre>

<h4 id="registerAnnotationConfigProcessors-方法"><a href="#registerAnnotationConfigProcessors-方法" class="headerlink" title="registerAnnotationConfigProcessors()方法"></a>registerAnnotationConfigProcessors()方法</h4><p>此方法会创建一些BeanDefinitionRegistryPostProcessor类，用于在Bean实例化之前对BeanDefinition进行操作。BeanDefinitionRegistryPostProcessor类继承了BeanFactoryPostProcessor类，在spring会在实例化Bean之前创建BeanFactoryPostProcessor对象，并调用postProcessBeanDefinitionRegistry()方法。</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Set&lt;BeanDefinitionHolder&gt; <span class="hljs-title">registerAnnotationConfigProcessors</span><span class="hljs-params">(</span></span>
<span class="hljs-function"><span class="hljs-params">		BeanDefinitionRegistry registry, <span class="hljs-meta">@Nullable</span> Object source)</span> </span>&#123;

	DefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry);
	<span class="hljs-keyword">if</span> (beanFactory != <span class="hljs-keyword">null</span>) &#123;
		<span class="hljs-keyword">if</span> (!(beanFactory.getDependencyComparator() <span class="hljs-keyword">instanceof</span> AnnotationAwareOrderComparator)) &#123;
			beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);
		&#125;
		<span class="hljs-keyword">if</span> (!(beanFactory.getAutowireCandidateResolver() <span class="hljs-keyword">instanceof</span> ContextAnnotationAutowireCandidateResolver)) &#123;
			beanFactory.setAutowireCandidateResolver(<span class="hljs-keyword">new</span> ContextAnnotationAutowireCandidateResolver());
		&#125;
	&#125;

	Set&lt;BeanDefinitionHolder&gt; beanDefs = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(<span class="hljs-number">8</span>);

	<span class="hljs-keyword">if</span> (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;
     <span class="hljs-comment">// 重点关注这行代码中的ConfigurationClassPostProcessor类</span>
		RootBeanDefinition def = <span class="hljs-keyword">new</span> RootBeanDefinition(ConfigurationClassPostProcessor.class);
		def.setSource(source);
		beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));
	&#125;

	<span class="hljs-keyword">if</span> (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;
		RootBeanDefinition def = <span class="hljs-keyword">new</span> RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);
		def.setSource(source);
		beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));
	&#125;

	<span class="hljs-comment">// Check for JSR-250 support, and if present add the CommonAnnotationBeanPostProcessor.</span>
	<span class="hljs-keyword">if</span> (jsr250Present &amp;&amp; !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;
		RootBeanDefinition def = <span class="hljs-keyword">new</span> RootBeanDefinition(CommonAnnotationBeanPostProcessor.class);
		def.setSource(source);
		beanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME));
	&#125;

	<span class="hljs-comment">// Check for JPA support, and if present add the PersistenceAnnotationBeanPostProcessor.</span>
	<span class="hljs-keyword">if</span> (jpaPresent &amp;&amp; !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;
		RootBeanDefinition def = <span class="hljs-keyword">new</span> RootBeanDefinition();
		<span class="hljs-keyword">try</span> &#123;
			def.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME,
					AnnotationConfigUtils.class.getClassLoader()));
		&#125;
		<span class="hljs-keyword">catch</span> (ClassNotFoundException ex) &#123;
			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(
					<span class="hljs-string">&quot;Cannot load optional framework class: &quot;</span> + PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, ex);
		&#125;
		def.setSource(source);
		beanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME));
	&#125;

	<span class="hljs-keyword">if</span> (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) &#123;
		RootBeanDefinition def = <span class="hljs-keyword">new</span> RootBeanDefinition(EventListenerMethodProcessor.class);
		def.setSource(source);
		beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME));
	&#125;

	<span class="hljs-keyword">if</span> (!registry.containsBeanDefinition(EVENT_LISTENER_FACTORY_BEAN_NAME)) &#123;
		RootBeanDefinition def = <span class="hljs-keyword">new</span> RootBeanDefinition(DefaultEventListenerFactory.class);
		def.setSource(source);
		beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_FACTORY_BEAN_NAME));
	&#125;

	<span class="hljs-keyword">return</span> beanDefs;
 &#125;</code></pre>

<h3 id="ConfigurationClassPostProcessor类解析"><a href="#ConfigurationClassPostProcessor类解析" class="headerlink" title="ConfigurationClassPostProcessor类解析"></a>ConfigurationClassPostProcessor类解析</h3><p>ConfigurationClassPostProcessor类是registerAnnotationConfigProcessors()方法注册的BeanDefinitionRegistryPostProcessor之一。</p>
<h4 id="processConfigBeanDefinitions-方法"><a href="#processConfigBeanDefinitions-方法" class="headerlink" title="processConfigBeanDefinitions()方法"></a>processConfigBeanDefinitions()方法</h4><p>该方法首先会调用ConfigurationClassUtils.checkConfigurationClassCandidate()方法将具有某些注解的BeanDefination对象放入configCandidates容器中，然后对configCandidates容器进行排序，再使用parse()方法对注解进行处理，最后使用loadBeanDefinitions()完成注册。</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processConfigBeanDefinitions</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> </span>&#123;
	List&lt;BeanDefinitionHolder&gt; configCandidates = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
	String[] candidateNames = registry.getBeanDefinitionNames();

	<span class="hljs-keyword">for</span> (String beanName : candidateNames) &#123;
		BeanDefinition beanDef = registry.getBeanDefinition(beanName);
		<span class="hljs-keyword">if</span> (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||
				ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) &#123;
			<span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;
				logger.debug(<span class="hljs-string">&quot;Bean definition has already been processed as a configuration class: &quot;</span> + beanDef);
			&#125;
		&#125;
		<span class="hljs-comment">//判断是类上或方法上的注解，</span>
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, <span class="hljs-keyword">this</span>.metadataReaderFactory)) &#123;
			configCandidates.add(<span class="hljs-keyword">new</span> BeanDefinitionHolder(beanDef, beanName));
		&#125;
	&#125;

	<span class="hljs-comment">// Return immediately if no @Configuration classes were found</span>
	<span class="hljs-keyword">if</span> (configCandidates.isEmpty()) &#123;
		<span class="hljs-keyword">return</span>;
	&#125;

   <span class="hljs-comment">//排序</span>
	<span class="hljs-comment">// Sort by previously determined @Order value, if applicable</span>
	configCandidates.sort((bd1, bd2) -&gt; &#123;
		<span class="hljs-keyword">int</span> i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());
		<span class="hljs-keyword">int</span> i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());
		<span class="hljs-keyword">return</span> Integer.compare(i1, i2);
	&#125;);

	<span class="hljs-comment">// Detect any custom bean name generation strategy supplied through the enclosing application context</span>
	SingletonBeanRegistry sbr = <span class="hljs-keyword">null</span>;
	<span class="hljs-keyword">if</span> (registry <span class="hljs-keyword">instanceof</span> SingletonBeanRegistry) &#123;
		sbr = (SingletonBeanRegistry) registry;
		<span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.localBeanNameGeneratorSet) &#123;
			BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);
			<span class="hljs-keyword">if</span> (generator != <span class="hljs-keyword">null</span>) &#123;
				<span class="hljs-keyword">this</span>.componentScanBeanNameGenerator = generator;
				<span class="hljs-keyword">this</span>.importBeanNameGenerator = generator;
			&#125;
		&#125;
	&#125;

	<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.environment == <span class="hljs-keyword">null</span>) &#123;
		<span class="hljs-keyword">this</span>.environment = <span class="hljs-keyword">new</span> StandardEnvironment();
	&#125;

	<span class="hljs-comment">//这个类很重要，@ComponentScan @Configuration支持</span>
	<span class="hljs-comment">// Parse each @Configuration class</span>
	ConfigurationClassParser parser = <span class="hljs-keyword">new</span> ConfigurationClassParser(
			<span class="hljs-keyword">this</span>.metadataReaderFactory, <span class="hljs-keyword">this</span>.problemReporter, <span class="hljs-keyword">this</span>.environment,
			<span class="hljs-keyword">this</span>.resourceLoader, <span class="hljs-keyword">this</span>.componentScanBeanNameGenerator, registry);

	Set&lt;BeanDefinitionHolder&gt; candidates = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(configCandidates);
	Set&lt;ConfigurationClass&gt; alreadyParsed = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(configCandidates.size());
	<span class="hljs-keyword">do</span> &#123;
		parser.parse(candidates);
		parser.validate();

		Set&lt;ConfigurationClass&gt; configClasses = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(parser.getConfigurationClasses());
		configClasses.removeAll(alreadyParsed);

		<span class="hljs-comment">// Read the model and create bean definitions based on its content</span>
		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.reader == <span class="hljs-keyword">null</span>) &#123;
			<span class="hljs-keyword">this</span>.reader = <span class="hljs-keyword">new</span> ConfigurationClassBeanDefinitionReader(
					registry, <span class="hljs-keyword">this</span>.sourceExtractor, <span class="hljs-keyword">this</span>.resourceLoader, <span class="hljs-keyword">this</span>.environment,
					<span class="hljs-keyword">this</span>.importBeanNameGenerator, parser.getImportRegistry());
		&#125;
		<span class="hljs-comment">//设置beanDefinition的属性值,重点看，具体执行 import importSource @Bean的逻辑</span>
		<span class="hljs-keyword">this</span>.reader.loadBeanDefinitions(configClasses);
		alreadyParsed.addAll(configClasses);

		candidates.clear();
		<span class="hljs-keyword">if</span> (registry.getBeanDefinitionCount() &gt; candidateNames.length) &#123;
			String[] newCandidateNames = registry.getBeanDefinitionNames();
			Set&lt;String&gt; oldCandidateNames = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(Arrays.asList(candidateNames));
			Set&lt;String&gt; alreadyParsedClasses = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();
			<span class="hljs-keyword">for</span> (ConfigurationClass configurationClass : alreadyParsed) &#123;
				alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());
			&#125;
			<span class="hljs-keyword">for</span> (String candidateName : newCandidateNames) &#123;
				<span class="hljs-keyword">if</span> (!oldCandidateNames.contains(candidateName)) &#123;
					BeanDefinition bd = registry.getBeanDefinition(candidateName);
					<span class="hljs-keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, <span class="hljs-keyword">this</span>.metadataReaderFactory) &amp;&amp;
							!alreadyParsedClasses.contains(bd.getBeanClassName())) &#123;
						candidates.add(<span class="hljs-keyword">new</span> BeanDefinitionHolder(bd, candidateName));
					&#125;
				&#125;
			&#125;
			candidateNames = newCandidateNames;
		&#125;
	&#125;
	<span class="hljs-keyword">while</span> (!candidates.isEmpty());

	<span class="hljs-comment">// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes</span>
	<span class="hljs-keyword">if</span> (sbr != <span class="hljs-keyword">null</span> &amp;&amp; !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) &#123;
		sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());
	&#125;

	<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.metadataReaderFactory <span class="hljs-keyword">instanceof</span> CachingMetadataReaderFactory) &#123;
		<span class="hljs-comment">// Clear cache in externally provided MetadataReaderFactory; this is a no-op</span>
		<span class="hljs-comment">// for a shared cache since it&#x27;ll be cleared by the ApplicationContext.</span>
		((CachingMetadataReaderFactory) <span class="hljs-keyword">this</span>.metadataReaderFactory).clearCache();
	&#125;
&#125;</code></pre>

<h5 id="checkConfigurationClassCandidate-方法"><a href="#checkConfigurationClassCandidate-方法" class="headerlink" title="checkConfigurationClassCandidate()方法"></a>checkConfigurationClassCandidate()方法</h5><p>该方法会检查类上是否有@Component、@ComponentScan、@Import、@ImportResource、@Configuration注解或者方法上是否有@Bean注解，如果有会对用于排序的order属性进行设置。</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkConfigurationClassCandidate</span><span class="hljs-params">(</span></span>
<span class="hljs-function"><span class="hljs-params">		BeanDefinition beanDef, MetadataReaderFactory metadataReaderFactory)</span> </span>&#123;

	String className = beanDef.getBeanClassName();
	<span class="hljs-keyword">if</span> (className == <span class="hljs-keyword">null</span> || beanDef.getFactoryMethodName() != <span class="hljs-keyword">null</span>) &#123;
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
	&#125;

	AnnotationMetadata metadata;
	<span class="hljs-keyword">if</span> (beanDef <span class="hljs-keyword">instanceof</span> AnnotatedBeanDefinition &amp;&amp;
			className.equals(((AnnotatedBeanDefinition) beanDef).getMetadata().getClassName())) &#123;
		<span class="hljs-comment">// Can reuse the pre-parsed metadata from the given BeanDefinition...</span>
		metadata = ((AnnotatedBeanDefinition) beanDef).getMetadata();
	&#125;
	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (beanDef <span class="hljs-keyword">instanceof</span> AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) beanDef).hasBeanClass()) &#123;
		<span class="hljs-comment">// Check already loaded Class if present...</span>
		<span class="hljs-comment">// since we possibly can&#x27;t even load the class file for this Class.</span>
		Class&lt;?&gt; beanClass = ((AbstractBeanDefinition) beanDef).getBeanClass();
		metadata = <span class="hljs-keyword">new</span> StandardAnnotationMetadata(beanClass, <span class="hljs-keyword">true</span>);
	&#125;
	<span class="hljs-keyword">else</span> &#123;
		<span class="hljs-keyword">try</span> &#123;
			MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(className);
			metadata = metadataReader.getAnnotationMetadata();
		&#125;
		<span class="hljs-keyword">catch</span> (IOException ex) &#123;
			<span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;
				logger.debug(<span class="hljs-string">&quot;Could not find class file for introspecting configuration annotations: &quot;</span> +
						className, ex);
			&#125;
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
		&#125;
	&#125;

	<span class="hljs-comment">//判断是否有@Component、@ComponentScan、@Import、@ImportResource、@Configuration注解</span>
	<span class="hljs-keyword">if</span> (isFullConfigurationCandidate(metadata)) &#123;
		beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_FULL);
	&#125;
	<span class="hljs-comment">//判断是否有@Component注解，或者类上面没注解（xml配置实例化）方法上面有@Bean注解</span>
	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isLiteConfigurationCandidate(metadata)) &#123;
		beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_LITE);
	&#125;
	<span class="hljs-keyword">else</span> &#123;
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
	&#125;

	<span class="hljs-comment">// It&#x27;s a full or lite configuration candidate... Let&#x27;s determine the order value, if any.</span>
   <span class="hljs-comment">//设置order属性</span>
	Integer order = getOrder(metadata);
	<span class="hljs-keyword">if</span> (order != <span class="hljs-keyword">null</span>) &#123;
		beanDef.setAttribute(ORDER_ATTRIBUTE, order);
	&#125;

	<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
&#125;</code></pre>

<h5 id="parse-方法"><a href="#parse-方法" class="headerlink" title="parse()方法"></a>parse()方法</h5><p>parse()方法最终会调用doProcessConfigurationClass()方法对注解进行处理。此处分析的为componentScanParser中的doProcessConfigurationClass()方法，该方法会使用parse()方法解析某些有特定注解的类，然后对@Import注解进行处理，最后调用scanner.doScan()方法完成包扫描。@Import注解用于引用一个类，该类会交由spring初始化及管理，常用于引入扫描路径之外的类。</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> SourceClass <span class="hljs-title">doProcessConfigurationClass</span><span class="hljs-params">(ConfigurationClass configClass, SourceClass sourceClass)</span></span>
<span class="hljs-function">		<span class="hljs-keyword">throws</span> IOException </span>&#123;

	<span class="hljs-keyword">if</span> (configClass.getMetadata().isAnnotated(Component.class.getName())) &#123;
		<span class="hljs-comment">// Recursively process any member (nested) classes first</span>
		processMemberClasses(configClass, sourceClass);
	&#125;

	<span class="hljs-comment">// Process any @PropertySource annotations</span>
	<span class="hljs-keyword">for</span> (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(
			sourceClass.getMetadata(), PropertySources.class,
			org.springframework.context.annotation.PropertySource.class)) &#123;
		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.environment <span class="hljs-keyword">instanceof</span> ConfigurableEnvironment) &#123;
			processPropertySource(propertySource);
		&#125;
		<span class="hljs-keyword">else</span> &#123;
			logger.info(<span class="hljs-string">&quot;Ignoring @PropertySource annotation on [&quot;</span> + sourceClass.getMetadata().getClassName() +
					<span class="hljs-string">&quot;]. Reason: Environment must implement ConfigurableEnvironment&quot;</span>);
		&#125;
	&#125;

	<span class="hljs-comment">// Process any @ComponentScan annotations</span>
	Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(
			sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);
	<span class="hljs-keyword">if</span> (!componentScans.isEmpty() &amp;&amp;
			!<span class="hljs-keyword">this</span>.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123;
		<span class="hljs-keyword">for</span> (AnnotationAttributes componentScan : componentScans) &#123;
			<span class="hljs-comment">// The config class is annotated with @ComponentScan -&gt; perform the scan immediately</span>
       <span class="hljs-comment">//重点看这个方法</span>
			Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =
					<span class="hljs-keyword">this</span>.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());
			<span class="hljs-comment">// Check the set of scanned definitions for any further config classes and parse recursively if needed</span>
			<span class="hljs-keyword">for</span> (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123;
				BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();
				<span class="hljs-keyword">if</span> (bdCand == <span class="hljs-keyword">null</span>) &#123;
					bdCand = holder.getBeanDefinition();
				&#125;
         <span class="hljs-comment">//对特定注解进行扫描</span>
				<span class="hljs-keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, <span class="hljs-keyword">this</span>.metadataReaderFactory)) &#123;
					parse(bdCand.getBeanClassName(), holder.getBeanName());
				&#125;
			&#125;
		&#125;
	&#125;

   <span class="hljs-comment">//用于处理@import注解</span>
	<span class="hljs-comment">// Process any @Import annotations</span>
	processImports(configClass, sourceClass, getImports(sourceClass), <span class="hljs-keyword">true</span>);

	<span class="hljs-comment">// Process any @ImportResource annotations</span>
	AnnotationAttributes importResource =
			AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);
	<span class="hljs-keyword">if</span> (importResource != <span class="hljs-keyword">null</span>) &#123;
		String[] resources = importResource.getStringArray(<span class="hljs-string">&quot;locations&quot;</span>);
		Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass(<span class="hljs-string">&quot;reader&quot;</span>);
		<span class="hljs-keyword">for</span> (String resource : resources) &#123;
			String resolvedResource = <span class="hljs-keyword">this</span>.environment.resolveRequiredPlaceholders(resource);
			configClass.addImportedResource(resolvedResource, readerClass);
		&#125;
	&#125;

	<span class="hljs-comment">// Process individual @Bean methods</span>
	Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);
	<span class="hljs-keyword">for</span> (MethodMetadata methodMetadata : beanMethods) &#123;
		configClass.addBeanMethod(<span class="hljs-keyword">new</span> BeanMethod(methodMetadata, configClass));
	&#125;

	<span class="hljs-comment">// Process default methods on interfaces</span>
	processInterfaces(configClass, sourceClass);

	<span class="hljs-comment">// Process superclass, if any</span>
	<span class="hljs-keyword">if</span> (sourceClass.getMetadata().hasSuperClass()) &#123;
		String superclass = sourceClass.getMetadata().getSuperClassName();
		<span class="hljs-keyword">if</span> (superclass != <span class="hljs-keyword">null</span> &amp;&amp; !superclass.startsWith(<span class="hljs-string">&quot;java&quot;</span>) &amp;&amp;
				!<span class="hljs-keyword">this</span>.knownSuperclasses.containsKey(superclass)) &#123;
			<span class="hljs-keyword">this</span>.knownSuperclasses.put(superclass, configClass);
			<span class="hljs-comment">// Superclass found, return its annotation metadata and recurse</span>
			<span class="hljs-keyword">return</span> sourceClass.getSuperClass();
		&#125;
	&#125;

	<span class="hljs-comment">// No superclass -&gt; processing is complete</span>
	<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
 &#125;</code></pre>

<h5 id="loadBeanDefinitions"><a href="#loadBeanDefinitions" class="headerlink" title="loadBeanDefinitions()"></a>loadBeanDefinitions()</h5><p>loadBeanDefinitions最终会调用loadBeanDefinitionsForConfigurationClass()方法完成对@Bean，@Import，@ImportSource注解的处理。@ImportSources注解会引入一个xml文件，loadBeanDefinitionsFromImportedResources()方法会调用loadBeanDefinitions()方法解析xml文件，这个方法在spring以xml文件的方式启动时调用的相同。</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadBeanDefinitionsForConfigurationClass</span><span class="hljs-params">(</span></span>
<span class="hljs-function"><span class="hljs-params">		ConfigurationClass configClass, TrackedConditionEvaluator trackedConditionEvaluator)</span> </span>&#123;

	<span class="hljs-keyword">if</span> (trackedConditionEvaluator.shouldSkip(configClass)) &#123;
		String beanName = configClass.getBeanName();
		<span class="hljs-keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="hljs-keyword">this</span>.registry.containsBeanDefinition(beanName)) &#123;
			<span class="hljs-keyword">this</span>.registry.removeBeanDefinition(beanName);
		&#125;
		<span class="hljs-keyword">this</span>.importRegistry.removeImportingClass(configClass.getMetadata().getClassName());
		<span class="hljs-keyword">return</span>;
	&#125;

	<span class="hljs-keyword">if</span> (configClass.isImported()) &#123;
		registerBeanDefinitionForImportedConfigurationClass(configClass);
	&#125;
	<span class="hljs-keyword">for</span> (BeanMethod beanMethod : configClass.getBeanMethods()) &#123;
		<span class="hljs-comment">//@Bean标签的处理</span>
		loadBeanDefinitionsForBeanMethod(beanMethod);
	&#125;
	<span class="hljs-comment">//@ImportSources注解处理</span>
	loadBeanDefinitionsFromImportedResources(configClass.getImportedResources());
	<span class="hljs-comment">//@Import注解处理</span>
	loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars());
&#125;</code></pre>


            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/blog/categories/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">Spring源码解析</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/blog/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">源码解析</a>
                    
                      <a class="hover-with-bg" href="/blog/tags/spring/">spring</a>
                    
                  </div>
                
              </div>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/blog/2020/04/19/Spring%E6%BA%90%E7%A0%81/AOP%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Spring的AOP源码解析</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/blog/2020/04/15/Spring%E6%BA%90%E7%A0%81/%E5%AE%9E%E4%BE%8B%E5%8C%96bean%E7%9A%84%E8%BF%87%E7%A8%8B/">
                        <span class="hidden-mobile">Spring实例化Bean的过程</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":200})
    NProgress.start()
    document.addEventListener('DOMContentLoaded', function() {
      window.NProgress && window.NProgress.inc();
    })
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.staticfile.org/jquery/3.5.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/js/bootstrap.min.js" ></script>
<script  src="/blog/js/debouncer.js" ></script>
<script  src="/blog/js/events.js" ></script>
<script  src="/blog/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/blog/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.staticfile.org/tocbot/4.12.0/tocbot.min.js" ></script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>





  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/blog/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/blog/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/blog/js/boot.js" ></script>



</body>
</html>
