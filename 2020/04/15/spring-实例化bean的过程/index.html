<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/blog/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/blog/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="">
  <meta name="keywords" content="">
  <title>Springå®ä¾‹åŒ–Beançš„è¿‡ç¨‹ - ğŸğŸŠ&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/5.12.1/css/all.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/mdbootstrap/4.13.0/css/mdb.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/3.0.1/github-markdown.min.css" />

<link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">



  <link  rel="stylesheet" href="/blog/lib/prettify/tomorrow-night-eighties.min.css" />

<link  rel="stylesheet" href="/blog/css/main.css" />


  <link defer rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />


<!-- è‡ªå®šä¹‰æ ·å¼ä¿æŒåœ¨æœ€åº•éƒ¨ -->


<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/blog/">&nbsp;<strong>ğŸğŸŠ's blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/blog/">é¦–é¡µ</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/blog/archives/">å½’æ¡£</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/blog/categories/">åˆ†ç±»</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/blog/tags/">æ ‡ç­¾</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/blog/about">å…³äº</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/blog/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
                <p class="mt-3 post-meta">
                  <i class="fas fa-calendar-alt" aria-hidden="true"></i>
                  æ˜ŸæœŸä¸‰, å››æœˆ 15æ—¥ 2020, 9:09 æ™šä¸Š
                </p>
              

              <p class="mt-1">
                
                  
                  <span class="post-meta">
                    <i class="far fa-chart-bar"></i>
                    14.3k å­—
                  </span>
                

                
                  
                  <span class="post-meta">
                      <i class="far fa-clock"></i>
                      73 åˆ†é’Ÿ
                  </span>
                

                
                  <!-- ä¸è’œå­ç»Ÿè®¡æ–‡ç« PV -->
                  
                  <span id="busuanzi_container_page_pv" class="post-meta" style="display: none">
                    <i class="far fa-eye" aria-hidden="true"></i>
                    <span id="busuanzi_value_page_pv"></span> æ¬¡
                  </span>
                
              </p>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5 z-depth-3" id="board">
          <div class="post-content mx-auto" id="post">
            
              <p
                class="note note-warning">æœ¬æ–‡æœ€åæ›´æ–°äºï¼šæ˜ŸæœŸäº”, å…«æœˆ 7æ—¥ 2020, 3:40 ä¸‹åˆ</p>
            
            <div class="markdown-body">
              <h2 id="DeanDefinitionç®€ä»‹"><a href="#DeanDefinitionç®€ä»‹" class="headerlink" title="DeanDefinitionç®€ä»‹"></a>DeanDefinitionç®€ä»‹</h2><p>BeanDefinitionåœ¨springä¸­è´¯ç©¿å§‹ç»ˆï¼Œspringè¦æ ¹æ®BeanDefinitonå¯¹è±¡æ¥å®ä¾‹åŒ–beanã€‚åœ¨å®ä¾‹åŒ–ä¹‹å‰ï¼Œéœ€è¦è§£æbeanæ ‡ç­¾å¹¶å°è£…æˆBeanDefinitonå¯¹è±¡ã€‚</p>
<h3 id="BeanDefinitionå®ç°ç±»"><a href="#BeanDefinitionå®ç°ç±»" class="headerlink" title="BeanDefinitionå®ç°ç±»"></a>BeanDefinitionå®ç°ç±»</h3><ul>
<li>ChildBeanDefinitionï¼šChildBeanDefinitioå¯ä»¥ç»§æ‰¿parent bean definitionçš„è®¾ç½®ï¼Œå¯¹RootBeanDefinition æœ‰ä¸€å®šçš„ä¾èµ–å…³ç³»ã€‚ ChildBeanDefinitionå¯ä»¥ç»§æ‰¿çˆ¶ç±»çš„æ„é€ å‚æ•°å€¼ï¼Œå±æ€§å€¼å¹¶å¯ä»¥é‡å†™çˆ¶ç±»çš„æ–¹æ³•ï¼ŒåŒæ—¶ä¹Ÿå¯ä»¥å¢åŠ æ–°çš„å±æ€§æˆ–è€…æ–¹æ³•ã€‚è‹¥æŒ‡å®šåˆå§‹åŒ–æ–¹æ³•ï¼Œé”€æ¯æ–¹æ³•æˆ–è€…é™æ€å·¥å‚æ–¹æ³•ï¼ŒChildBeanDefinitionå°†é‡å†™ç›¸åº”çˆ¶ç±»çš„è®¾ç½®ã€‚</li>
<li>RootBeanDefinitionï¼šRootBeanDefinitionæ˜¯ä¸€ä¸ªå¯åˆå¹¶çš„bean definitionï¼Œå³åœ¨spring beanFactoryè¿è¡ŒæœŸé—´ï¼Œå¯ä»¥è¿”å›ä¸€ä¸ªç‰¹å®šçš„beanã€‚</li>
<li>GenericBeanDefinitionï¼šä»spring 2.5ä»¥åäº†æä¾›çš„æ›´å¥½çš„æ³¨å†Œbean definitionç±»ï¼Œç”¨æ¥æ›¿ä»£ChildBeanDefinitionè·ŸRootBeanDefinitionã€‚æ ‡å‡†BeanDefinitionï¼Œé™¤äº†å…·æœ‰æŒ‡å®šç±»ã€å¯é€‰çš„æ„é€ å‚æ•°å€¼å’Œå±æ€§å‚æ•°è¿™äº›å…¶å®ƒBeanDefinitionä¸€æ ·çš„ç‰¹æ€§å¤–ï¼Œå®ƒè¿˜å…·æœ‰é€šè¿‡parenetNameå±æ€§æ¥åŠ¨æ€è®¾ç½®parent bean definitionï¼Œè€Œéç¡¬ç¼–ç ä½œä¸ºroot bean definitionã€‚ </li>
</ul>
<h3 id="BeanDefinitionä¸­çš„å±æ€§"><a href="#BeanDefinitionä¸­çš„å±æ€§" class="headerlink" title="BeanDefinitionä¸­çš„å±æ€§"></a>BeanDefinitionä¸­çš„å±æ€§</h3><img src="/blog/2020/04/15/spring-%E5%AE%9E%E4%BE%8B%E5%8C%96bean%E7%9A%84%E8%BF%87%E7%A8%8B/pic1.png" srcset="/blog/img/loading.gif" class>

<ul>
<li><p>idï¼šBean çš„å”¯ä¸€æ ‡è¯†åã€‚å®ƒå¿…é¡»æ˜¯åˆæ³•çš„ XMLIDï¼Œåœ¨æ•´ä¸ª XML æ–‡æ¡£ä¸­å”¯ä¸€ã€‚</p>
</li>
<li><p>nameï¼šç”¨æ¥ä¸ºidåˆ›å»ºä¸€ä¸ªæˆ–å¤šä¸ªåˆ«åã€‚å®ƒå¯ä»¥æ˜¯ä»»æ„çš„å­—æ¯ç¬¦åˆã€‚å¤šä¸ªåˆ«åä¹‹é—´ç”¨é€—å·æˆ–ç©ºæ ¼åˆ†å¼€ã€‚</p>
</li>
<li><p>classï¼šç”¨æ¥å®šä¹‰ç±»çš„å…¨é™å®šå(åŒ…å+ç±»å)ã€‚åªæœ‰å­ç±» Bean ä¸ç”¨å®šä¹‰è¯¥å±æ€§ã€‚</p>
</li>
<li><p>parentï¼šå­ç±»Bean å®šä¹‰å®ƒæ‰€å¼•ç”¨å®ƒçš„çˆ¶ç±»Beanã€‚è¿™æ—¶å‰é¢çš„class å±æ€§å¤±æ•ˆã€‚å­ç±»Beanä¼šç»§æ‰¿çˆ¶ç±»Beançš„æ‰€æœ‰å±æ€§ï¼Œå­ç±»Beanä¹Ÿå¯ä»¥è¦†ç›–çˆ¶ç±» Bean çš„å±æ€§ã€‚æ³¨æ„:å­ç±» Bean å’Œçˆ¶ç±» Bean æ˜¯åŒä¸€ ä¸ª Java ç±»ã€‚</p>
</li>
<li><p>abstract(é»˜è®¤ä¸ºâ€falseâ€)ï¼šç”¨æ¥å®šä¹‰Beanæ˜¯å¦ä¸ºæŠ½è±¡Beanã€‚å®ƒè¡¨ç¤ºè¿™ä¸ªBeanå°†ä¸ä¼šè¢«å®ä¾‹åŒ–ï¼Œä¸€èˆ¬ç”¨äºçˆ¶ç±» Beanï¼Œå› ä¸ºçˆ¶ç±»Beanä¸»è¦æ˜¯ä¾›å­ç±»Beanç»§æ‰¿ä½¿ç”¨ã€‚</p>
</li>
<li><p>lazy-init(é»˜è®¤ä¸ºâ€œdefaultâ€)ï¼šç”¨æ¥å®šä¹‰è¿™ä¸ªBeanæ˜¯å¦å®ç°æ‡’åˆå§‹åŒ–ã€‚å¦‚æœä¸ºâ€œtrueâ€ï¼Œå®ƒå°†åœ¨BeanFactory å¯åŠ¨æ—¶åˆå§‹åŒ–æ‰€æœ‰çš„SingletonBeanã€‚åä¹‹ï¼Œå¦‚æœä¸ºâ€œfalseâ€ï¼Œå®ƒåªåœ¨Beanè¯·æ±‚æ—¶æ‰å¼€å§‹åˆ›å»ºSingletonBeanã€‚</p>
</li>
<li><p>autowireï¼š(è‡ªåŠ¨è£…é…ï¼Œé»˜è®¤ä¸ºâ€œdefaultâ€ï¼šå®ƒå®šä¹‰äº†Beançš„è‡ªåŠ¨è£…è½½æ–¹å¼ã€‚ </p>
<ul>
<li><p>â€œnoâ€ï¼šä¸ä½¿ç”¨è‡ªåŠ¨è£…é…åŠŸèƒ½ã€‚</p>
</li>
<li><p>â€œbyNameâ€ï¼šé€šè¿‡ Bean çš„å±æ€§åå®ç°è‡ªåŠ¨è£…é…ã€‚</p>
</li>
<li><p>â€œbyTypeâ€ï¼šé€šè¿‡ Bean çš„ç±»å‹å®ç°è‡ªåŠ¨è£…é…ã€‚</p>
</li>
<li><p>â€œconstructorâ€ï¼šç±»ä¼¼äº byTypeï¼Œä½†å®ƒæ˜¯ç”¨äºæ„é€ å‡½æ•°çš„å‚æ•°çš„è‡ªåŠ¨ç»„è£…ã€‚</p>
</li>
<li><p>â€œautodetectâ€ï¼šé€šè¿‡ Bean ç±»çš„åçœæœºåˆ¶(introspection)å†³å®šæ˜¯ä½¿ç”¨â€œconstructorâ€è¿˜æ˜¯ä½¿ç”¨â€œbyTypeâ€ã€‚</p>
</li>
</ul>
</li>
<li><p>depends-on(ä¾èµ–å¯¹è±¡)ï¼šè¿™ä¸ªBeanåœ¨åˆå§‹åŒ–æ—¶ä¾èµ–çš„å¯¹è±¡ï¼Œè¿™ä¸ªå¯¹è±¡ä¼šåœ¨è¿™ä¸ªBeanåˆå§‹åŒ–ä¹‹å‰åˆ›å»ºã€‚</p>
</li>
<li><p>init-methodï¼šç”¨æ¥å®šä¹‰Beançš„åˆå§‹åŒ–æ–¹æ³•ï¼Œå®ƒä¼šåœ¨Beanç»„è£…ä¹‹åè°ƒç”¨ã€‚å®ƒå¿…é¡»æ˜¯ä¸€ä¸ªæ— å‚æ•°çš„æ–¹æ³•ã€‚</p>
</li>
<li><p>destroy-methodï¼šç”¨æ¥å®šä¹‰Beançš„é”€æ¯æ–¹æ³•ï¼Œå®ƒåœ¨BeanFactoryå…³é—­æ—¶è°ƒç”¨ã€‚åŒæ ·ï¼Œå®ƒä¹Ÿå¿…é¡»æ˜¯ä¸€ä¸ªæ— å‚æ•°çš„æ–¹æ³•ã€‚å®ƒåªèƒ½åº”ç”¨äº singletonBeanã€‚</p>
</li>
<li><p>factory-methodï¼šå®šä¹‰åˆ›å»ºè¯¥Beanå¯¹è±¡çš„å·¥å‚æ–¹æ³•ã€‚å®ƒç”¨äºä¸‹é¢çš„â€œfactory-beanâ€ï¼Œè¡¨ç¤º è¿™ä¸ªBeanæ˜¯é€šè¿‡å·¥å‚æ–¹æ³•åˆ›å»ºã€‚æ­¤æ—¶ï¼Œâ€œclassâ€å±æ€§å¤±æ•ˆã€‚</p>
</li>
<li><p>factory-beanï¼šå®šä¹‰åˆ›å»ºè¯¥Beanå¯¹è±¡çš„å·¥å‚ç±»ã€‚å¦‚æœä½¿ç”¨äº†â€œfactory-beanâ€åˆ™â€œclassâ€å±æ€§å¤±æ•ˆã€‚</p>
</li>
<li><p>autowire-candidateï¼šé‡‡ç”¨xmlæ ¼å¼é…ç½®beanæ—¶ï¼Œå°†&lt;bean/&gt;å…ƒç´ çš„autowire-candidateå±æ€§è®¾ç½®ä¸º falseï¼Œè¿™æ ·å®¹å™¨åœ¨æŸ¥æ‰¾è‡ªåŠ¨è£…é…å¯¹è±¡æ—¶ï¼Œå°†ä¸è€ƒè™‘è¯¥beanï¼Œå³å®ƒä¸ä¼šè¢«è€ƒè™‘ä½œä¸ºå…¶å®ƒbeanè‡ªåŠ¨è£…é…çš„å€™é€‰è€…ï¼Œä½†æ˜¯è¯¥beanæœ¬èº«è¿˜æ˜¯å¯ä»¥ä½¿ç”¨è‡ªåŠ¨è£…é…æ¥æ³¨å…¥å…¶å®ƒbeançš„ã€‚</p>
</li>
<li><p>MutablePropertyValuesï¼šç”¨äºå°è£…&lt;property&gt;æ ‡ç­¾çš„ä¿¡æ¯ï¼Œå…¶å®ç±»é‡Œé¢å°±æ˜¯æœ‰ä¸€ä¸ªlistï¼Œlisté‡Œé¢æ˜¯PropertyValueå¯¹è±¡ï¼ŒPropertyValueå°±æ˜¯ä¸€ä¸ªnameå’Œvalueå±æ€§ï¼Œç”¨äºå°è£…&lt;property&gt;æ ‡ç­¾çš„åç§°å’Œå€¼ä¿¡æ¯</p>
</li>
<li><p>ConstructorArgumentValuesï¼šç”¨äºå°è£…&lt;constructor-arg&gt;\æ ‡ç­¾çš„ä¿¡æ¯ï¼Œå…¶å®ç±»é‡Œé¢å°±æ˜¯æœ‰ä¸€ä¸ªmapï¼Œmapä¸­ç”¨æ„é€ å‡½æ•°çš„å‚æ•°é¡ºåºä½œä¸ºkeyï¼Œå€¼ä½œä¸ºvalueå­˜å‚¨åˆ°mapä¸­</p>
</li>
<li><p>MethodOverridesï¼šç”¨äºå°è£…lookup-methodå’Œreplaced-methodæ ‡ç­¾çš„ä¿¡æ¯ï¼ŒåŒæ ·çš„ç±»é‡Œé¢æœ‰ä¸€ä¸ªSetå¯¹è±¡æ·»åŠ LookupOverrideå¯¹è±¡å’ŒReplaceOverrideå¯¹è±¡</p>
</li>
</ul>
<h2 id="invokeBeanFactoryPostProcessors-æ–¹æ³•"><a href="#invokeBeanFactoryPostProcessors-æ–¹æ³•" class="headerlink" title="invokeBeanFactoryPostProcessors()æ–¹æ³•"></a>invokeBeanFactoryPostProcessors()æ–¹æ³•</h2><p>invokeBeanFactoryPostProcessors()æ–¹æ³•åœ¨springçš„æ ¸å¿ƒæ–¹æ³•refresh()ä¸­è°ƒç”¨ï¼Œä¸»è¦ç”¨äºå¤„ç†BeanFactoryPostProcessoræ¥å£ï¼Œæ˜¯é’ˆå¯¹BeanFactoryçš„æ‰©å±•ï¼Œä¸»è¦ç”¨åœ¨beanå®ä¾‹åŒ–ä¹‹å‰ï¼Œè¯»å–beançš„å®šä¹‰ï¼Œå®Œæˆå¯¹BeanDefinitionçš„ä¿®æ”¹ã€‚</p>
<p>è¯¥æ–¹æ³•ä¼šå®ä¾‹åŒ–å’Œè°ƒç”¨æ‰€æœ‰çš„BeanFactoryPostProcessorï¼ˆåŒ…æ‹¬å­ç±»BeanDefinitionRegistryPostProcessorï¼‰ï¼Œå¹¶è°ƒç”¨postProcessBeanDefinitionRegistry()æ–¹æ³•ã€‚</p>
<p>postProcessBeanDefinitionRegistry()æ–¹æ³•çš„å…¥å‚ä¸ºBeanDefinitionRegistryå¯¹è±¡ï¼Œé€šè¿‡è¿™ä¸ªå¯¹è±¡å¯ä»¥å®Œæˆå¯¹æ‰€æœ‰BeanDefinitionå¯¹è±¡çš„å¢åˆ æ”¹æŸ¥ã€‚</p>
<p>åœ¨æ‰§è¡Œè¿‡ç¨‹ä¸­ä¼šå¯¹å®ç°æ’åºæ¥å£çš„BeanFactoryPostProcessorè¿›è¡Œæ’åºï¼Œç„¶åæŒ‰ç…§é¡ºåºè¿›è¡Œè°ƒç”¨ã€‚</p>
<p>è°ƒç”¨é¡ºåºä¸º: </p>
<ol>
<li>å®ç°PriorityOrderedæ’åºæ¥å£</li>
<li>å®ç°Orderedæ’åºæ¥å£</li>
<li>æ²¡æœ‰å®ç°æ¥å£çš„è°ƒç”¨</li>
</ol>
<pre><code class="java">    public static void invokeBeanFactoryPostProcessors(
            ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors) {

        // Invoke BeanDefinitionRegistryPostProcessors first, if any.
        Set&lt;String&gt; processedBeans = new HashSet&lt;&gt;();

        if (beanFactory instanceof BeanDefinitionRegistry) {
            BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;
            List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = new ArrayList&lt;&gt;();
            List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = new ArrayList&lt;&gt;();

            for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) {
                if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) {
                    BeanDefinitionRegistryPostProcessor registryProcessor =
                            (BeanDefinitionRegistryPostProcessor) postProcessor;
                    registryProcessor.postProcessBeanDefinitionRegistry(registry);
                    registryProcessors.add(registryProcessor);
                }
                else {
                    regularPostProcessors.add(postProcessor);
                }
            }

            // Do not initialize FactoryBeans here: We need to leave all regular beans
            // uninitialized to let the bean factory post-processors apply to them!
            // Separate between BeanDefinitionRegistryPostProcessors that implement
            // PriorityOrdered, Ordered, and the rest.
            List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = new ArrayList&lt;&gt;();

            //è·å–å®ç°äº†BeanDefinitionRegistryPostProcessoræ¥å£çš„æ‰€æœ‰ç±»çš„BeanDefinitionå¯¹è±¡çš„beanName
            // First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.
            String[] postProcessorNames =
                    beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
            for (String ppName : postProcessorNames) {
                //åˆ¤æ–­æ˜¯å¦å®ç°äº†æ’åºæ¥å£ PriorityOrdered
                if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
                    currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
                    processedBeans.add(ppName);
                }
            }

            //æ’åº
            sortPostProcessors(currentRegistryProcessors, beanFactory);
            registryProcessors.addAll(currentRegistryProcessors);

            //è°ƒç”¨è¿‡ç¨‹
            invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
            currentRegistryProcessors.clear();

            // Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.
            postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
            for (String ppName : postProcessorNames) {

                //åˆ¤æ–­æ˜¯å¦æ˜¯å®ç°çš„Orderedæ¥å£
                if (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) {
          //å®Œæˆå®ä¾‹åŒ–
                    currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
                    processedBeans.add(ppName);
                }
            }
            sortPostProcessors(currentRegistryProcessors, beanFactory);
            registryProcessors.addAll(currentRegistryProcessors);
            invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
            currentRegistryProcessors.clear();

            //æ²¡å®ç°æ’åºæ¥å£çš„è°ƒç”¨
            // Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.
            boolean reiterate = true;
            while (reiterate) {
                reiterate = false;
                postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
                for (String ppName : postProcessorNames) {
                    if (!processedBeans.contains(ppName)) {
                        currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
                        processedBeans.add(ppName);
                        reiterate = true;
                    }
                }
                sortPostProcessors(currentRegistryProcessors, beanFactory);
                registryProcessors.addAll(currentRegistryProcessors);
                //
                invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
                currentRegistryProcessors.clear();
            }

            //è°ƒç”¨postProcessBeanFactoryæ–¹æ³•
            // Now, invoke the postProcessBeanFactory callback of all processors handled so far.
            invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);
            invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);
        }

        else {
            // Invoke factory processors registered with the context instance.
            invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);
        }

        //è·å–å®ç°äº†BeanFactoryPostProcessoræ¥å£çš„ç±»ï¼Œè·å–beanDefinitionçš„åç§°
        // Do not initialize FactoryBeans here: We need to leave all regular beans
        // uninitialized to let the bean factory post-processors apply to them!
        String[] postProcessorNames =
                beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);

        // Separate between BeanFactoryPostProcessors that implement PriorityOrdered,
        // Ordered, and the rest.
        List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;&gt;();
        List&lt;String&gt; orderedPostProcessorNames = new ArrayList&lt;&gt;();
        List&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList&lt;&gt;();
        for (String ppName : postProcessorNames) {
            if (processedBeans.contains(ppName)) {
                // skip - already processed in first phase above
            }
            //å®ç°äº†PriorityOrderedæ¥å£çš„
            else if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
                priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));
            }
            //å®ç°äº†Orderedæ¥å£çš„
            else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {
                orderedPostProcessorNames.add(ppName);
            }
            else {
                //æ²¡å®ç°æ¥å£çš„
                nonOrderedPostProcessorNames.add(ppName);
            }
        }

        //æ’åº
        // First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.
        sortPostProcessors(priorityOrderedPostProcessors, beanFactory);

        //è°ƒç”¨
        invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);

        // Next, invoke the BeanFactoryPostProcessors that implement Ordered.
        List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;&gt;();
        for (String postProcessorName : orderedPostProcessorNames) {
            orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));
        }
        sortPostProcessors(orderedPostProcessors, beanFactory);
        invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);

        // Finally, invoke all other BeanFactoryPostProcessors.
        List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = new ArrayList&lt;&gt;();
        for (String postProcessorName : nonOrderedPostProcessorNames) {
            nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));
        }
        invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);

        // Clear cached merged bean definitions since the post-processors might have
        // modified the original metadata, e.g. replacing placeholders in values...
        beanFactory.clearMetadataCache();
    }</code></pre>
<h2 id="registerBeanPostProcessors-æ–¹æ³•"><a href="#registerBeanPostProcessors-æ–¹æ³•" class="headerlink" title="registerBeanPostProcessors()æ–¹æ³•"></a>registerBeanPostProcessors()æ–¹æ³•</h2><p>registerBeanPostProcessorsæ–¹æ³•ä¸»è¦ç”¨äºå¤„ç†BeanPostProcessoræ¥å£ï¼Œä¼šå®ä¾‹åŒ–æ‰€æœ‰çš„BeanPostProcessorï¼Œå°†æ‰€æœ‰å®ç°äº†BeanPostProcessoræ¥å£çš„ç±»åŠ è½½åˆ°BeanFactoryä¸­ã€‚BeanPostProcessoræ¥å£ç”¨äºåœ¨BeanDefinationåˆå§‹åŒ–è¿‡ç¨‹ä¸­å¯¹Beanè¿›è¡Œä¸€äº›æ“ä½œã€‚</p>
<p>è°ƒç”¨é¡ºåºä¸invokeBeanFactoryPostProcessors()æ–¹æ³•ç›¸åŒã€‚</p>
<pre><code class="java">    public static void registerBeanPostProcessors(
            ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) {

        //æ‹¿åˆ°å·¥ç¨‹é‡Œé¢æ‰€æœ‰å®ç°äº†BeanPostProcessoræ¥å£çš„ç±»ï¼Œè·å–åˆ°BeanDefinitionçš„åç§°
        String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);

        // Register BeanPostProcessorChecker that logs an info message when
        // a bean is created during BeanPostProcessor instantiation, i.e. when
        // a bean is not eligible for getting processed by all BeanPostProcessors.
        int beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length;
        beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));

        // Separate between BeanPostProcessors that implement PriorityOrdered,
        // Ordered, and the rest.
        List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;&gt;();
        List&lt;BeanPostProcessor&gt; internalPostProcessors = new ArrayList&lt;&gt;();
        List&lt;String&gt; orderedPostProcessorNames = new ArrayList&lt;&gt;();
        List&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList&lt;&gt;();

        //æå‰å®ä¾‹åŒ–BeanPostProcessorç±»å‹çš„beanï¼Œç„¶åbeanè¿›è¡Œæ’åº
        for (String ppName : postProcessorNames) {
            if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {

                //getBeanæ˜¯å®ä¾‹åŒ–æ–¹æ³•ï¼Œåé¢æˆ‘ä»¬åœ¨è®²beanå®ä¾‹åŒ–è¿‡ç¨‹æ˜¯ä¼šç€é‡è®²åˆ°
                BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
                priorityOrderedPostProcessors.add(pp);

                //åˆ¤æ–­ç±»å‹æ˜¯å¦æ˜¯MergedBeanDefinitionPostProcessorï¼Œå¦‚æœæ˜¯åˆ™ä»£ç æ˜¯å†…éƒ¨ä½¿ç”¨çš„
                if (pp instanceof MergedBeanDefinitionPostProcessor) {
                    internalPostProcessors.add(pp);
                }
            }
            else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {
                orderedPostProcessorNames.add(ppName);
            }
            else {
                nonOrderedPostProcessorNames.add(ppName);
            }
        }

        // First, register the BeanPostProcessors that implement PriorityOrdered.
        sortPostProcessors(priorityOrderedPostProcessors, beanFactory);

        //æ³¨å†Œåˆ°BeanFactoryä¸­
        registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);

        // Next, register the BeanPostProcessors that implement Ordered.
        List&lt;BeanPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;&gt;();
        for (String ppName : orderedPostProcessorNames) {
            BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
            orderedPostProcessors.add(pp);
            if (pp instanceof MergedBeanDefinitionPostProcessor) {
                internalPostProcessors.add(pp);
            }
        }
        sortPostProcessors(orderedPostProcessors, beanFactory);
        registerBeanPostProcessors(beanFactory, orderedPostProcessors);

        // Now, register all regular BeanPostProcessors.
        List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = new ArrayList&lt;&gt;();
        for (String ppName : nonOrderedPostProcessorNames) {
            BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
            nonOrderedPostProcessors.add(pp);
            if (pp instanceof MergedBeanDefinitionPostProcessor) {
                internalPostProcessors.add(pp);
            }
        }
        registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);

        // Finally, re-register all internal BeanPostProcessors.
        sortPostProcessors(internalPostProcessors, beanFactory);
        registerBeanPostProcessors(beanFactory, internalPostProcessors);

        // Re-register post-processor for detecting inner beans as ApplicationListeners,
        // moving it to the end of the processor chain (for picking up proxies etc).
        beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext));
    }</code></pre>
<h2 id="finishBeanFactoryInitialization-æ–¹æ³•"><a href="#finishBeanFactoryInitialization-æ–¹æ³•" class="headerlink" title="finishBeanFactoryInitialization()æ–¹æ³•"></a>finishBeanFactoryInitialization()æ–¹æ³•</h2><p>è¿™ä¸ªæ–¹æ³•æ˜¯springä¸­æœ€é‡è¦çš„æ–¹æ³•ï¼ŒåŒ…æ‹¬beanå®ä¾‹åŒ–è¿‡ç¨‹ã€iocã€æ³¨è§£æ”¯æŒã€BeanPostProcessorçš„æ‰§è¡Œã€Aopçš„å…¥å£ã€‚</p>
<ol>
<li><p>preInstantiateSingletons()æ˜¯ä»–çš„ä¸»è¦æ–¹æ³•ï¼Œå®Œæˆå¯¹beançš„å®ä¾‹åŒ–ã€‚è¯¥æ–¹æ³•ä¼šéå†beanDefinitionNamesï¼Œé¦–å…ˆä¼šå°†çˆ¶å­BeanDefinitionåˆå¹¶ï¼Œç„¶åå°†å…·æœ‰æŸäº›ç‰¹å¾çš„BeanDefinitioné€šè¿‡getBean()æ–¹æ³•å®ä¾‹åŒ–ã€‚</p>
<pre><code class="java">    public void preInstantiateSingletons() throws BeansException {
        if (logger.isTraceEnabled()) {
            logger.trace(&quot;Pre-instantiating singletons in &quot; + this);
        }

        // Iterate over a copy to allow for init methods which in turn register new bean definitions.
        // While this may not be part of the regular factory bootstrap, it does otherwise work fine.
        //xmlè§£ææ—¶ï¼Œè®²è¿‡ï¼ŒæŠŠæ‰€æœ‰beanNameéƒ½ç¼“å­˜åˆ°beanDefinitionNamesäº†
        List&lt;String&gt; beanNames = new ArrayList&lt;&gt;(this.beanDefinitionNames);

        // Trigger initialization of all non-lazy singleton beans...
        for (String beanName : beanNames) {
            //æŠŠçˆ¶BeanDefinitioné‡Œé¢çš„å±æ€§æ‹¿åˆ°å­BeanDefinitionä¸­
      //åœ¨è§£æxmlæ—¶çˆ¶å­æ ‡ç­¾ä¼šè¢«è§£æä¸ºä¸¤ä¸ªBeanDefinitionä½†åªä¼šå®ä¾‹åŒ–ä¸€ä¸ªå¯¹è±¡
            RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);

            //å¦‚æœä¸æ˜¯æŠ½è±¡çš„ï¼Œå•ä¾‹çš„ï¼Œéæ‡’åŠ è½½çš„å°±å®ä¾‹åŒ–
            if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) {

                //åˆ¤æ–­beanæ˜¯å¦å®ç°äº†FactoryBeanæ¥å£ï¼Œè¿™é‡Œå¯ä»¥ä¸çœ‹
                if (isFactoryBean(beanName)) {
                    Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);
                    if (bean instanceof FactoryBean) {
                        final FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;
                        boolean isEagerInit;
                        if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) {
                            isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;)
                                            ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,
                                    getAccessControlContext());
                        }
                        else {
                            isEagerInit = (factory instanceof SmartFactoryBean &amp;&amp;
                                    ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());
                        }
                        if (isEagerInit) {
                            getBean(beanName);
                        }
                    }
                }
                else {
                    //ä¸»è¦ä»è¿™é‡Œè¿›å…¥ï¼Œçœ‹çœ‹å®ä¾‹åŒ–è¿‡ç¨‹
                    getBean(beanName);
                }
            }
        }

        // Trigger post-initialization callback for all applicable beans...
        for (String beanName : beanNames) {
            Object singletonInstance = getSingleton(beanName);
            if (singletonInstance instanceof SmartInitializingSingleton) {
                final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;
                if (System.getSecurityManager() != null) {
                    AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; {
                        smartSingleton.afterSingletonsInstantiated();
                        return null;
                    }, getAccessControlContext());
                }
                else {
                    smartSingleton.afterSingletonsInstantiated();
                }
            }
        }
    }</code></pre>
</li>
<li><p>getBean()æ˜¯å®ä¾‹åŒ–çš„æ ¸å¿ƒæ–¹æ³•ï¼ŒdoGetBean()æ–¹æ³•æ˜¯getBean()æ–¹æ³•çš„ä¸»è¦æ–¹æ³•ã€‚è¯¥æ–¹æ³•é¦–å…ˆä¼šå°è¯•ä»ç¼“å­˜ä¸­è·å–å®ä¾‹ï¼Œå¦‚æœæ²¡æœ‰å†è¿›è¡Œç±»çš„å®ä¾‹åŒ–ï¼Œæ­¤æ—¶ç¼“å­˜ä¸­ä¸€èˆ¬æ˜¯æ²¡æœ‰å®ä¾‹çš„ã€‚åœ¨ç±»å®ä¾‹åŒ–ä¹‹å‰ä¼šåˆ¤æ–­ç±»ä¸Šæ˜¯å¦æœ‰@Dependonæ³¨è§£ï¼Œå¦‚æœæœ‰å°±å…ˆå®ä¾‹åŒ–@Dependonæ³¨è§£ä¸­çš„ç±»ã€‚ç±»çš„å®ä¾‹åŒ–æ˜¯é€šè¿‡getSingleton()æ–¹æ³•å®ç°çš„ã€‚getObjectForBeanInstance()æ–¹æ³•ç”¨äºå¯¹BeanFactoryæ¥å£çš„æ”¯æŒï¼Œä¹‹åä¼šè¿›è¡Œå•ç‹¬åˆ†æã€‚</p>
<pre><code class="java">protected &lt;T&gt; T doGetBean(final String name, @Nullable final Class&lt;T&gt; requiredType,
            @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException {

        final String beanName = transformedBeanName(name);
        Object bean;

        //ä»ç¼“å­˜ä¸­æ‹¿å®ä¾‹
        // Eagerly check singleton cache for manually registered singletons.
        Object sharedInstance = getSingleton(beanName);
        //å¦‚æœç¼“å­˜é‡Œé¢èƒ½æ‹¿åˆ°å®ä¾‹
        if (sharedInstance != null &amp;&amp; args == null) {
            if (logger.isTraceEnabled()) {
                if (isSingletonCurrentlyInCreation(beanName)) {
                    logger.trace(&quot;Returning eagerly cached instance of singleton bean &#39;&quot; + beanName +
                            &quot;&#39; that is not fully initialized yet - a consequence of a circular reference&quot;);
                }
                else {
                    logger.trace(&quot;Returning cached instance of singleton bean &#39;&quot; + beanName + &quot;&#39;&quot;);
                }
            }
            //æ”¹æ–¹æ³•æ˜¯FactoryBeanæ¥å£çš„è°ƒç”¨å…¥å£
            bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);
        }

        else {

            //å¦‚æœsingletonObjectsç¼“å­˜é‡Œé¢æ²¡æœ‰ï¼Œåˆ™èµ°ä¸‹æ¥
            // Fail if we&#39;re already creating this bean instance:
            // We&#39;re assumably within a circular reference.

            //å¦‚æœæ˜¯scope æ˜¯Prototypeçš„ï¼Œæ ¡éªŒæ˜¯å¦æœ‰å‡ºç°å¾ªç¯ä¾èµ–ï¼Œå¦‚æœæœ‰åˆ™ç›´æ¥æŠ¥é”™
            if (isPrototypeCurrentlyInCreation(beanName)) {
                throw new BeanCurrentlyInCreationException(beanName);
            }

            // Check if bean definition exists in this factory.
            BeanFactory parentBeanFactory = getParentBeanFactory();
            if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) {
                // Not found -&gt; check parent.
                String nameToLookup = originalBeanName(name);
                if (parentBeanFactory instanceof AbstractBeanFactory) {
                    return ((AbstractBeanFactory) parentBeanFactory).doGetBean(
                            nameToLookup, requiredType, args, typeCheckOnly);
                }
                else if (args != null) {
                    // Delegation to parent with explicit args.
                    return (T) parentBeanFactory.getBean(nameToLookup, args);
                }
                else if (requiredType != null) {
                    // No args -&gt; delegate to standard getBean method.
                    return parentBeanFactory.getBean(nameToLookup, requiredType);
                }
                else {
                    return (T) parentBeanFactory.getBean(nameToLookup);
                }
            }

            if (!typeCheckOnly) {
                markBeanAsCreated(beanName);
            }

            try {
                //çˆ¶å­BeanDefinitionåˆå¹¶
                final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
                checkMergedBeanDefinition(mbd, beanName, args);

                //è·å–ä¾èµ–å¯¹è±¡å±æ€§ï¼Œä¾èµ–å¯¹è±¡è¦å…ˆå®ä¾‹åŒ–
                // Guarantee initialization of beans that the current bean depends on.
                String[] dependsOn = mbd.getDependsOn();
                if (dependsOn != null) {
                    for (String dep : dependsOn) {
                        if (isDependent(beanName, dep)) {
                            throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                                    &quot;Circular depends-on relationship between &#39;&quot; + beanName + &quot;&#39; and &#39;&quot; + dep + &quot;&#39;&quot;);
                        }
                        registerDependentBean(dep, beanName);
                        try {
                            //å®ä¾‹åŒ–
                            getBean(dep);
                    }
                        catch (NoSuchBeanDefinitionException ex) {
                            throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                                    &quot;&#39;&quot; + beanName + &quot;&#39; depends on missing bean &#39;&quot; + dep + &quot;&#39;&quot;, ex);
                        }
                    }
                }

                //ç€é‡çœ‹ï¼Œå¤§éƒ¨åˆ†æ˜¯å•ä¾‹çš„æƒ…å†µ
                // Create bean instance.
                if (mbd.isSingleton()) {
                    sharedInstance = getSingleton(beanName, () -&gt; {
                        try {
                            return createBean(beanName, mbd, args);
                        }
                        catch (BeansException ex) {
                            // Explicitly remove instance from singleton cache: It might have been put there
                            // eagerly by the creation process, to allow for circular reference resolution.
                            // Also remove any beans that received a temporary reference to the bean.
                            destroySingleton(beanName);
                            throw ex;
                        }
                    });
                    //è¯¥æ–¹æ³•æ˜¯FactoryBeanæ¥å£çš„è°ƒç”¨å…¥å£
                    bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
                }

                else if (mbd.isPrototype()) {
                    // It&#39;s a prototype -&gt; create a new instance.
                    Object prototypeInstance = null;
                    try {
                        beforePrototypeCreation(beanName);
                        prototypeInstance = createBean(beanName, mbd, args);
                    }
                    finally {
                        afterPrototypeCreation(beanName);
                    }
                    //è¯¥æ–¹æ³•æ˜¯FactoryBeanæ¥å£çš„è°ƒç”¨å…¥å£
                    bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
                }

                else {
                    String scopeName = mbd.getScope();
                    final Scope scope = this.scopes.get(scopeName);
                    if (scope == null) {
                        throw new IllegalStateException(&quot;No Scope registered for scope name &#39;&quot; + scopeName + &quot;&#39;&quot;);
                    }
                    try {
                        Object scopedInstance = scope.get(beanName, () -&gt; {
                            beforePrototypeCreation(beanName);
                            try {
                                return createBean(beanName, mbd, args);
                            }
                            finally {
                                afterPrototypeCreation(beanName);
                            }
                        });
                        //æ”¹æ–¹æ³•æ˜¯FactoryBeanæ¥å£çš„è°ƒç”¨å…¥å£
                        bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
                    }
                    catch (IllegalStateException ex) {
                        throw new BeanCreationException(beanName,
                                &quot;Scope &#39;&quot; + scopeName + &quot;&#39; is not active for the current thread; consider &quot; +
                                &quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;,
                                ex);
                    }
                }
            }
            catch (BeansException ex) {
                cleanupAfterBeanCreationFailure(beanName);
                throw ex;
            }
        }

        // Check if required type matches the type of the actual bean instance.
        if (requiredType != null &amp;&amp; !requiredType.isInstance(bean)) {
            try {
                T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);
                if (convertedBean == null) {
                    throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
                }
                return convertedBean;
            }
            catch (TypeMismatchException ex) {
                if (logger.isTraceEnabled()) {
                    logger.trace(&quot;Failed to convert bean &#39;&quot; + name + &quot;&#39; to required type &#39;&quot; +
                            ClassUtils.getQualifiedName(requiredType) + &quot;&#39;&quot;, ex);
                }
                throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
            }
        }
        return (T) bean;
    }</code></pre>
</li>
<li><p>getSingleton()æ–¹æ³•åœ¨åˆ›å»ºå‰ä¼šå°†beanNameæ·»åŠ åˆ°singletonsCurrentlyInCreationå®¹å™¨ä¸­ï¼Œè¯¥å®¹å™¨ä¸­å­˜å‚¨ç€æ­£åœ¨å®ä¾‹åŒ–çš„beanNameï¼Œç„¶åè°ƒç”¨ä¼ å…¥çš„singletonFactoryçš„getObject()æ–¹æ³•åˆ›å»ºå®ä¾‹ï¼Œåˆ›å»ºå®Œæˆåå†ä»å®¹å™¨ä¸­åˆ é™¤ï¼Œå¹¶æ”¾å…¥ä¸€çº§ç¼“å­˜ä¸­ã€‚getObject()æ–¹æ³•ä¼šè°ƒç”¨ä¸Šå±‚ä¼ å…¥çš„æ–¹æ³•createBean()ã€‚</p>
<pre><code class="java">    public Object getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory) {
        Assert.notNull(beanName, &quot;Bean name must not be null&quot;);
        synchronized (this.singletonObjects) {
            //å¦‚æœç¼“å­˜ä¸­æœ‰ï¼Œåˆ™ç›´æ¥è¿”å›
            Object singletonObject = this.singletonObjects.get(beanName);
            if (singletonObject == null) {
                if (this.singletonsCurrentlyInDestruction) {
                    throw new BeanCreationNotAllowedException(beanName,
                            &quot;Singleton bean creation not allowed while singletons of this factory are in destruction &quot; +
                            &quot;(Do not request a bean from a BeanFactory in a destroy method implementation!)&quot;);
                }
                if (logger.isDebugEnabled()) {
                    logger.debug(&quot;Creating shared instance of singleton bean &#39;&quot; + beanName + &quot;&#39;&quot;);
                }

                //æŠŠbeanNameæ·»åŠ åˆ°singletonsCurrentlyInCreation Setå®¹å™¨ä¸­ï¼Œåœ¨è¿™ä¸ªé›†åˆé‡Œé¢çš„beanéƒ½æ˜¯æ­£åœ¨å®ä¾‹åŒ–çš„bean
                beforeSingletonCreation(beanName);
                boolean newSingleton = false;
                boolean recordSuppressedExceptions = (this.suppressedExceptions == null);
                if (recordSuppressedExceptions) {
                    this.suppressedExceptions = new LinkedHashSet&lt;&gt;();
                }
        //è°ƒç”¨ä¸Šå±‚ä¼ å…¥çš„æ–¹æ³•åˆ›å»ºå®ä¾‹
                try {
                    singletonObject = singletonFactory.getObject();
                    newSingleton = true;
                }
                catch (IllegalStateException ex) {
                    // Has the singleton object implicitly appeared in the meantime -&gt;
                    // if yes, proceed with it since the exception indicates that state.
                    singletonObject = this.singletonObjects.get(beanName);
                    if (singletonObject == null) {
                        throw ex;
                    }
                }
                catch (BeanCreationException ex) {
                    if (recordSuppressedExceptions) {
                        for (Exception suppressedException : this.suppressedExceptions) {
                            ex.addRelatedCause(suppressedException);
                        }
                    }
                    throw ex;
                }
                finally {
                    if (recordSuppressedExceptions) {
                        this.suppressedExceptions = null;
                    }
                    //beanåˆ›å»ºå®ŒæˆåsingletonsCurrentlyInCreationè¦åˆ é™¤è¯¥bean
                    afterSingletonCreation(beanName);
                }
                if (newSingleton) {
                    //åˆ›å»ºå¯¹è±¡æˆåŠŸæ—¶ï¼ŒæŠŠå¯¹è±¡ç¼“å­˜åˆ°singletonObjectsç¼“å­˜ä¸­,beanåˆ›å»ºå®Œæˆæ—¶æ”¾å…¥ä¸€çº§ç¼“å­˜
                    addSingleton(beanName, singletonObject);
                }
            }
            return singletonObject;
        }
</code></pre>
</li>
<li><p>doCreateBean()æ˜¯createBean()çš„ä¸»è¦æ–¹æ³•ã€‚æ­¤æ–¹æ³•ä¸­é¦–å…ˆä¼šé€šè¿‡createBeanInstance()æ–¹æ³•åˆ›å»ºå®ä¾‹ï¼Œç„¶åè°ƒç”¨applyMergedBeanDefinitionPostProcessors()æ–¹æ³•å®Œæˆæ³¨è§£çš„è£…é…ï¼Œæ”¶é›†ã€‚addSingletonFactory()æ–¹æ³•ç”¨äºè§£å†³å¾ªç¯ä¾èµ–çš„é—®é¢˜ï¼Œä¹‹åä¼šè¿›è¡Œåˆ†æã€‚populateBean()æ–¹æ³•ç”¨äºå®ŒæˆapplyMergedBeanDefinitionPostProcessors(æ–¹æ³•è£…é…çš„æ³¨è§£è¿›è¡Œå¤„ç†ï¼Œä¸»è¦å®ŒæˆIOCã€DIç­‰å·¥ä½œã€‚initializeBean()æ–¹æ³•ç”¨äºå®Œæˆå®ä¾‹åŒ–åçš„ä¸€äº›æ“ä½œã€‚</p>
<pre><code class="java">    protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)
            throws BeanCreationException {

        // Instantiate the bean.
        BeanWrapper instanceWrapper = null;
        if (mbd.isSingleton()) {
            instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);
        }
        if (instanceWrapper == null) {
            //åˆ›å»ºå®ä¾‹ é‡ç‚¹çœ‹ é‡è¦ç¨‹åº¦ï¼š5
            instanceWrapper = createBeanInstance(beanName, mbd, args);
        }
        final Object bean = instanceWrapper.getWrappedInstance();
        Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();
        if (beanType != NullBean.class) {
            mbd.resolvedTargetType = beanType;
        }

        // Allow post-processors to modify the merged bean definition.
        synchronized (mbd.postProcessingLock) {
            if (!mbd.postProcessed) {
                try {
                    //CommonAnnotationBeanPostProcessor  æ”¯æŒäº†@PostConstructï¼Œ@PreDestroy,@Resourceæ³¨è§£
                    //AutowiredAnnotationBeanPostProcessor æ”¯æŒ @Autowired,@Valueæ³¨è§£
                    //BeanPostProcessoræ¥å£çš„å…¸å‹è¿ç”¨ï¼Œè¿™é‡Œè¦ç†è§£è¿™ä¸ªæ¥å£
                    //å¯¹ç±»ä¸­æ³¨è§£çš„è£…é…è¿‡ç¨‹
                    //é‡è¦ç¨‹åº¦5ï¼Œå¿…é¡»çœ‹
                    applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
                }
                catch (Throwable ex) {
                    throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                            &quot;Post-processing of merged bean definition failed&quot;, ex);
                }
                mbd.postProcessed = true;
            }
        }

        // Eagerly cache singletons to be able to resolve circular references
        // even when triggered by lifecycle interfaces like BeanFactoryAware.
        //æ˜¯å¦    å•ä¾‹beanæå‰æš´éœ²
        boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp;
                isSingletonCurrentlyInCreation(beanName));
        if (earlySingletonExposure) {
            if (logger.isTraceEnabled()) {
                logger.trace(&quot;Eagerly caching bean &#39;&quot; + beanName +
                        &quot;&#39; to allow for resolving potential circular references&quot;);
            }
            //è¿™é‡Œç€é‡ç†è§£ï¼Œå¯¹ç†è§£å¾ªç¯ä¾èµ–å¸®åŠ©éå¸¸å¤§ï¼Œé‡è¦ç¨‹åº¦ 5   æ·»åŠ ä¸‰çº§ç¼“å­˜
            addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));
        }

        // Initialize the bean instance.
        Object exposedObject = bean;
        try {
            //ioc diï¼Œä¾èµ–æ³¨å…¥çš„æ ¸å¿ƒæ–¹æ³•ï¼Œè¯¥æ–¹æ³•å¿…é¡»çœ‹ï¼Œé‡è¦ç¨‹åº¦ï¼š5
            populateBean(beanName, mbd, instanceWrapper);

            //bean å®ä¾‹åŒ–+iocä¾èµ–æ³¨å…¥å®Œä»¥åçš„è°ƒç”¨ï¼Œéå¸¸é‡è¦ï¼Œé‡è¦ç¨‹åº¦ï¼š5
            exposedObject = initializeBean(beanName, exposedObject, mbd);
        }
        catch (Throwable ex) {
            if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) {
                throw (BeanCreationException) ex;
            }
            else {
                throw new BeanCreationException(
                        mbd.getResourceDescription(), beanName, &quot;Initialization of bean failed&quot;, ex);
            }
        }

        if (earlySingletonExposure) {
            Object earlySingletonReference = getSingleton(beanName, false);
            if (earlySingletonReference != null) {
                if (exposedObject == bean) {
                    exposedObject = earlySingletonReference;
                }
                else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) {
                    String[] dependentBeans = getDependentBeans(beanName);
                    Set&lt;String&gt; actualDependentBeans = new LinkedHashSet&lt;&gt;(dependentBeans.length);
                    for (String dependentBean : dependentBeans) {
                        if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {
                            actualDependentBeans.add(dependentBean);
                        }
                    }
                    if (!actualDependentBeans.isEmpty()) {
                        throw new BeanCurrentlyInCreationException(beanName,
                                &quot;Bean with name &#39;&quot; + beanName + &quot;&#39; has been injected into other beans [&quot; +
                                StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +
                                &quot;] in its raw version as part of a circular reference, but has eventually been &quot; +
                                &quot;wrapped. This means that said other beans do not use the final version of the &quot; +
                                &quot;bean. This is often the result of over-eager type matching - consider using &quot; +
                                &quot;&#39;getBeanNamesOfType&#39; with the &#39;allowEagerInit&#39; flag turned off, for example.&quot;);
                    }
                }
            }
        }

        // Register bean as disposable.
        try {
            //æ³¨å†Œbeané”€æ¯æ—¶çš„ç±»DisposableBeanAdapter
            registerDisposableBeanIfNecessary(beanName, bean, mbd);
        }
        catch (BeanDefinitionValidationException ex) {
            throw new BeanCreationException(
                    mbd.getResourceDescription(), beanName, &quot;Invalid destruction signature&quot;, ex);
        }

        return exposedObject;
    }</code></pre>
</li>
</ol>
<h3 id="createBeanInstance-æ–¹æ³•"><a href="#createBeanInstance-æ–¹æ³•" class="headerlink" title="createBeanInstance()æ–¹æ³•"></a>createBeanInstance()æ–¹æ³•</h3><ol>
<li><p>createBeanInstance()æ–¹æ³•ï¼Œé¦–å…ˆä¼šé€šè¿‡åå°„æ‹¿åˆ°Classå¯¹è±¡ï¼Œç„¶åä¼šæ£€æŸ¥æ˜¯å¦æœ‰FactoryMethodNameå±æ€§ï¼Œå¦‚æœæœ‰åˆ™è°ƒç”¨instantiateUsingFactoryMethod()æ–¹æ³•åˆ›å»ºåè¿”å›ï¼Œå¦‚æœæ²¡æœ‰ä¼šä½¿ç”¨determineConstructorsFromBeanPostProcessors()æ–¹æ³•æ‰«ææœ‰Autowiredæ³¨è§£çš„æ„é€ å‡½æ•°ï¼Œå¦‚æœæœ‰åˆ™ä½¿ç”¨autowireConstructor()æ–¹æ³•åˆ›å»ºå¯¹è±¡å¹¶è¿”å›ï¼Œæ— å‚æ„é€ ç›´æ¥ä½¿ç”¨åå°„è°ƒç”¨æ„é€ å‡½æ•°åˆ›å»ºå®ä¾‹å¹¶åŒ…è£…ä¸ºBeanWrapperImplè¿”å›ã€‚</p>
<pre><code class="java">    protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) {
        // Make sure bean class is actually resolved at this point.
        //åå°„æ‹¿åˆ°Classå¯¹è±¡
        Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);

        if (beanClass != null &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) {
            throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                    &quot;Bean class isn&#39;t public, and non-public access not allowed: &quot; + beanClass.getName());
        }

        Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();
        if (instanceSupplier != null) {
            return obtainFromSupplier(instanceSupplier, beanName);
        }

        //å¦‚æœæœ‰FactoryMethodNameå±æ€§
        if (mbd.getFactoryMethodName() != null) {
            return instantiateUsingFactoryMethod(beanName, mbd, args);
        }

        // Shortcut when re-creating the same bean...
        boolean resolved = false;
        boolean autowireNecessary = false;
        if (args == null) {
            synchronized (mbd.constructorArgumentLock) {
                if (mbd.resolvedConstructorOrFactoryMethod != null) {
                    resolved = true;
                    autowireNecessary = mbd.constructorArgumentsResolved;
                }
            }
        }
        if (resolved) {
            if (autowireNecessary) {
                return autowireConstructor(beanName, mbd, null, null);
            }
            else {
                return instantiateBean(beanName, mbd);
            }
        }

        // Candidate constructors for autowiring?
        //å¯»æ‰¾å½“å‰æ­£åœ¨å®ä¾‹åŒ–çš„beanä¸­æœ‰@Autowiredæ³¨è§£çš„æ„é€ å‡½æ•°
        Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);
        if (ctors != null || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||
                mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) {
            //å¦‚æœctorsä¸ä¸ºç©ºï¼Œå°±è¯´æ˜æ„é€ å‡½æ•°ä¸Šæœ‰@Autowiredæ³¨è§£
            return autowireConstructor(beanName, mbd, ctors, args);
        }

        // Preferred constructors for default construction?
        ctors = mbd.getPreferredConstructors();
        if (ctors != null) {
            return autowireConstructor(beanName, mbd, ctors, null);
        }

        //æ— å‚æ„é€ å‡½æ•°çš„å®ä¾‹åŒ–,å¤§éƒ¨åˆ†çš„å®ä¾‹æ˜¯é‡‡ç”¨çš„æ— å‚æ„é€ å‡½æ•°çš„æ–¹å¼å®ä¾‹åŒ–
        // No special handling: simply use no-arg constructor.
        return instantiateBean(beanName, mbd);
    }</code></pre>
</li>
<li><p>instantiateUsingFactoryMethod()æ–¹æ³•æ˜¯é€šè¿‡åå°„è°ƒç”¨ç±»ä¸­çš„factoryMethodæ–¹æ³•åˆ›å»ºå¯¹è±¡ï¼Œç„¶åå°†å¯¹è±¡åŒ…è£…ä¸ºBeanWrapperImplå¯¹è±¡ã€‚BeanWrapperImplå¯¹è±¡ä¸­åŒ…å«å¯¹å®ä¾‹çš„å¼•ç”¨ï¼Œä»¥åŠä¸€äº›ç¼–è¾‘å™¨å’Œç±»å‹è½¬æ¢å™¨ï¼Œè¿™ä¸ªå¯¹è±¡ä¸éœ€è¦æ·±ç©¶ï¼Œäº†è§£å³å¯ã€‚@Beanæ³¨è§£å…¶å®å°±æ˜¯æŠŠæ–¹æ³•åç§°è®¾ç½®åˆ°BeanDefinitionçš„factoryMethodå±æ€§ä¸­ã€‚è¯¥æ–¹æ³•é‡Œé¢çš„å‚æ•°è§£æè¿‡ç¨‹ä¸éœ€è¦äº†è§£ã€‚</p>
<pre><code class="java">    public BeanWrapper instantiateUsingFactoryMethod(
            String beanName, RootBeanDefinition mbd, @Nullable Object[] explicitArgs) {

        BeanWrapperImpl bw = new BeanWrapperImpl();
        this.beanFactory.initBeanWrapper(bw);

        Object factoryBean;
        Class&lt;?&gt; factoryClass;
        boolean isStatic;

        String factoryBeanName = mbd.getFactoryBeanName();
        if (factoryBeanName != null) {
            if (factoryBeanName.equals(beanName)) {
                throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,
                        &quot;factory-bean reference points back to the same bean definition&quot;);
            }
            factoryBean = this.beanFactory.getBean(factoryBeanName);
            if (mbd.isSingleton() &amp;&amp; this.beanFactory.containsSingleton(beanName)) {
                throw new ImplicitlyAppearedSingletonException();
            }
            factoryClass = factoryBean.getClass();
            isStatic = false;
        }
        else {
            // It&#39;s a static factory method on the bean class.
            if (!mbd.hasBeanClass()) {
                throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,
                        &quot;bean definition declares neither a bean class nor a factory-bean reference&quot;);
            }
            factoryBean = null;
            factoryClass = mbd.getBeanClass();
            isStatic = true;
        }

        Method factoryMethodToUse = null;
        ArgumentsHolder argsHolderToUse = null;
        Object[] argsToUse = null;

        if (explicitArgs != null) {
            argsToUse = explicitArgs;
        }
        else {
            Object[] argsToResolve = null;
            synchronized (mbd.constructorArgumentLock) {
                factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;
                if (factoryMethodToUse != null &amp;&amp; mbd.constructorArgumentsResolved) {
                    // Found a cached factory method...
                    argsToUse = mbd.resolvedConstructorArguments;
                    if (argsToUse == null) {
                        argsToResolve = mbd.preparedConstructorArguments;
                    }
                }
            }
            if (argsToResolve != null) {
                argsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve, true);
            }
        }

        if (factoryMethodToUse == null || argsToUse == null) {
            // Need to determine the factory method...
            // Try all methods with this name to see if they match the given arguments.
            factoryClass = ClassUtils.getUserClass(factoryClass);

            Method[] rawCandidates = getCandidateMethods(factoryClass, mbd);
            List&lt;Method&gt; candidateList = new ArrayList&lt;&gt;();
            for (Method candidate : rawCandidates) {
                if (Modifier.isStatic(candidate.getModifiers()) == isStatic &amp;&amp; mbd.isFactoryMethod(candidate)) {
                    candidateList.add(candidate);
                }
            }

            if (candidateList.size() == 1 &amp;&amp; explicitArgs == null &amp;&amp; !mbd.hasConstructorArgumentValues()) {
                Method uniqueCandidate = candidateList.get(0);
                if (uniqueCandidate.getParameterCount() == 0) {
                    mbd.factoryMethodToIntrospect = uniqueCandidate;
                    synchronized (mbd.constructorArgumentLock) {
                        mbd.resolvedConstructorOrFactoryMethod = uniqueCandidate;
                        mbd.constructorArgumentsResolved = true;
                        mbd.resolvedConstructorArguments = EMPTY_ARGS;
                    }
                    bw.setBeanInstance(instantiate(beanName, mbd, factoryBean, uniqueCandidate, EMPTY_ARGS));
                    return bw;
                }
            }

            Method[] candidates = candidateList.toArray(new Method[0]);
            AutowireUtils.sortFactoryMethods(candidates);

            ConstructorArgumentValues resolvedValues = null;
            boolean autowiring = (mbd.getResolvedAutowireMode() == AutowireCapableBeanFactory.AUTOWIRE_CONSTRUCTOR);
            int minTypeDiffWeight = Integer.MAX_VALUE;
            Set&lt;Method&gt; ambiguousFactoryMethods = null;

            int minNrOfArgs;
            if (explicitArgs != null) {
                minNrOfArgs = explicitArgs.length;
            }
            else {
                // We don&#39;t have arguments passed in programmatically, so we need to resolve the
                // arguments specified in the constructor arguments held in the bean definition.
                if (mbd.hasConstructorArgumentValues()) {
                    ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();
                    resolvedValues = new ConstructorArgumentValues();
                    minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);
                }
                else {
                    minNrOfArgs = 0;
                }
            }

            LinkedList&lt;UnsatisfiedDependencyException&gt; causes = null;

            for (Method candidate : candidates) {
                Class&lt;?&gt;[] paramTypes = candidate.getParameterTypes();

                if (paramTypes.length &gt;= minNrOfArgs) {
                    ArgumentsHolder argsHolder;

                    if (explicitArgs != null) {
                        // Explicit arguments given -&gt; arguments length must match exactly.
                        if (paramTypes.length != explicitArgs.length) {
                            continue;
                        }
                        argsHolder = new ArgumentsHolder(explicitArgs);
                    }
                    else {
                        // Resolved constructor arguments: type conversion and/or autowiring necessary.
                        try {
                            String[] paramNames = null;
                            ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();
                            if (pnd != null) {
                                paramNames = pnd.getParameterNames(candidate);
                            }
                            argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw,
                                    paramTypes, paramNames, candidate, autowiring, candidates.length == 1);
                        }
                        catch (UnsatisfiedDependencyException ex) {
                            if (logger.isTraceEnabled()) {
                                logger.trace(&quot;Ignoring factory method [&quot; + candidate + &quot;] of bean &#39;&quot; + beanName + &quot;&#39;: &quot; + ex);
                            }
                            // Swallow and try next overloaded factory method.
                            if (causes == null) {
                                causes = new LinkedList&lt;&gt;();
                            }
                            causes.add(ex);
                            continue;
                        }
                    }

                    int typeDiffWeight = (mbd.isLenientConstructorResolution() ?
                            argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));
                    // Choose this factory method if it represents the closest match.
                    if (typeDiffWeight &lt; minTypeDiffWeight) {
                        factoryMethodToUse = candidate;
                        argsHolderToUse = argsHolder;
                        argsToUse = argsHolder.arguments;
                        minTypeDiffWeight = typeDiffWeight;
                        ambiguousFactoryMethods = null;
                    }
                    // Find out about ambiguity: In case of the same type difference weight
                    // for methods with the same number of parameters, collect such candidates
                    // and eventually raise an ambiguity exception.
                    // However, only perform that check in non-lenient constructor resolution mode,
                    // and explicitly ignore overridden methods (with the same parameter signature).
                    else if (factoryMethodToUse != null &amp;&amp; typeDiffWeight == minTypeDiffWeight &amp;&amp;
                            !mbd.isLenientConstructorResolution() &amp;&amp;
                            paramTypes.length == factoryMethodToUse.getParameterCount() &amp;&amp;
                            !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {
                        if (ambiguousFactoryMethods == null) {
                            ambiguousFactoryMethods = new LinkedHashSet&lt;&gt;();
                            ambiguousFactoryMethods.add(factoryMethodToUse);
                        }
                        ambiguousFactoryMethods.add(candidate);
                    }
                }
            }

            if (factoryMethodToUse == null) {
                if (causes != null) {
                    UnsatisfiedDependencyException ex = causes.removeLast();
                    for (Exception cause : causes) {
                        this.beanFactory.onSuppressedException(cause);
                    }
                    throw ex;
                }
                List&lt;String&gt; argTypes = new ArrayList&lt;&gt;(minNrOfArgs);
                if (explicitArgs != null) {
                    for (Object arg : explicitArgs) {
                        argTypes.add(arg != null ? arg.getClass().getSimpleName() : &quot;null&quot;);
                    }
                }
                else if (resolvedValues != null) {
                    Set&lt;ValueHolder&gt; valueHolders = new LinkedHashSet&lt;&gt;(resolvedValues.getArgumentCount());
                    valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());
                    valueHolders.addAll(resolvedValues.getGenericArgumentValues());
                    for (ValueHolder value : valueHolders) {
                        String argType = (value.getType() != null ? ClassUtils.getShortName(value.getType()) :
                                (value.getValue() != null ? value.getValue().getClass().getSimpleName() : &quot;null&quot;));
                        argTypes.add(argType);
                    }
                }
                String argDesc = StringUtils.collectionToCommaDelimitedString(argTypes);
                throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                        &quot;No matching factory method found: &quot; +
                        (mbd.getFactoryBeanName() != null ?
                            &quot;factory bean &#39;&quot; + mbd.getFactoryBeanName() + &quot;&#39;; &quot; : &quot;&quot;) +
                        &quot;factory method &#39;&quot; + mbd.getFactoryMethodName() + &quot;(&quot; + argDesc + &quot;)&#39;. &quot; +
                        &quot;Check that a method with the specified name &quot; +
                        (minNrOfArgs &gt; 0 ? &quot;and arguments &quot; : &quot;&quot;) +
                        &quot;exists and that it is &quot; +
                        (isStatic ? &quot;static&quot; : &quot;non-static&quot;) + &quot;.&quot;);
            }
            else if (void.class == factoryMethodToUse.getReturnType()) {
                throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                        &quot;Invalid factory method &#39;&quot; + mbd.getFactoryMethodName() +
                        &quot;&#39;: needs to have a non-void return type!&quot;);
            }
            else if (ambiguousFactoryMethods != null) {
                throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                        &quot;Ambiguous factory method matches found in bean &#39;&quot; + beanName + &quot;&#39; &quot; +
                        &quot;(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): &quot; +
                        ambiguousFactoryMethods);
            }

            if (explicitArgs == null &amp;&amp; argsHolderToUse != null) {
                mbd.factoryMethodToIntrospect = factoryMethodToUse;
                argsHolderToUse.storeCache(mbd, factoryMethodToUse);
            }
        }

        Assert.state(argsToUse != null, &quot;Unresolved factory method arguments&quot;);
        bw.setBeanInstance(instantiate(beanName, mbd, factoryBean, factoryMethodToUse, argsToUse));
        return bw;
    }</code></pre>
</li>
<li><p>determineConstructorsFromBeanPostProcessors()é¦–å…ˆä¼šè·å–æ‰€æœ‰çš„BeanPostProcessorï¼Œç„¶åè°ƒç”¨determineCandidateConstructors()æ–¹æ³•è·å–å¸¦@Autowiredæ³¨è§£çš„æ„é€ å‡½æ•°ã€‚è¯¥æ–¹æ³•æ˜¯BeanPostProcessoræ¥å£ç±»çš„é¦–æ¬¡åº”ç”¨ï¼Œæœ€ç»ˆä¼šæ‰åˆ°AutowiredAnnotationBeanPostProcessorç±»çš„æ–¹æ³•ï¼Œåœ¨æ–¹æ³•ä¸­ä¼šæ‰«ææœ‰æ³¨è§£çš„æ„é€ å‡½æ•°å¹¶è¿”å›ã€‚</p>
<pre><code class="java">    protected Constructor&lt;?&gt;[] determineConstructorsFromBeanPostProcessors(@Nullable Class&lt;?&gt; beanClass, String beanName)
            throws BeansException {

        if (beanClass != null &amp;&amp; hasInstantiationAwareBeanPostProcessors()) {
            //è·å–æ‰€æœ‰çš„BeanPostProcessors
            for (BeanPostProcessor bp : getBeanPostProcessors()) {
                if (bp instanceof SmartInstantiationAwareBeanPostProcessor) {
                    SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;
                    //æ‰¾åˆ°åˆé€‚çš„æ„é€ å‡½æ•°
                    Constructor&lt;?&gt;[] ctors = ibp.determineCandidateConstructors(beanClass, beanName);
                    if (ctors != null) {
                        return ctors;
                    }
                }
            }
        }
        return null;
    }</code></pre>
</li>
<li><p>AutowiredAnnotationBeanPostProcessorä¸­çš„determineCandidateConstructors()æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ä¼šè¿”å›æœ‰@Autowiredæ³¨è§£çš„æ„é€ å‡½æ•°ã€‚è¯¥æ–¹æ³•é¦–å…ˆä¼šæ‰«ææ‰€æœ‰æ–¹æ³•ï¼Œå¤„ç†æœ‰@Lookupæ³¨è§£çš„æ–¹æ³•ï¼Œç„¶åæ‹¿åˆ°æ‰€æœ‰çš„æ„é€ å‡½æ•°å¹¶ä½¿ç”¨findAutowiredAnnotation()æ–¹æ³•å¯¹@Autowiredè·Ÿ@Valueæ³¨è§£è¿›è¡Œæ‰«æï¼Œè¿”å›æœ‰@Autowiredçš„æ„é€ å‡½æ•°ã€‚</p>
<pre><code class="java">    public Constructor&lt;?&gt;[] determineCandidateConstructors(Class&lt;?&gt; beanClass, final String beanName)
            throws BeanCreationException {

        // Let&#39;s check for lookup methods here..
        if (!this.lookupMethodsChecked.contains(beanName)) {
            try {
                //æ‹¿åˆ°æ‰€æœ‰æ–¹æ³•ï¼Œå¾ªç¯å›è°ƒlambdaä¸­çš„å†…å®¹
                ReflectionUtils.doWithMethods(beanClass, method -&gt; {
                    //å¯¹æ³¨è§£@Lookupçš„æ”¯æŒï¼Œè¯¥æ³¨è§£ç”¨äºæ›¿ä»£æ–¹æ³•è¿”å›å€¼
                    Lookup lookup = method.getAnnotation(Lookup.class);
                    if (lookup != null) {
                        Assert.state(this.beanFactory != null, &quot;No BeanFactory available&quot;);
                        LookupOverride override = new LookupOverride(method, lookup.value());
                        try {
                            RootBeanDefinition mbd = (RootBeanDefinition) this.beanFactory.getMergedBeanDefinition(beanName);
                            mbd.getMethodOverrides().addOverride(override);
                        }
                        catch (NoSuchBeanDefinitionException ex) {
                            throw new BeanCreationException(beanName,
                                    &quot;Cannot apply @Lookup to beans without corresponding bean definition&quot;);
                        }
                    }
                });
            }
            catch (IllegalStateException ex) {
                throw new BeanCreationException(beanName, &quot;Lookup method resolution failed&quot;, ex);
            }
            this.lookupMethodsChecked.add(beanName);
        }

        // Quick check on the concurrent map first, with minimal locking.
        Constructor&lt;?&gt;[] candidateConstructors = this.candidateConstructorsCache.get(beanClass);
        if (candidateConstructors == null) {
            // Fully synchronized resolution now...
            synchronized (this.candidateConstructorsCache) {
                candidateConstructors = this.candidateConstructorsCache.get(beanClass);
                if (candidateConstructors == null) {
                    Constructor&lt;?&gt;[] rawCandidates;
                    try {
                        //è·å–beanå¯¹åº”çš„æ‰€æœ‰æ„é€ å™¨
                        rawCandidates = beanClass.getDeclaredConstructors();
                    }
                    catch (Throwable ex) {
                        throw new BeanCreationException(beanName,
                                &quot;Resolution of declared constructors on bean Class [&quot; + beanClass.getName() +
                                &quot;] from ClassLoader [&quot; + beanClass.getClassLoader() + &quot;] failed&quot;, ex);
                    }
                    List&lt;Constructor&lt;?&gt;&gt; candidates = new ArrayList&lt;&gt;(rawCandidates.length);
                    Constructor&lt;?&gt; requiredConstructor = null;
                    Constructor&lt;?&gt; defaultConstructor = null;
                    Constructor&lt;?&gt; primaryConstructor = BeanUtils.findPrimaryConstructor(beanClass);
                    int nonSyntheticConstructors = 0;
                    for (Constructor&lt;?&gt; candidate : rawCandidates) {
                        if (!candidate.isSynthetic()) {
                            nonSyntheticConstructors++;
                        }
                        else if (primaryConstructor != null) {
                            continue;
                        }
                        //è·å–åˆ°æ„é€ å‡½æ•°ä¸Šçš„@Autowiredæ³¨è§£ä¿¡æ¯,è¿™ä¸ªæ–¹æ³•å¯ä»¥ä¸çœ‹
                        AnnotationAttributes ann = findAutowiredAnnotation(candidate);
                        if (ann == null) {
                            Class&lt;?&gt; userClass = ClassUtils.getUserClass(beanClass);
                            if (userClass != beanClass) {
                                try {
                                    Constructor&lt;?&gt; superCtor =
                                            userClass.getDeclaredConstructor(candidate.getParameterTypes());

                                    ann = findAutowiredAnnotation(superCtor);
                                }
                                catch (NoSuchMethodException ex) {
                                    // Simply proceed, no equivalent superclass constructor found...
                                }
                            }
                        }
                        if (ann != null) {
                            if (requiredConstructor != null) {
                                throw new BeanCreationException(beanName,
                                        &quot;Invalid autowire-marked constructor: &quot; + candidate +
                                        &quot;. Found constructor with &#39;required&#39; Autowired annotation already: &quot; +
                                        requiredConstructor);
                            }
                            //è·å–åˆ°@Autowiredé‡Œé¢çš„requiredæ–¹æ³•çš„å€¼
                            boolean required = determineRequiredStatus(ann);
                            if (required) {
                                if (!candidates.isEmpty()) {
                                    throw new BeanCreationException(beanName,
                                            &quot;Invalid autowire-marked constructors: &quot; + candidates +
                                            &quot;. Found constructor with &#39;required&#39; Autowired annotation: &quot; +
                                            candidate);
                                }
                                requiredConstructor = candidate;
                            }
                            candidates.add(candidate);
                        }
                        else if (candidate.getParameterCount() == 0) {
                            defaultConstructor = candidate;
                        }
                    }
                    if (!candidates.isEmpty()) {
                        // Add default constructor to list of optional constructors, as fallback.
                        if (requiredConstructor == null) {
                            if (defaultConstructor != null) {
                                candidates.add(defaultConstructor);
                            }
                            else if (candidates.size() == 1 &amp;&amp; logger.isInfoEnabled()) {
                                logger.info(&quot;Inconsistent constructor declaration on bean with name &#39;&quot; + beanName +
                                        &quot;&#39;: single autowire-marked constructor flagged as optional - &quot; +
                                        &quot;this constructor is effectively required since there is no &quot; +
                                        &quot;default constructor to fall back to: &quot; + candidates.get(0));
                            }
                        }
                        candidateConstructors = candidates.toArray(new Constructor&lt;?&gt;[0]);
                    }
                    else if (rawCandidates.length == 1 &amp;&amp; rawCandidates[0].getParameterCount() &gt; 0) {
                        candidateConstructors = new Constructor&lt;?&gt;[] {rawCandidates[0]};
                    }
                    else if (nonSyntheticConstructors == 2 &amp;&amp; primaryConstructor != null &amp;&amp;
                            defaultConstructor != null &amp;&amp; !primaryConstructor.equals(defaultConstructor)) {
                        candidateConstructors = new Constructor&lt;?&gt;[] {primaryConstructor, defaultConstructor};
                    }
                    else if (nonSyntheticConstructors == 1 &amp;&amp; primaryConstructor != null) {
                        candidateConstructors = new Constructor&lt;?&gt;[] {primaryConstructor};
                    }
                    else {
                        candidateConstructors = new Constructor&lt;?&gt;[0];
                    }
                    this.candidateConstructorsCache.put(beanClass, candidateConstructors);
                }
            }
        }
        return (candidateConstructors.length &gt; 0 ? candidateConstructors : null);
    }</code></pre>
</li>
<li><p>autowireConstructor()æ–¹æ³•ä¸­ä¼šè·å–@Autowiredçš„å‚æ•°ï¼Œè¿‡ç¨‹ä¸­ä¼šè§¦å‘getBean()æ–¹æ³•ï¼Œæ­¤æ—¶çš„getBean()æ–¹æ³•å¯èƒ½æ˜¯ä»ç¼“å­˜ä¸­è·å–ã€‚è·å–åˆ°å‚æ•°åä½¿ç”¨åå°„åˆ›å»ºå®ä¾‹å¹¶åŒ…è£…ä¸ºBeanWrapperImplåè¿”å›ã€‚</p>
<pre><code class="java">public BeanWrapper autowireConstructor(String beanName, RootBeanDefinition mbd,
            @Nullable Constructor&lt;?&gt;[] chosenCtors, @Nullable Object[] explicitArgs) {

        BeanWrapperImpl bw = new BeanWrapperImpl();
        //å¿½ç•¥å¯ä»¥ä¸çœ‹ï¼Œè®¾ç½®ç±»å‹è½¬æ¢å™¨ï¼Œæ³¨å†Œè‡ªå®šä¹‰ç¼–è¾‘å™¨
        this.beanFactory.initBeanWrapper(bw);

        Constructor&lt;?&gt; constructorToUse = null;
        ArgumentsHolder argsHolderToUse = null;
        Object[] argsToUse = null;

        if (explicitArgs != null) {
            argsToUse = explicitArgs;
        }
        else {
            Object[] argsToResolve = null;
            synchronized (mbd.constructorArgumentLock) {
                constructorToUse = (Constructor&lt;?&gt;) mbd.resolvedConstructorOrFactoryMethod;
                if (constructorToUse != null &amp;&amp; mbd.constructorArgumentsResolved) {
                    // Found a cached constructor...
                    argsToUse = mbd.resolvedConstructorArguments;
                    if (argsToUse == null) {
                        argsToResolve = mbd.preparedConstructorArguments;
                    }
                }
            }
            if (argsToResolve != null) {
                argsToUse = resolvePreparedArguments(beanName, mbd, bw, constructorToUse, argsToResolve, true);
            }
        }

        if (constructorToUse == null || argsToUse == null) {
            // Take specified constructors, if any.
            Constructor&lt;?&gt;[] candidates = chosenCtors;
            if (candidates == null) {
                Class&lt;?&gt; beanClass = mbd.getBeanClass();
                try {
                    candidates = (mbd.isNonPublicAccessAllowed() ?
                            beanClass.getDeclaredConstructors() : beanClass.getConstructors());
                }
                catch (Throwable ex) {
                    throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                            &quot;Resolution of declared constructors on bean Class [&quot; + beanClass.getName() +
                            &quot;] from ClassLoader [&quot; + beanClass.getClassLoader() + &quot;] failed&quot;, ex);
                }
            }

            //mbd.hasConstructorArgumentValues()è¿™ä¸ªæ˜¯falseçš„ï¼Œå› ä¸ºæ˜¯@Autowiredçš„æ„é€ å‡½æ•°ï¼Œä¸æ˜¯&lt;constructor-arg&gt;æ ‡ç­¾
            if (candidates.length == 1 &amp;&amp; explicitArgs == null &amp;&amp; !mbd.hasConstructorArgumentValues()) {
                Constructor&lt;?&gt; uniqueCandidate = candidates[0];
                //å¦‚æœæ˜¯æ— å‚æ„é€ å‡½æ•°
                if (uniqueCandidate.getParameterCount() == 0) {
                    synchronized (mbd.constructorArgumentLock) {
                        mbd.resolvedConstructorOrFactoryMethod = uniqueCandidate;
                        mbd.constructorArgumentsResolved = true;
                        mbd.resolvedConstructorArguments = EMPTY_ARGS;
                    }
                    bw.setBeanInstance(instantiate(beanName, mbd, uniqueCandidate, EMPTY_ARGS));
                    return bw;
                }
            }

            // Need to resolve the constructor.
            boolean autowiring = (chosenCtors != null ||
                    mbd.getResolvedAutowireMode() == AutowireCapableBeanFactory.AUTOWIRE_CONSTRUCTOR);
            ConstructorArgumentValues resolvedValues = null;

            int minNrOfArgs;
            if (explicitArgs != null) {
                minNrOfArgs = explicitArgs.length;
            }
            else {
                ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();
                resolvedValues = new ConstructorArgumentValues();
                minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);
            }

            AutowireUtils.sortConstructors(candidates);
            int minTypeDiffWeight = Integer.MAX_VALUE;
            Set&lt;Constructor&lt;?&gt;&gt; ambiguousConstructors = null;
            LinkedList&lt;UnsatisfiedDependencyException&gt; causes = null;

            for (Constructor&lt;?&gt; candidate : candidates) {
                //è·å–åˆ°æ„é€ å‡½æ•°çš„å‚æ•°ç±»å‹
                Class&lt;?&gt;[] paramTypes = candidate.getParameterTypes();

                if (constructorToUse != null &amp;&amp; argsToUse != null &amp;&amp; argsToUse.length &gt; paramTypes.length) {
                    // Already found greedy constructor that can be satisfied -&gt;
                    // do not look any further, there are only less greedy constructors left.
                    break;
                }
                if (paramTypes.length &lt; minNrOfArgs) {
                    continue;
                }

                ArgumentsHolder argsHolder;
                if (resolvedValues != null) {
                    try {
                        String[] paramNames = ConstructorPropertiesChecker.evaluate(candidate, paramTypes.length);
                        if (paramNames == null) {
                            ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();
                            if (pnd != null) {
                                //è·å–æ„é€ å‡½æ•°ä¸­å‚æ•°çš„åç§°
                                paramNames = pnd.getParameterNames(candidate);
                            }
                        }
                        //è·å–åˆ°å‚æ•°çš„å€¼ï¼Œå»ºè®®ä¸è¦çœ‹ï¼Œæ¯”è¾ƒæ·±ï¼Œä¸»æµç¨‹å¼„æ‡‚åå†å»ç»†ç»†æ‰“ç£¨
                        argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames,
                                getUserDeclaredConstructor(candidate), autowiring, candidates.length == 1);
                    }
                    catch (UnsatisfiedDependencyException ex) {
                        if (logger.isTraceEnabled()) {
                            logger.trace(&quot;Ignoring constructor [&quot; + candidate + &quot;] of bean &#39;&quot; + beanName + &quot;&#39;: &quot; + ex);
                        }
                        // Swallow and try next constructor.
                        if (causes == null) {
                            causes = new LinkedList&lt;&gt;();
                        }
                        causes.add(ex);
                        continue;
                    }
                }
                else {
                    // Explicit arguments given -&gt; arguments length must match exactly.
                    if (paramTypes.length != explicitArgs.length) {
                        continue;
                    }
                    argsHolder = new ArgumentsHolder(explicitArgs);
                }

                int typeDiffWeight = (mbd.isLenientConstructorResolution() ?
                        argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));
                // Choose this constructor if it represents the closest match.
                if (typeDiffWeight &lt; minTypeDiffWeight) {
                    constructorToUse = candidate;
                    argsHolderToUse = argsHolder;
                    argsToUse = argsHolder.arguments;
                    minTypeDiffWeight = typeDiffWeight;
                    ambiguousConstructors = null;
                }
                else if (constructorToUse != null &amp;&amp; typeDiffWeight == minTypeDiffWeight) {
                    if (ambiguousConstructors == null) {
                        ambiguousConstructors = new LinkedHashSet&lt;&gt;();
                        ambiguousConstructors.add(constructorToUse);
                    }
                    ambiguousConstructors.add(candidate);
                }
            }

            if (constructorToUse == null) {
                if (causes != null) {
                    UnsatisfiedDependencyException ex = causes.removeLast();
                    for (Exception cause : causes) {
                        this.beanFactory.onSuppressedException(cause);
                    }
                    throw ex;
                }
                throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                        &quot;Could not resolve matching constructor &quot; +
                        &quot;(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities)&quot;);
            }
            else if (ambiguousConstructors != null &amp;&amp; !mbd.isLenientConstructorResolution()) {
                throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                        &quot;Ambiguous constructor matches found in bean &#39;&quot; + beanName + &quot;&#39; &quot; +
                        &quot;(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): &quot; +
                        ambiguousConstructors);
            }

            if (explicitArgs == null &amp;&amp; argsHolderToUse != null) {
                argsHolderToUse.storeCache(mbd, constructorToUse);
            }
        }

        Assert.state(argsToUse != null, &quot;Unresolved constructor arguments&quot;);

        //æœ‰å‚æ„é€ å‡½æ•°çš„å®ä¾‹åŒ–ï¼Œåå°„å®ä¾‹åŒ–
        bw.setBeanInstance(instantiate(beanName, mbd, constructorToUse, argsToUse));
        return bw;
    }</code></pre>
</li>
</ol>
<h3 id="applyMergedBeanDefinitionPostProcessors-æ–¹æ³•"><a href="#applyMergedBeanDefinitionPostProcessors-æ–¹æ³•" class="headerlink" title="applyMergedBeanDefinitionPostProcessors()æ–¹æ³•"></a>applyMergedBeanDefinitionPostProcessors()æ–¹æ³•</h3><ol>
<li><p>applyMergedBeanDefinitionPostProcessors()æ–¹æ³•ä¼šæ‹¿åˆ°æ‰€æœ‰çš„BeanPostProcessoræ¥å£ï¼Œç„¶åè°ƒç”¨MergedBeanDefinitionPostProcessoræ¥å£çš„postProcessMergedBeanDefinition()æ–¹æ³•å®Œæˆæ³¨è§£çš„æ”¶é›†ã€‚</p>
<pre><code class="java">    protected void applyMergedBeanDefinitionPostProcessors(RootBeanDefinition mbd, Class&lt;?&gt; beanType, String beanName) {
        for (BeanPostProcessor bp : getBeanPostProcessors()) {
            if (bp instanceof MergedBeanDefinitionPostProcessor) {
                MergedBeanDefinitionPostProcessor bdp = (MergedBeanDefinitionPostProcessor) bp;
                bdp.postProcessMergedBeanDefinition(mbd, beanType, beanName);
            }
        }
    }</code></pre>
</li>
<li><p>CommonAnnotationBeanPostProcessorçš„postProcessMergedBeanDefinition()æ–¹æ³•ä¼šè°ƒç”¨InitDestroyAnnotationBeanPostProcessorçš„postProcessMergedBeanDefinition()æ–¹æ³•å®Œæˆ@postConstructè·Ÿ@PreDestory()æ³¨è§£çš„æ‰«æï¼Œç„¶åè°ƒç”¨findResourceMetadata()æ‰«æ@Resourceæ³¨è§£ã€‚</p>
<pre><code>    public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName) {
        //æ‰«æ@PostConstruct @PreDestroy
        super.postProcessMergedBeanDefinition(beanDefinition, beanType, beanName);
        //æ‰«æ@Resource,æ‰«æå±æ€§å’Œæ–¹æ³•ä¸Šé¢æ˜¯å¦æœ‰@Resourceæ³¨è§£ï¼Œå¦‚æœæœ‰åˆ™æ”¶é›†èµ·æ¥å°è£…æˆå¯¹è±¡
        InjectionMetadata metadata = findResourceMetadata(beanName, beanType, null);
        metadata.checkConfigMembers(beanDefinition);
    }</code></pre></li>
<li><p>InitDestroyAnnotationBeanPostProcessorçš„postProcessMergedBeanDefinition()æ–¹æ³•ä¼šè°ƒç”¨findLifecycleMetadata()æ–¹æ³•ï¼Œç„¶åå†æ¬¡å°è£…å…¶è¿”å›çš„LifecycleMetadataå¯¹è±¡ã€‚buildLifecycleMetadata()æ˜¯findLifecycleMetadata()çš„æ ¸å¿ƒæ–¹æ³•ï¼Œä¼šå¾ªç¯åˆ¤æ–­ç±»ä¸­çš„æ‰€æœ‰æ–¹æ³•æ˜¯å¦æœ‰@postConstructè·Ÿ@PreDestory()æ³¨è§£ï¼Œå¦‚æœæœ‰å°±å°†è¿™ä¸ªæ–¹æ³•æ”¾åˆ°å®¹å™¨ä¸­ï¼Œæœ€ååŒ…è£…ä¸ºLifecycleMetadataå¹¶è¿”å›ã€‚</p>
<pre><code class="java">    private LifecycleMetadata buildLifecycleMetadata(final Class&lt;?&gt; clazz) {
        List&lt;LifecycleElement&gt; initMethods = new ArrayList&lt;&gt;();
        List&lt;LifecycleElement&gt; destroyMethods = new ArrayList&lt;&gt;();
        Class&lt;?&gt; targetClass = clazz;

        do {
            final List&lt;LifecycleElement&gt; currInitMethods = new ArrayList&lt;&gt;();
            final List&lt;LifecycleElement&gt; currDestroyMethods = new ArrayList&lt;&gt;();

            ReflectionUtils.doWithLocalMethods(targetClass, method -&gt; {
                if (this.initAnnotationType != null &amp;&amp; method.isAnnotationPresent(this.initAnnotationType)) {
                    LifecycleElement element = new LifecycleElement(method);
                    currInitMethods.add(element);
                    if (logger.isTraceEnabled()) {
                        logger.trace(&quot;Found init method on class [&quot; + clazz.getName() + &quot;]: &quot; + method);
                    }
                }
                if (this.destroyAnnotationType != null &amp;&amp; method.isAnnotationPresent(this.destroyAnnotationType)) {
                    currDestroyMethods.add(new LifecycleElement(method));
                    if (logger.isTraceEnabled()) {
                        logger.trace(&quot;Found destroy method on class [&quot; + clazz.getName() + &quot;]: &quot; + method);
                    }
                }
            });

            initMethods.addAll(0, currInitMethods);
            destroyMethods.addAll(currDestroyMethods);
            targetClass = targetClass.getSuperclass();
        }
        while (targetClass != null &amp;&amp; targetClass != Object.class);

        return new LifecycleMetadata(clazz, initMethods, destroyMethods);
    }</code></pre>
</li>
<li><p>findResourceMetadata()æ–¹æ³•ä¼šè°ƒç”¨buildResourceMetadata()æ–¹æ³•è·å–åŒ…è£…åçš„InjectionMetadataï¼Œæ”¾å…¥ç¼“å­˜åè¿”å›ã€‚</p>
<pre><code class="java">    private InjectionMetadata findResourceMetadata(String beanName, final Class&lt;?&gt; clazz, @Nullable PropertyValues pvs) {
        // Fall back to class name as cache key, for backwards compatibility with custom callers.
        String cacheKey = (StringUtils.hasLength(beanName) ? beanName : clazz.getName());
        // Quick check on the concurrent map first, with minimal locking.
        InjectionMetadata metadata = this.injectionMetadataCache.get(cacheKey);
        if (InjectionMetadata.needsRefresh(metadata, clazz)) {
            synchronized (this.injectionMetadataCache) {
                metadata = this.injectionMetadataCache.get(cacheKey);
                if (InjectionMetadata.needsRefresh(metadata, clazz)) {
                    if (metadata != null) {
                        metadata.clear(pvs);
                    }
                    //ä¸»è¦çœ‹è¿™ä¸ªæ–¹æ³•
                    metadata = buildResourceMetadata(clazz);
                    this.injectionMetadataCache.put(cacheKey, metadata);
                }
            }
        }
        return metadata;
    }</code></pre>
</li>
<li><p>buildResourceMetadata()æ–¹æ³•ä¼šå»è·å–ç±»ä¸Šçš„æ‰€æœ‰å±æ€§ï¼Œç„¶åå¾ªç¯è°ƒç”¨lambdaä¸­çš„å†…å®¹æ”¾åˆ°å®¹å™¨ä¸­ï¼Œæœ€åå°è£…ä¸ºInjectionMetadataå¯¹è±¡åè¿”å›ã€‚</p>
<pre><code class="java">    private InjectionMetadata buildResourceMetadata(final Class&lt;?&gt; clazz) {
        List&lt;InjectionMetadata.InjectedElement&gt; elements = new ArrayList&lt;&gt;();
        Class&lt;?&gt; targetClass = clazz;

        do {
            final List&lt;InjectionMetadata.InjectedElement&gt; currElements = new ArrayList&lt;&gt;();

            ReflectionUtils.doWithLocalFields(targetClass, field -&gt; {
                if (webServiceRefClass != null &amp;&amp; field.isAnnotationPresent(webServiceRefClass)) {
                    if (Modifier.isStatic(field.getModifiers())) {
                        throw new IllegalStateException(&quot;@WebServiceRef annotation is not supported on static fields&quot;);
                    }
                    currElements.add(new WebServiceRefElement(field, field, null));
                }
                else if (ejbRefClass != null &amp;&amp; field.isAnnotationPresent(ejbRefClass)) {
                    if (Modifier.isStatic(field.getModifiers())) {
                        throw new IllegalStateException(&quot;@EJB annotation is not supported on static fields&quot;);
                    }
                    currElements.add(new EjbRefElement(field, field, null));
                }
                else if (field.isAnnotationPresent(Resource.class)) {
                    if (Modifier.isStatic(field.getModifiers())) {
                        throw new IllegalStateException(&quot;@Resource annotation is not supported on static fields&quot;);
                    }
                    if (!this.ignoredResourceTypes.contains(field.getType().getName())) {
                        currElements.add(new ResourceElement(field, field, null));
                    }
                }
            });

            ReflectionUtils.doWithLocalMethods(targetClass, method -&gt; {
                Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);
                if (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) {
                    return;
                }
                if (method.equals(ClassUtils.getMostSpecificMethod(method, clazz))) {
                    if (webServiceRefClass != null &amp;&amp; bridgedMethod.isAnnotationPresent(webServiceRefClass)) {
                        if (Modifier.isStatic(method.getModifiers())) {
                            throw new IllegalStateException(&quot;@WebServiceRef annotation is not supported on static methods&quot;);
                        }
                        if (method.getParameterCount() != 1) {
                            throw new IllegalStateException(&quot;@WebServiceRef annotation requires a single-arg method: &quot; + method);
                        }
                        PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz);
                        currElements.add(new WebServiceRefElement(method, bridgedMethod, pd));
                    }
                    else if (ejbRefClass != null &amp;&amp; bridgedMethod.isAnnotationPresent(ejbRefClass)) {
                        if (Modifier.isStatic(method.getModifiers())) {
                            throw new IllegalStateException(&quot;@EJB annotation is not supported on static methods&quot;);
                        }
                        if (method.getParameterCount() != 1) {
                            throw new IllegalStateException(&quot;@EJB annotation requires a single-arg method: &quot; + method);
                        }
                        PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz);
                        currElements.add(new EjbRefElement(method, bridgedMethod, pd));
                    }
                    else if (bridgedMethod.isAnnotationPresent(Resource.class)) {
                        if (Modifier.isStatic(method.getModifiers())) {
                            throw new IllegalStateException(&quot;@Resource annotation is not supported on static methods&quot;);
                        }
                        Class&lt;?&gt;[] paramTypes = method.getParameterTypes();
                        if (paramTypes.length != 1) {
                            throw new IllegalStateException(&quot;@Resource annotation requires a single-arg method: &quot; + method);
                        }
                        if (!this.ignoredResourceTypes.contains(paramTypes[0].getName())) {
                            PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz);
                            currElements.add(new ResourceElement(method, bridgedMethod, pd));
                        }
                    }
                }
            });

            elements.addAll(0, currElements);
            targetClass = targetClass.getSuperclass();
        }
        while (targetClass != null &amp;&amp; targetClass != Object.class);

        return new InjectionMetadata(clazz, elements);
    }</code></pre>
</li>
</ol>
<p>æ³¨ï¼šå…¶ä»–ç±»å‹çš„BeanPostProcessoræ”¶é›†è¿‡ç¨‹ä¸InitDestroyAnnotationBeanPostProcessoråŸºæœ¬ç›¸åŒï¼Œåªæ˜¯æ‰«æçš„æ³¨è§£ä¸åŒï¼Œæ­¤å¤„ä¸åœ¨èµ˜è¿°ã€‚</p>
<h3 id="populateBean-æ–¹æ³•"><a href="#populateBean-æ–¹æ³•" class="headerlink" title="populateBean()æ–¹æ³•"></a>populateBean()æ–¹æ³•</h3><ol>
<li><p>ä¾èµ–æ³¨å…¥çš„æ ¸å¿ƒæ–¹æ³•ï¼Œä¸»è¦æ–¹æ³•ä¸ºpostProcessProperties()ï¼Œä¾æ®applyMergedBeanDefinitionPostProcessorsæ”¶é›†çš„æ³¨è§£è¿›è¡Œä¾èµ–æ³¨å…¥ã€‚</p>
<pre><code class="java">    protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) {
        if (bw == null) {
            if (mbd.hasPropertyValues()) {
                throw new BeanCreationException(
                        mbd.getResourceDescription(), beanName, &quot;Cannot apply property values to null instance&quot;);
            }
            else {
                // Skip property population phase for null instance.
                return;
            }
        }

        // Give any InstantiationAwareBeanPostProcessors the opportunity to modify the
        // state of the bean before properties are set. This can be used, for example,
        // to support styles of field injection.
        boolean continueWithPropertyPopulation = true;

        //è¿™é‡Œå¾ˆæœ‰æ„æ€ï¼Œå†™æ¥å£å¯ä»¥è®©æ‰€æœ‰ç±»éƒ½ä¸èƒ½ä¾èµ–æ³¨å…¥
        if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) {
            for (BeanPostProcessor bp : getBeanPostProcessors()) {
                if (bp instanceof InstantiationAwareBeanPostProcessor) {
                    InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
                    if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {

                        //æ˜¯å¦éœ€è¦DIï¼Œä¾èµ–æ³¨å…¥
                        continueWithPropertyPopulation = false;
                        break;
                    }
                }
            }
        }

        if (!continueWithPropertyPopulation) {
            return;
        }

        PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : null);

        if (mbd.getResolvedAutowireMode() == AUTOWIRE_BY_NAME || mbd.getResolvedAutowireMode() == AUTOWIRE_BY_TYPE) {
            MutablePropertyValues newPvs = new MutablePropertyValues(pvs);
            // Add property values based on autowire by name if applicable.
            if (mbd.getResolvedAutowireMode() == AUTOWIRE_BY_NAME) {
                autowireByName(beanName, mbd, bw, newPvs);
            }
            // Add property values based on autowire by type if applicable.
            if (mbd.getResolvedAutowireMode() == AUTOWIRE_BY_TYPE) {
                autowireByType(beanName, mbd, bw, newPvs);
            }
            pvs = newPvs;
        }

        boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();
        boolean needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);

        PropertyDescriptor[] filteredPds = null;

        //é‡ç‚¹çœ‹è¿™ä¸ªifä»£ç å—ï¼Œé‡è¦ç¨‹åº¦ 5
        if (hasInstAwareBpps) {
            if (pvs == null) {
                pvs = mbd.getPropertyValues();
            }
            for (BeanPostProcessor bp : getBeanPostProcessors()) {
                if (bp instanceof InstantiationAwareBeanPostProcessor) {
                    InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
                    //ä¾èµ–æ³¨å…¥è¿‡ç¨‹ï¼Œ@Autowiredçš„æ”¯æŒ
                    PropertyValues pvsToUse = ibp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);
                    if (pvsToUse == null) {
                        if (filteredPds == null) {
                            filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
                        }

                        //è€ç‰ˆæœ¬ç”¨è¿™ä¸ªå®Œæˆä¾èµ–æ³¨å…¥è¿‡ç¨‹ï¼Œ@Autowiredçš„æ”¯æŒ
                        pvsToUse = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);
                        if (pvsToUse == null) {
                            return;
                        }
                    }
                    pvs = pvsToUse;
                }
            }
        }
        if (needsDepCheck) {
            if (filteredPds == null) {
                filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
            }
            checkDependencies(beanName, mbd, filteredPds, pvs);
        }

        //è¿™ä¸ªæ–¹æ³•å¾ˆé¸¡è‚‹äº†ï¼Œå»ºè®®ä¸çœ‹ï¼Œæ˜¯è€ç‰ˆæœ¬ç”¨&lt;property name=&quot;username&quot; value=&quot;Jack&quot;/&gt;
        //æ ‡ç­¾åšä¾èµ–æ³¨å…¥çš„ä»£ç å®ç°ï¼Œå¤æ‚ä¸”æ— ç”¨
        if (pvs != null) {
            applyPropertyValues(beanName, mbd, bw, pvs);
        }
    }</code></pre>
</li>
<li><p>AutowiredAnnotationBeanPostProcessorçš„postProcessProperties()æ–¹æ³•ã€‚è¯¥æ–¹æ³•é¦–å…ˆä»ç¼“å­˜ä¸­è·å–ä¹‹å‰æ”¶é›†å¥½çš„æ‰€æœ‰InjectionMetadataå¯¹è±¡ï¼Œç„¶åè°ƒç”¨å¾ªç¯è°ƒç”¨inject()æ–¹æ³•è¿›è¡Œæ³¨å…¥ã€‚</p>
<pre><code class="java">    public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) {
    // ä»ç¼“å­˜ä¸­è·å–InjectionMetadataå¯¹è±¡
        InjectionMetadata metadata = findAutowiringMetadata(beanName, bean.getClass(), pvs);
        try {
            metadata.inject(bean, beanName, pvs);
        }
        catch (BeanCreationException ex) {
            throw ex;
        }
        catch (Throwable ex) {
            throw new BeanCreationException(beanName, &quot;Injection of autowired dependencies failed&quot;, ex);
        }
        return pvs;
    }</code></pre>
</li>
<li><p>æ­¤å¤„ä¸ºinject()æ–¹æ³•ï¼Œå…ˆä»springå®¹å™¨ä¸­æ‹¿åˆ°å‚æ•°å¯¹åº”çš„å€¼ï¼Œè¿™æ—¶å¯èƒ½ä¼šè§¦å‘å®ä¾‹åŒ–ï¼Œç„¶åé€šè¿‡åå°„å®Œæˆå¯¹è±¡çš„æ³¨å…¥ã€‚</p>
<pre><code class="java">        protected void inject(Object bean, @Nullable String beanName, @Nullable PropertyValues pvs) throws Throwable {
            Field field = (Field) this.member;
            Object value;
            if (this.cached) {
                value = resolvedCachedArgument(beanName, this.cachedFieldValue);
            }
            else {
                DependencyDescriptor desc = new DependencyDescriptor(field, this.required);
                desc.setContainingClass(bean.getClass());
                Set&lt;String&gt; autowiredBeanNames = new LinkedHashSet&lt;&gt;(1);
                Assert.state(beanFactory != null, &quot;No BeanFactory available&quot;);
                TypeConverter typeConverter = beanFactory.getTypeConverter();
                try {
                    value = beanFactory.resolveDependency(desc, beanName, autowiredBeanNames, typeConverter);
                }
                catch (BeansException ex) {
                    throw new UnsatisfiedDependencyException(null, beanName, new InjectionPoint(field), ex);
                }
                synchronized (this) {
                    if (!this.cached) {
                        if (value != null || this.required) {
                            this.cachedFieldValue = desc;
                            registerDependentBeans(beanName, autowiredBeanNames);
                            if (autowiredBeanNames.size() == 1) {
                                String autowiredBeanName = autowiredBeanNames.iterator().next();
                                if (beanFactory.containsBean(autowiredBeanName) &amp;&amp;
                                        beanFactory.isTypeMatch(autowiredBeanName, field.getType())) {
                                    this.cachedFieldValue = new ShortcutDependencyDescriptor(
                                            desc, autowiredBeanName, field.getType());
                                }
                            }
                        }
                        else {
                            this.cachedFieldValue = null;
                        }
                        this.cached = true;
                    }
                }
            }
            if (value != null) {
                ReflectionUtils.makeAccessible(field);
                field.set(bean, value);
            }
        }
    }</code></pre>
</li>
</ol>
<p>æ³¨ï¼šå…¶ä»–ç±»çš„postProcessPropertiesä¸æ­¤å¤„åŸºæœ¬ç›¸åŒã€‚</p>
<h3 id="initializeBean-æ–¹æ³•"><a href="#initializeBean-æ–¹æ³•" class="headerlink" title="initializeBean()æ–¹æ³•"></a>initializeBean()æ–¹æ³•</h3><ol>
<li><p>initializeBean()æ–¹æ³•æ˜¯BeanDefinitionå®ä¾‹åŒ–å®Œæˆåçš„æ“ä½œã€‚é¦–å…ˆä¼šä½¿ç”¨applyBeanPostProcessorsBeforeInitialization()æ–¹æ³•å¯¹@PostConstructï¼ŒAwareæ¥å£è¿›è¡Œè°ƒç”¨ï¼Œç„¶åä½¿ç”¨invokeInitMethods()æ¥å£ï¼Œå®Œæˆå¯¹InitializingBeanæ¥å£çš„afterPropertiesSet()æ–¹æ³•ã€BeanDefinationä¸­init-methodå¯¹åº”æ–¹æ³•çš„è°ƒç”¨ã€‚è¿™äº›æ³¨è§£åœ¨applyMergedBeanDefinitionPostProcessors()æ–¹æ³•ä¸­å·²ç»è¢«æ”¶é›†å¹¶å°è£…ä¸ºMetadataå¯¹è±¡ã€‚applyBeanPostProcessorsAfterInitialization()æ–¹æ³•æ˜¯aopå…¥å£ç±»ï¼Œåœ¨ä¹‹åä¼šæœ‰è¯¦ç»†åˆ†æã€‚</p>
<pre><code class="java">    protected Object initializeBean(final String beanName, final Object bean, @Nullable RootBeanDefinition mbd) {
        if (System.getSecurityManager() != null) {
            AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; {
                invokeAwareMethods(beanName, bean);
                return null;
            }, getAccessControlContext());
        }
        else {
            //è°ƒç”¨Awareæ–¹æ³•
            invokeAwareMethods(beanName, bean);
        }

        Object wrappedBean = bean;
        if (mbd == null || !mbd.isSynthetic()) {
            //å¯¹ç±»ä¸­æŸäº›ç‰¹æ®Šæ–¹æ³•çš„è°ƒç”¨ï¼Œæ¯”å¦‚@PostConstructï¼ŒAwareæ¥å£ï¼Œéå¸¸é‡è¦ é‡è¦ç¨‹åº¦ ï¼š5
            wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);
        }

        try {
            //InitializingBeanæ¥å£ï¼ŒafterPropertiesSetï¼Œinit-methodå±æ€§è°ƒç”¨,éå¸¸é‡è¦ï¼Œé‡è¦ç¨‹åº¦ï¼š5
            invokeInitMethods(beanName, wrappedBean, mbd);
        }
        catch (Throwable ex) {
            throw new BeanCreationException(
                    (mbd != null ? mbd.getResourceDescription() : null),
                    beanName, &quot;Invocation of init method failed&quot;, ex);
        }
        if (mbd == null || !mbd.isSynthetic()) {
            wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);
        }

        return wrappedBean;
    }</code></pre>
</li>
<li><p>applyBeanPostProcessorsBeforeInitialization()æ–¹æ³•</p>
<pre><code class="java">    @Override
    public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)
            throws BeansException {

        Object result = existingBean;
        /*
        * ç€é‡çœ‹å‡ ä¸ª
        * 1ã€ApplicationContextAwareProcessor  å¯¹æŸä¸ªAwareæ¥å£æ–¹æ³•çš„è°ƒç”¨
        * 2ã€InitDestroyAnnotationBeanPostProcessor  @PostConstructæ³¨è§£æ–¹æ³•çš„è°ƒç”¨
        *
        * 3ã€ImportAwareBeanPostProcessor  å¯¹ImportAwareç±»å‹å®ä¾‹setImportMetadataè°ƒç”¨
        * è¿™ä¸ªå¯¹ç†è§£springbootæœ‰å¾ˆå¤§å¸®åŠ©ã€‚ è¿™é‡Œæš‚æ—¶ä¸éœ€è¦æ·±å…¥çœ‹
        * */
        for (BeanPostProcessor processor : getBeanPostProcessors()) {
            Object current = processor.postProcessBeforeInitialization(result, beanName);
            if (current == null) {
                return result;
            }
            result = current;
        }
        return result;
    }</code></pre>
</li>
<li><p>InitDestroyAnnotationBeanPostProcessorçš„postProcessBeforeInitialization()æ–¹æ³•ä¼šé€šè¿‡åå°„è°ƒç”¨metadataä¸­çš„æ–¹æ³•ï¼Œæ­¤å¤„è¢«è°ƒç”¨çš„æ–¹æ³•ä¸èƒ½æœ‰ä»»ä½•å‚æ•°ã€‚</p>
<pre><code class="java">    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        LifecycleMetadata metadata = findLifecycleMetadata(bean.getClass());
        try {
            //è°ƒç”¨@PostConstructæ³¨è§£çš„æ–¹æ³•
            metadata.invokeInitMethods(bean, beanName);
        }
        catch (InvocationTargetException ex) {
            throw new BeanCreationException(beanName, &quot;Invocation of init method failed&quot;, ex.getTargetException());
        }
        catch (Throwable ex) {
            throw new BeanCreationException(beanName, &quot;Failed to invoke init method&quot;, ex);
        }
        return bean;
    }</code></pre>
</li>
<li><p>invokeInitMethods()æ–¹æ³•é¦–å…ˆä¼šåˆ¤æ–­beanæ˜¯å¦å®ç°äº†InitializingBeanæ¥å£ï¼Œå¦‚æœæ˜¯å°±ç›´æ¥é€šè¿‡åå°„è°ƒç”¨è¯¥æ¥å£çš„afterPropertiesSet()æ–¹æ³•ã€‚ç„¶åä¼šé€šè¿‡invokeCustomInitMethod()æ–¹æ³•è°ƒç”¨initMethod()æ–¹æ³•æ–¹æ³•ã€‚å¦‚æœè¦åœ¨Beanå®ä¾‹åŒ–ä¹‹åå»åšä¸€äº›äº‹æƒ…å¯ä»¥å®ç°InitializingBeanæ¥å£ï¼Œæ¯”å¦‚ç¼“å­˜é¢„çƒ­ï¼Œæ³¨å†Œåˆ°æ³¨å†Œä¸­å¿ƒç­‰ï¼ŒMybatisä¸­xmlçš„è§£æä¹Ÿæ˜¯ç”¨äº†è¯¥æ¥å£ã€‚</p>
<pre><code class="java">    protected void invokeInitMethods(String beanName, final Object bean, @Nullable RootBeanDefinition mbd)
            throws Throwable {

        boolean isInitializingBean = (bean instanceof InitializingBean);
        if (isInitializingBean &amp;&amp; (mbd == null || !mbd.isExternallyManagedInitMethod(&quot;afterPropertiesSet&quot;))) {
            if (logger.isTraceEnabled()) {
                logger.trace(&quot;Invoking afterPropertiesSet() on bean with name &#39;&quot; + beanName + &quot;&#39;&quot;);
            }
            if (System.getSecurityManager() != null) {
                try {
                    AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) () -&gt; {
                        ((InitializingBean) bean).afterPropertiesSet();
                        return null;
                    }, getAccessControlContext());
                }
                catch (PrivilegedActionException pae) {
                    throw pae.getException();
                }
            }
            else {
                ((InitializingBean) bean).afterPropertiesSet();
            }
        }

        if (mbd != null &amp;&amp; bean.getClass() != NullBean.class) {
            String initMethodName = mbd.getInitMethodName();
            if (StringUtils.hasLength(initMethodName) &amp;&amp;
                    !(isInitializingBean &amp;&amp; &quot;afterPropertiesSet&quot;.equals(initMethodName)) &amp;&amp;
                    !mbd.isExternallyManagedInitMethod(initMethodName)) {
                invokeCustomInitMethod(beanName, bean, mbd);
            }
        }
    }</code></pre>
</li>
</ol>
<h3 id="registerDisposableBeanIfNecessary-æ–¹æ³•"><a href="#registerDisposableBeanIfNecessary-æ–¹æ³•" class="headerlink" title="registerDisposableBeanIfNecessary()æ–¹æ³•"></a>registerDisposableBeanIfNecessary()æ–¹æ³•</h3><p>è¯¥æ–¹æ³•é¦–å…ˆä¼šå°†éœ€è¦é”€æ¯çš„BeanåŒ…è£…ä¸ºDisposableBeanAdapterå¯¹è±¡ï¼Œç„¶åé€šè¿‡registerDisposableBean()æ–¹æ³•æ”¾å…¥disposableBeanså®¹å™¨ä¸­ã€‚</p>
<pre><code class="java">    protected void registerDisposableBeanIfNecessary(String beanName, Object bean, RootBeanDefinition mbd) {
        AccessControlContext acc = (System.getSecurityManager() != null ? getAccessControlContext() : null);
        if (!mbd.isPrototype() &amp;&amp; requiresDestruction(bean, mbd)) {
            if (mbd.isSingleton()) {
                // Register a DisposableBean implementation that performs all destruction
                // work for the given bean: DestructionAwareBeanPostProcessors,
                // DisposableBean interface, custom destroy method.
                registerDisposableBean(beanName,
                        new DisposableBeanAdapter(bean, beanName, mbd, getBeanPostProcessors(), acc));
            }
            else {
                // A bean with a custom scope...
                Scope scope = this.scopes.get(mbd.getScope());
                if (scope == null) {
                    throw new IllegalStateException(&quot;No Scope registered for scope name &#39;&quot; + mbd.getScope() + &quot;&#39;&quot;);
                }
                scope.registerDestructionCallback(beanName,
                        new DisposableBeanAdapter(bean, beanName, mbd, getBeanPostProcessors(), acc));
            }
        }
    }</code></pre>
<p>DisposableBeanAdapterçš„æ„é€ æ–¹æ³•ã€‚è¯¥æ–¹æ³•é¦–å…ˆä¼šæ‹¿åˆ°ç±»çš„destory-methodå±æ€§ï¼Œç„¶åé€šè¿‡filterPostProcessors()æ–¹æ³•è·å–åˆ°DestructionAwareBeanPostProcessorç±»å‹çš„BeanPostProcessorã€‚</p>
<pre><code class="java">    public DisposableBeanAdapter(Object bean, String beanName, RootBeanDefinition beanDefinition,
            List&lt;BeanPostProcessor&gt; postProcessors, @Nullable AccessControlContext acc) {

        Assert.notNull(bean, &quot;Disposable bean must not be null&quot;);
        this.bean = bean;
        this.beanName = beanName;
        this.invokeDisposableBean =
                (this.bean instanceof DisposableBean &amp;&amp; !beanDefinition.isExternallyManagedDestroyMethod(&quot;destroy&quot;));
        this.nonPublicAccessAllowed = beanDefinition.isNonPublicAccessAllowed();
        this.acc = acc;
        String destroyMethodName = inferDestroyMethodIfNecessary(bean, beanDefinition);
        if (destroyMethodName != null &amp;&amp; !(this.invokeDisposableBean &amp;&amp; &quot;destroy&quot;.equals(destroyMethodName)) &amp;&amp;
                !beanDefinition.isExternallyManagedDestroyMethod(destroyMethodName)) {
            this.destroyMethodName = destroyMethodName;
            this.destroyMethod = determineDestroyMethod(destroyMethodName);
            if (this.destroyMethod == null) {
                if (beanDefinition.isEnforceDestroyMethod()) {
                    throw new BeanDefinitionValidationException(&quot;Could not find a destroy method named &#39;&quot; +
                            destroyMethodName + &quot;&#39; on bean with name &#39;&quot; + beanName + &quot;&#39;&quot;);
                }
            }
            else {
                Class&lt;?&gt;[] paramTypes = this.destroyMethod.getParameterTypes();
                if (paramTypes.length &gt; 1) {
                    throw new BeanDefinitionValidationException(&quot;Method &#39;&quot; + destroyMethodName + &quot;&#39; of bean &#39;&quot; +
                            beanName + &quot;&#39; has more than one parameter - not supported as destroy method&quot;);
                }
                else if (paramTypes.length == 1 &amp;&amp; boolean.class != paramTypes[0]) {
                    throw new BeanDefinitionValidationException(&quot;Method &#39;&quot; + destroyMethodName + &quot;&#39; of bean &#39;&quot; +
                            beanName + &quot;&#39; has a non-boolean parameter - not supported as destroy method&quot;);
                }
            }
        }
        this.beanPostProcessors = filterPostProcessors(postProcessors, bean);
    }</code></pre>
<p>destory()æ–¹æ³•é¦–å…ˆä¼šè°ƒç”¨BeanPostProcessoræ¥å£çš„postProcessBeforeDestruction()æ–¹æ³•ï¼Œç„¶åè°ƒç”¨DisposableBeanæ¥å£çš„distory()æ–¹æ³•ï¼Œå†é€šè¿‡åå°„è°ƒç”¨destory-methodå±æ€§è®¾ç½®çš„æ–¹æ³•ã€‚è¿™ä¸ªæ–¹æ³•ä¸€èˆ¬ç”±tomcatä¸­servletè§„èŒƒä¸­çš„ContextLoaderListener.contextDestroyed()æ–¹æ³•è§¦å‘ã€‚</p>
<pre><code class="java">    public void destroy() {
        if (!CollectionUtils.isEmpty(this.beanPostProcessors)) {
            for (DestructionAwareBeanPostProcessor processor : this.beanPostProcessors) {
                processor.postProcessBeforeDestruction(this.bean, this.beanName);
            }
        }

        if (this.invokeDisposableBean) {
            if (logger.isTraceEnabled()) {
                logger.trace(&quot;Invoking destroy() on bean with name &#39;&quot; + this.beanName + &quot;&#39;&quot;);
            }
            try {
                if (System.getSecurityManager() != null) {
                    AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) () -&gt; {
                        ((DisposableBean) this.bean).destroy();
                        return null;
                    }, this.acc);
                }
                else {
                    ((DisposableBean) this.bean).destroy();
                }
            }
            catch (Throwable ex) {
                String msg = &quot;Invocation of destroy method failed on bean with name &#39;&quot; + this.beanName + &quot;&#39;&quot;;
                if (logger.isDebugEnabled()) {
                    logger.info(msg, ex);
                }
                else {
                    logger.info(msg + &quot;: &quot; + ex);
                }
            }
        }

        if (this.destroyMethod != null) {
            invokeCustomDestroyMethod(this.destroyMethod);
        }
        else if (this.destroyMethodName != null) {
            Method methodToCall = determineDestroyMethod(this.destroyMethodName);
            if (methodToCall != null) {
                invokeCustomDestroyMethod(methodToCall);
            }
        }
    }</code></pre>
<h2 id="å•å®ä¾‹å¾ªç¯ä¾èµ–"><a href="#å•å®ä¾‹å¾ªç¯ä¾èµ–" class="headerlink" title="å•å®ä¾‹å¾ªç¯ä¾èµ–"></a>å•å®ä¾‹å¾ªç¯ä¾èµ–</h2><p><a href="https://www.processon.com/view/link/5df9ce52e4b0c4255ea1a84f" target="_blank" rel="noopener">å¾ªç¯ä¾èµ–æµç¨‹å›¾</a></p>
<p>å•ä¾‹å®ä¾‹æ— å‚æ„é€ å‡½æ•°çš„å¾ªç¯ä¾èµ–æ˜¯å¯ä»¥è§£å†³çš„ï¼Œä½†å¦‚æœæ˜¯å‚æ„é€ å‡½æ•°@Autowired çš„æ–¹å¼é€ æˆçš„å¾ªç¯ä¾èµ–ä¼šç›´æ¥æŠ¥é”™ï¼Œå¤šä¾‹çš„å¾ªç¯ä¾èµ–ä¹Ÿæ˜¯ç›´æ¥æŠ¥é”™ã€‚</p>
<p>doGetBean()æ–¹æ³•çš„å†åˆ†æã€‚åœ¨è°ƒç”¨doGetBean()æ–¹æ³•è·å–å®ä¾‹æ—¶ï¼Œåœ¨è¯¥æ–¹æ³•ä¸­ä¼šå°è¯•é€šè¿‡getSingleton(beanName)æ–¹æ³•ä»ç¼“å­˜ä¸­è·å–å®ä¾‹ï¼Œå¦‚æœæ²¡æœ‰ä¼šé€šè¿‡getSingleton()çš„é‡è½½æ–¹æ³•åˆ›å»ºå®ä¾‹ã€‚</p>
<pre><code class="java">    protected &lt;T&gt; T doGetBean(final String name, @Nullable final Class&lt;T&gt; requiredType,
            @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException {

        final String beanName = transformedBeanName(name);
        Object bean;

        //ä»ç¼“å­˜ä¸­æ‹¿å®ä¾‹
        // Eagerly check singleton cache for manually registered singletons.
        Object sharedInstance = getSingleton(beanName);
        //å¦‚æœç¼“å­˜é‡Œé¢èƒ½æ‹¿åˆ°å®ä¾‹
        if (sharedInstance != null &amp;&amp; args == null) {
            if (logger.isTraceEnabled()) {
                if (isSingletonCurrentlyInCreation(beanName)) {
                    logger.trace(&quot;Returning eagerly cached instance of singleton bean &#39;&quot; + beanName +
                            &quot;&#39; that is not fully initialized yet - a consequence of a circular reference&quot;);
                }
                else {
                    logger.trace(&quot;Returning cached instance of singleton bean &#39;&quot; + beanName + &quot;&#39;&quot;);
                }
            }
            //æ”¹æ–¹æ³•æ˜¯FactoryBeanæ¥å£çš„è°ƒç”¨å…¥å£
            bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);
        }

        else {

            //å¦‚æœsingletonObjectsç¼“å­˜é‡Œé¢æ²¡æœ‰ï¼Œåˆ™èµ°ä¸‹æ¥
            // Fail if we&#39;re already creating this bean instance:
            // We&#39;re assumably within a circular reference.

            //å¦‚æœæ˜¯scope æ˜¯Prototypeçš„ï¼Œæ ¡éªŒæ˜¯å¦æœ‰å‡ºç°å¾ªç¯ä¾èµ–ï¼Œå¦‚æœæœ‰åˆ™ç›´æ¥æŠ¥é”™
            if (isPrototypeCurrentlyInCreation(beanName)) {
                throw new BeanCurrentlyInCreationException(beanName);
            }

            // Check if bean definition exists in this factory.
            BeanFactory parentBeanFactory = getParentBeanFactory();
            if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) {
                // Not found -&gt; check parent.
                String nameToLookup = originalBeanName(name);
                if (parentBeanFactory instanceof AbstractBeanFactory) {
                    return ((AbstractBeanFactory) parentBeanFactory).doGetBean(
                            nameToLookup, requiredType, args, typeCheckOnly);
                }
                else if (args != null) {
                    // Delegation to parent with explicit args.
                    return (T) parentBeanFactory.getBean(nameToLookup, args);
                }
                else if (requiredType != null) {
                    // No args -&gt; delegate to standard getBean method.
                    return parentBeanFactory.getBean(nameToLookup, requiredType);
                }
                else {
                    return (T) parentBeanFactory.getBean(nameToLookup);
                }
            }

            if (!typeCheckOnly) {
                markBeanAsCreated(beanName);
            }

            try {
                //çˆ¶å­BeanDefinitionåˆå¹¶
                final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
                checkMergedBeanDefinition(mbd, beanName, args);

                //è·å–ä¾èµ–å¯¹è±¡å±æ€§ï¼Œä¾èµ–å¯¹è±¡è¦å…ˆå®ä¾‹åŒ–
                // Guarantee initialization of beans that the current bean depends on.
                String[] dependsOn = mbd.getDependsOn();
                if (dependsOn != null) {
                    for (String dep : dependsOn) {
                        if (isDependent(beanName, dep)) {
                            throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                                    &quot;Circular depends-on relationship between &#39;&quot; + beanName + &quot;&#39; and &#39;&quot; + dep + &quot;&#39;&quot;);
                        }
                        registerDependentBean(dep, beanName);
                        try {
                            //å®ä¾‹åŒ–
                            getBean(dep);
                    }
                        catch (NoSuchBeanDefinitionException ex) {
                            throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                                    &quot;&#39;&quot; + beanName + &quot;&#39; depends on missing bean &#39;&quot; + dep + &quot;&#39;&quot;, ex);
                        }
                    }
                }

                //ç€é‡çœ‹ï¼Œå¤§éƒ¨åˆ†æ˜¯å•ä¾‹çš„æƒ…å†µ
                // Create bean instance.
                if (mbd.isSingleton()) {
                    sharedInstance = getSingleton(beanName, () -&gt; {
                        try {
                            return createBean(beanName, mbd, args);
                        }
                        catch (BeansException ex) {
                            // Explicitly remove instance from singleton cache: It might have been put there
                            // eagerly by the creation process, to allow for circular reference resolution.
                            // Also remove any beans that received a temporary reference to the bean.
                            destroySingleton(beanName);
                            throw ex;
                        }
                    });
                    //è¯¥æ–¹æ³•æ˜¯FactoryBeanæ¥å£çš„è°ƒç”¨å…¥å£
                    bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
                }

                else if (mbd.isPrototype()) {
                    // It&#39;s a prototype -&gt; create a new instance.
                    Object prototypeInstance = null;
                    try {
                        beforePrototypeCreation(beanName);
                        prototypeInstance = createBean(beanName, mbd, args);
                    }
                    finally {
                        afterPrototypeCreation(beanName);
                    }
                    //è¯¥æ–¹æ³•æ˜¯FactoryBeanæ¥å£çš„è°ƒç”¨å…¥å£
                    bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
                }

                else {
                    String scopeName = mbd.getScope();
                    final Scope scope = this.scopes.get(scopeName);
                    if (scope == null) {
                        throw new IllegalStateException(&quot;No Scope registered for scope name &#39;&quot; + scopeName + &quot;&#39;&quot;);
                    }
                    try {
                        Object scopedInstance = scope.get(beanName, () -&gt; {
                            beforePrototypeCreation(beanName);
                            try {
                                return createBean(beanName, mbd, args);
                            }
                            finally {
                                afterPrototypeCreation(beanName);
                            }
                        });
                        //è¯¥æ–¹æ³•æ˜¯FactoryBeanæ¥å£çš„è°ƒç”¨å…¥å£
                        bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
                    }
                    catch (IllegalStateException ex) {
                        throw new BeanCreationException(beanName,
                                &quot;Scope &#39;&quot; + scopeName + &quot;&#39; is not active for the current thread; consider &quot; +
                                &quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;,
                                ex);
                    }
                }
            }
            catch (BeansException ex) {
                cleanupAfterBeanCreationFailure(beanName);
                throw ex;
            }
        }

        // Check if required type matches the type of the actual bean instance.
        if (requiredType != null &amp;&amp; !requiredType.isInstance(bean)) {
            try {
                T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);
                if (convertedBean == null) {
                    throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
                }
                return convertedBean;
            }
            catch (TypeMismatchException ex) {
                if (logger.isTraceEnabled()) {
                    logger.trace(&quot;Failed to convert bean &#39;&quot; + name + &quot;&#39; to required type &#39;&quot; +
                            ClassUtils.getQualifiedName(requiredType) + &quot;&#39;&quot;, ex);
                }
                throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
            }
        }
        return (T) bean;
    }</code></pre>
<p>getSingleton()æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç”¨äºä»ç¼“å­˜ä¸­è·å–å®ä¾‹ï¼Œä¼šæŒ‰ç…§ä¸€çº§ç¼“å­˜ã€äºŒçº§ç¼“å­˜ã€ä¸‰çº§ç¼“å­˜çš„é¡ºåºè·å–ï¼Œå†ä»ä¸‰çº§ç¼“å­˜ä¸­è·å–å®ä¾‹åï¼Œä¼šå°†å®ä¾‹æ”¾åˆ°äºŒçº§ç¼“å­˜å¹¶åˆ é™¤ä¸‰çº§ç¼“å­˜ã€‚ä¸€çº§ç¼“å­˜ä¸­çš„beanæ˜¯å®Œæˆå®ä¾‹åŒ–ï¼ŒIOCã€DIæ³¨å…¥çš„ï¼Œä¸‰çº§ç¼“å­˜ä¸­æ—¶ä»…ä»…æ‰§è¡Œå®Œæ„é€ æ–¹æ³•ï¼Œè¿˜æ²¡æœ‰å¯¹å±æ€§è¿›è¡Œèµ‹å€¼æ“ä½œçš„beanï¼ŒäºŒçº§ç¼“å­˜ä¸­çš„beanä¸ä¸‰çº§ç¼“å­˜ç›¸åŒï¼ŒäºŒçº§ç¼“å­˜å­˜åœ¨çš„æ„ä¹‰æ˜¯ä¸ºäº†æå‡æ•ˆç‡ã€‚</p>
<pre><code class="java">    protected Object getSingleton(String beanName, boolean allowEarlyReference) {
        //æ ¹æ®beanNameä»ç¼“å­˜ä¸­æ‹¿å®ä¾‹
        //å…ˆä»ä¸€çº§ç¼“å­˜æ‹¿
        Object singletonObject = this.singletonObjects.get(beanName);
        //å¦‚æœbeanè¿˜æ­£åœ¨åˆ›å»ºï¼Œè¿˜æ²¡åˆ›å»ºå®Œæˆï¼Œå…¶å®å°±æ˜¯å †å†…å­˜æœ‰äº†ï¼Œå±æ€§è¿˜æ²¡æœ‰DIä¾èµ–æ³¨å…¥
        if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) {
            synchronized (this.singletonObjects) {
                //ä»äºŒçº§ç¼“å­˜ä¸­æ‹¿
                singletonObject = this.earlySingletonObjects.get(beanName);

                //å¦‚æœè¿˜æ‹¿ä¸åˆ°ï¼Œå¹¶ä¸”å…è®¸beanæå‰æš´éœ²
                if (singletonObject == null &amp;&amp; allowEarlyReference) {
                    //ä»ä¸‰çº§ç¼“å­˜ä¸­æ‹¿åˆ°å¯¹è±¡å·¥å‚
                    ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName);
                    if (singletonFactory != null) {
                        //ä»å·¥å‚ä¸­æ‹¿åˆ°å¯¹è±¡
                        singletonObject = singletonFactory.getObject();
                        //å‡çº§åˆ°äºŒçº§ç¼“å­˜
                        this.earlySingletonObjects.put(beanName, singletonObject);
                        //åˆ é™¤ä¸‰çº§ç¼“å­˜
                        this.singletonFactories.remove(beanName);
                    }
                }
            }
        }
        return singletonObject;
    }</code></pre>
<p>é‡è½½çš„getSingleton()æ–¹æ³•ï¼Œè¯¥æ–¹æ³•åœ¨åˆ›å»ºBeanä¹‹å‰ä¼šå°†beanNameæ·»åŠ åˆ°singletonsCurrentlyInCreationå®¹å™¨ä¸­ï¼Œå¦‚æœå®¹å™¨ä¸­å·²æœ‰è¯¥beanNameä¼šç›´æ¥æŠ¥é”™ï¼Œç„¶åé€šè¿‡singletonFactory.getObject()æ–¹æ³•åˆ›å»ºå®ä¾‹ï¼Œå¦‚æœæœ‰è¿”å›å€¼ï¼Œå°±è¡¨ç¤ºå®ä¾‹å·²ç»å®Œæˆåˆ›å»ºï¼Œå†ä»å®¹å™¨ä¸­åˆ é™¤beanNameï¼Œåˆ›å»ºå®Œæˆåè°ƒç”¨addSingleton()æ–¹æ³•æ”¾å…¥ä¸€çº§ç¼“å­˜ã€‚</p>
<pre><code class="java">    public Object getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory) {
        Assert.notNull(beanName, &quot;Bean name must not be null&quot;);
        synchronized (this.singletonObjects) {
            //å¦‚æœç¼“å­˜ä¸­æœ‰ï¼Œåˆ™ç›´æ¥è¿”å›
            Object singletonObject = this.singletonObjects.get(beanName);
            if (singletonObject == null) {
                if (this.singletonsCurrentlyInDestruction) {
                    throw new BeanCreationNotAllowedException(beanName,
                            &quot;Singleton bean creation not allowed while singletons of this factory are in destruction &quot; +
                            &quot;(Do not request a bean from a BeanFactory in a destroy method implementation!)&quot;);
                }
                if (logger.isDebugEnabled()) {
                    logger.debug(&quot;Creating shared instance of singleton bean &#39;&quot; + beanName + &quot;&#39;&quot;);
                }

                //æŠŠbeanNameæ·»åŠ åˆ°singletonsCurrentlyInCreation Setå®¹å™¨ä¸­ï¼Œåœ¨è¿™ä¸ªé›†åˆé‡Œé¢çš„beanéƒ½æ˜¯æ­£åœ¨å®ä¾‹åŒ–çš„bean
                beforeSingletonCreation(beanName);
                boolean newSingleton = false;
                boolean recordSuppressedExceptions = (this.suppressedExceptions == null);
                if (recordSuppressedExceptions) {
                    this.suppressedExceptions = new LinkedHashSet&lt;&gt;();
                }
                try {
                    singletonObject = singletonFactory.getObject();
                    newSingleton = true;
                }
                catch (IllegalStateException ex) {
                    // Has the singleton object implicitly appeared in the meantime -&gt;
                    // if yes, proceed with it since the exception indicates that state.
                    singletonObject = this.singletonObjects.get(beanName);
                    if (singletonObject == null) {
                        throw ex;
                    }
                }
                catch (BeanCreationException ex) {
                    if (recordSuppressedExceptions) {
                        for (Exception suppressedException : this.suppressedExceptions) {
                            ex.addRelatedCause(suppressedException);
                        }
                    }
                    throw ex;
                }
                finally {
                    if (recordSuppressedExceptions) {
                        this.suppressedExceptions = null;
                    }
                    //beanåˆ›å»ºå®ŒæˆåsingletonsCurrentlyInCreationè¦åˆ é™¤è¯¥bean
                    afterSingletonCreation(beanName);
                }
                if (newSingleton) {
                    //åˆ›å»ºå¯¹è±¡æˆåŠŸæ—¶ï¼ŒæŠŠå¯¹è±¡ç¼“å­˜åˆ°singletonObjectsç¼“å­˜ä¸­,beanåˆ›å»ºå®Œæˆæ—¶æ”¾å…¥ä¸€çº§ç¼“å­˜
                    addSingleton(beanName, singletonObject);
                }
            }
            return singletonObject;
        }
</code></pre>
<p>addSington()æ–¹æ³•ï¼Œè¯¥æ–¹æ³•åœ¨å®ä¾‹åˆ›å»ºåä¼šå°†å®ä¾‹æ”¾å…¥ä¸€çº§ç¼“å­˜ï¼Œå¹¶åˆ é™¤äºŒçº§ã€ä¸‰çº§ç¼“å­˜ä¸­çš„å®ä¾‹ã€‚</p>
<pre><code class="java">    protected void addSingleton(String beanName, Object singletonObject) {
        synchronized (this.singletonObjects) {
            //ä¸€çº§ç¼“å­˜
            this.singletonObjects.put(beanName, singletonObject);
            //ä¸‰çº§ç¼“å­˜
            this.singletonFactories.remove(beanName);
            //äºŒçº§ç¼“å­˜
            this.earlySingletonObjects.remove(beanName);
            this.registeredSingletons.add(beanName);
        }
    }</code></pre>
<p>singletonFactory.getObject()æ–¹æ³•ä¼šå›è°ƒåˆ°doCreateBean()æ–¹æ³•ï¼Œè¯¥æ–¹æ³•å®Œæˆå®ä¾‹çš„æ„é€ å‡½æ•°ååˆ›å»ºå®ä¾‹åï¼Œä¼šåˆ¤æ–­ç±»æ˜¯å¦éœ€è¦æå‰æš´éœ²ï¼Œå¦‚æœéœ€è¦ä¼šè°ƒç”¨addSingletonFactory()æ–¹æ³•å°†æ­£åœ¨åˆ›å»ºçš„beanæ·»åŠ åˆ°ä¸‰çº§ç¼“å­˜ï¼Œæ³¨æ„æ­¤æ—¶æ³¨è§£è£…é…å·²ç»å®Œæˆï¼Œä½†å¯¹æ³¨è§£çš„IOCã€DIç­‰æ“ä½œè¿˜æœªå¼€å§‹ã€‚addSingletonFactory()æ–¹æ³•ä¼šè°ƒç”¨åˆ°getEarlyBeanReference()æ–¹æ³•è·å–å®Œæˆå®ä¾‹åŒ–çš„beanã€‚åˆ¤æ–­beanæ˜¯å¦æ­£åœ¨åˆ›å»ºçš„æ–¹æ³•ä¸ºåˆ¤æ–­beanNameåœ¨singletonsCurrentlyInCreationä¸­æ˜¯å¦å­˜åœ¨ã€‚</p>
<pre><code class="java">    protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)
            throws BeanCreationException {

        // Instantiate the bean.
        BeanWrapper instanceWrapper = null;
        if (mbd.isSingleton()) {
            instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);
        }
        if (instanceWrapper == null) {
            //åˆ›å»ºå®ä¾‹ é‡ç‚¹çœ‹ é‡è¦ç¨‹åº¦ï¼š5
            instanceWrapper = createBeanInstance(beanName, mbd, args);
        }
        final Object bean = instanceWrapper.getWrappedInstance();
        Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();
        if (beanType != NullBean.class) {
            mbd.resolvedTargetType = beanType;
        }

        // Allow post-processors to modify the merged bean definition.
        synchronized (mbd.postProcessingLock) {
            if (!mbd.postProcessed) {
                try {
                    //CommonAnnotationBeanPostProcessor  æ”¯æŒäº†@PostConstructï¼Œ@PreDestroy,@Resourceæ³¨è§£
                    //AutowiredAnnotationBeanPostProcessor æ”¯æŒ @Autowired,@Valueæ³¨è§£
                    //BeanPostProcessoræ¥å£çš„å…¸å‹è¿ç”¨ï¼Œè¿™é‡Œè¦ç†è§£è¿™ä¸ªæ¥å£
                    //å¯¹ç±»ä¸­æ³¨è§£çš„è£…é…è¿‡ç¨‹
                    //é‡è¦ç¨‹åº¦5ï¼Œå¿…é¡»çœ‹
                    applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
                }
                catch (Throwable ex) {
                    throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                            &quot;Post-processing of merged bean definition failed&quot;, ex);
                }
                mbd.postProcessed = true;
            }
        }

        // Eagerly cache singletons to be able to resolve circular references
        // even when triggered by lifecycle interfaces like BeanFactoryAware.
        //æ˜¯å¦    å•ä¾‹beanæå‰æš´éœ²
        boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp;
                isSingletonCurrentlyInCreation(beanName));
        if (earlySingletonExposure) {
            if (logger.isTraceEnabled()) {
                logger.trace(&quot;Eagerly caching bean &#39;&quot; + beanName +
                        &quot;&#39; to allow for resolving potential circular references&quot;);
            }
            //è¿™é‡Œç€é‡ç†è§£ï¼Œå¯¹ç†è§£å¾ªç¯ä¾èµ–å¸®åŠ©éå¸¸å¤§ï¼Œé‡è¦ç¨‹åº¦ 5   æ·»åŠ ä¸‰çº§ç¼“å­˜
            addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));
        }

        // Initialize the bean instance.
        Object exposedObject = bean;
        try {
            //ioc diï¼Œä¾èµ–æ³¨å…¥çš„æ ¸å¿ƒæ–¹æ³•ï¼Œè¯¥æ–¹æ³•å¿…é¡»çœ‹ï¼Œé‡è¦ç¨‹åº¦ï¼š5
            populateBean(beanName, mbd, instanceWrapper);

            //bean å®ä¾‹åŒ–+iocä¾èµ–æ³¨å…¥å®Œä»¥åçš„è°ƒç”¨ï¼Œéå¸¸é‡è¦ï¼Œé‡è¦ç¨‹åº¦ï¼š5
            exposedObject = initializeBean(beanName, exposedObject, mbd);
        }
        catch (Throwable ex) {
            if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) {
                throw (BeanCreationException) ex;
            }
            else {
                throw new BeanCreationException(
                        mbd.getResourceDescription(), beanName, &quot;Initialization of bean failed&quot;, ex);
            }
        }

        if (earlySingletonExposure) {
            Object earlySingletonReference = getSingleton(beanName, false);
            if (earlySingletonReference != null) {
                if (exposedObject == bean) {
                    exposedObject = earlySingletonReference;
                }
                else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) {
                    String[] dependentBeans = getDependentBeans(beanName);
                    Set&lt;String&gt; actualDependentBeans = new LinkedHashSet&lt;&gt;(dependentBeans.length);
                    for (String dependentBean : dependentBeans) {
                        if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {
                            actualDependentBeans.add(dependentBean);
                        }
                    }
                    if (!actualDependentBeans.isEmpty()) {
                        throw new BeanCurrentlyInCreationException(beanName,
                                &quot;Bean with name &#39;&quot; + beanName + &quot;&#39; has been injected into other beans [&quot; +
                                StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +
                                &quot;] in its raw version as part of a circular reference, but has eventually been &quot; +
                                &quot;wrapped. This means that said other beans do not use the final version of the &quot; +
                                &quot;bean. This is often the result of over-eager type matching - consider using &quot; +
                                &quot;&#39;getBeanNamesOfType&#39; with the &#39;allowEagerInit&#39; flag turned off, for example.&quot;);
                    }
                }
            }
        }

        // Register bean as disposable.
        try {
            //æ³¨å†Œbeané”€æ¯æ—¶çš„ç±»DisposableBeanAdapter
            registerDisposableBeanIfNecessary(beanName, bean, mbd);
        }
        catch (BeanDefinitionValidationException ex) {
            throw new BeanCreationException(
                    mbd.getResourceDescription(), beanName, &quot;Invalid destruction signature&quot;, ex);
        }

        return exposedObject;
    }</code></pre>
<p>getEarlyBeanReference()ä¼šå°†åˆšæ‰§è¡Œå®Œæ„é€ å‡½æ•°ï¼Œè¿˜æ²¡æœ‰è¿›è¡Œå±æ€§è®¾ç½®çš„ç±»è¿”å›ã€‚</p>
<pre><code class="java">    protected Object getEarlyBeanReference(String beanName, RootBeanDefinition mbd, Object bean) {
        Object exposedObject = bean;
        if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) {
            for (BeanPostProcessor bp : getBeanPostProcessors()) {
                if (bp instanceof SmartInstantiationAwareBeanPostProcessor) {
                    SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;
                    exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);
                }
            }
        }
        return exposedObject;
    }</code></pre>
<p>å¾ªç¯ä¾èµ–æ­¥éª¤:</p>
<ol>
<li>Aç±»æ— å‚æ„é€ å‡½æ•°å®ä¾‹åŒ–åï¼Œè®¾ç½®ä¸‰çº§ç¼“å­˜ã€‚</li>
<li>Aç±»è¿›è¡Œä¾èµ–æ³¨å…¥ï¼Œè°ƒç”¨Bç±»çš„getBean()æ“ä½œã€‚</li>
<li>Bç±»æ— å‚æ„é€ å‡½æ•°å®ä¾‹åŒ–åï¼Œè®¾ç½®ä¸‰çº§ç¼“å­˜ã€‚</li>
<li>Bç±»ä¾èµ–æ³¨å…¥ï¼Œå†æ¬¡è§¦å‘äº†Aç±»getBean()æ“ä½œã€‚</li>
<li>Bç±»æ‹¿åˆ°äº†Açš„ä¸‰çº§ç¼“å­˜ä¸­çš„å®ä¾‹å¹¶æ³¨å…¥ã€‚</li>
<li>Bç±»çš„å®ä¾‹åŒ–å®Œæˆï¼Œç”±äºBç±»çš„åˆå§‹åŒ–æ˜¯Aç±»è°ƒç”¨getBean()å®Œæˆçš„ï¼ŒBç±»å®Œæˆå®ä¾‹åŒ–åä¼šè¿”å›ç»™Aç±»ã€‚</li>
<li>Aç±»è·å–åˆ°Bç±»ï¼Œå®Œæˆä¾èµ–æ³¨å…¥ã€‚</li>
</ol>
<p>çœ‹å®Œä¸Šé¢çš„æµç¨‹åï¼Œå¯¹äºæœ‰å‚æ„é€ å‡½æ•°ä¸­çš„@Autowiredé€ æˆçš„å¾ªç¯ä¾èµ–ç›´æ¥æŠ¥é”™çš„åŸå› å°±æ˜¾è€Œæ˜“è§äº†ã€‚å¦‚æœAç±»åœ¨æ‰§è¡Œæœ‰@Autowiredæ³¨è§£çš„æ„é€ å‡½æ•°æ—¶éœ€è¦æ³¨å…¥Bç±»ï¼ŒBç±»çš„æ„é€ å‡½æ•°ä¸­ä¹Ÿä½¿ç”¨@Autowiredè¦æ±‚æ³¨å…¥Aç±»ï¼Œé‚£ä¹ˆåœ¨è°ƒç”¨Açš„æ„é€ å‡½æ•°æ—¶ä¼šè§¦å‘Bç±»çš„åˆå§‹åŒ–ã€‚è€Œè¦å¤„ç†Bç±»æ„é€ å‡½æ•°çš„@Autowiredå°±éœ€è¦è·å–Açš„å®ä¾‹ï¼Œå°±ä¼šå†æ¬¡è§¦å‘Aç±»çš„getBean()ï¼Œä½†æ­¤æ—¶Açš„æ„é€ å‡½æ•°è¿˜æ²¡æœ‰å®Œæˆï¼Œé€šè¿‡ä¸‰çº§ç¼“å­˜æ˜¯æ‹¿ä¸åˆ°Aç±»çš„ï¼Œæ‰€ä»¥ä¼šå†æ¬¡è§¦å‘getSingletonå¾€singletonsCurrentlyInCreationä¸­æ”¾å…¥beanNameï¼Œä½†ç”±äºåœ¨ä¸Šé¢æ‰§è¡ŒAçš„æ„é€ å‡½æ•°ä¹‹å‰å°±å·²ç»å¾€singletonsCurrentlyInCreationæ”¾å…¥äº†Aç±»çš„beanNameï¼Œæ­¤æ—¶å†æ¬¡æ”¾å…¥ä¼šç›´æ¥æŠ¥é”™ã€‚</p>
<h2 id="FactoryBeanæ¥å£"><a href="#FactoryBeanæ¥å£" class="headerlink" title="FactoryBeanæ¥å£"></a>FactoryBeanæ¥å£</h2><p>è¯¥æ¥å£ä¸»è¦æ˜¯åœ¨BeanFactoryå®Œæˆå®ä¾‹åŒ–åï¼Œåˆ›å»ºäº¤ç»™Springç®¡ç†çš„ã€å¯ä»¥ç”¨äº@Autowiredæ³¨è§£çš„å¯¹è±¡ã€‚æ³¨æ„æ­¤æ—¶æ ¹æ®beanNameè·å–çš„æ˜¯BeanFactoryæ¥å£åˆ›å»ºçš„å®ä¾‹ï¼Œå¦‚æœè¦è·å–BeanFactoryæ¥å£çš„å®ä¾‹éœ€è¦åœ¨BeanNameå‰åŠ ä¸Š&amp;ç¬¦å·ã€‚</p>
<p>getObjectForBeanInstance()æ–¹æ³•ç”¨äºå¯¹è¯¥æ¥å£çš„æ”¯æŒï¼Œå¦‚æœbeanNameä¸æ˜¯ä»¥&amp;å¼€å¤´ï¼Œå¹¶ä¸”beanInstanceæ˜¯FactoryBeanç±»å‹ï¼Œå°±ä¼šä»ç¼“å­˜é‡Œé¢æ‹¿FactoryBeanç±»å‹çš„å®ä¾‹ï¼Œç„¶åè°ƒç”¨getObjectFromFactoryBean()æ–¹æ³•åˆ›å»ºå®ä¾‹ã€‚</p>
<pre><code class="java">    protected Object getObjectForBeanInstance(
            Object beanInstance, String name, String beanName, @Nullable RootBeanDefinition mbd) {

        // Don&#39;t let calling code try to dereference the factory if the bean isn&#39;t a factory.
        if (BeanFactoryUtils.isFactoryDereference(name)) {
            if (beanInstance instanceof NullBean) {
                return beanInstance;
            }
            if (!(beanInstance instanceof FactoryBean)) {
                throw new BeanIsNotAFactoryException(transformedBeanName(name), beanInstance.getClass());
            }
        }

        // Now we have the bean instance, which may be a normal bean or a FactoryBean.
        // If it&#39;s a FactoryBean, we use it to create a bean instance, unless the
        // caller actually wants a reference to the factory.
        //å¦‚æœå®ä¾‹ä¸æ˜¯FactoryBeanç±»å‹çš„ï¼Œæˆ–è€…nameæ˜¯ä»¥&amp;å·å¼€å¤´çš„ï¼Œåˆ™ç›´æ¥è¿”å›å®ä¾‹
        if (!(beanInstance instanceof FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) {
            return beanInstance;
        }

        //å¦‚æœä»£ç èƒ½èµ°ä¸‹æ¥ï¼Œåˆ™è¯´æ˜ beanNameä¸æ˜¯ä»¥&amp;å¼€å¤´ï¼Œå¹¶ä¸”beanInstanceæ˜¯FactoryBeanç±»å‹çš„
        Object object = null;
        if (mbd == null) {
            //ä»ç¼“å­˜é‡Œé¢æ‹¿FactoryBeanç±»å‹çš„å®ä¾‹
            object = getCachedObjectForFactoryBean(beanName);
        }
        if (object == null) {
            // Return bean instance from factory.
            FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance;
            // Caches object obtained from FactoryBean if it is a singleton.
            if (mbd == null &amp;&amp; containsBeanDefinition(beanName)) {
                mbd = getMergedLocalBeanDefinition(beanName);
            }
            boolean synthetic = (mbd != null &amp;&amp; mbd.isSynthetic());

            //é‡ç‚¹çœ‹
            object = getObjectFromFactoryBean(factory, beanName, !synthetic);
        }
        return object;
    }</code></pre>
<p>getObjectFromFactoryBean()æ–¹æ³•ä¼šè°ƒç”¨FactoryBeanæ¥å£çš„getObject()æ–¹æ³•è·å–å®ä¾‹ï¼Œç„¶åå°†åˆ›å»ºçš„å¯¹è±¡ä¼šæ”¾å…¥factoryBeanObjectCacheå®¹å™¨ä¸­ï¼Œè€Œä¸æ˜¯ä¸€çº§ç¼“å­˜çš„å®¹å™¨ã€‚</p>
<pre><code class="java">    protected Object getObjectFromFactoryBean(FactoryBean&lt;?&gt; factory, String beanName, boolean shouldPostProcess) {
        if (factory.isSingleton() &amp;&amp; containsSingleton(beanName)) {
            synchronized (getSingletonMutex()) {
                Object object = this.factoryBeanObjectCache.get(beanName);
                if (object == null) {
                    //è°ƒç”¨getObjectæ–¹æ³•
                    object = doGetObjectFromFactoryBean(factory, beanName);
                    // Only post-process and store if not put there already during getObject() call above
                    // (e.g. because of circular reference processing triggered by custom getBean calls)
                    Object alreadyThere = this.factoryBeanObjectCache.get(beanName);
                    if (alreadyThere != null) {
                        object = alreadyThere;
                    }
                    else {
                        if (shouldPostProcess) {
                            if (isSingletonCurrentlyInCreation(beanName)) {
                                // Temporarily return non-post-processed object, not storing it yet..
                                return object;
                            }
                            beforeSingletonCreation(beanName);
                            try {
                                object = postProcessObjectFromFactoryBean(object, beanName);
                            }
                            catch (Throwable ex) {
                                throw new BeanCreationException(beanName,
                                        &quot;Post-processing of FactoryBean&#39;s singleton object failed&quot;, ex);
                            }
                            finally {
                                afterSingletonCreation(beanName);
                            }
                        }
                        if (containsSingleton(beanName)) {
                            //æŠŠå®ä¾‹ç¼“å­˜åˆ°factoryBeanObjectCache mapä¸­ï¼Œè¿™ä¸ªæ˜¯å•ç‹¬ç¼“å­˜FactoryBeanç±»å‹å®ä¾‹çš„map
                            this.factoryBeanObjectCache.put(beanName, object);
                        }
                    }
                }
                return object;
            }
        }
        else {
            Object object = doGetObjectFromFactoryBean(factory, beanName);
            if (shouldPostProcess) {
                try {
                    object = postProcessObjectFromFactoryBean(object, beanName);
                }
                catch (Throwable ex) {
                    throw new BeanCreationException(beanName, &quot;Post-processing of FactoryBean&#39;s object failed&quot;, ex);
                }
            }
            return object;
        }
    }</code></pre>
<h2 id="BeanPostProcessoræ¥å£"><a href="#BeanPostProcessoræ¥å£" class="headerlink" title="BeanPostProcessoræ¥å£"></a>BeanPostProcessoræ¥å£</h2><p>BeanPostProcessoræ¥å£ç±»å‹å®ä¾‹æ˜¯é’ˆå¯¹æŸç§ç‰¹å®šåŠŸèƒ½çš„åŸ‹ç‚¹ï¼Œåœ¨è¿™ä¸ªç‚¹ä¼šæ ¹æ®æ¥å£ç±»å‹æ¥è¿‡æ»¤æ‰ä¸å…³æ³¨è¿™ä¸ªç‚¹çš„å…¶ä»–ç±»ï¼Œåªæœ‰çœŸæ­£å…³æ³¨çš„ç±»æ‰ä¼šåœ¨è¿™ä¸ªç‚¹è¿›è¡Œç›¸åº”çš„åŠŸèƒ½å®ç°ã€‚åœ¨ä½¿ç”¨æ—¶é€šå¸¸ä¼šæ‹¿åˆ°æ‰€æœ‰çš„BeanPostProcessoræ¥å£ï¼Œç„¶åå¾ªç¯æ ¹æ®BeanPostProcessoræ¥å£çš„ç±»å‹è¿›è¡Œè¿‡æ»¤ï¼Œæˆ–è€…ç›´æ¥è°ƒç”¨å¯¹åº”çš„æ–¹æ³•ï¼Œå¦‚æœè¯¥BeanPostProcessoræ¥å£ä¸å…³æ³¨è¿™ä¸ªç‚¹ï¼Œå¯¹åº”çš„æ–¹æ³•ä¸­å°±æ²¡æœ‰ç›¸åº”çš„å®ç°ã€‚</p>
<h3 id="è·å–æœ‰-Autowiredæ³¨è§£çš„æ„é€ å‡½æ•°åŸ‹ç‚¹"><a href="#è·å–æœ‰-Autowiredæ³¨è§£çš„æ„é€ å‡½æ•°åŸ‹ç‚¹" class="headerlink" title="è·å–æœ‰@Autowiredæ³¨è§£çš„æ„é€ å‡½æ•°åŸ‹ç‚¹"></a>è·å–æœ‰@Autowiredæ³¨è§£çš„æ„é€ å‡½æ•°åŸ‹ç‚¹</h3><p>doCreateBean()åˆå§‹åŒ–Beanå®ä¾‹æ—¶ï¼Œç”¨äºåˆ›å»ºBeanå®ä¾‹çš„createBeanInstance()æ–¹æ³•ä¸­ï¼Œä¼šè°ƒç”¨determineConstructorsFromBeanPostProcessors()æ–¹æ³•è·å¾—æœ‰@Autowiredæ³¨è§£çš„æ„é€ æ–¹æ³•ã€‚</p>
<pre><code>        // Candidate constructors for autowiring?
        //å¯»æ‰¾å½“å‰æ­£åœ¨å®ä¾‹åŒ–çš„beanä¸­æœ‰@Autowiredæ³¨è§£çš„æ„é€ å‡½æ•°
        Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);
        if (ctors != null || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||
                mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) {
            //å¦‚æœctorsä¸ä¸ºç©ºï¼Œå°±è¯´æ˜æ„é€ å‡½æ•°ä¸Šæœ‰@Autowiredæ³¨è§£
            return autowireConstructor(beanName, mbd, ctors, args);
        }</code></pre><p>è¿™é‡Œè¿‡æ»¤çš„æ¥å£ç±»å‹æ˜¯SmartInstantiationAwareBeanPostProcessorï¼Œè°ƒç”¨çš„æ–¹æ³•æ˜¯determineCandidateConstructors()ã€‚</p>
<pre><code class="java">    protected Constructor&lt;?&gt;[] determineConstructorsFromBeanPostProcessors(@Nullable Class&lt;?&gt; beanClass, String beanName)
            throws BeansException {

        if (beanClass != null &amp;&amp; hasInstantiationAwareBeanPostProcessors()) {
            //è·å–æ‰€æœ‰çš„BeanPostProcessors
            for (BeanPostProcessor bp : getBeanPostProcessors()) {
                if (bp instanceof SmartInstantiationAwareBeanPostProcessor) {
                    SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;
                    //æ‰¾åˆ°åˆé€‚çš„æ„é€ å‡½æ•°
                    Constructor&lt;?&gt;[] ctors = ibp.determineCandidateConstructors(beanClass, beanName);
                    if (ctors != null) {
                        return ctors;
                    }
                }
            }
        }
        return null;
    }</code></pre>
<h3 id="æ”¶é›†-Resourceã€-Autowiredã€-Value-PostConstructã€-PreDestroyæ³¨è§£çš„æ–¹æ³•å’Œå±æ€§åŸ‹ç‚¹"><a href="#æ”¶é›†-Resourceã€-Autowiredã€-Value-PostConstructã€-PreDestroyæ³¨è§£çš„æ–¹æ³•å’Œå±æ€§åŸ‹ç‚¹" class="headerlink" title="æ”¶é›†@Resourceã€@Autowiredã€@Value@PostConstructã€@PreDestroyæ³¨è§£çš„æ–¹æ³•å’Œå±æ€§åŸ‹ç‚¹"></a>æ”¶é›†@Resourceã€@Autowiredã€@Value@PostConstructã€@PreDestroyæ³¨è§£çš„æ–¹æ³•å’Œå±æ€§åŸ‹ç‚¹</h3><p>doCreateBean()è¿›è¡Œæ³¨è§£çš„è£…é…æ—¶ï¼Œä¼šä½¿ç”¨applyMergedBeanDefinitionPostProcessors()æ–¹æ³•ã€‚</p>
<pre><code class="java">        synchronized (mbd.postProcessingLock) {
            if (!mbd.postProcessed) {
                try {
                    //CommonAnnotationBeanPostProcessor  æ”¯æŒäº†@PostConstructï¼Œ@PreDestroy,@Resourceæ³¨è§£
                    //AutowiredAnnotationBeanPostProcessor æ”¯æŒ @Autowired,@Valueæ³¨è§£
                    //BeanPostProcessoræ¥å£çš„å…¸å‹è¿ç”¨ï¼Œè¿™é‡Œè¦ç†è§£è¿™ä¸ªæ¥å£
                    //å¯¹ç±»ä¸­æ³¨è§£çš„è£…é…è¿‡ç¨‹
                    //é‡è¦ç¨‹åº¦5ï¼Œå¿…é¡»çœ‹
                    applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
                }
                catch (Throwable ex) {
                    throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                            &quot;Post-processing of merged bean definition failed&quot;, ex);
                }
                mbd.postProcessed = true;
            }
        }</code></pre>
<p>è¿‡æ»¤çš„æ¥å£ç±»å‹æ˜¯MergedBeanDefinitionPostProcessorï¼Œè°ƒç”¨çš„æ–¹æ³•æ˜¯postProcessMergedBeanDefinition()ã€‚</p>
<pre><code class="java">    protected void applyMergedBeanDefinitionPostProcessors(RootBeanDefinition mbd, Class&lt;?&gt; beanType, String beanName) {
        for (BeanPostProcessor bp : getBeanPostProcessors()) {
            if (bp instanceof MergedBeanDefinitionPostProcessor) {
                MergedBeanDefinitionPostProcessor bdp = (MergedBeanDefinitionPostProcessor) bp;
                bdp.postProcessMergedBeanDefinition(mbd, beanType, beanName);
            }
        }
    }</code></pre>
<h3 id="å¾ªç¯ä¾èµ–è§£å†³ä¸­beançš„æå‰æš´éœ²åŸ‹ç‚¹"><a href="#å¾ªç¯ä¾èµ–è§£å†³ä¸­beançš„æå‰æš´éœ²åŸ‹ç‚¹" class="headerlink" title="å¾ªç¯ä¾èµ–è§£å†³ä¸­beançš„æå‰æš´éœ²åŸ‹ç‚¹"></a>å¾ªç¯ä¾èµ–è§£å†³ä¸­beançš„æå‰æš´éœ²åŸ‹ç‚¹</h3><p>doCreateBean()å¯¹Beanè¿›è¡Œæå‰æš´éœ²æ—¶ï¼Œä¼šè°ƒç”¨getEarlyBeanReference()æ–¹æ³•è·å–åˆ°Beanå®ä¾‹ã€‚</p>
<pre><code class="java">        //æ˜¯å¦    å•ä¾‹beanæå‰æš´éœ²
        boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp;
                isSingletonCurrentlyInCreation(beanName));
        if (earlySingletonExposure) {
            if (logger.isTraceEnabled()) {
                logger.trace(&quot;Eagerly caching bean &#39;&quot; + beanName +
                        &quot;&#39; to allow for resolving potential circular references&quot;);
            }
            //è¿™é‡Œç€é‡ç†è§£ï¼Œå¯¹ç†è§£å¾ªç¯ä¾èµ–å¸®åŠ©éå¸¸å¤§ï¼Œé‡è¦ç¨‹åº¦ 5   æ·»åŠ ä¸‰çº§ç¼“å­˜
            addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));
        }</code></pre>
<p>è¿‡æ»¤çš„æ¥å£ç±»å‹æ˜¯SmartInstantiationAwareBeanPostProcessorï¼Œè°ƒç”¨çš„æ–¹æ³•æ˜¯determineCandidateConstructors()ã€‚</p>
<pre><code class="java">    protected Object getEarlyBeanReference(String beanName, RootBeanDefinition mbd, Object bean) {
        Object exposedObject = bean;
        if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) {
            for (BeanPostProcessor bp : getBeanPostProcessors()) {
                if (bp instanceof SmartInstantiationAwareBeanPostProcessor) {
                    SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;
                    exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);
                }
            }
        }
        return exposedObject;
    }</code></pre>
<h3 id="é˜»æ­¢ä¾èµ–æ³¨å…¥åŸ‹ç‚¹"><a href="#é˜»æ­¢ä¾èµ–æ³¨å…¥åŸ‹ç‚¹" class="headerlink" title="é˜»æ­¢ä¾èµ–æ³¨å…¥åŸ‹ç‚¹"></a>é˜»æ­¢ä¾èµ–æ³¨å…¥åŸ‹ç‚¹</h3><p>ä½äºdoCreateBean()è¿›è¡Œä¾èµ–æ³¨å…¥æ—¶ï¼ŒpopulateBean()æ–¹æ³•ä¸­ã€‚</p>
<p>è¿‡æ»¤çš„æ¥å£ç±»å‹æ˜¯InstantiationAwareBeanPostProcessorï¼Œè°ƒç”¨çš„æ–¹æ³•æ˜¯postProcessAfterInstantiationã€‚</p>
<pre><code class="java">        //è¿™é‡Œå†™æ¥å£å¯ä»¥è®©æ‰€æœ‰ç±»éƒ½ä¸èƒ½ä¾èµ–æ³¨å…¥
        if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) {
            for (BeanPostProcessor bp : getBeanPostProcessors()) {
                if (bp instanceof InstantiationAwareBeanPostProcessor) {
                    InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
                    if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {

                        //æ˜¯å¦éœ€è¦DIï¼Œä¾èµ–æ³¨å…¥
                        continueWithPropertyPopulation = false;
                        break;
                    }
                }
            }
        }</code></pre>
<h3 id="IOC-DI-ä¾èµ–æ³¨å…¥åŸ‹ç‚¹"><a href="#IOC-DI-ä¾èµ–æ³¨å…¥åŸ‹ç‚¹" class="headerlink" title="IOC/DI ä¾èµ–æ³¨å…¥åŸ‹ç‚¹"></a>IOC/DI ä¾èµ–æ³¨å…¥åŸ‹ç‚¹</h3><p>ä½äºdoCreateBean()è¿›è¡Œä¾èµ–æ³¨å…¥æ—¶ï¼ŒpopulateBean()æ–¹æ³•ä¸­ã€‚</p>
<p>è¿‡æ»¤çš„æ¥å£ç±»å‹æ˜¯InstantiationAwareBeanPostProcessorï¼Œè°ƒç”¨çš„æ–¹æ³•æ˜¯postProcessPropertiesã€‚</p>
<pre><code class="java">        //é‡ç‚¹çœ‹è¿™ä¸ªifä»£ç å—ï¼Œé‡è¦ç¨‹åº¦ 5
        if (hasInstAwareBpps) {
            if (pvs == null) {
                pvs = mbd.getPropertyValues();
            }
            for (BeanPostProcessor bp : getBeanPostProcessors()) {
                if (bp instanceof InstantiationAwareBeanPostProcessor) {
                    InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
                    //ä¾èµ–æ³¨å…¥è¿‡ç¨‹ï¼Œ@Autowiredçš„æ”¯æŒ
                    PropertyValues pvsToUse = ibp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);
                    if (pvsToUse == null) {
                        if (filteredPds == null) {
                            filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
                        }

                        //è€ç‰ˆæœ¬ç”¨è¿™ä¸ªå®Œæˆä¾èµ–æ³¨å…¥è¿‡ç¨‹ï¼Œ@Autowiredçš„æ”¯æŒ
                        pvsToUse = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);
                        if (pvsToUse == null) {
                            return;
                        }
                    }
                    pvs = pvsToUse;
                }
            }
    }</code></pre>
<h3 id="Beané”€æ¯çš„åŸ‹ç‚¹"><a href="#Beané”€æ¯çš„åŸ‹ç‚¹" class="headerlink" title="Beané”€æ¯çš„åŸ‹ç‚¹"></a>Beané”€æ¯çš„åŸ‹ç‚¹</h3><p>ä½äºdoGreateBean().registerDisposableBeanIfNecessary()æ–¹æ³•ä¸­è°ƒç”¨DisposableBeanAdapterçš„æ„é€ å‡½æ•°æ—¶ã€‚ç”¨äºå¯»æ‰¾DestructionAwareBeanPostProcessorç±»å‹çš„BeanPostProcessorã€‚</p>
<pre><code class="java">    private List&lt;DestructionAwareBeanPostProcessor&gt; filterPostProcessors(List&lt;BeanPostProcessor&gt; processors, Object bean) {
        List&lt;DestructionAwareBeanPostProcessor&gt; filteredPostProcessors = null;
        if (!CollectionUtils.isEmpty(processors)) {
            filteredPostProcessors = new ArrayList&lt;&gt;(processors.size());
            for (BeanPostProcessor processor : processors) {
                if (processor instanceof DestructionAwareBeanPostProcessor) {
                    DestructionAwareBeanPostProcessor dabpp = (DestructionAwareBeanPostProcessor) processor;
                    if (dabpp.requiresDestruction(bean)) {
                        filteredPostProcessors.add(dabpp);
                    }
                }
            }
        }
        return filteredPostProcessors;
    }</code></pre>

            </div>
            <hr>
            <div>
              <p>
                
                  <span>
                <i class="iconfont icon-inbox"></i>
                    
                      <a class="hover-with-bg" href="/blog/categories/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">Springæºç è§£æ</a>
                      &nbsp;
                    
                  </span>&nbsp;&nbsp;
                
                
                  <span>
                <i class="iconfont icon-tag"></i>
                    
                      <a class="hover-with-bg" href="/blog/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">æºç è§£æ</a>
                    
                      <a class="hover-with-bg" href="/blog/tags/spring/">spring</a>
                    
                  </span>
                
              </p>
              
                <p class="note note-warning">æœ¬åšå®¢æ‰€æœ‰æ–‡ç« é™¤ç‰¹åˆ«å£°æ˜å¤–ï¼Œå‡é‡‡ç”¨ <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0åè®®</a> ã€‚è½¬è½½è¯·æ³¨æ˜å‡ºå¤„ï¼</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/blog/2020/04/18/spring-%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F%E8%A7%A3%E6%9E%90%E5%92%8CBean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/">
                        <i class="fa fa-chevron-left"></i>
                        <span class="hidden-mobile">SpringåŸºäºæ³¨è§£çš„å¯åŠ¨æ–¹å¼è§£æå’ŒBeançš„ä½œç”¨åŸŸ</span>
                        <span class="visible-mobile">ä¸Šä¸€ç¯‡</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/blog/2020/04/13/spring-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%85%A5%E5%8F%A3%E5%92%8Cxml%E8%A7%A3%E6%9E%90/">
                        <span class="hidden-mobile">Springçš„åˆå§‹åŒ–å…¥å£å’Œxmlè§£æ</span>
                        <span class="visible-mobile">ä¸‹ä¸€ç¯‡</span>
                        <i class="fa fa-chevron-right"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

              
                <!-- Comments -->
                <div class="comments" id="comments">
                  
                  

                </div>
              
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc-start"></div>
<div id="toc">
  <p class="h5"><i class="far fa-list-alt"></i>&nbsp;ç›®å½•</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a class="z-depth-1" id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">æœç´¢</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">å…³é”®è¯</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"> <b>Fluid</b></a>
    </div>
    
  <div>
    
      <!-- ä¸è’œå­ç»Ÿè®¡PV -->
      
      <span id="busuanzi_container_site_pv" style="display: none">
      æ€»è®¿é—®é‡ <span id="busuanzi_value_site_pv"></span> æ¬¡
    </span>
    
    
      <!-- ä¸è’œå­ç»Ÿè®¡UV -->
      
      <span id="busuanzi_container_site_uv" style="display: none">
      æ€»è®¿å®¢æ•° <span id="busuanzi_value_site_uv"></span> äºº
    </span>
    
  </div>


    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/popper.js/1.16.1/umd/popper.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="https://cdn.staticfile.org/mdbootstrap/4.13.0/js/mdb.min.js" ></script>
<script  src="/blog/js/main.js" ></script>


  <script  src="/blog/js/lazyload.js" ></script>



  
  <script  src="https://cdn.staticfile.org/tocbot/4.10.0/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var navHeight = $('#navbar').height();
      var toc = $('#toc');
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;
      var tocLimMax = 2 * boardTop + boardCtn.height();

      $(window).scroll(function () {
        var tocLimMin = $('#toc-start').offset().top - navHeight;
        var scroH = document.body.scrollTop + document.documentElement.scrollTop;

        if (tocLimMin <= scroH && scroH <= tocLimMax) {
          toc.css({
            'display': 'block',
            'position': 'fixed',
            'top': navHeight,
          });
        } else if (scroH <= tocLimMin) {
          toc.css({
            'position': '',
            'top': '',
          });
        } else if (scroH > tocLimMax) {
          toc.css('display', 'none');
        }
      });
      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '.post-content',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc > p').css('visibility', 'visible');
      }
      var offset = boardCtn.css('margin-right')
      $('#toc-ctn').css({
        'right': offset
      })
    });
  </script>





  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/blog/js/clipboard-use.js" ></script>



  <script defer src="https://cdn.staticfile.org/smoothscroll/1.4.10/SmoothScroll.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




<!-- Plugins -->


  

  

  

  

  

  



  <script  src="https://cdn.staticfile.org/prettify/188.0.0/prettify.min.js" ></script>
  <script>
    $(document).ready(function () {
      $('pre').addClass('prettyprint  linenums');
      prettyPrint();
    })
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "Springå®ä¾‹åŒ–Beançš„è¿‡ç¨‹&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/blog/js/local-search.js" ></script>
  <script>
    var path = "/blog/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script defer src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <script>
    $("#post img:not(.no-zoom img, img[no-zoom])").each(
      function () {
        var element = document.createElement("a");
        $(element).attr("data-fancybox", "images");
        $(element).attr("href", $(this).attr("src"));
        $(this).wrap(element);
      }
    );
  </script>





  
  
    <script type="text/javascript">
      //å®šä¹‰è·å–è¯è¯­ä¸‹æ ‡
      var a_idx = 0;
      jQuery(document).ready(function ($) {
        //ç‚¹å‡»bodyæ—¶è§¦å‘äº‹ä»¶
        $("body").click(function (e) {
          //éœ€è¦æ˜¾ç¤ºçš„è¯è¯­
          var a = new Array("å¯Œå¼º", "æ°‘ä¸»", "æ–‡æ˜", "å’Œè°", "è‡ªç”±", "å¹³ç­‰", "å…¬æ­£", "æ³•æ²»", "çˆ±å›½", "æ•¬ä¸š", "è¯šä¿¡", "å‹å–„");
          //è®¾ç½®è¯è¯­ç»™spanæ ‡ç­¾
          var $i = $("<span/>").text(a[a_idx]);
          //ä¸‹æ ‡ç­‰äºåŸæ¥ä¸‹æ ‡+1  ä½™ è¯è¯­æ€»æ•°
          a_idx = (a_idx + 1) % a.length;
          //è·å–é¼ æ ‡æŒ‡é’ˆçš„ä½ç½®ï¼Œåˆ†åˆ«ç›¸å¯¹äºæ–‡æ¡£çš„å·¦å’Œå³è¾¹ç¼˜ã€‚
          //è·å–xå’Œyçš„æŒ‡é’ˆåæ ‡
          var x = e.pageX, y = e.pageY;
          //åœ¨é¼ æ ‡çš„æŒ‡é’ˆçš„ä½ç½®ç»™$iå®šä¹‰çš„spanæ ‡ç­¾æ·»åŠ cssæ ·å¼
          $i.css({
            "z-index": 999,
            "top": y - 20,
            "left": x,
            "position": "absolute",
            "font-weight": "bold",
            "color": rand_color()
          });
          // éšæœºé¢œè‰²
          function rand_color() {
            return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"
          }
          //åœ¨bodyæ·»åŠ è¿™ä¸ªæ ‡ç­¾
          $("body").append($i);
          //animate() æ–¹æ³•æ‰§è¡Œ CSS å±æ€§é›†çš„è‡ªå®šä¹‰åŠ¨ç”»ã€‚
          //è¯¥æ–¹æ³•é€šè¿‡CSSæ ·å¼å°†å…ƒç´ ä»ä¸€ä¸ªçŠ¶æ€æ”¹å˜ä¸ºå¦ä¸€ä¸ªçŠ¶æ€ã€‚CSSå±æ€§å€¼æ˜¯é€æ¸æ”¹å˜çš„ï¼Œè¿™æ ·å°±å¯ä»¥åˆ›å»ºåŠ¨ç”»æ•ˆæœã€‚
          //è¯¦æƒ…è¯·çœ‹http://www.w3school.com.cn/jquery/effect_animate.asp
          $i.animate({
            //å°†åŸæ¥çš„ä½ç½®å‘ä¸Šç§»åŠ¨180
            "top": y - 180,
            "opacity": 0
            //1500åŠ¨ç”»çš„é€Ÿåº¦
          }, 1500, function () {
            //æ—¶é—´åˆ°äº†è‡ªåŠ¨åˆ é™¤
            $i.remove();
          });
        });
      })
      ;
    </script>
  








</body>
</html>
