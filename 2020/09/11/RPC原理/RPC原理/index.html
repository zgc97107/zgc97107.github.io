

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/blog/img/favicon.png">
  <link rel="icon" type="image/png" href="/blog/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="">
  <meta name="keywords" content="">
  <title>RPC原理 - 萤火的博客</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/blog/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.1.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/blog/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"zhaoguocheng.gitee.io","root":"/blog/","version":"1.8.5","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"copy_btn":true,"image_zoom":{"enable":true},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/blog/js/utils.js" ></script>
  <script  src="/blog/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/blog/">&nbsp;<strong>萤火的博客</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/">
                <i class="iconfont icon-home-fill"></i>
                主页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/blog/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="RPC原理">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-09-11 20:08" pubdate>
        2020年9月11日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      6.4k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      70
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">RPC原理</h1>
            
            <div class="markdown-body">
              <h3 id="RPC简介"><a href="#RPC简介" class="headerlink" title="RPC简介"></a>RPC简介</h3><p>RPC的主要功能目标是让构建分布式计算（应用）更容易，RPC框架提供一种透明的调用机制，让使用者以类似本地调用的方式完成远程调用。</p>
<p>RPC的优点： </p>
<ul>
<li><p>分布式设计 </p>
</li>
<li><p>部署灵活 </p>
</li>
<li><p>解耦服务 </p>
</li>
<li><p>扩展性强 </p>
</li>
</ul>
<h3 id="RPC框架"><a href="#RPC框架" class="headerlink" title="RPC框架"></a>RPC框架</h3><ul>
<li><p>Dubbo：国内最早开源的 RPC 框架，由阿里巴巴公司开发并于 2011 年末对外开源，仅支持 Java 语言。 </p>
</li>
<li><p>Motan：微博内部使用的 RPC 框架，于 2016 年对外开源，仅支持 Java 语言。 </p>
</li>
<li><p>Tars：腾讯内部使用的 RPC 框架，于 2017 年对外开源，仅支持 C++ 语言。 </p>
</li>
<li><p>Spring Cloud：国外 Pivotal 公司 2014 年对外开源的 RPC 框架，提供了丰富的生态组件。 </p>
</li>
<li><p>gRPC：Google 于 2015 年对外开源的跨语言 RPC 框架，支持多种语言。 </p>
</li>
<li><p>Thrift：最初是由 Facebook 开发的内部系统跨语言的 RPC 框架，2007 年贡献给了 Apache 基金，成为 </p>
</li>
<li><p>Apache 开源项目之一，支持多种语言。 </p>
</li>
</ul>
<p>详情: <a target="_blank" rel="noopener" href="https://juejin.im/post/5d5bfab6f265da03d2114215">https://juejin.im/post/5d5bfab6f265da03d2114215</a> </p>
<ul>
<li><p>RPC框架的优点：</p>
</li>
<li><p>RPC框架一般使用长链接，不必每次通信都要3次握手，减少网络开销。 </p>
</li>
<li><p>RPC框架一般都有注册中心，有丰富的监控管理发布、下线接口、动态扩展等，对调用方来说是无感知、统一化的操作协议私密，安全性较高 </p>
</li>
<li><p>RPC框架的协议更简单内容更小，效率更高，服务化架构、服务化治理，RPC框架是一个强力的支撑。 </p>
</li>
</ul>
<h3 id="RPC原理"><a href="#RPC原理" class="headerlink" title="RPC原理"></a>RPC原理</h3><h4 id="设计架构"><a href="#设计架构" class="headerlink" title="设计架构"></a>设计架构</h4><img src="/blog/2020/09/11/RPC%E5%8E%9F%E7%90%86/RPC%E5%8E%9F%E7%90%86/pic1.png" srcset="/blog/img/loading.gif" class>

<h4 id="调用流程"><a href="#调用流程" class="headerlink" title="调用流程"></a>调用流程</h4><img src="/blog/2020/09/11/RPC%E5%8E%9F%E7%90%86/RPC%E5%8E%9F%E7%90%86/pic2.png" srcset="/blog/img/loading.gif" class>

<p>具体调用过程： </p>
<ol>
<li><p>服务消费者（client客户端）通过本地调用的方式调用服务。 </p>
</li>
<li><p>客户端存根（client stub）接收到请求后负责将方法、入参等信息序列化（组装）成能够进行网络传输的消息体。 </p>
</li>
<li><p>客户端存根（client stub）找到远程的服务地址，并且将消息通过网络发送给服务端。 </p>
</li>
<li><p>服务端存根（server stub）收到消息后进行解码（反序列化操作）。 </p>
</li>
<li><p>服务端存根（server stub）根据解码结果调用本地的服务进行相关处理。 </p>
</li>
<li><p>本地服务执行具体业务逻辑并将处理结果返回给服务端存根（server stub）。 </p>
</li>
<li><p>服务端存根（server stub）将返回结果重新打包成消息（序列化）并通过网络发送至消费方。 </p>
</li>
<li><p>客户端存根（client stub）接收到消息，并进行解码（反序列化）。 </p>
</li>
<li><p>服务消费方得到最终结果。</p>
</li>
</ol>
<p>所涉及的技术：</p>
<ol>
<li><p>动态代理：生成Client Stub（客户端存根）和Server Stub（服务端存根）的时候需要用到java动态代理技术。 </p>
</li>
<li><p>序列化：在网络中，所有的数据都将会被转化为字节进行传送，需要对这些参数进行序列化和反序列化操作。 目前主流高效的开源序列化框架有Kryo、fastjson、Hessian、Protobuf等。 </p>
</li>
<li><p><strong>NIO</strong>通信 ：Java 提供了 NIO 的解决方案，Java 7 也提供了更优秀的 NIO.2 支持。可以采用Netty或者mina框架来解决NIO数据传输的问题。开源的RPC框架Dubbo就是采用NIO通信，集成支持netty、mina、grizzly。</p>
</li>
<li><p>服务注册中心：通过注册中心，让客户端连接调用服务端所发布的服务。主流的注册中心组件：Redis、Zookeeper、Consul 、Etcd。Dubbo采用的是ZooKeeper提供服务注册与发现功能。 </p>
</li>
<li><p>负载均衡 ：在高并发的场景下，需要多个节点或集群来提升整体吞吐能力。 </p>
</li>
<li><p>健康检查：健康检查包括，客户端心跳和服务端主动探测两种方式。 </p>
</li>
</ol>
<h3 id="RPC解析"><a href="#RPC解析" class="headerlink" title="RPC解析"></a>RPC解析</h3><h4 id="序列化技术"><a href="#序列化技术" class="headerlink" title="序列化技术"></a>序列化技术</h4><img src="/blog/2020/09/11/RPC%E5%8E%9F%E7%90%86/RPC%E5%8E%9F%E7%90%86/pic3.png" srcset="/blog/img/loading.gif" class>

<p>在网络传输中，数据必须采用二进制形式， 所以在RPC调用过程中， 需要采用序列化技术，对入参对象和返回值对象进行序列化与反序列化。 </p>
<ol>
<li><p>解析效率：序列化协议应该首要考虑的因素，像xml/json解析起来比较耗时，需要解析doom树，二进制自定义协议解析起来效率要快很多。 </p>
</li>
<li><p>压缩率：同样一个对象，xml/json传输起来有大量的标签冗余信息，信息有效性低，二进制自定义协议占用的空间相对来说会小很多。 </p>
</li>
<li><p>扩展性与兼容性：是否能够利于信息的扩展，并且增加字段后旧版客户端是否需要强制升级，这都是需要考虑的问题，在自定义二进制协议时候，要做好充分考虑设计。 </p>
</li>
<li><p>可读性与可调试性：xml/json的可读性会比二进制协议好很多，并且通过网络抓包是可以直接读取，二进制则需要反序列化才能查看其内容。 </p>
</li>
<li><p>跨语言：有些序列化协议是与开发语言紧密相关的，例如dubbo的Hessian序列化协议就只能支持Java的RPC调用。 </p>
</li>
<li><p>通用性：xml/json非常通用，都有很好的第三方解析库，各个语言解析起来都十分方便，二进制数据的处理方面也有Protobuf和Hessian等插件，在做设计的时候尽量做到较好的通用性。 </p>
</li>
</ol>
<h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><img src="/blog/2020/09/11/RPC%E5%8E%9F%E7%90%86/RPC%E5%8E%9F%E7%90%86/pic4.png" srcset="/blog/img/loading.gif" class>

<p>RPC的调用内部核心技术采用的就是动态代理。</p>
<p>JDK动态代理的实现原理:</p>
<img src="/blog/2020/09/11/RPC%E5%8E%9F%E7%90%86/RPC%E5%8E%9F%E7%90%86/pic5.png" srcset="/blog/img/loading.gif" class>

<p>代理类 $Proxy里面会定义相同签名的接口，然后内部会定义一个变量绑定JDKProxy代理对象，当调用 User.job接口方法，实质上调用的是JDKProxy.invoke()方法。</p>
<p>动态代理开源技术</p>
<ul>
<li>Cglib动态代理 ：Cglib是一个强大的、高性能的代码生成包</li>
<li>Javassist动态代理：一个开源的分析、编辑和创建Java字节码的类库。 </li>
<li>Byte Buddy字节码增强库：Byte Buddy是致力于解决字节码操作和 简化操作复杂性的开源框架。 </li>
</ul>
<p>几种动态代理性能比较： </p>
<p>综合结果: </p>
<p>Byte Buddy &gt; Javassist &gt; CGLIB &gt; JDK。 </p>
<h4 id="服务注册发现"><a href="#服务注册发现" class="headerlink" title="服务注册发现"></a>服务注册发现</h4><h5 id="服务注册发现的处理流程"><a href="#服务注册发现的处理流程" class="headerlink" title="服务注册发现的处理流程"></a>服务注册发现的处理流程</h5><img src="/blog/2020/09/11/RPC%E5%8E%9F%E7%90%86/RPC%E5%8E%9F%E7%90%86/pic6.png" srcset="/blog/img/loading.gif" class>

<p>服务注册：服务提供方将对外暴露的接口发布到注册中心内，注册中心为了检测服务的有效状态，一般会建                                    立双向心跳机制。 </p>
<p>服务订阅：服务调用方去注册中心查找并订阅服务提供方的 IP，并缓存到本地用于后续调用。 </p>
<p>如何实现服务的注册发现</p>
<p>基于 ZooKeeper 的服务发现方式： </p>
<img src="/blog/2020/09/11/RPC%E5%8E%9F%E7%90%86/RPC%E5%8E%9F%E7%90%86/pic7.png" srcset="/blog/img/loading.gif" class>

<p>A. 在 ZooKeeper 中创建一个服务根路径，可以根据接口名命名（例如：/micro/service/com.itcast.orderService），在这个路径再创建服务提供方与调用方目录（server、client），分别用来存储服务提供方和调用方的节点信息。 </p>
<p>B. 服务端发起注册时，会在服务提供方目录中创建一个临时节点，节点中存储注册信息。 </p>
<p>C. 客户端发起订阅时，会在服务调用方目录中创建一个临时节点，节点中存储调用方的信息，同时watch 服务提供方的目录（/micro/service/com.itcast.orderService/server）中所有的服务节点数据。当服务端产生变化时ZK就 通知给订阅的客户端。 </p>
<p>ZooKeeper方案的特点： </p>
<p>强一致性，ZooKeeper 集群的每个节点的数据每次发生更新操作，都会通知其它 ZooKeeper 节点同时执行更新。 </p>
<h4 id="健康监测"><a href="#健康监测" class="headerlink" title="健康监测"></a>健康监测</h4><p>比如网络中的波动，硬件设施的老化等等。可能造成集群当中的某个节点存在问题，无法正常调用。</p>
<img src="/blog/2020/09/11/RPC%E5%8E%9F%E7%90%86/RPC%E5%8E%9F%E7%90%86/pic8.png" srcset="/blog/img/loading.gif" class>

<p>健康监测实现分析</p>
<p>心跳检测的过程总共包含以下状态: </p>
<ul>
<li><p>健康状态 </p>
</li>
<li><p>波动状态 </p>
</li>
<li><p>失败状态 </p>
</li>
</ul>
<p>完善的解决方案 </p>
<ul>
<li><p>阈值： 健康监测增加失败阈值记录。 </p>
</li>
<li><p>成功率： 可以再追加调用成功率的记录（成功次数/总次数）。 </p>
</li>
<li><p>探针： 对服务节点有一个主动的存活检测机制。 </p>
</li>
</ul>
<h4 id="网络IO模型"><a href="#网络IO模型" class="headerlink" title="网络IO模型"></a>网络IO模型</h4><p>网络IO模型分为五种： </p>
<ul>
<li><p>同步阻塞 IO（BIO） </p>
</li>
<li><p>同步非阻塞 IO（NIO） </p>
</li>
<li><p>IO 多路复用 </p>
</li>
<li><p>信号驱动IO </p>
</li>
<li><p>异步非阻塞 IO（AIO） </p>
</li>
</ul>
<p>常用的是同步阻塞 IO 和 IO 多路复用模型。 </p>
<p>阻塞IO模型</p>
<img src="/blog/2020/09/11/RPC%E5%8E%9F%E7%90%86/RPC%E5%8E%9F%E7%90%86/pic9.png" srcset="/blog/img/loading.gif" class>

<p>IO多路复用</p>
<p>IO多路复用的实现主要有select，poll和epoll模式。 </p>
<p>三者的区别：</p>
<table>
<thead>
<tr>
<th></th>
<th>select</th>
<th>poll</th>
<th>epoll</th>
</tr>
</thead>
<tbody><tr>
<td>操作方式</td>
<td>遍历</td>
<td>遍历</td>
<td>回调</td>
</tr>
<tr>
<td>底层实现</td>
<td>bitmap</td>
<td>数组</td>
<td>红黑树</td>
</tr>
<tr>
<td>IO效率</td>
<td>每次调用都进行线性 遍历，时间复杂度为 O(n)</td>
<td>每次调用都进行线性 遍历，时间复杂度为 O(n)</td>
<td>事件通知方式，每当fd就绪，系统注册的回 调函数就会被调用，将就绪fd放到readyList 里面，时间复杂度O(1)</td>
</tr>
<tr>
<td>最大连接数</td>
<td>1024（x86）或 2048（x64）</td>
<td>无上限</td>
<td>无上限</td>
</tr>
<tr>
<td>fd拷贝</td>
<td>每次调用select，都 需要把fd集合从用户 态拷贝到内核态</td>
<td>每次调用poll，都需 要把fd集合从用户态 拷贝到内核态</td>
<td>调用epoll_ctl时拷贝进内核并保存，之后每次 epoll_wait不拷贝</td>
</tr>
</tbody></table>
<p>基于select的 I/O 复用模型：</p>
<img src="/blog/2020/09/11/RPC%E5%8E%9F%E7%90%86/RPC%E5%8E%9F%E7%90%86/pic10.png" srcset="/blog/img/loading.gif" class>

<p>在基于select的 I/O 复用模型中，会用到 Select，这个函数也会使进程阻塞，但是和阻塞 I/O 所不同的是这两个函数可以同时对多个 I/O 操作。而且可以同时对多个读操作，多个写操作的 I/O 函数进行检测，直到有数据可读或可写时，才真正调用 I/O 操作函数。</p>
<p>epoll 是线程安全的。 epoll 不仅告诉你sock组里面的数据，还会告诉你具体哪个sock连接有数据，不用进程独自轮询查找。 </p>
<p>为什么阻塞 IO 和 IO 多路复用最为常用？</p>
<p>在实际的网络 IO 的应用中，需要的是系统内核的支持以及编程语言的支持。现在大多数系统内核都会支持阻塞IO、非阻塞 IO 和 IO 多路复用，但像信号驱动 IO、异步 IO，只有高版本的 Linux 系统内核才会支持。</p>
<p>RPC 框架应该采用哪种网络 IO 模型？</p>
<p>IO 多路复用应用特点： </p>
<p>IO 多路复用更适合高并发的场景，可以用较少的进程（线程）处理较多的 socket 的 IO 请求，但使用难度比较高。 </p>
<p>阻塞 IO应用特点: </p>
<p>与 IO 多路复用相比，阻塞 IO 每处理一个 socket 的 IO 请求都会阻塞进程（线程），但使用难度较低。 </p>
<p>RPC框架应用： </p>
<p>RPC 调用在大多数的情况下，是一个高并发调用的场景， 在 RPC 框架的实现中，一般会选择 <strong>IO</strong> 多路复用的方式。 </p>
<h4 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h4><p>系统内核处理 IO 操作分为两个阶段：等待数据和拷贝数据。</p>
<p>等待数据，就是系统内核在等待网卡接收到数据后，把数据写到内核中。</p>
<p>拷贝数据，就是系统内核在获取到数据后，将数据拷贝到用户进程的空间中。</p>
<p>具体流程： </p>
<img src="/blog/2020/09/11/RPC%E5%8E%9F%E7%90%86/RPC%E5%8E%9F%E7%90%86/pic11.png" srcset="/blog/img/loading.gif" class>

<p>所谓的零拷贝，就是取消用户空间与内核空间之间的数据拷贝操作，应用进程每一次的读写操作，都可以通 过一种方式，让应用进程向用户空间写入或者读取数据，就如同直接向内核空间写入或者读取数据一样，再 通过DMA将内核中的数据拷贝到网卡，或将网卡中的数据copy到内核。</p>
<p>RPC框架中的零拷贝应用</p>
<p>Netty零拷贝主要体现在三个方面：</p>
<p>Netty的接收和发送ByteBuffer是采用DIRECT BUFFERS，使用堆外的直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝。如果采用传统堆内存（HEAP BUFFERS）进行Socket读写，JVM会将堆内存Buffer拷贝一份到直接内存中，然后写入Socket中。 </p>
<p>Netty提供了组合Buffer对象，也就是CompositeByteBuf 类，可以将 ByteBuf 分解为多个共享同一个 存储区域的 ByteBuf，避免了内存的拷贝。</p>
<img src="/blog/2020/09/11/RPC%E5%8E%9F%E7%90%86/RPC%E5%8E%9F%E7%90%86/pic12.png" srcset="/blog/img/loading.gif" class>

<p>Netty的文件传输采用了FileRegion 中包装 NIO 的 FileChannel.transferTo() 方法，它可以直接将文件缓冲区的数据发送到目标Channel，避免了传统通过循环write方式导致的内存拷贝问题。</p>
<p>零拷贝带来的作用就是避免没必要的 CPU 拷贝，减少了 CPU 在用户空间与内核空间之间的上下文切换，从而提升了网络通信效率与应用程序的整体性能。</p>
<h4 id="时间轮"><a href="#时间轮" class="headerlink" title="时间轮"></a>时间轮</h4><p>在Dubbo中，为增强系统的容错能力，会有相应的监听判断处理机制。比如RPC调用的超时机制的实现，消费者判断RPC调用是否超时，如果超时会将超时结果返回给应用层。在Dubbo最开始的实现中，是将所有的返回结果（DefaultFuture）都放入一个集合中，并且通过一个定时任务，每隔一定时间间隔就扫描所有的 future，逐个判断是否超时。</p>
<p>这样的实现方式虽然比较简单，但是存在一个问题就是会有很多无意义的遍历操作开销。比如一个RPC调用的超时时间是10秒，而设置的超时判定的定时任务是2秒执行一次，那么可能会有4次左右无意义的循环检测判 断操作。 为了解决上述场景中的类似问题，Dubbo借鉴Netty，引入了时间轮算法，减少无意义的轮询判断操作。</p>
<h5 id="时间轮原理"><a href="#时间轮原理" class="headerlink" title="时间轮原理"></a>时间轮原理</h5><p>时钟轮的实质上是参考了生活中的时钟跳动的原理，在时钟轮机制中，有时间槽和时钟轮的概念，时间槽就相当于时钟的刻度；而时钟轮就相当于指针跳动的一 个周期，我们可以将每个任务放到对应的时间槽位上。</p>
<p>如果时钟轮有 10 个槽位，而时钟轮一轮的周期是 10 秒，那么我们每个槽位的单位时间就是 1 秒，而下一层时间 轮的周期就是 100 秒，每个槽位的单位时间也就是 10 秒，这就好比秒针与分针， 在秒针周期下， 刻度单位为秒， 在分针周期下， 刻度为分。</p>
<img src="/blog/2020/09/11/RPC%E5%8E%9F%E7%90%86/RPC%E5%8E%9F%E7%90%86/pic13.png" srcset="/blog/img/loading.gif" class>

<h5 id="时间轮在RPC的应用"><a href="#时间轮在RPC的应用" class="headerlink" title="时间轮在RPC的应用"></a>时间轮在RPC的应用</h5><p>调用超时： 上面所讲的客户端调用超时的处理，就可以应用到时钟轮，我们每发一次请求，都创建一个处理请求超时的定时任务放到时钟轮里，在高并发、高访问量的情况下，时钟轮每次只轮询一个时间槽 位中的任务，这样会节省大量的 CPU。 </p>
<p>启动加载： 调用端与服务端启动也可以应用到时钟轮，比如说在服务启动完成之后要去加载缓存，执行定时任务等， 都可以放在时钟轮里。</p>
<p>定时心跳检测： RPC 框架调用端定时向服务端发送的心跳检测，来维护连接状态，我们可以将心跳的逻辑封装为一个心跳任务，放到时钟轮里。在定时任务逻辑结束的最后，再加上 一段逻辑， 重设这个任务的执行时间，把它重新丢回到时钟轮里。这样就可以实现循环执行。</p>
<h5 id="Dubbo中的时间轮原理"><a href="#Dubbo中的时间轮原理" class="headerlink" title="Dubbo中的时间轮原理"></a>Dubbo中的时间轮原理</h5><p>主要是通过Timer，Timeout，TimerTask几个接口定义了一个定时器的模型，再通过HashedWheelTimer这个类实现了一个时间轮定时器（默认的时间槽的数量是512，可以自定义这个值）。它对外提供了简单易用的接口，只需要调用newTimeout接口，就可以实现对只需执行一次任务的调度。通过该定时器，Dubbo在响应的场景中实现了高效的任务调度。 </p>
<h3 id="RPC的运用"><a href="#RPC的运用" class="headerlink" title="RPC的运用"></a>RPC的运用</h3><h4 id="基于Dubbo分布式高并发场景下的运用要点"><a href="#基于Dubbo分布式高并发场景下的运用要点" class="headerlink" title="基于Dubbo分布式高并发场景下的运用要点"></a>基于Dubbo分布式高并发场景下的运用要点</h4><h5 id="异步处理机制"><a href="#异步处理机制" class="headerlink" title="异步处理机制"></a>异步处理机制</h5><p>如果采用同步调用， CPU 大部分的时间都在等待而没有去计算，从而导致 CPU 的利用率不够。 在大多数情况下，RPC 本身处理请求的效率是在毫秒级的，请求的耗时大部分都是业务耗时。</p>
<p>实现异步的常用方式有两种：</p>
<ul>
<li>Future方式，返回Future对象，通过get方法获取结果，</li>
<li>Callable方式，处理完业务逻辑后，回调传入的Callable中的方法</li>
</ul>
<p>DUBBO框架的异步调用流程</p>
<img src="/blog/2020/09/11/RPC%E5%8E%9F%E7%90%86/RPC%E5%8E%9F%E7%90%86/pic14.png" srcset="/blog/img/loading.gif" class>

<p>DUBBO服务端会在业务处理时增加异步机制，来提升性能。</p>
<p>RPC 框架的异步策略主要是调用端异步与服务端异步。一般情况下调用端的异步就是通过 Future 方式， 服务端异步则通过 Callable 方式，来实现RPC调用的全异步化。</p>
<h5 id="路由与负载均衡"><a href="#路由与负载均衡" class="headerlink" title="路由与负载均衡"></a>路由与负载均衡</h5><p>真实的环境中一般是以集群的方式提供服务，对于服务调用方来说，一个接口会有多个服务提供方同时提供服务，所以 RPC 在每次发起请求的时候，都需要从多个服务节点里面选取一个用于处理请求的服务节点。 这就需要在RPC应用中增加路由功能，来实现节点的选择。</p>
<p>节点选择时需要通过特定的条件从服务提供方节点集合中挑选合适的节点，这个就是路由策略。</p>
<p>路由流程：接收请求–&gt;请求校验–&gt;路由策略–&gt;负载均衡–&gt; </p>
<p>使用了 IP 路由策略后，整个集群的调用拓扑如下图所示：</p>
<img src="/blog/2020/09/11/RPC%E5%8E%9F%E7%90%86/RPC%E5%8E%9F%E7%90%86/pic15.png" srcset="/blog/img/loading.gif" class>

<p>有些场景下，可能还需要更细粒度的路由方式，比如说根据SESSIONID要落到相同的服务节点上以保持会话的有效性; </p>
<p>这时可以考虑采用参数化路由：</p>
<img src="/blog/2020/09/11/RPC%E5%8E%9F%E7%90%86/RPC%E5%8E%9F%E7%90%86/pic16.png" srcset="/blog/img/loading.gif" class>

<p>RPC框架中的负载均衡</p>
<p> RPC 的负载均衡是由 RPC 框架自身提供实现，自主选择一个最佳的服务节点，发起 RPC 调用请求。</p>
<img src="/blog/2020/09/11/RPC%E5%8E%9F%E7%90%86/RPC%E5%8E%9F%E7%90%86/pic17.png" srcset="/blog/img/loading.gif" class>

<p>RPC 负载均衡策略一般包括轮询、随机、权重、最少连接等。Dubbo默认就是使用随机负载均衡策略。 </p>
<p>自适应的负载均衡策略</p>
<p>RPC 的负载均衡完全由 RPC 框架自身实现，通过所配置的负载均衡组件，自主选择合适服务节点。这个就是自适应的负载均衡策略。</p>
<p>主要步骤： </p>
<ol>
<li><p>添加计分器和指标采集器。 </p>
</li>
<li><p>指标采集器收集服务节点 CPU 核数、CPU 负载以及内存占用率等指标。 </p>
</li>
<li><p>可以配置开启哪些指标采集器，并设置这些参考指标的具体权重。 </p>
</li>
<li><p>通过对服务节点的综合打分，最终计算出服务节点的实际权重，选择合适的服务节点。 </p>
</li>
</ol>
<img src="/blog/2020/09/11/RPC%E5%8E%9F%E7%90%86/RPC%E5%8E%9F%E7%90%86/pic18.png" srcset="/blog/img/loading.gif" class>

<h5 id="熔断限流"><a href="#熔断限流" class="headerlink" title="熔断限流"></a>熔断限流</h5><p>实际生产环境中，每个服务节点都可能由于访问量过大而引起一系列问题，就需要业务提供方能够进行自我保护，从而保证在高访问量、高并发的场景下，系统依然能够稳定，高效运行。</p>
<h6 id="服务端的自我保护实现"><a href="#服务端的自我保护实现" class="headerlink" title="服务端的自我保护实现"></a>服务端的自我保护实现</h6><img src="/blog/2020/09/11/RPC%E5%8E%9F%E7%90%86/RPC%E5%8E%9F%E7%90%86/pic19.png" srcset="/blog/img/loading.gif" class>

<p>在Dubbo框架中， 可以通过Sentinel来实现更为完善的熔断限流功能，限流逻辑有很多种， 最简单的是计数器，还有平滑限流的滑动窗口、漏斗算法以及令牌桶算法等等。Sentinel采用的是滑动窗口来实现的限流。</p>
<img src="/blog/2020/09/11/RPC%E5%8E%9F%E7%90%86/RPC%E5%8E%9F%E7%90%86/pic20.png" srcset="/blog/img/loading.gif" class>

<p>初始的时候arrays数组中只有一个窗口，每个时间窗口的长度是500ms，这就意味着只要当前时间与时间窗口的差值在500ms之内，时间窗口就不会向前滑动。</p>
<img src="/blog/2020/09/11/RPC%E5%8E%9F%E7%90%86/RPC%E5%8E%9F%E7%90%86/pic21.png" srcset="/blog/img/loading.gif" class>

<p>时间继续往前走，当超过500ms时，时间窗口就会向前滑动到下一个，这时就会更新当前窗口的开始时间。</p>
<p>在当前时间点中进入的请求，会被统计到当前时间所对应的时间窗口中。</p>
<h6 id="调用方的自我保护"><a href="#调用方的自我保护" class="headerlink" title="调用方的自我保护"></a>调用方的自我保护</h6><p>一个服务 A 调用服务 B 时，服务 B 的业务逻辑又调用了服务 C，这时服务 C 响应超时，服务 B 就可能会因为堆积大量请求而导致服务宕机，由此产生服务雪崩的问题。</p>
<p>熔断处理流程：</p>
<img src="/blog/2020/09/11/RPC%E5%8E%9F%E7%90%86/RPC%E5%8E%9F%E7%90%86/pic22.png" srcset="/blog/img/loading.gif" class>

<p>熔断机制： 熔断器的工作机制主要是关闭、打开和半打开这三个状态之间的切换。</p>
<p> Sentinel 熔断降级组件它可以支持以下降级策略： </p>
<ul>
<li>平均响应时间 ( DEGRADE_GRADE_RT )：当 1s 内持续进入 N 个请求，对应时刻的平均响应时间（秒级）均超过阈值（ count ，以 ms 为单位），那么在接下的时间窗口（ DegradeRule 中的 timeWindow ，以 s 为单位）之内，对这个方法的调用都会自动地熔断（抛出 DegradeException ）。注意 Sentinel 默认统计的 RT 上限是 4900 ms，超出此阈值的都会算作 4900 ms，若需要变更此上限可以通过启动配置项 - csp.sentinel.statistic.max.rt=xxx 来配置。 </li>
<li>异常比例 ( DEGRADE_GRADE_EXCEPTION_RATIO )：当资源的每秒请求量 &gt;= N（可配置），并且每秒异常总数占通过量的比值超过阈值（ DegradeRule 中的 count ）之后，资源进入降级状态，即在接下的时间窗口（ DegradeRule 中的 timeWindow ，以 s 为单位）之内，对这个方法的调用都会自动地返回。异常比率的阈值范围是 [0.0, 1.0] ，代表 0% - 100%。 </li>
<li>异常数 ( DEGRADE_GRADE_EXCEPTION_COUNT )：当资源近 1 分钟的异常数目超过阈值之后会进行熔断。注意由于统计时间窗口是分钟级别的，若 timeWindow 小于 60s，则结束熔断状态后仍可能再进入熔断状态。 </li>
</ul>
<h5 id="优雅启动"><a href="#优雅启动" class="headerlink" title="优雅启动"></a>优雅启动</h5><p>启动预热就是让刚启动的服务，不直接承担全部的流量，而是让它随着时间的移动慢慢增加调用次数，最终让流量缓和运行一段时间后达到正常水平。 </p>
<p>首先要知道服务提供方的启动时间，有两种获取方法： </p>
<ul>
<li><p>一种是服务提供方在启动的时候，主动将启动的时间发送给注册中心； </p>
</li>
<li><p>另一种就是注册中心来检测， 将服务提供方的请求注册时间作为启动时间。</p>
</li>
</ul>
<p>调用方通过服务发现获取服务提供方的启动时间， 然后进行降权，减少被负载均衡选择的概率，从而实现预热的过程。</p>
<p>在Dubbo框架中也引入了”warmup”特性，在com.alibaba.dubbo.rpc.cluster.loadbalance.AbstractLoadBalance.java中： </p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractLoadBalance</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">LoadBalance</span> </span>&#123;
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * Calculate the weight according to the uptime proportion of warmup time</span>
<span class="hljs-comment">     * the new weight will be within 1(inclusive) to weight(inclusive)</span>
<span class="hljs-comment">     *</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> uptime the uptime in milliseconds</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> warmup the warmup time in milliseconds</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> weight the weight of an invoker</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@return</span> weight which takes warmup into account</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calculateWarmupWeight</span><span class="hljs-params">(<span class="hljs-keyword">int</span> uptime, <span class="hljs-keyword">int</span> warmup, <span class="hljs-keyword">int</span> weight)</span> </span>&#123;
      	<span class="hljs-comment">// 随着provider的启动时间越来越长，慢慢提升权重weight</span>
        <span class="hljs-keyword">int</span> ww = (<span class="hljs-keyword">int</span>) ((<span class="hljs-keyword">float</span>) uptime / ((<span class="hljs-keyword">float</span>) warmup / (<span class="hljs-keyword">float</span>) weight));
        <span class="hljs-keyword">return</span> ww &lt; <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : (ww &gt; weight ? weight : ww);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">Invoker&lt;T&gt; <span class="hljs-title">select</span><span class="hljs-params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (CollectionUtils.isEmpty(invokers)) &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
        &#125;
        <span class="hljs-keyword">if</span> (invokers.size() == <span class="hljs-number">1</span>) &#123;
            <span class="hljs-keyword">return</span> invokers.get(<span class="hljs-number">0</span>);
        &#125;
        <span class="hljs-keyword">return</span> doSelect(invokers, url, invocation);
    &#125;

    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> &lt;T&gt; <span class="hljs-function">Invoker&lt;T&gt; <span class="hljs-title">doSelect</span><span class="hljs-params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span></span>;


    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * Get the weight of the invoker&#x27;s invocation which takes warmup time into account</span>
<span class="hljs-comment">     * if the uptime is within the warmup time, the weight will be reduce proportionally</span>
<span class="hljs-comment">     *</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> invoker    the invoker</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> invocation the invocation of this invoker</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@return</span> weight</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getWeight</span><span class="hljs-params">(Invoker&lt;?&gt; invoker, Invocation invocation)</span> </span>&#123;
        <span class="hljs-comment">// 先得到Provider的权重</span>
        <span class="hljs-keyword">int</span> weight = invoker.getUrl().getMethodParameter(invocation.getMethodName(), WEIGHT_KEY, DEFAULT_WEIGHT);
        <span class="hljs-keyword">if</span> (weight &gt; <span class="hljs-number">0</span>) &#123;
          	<span class="hljs-comment">// 得到provider的启动时间戳</span>
            <span class="hljs-keyword">long</span> timestamp = invoker.getUrl().getParameter(REMOTE_TIMESTAMP_KEY, <span class="hljs-number">0L</span>);
            <span class="hljs-keyword">if</span> (timestamp &gt; <span class="hljs-number">0L</span>) &#123;
              	<span class="hljs-comment">// provider已经运行时间</span>
                <span class="hljs-keyword">int</span> uptime = (<span class="hljs-keyword">int</span>) (System.currentTimeMillis() - timestamp);
              	<span class="hljs-comment">// 得到warmup的值，默认为10分钟</span>
                <span class="hljs-keyword">int</span> warmup = invoker.getUrl().getParameter(WARMUP_KEY, DEFAULT_WARMUP);
              	<span class="hljs-comment">// provider运行时间少于预热时间，那么需要重新计算权重weight（即需要降权）</span>
                <span class="hljs-keyword">if</span> (uptime &gt; <span class="hljs-number">0</span> &amp;&amp; uptime &lt; warmup) &#123;
                    weight = calculateWarmupWeight(uptime, warmup, weight);
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> weight &gt;= <span class="hljs-number">0</span> ? weight : <span class="hljs-number">0</span>;
    &#125;

&#125;</code></pre>

<p>执行策略： 如果provider运行了1分钟，那么weight为10，承担10%流量； 如果provider运行了2分钟，那么weight为20，承担20%流量； 如果provider运行了5分钟，那么weight为50，承担50%流量。</p>
<h5 id="优雅关闭"><a href="#优雅关闭" class="headerlink" title="优雅关闭"></a>优雅关闭</h5><p>主要是为了应对调用目标服务已经下线、或正在关闭中的情况。</p>
<img src="/blog/2020/09/11/RPC%E5%8E%9F%E7%90%86/RPC%E5%8E%9F%E7%90%86/pic23.png" srcset="/blog/img/loading.gif" class>

<p>常用的解决方式是设置请求“挡板”，挡板的作用就是告诉调用方，服务提供方已经开始进入关闭流程了，不能再处理其他请求了。 </p>
<p>当服务提供方正在关闭，可以直接返回一个特定的异常给调用方。然后调用方把这个节点从健康列表挪出，并把其他请求自动重试到其他节点。如需更为完善，可以再加上主动通知机制。</p>
<p>在Dubbo框架中， 在以下场景中会触发优雅关闭： </p>
<ul>
<li><p>JVM主动关闭( System.exit(int) </p>
</li>
<li><p>JVM由于资源问题退出( OOM )</p>
</li>
<li><p> 应用程序接受到进程正常结束信号： </p>
</li>
<li><p>SIGTERM 或 SIGINT 信号。 </p>
</li>
</ul>
<p>优雅停机是默认开启的，停机等待时间为10秒。可以通过配置 dubbo.service.shutdown.wait 来修改等待时间。 </p>
<p>Dubbo 推出了多段关闭的方式来保证服务完全无损。 </p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/blog/categories/RPC%E5%8E%9F%E7%90%86/">RPC原理</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/blog/tags/RPC/">RPC</a>
                    
                      <a class="hover-with-bg" href="/blog/tags/dubbo/">dubbo</a>
                    
                      <a class="hover-with-bg" href="/blog/tags/SpringCloudAlibaba/">SpringCloudAlibaba</a>
                    
                  </div>
                
              </div>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/blog/2020/09/12/RPC%E5%8E%9F%E7%90%86/zookeeper%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Zookeeper深入剖析</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/blog/2020/08/26/%E7%BC%93%E5%AD%98/RESTful%E5%AE%89%E5%85%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">
                        <span class="hidden-mobile">RESTful安全解决方案</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":200})
    NProgress.start()
    document.addEventListener('DOMContentLoaded', function() {
      window.NProgress && window.NProgress.inc();
    })
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.staticfile.org/jquery/3.5.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/js/bootstrap.min.js" ></script>
<script  src="/blog/js/debouncer.js" ></script>
<script  src="/blog/js/events.js" ></script>
<script  src="/blog/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/blog/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.staticfile.org/tocbot/4.12.0/tocbot.min.js" ></script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>





  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/blog/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/blog/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/blog/js/boot.js" ></script>



</body>
</html>
