<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="">
  <meta name="keywords" content="">
  <title>JVM的垃圾回收算法与垃圾回收器 - zgcheng&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/5.12.1/css/all.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/mdbootstrap/4.13.0/css/mdb.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/3.0.1/github-markdown.min.css" />

<link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">



  <link  rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css" />

<link  rel="stylesheet" href="/css/main.css" />


  <link defer rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />


<!-- 自定义样式保持在最底部 -->


<meta name="generator" content="Hexo 4.1.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>zgcheng's blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">归档</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/">分类</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">标签</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about">关于</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
                <p class="mt-3 post-meta">
                  <i class="fas fa-calendar-alt" aria-hidden="true"></i>
                  星期一, 三月 9日 2020, 5:40 下午
                </p>
              

              <p class="mt-1">
                
                  
                  <span class="post-meta">
                    <i class="far fa-chart-bar"></i>
                    6.4k 字
                  </span>
                

                
                  
                  <span class="post-meta">
                      <i class="far fa-clock"></i>
                      23 分钟
                  </span>
                

                
                  <!-- 不蒜子统计文章PV -->
                  
                  <span id="busuanzi_container_page_pv" class="post-meta" style="display: none">
                    <i class="far fa-eye" aria-hidden="true"></i>
                    <span id="busuanzi_value_page_pv"></span> 次
                  </span>
                
              </p>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5 z-depth-3" id="board">
          <div class="post-content mx-auto" id="post">
            
              <p
                class="note note-warning">本文最后更新于：星期一, 五月 18日 2020, 12:33 下午</p>
            
            <div class="markdown-body">
              <h2 id="垃圾回收的区域"><a href="#垃圾回收的区域" class="headerlink" title="垃圾回收的区域"></a>垃圾回收的区域</h2><p>栈中的生命周期是跟随线程，所以一般不需要关注，堆中的对象是垃圾回收的重点，方法区/元空间也会发生垃圾回收，不过这块的效率比较低，一般不是我们关注的重点</p>
<h2 id="GC判断对象的存活"><a href="#GC判断对象的存活" class="headerlink" title="GC判断对象的存活"></a>GC判断对象的存活</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。（Python在用，但主流虚拟机没有使用）</p>
<p>优点：快，方便，实现简单。</p>
<p>缺陷：对象相互引用时（A.instance=B同时B.instance=A），很难判断对象是否该回收。</p>
<h3 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h3><p>这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。</p>
<p>作为GC Roots的对象包括下面几种：</p>
<ul>
<li><p>当前虚拟机栈中局部变量表中的引用的对象</p>
</li>
<li><p>当前本地方法栈中局部变量表中的引用的对象</p>
</li>
<li><p>方法区中类静态属性引用的对象</p>
</li>
<li><p>方法区中的常量引用的对象</p>
</li>
</ul>
<p>注意：当垃圾回收器将要回收对象所占内存之前会调用finalize()方法，让此对象处理它生前的最后事情（这个对象可以趁这个时机挣脱死亡的命运）。finalize()可以完成对象的拯救，但是JVM不保证一定能执行。</p>
<h2 id="引用（Reference）"><a href="#引用（Reference）" class="headerlink" title="引用（Reference）"></a>引用（Reference）</h2><p>传统定义：Reference中存储的数据代表的是一块内存的起始地址。</p>
<h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><p>即使内存不足，垃圾回收器也绝对不会回收GC Roots的强引用对象。</p>
<p>一般的Object obj = new Object() ，就属于强引用。</p>
<h3 id="软引用（SoftReference）"><a href="#软引用（SoftReference）" class="headerlink" title="软引用（SoftReference）"></a>软引用（SoftReference）</h3><p>垃圾回收器在内存充足的时候不会回收GC Roots 的软引用对象，而在内存不足时才会回收。</p>
<p>软引用非常适合于创建缓存。当系统内存不足的时候，缓存中的内容是可以被释放的。例如，一个程序用来处理用户提供的图片。如果将所有图片读入内存，这样虽然可以很快的打开图片，但内存空间使用巨大，一些使用较少的图片浪费内存空间，需要手动从内存中移除。如果每次打开图片都从磁盘文件中读取到内存再显示出来，虽然内存占用较少，但一些经常使用的图片每次打开都要访问磁盘，代价巨大。这个时候就可以用软引用构建缓存。</p>
<p>用软引用关联的对象，系统将要发生OOM之前，这些对象就会被回收。参见代码：</p>
<p>VM参数 -Xms10m -Xmx10m -XX:+PrintGC</p>
<pre><code>public class TestSoftRef {
    //对象
    public static class User{
        public int id = 0;
        public String name = &quot;&quot;;
        public User(int id, String name) {
            super();
            this.id = id;
            this.name = name;
        }
        @Override
        public String toString() {
            return &quot;User [id=&quot; + id + &quot;, name=&quot; + name + &quot;]&quot;;
        }

    }
    //
    public static void main(String[] args) {
        User u = new User(1,&quot;King&quot;); //new是强引用
        SoftReference&lt;User&gt; userSoft = new SoftReference&lt;User&gt;(u);
        u = null;//干掉强引用，确保这个实例只有userSoft的软引用
        System.out.println(userSoft.get()); //看一下这个对象是否还在
        System.gc();//进行一次GC垃圾回收  千万不要写在业务代码中。
        System.out.println(&quot;After gc&quot;);
        System.out.println(userSoft.get());
        //往堆中填充数据，导致OOM
        List&lt;byte[]&gt; list = new LinkedList&lt;&gt;();
        try {
            for(int i=0;i&lt;100;i++) {
                System.out.println(&quot;*************&quot;+userSoft.get());
                list.add(new byte[1024*1024*1]); //1M的对象
            }
        } catch (Throwable e) {
            //抛出了OOM异常时打印软引用对象
            System.out.println(&quot;Exception*************&quot;+userSoft.get());
        }

    }
}</code></pre><p>运行结果</p>
<img src="/2020/03/09/JVM%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/pic1.png" srcset="/img/loading.gif" class="">

<h3 id="弱引用-WeakReference"><a href="#弱引用-WeakReference" class="headerlink" title="弱引用 WeakReference"></a>弱引用 WeakReference</h3><p>垃圾回收器在扫描到弱引用的对象时，无论内存充足与否，都会回收该对象的内存。</p>
<p>一些有用（程度比软引用更低）但是并非必需，用弱引用关联的对象，只能生存到下一次垃圾回收之前，GC发生时，不管内存够不够都会被回收。</p>
<p>参看代码：</p>
<pre><code>public class TestWeakRef {
    public static class User{
        public int id = 0;
        public String name = &quot;&quot;;
        public User(int id, String name) {
            super();
            this.id = id;
            this.name = name;
        }
        @Override
        public String toString() {
            return &quot;User [id=&quot; + id + &quot;, name=&quot; + name + &quot;]&quot;;
        }

    }

    public static void main(String[] args) {
        User u = new User(1,&quot;King&quot;);
        WeakReference&lt;User&gt; userWeak = new WeakReference&lt;User&gt;(u);
        u = null;//干掉强引用，确保这个实例只有userWeak的弱引用
        System.out.println(userWeak.get());
        System.gc();//进行一次GC垃圾回收
        System.out.println(&quot;After gc&quot;);
        System.out.println(userWeak.get());
    }
}</code></pre><p><strong>注意：</strong>软引用 SoftReference和弱引用 WeakReference，可以用在内存资源紧张的情况下或者创建不是很重要的数据缓存。JDK中WeakHashMap和ThreadLocal中的key使用的就是弱引用。</p>
<h3 id="虚引用-PhantomReference"><a href="#虚引用-PhantomReference" class="headerlink" title="虚引用 PhantomReference"></a>虚引用 PhantomReference</h3><p>虚引用也被称为幽灵引用，是最弱的引用类型，在被垃圾回收的时候可以收到一个通知，主要被用来跟踪对象被垃圾回收器回收的活动。如果一个对象只具有虚引用，那么它和没有任何引用一样，任何时候都可能被回收。</p>
<h2 id="GC（Garbage-Collection）"><a href="#GC（Garbage-Collection）" class="headerlink" title="GC（Garbage Collection）"></a>GC（Garbage Collection）</h2><h3 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor GC"></a>Minor GC</h3><p><strong>特点</strong>：发生在新生代上，发生的较频繁，执行速度较快</p>
<p>触发条件： Eden区空间不足，空间分配担保成功</p>
<h3 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h3><p><strong>特点</strong>： 主要发生在老年代上（新生代也会回收），较少发生，执行速度较慢</p>
<p><strong>触发条件</strong>： </p>
<ul>
<li><p>调用 System.gc()</p>
</li>
<li><p>老年代区域空间不足</p>
</li>
<li><p>空间分配担保失败</p>
</li>
<li><p>JDK 1.7 及以前的永久代(方法区)空间不足</p>
</li>
<li><p>CMS GC处理浮动垃圾申请预留空间时，如果新生代空间不足，则采用空间分配担保机制，如果老年代空间不足，则触发Full GC</p>
</li>
</ul>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="复制算法（Copying）"><a href="#复制算法（Copying）" class="headerlink" title="复制算法（Copying）"></a>复制算法（Copying）</h3><p>将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。这块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间全部清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为了原来的一半。</p>
<p>新生代中的对象98%是“朝生夕死”的，所以一般来说回收占据10%的空间够用了，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。</p>
<p>HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存会被“浪费”。</p>
<h3 id="标记-清除算法（Mark-Sweep）"><a href="#标记-清除算法（Mark-Sweep）" class="headerlink" title="标记-清除算法（Mark-Sweep）"></a>标记-清除算法（Mark-Sweep）</h3><p>首先标记所有需要回收的对象 ，之后统一回收被标记的对象。缺点是相对于复制算法标记和清除效率都不高，而且会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p>
<h3 id="标记-整理算法（Mark-Compact）"><a href="#标记-整理算法（Mark-Compact）" class="headerlink" title="标记-整理算法（Mark-Compact）"></a>标记-整理算法（Mark-Compact）</h3><p>首先标记出所有需要回收的对象，在标记完成后，后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。缺点是效率相对标记-清除会更低一点。</p>
<h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><h3 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h3><p>根据各个年代的特点选取不同的垃圾收集算法：新生代使用复制算法，老年代使用标记-整理或者标记-清除算法。</p>
<p>在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。</p>
<p>而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。</p>
<h3 id="各种垃圾回收器"><a href="#各种垃圾回收器" class="headerlink" title="各种垃圾回收器"></a>各种垃圾回收器</h3><h4 id="Serial-Serial-Old"><a href="#Serial-Serial-Old" class="headerlink" title="Serial/Serial Old"></a>Serial/Serial Old</h4><p>最古老、成熟的单线程（独占式）收集器，适用于单CPU 服务器。</p>
<p>Serial采用<strong>复制算法</strong>回收区域为新生代，Serial Old使用<strong>标记整理算法</strong>回收区域为老年代。</p>
<h4 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h4><p>和Serial基本没区别，唯一的区别在于ParNew是并行收集器，停顿时间比Serial少。</p>
<p>并行是指垃圾收集的多线程的同时进行。</p>
<p>ParNew回收区域为<strong>新生代</strong>，算法为<strong>复制算法</strong>。</p>
<h4 id="Parallel-Scavenge（ParallerGC）-Parallel-Old"><a href="#Parallel-Scavenge（ParallerGC）-Parallel-Old" class="headerlink" title="Parallel Scavenge（ParallerGC）/Parallel Old"></a>Parallel Scavenge（ParallerGC）/Parallel Old</h4><p>注重于吞吐量的并行收集器，高吞吐量可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台计算为主没有太多交互的任务。</p>
<p>吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间），虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</p>
<p>Parallel Scavenge（ParallerGC）采用<strong>复制算法</strong>，回收的区域为新生代、Parallel Old采用<strong>标记整理算法</strong>，回收区域为老年代。</p>
<h4 id="Concurrent-Mark-Sweep-（CMS）"><a href="#Concurrent-Mark-Sweep-（CMS）" class="headerlink" title="Concurrent Mark Sweep （CMS）"></a>Concurrent Mark Sweep （CMS）</h4><p>以获取最短回收停顿时间为目标的并行与并发收集器。</p>
<p>并发是指垃圾收集的多线程和应用的多线程同时进行，不支持并发的收集器在回收时会暂停所有用户线程（STW -Stop the world）。</p>
<p>目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。</p>
<p>从名字（包含“Mark Sweep”）上就可以看出，CMS收集器是基于<strong>标记清除算法</strong>实现的，但它的运作过程相对于前面几种收集器来说更复杂一些，回收区域为<strong>老年代</strong>。</p>
<p><strong>收集过程</strong>：</p>
<ul>
<li><strong>初始标记：</strong>标记 GC Roots的直接关联到的对象，速度很快，需要暂停所有用户线程（STW -Stop the world）。</li>
<li><strong>并发标记：</strong>从GC Roots的直接关联的对象开始进行可达性分析，找到存活对象，它在整个回收过程中耗时最长，不需要停顿。</li>
<li><strong>重新标记：</strong>由于并发标记期间用户线程继续运作而导致部分对象的标记记录产生变动，需要停顿(STW)来修正这部分标记记录。停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。</li>
<li><strong>并发清除：</strong>不需要停顿。</li>
</ul>
<img src="/2020/03/09/JVM%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/pic3.png" srcset="/img/loading.gif" class="">

<p>在整个过程中耗时最长的并发标记、并发清除，收集器线程可以与用户线程一起工作，所以总体上说CMS收集器的内存回收过程是与用户线程一起并发执行的。</p>
<p>由于采用标记 - 清除算法会导致产生不连续的空间碎片</p>
<p>在并发阶段多线程占据会占据比较多的CPU资源，如果CPU资源不足，效率会明显降低。</p>
<p>在CMS并发清理之前，标记过程之后用户线程继续运行产生的垃圾，CMS无法在当次收集中处理掉，只好留待下一次GC时再清理掉，这一部分垃圾就称为“浮动垃圾”。</p>
<p>由于浮动垃圾的存在，需要预留出一部分内存，这就意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。</p>
<p>在1.6的版本中老年代空间使用率阈值为92%</p>
<p>如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。</p>
<h4 id="G1（Garbage-First）垃圾回收器"><a href="#G1（Garbage-First）垃圾回收器" class="headerlink" title="G1（Garbage First）垃圾回收器"></a>G1（Garbage First）垃圾回收器</h4><p>G1（Garbage First）收集器是当今垃圾回收技术最前沿的成果之一。同CMS收集器一样，G1也是关注最小时延的<strong>并行与并发收集器</strong>，也同样适合大尺寸堆内存的垃圾收集，官方也推荐使用G1来代替选择CMS。</p>
<p>G1最大的特点是引入分区的思路，弱化了分代的概念，合理利用垃圾收集各个周期的资源，解决了其他收集器甚至CMS的众多缺陷。</p>
<p>G1 把堆划分成多个大小相等的独立区域（Region），每个独立区域会被标记为Eden/Survivor/Old/Humongous（用于存储大对象）中的一个，并使用标记—整理 （humongous） 和复制回收算法(survivor)，避免产生内存碎片。</p>
<img src="/2020/03/09/JVM%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/pic4.png" srcset="/img/loading.gif" class="">

<p>G1可以将可以将停顿（STW）的时间尽可能的控制在设置的时间之内。</p>
<p>G1收集器之所以能建立可控制的停顿时间模型，是因为它可以避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region（这也就是Garbage-First名称的来由）。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。</p>
<h5 id="G1-GC模式"><a href="#G1-GC模式" class="headerlink" title="G1 GC模式"></a>G1 GC模式</h5><h6 id="Young-GC"><a href="#Young-GC" class="headerlink" title="Young GC"></a>Young GC</h6><p>选定所有年轻代里的Region。通过控制年轻代的region个数，即年轻代内存大小，来控制young GC（复制回收算法）的时间开销。</p>
<h6 id="Mixed-GC"><a href="#Mixed-GC" class="headerlink" title="Mixed GC"></a>Mixed GC</h6><p>选定所有年轻代里的Region，外加根据全局并发标记（global concurrent marking）统计得出收集收益高的若干老年代Region。在用户指定的开销目标范围内尽可能选择收益高的老年代Region。</p>
<p>Mixed GC不是full GC，它只能回收部分老年代的Region。如果mixed GC实在无法跟上程序分配内存的速度，导致老年代填满无法继续进行Mixed GC，就会使用serial old GC（full GC）来收集整个GC heap。所以我们可以知道，G1是不提供full GC的。</p>
<h5 id="全局并发标记（global-concurrent-marking）"><a href="#全局并发标记（global-concurrent-marking）" class="headerlink" title="全局并发标记（global concurrent marking）"></a>全局并发标记（global concurrent marking）</h5><p><strong>初始标记：</strong>仅仅只是标记一下GC Roots 能直接关联到的对象，并且修改TAMS（Nest Top Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可以的Region中创建对象，此阶段需要停顿线程(STW)，但耗时很短。</p>
<p><strong>并发标记：</strong>对堆中直接关联到GC Roots之外的所有对象进行可达性分析，找到存活对象，此阶段耗时较长，但可与用户程序并发执行。</p>
<p><strong>最终标记：</strong>为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程(STW)，可并行执行。</p>
<p><strong>筛选回收：</strong>首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</p>
<img src="/2020/03/09/JVM%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/pic5.png" srcset="/img/loading.gif" class="">

<h5 id="G1-GC主要的参数"><a href="#G1-GC主要的参数" class="headerlink" title="G1 GC主要的参数"></a>G1 GC主要的参数</h5><table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>-XX:G1HeapRegionSize=n</td>
<td>设置Region大小，并非最终值</td>
</tr>
<tr>
<td>-XX:MaxGCPauseMillis</td>
<td>设置G1收集过程目标时间，默认值200ms，不是硬性条件</td>
</tr>
<tr>
<td>-XX:G1NewSizePercent</td>
<td>新生代最小值，默认值5%</td>
</tr>
<tr>
<td>-XX:G1MaxNewSizePercent</td>
<td>新生代最大值，默认值60%</td>
</tr>
<tr>
<td>-XX:ParallelGCThreads</td>
<td>STW期间，并行GC线程数</td>
</tr>
<tr>
<td>-XX:ConcGCThreads=n</td>
<td>并发标记阶段，并行执行的线程数</td>
</tr>
<tr>
<td>-XX:InitiatingHeapOccupancyPercent</td>
<td>设置触发标记周期的 Java 堆占用率阈值。默认值是45%。这里的java堆占比指的是non_young_capacity_bytes，包括old+humongous</td>
</tr>
</tbody></table>
<h4 id="新一代垃圾回收器-ZGC"><a href="#新一代垃圾回收器-ZGC" class="headerlink" title="新一代垃圾回收器-ZGC"></a>新一代垃圾回收器-ZGC</h4><p>Java 11推出了一个全新的垃圾收集器ZGC，它是由Oracle开发的，为实现以下几个目标而诞生的垃圾回收器：</p>
<ul>
<li>停顿时间不超过10ms</li>
<li>停顿时间不会因堆变大而变长</li>
<li>堆大小范围可支持几G到几T</li>
</ul>
<p>为了实现其目标（暂停时间和性能影响），ZGC使用了两种新的热点垃圾收集器技术：指针着色和负载屏障。</p>
<h5 id="指针着色"><a href="#指针着色" class="headerlink" title="指针着色"></a>指针着色</h5><p>指针表示虚拟内存中字节的位置。 但是，我们不一定要使用指针的所有位来执行此操作 - 某些位可以表示指针的属性。 这就是我们所说的指针着色。</p>
<p>使用32位，我们可以处理4GB字节（2的32次方）。 由于现在配置的内存已经远远超过了这个数量，我们显然不能使用32位。 因此，ZGC使用64位指针， 这意味着ZGC仅适用于64位平台：</p>
<img src="/2020/03/09/JVM%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/pic1.png" srcset="/img/loading.gif" class="">

<p>ZGC指针使用42位来表示地址本身。 因此，ZGC指针可以处理4TB的内存空间（2的42次方）。</p>
<p>最重要的是，我们有4位来存储指针状态：</p>
<ul>
<li>finalizable bit：该对象只能通过终结器来访问</li>
<li>重映射位：参考指向对象的当前地址（下面的重定位）</li>
<li>marked0和marked1位：这些用于标记可到达的对象，我们还将这些位称为元数据位。</li>
</ul>
<h5 id="多重映射"><a href="#多重映射" class="headerlink" title="多重映射"></a>多重映射</h5><p>多重映射意味着我们将多个虚拟内存范围映射到物理内存。 在ZGC中，这些范围仅在前面提到的元数据位中不同。</p>
<p>指针着色使解除引用开销更加昂贵，因为我们必须屏蔽有用的位来访问地址本身。 但是，ZGC绕过这个成本，因为四个元数据位中只有一个是1。这样我们只有四个范围要映射，映射由操作系统处理。 此外，我们只使用其中三个范围，因为我们从不想取消引用可终结指针：</p>
<h5 id="负载屏障"><a href="#负载屏障" class="headerlink" title="负载屏障"></a>负载屏障</h5><p>负载屏障是一个代码片段，它在线程从堆加载引用时运行，例如，当我们访问对象的非基本字段时。</p>
<img src="/2020/03/09/JVM%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/pic2.png" srcset="/img/loading.gif" class="">

<p>在上面的代码中，第一行（String name = person.name;）这行会对堆中对象数据的Person引用之后，然后加载对其所包含名称的引用，这时会触发负载屏障。</p>
<p>第二行触发打印到屏幕，不会直接导致负载屏障触发，因为引用名称(name)是局部变量，因此没有从堆加载引用。</p>
<p>在ZGC中，负载障碍检查引用的元数据位。 根据这些位，ZGC可能会在我们获得它之前对引用执行一些处理。 因此，它可能产生完全不同的引用。</p>
<h5 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h5><p>标记是垃圾收集器确定我们可以到达哪些对象的过程。 我们无法达到的被认为是垃圾。 ZGC将标记分为三个阶段：</p>
<ul>
<li><p>第一阶段是Stop The World阶段。 在这个阶段，我们寻找根引用并标记它们。 根引用是到达堆中对象的起点，例如，局部变量或静态字段。 由于根引用的数量通常较小，因此该阶段很短。</p>
</li>
<li><p>下一阶段是并发阶段。 在这个阶段，我们从根引用开始遍历对象图。 我们标记我们到达的每个对象。 此外，当负载屏障检测到未标记的引用时，也会进行标记。</p>
</li>
<li><p>最后阶段也是Stop The World阶段，用来处理一些边缘情况，比如弱引用。</p>
</li>
</ul>
<p>这几个阶段完成后，我们就知道哪些对象可达，哪些对象不可达。</p>
<p>ZGC使用marked0和marked1元数据位进行标记。</p>
<h5 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h5><p>当我们必须为新对象分配内存时，我们可以遵循两种策略。</p>
<p>首先，我们可以扫描内存中的可用空间，直到有空间间足以容纳我们的对象。但是扫描内存是一项昂贵的操作，此外，内存将变得碎片化。如果我们想要减小碎片化，让内存变得更紧凑，将消耗更多的CPU处理能力。</p>
<p>另一种策略是频繁地将碎片存储区域中的对象以更紧凑的格式重定位到空闲区域。为了更有效，我们将内存空间分成块。我们要么将所有对象重新定位到一个块中的或者一个块不存在一个对象。这样，内存分配会更快，因为我们知道内存中有整个空块。</p>
<p>在ZGC，重定位也包括三个阶段。</p>
<ul>
<li>并发阶段查找我们要重定位的块并将它们放入重定位集中。</li>
<li>Stop The World阶段将重定位集中的所有根引用进行重定位并更新其引用。</li>
<li>并发阶段将重定位集中的所有剩余对象进行重定位，并在转发表中存储旧地址和新地址之间的映射。</li>
</ul>
<h5 id="重新映射"><a href="#重新映射" class="headerlink" title="重新映射"></a>重新映射</h5><p>请注意，在重定位阶段，我们没有重写对重定位对象的所有引用。 因此，使用这些引用，我们将无法访问我们想要的对象。 更糟糕的是，我们会访问到垃圾对象。</p>
<p>ZGC使用负载屏障来解决这个问题。 负载屏障使用称为重新映射的技术来修复指向重定位对象的引用。</p>
<h5 id="如何启用ZGC？"><a href="#如何启用ZGC？" class="headerlink" title="如何启用ZGC？"></a>如何启用ZGC？</h5><p>运行我们的应用程序时，我们可以使用以下命令行选项启用ZGC：</p>
<p>-XX：+ UnlockExperimentalVMOptions -XX：+ UseZGC 请注意，目前ZGC是一个实验性GC，在生产平台上使用，还需要再考察。</p>
<h3 id="垃圾回收器之间的对应关系"><a href="#垃圾回收器之间的对应关系" class="headerlink" title="垃圾回收器之间的对应关系"></a>垃圾回收器之间的对应关系</h3><img src="/2020/03/09/JVM%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/pic2.png" srcset="/img/loading.gif" class="">

<h3 id="垃圾回收器的重要参数"><a href="#垃圾回收器的重要参数" class="headerlink" title="垃圾回收器的重要参数"></a>垃圾回收器的重要参数</h3><table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>-XX:UseSerialGC</td>
<td>虚拟机运行在Client模式下的默认值，打开此开关后，使用 Serial+Serial Old 的收集器组合进行内存回收</td>
</tr>
<tr>
<td>-XX:UseParNewGC</td>
<td>打开此开关后，使用 ParNew + Serial Old 的收集器组合进行内存回收</td>
</tr>
<tr>
<td>-XX:UseConcMarkSweepGC</td>
<td>打开此开关后，使用 ParNew + CMS + Serial Old 的收集器组合进行内存回收。Serial Old 收集器将作为 CMS 收集器出现 Concurrent Mode Failure 失败后的后备收集器使用</td>
</tr>
<tr>
<td>-XX:UseParallelGC</td>
<td>虚拟机运行在 Server 模式下的默认值，打开此开关后，使用 Parallel Scavenge + Serial Old(PS MarkSweep) 的收集器组合进行内存回收</td>
</tr>
<tr>
<td>-XX:UseParallelOldGC</td>
<td>打开此开关后，使用 Parallel Scavenge + Parallel Old 的收集器组合进行内存回收</td>
</tr>
<tr>
<td>-XX:SurvivorRatio</td>
<td>新生代中 Eden 区域与 Survivor 区域的容量比值，默认为8，代表 Eden : Survivor = 8 : 1</td>
</tr>
<tr>
<td>-XX:PretenureSizeThreshold</td>
<td>直接晋升到老年代的对象大小，设置这个参数后，大于这个参数的对象将直接在老年代分配</td>
</tr>
<tr>
<td>-XX:MaxTenuringThreshold</td>
<td>晋升到老年代的对象年龄，每个对象在坚持过一次 Minor GC 之后，年龄就增加1，当超过这个参数值时就进入老年代</td>
</tr>
<tr>
<td>-XX:UseAdaptiveSizePolicy</td>
<td>动态调整 Java 堆中各个区域的大小以及进入老年代的年龄</td>
</tr>
<tr>
<td>-XX:HandlePromotionFailure</td>
<td>是否允许分配担保失败，即老年代的剩余空间不足以应付新生代的整个 Eden 和 Survivor 区的所有对象都存活的极端情况</td>
</tr>
<tr>
<td>-XX:ParallelGCThreads</td>
<td>设置并行GC时进行内存回收的线程数</td>
</tr>
<tr>
<td>-XX:GCTimeRatio</td>
<td>GC 时间占总时间的比率，默认值为99，即允许 1% 的GC时间，仅在使用 Parallel Scavenge 收集器生效</td>
</tr>
<tr>
<td>-XX:MaxGCPauseMillis</td>
<td>设置 GC 的最大停顿时间，仅在使用 Parallel Scavenge 收集器时生效</td>
</tr>
<tr>
<td>-XX:CMSInitiatingOccupancyFraction</td>
<td>设置 CMS 收集器在老年代空间被使用多少后触发垃圾收集，默认值为 68%，仅在使用 CMS 收集器时生效</td>
</tr>
<tr>
<td>-XX:UseCMSCompactAtFullCollection</td>
<td>设置 CMS 收集器在完成垃圾收集后是否要进行一次内存碎片整理，仅在使用 CMS 收集器时生效</td>
</tr>
<tr>
<td>-XX:CMSFullGCsBeforeCompaction</td>
<td>设置 CMS 收集器在进行若干次垃圾收集后再启动一次内存碎片整理，仅在使用 CMS 收集器时生效</td>
</tr>
</tbody></table>
<p>使用jps -v可以查看当前虚拟机参数</p>

            </div>
            <hr>
            <div>
              <p>
                
                  <span>
                <i class="iconfont icon-inbox"></i>
                    
                      <a class="hover-with-bg" href="/categories/JVM/">JVM</a>
                      &nbsp;
                    
                  </span>&nbsp;&nbsp;
                
                
                  <span>
                <i class="iconfont icon-tag"></i>
                    
                      <a class="hover-with-bg" href="/tags/JVM/">JVM</a>
                    
                      <a class="hover-with-bg" href="/tags/Java/">Java</a>
                    
                  </span>
                
              </p>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2020/03/12/JVM%E7%9A%84%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F/">
                        <i class="fa fa-chevron-left"></i>
                        <span class="hidden-mobile">JVM的执行子系统</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/03/07/JVM%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%86%E9%85%8D%E5%92%8C%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F/">
                        <span class="hidden-mobile">JVM对象的分配和访问方式</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="fa fa-chevron-right"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

              
                <!-- Comments -->
                <div class="comments" id="comments">
                  
                  

                </div>
              
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc-start"></div>
<div id="toc">
  <p class="h5"><i class="far fa-list-alt"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a class="z-depth-1" id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"> <b>Fluid</b></a>
    </div>
    
  <div>
    
      <!-- 不蒜子统计PV -->
      
      <span id="busuanzi_container_site_pv" style="display: none">
      总访问量 <span id="busuanzi_value_site_pv"></span> 次
    </span>
    
    
      <!-- 不蒜子统计UV -->
      
      <span id="busuanzi_container_site_uv" style="display: none">
      总访客数 <span id="busuanzi_value_site_uv"></span> 人
    </span>
    
  </div>


    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/popper.js/1.16.1/umd/popper.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="https://cdn.staticfile.org/mdbootstrap/4.13.0/js/mdb.min.js" ></script>
<script  src="/js/main.js" ></script>


  <script  src="/js/lazyload.js" ></script>



  
  <script  src="https://cdn.staticfile.org/tocbot/4.10.0/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var navHeight = $('#navbar').height();
      var toc = $('#toc');
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;
      var tocLimMax = 2 * boardTop + boardCtn.height();

      $(window).scroll(function () {
        var tocLimMin = $('#toc-start').offset().top - navHeight;
        var scroH = document.body.scrollTop + document.documentElement.scrollTop;

        if (tocLimMin <= scroH && scroH <= tocLimMax) {
          toc.css({
            'display': 'block',
            'position': 'fixed',
            'top': navHeight,
          });
        } else if (scroH <= tocLimMin) {
          toc.css({
            'position': '',
            'top': '',
          });
        } else if (scroH > tocLimMax) {
          toc.css('display', 'none');
        }
      });
      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '.post-content',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc > p').css('visibility', 'visible');
      }
      var offset = boardCtn.css('margin-right')
      $('#toc-ctn').css({
        'right': offset
      })
    });
  </script>





  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>



  <script defer src="https://cdn.staticfile.org/smoothscroll/1.4.10/SmoothScroll.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




<!-- Plugins -->


  

  

  

  

  

  



  <script  src="https://cdn.staticfile.org/prettify/188.0.0/prettify.min.js" ></script>
  <script>
    $(document).ready(function () {
      $('pre').addClass('prettyprint  linenums');
      prettyPrint();
    })
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "JVM的垃圾回收算法与垃圾回收器&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script defer src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <script>
    $("#post img:not(.no-zoom img, img[no-zoom])").each(
      function () {
        var element = document.createElement("a");
        $(element).attr("data-fancybox", "images");
        $(element).attr("href", $(this).attr("src"));
        $(this).wrap(element);
      }
    );
  </script>





  
  
    <script type="text/javascript">
      //定义获取词语下标
      var a_idx = 0;
      jQuery(document).ready(function ($) {
        //点击body时触发事件
        $("body").click(function (e) {
          //需要显示的词语
          var a = new Array("富强", "民主", "文明", "和谐", "自由", "平等", "公正", "法治", "爱国", "敬业", "诚信", "友善");
          //设置词语给span标签
          var $i = $("<span/>").text(a[a_idx]);
          //下标等于原来下标+1  余 词语总数
          a_idx = (a_idx + 1) % a.length;
          //获取鼠标指针的位置，分别相对于文档的左和右边缘。
          //获取x和y的指针坐标
          var x = e.pageX, y = e.pageY;
          //在鼠标的指针的位置给$i定义的span标签添加css样式
          $i.css({
            "z-index": 999,
            "top": y - 20,
            "left": x,
            "position": "absolute",
            "font-weight": "bold",
            "color": rand_color()
          });
          // 随机颜色
          function rand_color() {
            return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"
          }
          //在body添加这个标签
          $("body").append($i);
          //animate() 方法执行 CSS 属性集的自定义动画。
          //该方法通过CSS样式将元素从一个状态改变为另一个状态。CSS属性值是逐渐改变的，这样就可以创建动画效果。
          //详情请看http://www.w3school.com.cn/jquery/effect_animate.asp
          $i.animate({
            //将原来的位置向上移动180
            "top": y - 180,
            "opacity": 0
            //1500动画的速度
          }, 1500, function () {
            //时间到了自动删除
            $i.remove();
          });
        });
      })
      ;
    </script>
  








</body>
</html>
