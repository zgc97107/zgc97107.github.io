<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="">
  <meta name="keywords" content="">
  <title>JVM执行子程序 - zgcheng&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/5.12.1/css/all.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/mdbootstrap/4.13.0/css/mdb.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/3.0.1/github-markdown.min.css" />

<link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">



  <link  rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css" />

<link  rel="stylesheet" href="/css/main.css" />


  <link defer rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />


<!-- 自定义样式保持在最底部 -->


<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>zgcheng's blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">归档</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/">分类</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">标签</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about">关于</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
                <p class="mt-3 post-meta">
                  <i class="fas fa-calendar-alt" aria-hidden="true"></i>
                  星期四, 三月 12日 2020, 5:59 下午
                </p>
              

              <p class="mt-1">
                
                  
                  <span class="post-meta">
                    <i class="far fa-chart-bar"></i>
                    5.4k 字
                  </span>
                

                
                  
                  <span class="post-meta">
                      <i class="far fa-clock"></i>
                      19 分钟
                  </span>
                

                
                  <!-- 不蒜子统计文章PV -->
                  
                  <span id="busuanzi_container_page_pv" class="post-meta" style="display: none">
                    <i class="far fa-eye" aria-hidden="true"></i>
                    <span id="busuanzi_value_page_pv"></span> 次
                  </span>
                
              </p>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5 z-depth-3" id="board">
          <div class="post-content mx-auto" id="post">
            
              <p
                class="note note-warning">本文最后更新于：星期六, 五月 23日 2020, 7:09 晚上</p>
            
            <div class="markdown-body">
              <h2 id="Class类文件（字节码）"><a href="#Class类文件（字节码）" class="headerlink" title="Class类文件（字节码）"></a>Class类文件（字节码）</h2><p>各种不同平台的虚拟机与所有平台都统一使用的java程序存储格式—字节码（ByteCode），这是构成<strong>平台无关性</strong>的基石，也是<strong>语言无关性</strong>的基础。<strong>平台无关性</strong>是建立在操作系统上，虚拟机厂商提供了许多可以运行在各种不同平台的虚拟机，它们都可以载入和执行字节码，从而实现程序的<strong>一次编写，到处运行</strong>。</p>
<p>Java虚拟机不和包括Java在内的任何语言绑定，它只与<strong>Class文件</strong>这种特定的二进制文件格式所关联，Class文件中包含了Java虚拟机指令集和符号表以及若干其他辅助信息。</p>
<p>整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在，各个数据严格按照顺序紧凑地排列，中间没有添加任何分隔符。Class文件是一组以<strong>8位字节</strong>为基础单位的<strong>二进制流</strong>，由于它没有任何分隔符号，所以在其中存储的数据项，无论是顺序还是数量，都是被严格限定的，哪个字节代表什么含义，长度是多少，先后顺序如何，都不允许改变。</p>
<p>Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：<strong>无符号数</strong>和<strong>表</strong>。</p>
<ul>
<li>无符号数属于基本的<strong>数据类型</strong>，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来<strong>描述数字</strong>、<strong>索引引用</strong>、<strong>数量值</strong>或者按照UTF-8编码构成<strong>字符串值</strong>。</li>
<li>表是由<strong>多个无符号数</strong>或者<strong>其他表</strong>作为数据项构成的<strong>复合数据类型</strong>，所有表都习惯性地以<strong>_info</strong>结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表。</li>
</ul>
<p>Class文件中存储的数据按顺序包括：</p>
<ol>
<li><p><strong>魔数与Class文件的版本</strong></p>
<p>每个Class文件的<strong>头4个字节</strong>称为魔数（Magic Number），它的唯一作用是确定这个文件是否为一个能<strong>被虚拟机接受的Class文件</strong>。使用魔数而不是扩展名来进行识别主要是基于安全方面的考虑，因为文件扩展名可以随意地改动。文件格式的制定者可以自由地选择魔数值，只要这个魔数值还没有被广泛采用过同时又不会引起混淆即可。紧接着魔数的4个字节存储的是<strong>Class文件的版本号</strong>：第5和第6个字节是次版本号（MinorVersion），第7和第8个字节是主版本号（Major Version）。Java的版本号是从45开始的，JDK 1.1之后的每个JDK大版本发布主版本号向上加1高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件，即使文件格式并未发生任何变化，虚拟机也必须拒绝执行超过其版本号的Class文件。</p>
</li>
<li><p><strong>常量池</strong></p>
<p>常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项u2类型的数据，代表常量池容量计数值（constant_pool_count）。与Java中语言习惯不一样的是，这个容量计数是从1而不是0开始的。常量池中主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）。</p>
<ul>
<li><p>字面量比较接近于Java语言层面的常量概念，如文本字符串、声明为final的常量值等；</p>
</li>
<li><p>符号引用则属于编译原理方面的概念，包括了<strong>类和接口的全限定名（Fully Qualified Name）</strong>、<strong>字段的名称和描述符（Descriptor）、方法的名称和描述符</strong>；</p>
</li>
</ul>
</li>
<li><p><strong>访问标志</strong></p>
<p>用于<strong>识别一些类或者接口层次的访问信息</strong>，包括这个Class是类还是接口、是否定义为public类型、是否定义为abstract类型；如果是类的话，是否被声明为final等。</p>
</li>
<li><p><strong>类索引、父类索引与接口索引集合</strong></p>
<p>这三项数据来确定这个类的<strong>继承关系</strong>。<strong>类索引</strong>用于确定这个<strong>类的全限定名</strong>，<strong>父类索引</strong>用于确定这个<strong>类的父类的全限定名</strong>。由于Java语言不允许多重继承，所以父类索引只有一个，除了java.lang.Object之外，所有的Java类都有父类，因此除了java.lang.Object外，所有Java类的父类索引都不为0。<strong>接口索引集合</strong>就用来描述这个<strong>类实现了哪些接口</strong>，这些被实现的接口将按implements语句（如果这个类本身是一个接口，则应当是extends语句）后的接口顺序从左到右排列在接口索引集合中。</p>
</li>
<li><p><strong>字段表集合</strong></p>
<p>描述<strong>接口或者类中声明的变量</strong>。字段（field）包括类级变量以及实例级变量。而字段叫什么名字、字段被定义为什么数据类型，这些都是无法固定的，只能引用常量池中的常量来描述。</p>
<p>字段表集合中不会列出从超类或者父接口中继承而来的字段，但有可能列出原本Java代码之中不存在的字段，譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。</p>
</li>
<li><p><strong>方法表集合</strong></p>
<p>描述了<strong>方法的定义</strong>，但是方法里的Java代码，经过编译器编译成字节码指令后，存放在属性表集合中的方法属性表集合中一个名为<strong>Code</strong>的属性里面。</p>
<p>与字段表集合相似，如果父类方法在子类中没有被重写（Override），方法表集合中就不会出现来自父类的方法信息。但同样的，有可能会出现由编译器自动添加的方法，最典型的便是类构造器<strong>＜clinit＞</strong>方法和实例构造器<strong>＜init＞</strong></p>
</li>
<li><p><strong>属性表集合</strong></p>
<p>存储Class文件、字段表、方法表都自己的属性表集合，以用于描述某些场景专有的信息。如方法的代码就存储在Code属性表中。</p>
</li>
</ol>
<h2 id="栈帧详解"><a href="#栈帧详解" class="headerlink" title="栈帧详解"></a>栈帧详解</h2><p>当前栈帧：一个线程的方法调用链可能会很长，这意味着虚拟机栈会被压入很多栈帧，但在线程执行的某个时间点只有位于栈顶的栈帧才是有效的，该栈帧称为<strong>当前栈帧</strong>，与这个栈帧相关联的方法称为<strong>当前方法</strong>。</p>
<img src="/.top//03/12/JVM%E6%89%A7%E8%A1%8C%E5%AD%90%E7%A8%8B%E5%BA%8F/pic1.png" srcset="/img/loading.gif" class>

<ul>
<li><p><strong>局部变量表</strong></p>
<p>局部变量表的容量以<strong>变量槽（Variable Slot，下称 Slot）</strong>为最小单位，虚拟机规范中导向性地说到每个 <strong>Slot</strong> 都应该能存放一个 boolean、byte、char、short、int、float、double、long 8 种数据类型和reference ，可以使用 32 位或更小的物理内存来存放。</p>
<p>对于 64 位的数据类型，虚拟机会以高位对齐的方式为其分配两个连续的Slot空间。Java 语言中明确的（reference 类型则可能是 32 位也可能是 64 位）64 位的数据类型只有 long 和 double 两种。</p>
</li>
<li><p><strong>操作数栈</strong></p>
<p>操作数栈（Operand Stack）也常称为操作栈，它是一个先进后出（First In Last Out,FILO）栈。 同局部变量表一样， 操作数栈的每一个元素可以是任意的Java数据类型，包括long和double。 32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2。 </p>
<p>当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈/入栈操作。 例如，在做算术运算的时候是通过操作数栈来进行的，又或者在”调用其他方法的时候是通过操作数栈来进行参数传递的”。</p>
<p>java虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中所指的“栈”就是操作数栈。</p>
</li>
<li><p><strong>数据重叠优化</strong></p>
<p>虚拟机概念模型中每二个栈帧都是相互独立的，但在实际应用是我们知道一个方法调用另一个方法时，往往存在参数传递，这种做法在虚拟机实现过程中会做一些优化，具体做法如下：令两个栈帧出现一部分重叠。让下面栈帧的一部分操作数栈与上面栈帧的部分局部变量表重叠在一起，进行方法调用时就可以共用一部分数据，无须进行额外的参数复制传递。</p>
<img src="/.top//03/12/JVM%E6%89%A7%E8%A1%8C%E5%AD%90%E7%A8%8B%E5%BA%8F/pic2.png" srcset="/img/loading.gif" class>
</li>
<li><p><strong>动态连接</strong></p>
<p>栈帧执行方法是哪个方法，栈帧中会持有一个<strong>符号引用</strong>，该引用指向某个具体方法。</p>
<p><strong>符号引用</strong>是一个<strong>地址位置</strong>的代号，在编译的时候我们是不知道某个方法在运行的时候是放到哪里的，这时我用代号<code>com/enjoy/pojo/User.Say:()V</code>指代某个类的方法，将来可以把符号引用转换成直接引用进行真实的调用。</p>
<p>用符号引用转化成直接引用的解析时机，把解析分为两大类 </p>
<ul>
<li><p><strong>静态解析</strong>：符号引用在类加载阶段或者第一次使用的时候就直接转换成直接引用。</p>
</li>
<li><p><strong>动态连接</strong>：符号引用在每次运行期间转换为直接引用，即每次运行都重新转换。</p>
</li>
</ul>
</li>
<li><p><strong>方法返回地址</strong></p>
<p>方法退出方式有：正常退出与异常退出</p>
<p>理论上，执行完当前栈帧的方法，需要返回到当前方法被调用的位置，所以栈帧需要记录一些信息，用来恢复上层方法的执行状态。正常退出：上层方法的PC计数器可以做为当前方法的返回地址，被保存在当前栈帧中。异常退出时：通过异常处理器表来确定返回地址。</p>
<p>方法退出时会做的操作：恢复上次方法的局部变量表、操作数栈，把当前方法的返回值，压入调用者栈帧的操作数栈中，使用当前栈帧保存的返回地址调整PC计数器的值，当前栈帧出栈，随后，执行PC计数器指向的指令。</p>
</li>
<li><p><strong>附加信息</strong></p>
<p>虚拟机规范允许实现虚拟机时增加一些额外信息，例如与调试相关的信息。</p>
<p>一般把动态连接、方法返回地址、其他额外信息归成一类，称为栈帧信息。</p>
</li>
</ul>
<h2 id="字节码执行引擎"><a href="#字节码执行引擎" class="headerlink" title="字节码执行引擎"></a>字节码执行引擎</h2><p>Java编译器输出的指令流基本上是一种<strong>基于栈的指令集</strong>架构，指令流中的指令大部分都是零地址指令，它们依赖<strong>操作数栈</strong>进行工作。</p>
<p>基于寄存器的指令集，最典型的就是x86的二地址指令集，说得通俗一些，就是现在我们主流PC机中直接支持的指令集架构，这些指令依赖寄存器进行工作。</p>
<p>举个最简单的例子，分别使用这两种指令集计算“1+1”的结果，基于栈的指令集会是这样子的：</p>
<pre><code>iconst_1
iconst_1
iadd
istore_0</code></pre><p>两条iconst_1指令连续把两个常量1压入栈后，iadd指令把栈顶的两个值出栈、相加，然后把结果放回栈顶，最后istore_0把栈顶的值放到局部变量表的第0个Slot中。</p>
<p>如果基于寄存器，那程序可能会是这个样子：</p>
<pre><code>mov eax，1
add eax，1</code></pre><p>mov指令把EAX寄存器的值设为1，然后add指令再把这个值加1，结果就保存在EAX寄存器里面。</p>
<p>基于栈的指令集主要的优点就是<strong>可移植</strong>，寄存器由硬件直接提供，程序直接依赖这些硬件寄存器则不可避免地要受到硬件的约束。栈架构指令集的主要缺点是执行速度相对来说会稍慢一些。所有主流物理机的指令集都是寄存器架构也从侧面印证了这一点。</p>
<h2 id="字节码指令"><a href="#字节码指令" class="headerlink" title="字节码指令"></a>字节码指令</h2><p>Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（称为操作码，Opcode）以及跟随其后的零至多个代表此操作所需参数（称为操作数，Operands）而构成。</p>
<p>由于限制了Java虚拟机操作码的长度为一个字节（即0～255），这意味着指令集的操作码总数不可能超过256条。</p>
<p>大多数的指令都包含了其操作所对应的数据类型信息。例如：</p>
<p>iload指令用于从局部变量表中加载int型的数据到操作数栈中，而fload指令加载的则是float类型的数据。</p>
<p>大部分的指令都没有支持整数类型byte、char和short，甚至没有任何指令支持boolean类型。大多数对于boolean、byte、short和char类型数据的操作，实际上都是使用相应的int类型作为运算类型</p>
<p>常见指令一般有：</p>
<ul>
<li><p><strong>加载和存储指令</strong></p>
<p>用于将数据在栈帧中的局部变量表和操作数栈之间来回传输，这类指令包括如下内容。</p>
<p>将一个局部变量加载到操作栈：iload、iload_＜n＞、lload、lload_＜n＞、fload、fload_＜n＞、dload、dload_＜n＞、aload、aload_＜n＞。</p>
<p>将一个数值从操作数栈存储到局部变量表：istore、istore_＜n＞、lstore、lstore_＜n＞、fstore、fstore_＜n＞、dstore、dstore_＜n＞、astore、astore_＜n＞。_</p>
<p>将一个常量加载到操作数栈：bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconst_m1、iconst_＜i＞、lconst_＜l＞、fconst_＜f＞、dconst_＜d＞。</p>
<p>扩充局部变量表的访问索引的指令：wide。</p>
</li>
<li><p><strong>运算或算术指令</strong></p>
<p>用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。</p>
<p>加法指令：iadd、ladd、fadd、dadd。</p>
<p>减法指令：isub、lsub、fsub、dsub。</p>
<p>乘法指令：imul、lmul、fmul、dmul等等</p>
</li>
<li><p><strong>类型转换指令</strong></p>
<p>可以将两种不同的数值类型进行相互转换，</p>
<p>Java虚拟机直接支持以下数值类型的宽化类型转换（即小范围类型向大范围类型的安全转换）：</p>
<ul>
<li>int类型到long、float或者double类型。</li>
<li>long类型到float、double类型。</li>
<li>float类型到double类型。</li>
</ul>
<p>处理窄化类型转换（Narrowing Numeric Conversions）时，必须显式地使用转换指令来完成，这些转换指令包括：i2b、i2c、i2s、l2i、f2i、f2l、d2i、d2l和d2f。</p>
</li>
<li><p><strong>创建类实例的指令</strong></p>
<p>new</p>
</li>
<li><p><strong>创建数组的指令</strong></p>
<p>newarray、anewarray、multianewarray。</p>
</li>
<li><p><strong>访问字段指令</strong></p>
<p>getfield、putfield、getstatic、putstatic。</p>
</li>
<li><p><strong>数组存取相关指令</strong></p>
<p>把一个数组元素加载到操作数栈的指令：baload、caload、saload、iaload、laload、faload、daload、aaload。</p>
<p>将一个操作数栈的值存储到数组元素中的指令：bastore、castore、sastore、iastore、fastore、dastore、aastore。</p>
</li>
<li><p><strong>取数组长度的指令</strong></p>
<p>arraylength</p>
</li>
<li><p><strong>检查类实例类型的指令</strong></p>
<p>instanceof、checkcast。</p>
</li>
<li><p><strong>操作数栈管理指令</strong></p>
<p>如同操作一个普通数据结构中的堆栈那样，Java虚拟机提供了一些用于直接操作操作数栈的指令，包括：将操作数栈的栈顶一个或两个元素出栈：pop、pop2。</p>
<p>复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：dup、dup2、dup_x1、dup2_x1、dup_x2、dup2_x2。</p>
<p>将栈最顶端的两个数值互换：swap。</p>
</li>
<li><p><strong>控制转移指令</strong></p>
<p>控制转移指令可以让Java虚拟机有条件或无条件地从指定的位置指令而不是控制转移指令的下一条指令继续执行程序，从概念模型上理解，可以认为控制转移指令就是在有条件或无条件地修改PC寄存器的值。控制转移指令如下。</p>
<ul>
<li>条件分支：ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull、if_icmpeq、if_icmpne、if_icmplt、if_icmpgt、if_icmple、if_icmpge、if_acmpeq和if_acmpne。</li>
<li>复合条件分支：tableswitch、lookupswitch。</li>
<li>无条件分支：goto、goto_w、jsr、jsr_w、ret。</li>
</ul>
</li>
<li><p><strong>方法调用指令</strong></p>
<p>invokevirtual指令用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），这也是Java语言中最常见的方法分派方式。</p>
<p>invokeinterface指令用于调用接口方法，它会在运行时搜索一个实现了这个接口方法的对象，找出适合的方法进行调用。</p>
<p>invokespecial指令用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法。</p>
<p>invokestatic指令用于调用类方法（static方法）。</p>
<p>invokedynamic指令用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法，前面4条调用指令的分派逻辑都固化在Java虚拟机内部，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。</p>
<p>方法调用指令与数据类型无关。</p>
</li>
<li><p><strong>方法返回指令</strong></p>
<p>是根据返回值的类型区分的，包括ireturn（当返回值是boolean、byte、char、short和int类型时使用）、lreturn、freturn、dreturn和areturn，另外还有一条return指令供声明为void的方法、实例初始化方法以及类和接口的类初始化方法使用。</p>
</li>
<li><p><strong>异常处理指令</strong></p>
<p>在Java程序中显式抛出异常的操作（throw语句）都由athrow指令来实现</p>
</li>
<li><p><strong>同步指令</strong></p>
<p>有monitorenter和monitorexit两条指令来支持synchronized关键字的语义</p>
</li>
</ul>
<h2 id="方法调用详解"><a href="#方法调用详解" class="headerlink" title="方法调用详解"></a>方法调用详解</h2><p>在Java语言中符合<strong>编译期可知，运行期不可变</strong>这个要求的方法，主要包括静态方法和私有方法两大类，前者与类型直接关联，后者在外部不可被访问，这两种方法各自的特点决定了它们都不可能通过继承或别的方式重写其他版本，因此它们都适合在类加载阶段进行解析。</p>
<h3 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h3><pre><code>public class StaticDispatch{
    static abstract class Human{}
    static class Man extends Human{    }
    static class Woman extends Human{}

    public void sayHello(Human guy){
        System.out.println(&quot;hello,guy！&quot;);
    }
    public void sayHello(Man guy){
        System.out.println(&quot;hello,gentleman！&quot;);
    }
    public void sayHello(Woman guy){
        System.out.println(&quot;hello,lady！&quot;);
    }
    public static void main(String[]args){
        Human h1 = new Man();
        Human h2 = new Woman();
        StaticDispatch sr = new StaticDispatch();
        sr.sayHello(h1);
        sr.sayHello(h2);

        //实际类型变化
        Human man=new Man();
        //静态类型变化
        sr.sayHello((Man)man);
        man=new Woman();
        sr.sayHello((Woman)man);
    }
}</code></pre><p>输出结果</p>
<pre><code>hello,guy
hello,guy</code></pre><p>“Human”称为变量的静态类型（Static Type），或者叫做的外观类型（Apparent Type），后面的“Man”则称为变量的实际类型（Actual Type），静态类型和实际类型在程序中都可以发生一些变化，区别是静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且变量本身的静态类型是在编译期可知的；而实际类型变化的结果在运行期才可确定，编译器在编译程序的时候并不知道一个对象的实际类型是什么。</p>
<p>代码中定义了两个静态类型相同但实际类型不同的变量，但虚拟机（准确地说是编译器）在重载时是通过参数的静态类型而不是实际类型作为判定依据的。并且静态类型是编译期可知的，因此，在编译阶段，Javac编译器会根据参数的静态类型决定使用哪个重载版本，所以选择了sayHello（Human）作为调用目标。所有依赖静态类型来定位方法执行版本的分派动作称为静态分派。静态分派的典型应用是方法重载。静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行的。</p>
<h3 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h3><pre><code>public class DynamicDispatch {
    static abstract class Human{
        protected abstract void sayHello();
    }
    static class Man extends Human{
        @Override
        protected void sayHello() {
            System.out.println(&quot;hello,gentleman！&quot;);
        }
    }
    static class Woman extends Human{
        @Override
        protected void sayHello() {
            System.out.println(&quot;hello,lady！&quot;);
        }
    }
    public static void main(String[]args){
        Human h1 = new Man();
        Human h2 = new Woman();
        h1.sayHello();
        h2.sayHello();

        h1 = new Woman();
        h1.sayHello();
    }
}</code></pre><p>输出结果</p>
<pre><code>hello,gentleman！
hello,lady！
hello,lady！</code></pre><p>上述代码的静态类型同样都是Human的两个变量h1和h2，但在调用sayHello()方法时执行了不同的行为，并且变量好在两次调用中执行了不同的方法。导致这个现象的原因很明显，是这两个变量的实际类型不同。</p>
<img src="/.top//03/12/JVM%E6%89%A7%E8%A1%8C%E5%AD%90%E7%A8%8B%E5%BA%8F/pic3.png" srcset="/img/loading.gif" class>

<p>动态分派最常用的实现手段就是为类在方法区中建立一个虚方法表。虚方法表中存放着各个方法的实际入口地址。如果某个方法在子类中没有被重写，那子类的虚方法表里面的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。如果子类中重写了这个方法，子类方法表中的地址将会替换为指向子类实现版本的入口地址。图中，Son重写了来自Father的全部方法，因此Son的方法表没有指向Father类型数据的箭头。但是Son和Father都没有重写来自Object的方法，所以它们的方法表中所有从Object继承来的方法都指向了Object的数据类型。</p>

            </div>
            <hr>
            <div>
              <p>
                
                  <span>
                <i class="iconfont icon-inbox"></i>
                    
                      <a class="hover-with-bg" href="/categories/JVM/">JVM</a>
                      &nbsp;
                    
                  </span>&nbsp;&nbsp;
                
                
                  <span>
                <i class="iconfont icon-tag"></i>
                    
                      <a class="hover-with-bg" href="/tags/JVM/">JVM</a>
                    
                      <a class="hover-with-bg" href="/tags/Java/">Java</a>
                    
                  </span>
                
              </p>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2020/03/21/JVM%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">
                        <i class="fa fa-chevron-left"></i>
                        <span class="hidden-mobile">JVM性能优化</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/03/12/JVM%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD/">
                        <span class="hidden-mobile">JVM的类加载</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="fa fa-chevron-right"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

              
                <!-- Comments -->
                <div class="comments" id="comments">
                  
                  

                </div>
              
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc-start"></div>
<div id="toc">
  <p class="h5"><i class="far fa-list-alt"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a class="z-depth-1" id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"> <b>Fluid</b></a>
    </div>
    
  <div>
    
      <!-- 不蒜子统计PV -->
      
      <span id="busuanzi_container_site_pv" style="display: none">
      总访问量 <span id="busuanzi_value_site_pv"></span> 次
    </span>
    
    
      <!-- 不蒜子统计UV -->
      
      <span id="busuanzi_container_site_uv" style="display: none">
      总访客数 <span id="busuanzi_value_site_uv"></span> 人
    </span>
    
  </div>


    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/popper.js/1.16.1/umd/popper.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="https://cdn.staticfile.org/mdbootstrap/4.13.0/js/mdb.min.js" ></script>
<script  src="/js/main.js" ></script>


  <script  src="/js/lazyload.js" ></script>



  
  <script  src="https://cdn.staticfile.org/tocbot/4.10.0/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var navHeight = $('#navbar').height();
      var toc = $('#toc');
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;
      var tocLimMax = 2 * boardTop + boardCtn.height();

      $(window).scroll(function () {
        var tocLimMin = $('#toc-start').offset().top - navHeight;
        var scroH = document.body.scrollTop + document.documentElement.scrollTop;

        if (tocLimMin <= scroH && scroH <= tocLimMax) {
          toc.css({
            'display': 'block',
            'position': 'fixed',
            'top': navHeight,
          });
        } else if (scroH <= tocLimMin) {
          toc.css({
            'position': '',
            'top': '',
          });
        } else if (scroH > tocLimMax) {
          toc.css('display', 'none');
        }
      });
      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '.post-content',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc > p').css('visibility', 'visible');
      }
      var offset = boardCtn.css('margin-right')
      $('#toc-ctn').css({
        'right': offset
      })
    });
  </script>





  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>



  <script defer src="https://cdn.staticfile.org/smoothscroll/1.4.10/SmoothScroll.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




<!-- Plugins -->


  

  

  

  

  

  



  <script  src="https://cdn.staticfile.org/prettify/188.0.0/prettify.min.js" ></script>
  <script>
    $(document).ready(function () {
      $('pre').addClass('prettyprint  linenums');
      prettyPrint();
    })
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "JVM执行子程序&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script defer src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <script>
    $("#post img:not(.no-zoom img, img[no-zoom])").each(
      function () {
        var element = document.createElement("a");
        $(element).attr("data-fancybox", "images");
        $(element).attr("href", $(this).attr("src"));
        $(this).wrap(element);
      }
    );
  </script>





  
  
    <script type="text/javascript">
      //定义获取词语下标
      var a_idx = 0;
      jQuery(document).ready(function ($) {
        //点击body时触发事件
        $("body").click(function (e) {
          //需要显示的词语
          var a = new Array("富强", "民主", "文明", "和谐", "自由", "平等", "公正", "法治", "爱国", "敬业", "诚信", "友善");
          //设置词语给span标签
          var $i = $("<span/>").text(a[a_idx]);
          //下标等于原来下标+1  余 词语总数
          a_idx = (a_idx + 1) % a.length;
          //获取鼠标指针的位置，分别相对于文档的左和右边缘。
          //获取x和y的指针坐标
          var x = e.pageX, y = e.pageY;
          //在鼠标的指针的位置给$i定义的span标签添加css样式
          $i.css({
            "z-index": 999,
            "top": y - 20,
            "left": x,
            "position": "absolute",
            "font-weight": "bold",
            "color": rand_color()
          });
          // 随机颜色
          function rand_color() {
            return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"
          }
          //在body添加这个标签
          $("body").append($i);
          //animate() 方法执行 CSS 属性集的自定义动画。
          //该方法通过CSS样式将元素从一个状态改变为另一个状态。CSS属性值是逐渐改变的，这样就可以创建动画效果。
          //详情请看http://www.w3school.com.cn/jquery/effect_animate.asp
          $i.animate({
            //将原来的位置向上移动180
            "top": y - 180,
            "opacity": 0
            //1500动画的速度
          }, 1500, function () {
            //时间到了自动删除
            $i.remove();
          });
        });
      })
      ;
    </script>
  








</body>
</html>
