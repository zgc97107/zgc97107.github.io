<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="description" content="">
  <meta name="author" content="">
  <meta name="keywords" content="">
  <title>线程的并发工具类 ~ zgcheng&#39;s blog</title>

  <link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"  >
<link rel="stylesheet" href="/lib/bootstrap/css/bootstrap.min.css"  >
<link rel="stylesheet" href="/lib/mdbootstrap/css/mdb.min.css"  >
<link rel="stylesheet" href="/lib/github-markdown/github-markdown.min.css"  >

<link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">



  <link rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css"  >

<link rel="stylesheet" href="/css/main.css"  >


  <link rel="stylesheet" href="/lib/fancybox/jquery.fancybox.min.css"  >


<meta name="generator" content="Hexo 4.1.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>zgcheng&#39;s blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">归档</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/">分类</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">标签</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">关于</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>


</nav>

    <div class="view intro-2" id="background"
         style="background: url('/img/default.png')no-repeat center center;
           background-size: cover;
           background-attachment: fixed;">
      <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              <br>
              
                <p class="mt-3">
                  <i class="fas fa-calendar-alt" aria-hidden="true"></i>&nbsp;
                  星期五, 十二月 20日 2019, 4:04 下午
                </p>
              

              <p>
                
                  
                  &nbsp;<i class="far fa-chart-bar"></i>
                  <span class="post-count">
                    4.9k 字
                  </span>&nbsp;
                

                
                  
                  &nbsp;<i class="far fa-clock"></i>
                  <span class="post-count">
                      20 分钟
                  </span>&nbsp;
                

                
                  <!-- 不蒜子统计文章PV -->
                  
                  &nbsp;<i class="far fa-eye" aria-hidden="true"></i>&nbsp;
                  <span id="busuanzi_container_page_pv">
                    <span id="busuanzi_value_page_pv"></span> 次
                  </span>&nbsp;
                
              </p>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="py-5 z-depth-3" id="board">
        <div class="post-content mx-auto" id="post">
          <div class="markdown-body">
            <h1 id="Fork-Join"><a href="#Fork-Join" class="headerlink" title="Fork-Join"></a>Fork-Join</h1><p>forkjoin体现了分而治之的策略，java下多线程的开发可以我们自己启用多线程，线程池，还可以使用forkjoin，forkjoin可以让我们不去了解诸如Thread，Runnable等相关的知识，只要遵循forkjoin的开发模式，就可以写出很好的多线程并发程序。</p>
<h3 id="分而治之"><a href="#分而治之" class="headerlink" title="分而治之"></a>分而治之</h3><p>分治策略是：对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同（子问题相互之间有联系就会变为动态规范算法），递归地解这些子问题，然后将各子问题的解合并得到原问题的解，这种算法设计策略叫做分治法。</p>
<p>归并排序，快速排序，二分查找及大数据中M/R都体现了分而治之的策略。</p>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>若将两个有序表合并成一个有序表，称为2-路归并，与之对应的还有多路归并。</p>
<p>对于给定的一组数据，利用递归与分治技术将数据序列划分成为越来越小的半子表，在对半子表排序后，再用递归方法将排好序的半子表合并成为越来越大的有序序列。</p>
<p>为了提升性能，有时我们在半子表的个数小于某个数（比如15）的情况下，对半子表的排序采用其他排序算法，比如插入排序。</p>
<h3 id="归并排序（降序）示例"><a href="#归并排序（降序）示例" class="headerlink" title="归并排序（降序）示例"></a>归并排序（降序）示例</h3><img src="/2019/12/20/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/pic1.png" srcset="/img/loading.gif" class="">

<p>先讲数组划分为左右两个子表：</p>
<img src="/2019/12/20/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/pic2.png" srcset="/img/loading.gif" class=""> <img src="/2019/12/20/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/pic3.png" srcset="/img/loading.gif" class="">

<p>然后继续左右两个子表拆分：</p>
<img src="/2019/12/20/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/pic4.png" srcset="/img/loading.gif" class="">

<p>对最后的拆分的子表，两两进行排序</p>
<img src="/2019/12/20/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/pic5.png" srcset="/img/loading.gif" class="">

<p>对有序的子表进行排序和比较合并</p>
<img src="/2019/12/20/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/pic6.png" srcset="/img/loading.gif" class="">

<p>对合并后的子表继续比较合并</p>
<img src="/2019/12/20/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/pic7.png" srcset="/img/loading.gif" class="">

<h2 id="Fork-Join原理"><a href="#Fork-Join原理" class="headerlink" title="Fork-Join原理"></a>Fork-Join原理</h2><p>Fork/Join框架：就是在必要的情况下，讲一个大任务，进行拆分（fork）成若干个小任务（拆到不可在拆时），再将一个个小任务进行join汇总。</p>
<img src="/2019/12/20/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/pic8.png" srcset="/img/loading.gif" class="">

<h3 id="工作密取"><a href="#工作密取" class="headerlink" title="工作密取"></a>工作密取</h3><p>即当前线程的Task已经全被执行完毕，则自动取到其他线程的Task池中取出Task继续执行。</p>
<p>ForkJoinPool中维护着多个线程（一般为CPU核数）在不断地执行Task，每个线程除了执行自己职务内的Task之外，还会根据自己工作线程的闲置情况去获取其他繁忙的工作线程的Task，如此一来就能能够减少线程阻塞或是闲置的时间，提高CPU利用率。</p>
<img src="/2019/12/20/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/pic9.png" srcset="/img/loading.gif" class="">

<h2 id="Fork-Join实战"><a href="#Fork-Join实战" class="headerlink" title="Fork-Join实战"></a>Fork-Join实战</h2><h3 id="Fork-Join使用的标准范式"><a href="#Fork-Join使用的标准范式" class="headerlink" title="Fork/Join使用的标准范式"></a>Fork/Join使用的标准范式</h3><img src="/2019/12/20/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/pic10.png" srcset="/img/loading.gif" class="">

<p>要使用ForkJoin框架，必须首先创建一个ForkJoin任务，创建方式为继承ForkJoin的子类：RecursiveAction或RecursiveTask，然后实现其中的compute方法。ForkJoin框架将compute()中的逻辑来进行fork或join操作。</p>
<ol>
<li><p><strong>RecursiveAction：</strong>没有返回结果的任务</p>
</li>
<li><p><strong>RecursiveTask：</strong>有返回值的任务</p>
</li>
</ol>
<p>在compute方法里，首先需要判断任务是否足够小，如果足够小就直接执行任务。如果不足够小，就必须分割成两个并创建子任务，然后调用invokeAll()方法将创建的子任务提交，如果子任务有返回值，则调用join()方法获取子任务的执行结果之后需要将执行结果合并并返回，提交之后的子任务会再次进入compute，判断子任务是否需要继续拆分，如果不需要继续分割，则执行当前子任务并返回结果。</p>
<p> 继承之后的子类要提交到ForkJoinPool中执行，可以使用invoke()，submit()，execture()提交，区别是：invoke()是同步执行，调用之后当前线程阻塞，等待任务完成；submit()和execture()是异步执行不会阻塞当前线程，submit()可以返回结果值，execute()不会返回结果值。之后可以通过join()或get()方法获取执行结果，如果是异步执行，join()和get()方法会阻塞当前线程直到所有任务执行完毕。</p>
<h3 id="实现数组排序"><a href="#实现数组排序" class="headerlink" title="实现数组排序"></a>实现数组排序</h3><pre><code>public class MergeSort {

    //数组长度
    public static final int ARRAY_LENGTH  = 40000000;
    public final static int THRESHOLD = 47;

    public static int[] makeArray() {

        //new一个随机数发生器
        Random r = new Random();
        int[] result = new int[ARRAY_LENGTH];
        for(int i=0;i&lt;ARRAY_LENGTH;i++){
            //用随机数填充数组
            result[i] =  r.nextInt(ARRAY_LENGTH*3);
        }
        return result;

    }

    /**
     * 归并排序——将两段排序好的数组结合成一个排序数组
     *
     * @param left
     * @param right
     * @return
     */
    public static int[] merge(int[] left, int[] right) {
        int[] result = new int[left.length + right.length];
        for (int index = 0, i = 0, j = 0; index &lt; result.length; index++) {
            if (i &gt;= left.length)/*左边数组已经取完，完全取右边数组的值即可*/
                result[index] = right[j++];
            else if (j &gt;= right.length)/*右边数组已经取完，完全取左边数组的值即可*/
                result[index] = left[i++];
            else if (left[i] &gt; right[j])/*左边数组的元素值大于右边数组，取右边数组的值*/
                result[index] = right[j++];
            else/*右边数组的元素值大于左边数组，取左边数组的值*/
                result[index] = left[i++];
        }

        return result;
    }

     /**
     * 插入排序
     *
     * @param array
     * @return
     */
    public static int[] sort(int[] array) {
        if (array.length == 0)
            return array;
        int currentValue;/*当前待排序数据，该元素之前的元素均已被排序过*/
        for (int i = 0; i &lt; array.length - 1; i++) {
            int preIndex = i;/*已被排序数据的索引*/
            currentValue = array[preIndex + 1];

            /*在已被排序过数据中倒序寻找合适的位置，如果当前待排序数据比比较的元素要小，
            将比较的元素元素后移一位*/
            while (preIndex &gt;= 0 &amp;&amp; currentValue &lt; array[preIndex]) {
                //将当前元素后移一位
                array[preIndex + 1] = array[preIndex];
                preIndex--;
            }
            /*while循环结束时，说明已经找到了当前待排序数据的合适位置，插入*/
            array[preIndex + 1] = currentValue;
        }
        return array;
    }

    public static void main(String[] args) {
        System.out.println(&quot;============================================&quot;);
        long start = System.currentTimeMillis();
        ForkJoinPool forkJoinPool = new ForkJoinPool();
        MergeSortTask sortTask = new MergeSortTask(MakeArray.makeArray());
        forkJoinPool.invoke(sortTask);
        //forkJoinPool.submit(sortTask);
        //int[] array = sortTask.join();
        System.out.println(&quot; spend time:&quot;+(System.currentTimeMillis()-start)+&quot;ms&quot;);
        System.out.println(&quot;============================================&quot;);
    }

    private static class MergeSortTask extends RecursiveTask&lt;int[]&gt;{
        private int[] array;

        public MergeSortTask(int[] array){
            this.array = array;
        }

        @Override
        protected int[] compute() {
            if (array.length&lt;= THRESHOLD) {
                return sort(array);
            }else{
                int mid = array.length / 2;
                int[] leftArray = Arrays.copyOfRange(array, 0, mid);
                int[] rightArray = Arrays.copyOfRange(array, mid, array.length);
                MergeSortTask leftTask = new MergeSortTask(leftArray);
                MergeSortTask rightTask = new MergeSortTask(rightArray);
                invokeAll(leftTask, rightTask);
                return merge(leftTask.join(), rightTask.join());
            }
        }
    }
}
</code></pre><h3 id="异步寻找目录下的文件"><a href="#异步寻找目录下的文件" class="headerlink" title="异步寻找目录下的文件"></a>异步寻找目录下的文件</h3><pre><code>public class FindDirsFiles extends RecursiveAction {

    private File path;

    public FindDirsFiles(File path) {
        this.path = path;
    }

    @Override
    protected void compute() {
        List&lt;FindDirsFiles&gt; subTasks = new ArrayList&lt;&gt;();

        File[] files = path.listFiles();
        if (files!=null){
            for (File file : files) {
                if (file.isDirectory()) {
                    // 对每个子目录都新建一个子任务。
                    subTasks.add(new FindDirsFiles(file));
                } else {
                    // 遇到文件，检查。
                    if (file.getAbsolutePath().endsWith(&quot;txt&quot;)){
                        System.out.println(&quot;文件:&quot; + file.getAbsolutePath());
                    }
                }
            }
            if (!subTasks.isEmpty()) {
                // 在当前的 ForkJoinPool 上调度所有的子任务。
                for (FindDirsFiles subTask : invokeAll(subTasks)) {
                    subTask.join();
                }
            }
        }
    }

    public static void main(String [] args){
        try {
            // 用一个 ForkJoinPool 实例调度总任务
            ForkJoinPool pool = new ForkJoinPool();
            FindDirsFiles task = new FindDirsFiles(new File(&quot;./&quot;));

            /*异步提交*/
            pool.execute(task);

            /*主线程做自己的业务工作*/
            System.out.println(&quot;Task is Running......&quot;);
            Thread.sleep(1);
            int otherWork = 0;
            for(int i=0;i&lt;100;i++){
                otherWork = otherWork+i;
            }
            System.out.println(&quot;Main Thread done sth......,otherWork=&quot;
                    +otherWork);
            task.join();//阻塞方法
            System.out.println(&quot;Task end&quot;);
        } catch (Exception e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }
}</code></pre><h1 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h1><p>闭锁，CountDownLatch这个类能够使一个线程或多个线程等待其他线程完成后再执行。例如，应用程序的主线程希望在负责启动框架服务的线程已经完成之后再执行。</p>
<p>CountDownLatch是通过一个计数器来实现的，计数器的初始值为初始任务的数量（也可以大于线程数即线程中可以多次执行countDown()，线程执行countDown()之后也可以继续执行）。每当完成了一个任务后，计数器的值就会减1（CountDownLatch.countDown()方法）。当计数器值到达0时，它表示所有的已经完成了任务，然后在闭锁上等待CountDownLatch.await()方法的线程就可以继续执行。</p>
<img src="/2019/12/20/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/pic11.png" srcset="/img/loading.gif" class="">

<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>实现最大的并行性：有时我们想同时启动多个线程，实现最大程度的并行性。例如，我们想测试一个单例类。如果我们创建一个初始计数为1的CountDownLatch，并让所有线程都在这个锁上等待，那么我们可以很轻松地完成测试。我们只需调用 一次countDown()方法就可以让所有的等待线程同时恢复执行。</p>
<p>开始执行前等待n个线程完成各自任务：例如应用程序启动类要确保在处理用户请求前，所有N个外部系统已经启动和运行了，例如处理excel中多个表单。</p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><pre><code>/**
 *类说明：演示CountDownLatch用法，
 * 共5个初始化子线程，6个闭锁扣除点，扣除完毕后，主线程和业务线程才能继续执行
 */
public class UseCountDownLatch {

    static CountDownLatch latch = new CountDownLatch(6);

    /*初始化线程*/
    private static class InitThread implements Runnable{

        public void run() {
            System.out.println(&quot;Thread_&quot;+Thread.currentThread().getId()
                    +&quot; ready init work......&quot;);
            latch.countDown();
            for(int i =0;i&lt;2;i++) {
                System.out.println(&quot;Thread_&quot;+Thread.currentThread().getId()
                        +&quot; ........continue do its work&quot;);
            }
        }
    }

    /*业务线程等待latch的计数器为0完成*/
    private static class BusiThread implements Runnable{

        public void run() {
            try {
                latch.await();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            for(int i =0;i&lt;3;i++) {
                System.out.println(&quot;BusiThread_&quot;+Thread.currentThread().getId()
                        +&quot; do business-----&quot;);
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        new Thread(new Runnable() {
            public void run() {
                SleepTools.ms(1);
                System.out.println(&quot;Thread_&quot;+Thread.currentThread().getId()
                        +&quot; ready init work step 1st......&quot;);
                latch.countDown();
                System.out.println(&quot;begin step 2nd.......&quot;);
                SleepTools.ms(1);
                System.out.println(&quot;Thread_&quot;+Thread.currentThread().getId()
                        +&quot; ready init work step 2nd......&quot;);
                latch.countDown();
            }
        }).start();
        new Thread(new BusiThread()).start();
        for(int i=0;i&lt;=3;i++){
            Thread thread = new Thread(new InitThread());
            thread.start();
        }

        latch.await();
        System.out.println(&quot;Main do ites work........&quot;);
    }
}</code></pre><h1 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h1><p>CyclicBarrier的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到所有线程到达屏障时，解除屏障，所有被屏障拦截的线程才会继续运行。CyclicBarrier默认的构造方法是CyclicBarrier（int parties），其参数表示屏障拦截的线程数量，每个线程调用await()方法告诉CyclicBarrier当前线程已经到达了屏障，然后这个线程被阻塞。</p>
<p>CyclicBarrier还提供一个更高级的构造函数CyclicBarrier（int parties，Runnable barrierAction），用于在线程到达屏障时，执行barrierAction，方便处理更复杂的业务场景。</p>
<p>await()方法可以执行多次，当满足条件屏障解除之后，CyclicBarrier就会被复位。</p>
<img src="/2019/12/20/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/pic12.png" srcset="/img/loading.gif" class="">

<h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><p>CyclicBarrier可以用于多线程计算数据，最后合并计算结果的场景。</p>
<h3 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h3><pre><code>/**
 * 类说明：演示CyclicBarrier用法,共4个子线程，他们全部完成工作后，交出自己结果，
 * 再被统一释放去做自己的事情，而交出的结果被另外的线程拿来拼接字符串
 */
public class UseCyclicBarrier {

    private static CyclicBarrier barrier = new CyclicBarrier(4, new CollectThread());

    //存放子线程工作结果的容器
    private static ConcurrentHashMap&lt;String, Long&gt; resultMap
            = new ConcurrentHashMap&lt;&gt;();

    public static void main(String[] args) {
        for (int i = 0; i &lt; 4; i++) {
            Thread thread = new Thread(new SubThread());
            thread.start();
        }

    }

    /*汇总的任务*/
    private static class CollectThread implements Runnable {

        @Override
        public void run() {
            StringBuilder result = new StringBuilder();
            for (Map.Entry&lt;String, Long&gt; workResult : resultMap.entrySet()) {
                result.append(&quot;[&quot; + workResult.getValue() + &quot;]&quot;);
            }
            System.out.println(&quot; the result = &quot; + result);
            System.out.println(&quot;do other business........&quot;);
        }
    }

    /*相互等待的子线程*/
    private static class SubThread implements Runnable {

        @Override
        public void run() {
            long id = Thread.currentThread().getId();
            resultMap.put(Thread.currentThread().getId() + &quot;&quot;, id);
            try {
                Thread.sleep(1000 + id);
                System.out.println(&quot;Thread_&quot; + id + &quot; ....do something &quot;);
                barrier.await();
                Thread.sleep(1000 + id);
                System.out.println(&quot;Thread_&quot; + id + &quot; ....do its business &quot;);
            } catch (Exception e) {
                e.printStackTrace();
            }

        }
    }
}</code></pre><h3 id="CountDownLatch和CyclicBarrier辨析"><a href="#CountDownLatch和CyclicBarrier辨析" class="headerlink" title="CountDownLatch和CyclicBarrier辨析"></a>CountDownLatch和CyclicBarrier辨析</h3><ul>
<li><p>CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以反复使用。</p>
</li>
<li><p>CountDownLatch.await()会阻塞当前线程，等待所有工作线程执行countDown()之后继续执行，而CyclicBarrier通过线程调用await()阻塞工作线程，直到所有工作线程达到指定屏障，所有工作线程再继续执行。</p>
</li>
<li><p>在控制多个线程同时运行上，CountDownLatch可以不限线程数量，而CyclicBarrier是固定线程数。</p>
</li>
<li><p>CyclicBarrier还可以提供一个barrierAction，用于进行到达屏障后的工作，如：合并多线程计算结果。</p>
</li>
</ul>
<h1 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h1><p>Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。应用场景Semaphore可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接。假如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程并发地读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这时我们必须控制只有10个线程同时获取数据库连接保存数据，否则会报错无法获取数据库连接。这个时候，就可以使用Semaphore来做流量控制。Semaphore的构造方法Semaphore（int permits）接受一个整型的数字，表示可用的许可证数量。Semaphore的用法也很简单，首先线程使用Semaphore的acquire()方法获取一个许可证 ，使用完之后调用release()方法归还许可证。还可以用tryAcquire()方法尝试获取许可证。</p>
<p>Semaphore还提供一些其他方法，具体如下。</p>
<ul>
<li><p><strong>int availablePermits()：</strong>返回此信号量中当前可用的许可证数。</p>
</li>
<li><p><strong>int getQueueLength()：</strong>返回正在等待获取许可证的线程数。</p>
</li>
<li><p><strong>boolean hasQueuedThreads()：</strong>是否有线程正在等待获取许可证。</p>
</li>
<li><p><strong>void reducePermits(int reduction)：</strong>减少reduction个许可证，是个protected方法。</p>
</li>
<li><p><strong>Collection getQueuedThreads()</strong>：返回所有等待获取许可证的线程集合，是个protected方法。</p>
</li>
</ul>
<img src="/2019/12/20/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/pic13.png" srcset="/img/loading.gif" class="">

<h3 id="用Semaphore实现数据库连接池"><a href="#用Semaphore实现数据库连接池" class="headerlink" title="用Semaphore实现数据库连接池"></a>用Semaphore实现数据库连接池</h3><pre><code>/**
 *类说明：演示Semaphore用法，一个数据库连接池的实现
 */
public class DBPoolSemaphore {

    private final static int POOL_SIZE = 10;
    //两个指示器，分别表示池子还有可用连接和已用连接
    private final Semaphore useful, useless;
    //存放数据库连接的容器
    private static LinkedList&lt;Connection&gt; pool = new LinkedList&lt;Connection&gt;();
    //初始化池
    static {
        for (int i = 0; i &lt; POOL_SIZE; i++) {
            pool.addLast(SqlConnectImpl.fetchConnection());
        }
    }
    public DBPoolSemaphore() {
        this.useful = new Semaphore(10);
        this.useless = new Semaphore(10);
    }

    /*归还连接*/
    public void returnConnect(Connection connection) throws InterruptedException {
        if(connection!=null) {
            System.out.println(&quot;当前有&quot;+useful.getQueueLength()+&quot;个线程等待数据库连接!!&quot;
                    +&quot;可用连接数：&quot;+useful.availablePermits());
            useless.acquire();
            synchronized (pool) {
                pool.addLast(connection);
            }
            useful.release();
        }
    }

    /*从池子拿连接*/
    public Connection takeConnect() throws InterruptedException {
        useful.acquire();
        Connection connection;
        synchronized (pool) {
            connection = pool.removeFirst();
        }
        useless.release();
        return connection;
    }

    private static DBPoolSemaphore dbPool = new DBPoolSemaphore();

    private static class BusiThread extends Thread{
        @Override
        public void run() {
            Random r = new Random();//让每个线程持有连接的时间不一样
            long start = System.currentTimeMillis();
            try {
                Connection connect = dbPool.takeConnect();
                System.out.println(&quot;Thread_&quot;+Thread.currentThread().getId()
                        +&quot;_获取数据库连接共耗时【&quot;+(System.currentTimeMillis()-start)+&quot;】ms.&quot;);
                SleepTools.ms(100+r.nextInt(100));//模拟业务操作，线程持有连接查询数据
                System.out.println(&quot;查询数据完成，归还连接！&quot;);
                dbPool.returnConnect(connect);
            } catch (InterruptedException e) {
            }
        }
    }

    public static void main(String[] args) {
        for (int i = 0; i &lt; 50; i++) {
            Thread thread = new BusiThread();
            thread.start();
        }
    }
}</code></pre><h3 id="Semaphore注意事项"><a href="#Semaphore注意事项" class="headerlink" title="Semaphore注意事项"></a>Semaphore注意事项</h3><p>当只有不使用userless控制可归还链接数，在归还链接时，Semaphore允许归还并不是通过线程池获取而是通过其他方式创建的链接，这就会导致Semaphore的数量增加。</p>
<pre><code>/**
 *类说明：演示Semaphore用法，一个数据库连接池的实现
 */
public class DBPoolNoUseless {

    private final static int POOL_SIZE = 10;
    private final Semaphore useful;
    //存放数据库连接的容器
    private static LinkedList&lt;Connection&gt; pool = new LinkedList&lt;Connection&gt;();
    //初始化池
    static {
        for (int i = 0; i &lt; POOL_SIZE; i++) {
            pool.addLast(SqlConnectImpl.fetchConnection());
        }
    }
    public DBPoolNoUseless() {
        this.useful = new Semaphore(10);
    }

    /*归还连接*/
    public void returnConnect(Connection connection) throws InterruptedException {
        if(connection!=null) {
            System.out.println(&quot;当前有&quot;+useful.getQueueLength()+&quot;个线程等待数据库连接!!&quot;
                    +&quot;可用连接数：&quot;+useful.availablePermits());
            synchronized (pool) {
                pool.addLast(connection);
            }
            useful.release();
        }
    }

    /*从池子拿连接*/
    public Connection takeConnect() throws InterruptedException {
        useful.acquire();
        Connection connection;
        synchronized (pool) {
            connection = pool.removeFirst();
        }
        return connection;
    }

    private static DBPoolNoUseless dbPoolNoUseless = new DBPoolNoUseless();

    private static class BusiThread extends Thread{
        @Override
        public void run() {
            Random r = new Random();//让每个线程持有连接的时间不一样
            long start = System.currentTimeMillis();
            try {
                System.out.println(&quot;Thread_&quot;+Thread.currentThread().getId()
                        +&quot;_获取数据库连接共耗时【&quot;+(System.currentTimeMillis()-start)+&quot;】ms.&quot;);
                SleepTools.ms(100+r.nextInt(100));//模拟业务操作，线程持有连接查询数据
                System.out.println(&quot;查询数据完成，归还连接！&quot;);
                dbPoolNoUseless.returnConnect(new SqlConnectImpl());
            } catch (InterruptedException e) {
            }
        }
    }

    public static void main(String[] args) {
        for (int i = 0; i &lt; 50; i++) {
            Thread thread = new BusiThread();
            thread.start();
        }
    }
}</code></pre><h1 id="Exchange"><a href="#Exchange" class="headerlink" title="Exchange"></a>Exchange</h1><p>Exchanger（交换者）是一个用于线程间协作的工具类。Exchanger用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。这两个线程通过exchange方法交换数据，如果第一个线程先执行exchange()方法，它会一直等待第二个线程也执行exchange()方法，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。交换过程由jdk保证线程安全。</p>
<img src="/2019/12/20/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/pic14.png" srcset="/img/loading.gif" class="">

<h3 id="用法-2"><a href="#用法-2" class="headerlink" title="用法"></a>用法</h3><pre><code>/**
 * 类说明：演示CyclicExchange用法
 */
public class UseExchange {
    private static final Exchanger&lt;Set&lt;String&gt;&gt; exchange = new Exchanger&lt;Set&lt;String&gt;&gt;();

    public static void main(String[] args) {

        new Thread(new Runnable() {
            @Override
            public void run() {
                Set&lt;String&gt; setA = new HashSet&lt;String&gt;();//存放数据的容器
                try {
                    setA.add(&quot;A&quot;);
                    setA = exchange.exchange(setA);//交换set
                    System.out.println(&quot;A:&quot; + setA);
                    /*处理交换后的数据*/
                } catch (InterruptedException e) {
                }
            }
        }).start();

        new Thread(new Runnable() {
            @Override
            public void run() {
                Set&lt;String&gt; setB = new HashSet&lt;String&gt;();//存放数据的容器
                try {
                    setB.add(&quot;B&quot;);
                    setB = exchange.exchange(setB);//交换set
                    System.out.println(&quot;B:&quot; + setB);
                    /*处理交换后的数据*/
                } catch (InterruptedException e) {
                }
            }
        }).start();

    }
}</code></pre><h1 id="Callable、Future和FutureTask"><a href="#Callable、Future和FutureTask" class="headerlink" title="Callable、Future和FutureTask"></a>Callable、Future和FutureTask</h1><p>Runnable是一个接口，在它里面只声明了一个run()方法，由于run()方法返回值为void类型，所以在执行完任务之后无法返回任何结果。</p>
<p>Callable位于java.util.concurrent包下，它也是一个接口，在它里面也只声明了一个call()方法，这是一个泛型接口，call()函数返回的类型就是传递进来的V类型。 但Callable无法直接交给Thread执行，这时就需要一个类来包装Callable使其能够被Thread类执行。</p>
<p>RunnableFuture继承了Runnable接口和Future接口所以RunnableFuture接口可以被Thread执行，FutureTask类实现了RunnableFuture接口，所以它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。</p>
<p>Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。但Future只是一个接口，所以是无法直接用来创建对象使用的，就有了上面的FutureTask。</p>
<img src="/2019/12/20/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/pic15.png" srcset="/img/loading.gif" class="">

<p>因此我们通过一个线程运行Callable，但是Thread不支持构造方法中传递Callable的实例，所以我们需要通过FutureTask把一个Callable包装成Runnable，然后再通过这个FutureTask拿到Callable运行后的返回值。</p>
<h3 id="用法-3"><a href="#用法-3" class="headerlink" title="用法"></a>用法</h3><pre><code>/**
 * 类说明：演示Future等的使用
 */
public class UseFuture {
    /*实现Callable接口，允许有返回值*/
    private static class UseCallable implements Callable&lt;Integer&gt; {
        private int sum;

        @Override
        public Integer call() throws Exception {
            System.out.println(&quot;Callable子线程开始计算！&quot;);
            for (int i = 0; i &lt; 500; i++) {
                if (Thread.currentThread().isInterrupted()) {
                    System.out.println(&quot;Callable子线程计算任务中断！&quot;);
                    return null;
                }
                sum = sum + i;
            }
            System.out.println(&quot;Callable子线程计算结束！结果为: &quot; + sum);
            return sum;
        }
    }

    public static void main(String[] args) throws InterruptedException, ExecutionException {
        UseCallable useCallable = new UseCallable();
        FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(useCallable);
        new Thread(futureTask).start();
        Random r = new Random();
        if (r.nextInt(100) &gt; 50) {
            System.out.println(&quot;result = &quot; + futureTask.get());
        } else {
            System.out.println(&quot;cancel&quot;);
            futureTask.cancel(true);
        }
    }
}</code></pre>
            <hr>
          </div>
          <br>
          <div>
            <p>
            
              <span>
                <i class="iconfont icon-inbox"></i>
                
                  <a class="hover-with-bg" href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B">并发编程</a>
                  &nbsp;
                
              </span>&nbsp;&nbsp;
            
            
              <span>
                <i class="iconfont icon-tag"></i>
                
                  <a class="hover-with-bg" href="/tags/java">java</a>
                
                  <a class="hover-with-bg" href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B">并发编程</a>
                
              </span>
            
            </p>
            
              <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
            
          </div>
        </div>
      </div>
    </div>
    <div class="d-none d-lg-block col-lg-2 toc-container">
      
  <div id="toc">
    <p class="h4"><i class="far fa-list-alt"></i>&nbsp;目录</p>
    <div id="tocbot"></div>
  </div>

    </div>
  </div>
</div>

<!-- custom -->


<!-- Comments -->
<div class="col-lg-7 mx-auto nopadding-md">
  <div class="container comments mx-auto" id="comments">
    
  </div>
</div>

    
  </main>

  
    <a class="z-depth-1" id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  <footer class="mt-5">
  <div class="text-center py-3">
    <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a>
    <i class="iconfont icon-love"></i>
    <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"> <b>Fluid</b></a>
    <br>

    
  
    <!-- 不蒜子统计PV -->
    
    &nbsp;<span id="busuanzi_container_site_pv">总访问量 
          <span id="busuanzi_value_site_pv"></span> 次</span>&nbsp;
  
  
    <!-- 不蒜子统计UV -->
    
    &nbsp;<span id="busuanzi_container_site_uv">总访客数 
            <span id="busuanzi_value_site_uv"></span> 人</span>&nbsp;
  
  <br>



    

  </div>
</footer>

<!-- SCRIPTS -->
<script src="/lib/jquery/jquery.min.js" ></script>
<script src="/lib/popper/popper.min.js" ></script>
<script src="/lib/bootstrap/js/bootstrap.min.js" ></script>
<script src="/lib/mdbootstrap/js/mdb.min.js" ></script>
<script src="/js/main.js" ></script>


  <script src="/js/lazyload.js" ></script>



  
    <script src="/lib/tocbot/tocbot.min.js" ></script>
  
  <script src="/js/post.js" ></script>



  <script src="/lib/smooth-scroll/smooth-scroll.min.js" ></script>



  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>


<!-- Plugins -->


  

  

  

  

  




  <script src="/lib/prettify/prettify.min.js" ></script>
  <script>
    $(document).ready(function () {
      $('pre').addClass('prettyprint  linenums');
      prettyPrint();
    })
  </script>



  <script src="/lib/typed/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "线程的并发工具类&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script src="/lib/anchor/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "false",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script src="/lib/fancybox/jquery.fancybox.min.js" ></script>
  <script>
    $("#post img:not(.no-zoom img, img[no-zoom])").each(
      function () {
        var element = document.createElement("a");
        $(element).attr("data-fancybox", "images");
        $(element).attr("href", $(this).attr("src"));
        $(this).wrap(element);
      }
    );
  </script>







</body>
</html>
